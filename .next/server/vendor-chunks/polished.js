"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/polished";
exports.ids = ["vendor-chunks/polished"];
exports.modules = {

/***/ "(ssr)/./node_modules/polished/dist/polished.esm.js":
/*!****************************************************!*\
  !*** ./node_modules/polished/dist/polished.esm.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   adjustHue: () => (/* binding */ curriedAdjustHue$1),\n/* harmony export */   animation: () => (/* binding */ animation),\n/* harmony export */   backgroundImages: () => (/* binding */ backgroundImages),\n/* harmony export */   backgrounds: () => (/* binding */ backgrounds),\n/* harmony export */   between: () => (/* binding */ between),\n/* harmony export */   border: () => (/* binding */ border),\n/* harmony export */   borderColor: () => (/* binding */ borderColor),\n/* harmony export */   borderRadius: () => (/* binding */ borderRadius),\n/* harmony export */   borderStyle: () => (/* binding */ borderStyle),\n/* harmony export */   borderWidth: () => (/* binding */ borderWidth),\n/* harmony export */   buttons: () => (/* binding */ buttons),\n/* harmony export */   clearFix: () => (/* binding */ clearFix),\n/* harmony export */   complement: () => (/* binding */ complement),\n/* harmony export */   cover: () => (/* binding */ cover),\n/* harmony export */   cssVar: () => (/* binding */ cssVar),\n/* harmony export */   darken: () => (/* binding */ curriedDarken$1),\n/* harmony export */   desaturate: () => (/* binding */ curriedDesaturate$1),\n/* harmony export */   directionalProperty: () => (/* binding */ directionalProperty),\n/* harmony export */   easeIn: () => (/* binding */ easeIn),\n/* harmony export */   easeInOut: () => (/* binding */ easeInOut),\n/* harmony export */   easeOut: () => (/* binding */ easeOut),\n/* harmony export */   ellipsis: () => (/* binding */ ellipsis),\n/* harmony export */   em: () => (/* binding */ em$1),\n/* harmony export */   fluidRange: () => (/* binding */ fluidRange),\n/* harmony export */   fontFace: () => (/* binding */ fontFace),\n/* harmony export */   getContrast: () => (/* binding */ getContrast),\n/* harmony export */   getLuminance: () => (/* binding */ getLuminance),\n/* harmony export */   getValueAndUnit: () => (/* binding */ getValueAndUnit),\n/* harmony export */   grayscale: () => (/* binding */ grayscale),\n/* harmony export */   hiDPI: () => (/* binding */ hiDPI),\n/* harmony export */   hideText: () => (/* binding */ hideText),\n/* harmony export */   hideVisually: () => (/* binding */ hideVisually),\n/* harmony export */   hsl: () => (/* binding */ hsl),\n/* harmony export */   hslToColorString: () => (/* binding */ hslToColorString),\n/* harmony export */   hsla: () => (/* binding */ hsla),\n/* harmony export */   important: () => (/* binding */ important),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   lighten: () => (/* binding */ curriedLighten$1),\n/* harmony export */   linearGradient: () => (/* binding */ linearGradient),\n/* harmony export */   margin: () => (/* binding */ margin),\n/* harmony export */   math: () => (/* binding */ math),\n/* harmony export */   meetsContrastGuidelines: () => (/* binding */ meetsContrastGuidelines),\n/* harmony export */   mix: () => (/* binding */ mix$1),\n/* harmony export */   modularScale: () => (/* binding */ modularScale),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   opacify: () => (/* binding */ curriedOpacify$1),\n/* harmony export */   padding: () => (/* binding */ padding),\n/* harmony export */   parseToHsl: () => (/* binding */ parseToHsl),\n/* harmony export */   parseToRgb: () => (/* binding */ parseToRgb),\n/* harmony export */   position: () => (/* binding */ position),\n/* harmony export */   radialGradient: () => (/* binding */ radialGradient),\n/* harmony export */   readableColor: () => (/* binding */ readableColor),\n/* harmony export */   rem: () => (/* binding */ rem$1),\n/* harmony export */   remToPx: () => (/* binding */ remToPx),\n/* harmony export */   retinaImage: () => (/* binding */ retinaImage),\n/* harmony export */   rgb: () => (/* binding */ rgb),\n/* harmony export */   rgbToColorString: () => (/* binding */ rgbToColorString),\n/* harmony export */   rgba: () => (/* binding */ rgba),\n/* harmony export */   saturate: () => (/* binding */ curriedSaturate$1),\n/* harmony export */   setHue: () => (/* binding */ curriedSetHue$1),\n/* harmony export */   setLightness: () => (/* binding */ curriedSetLightness$1),\n/* harmony export */   setSaturation: () => (/* binding */ curriedSetSaturation$1),\n/* harmony export */   shade: () => (/* binding */ curriedShade$1),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   stripUnit: () => (/* binding */ stripUnit),\n/* harmony export */   textInputs: () => (/* binding */ textInputs),\n/* harmony export */   timingFunctions: () => (/* binding */ timingFunctions),\n/* harmony export */   tint: () => (/* binding */ curriedTint$1),\n/* harmony export */   toColorString: () => (/* binding */ toColorString),\n/* harmony export */   transitions: () => (/* binding */ transitions),\n/* harmony export */   transparentize: () => (/* binding */ curriedTransparentize$1),\n/* harmony export */   triangle: () => (/* binding */ triangle),\n/* harmony export */   wordWrap: () => (/* binding */ wordWrap)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inheritsLoose */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/wrapNativeSuper */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/taggedTemplateLiteralLoose */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteralLoose.js\");\n\n\n\n\n\nfunction last() {\n    var _ref;\n    return _ref = arguments.length - 1, _ref < 0 || arguments.length <= _ref ? undefined : arguments[_ref];\n}\nfunction negation(a) {\n    return -a;\n}\nfunction addition(a, b) {\n    return a + b;\n}\nfunction subtraction(a, b) {\n    return a - b;\n}\nfunction multiplication(a, b) {\n    return a * b;\n}\nfunction division(a, b) {\n    return a / b;\n}\nfunction max() {\n    return Math.max.apply(Math, arguments);\n}\nfunction min() {\n    return Math.min.apply(Math, arguments);\n}\nfunction comma() {\n    return Array.of.apply(Array, arguments);\n}\nvar defaultSymbols = {\n    symbols: {\n        \"*\": {\n            infix: {\n                symbol: \"*\",\n                f: multiplication,\n                notation: \"infix\",\n                precedence: 4,\n                rightToLeft: 0,\n                argCount: 2\n            },\n            symbol: \"*\",\n            regSymbol: \"\\\\*\"\n        },\n        \"/\": {\n            infix: {\n                symbol: \"/\",\n                f: division,\n                notation: \"infix\",\n                precedence: 4,\n                rightToLeft: 0,\n                argCount: 2\n            },\n            symbol: \"/\",\n            regSymbol: \"/\"\n        },\n        \"+\": {\n            infix: {\n                symbol: \"+\",\n                f: addition,\n                notation: \"infix\",\n                precedence: 2,\n                rightToLeft: 0,\n                argCount: 2\n            },\n            prefix: {\n                symbol: \"+\",\n                f: last,\n                notation: \"prefix\",\n                precedence: 3,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \"+\",\n            regSymbol: \"\\\\+\"\n        },\n        \"-\": {\n            infix: {\n                symbol: \"-\",\n                f: subtraction,\n                notation: \"infix\",\n                precedence: 2,\n                rightToLeft: 0,\n                argCount: 2\n            },\n            prefix: {\n                symbol: \"-\",\n                f: negation,\n                notation: \"prefix\",\n                precedence: 3,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \"-\",\n            regSymbol: \"-\"\n        },\n        \",\": {\n            infix: {\n                symbol: \",\",\n                f: comma,\n                notation: \"infix\",\n                precedence: 1,\n                rightToLeft: 0,\n                argCount: 2\n            },\n            symbol: \",\",\n            regSymbol: \",\"\n        },\n        \"(\": {\n            prefix: {\n                symbol: \"(\",\n                f: last,\n                notation: \"prefix\",\n                precedence: 0,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \"(\",\n            regSymbol: \"\\\\(\"\n        },\n        \")\": {\n            postfix: {\n                symbol: \")\",\n                f: undefined,\n                notation: \"postfix\",\n                precedence: 0,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \")\",\n            regSymbol: \"\\\\)\"\n        },\n        min: {\n            func: {\n                symbol: \"min\",\n                f: min,\n                notation: \"func\",\n                precedence: 0,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \"min\",\n            regSymbol: \"min\\\\b\"\n        },\n        max: {\n            func: {\n                symbol: \"max\",\n                f: max,\n                notation: \"func\",\n                precedence: 0,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \"max\",\n            regSymbol: \"max\\\\b\"\n        }\n    }\n};\nvar defaultSymbolMap = defaultSymbols;\n// based on https://github.com/styled-components/styled-components/blob/fcf6f3804c57a14dd7984dfab7bc06ee2edca044/src/utils/error.js\n/**\n * Parse errors.md and turn it into a simple hash of code: message\n * @private\n */ var ERRORS = {\n    \"1\": \"Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).\\n\\n\",\n    \"2\": \"Passed invalid arguments to hsla, please pass multiple numbers e.g. hsla(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).\\n\\n\",\n    \"3\": \"Passed an incorrect argument to a color function, please pass a string representation of a color.\\n\\n\",\n    \"4\": \"Couldn't generate valid rgb string from %s, it returned %s.\\n\\n\",\n    \"5\": \"Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.\\n\\n\",\n    \"6\": \"Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).\\n\\n\",\n    \"7\": \"Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).\\n\\n\",\n    \"8\": \"Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.\\n\\n\",\n    \"9\": \"Please provide a number of steps to the modularScale helper.\\n\\n\",\n    \"10\": \"Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\\n\\n\",\n    \"11\": 'Invalid value passed as base to modularScale, expected number or em string but got \"%s\"\\n\\n',\n    \"12\": 'Expected a string ending in \"px\" or a number passed as the first argument to %s(), got \"%s\" instead.\\n\\n',\n    \"13\": 'Expected a string ending in \"px\" or a number passed as the second argument to %s(), got \"%s\" instead.\\n\\n',\n    \"14\": 'Passed invalid pixel value (\"%s\") to %s(), please pass a value like \"12px\" or 12.\\n\\n',\n    \"15\": 'Passed invalid base value (\"%s\") to %s(), please pass a value like \"12px\" or 12.\\n\\n',\n    \"16\": \"You must provide a template to this method.\\n\\n\",\n    \"17\": \"You passed an unsupported selector state to this method.\\n\\n\",\n    \"18\": \"minScreen and maxScreen must be provided as stringified numbers with the same units.\\n\\n\",\n    \"19\": \"fromSize and toSize must be provided as stringified numbers with the same units.\\n\\n\",\n    \"20\": \"expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\\n\\n\",\n    \"21\": \"expects the objects in the first argument array to have the properties `prop`, `fromSize`, and `toSize`.\\n\\n\",\n    \"22\": \"expects the first argument object to have the properties `prop`, `fromSize`, and `toSize`.\\n\\n\",\n    \"23\": \"fontFace expects a name of a font-family.\\n\\n\",\n    \"24\": \"fontFace expects either the path to the font file(s) or a name of a local copy.\\n\\n\",\n    \"25\": \"fontFace expects localFonts to be an array.\\n\\n\",\n    \"26\": \"fontFace expects fileFormats to be an array.\\n\\n\",\n    \"27\": \"radialGradient requries at least 2 color-stops to properly render.\\n\\n\",\n    \"28\": \"Please supply a filename to retinaImage() as the first argument.\\n\\n\",\n    \"29\": \"Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\\n\\n\",\n    \"30\": \"Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\\n\\n\",\n    \"31\": \"The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation\\n\\n\",\n    \"32\": \"To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s')\\n\\n\",\n    \"33\": \"The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation\\n\\n\",\n    \"34\": \"borderRadius expects a radius value as a string or number as the second argument.\\n\\n\",\n    \"35\": 'borderRadius expects one of \"top\", \"bottom\", \"left\" or \"right\" as the first argument.\\n\\n',\n    \"36\": \"Property must be a string value.\\n\\n\",\n    \"37\": \"Syntax Error at %s.\\n\\n\",\n    \"38\": \"Formula contains a function that needs parentheses at %s.\\n\\n\",\n    \"39\": \"Formula is missing closing parenthesis at %s.\\n\\n\",\n    \"40\": \"Formula has too many closing parentheses at %s.\\n\\n\",\n    \"41\": \"All values in a formula must have the same unit or be unitless.\\n\\n\",\n    \"42\": \"Please provide a number of steps to the modularScale helper.\\n\\n\",\n    \"43\": \"Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\\n\\n\",\n    \"44\": \"Invalid value passed as base to modularScale, expected number or em/rem string but got %s.\\n\\n\",\n    \"45\": \"Passed invalid argument to hslToColorString, please pass a HslColor or HslaColor object.\\n\\n\",\n    \"46\": \"Passed invalid argument to rgbToColorString, please pass a RgbColor or RgbaColor object.\\n\\n\",\n    \"47\": \"minScreen and maxScreen must be provided as stringified numbers with the same units.\\n\\n\",\n    \"48\": \"fromSize and toSize must be provided as stringified numbers with the same units.\\n\\n\",\n    \"49\": \"Expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\\n\\n\",\n    \"50\": \"Expects the objects in the first argument array to have the properties prop, fromSize, and toSize.\\n\\n\",\n    \"51\": \"Expects the first argument object to have the properties prop, fromSize, and toSize.\\n\\n\",\n    \"52\": \"fontFace expects either the path to the font file(s) or a name of a local copy.\\n\\n\",\n    \"53\": \"fontFace expects localFonts to be an array.\\n\\n\",\n    \"54\": \"fontFace expects fileFormats to be an array.\\n\\n\",\n    \"55\": \"fontFace expects a name of a font-family.\\n\\n\",\n    \"56\": \"linearGradient requries at least 2 color-stops to properly render.\\n\\n\",\n    \"57\": \"radialGradient requries at least 2 color-stops to properly render.\\n\\n\",\n    \"58\": \"Please supply a filename to retinaImage() as the first argument.\\n\\n\",\n    \"59\": \"Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\\n\\n\",\n    \"60\": \"Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\\n\\n\",\n    \"61\": \"Property must be a string value.\\n\\n\",\n    \"62\": \"borderRadius expects a radius value as a string or number as the second argument.\\n\\n\",\n    \"63\": 'borderRadius expects one of \"top\", \"bottom\", \"left\" or \"right\" as the first argument.\\n\\n',\n    \"64\": \"The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation.\\n\\n\",\n    \"65\": \"To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s').\\n\\n\",\n    \"66\": \"The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation.\\n\\n\",\n    \"67\": \"You must provide a template to this method.\\n\\n\",\n    \"68\": \"You passed an unsupported selector state to this method.\\n\\n\",\n    \"69\": 'Expected a string ending in \"px\" or a number passed as the first argument to %s(), got %s instead.\\n\\n',\n    \"70\": 'Expected a string ending in \"px\" or a number passed as the second argument to %s(), got %s instead.\\n\\n',\n    \"71\": 'Passed invalid pixel value %s to %s(), please pass a value like \"12px\" or 12.\\n\\n',\n    \"72\": 'Passed invalid base value %s to %s(), please pass a value like \"12px\" or 12.\\n\\n',\n    \"73\": \"Please provide a valid CSS variable.\\n\\n\",\n    \"74\": \"CSS variable not found and no default was provided.\\n\\n\",\n    \"75\": \"important requires a valid style object, got a %s instead.\\n\\n\",\n    \"76\": \"fromSize and toSize must be provided as stringified numbers with the same units as minScreen and maxScreen.\\n\\n\",\n    \"77\": 'remToPx expects a value in \"rem\" but you provided it in \"%s\".\\n\\n',\n    \"78\": 'base must be set in \"px\" or \"%\" but you set it in \"%s\".\\n'\n};\n/**\n * super basic version of sprintf\n * @private\n */ function format() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    var a = args[0];\n    var b = [];\n    var c;\n    for(c = 1; c < args.length; c += 1){\n        b.push(args[c]);\n    }\n    b.forEach(function(d) {\n        a = a.replace(/%[a-z]/, d);\n    });\n    return a;\n}\n/**\n * Create an error file out of errors.md for development and a simple web link to the full errors\n * in production mode.\n * @private\n */ var PolishedError = /*#__PURE__*/ function(_Error) {\n    (0,_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(PolishedError, _Error);\n    function PolishedError(code) {\n        var _this;\n        if (false) {} else {\n            for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                args[_key2 - 1] = arguments[_key2];\n            }\n            _this = _Error.call(this, format.apply(void 0, [\n                ERRORS[code]\n            ].concat(args))) || this;\n        }\n        return (0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_this);\n    }\n    return PolishedError;\n}(/*#__PURE__*/ (0,_babel_runtime_helpers_esm_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(Error));\nvar unitRegExp = /((?!\\w)a|na|hc|mc|dg|me[r]?|xe|ni(?![a-zA-Z])|mm|cp|tp|xp|q(?!s)|hv|xamv|nimv|wv|sm|s(?!\\D|$)|ged|darg?|nrut)/g;\n// Merges additional math functionality into the defaults.\nfunction mergeSymbolMaps(additionalSymbols) {\n    var symbolMap = {};\n    symbolMap.symbols = additionalSymbols ? (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, defaultSymbolMap.symbols, additionalSymbols.symbols) : (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, defaultSymbolMap.symbols);\n    return symbolMap;\n}\nfunction exec(operators, values) {\n    var _ref;\n    var op = operators.pop();\n    values.push(op.f.apply(op, (_ref = []).concat.apply(_ref, values.splice(-op.argCount))));\n    return op.precedence;\n}\nfunction calculate(expression, additionalSymbols) {\n    var symbolMap = mergeSymbolMaps(additionalSymbols);\n    var match;\n    var operators = [\n        symbolMap.symbols[\"(\"].prefix\n    ];\n    var values = [];\n    var pattern = new RegExp(\"\\\\d+(?:\\\\.\\\\d+)?|\" + // ...and patterns for individual operators/function names\n    Object.keys(symbolMap.symbols).map(function(key) {\n        return symbolMap.symbols[key];\n    })// longer symbols should be listed first\n    // $FlowFixMe\n    .sort(function(a, b) {\n        return b.symbol.length - a.symbol.length;\n    })// $FlowFixMe\n    .map(function(val) {\n        return val.regSymbol;\n    }).join(\"|\") + \"|(\\\\S)\", \"g\");\n    pattern.lastIndex = 0; // Reset regular expression object\n    var afterValue = false;\n    do {\n        match = pattern.exec(expression);\n        var _ref2 = match || [\n            \")\",\n            undefined\n        ], token = _ref2[0], bad = _ref2[1];\n        var notNumber = symbolMap.symbols[token];\n        var notNewValue = notNumber && !notNumber.prefix && !notNumber.func;\n        var notAfterValue = !notNumber || !notNumber.postfix && !notNumber.infix;\n        // Check for syntax errors:\n        if (bad || (afterValue ? notAfterValue : notNewValue)) {\n            throw new PolishedError(37, match ? match.index : expression.length, expression);\n        }\n        if (afterValue) {\n            // We either have an infix or postfix operator (they should be mutually exclusive)\n            var curr = notNumber.postfix || notNumber.infix;\n            do {\n                var prev = operators[operators.length - 1];\n                if ((curr.precedence - prev.precedence || prev.rightToLeft) > 0) break;\n            // Apply previous operator, since it has precedence over current one\n            }while (exec(operators, values)); // Exit loop after executing an opening parenthesis or function\n            afterValue = curr.notation === \"postfix\";\n            if (curr.symbol !== \")\") {\n                operators.push(curr);\n                // Postfix always has precedence over any operator that follows after it\n                if (afterValue) exec(operators, values);\n            }\n        } else if (notNumber) {\n            // prefix operator or function\n            operators.push(notNumber.prefix || notNumber.func);\n            if (notNumber.func) {\n                // Require an opening parenthesis\n                match = pattern.exec(expression);\n                if (!match || match[0] !== \"(\") {\n                    throw new PolishedError(38, match ? match.index : expression.length, expression);\n                }\n            }\n        } else {\n            // number\n            values.push(+token);\n            afterValue = true;\n        }\n    }while (match && operators.length);\n    if (operators.length) {\n        throw new PolishedError(39, match ? match.index : expression.length, expression);\n    } else if (match) {\n        throw new PolishedError(40, match ? match.index : expression.length, expression);\n    } else {\n        return values.pop();\n    }\n}\nfunction reverseString(str) {\n    return str.split(\"\").reverse().join(\"\");\n}\n/**\n * Helper for doing math with CSS Units. Accepts a formula as a string. All values in the formula must have the same unit (or be unitless). Supports complex formulas utliziing addition, subtraction, multiplication, division, square root, powers, factorial, min, max, as well as parentheses for order of operation.\n *\n *In cases where you need to do calculations with mixed units where one unit is a [relative length unit](https://developer.mozilla.org/en-US/docs/Web/CSS/length#Relative_length_units), you will want to use [CSS Calc](https://developer.mozilla.org/en-US/docs/Web/CSS/calc).\n *\n * *warning* While we've done everything possible to ensure math safely evalutes formulas expressed as strings, you should always use extreme caution when passing `math` user provided values.\n * @example\n * // Styles as object usage\n * const styles = {\n *   fontSize: math('12rem + 8rem'),\n *   fontSize: math('(12px + 2px) * 3'),\n *   fontSize: math('3px^2 + sqrt(4)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   fontSize: ${math('12rem + 8rem')};\n *   fontSize: ${math('(12px + 2px) * 3')};\n *   fontSize: ${math('3px^2 + sqrt(4)')};\n * `\n *\n * // CSS as JS Output\n *\n * div: {\n *   fontSize: '20rem',\n *   fontSize: '42px',\n *   fontSize: '11px',\n * }\n */ function math(formula, additionalSymbols) {\n    var reversedFormula = reverseString(formula);\n    var formulaMatch = reversedFormula.match(unitRegExp);\n    // Check that all units are the same\n    if (formulaMatch && !formulaMatch.every(function(unit) {\n        return unit === formulaMatch[0];\n    })) {\n        throw new PolishedError(41);\n    }\n    var cleanFormula = reverseString(reversedFormula.replace(unitRegExp, \"\"));\n    return \"\" + calculate(cleanFormula, additionalSymbols) + (formulaMatch ? reverseString(formulaMatch[0]) : \"\");\n}\nvar cssVariableRegex = /--[\\S]*/g;\n/**\n * Fetches the value of a passed CSS Variable in the :root scope, or otherwise returns a defaultValue if provided.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   'background': cssVar('--background-color'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${cssVar('--background-color')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   'background': 'red'\n * }\n */ function cssVar(cssVariable, defaultValue) {\n    if (!cssVariable || !cssVariable.match(cssVariableRegex)) {\n        throw new PolishedError(73);\n    }\n    var variableValue;\n    /* eslint-disable */ /* istanbul ignore next */ if (typeof document !== \"undefined\" && document.documentElement !== null) {\n        variableValue = getComputedStyle(document.documentElement).getPropertyValue(cssVariable);\n    }\n    /* eslint-enable */ if (variableValue) {\n        return variableValue.trim();\n    } else if (defaultValue) {\n        return defaultValue;\n    }\n    throw new PolishedError(74);\n}\n// @private\nfunction capitalizeString(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n}\nvar positionMap$1 = [\n    \"Top\",\n    \"Right\",\n    \"Bottom\",\n    \"Left\"\n];\nfunction generateProperty(property, position) {\n    if (!property) return position.toLowerCase();\n    var splitProperty = property.split(\"-\");\n    if (splitProperty.length > 1) {\n        splitProperty.splice(1, 0, position);\n        return splitProperty.reduce(function(acc, val) {\n            return \"\" + acc + capitalizeString(val);\n        });\n    }\n    var joinedProperty = property.replace(/([a-z])([A-Z])/g, \"$1\" + position + \"$2\");\n    return property === joinedProperty ? \"\" + property + position : joinedProperty;\n}\nfunction generateStyles(property, valuesWithDefaults) {\n    var styles = {};\n    for(var i = 0; i < valuesWithDefaults.length; i += 1){\n        if (valuesWithDefaults[i] || valuesWithDefaults[i] === 0) {\n            styles[generateProperty(property, positionMap$1[i])] = valuesWithDefaults[i];\n        }\n    }\n    return styles;\n}\n/**\n * Enables shorthand for direction-based properties. It accepts a property (hyphenated or camelCased) and up to four values that map to top, right, bottom, and left, respectively. You can optionally pass an empty string to get only the directional values as properties. You can also optionally pass a null argument for a directional value to ignore it.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...directionalProperty('padding', '12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${directionalProperty('padding', '12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'paddingTop': '12px',\n *   'paddingRight': '24px',\n *   'paddingBottom': '36px',\n *   'paddingLeft': '48px'\n * }\n */ function directionalProperty(property) {\n    for(var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        values[_key - 1] = arguments[_key];\n    }\n    //  prettier-ignore\n    var firstValue = values[0], _values$ = values[1], secondValue = _values$ === void 0 ? firstValue : _values$, _values$2 = values[2], thirdValue = _values$2 === void 0 ? firstValue : _values$2, _values$3 = values[3], fourthValue = _values$3 === void 0 ? secondValue : _values$3;\n    var valuesWithDefaults = [\n        firstValue,\n        secondValue,\n        thirdValue,\n        fourthValue\n    ];\n    return generateStyles(property, valuesWithDefaults);\n}\n/**\n * Check if a string ends with something\n * @private\n */ function endsWith(string, suffix) {\n    return string.substr(-suffix.length) === suffix;\n}\nvar cssRegex$1 = /^([+-]?(?:\\d+|\\d*\\.\\d+))([a-z]*|%)$/;\n/**\n * Returns a given CSS value minus its unit of measure.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   '--dimension': stripUnit('100px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   --dimension: ${stripUnit('100px')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   '--dimension': 100\n * }\n */ function stripUnit(value) {\n    if (typeof value !== \"string\") return value;\n    var matchedValue = value.match(cssRegex$1);\n    return matchedValue ? parseFloat(value) : value;\n}\n/**\n * Factory function that creates pixel-to-x converters\n * @private\n */ var pxtoFactory = function pxtoFactory(to) {\n    return function(pxval, base) {\n        if (base === void 0) {\n            base = \"16px\";\n        }\n        var newPxval = pxval;\n        var newBase = base;\n        if (typeof pxval === \"string\") {\n            if (!endsWith(pxval, \"px\")) {\n                throw new PolishedError(69, to, pxval);\n            }\n            newPxval = stripUnit(pxval);\n        }\n        if (typeof base === \"string\") {\n            if (!endsWith(base, \"px\")) {\n                throw new PolishedError(70, to, base);\n            }\n            newBase = stripUnit(base);\n        }\n        if (typeof newPxval === \"string\") {\n            throw new PolishedError(71, pxval, to);\n        }\n        if (typeof newBase === \"string\") {\n            throw new PolishedError(72, base, to);\n        }\n        return \"\" + newPxval / newBase + to;\n    };\n};\nvar pixelsto = pxtoFactory;\n/**\n * Convert pixel value to ems. The default base value is 16px, but can be changed by passing a\n * second argument to the function.\n * @function\n * @param {string|number} pxval\n * @param {string|number} [base='16px']\n * @example\n * // Styles as object usage\n * const styles = {\n *   'height': em('16px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   height: ${em('16px')}\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   'height': '1em'\n * }\n */ var em = pixelsto(\"em\");\nvar em$1 = em;\nvar cssRegex = /^([+-]?(?:\\d+|\\d*\\.\\d+))([a-z]*|%)$/;\n/**\n * Returns a given CSS value and its unit as elements of an array.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   '--dimension': getValueAndUnit('100px')[0],\n *   '--unit': getValueAndUnit('100px')[1],\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   --dimension: ${getValueAndUnit('100px')[0]};\n *   --unit: ${getValueAndUnit('100px')[1]};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   '--dimension': 100,\n *   '--unit': 'px',\n * }\n */ function getValueAndUnit(value) {\n    if (typeof value !== \"string\") return [\n        value,\n        \"\"\n    ];\n    var matchedValue = value.match(cssRegex);\n    if (matchedValue) return [\n        parseFloat(value),\n        matchedValue[2]\n    ];\n    return [\n        value,\n        undefined\n    ];\n}\n/**\n * Helper for targeting rules in a style block generated by polished modules that need !important-level specificity. Can optionally specify a rule (or rules) to target specific rules.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...important(cover())\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${important(cover())}\n * `\n *\n * // CSS as JS Output\n *\n * div: {\n *   'position': 'absolute !important',\n *   'top': '0 !important',\n *   'right: '0 !important',\n *   'bottom': '0 !important',\n *   'left: '0 !important'\n * }\n */ function important(styleBlock, rules) {\n    if (typeof styleBlock !== \"object\" || styleBlock === null) {\n        throw new PolishedError(75, typeof styleBlock);\n    }\n    var newStyleBlock = {};\n    Object.keys(styleBlock).forEach(function(key) {\n        if (typeof styleBlock[key] === \"object\" && styleBlock[key] !== null) {\n            newStyleBlock[key] = important(styleBlock[key], rules);\n        } else if (!rules || rules && (rules === key || rules.indexOf(key) >= 0)) {\n            newStyleBlock[key] = styleBlock[key] + \" !important\";\n        } else {\n            newStyleBlock[key] = styleBlock[key];\n        }\n    });\n    return newStyleBlock;\n}\nvar ratioNames = {\n    minorSecond: 1.067,\n    majorSecond: 1.125,\n    minorThird: 1.2,\n    majorThird: 1.25,\n    perfectFourth: 1.333,\n    augFourth: 1.414,\n    perfectFifth: 1.5,\n    minorSixth: 1.6,\n    goldenSection: 1.618,\n    majorSixth: 1.667,\n    minorSeventh: 1.778,\n    majorSeventh: 1.875,\n    octave: 2,\n    majorTenth: 2.5,\n    majorEleventh: 2.667,\n    majorTwelfth: 3,\n    doubleOctave: 4\n};\nfunction getRatio(ratioName) {\n    return ratioNames[ratioName];\n}\n/**\n * Establish consistent measurements and spacial relationships throughout your projects by incrementing an em or rem value up or down a defined scale. We provide a list of commonly used scales as pre-defined variables.\n * @example\n * // Styles as object usage\n * const styles = {\n *    // Increment two steps up the default scale\n *   'fontSize': modularScale(2)\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *    // Increment two steps up the default scale\n *   fontSize: ${modularScale(2)}\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   'fontSize': '1.77689em'\n * }\n */ function modularScale(steps, base, ratio) {\n    if (base === void 0) {\n        base = \"1em\";\n    }\n    if (ratio === void 0) {\n        ratio = 1.333;\n    }\n    if (typeof steps !== \"number\") {\n        throw new PolishedError(42);\n    }\n    if (typeof ratio === \"string\" && !ratioNames[ratio]) {\n        throw new PolishedError(43);\n    }\n    var _ref = typeof base === \"string\" ? getValueAndUnit(base) : [\n        base,\n        \"\"\n    ], realBase = _ref[0], unit = _ref[1];\n    var realRatio = typeof ratio === \"string\" ? getRatio(ratio) : ratio;\n    if (typeof realBase === \"string\") {\n        throw new PolishedError(44, base);\n    }\n    return \"\" + realBase * Math.pow(realRatio, steps) + (unit || \"\");\n}\n/**\n * Convert pixel value to rems. The default base value is 16px, but can be changed by passing a\n * second argument to the function.\n * @function\n * @param {string|number} pxval\n * @param {string|number} [base='16px']\n * @example\n * // Styles as object usage\n * const styles = {\n *   'height': rem('16px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   height: ${rem('16px')}\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   'height': '1rem'\n * }\n */ var rem = pixelsto(\"rem\");\nvar rem$1 = rem;\nvar defaultFontSize = 16;\nfunction convertBase(base) {\n    var deconstructedValue = getValueAndUnit(base);\n    if (deconstructedValue[1] === \"px\") {\n        return parseFloat(base);\n    }\n    if (deconstructedValue[1] === \"%\") {\n        return parseFloat(base) / 100 * defaultFontSize;\n    }\n    throw new PolishedError(78, deconstructedValue[1]);\n}\nfunction getBaseFromDoc() {\n    /* eslint-disable */ /* istanbul ignore next */ if (typeof document !== \"undefined\" && document.documentElement !== null) {\n        var rootFontSize = getComputedStyle(document.documentElement).fontSize;\n        return rootFontSize ? convertBase(rootFontSize) : defaultFontSize;\n    }\n    /* eslint-enable */ /* istanbul ignore next */ return defaultFontSize;\n}\n/**\n * Convert rem values to px. By default, the base value is pulled from the font-size property on the root element (if it is set in % or px). It defaults to 16px if not found on the root. You can also override the base value by providing your own base in % or px.\n * @example\n * // Styles as object usage\n * const styles = {\n *   'height': remToPx('1.6rem')\n *   'height': remToPx('1.6rem', '10px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   height: ${remToPx('1.6rem')}\n *   height: ${remToPx('1.6rem', '10px')}\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   'height': '25.6px',\n *   'height': '16px',\n * }\n */ function remToPx(value, base) {\n    var deconstructedValue = getValueAndUnit(value);\n    if (deconstructedValue[1] !== \"rem\" && deconstructedValue[1] !== \"\") {\n        throw new PolishedError(77, deconstructedValue[1]);\n    }\n    var newBase = base ? convertBase(base) : getBaseFromDoc();\n    return deconstructedValue[0] * newBase + \"px\";\n}\nvar functionsMap$3 = {\n    back: \"cubic-bezier(0.600, -0.280, 0.735, 0.045)\",\n    circ: \"cubic-bezier(0.600,  0.040, 0.980, 0.335)\",\n    cubic: \"cubic-bezier(0.550,  0.055, 0.675, 0.190)\",\n    expo: \"cubic-bezier(0.950,  0.050, 0.795, 0.035)\",\n    quad: \"cubic-bezier(0.550,  0.085, 0.680, 0.530)\",\n    quart: \"cubic-bezier(0.895,  0.030, 0.685, 0.220)\",\n    quint: \"cubic-bezier(0.755,  0.050, 0.855, 0.060)\",\n    sine: \"cubic-bezier(0.470,  0.000, 0.745, 0.715)\"\n};\n/**\n * String to represent common easing functions as demonstrated here: (github.com/jaukia/easie).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   'transitionTimingFunction': easeIn('quad')\n * }\n *\n * // styled-components usage\n *  const div = styled.div`\n *   transitionTimingFunction: ${easeIn('quad')};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'transitionTimingFunction': 'cubic-bezier(0.550,  0.085, 0.680, 0.530)',\n * }\n */ function easeIn(functionName) {\n    return functionsMap$3[functionName.toLowerCase().trim()];\n}\nvar functionsMap$2 = {\n    back: \"cubic-bezier(0.680, -0.550, 0.265, 1.550)\",\n    circ: \"cubic-bezier(0.785,  0.135, 0.150, 0.860)\",\n    cubic: \"cubic-bezier(0.645,  0.045, 0.355, 1.000)\",\n    expo: \"cubic-bezier(1.000,  0.000, 0.000, 1.000)\",\n    quad: \"cubic-bezier(0.455,  0.030, 0.515, 0.955)\",\n    quart: \"cubic-bezier(0.770,  0.000, 0.175, 1.000)\",\n    quint: \"cubic-bezier(0.860,  0.000, 0.070, 1.000)\",\n    sine: \"cubic-bezier(0.445,  0.050, 0.550, 0.950)\"\n};\n/**\n * String to represent common easing functions as demonstrated here: (github.com/jaukia/easie).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   'transitionTimingFunction': easeInOut('quad')\n * }\n *\n * // styled-components usage\n *  const div = styled.div`\n *   transitionTimingFunction: ${easeInOut('quad')};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'transitionTimingFunction': 'cubic-bezier(0.455,  0.030, 0.515, 0.955)',\n * }\n */ function easeInOut(functionName) {\n    return functionsMap$2[functionName.toLowerCase().trim()];\n}\nvar functionsMap$1 = {\n    back: \"cubic-bezier(0.175,  0.885, 0.320, 1.275)\",\n    cubic: \"cubic-bezier(0.215,  0.610, 0.355, 1.000)\",\n    circ: \"cubic-bezier(0.075,  0.820, 0.165, 1.000)\",\n    expo: \"cubic-bezier(0.190,  1.000, 0.220, 1.000)\",\n    quad: \"cubic-bezier(0.250,  0.460, 0.450, 0.940)\",\n    quart: \"cubic-bezier(0.165,  0.840, 0.440, 1.000)\",\n    quint: \"cubic-bezier(0.230,  1.000, 0.320, 1.000)\",\n    sine: \"cubic-bezier(0.390,  0.575, 0.565, 1.000)\"\n};\n/**\n * String to represent common easing functions as demonstrated here: (github.com/jaukia/easie).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   'transitionTimingFunction': easeOut('quad')\n * }\n *\n * // styled-components usage\n *  const div = styled.div`\n *   transitionTimingFunction: ${easeOut('quad')};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'transitionTimingFunction': 'cubic-bezier(0.250,  0.460, 0.450, 0.940)',\n * }\n */ function easeOut(functionName) {\n    return functionsMap$1[functionName.toLowerCase().trim()];\n}\n/**\n * Returns a CSS calc formula for linear interpolation of a property between two values. Accepts optional minScreen (defaults to '320px') and maxScreen (defaults to '1200px').\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   fontSize: between('20px', '100px', '400px', '1000px'),\n *   fontSize: between('20px', '100px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   fontSize: ${between('20px', '100px', '400px', '1000px')};\n *   fontSize: ${between('20px', '100px')}\n * `\n *\n * // CSS as JS Output\n *\n * h1: {\n *   'fontSize': 'calc(-33.33333333333334px + 13.333333333333334vw)',\n *   'fontSize': 'calc(-9.090909090909093px + 9.090909090909092vw)'\n * }\n */ function between(fromSize, toSize, minScreen, maxScreen) {\n    if (minScreen === void 0) {\n        minScreen = \"320px\";\n    }\n    if (maxScreen === void 0) {\n        maxScreen = \"1200px\";\n    }\n    var _getValueAndUnit = getValueAndUnit(fromSize), unitlessFromSize = _getValueAndUnit[0], fromSizeUnit = _getValueAndUnit[1];\n    var _getValueAndUnit2 = getValueAndUnit(toSize), unitlessToSize = _getValueAndUnit2[0], toSizeUnit = _getValueAndUnit2[1];\n    var _getValueAndUnit3 = getValueAndUnit(minScreen), unitlessMinScreen = _getValueAndUnit3[0], minScreenUnit = _getValueAndUnit3[1];\n    var _getValueAndUnit4 = getValueAndUnit(maxScreen), unitlessMaxScreen = _getValueAndUnit4[0], maxScreenUnit = _getValueAndUnit4[1];\n    if (typeof unitlessMinScreen !== \"number\" || typeof unitlessMaxScreen !== \"number\" || !minScreenUnit || !maxScreenUnit || minScreenUnit !== maxScreenUnit) {\n        throw new PolishedError(47);\n    }\n    if (typeof unitlessFromSize !== \"number\" || typeof unitlessToSize !== \"number\" || fromSizeUnit !== toSizeUnit) {\n        throw new PolishedError(48);\n    }\n    if (fromSizeUnit !== minScreenUnit || toSizeUnit !== maxScreenUnit) {\n        throw new PolishedError(76);\n    }\n    var slope = (unitlessFromSize - unitlessToSize) / (unitlessMinScreen - unitlessMaxScreen);\n    var base = unitlessToSize - slope * unitlessMaxScreen;\n    return \"calc(\" + base.toFixed(2) + (fromSizeUnit || \"\") + \" + \" + (100 * slope).toFixed(2) + \"vw)\";\n}\n/**\n * CSS to contain a float (credit to CSSMojo).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *    ...clearFix(),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${clearFix()}\n * `\n *\n * // CSS as JS Output\n *\n * '&::after': {\n *   'clear': 'both',\n *   'content': '\"\"',\n *   'display': 'table'\n * }\n */ function clearFix(parent) {\n    var _ref;\n    if (parent === void 0) {\n        parent = \"&\";\n    }\n    var pseudoSelector = parent + \"::after\";\n    return _ref = {}, _ref[pseudoSelector] = {\n        clear: \"both\",\n        content: '\"\"',\n        display: \"table\"\n    }, _ref;\n}\n/**\n * CSS to fully cover an area. Can optionally be passed an offset to act as a \"padding\".\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...cover()\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${cover()}\n * `\n *\n * // CSS as JS Output\n *\n * div: {\n *   'position': 'absolute',\n *   'top': '0',\n *   'right: '0',\n *   'bottom': '0',\n *   'left: '0'\n * }\n */ function cover(offset) {\n    if (offset === void 0) {\n        offset = 0;\n    }\n    return {\n        position: \"absolute\",\n        top: offset,\n        right: offset,\n        bottom: offset,\n        left: offset\n    };\n}\n/**\n * CSS to represent truncated text with an ellipsis. You can optionally pass a max-width and number of lines before truncating.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...ellipsis('250px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${ellipsis('250px')}\n * `\n *\n * // CSS as JS Output\n *\n * div: {\n *   'display': 'inline-block',\n *   'maxWidth': '250px',\n *   'overflow': 'hidden',\n *   'textOverflow': 'ellipsis',\n *   'whiteSpace': 'nowrap',\n *   'wordWrap': 'normal'\n * }\n */ function ellipsis(width, lines) {\n    if (lines === void 0) {\n        lines = 1;\n    }\n    var styles = {\n        display: \"inline-block\",\n        maxWidth: width || \"100%\",\n        overflow: \"hidden\",\n        textOverflow: \"ellipsis\",\n        whiteSpace: \"nowrap\",\n        wordWrap: \"normal\"\n    };\n    return lines > 1 ? (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, styles, {\n        WebkitBoxOrient: \"vertical\",\n        WebkitLineClamp: lines,\n        display: \"-webkit-box\",\n        whiteSpace: \"normal\"\n    }) : styles;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\n/**\n * Returns a set of media queries that resizes a property (or set of properties) between a provided fromSize and toSize. Accepts optional minScreen (defaults to '320px') and maxScreen (defaults to '1200px') to constrain the interpolation.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...fluidRange(\n *    {\n *        prop: 'padding',\n *        fromSize: '20px',\n *        toSize: '100px',\n *      },\n *      '400px',\n *      '1000px',\n *    )\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${fluidRange(\n *      {\n *        prop: 'padding',\n *        fromSize: '20px',\n *        toSize: '100px',\n *      },\n *      '400px',\n *      '1000px',\n *    )}\n * `\n *\n * // CSS as JS Output\n *\n * div: {\n *   \"@media (min-width: 1000px)\": Object {\n *     \"padding\": \"100px\",\n *   },\n *   \"@media (min-width: 400px)\": Object {\n *     \"padding\": \"calc(-33.33333333333334px + 13.333333333333334vw)\",\n *   },\n *   \"padding\": \"20px\",\n * }\n */ function fluidRange(cssProp, minScreen, maxScreen) {\n    if (minScreen === void 0) {\n        minScreen = \"320px\";\n    }\n    if (maxScreen === void 0) {\n        maxScreen = \"1200px\";\n    }\n    if (!Array.isArray(cssProp) && typeof cssProp !== \"object\" || cssProp === null) {\n        throw new PolishedError(49);\n    }\n    if (Array.isArray(cssProp)) {\n        var mediaQueries = {};\n        var fallbacks = {};\n        for(var _iterator = _createForOfIteratorHelperLoose(cssProp), _step; !(_step = _iterator()).done;){\n            var _extends2, _extends3;\n            var obj = _step.value;\n            if (!obj.prop || !obj.fromSize || !obj.toSize) {\n                throw new PolishedError(50);\n            }\n            fallbacks[obj.prop] = obj.fromSize;\n            mediaQueries[\"@media (min-width: \" + minScreen + \")\"] = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, mediaQueries[\"@media (min-width: \" + minScreen + \")\"], (_extends2 = {}, _extends2[obj.prop] = between(obj.fromSize, obj.toSize, minScreen, maxScreen), _extends2));\n            mediaQueries[\"@media (min-width: \" + maxScreen + \")\"] = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, mediaQueries[\"@media (min-width: \" + maxScreen + \")\"], (_extends3 = {}, _extends3[obj.prop] = obj.toSize, _extends3));\n        }\n        return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, fallbacks, mediaQueries);\n    } else {\n        var _ref, _ref2, _ref3;\n        if (!cssProp.prop || !cssProp.fromSize || !cssProp.toSize) {\n            throw new PolishedError(51);\n        }\n        return _ref3 = {}, _ref3[cssProp.prop] = cssProp.fromSize, _ref3[\"@media (min-width: \" + minScreen + \")\"] = (_ref = {}, _ref[cssProp.prop] = between(cssProp.fromSize, cssProp.toSize, minScreen, maxScreen), _ref), _ref3[\"@media (min-width: \" + maxScreen + \")\"] = (_ref2 = {}, _ref2[cssProp.prop] = cssProp.toSize, _ref2), _ref3;\n    }\n}\nvar dataURIRegex = /^\\s*data:([a-z]+\\/[a-z-]+(;[a-z-]+=[a-z-]+)?)?(;charset=[a-z0-9-]+)?(;base64)?,[a-z0-9!$&',()*+,;=\\-._~:@/?%\\s]*\\s*$/i;\nvar formatHintMap = {\n    woff: \"woff\",\n    woff2: \"woff2\",\n    ttf: \"truetype\",\n    otf: \"opentype\",\n    eot: \"embedded-opentype\",\n    svg: \"svg\",\n    svgz: \"svg\"\n};\nfunction generateFormatHint(format, formatHint) {\n    if (!formatHint) return \"\";\n    return ' format(\"' + formatHintMap[format] + '\")';\n}\nfunction isDataURI(fontFilePath) {\n    return !!fontFilePath.replace(/\\s+/g, \" \").match(dataURIRegex);\n}\nfunction generateFileReferences(fontFilePath, fileFormats, formatHint) {\n    if (isDataURI(fontFilePath)) {\n        return 'url(\"' + fontFilePath + '\")' + generateFormatHint(fileFormats[0], formatHint);\n    }\n    var fileFontReferences = fileFormats.map(function(format) {\n        return 'url(\"' + fontFilePath + \".\" + format + '\")' + generateFormatHint(format, formatHint);\n    });\n    return fileFontReferences.join(\", \");\n}\nfunction generateLocalReferences(localFonts) {\n    var localFontReferences = localFonts.map(function(font) {\n        return 'local(\"' + font + '\")';\n    });\n    return localFontReferences.join(\", \");\n}\nfunction generateSources(fontFilePath, localFonts, fileFormats, formatHint) {\n    var fontReferences = [];\n    if (localFonts) fontReferences.push(generateLocalReferences(localFonts));\n    if (fontFilePath) {\n        fontReferences.push(generateFileReferences(fontFilePath, fileFormats, formatHint));\n    }\n    return fontReferences.join(\", \");\n}\n/**\n * CSS for a @font-face declaration. Defaults to check for local copies of the font on the user's machine. You can disable this by passing `null` to localFonts.\n *\n * @example\n * // Styles as object basic usage\n * const styles = {\n *    ...fontFace({\n *      'fontFamily': 'Sans-Pro',\n *      'fontFilePath': 'path/to/file'\n *    })\n * }\n *\n * // styled-components basic usage\n * const GlobalStyle = createGlobalStyle`${\n *   fontFace({\n *     'fontFamily': 'Sans-Pro',\n *     'fontFilePath': 'path/to/file'\n *   }\n * )}`\n *\n * // CSS as JS Output\n *\n * '@font-face': {\n *   'fontFamily': 'Sans-Pro',\n *   'src': 'url(\"path/to/file.eot\"), url(\"path/to/file.woff2\"), url(\"path/to/file.woff\"), url(\"path/to/file.ttf\"), url(\"path/to/file.svg\")',\n * }\n */ function fontFace(_ref) {\n    var fontFamily = _ref.fontFamily, fontFilePath = _ref.fontFilePath, fontStretch = _ref.fontStretch, fontStyle = _ref.fontStyle, fontVariant = _ref.fontVariant, fontWeight = _ref.fontWeight, _ref$fileFormats = _ref.fileFormats, fileFormats = _ref$fileFormats === void 0 ? [\n        \"eot\",\n        \"woff2\",\n        \"woff\",\n        \"ttf\",\n        \"svg\"\n    ] : _ref$fileFormats, _ref$formatHint = _ref.formatHint, formatHint = _ref$formatHint === void 0 ? false : _ref$formatHint, _ref$localFonts = _ref.localFonts, localFonts = _ref$localFonts === void 0 ? [\n        fontFamily\n    ] : _ref$localFonts, unicodeRange = _ref.unicodeRange, fontDisplay = _ref.fontDisplay, fontVariationSettings = _ref.fontVariationSettings, fontFeatureSettings = _ref.fontFeatureSettings;\n    // Error Handling\n    if (!fontFamily) throw new PolishedError(55);\n    if (!fontFilePath && !localFonts) {\n        throw new PolishedError(52);\n    }\n    if (localFonts && !Array.isArray(localFonts)) {\n        throw new PolishedError(53);\n    }\n    if (!Array.isArray(fileFormats)) {\n        throw new PolishedError(54);\n    }\n    var fontFaceDeclaration = {\n        \"@font-face\": {\n            fontFamily: fontFamily,\n            src: generateSources(fontFilePath, localFonts, fileFormats, formatHint),\n            unicodeRange: unicodeRange,\n            fontStretch: fontStretch,\n            fontStyle: fontStyle,\n            fontVariant: fontVariant,\n            fontWeight: fontWeight,\n            fontDisplay: fontDisplay,\n            fontVariationSettings: fontVariationSettings,\n            fontFeatureSettings: fontFeatureSettings\n        }\n    };\n    // Removes undefined fields for cleaner css object.\n    return JSON.parse(JSON.stringify(fontFaceDeclaration));\n}\n/**\n * CSS to hide text to show a background image in a SEO-friendly way.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   'backgroundImage': 'url(logo.png)',\n *   ...hideText(),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   backgroundImage: url(logo.png);\n *   ${hideText()};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'backgroundImage': 'url(logo.png)',\n *   'textIndent': '101%',\n *   'overflow': 'hidden',\n *   'whiteSpace': 'nowrap',\n * }\n */ function hideText() {\n    return {\n        textIndent: \"101%\",\n        overflow: \"hidden\",\n        whiteSpace: \"nowrap\"\n    };\n}\n/**\n * CSS to hide content visually but remain accessible to screen readers.\n * from [HTML5 Boilerplate](https://github.com/h5bp/html5-boilerplate/blob/9a176f57af1cfe8ec70300da4621fb9b07e5fa31/src/css/main.css#L121)\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...hideVisually(),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${hideVisually()};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'border': '0',\n *   'clip': 'rect(0 0 0 0)',\n *   'height': '1px',\n *   'margin': '-1px',\n *   'overflow': 'hidden',\n *   'padding': '0',\n *   'position': 'absolute',\n *   'whiteSpace': 'nowrap',\n *   'width': '1px',\n * }\n */ function hideVisually() {\n    return {\n        border: \"0\",\n        clip: \"rect(0 0 0 0)\",\n        height: \"1px\",\n        margin: \"-1px\",\n        overflow: \"hidden\",\n        padding: \"0\",\n        position: \"absolute\",\n        whiteSpace: \"nowrap\",\n        width: \"1px\"\n    };\n}\n/**\n * Generates a media query to target HiDPI devices.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *  [hiDPI(1.5)]: {\n *    width: 200px;\n *  }\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${hiDPI(1.5)} {\n *     width: 200px;\n *   }\n * `\n *\n * // CSS as JS Output\n *\n * '@media only screen and (-webkit-min-device-pixel-ratio: 1.5),\n *  only screen and (min--moz-device-pixel-ratio: 1.5),\n *  only screen and (-o-min-device-pixel-ratio: 1.5/1),\n *  only screen and (min-resolution: 144dpi),\n *  only screen and (min-resolution: 1.5dppx)': {\n *   'width': '200px',\n * }\n */ function hiDPI(ratio) {\n    if (ratio === void 0) {\n        ratio = 1.3;\n    }\n    return \"\\n    @media only screen and (-webkit-min-device-pixel-ratio: \" + ratio + \"),\\n    only screen and (min--moz-device-pixel-ratio: \" + ratio + \"),\\n    only screen and (-o-min-device-pixel-ratio: \" + ratio + \"/1),\\n    only screen and (min-resolution: \" + Math.round(ratio * 96) + \"dpi),\\n    only screen and (min-resolution: \" + ratio + \"dppx)\\n  \";\n}\nfunction constructGradientValue(literals) {\n    var template = \"\";\n    for(var _len = arguments.length, substitutions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        substitutions[_key - 1] = arguments[_key];\n    }\n    for(var i = 0; i < literals.length; i += 1){\n        template += literals[i];\n        if (i === substitutions.length - 1 && substitutions[i]) {\n            var definedValues = substitutions.filter(function(substitute) {\n                return !!substitute;\n            });\n            // Adds leading coma if properties preceed color-stops\n            if (definedValues.length > 1) {\n                template = template.slice(0, -1);\n                template += \", \" + substitutions[i];\n            // No trailing space if color-stops is the only param provided\n            } else if (definedValues.length === 1) {\n                template += \"\" + substitutions[i];\n            }\n        } else if (substitutions[i]) {\n            template += substitutions[i] + \" \";\n        }\n    }\n    return template.trim();\n}\nvar _templateObject$1;\n/**\n * CSS for declaring a linear gradient, including a fallback background-color. The fallback is either the first color-stop or an explicitly passed fallback color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...linearGradient({\n        colorStops: ['#00FFFF 0%', 'rgba(0, 0, 255, 0) 50%', '#0000FF 95%'],\n        toDirection: 'to top right',\n        fallback: '#FFF',\n      })\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${linearGradient({\n        colorStops: ['#00FFFF 0%', 'rgba(0, 0, 255, 0) 50%', '#0000FF 95%'],\n        toDirection: 'to top right',\n        fallback: '#FFF',\n      })}\n *`\n *\n * // CSS as JS Output\n *\n * div: {\n *   'backgroundColor': '#FFF',\n *   'backgroundImage': 'linear-gradient(to top right, #00FFFF 0%, rgba(0, 0, 255, 0) 50%, #0000FF 95%)',\n * }\n */ function linearGradient(_ref) {\n    var colorStops = _ref.colorStops, fallback = _ref.fallback, _ref$toDirection = _ref.toDirection, toDirection = _ref$toDirection === void 0 ? \"\" : _ref$toDirection;\n    if (!colorStops || colorStops.length < 2) {\n        throw new PolishedError(56);\n    }\n    return {\n        backgroundColor: fallback || colorStops[0].replace(/,\\s+/g, \",\").split(\" \")[0].replace(/,(?=\\S)/g, \", \"),\n        backgroundImage: constructGradientValue(_templateObject$1 || (_templateObject$1 = (0,_babel_runtime_helpers_esm_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_4__[\"default\"])([\n            \"linear-gradient(\",\n            \"\",\n            \")\"\n        ])), toDirection, colorStops.join(\", \").replace(/,(?=\\S)/g, \", \"))\n    };\n}\n/**\n * CSS to normalize abnormalities across browsers (normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css)\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *    ...normalize(),\n * }\n *\n * // styled-components usage\n * const GlobalStyle = createGlobalStyle`${normalize()}`\n *\n * // CSS as JS Output\n *\n * html {\n *   lineHeight: 1.15,\n *   textSizeAdjust: 100%,\n * } ...\n */ function normalize() {\n    var _ref;\n    return [\n        (_ref = {\n            html: {\n                lineHeight: \"1.15\",\n                textSizeAdjust: \"100%\"\n            },\n            body: {\n                margin: \"0\"\n            },\n            main: {\n                display: \"block\"\n            },\n            h1: {\n                fontSize: \"2em\",\n                margin: \"0.67em 0\"\n            },\n            hr: {\n                boxSizing: \"content-box\",\n                height: \"0\",\n                overflow: \"visible\"\n            },\n            pre: {\n                fontFamily: \"monospace, monospace\",\n                fontSize: \"1em\"\n            },\n            a: {\n                backgroundColor: \"transparent\"\n            },\n            \"abbr[title]\": {\n                borderBottom: \"none\",\n                textDecoration: \"underline\"\n            }\n        }, _ref[\"b,\\n    strong\"] = {\n            fontWeight: \"bolder\"\n        }, _ref[\"code,\\n    kbd,\\n    samp\"] = {\n            fontFamily: \"monospace, monospace\",\n            fontSize: \"1em\"\n        }, _ref.small = {\n            fontSize: \"80%\"\n        }, _ref[\"sub,\\n    sup\"] = {\n            fontSize: \"75%\",\n            lineHeight: \"0\",\n            position: \"relative\",\n            verticalAlign: \"baseline\"\n        }, _ref.sub = {\n            bottom: \"-0.25em\"\n        }, _ref.sup = {\n            top: \"-0.5em\"\n        }, _ref.img = {\n            borderStyle: \"none\"\n        }, _ref[\"button,\\n    input,\\n    optgroup,\\n    select,\\n    textarea\"] = {\n            fontFamily: \"inherit\",\n            fontSize: \"100%\",\n            lineHeight: \"1.15\",\n            margin: \"0\"\n        }, _ref[\"button,\\n    input\"] = {\n            overflow: \"visible\"\n        }, _ref[\"button,\\n    select\"] = {\n            textTransform: \"none\"\n        }, _ref['button,\\n    html [type=\"button\"],\\n    [type=\"reset\"],\\n    [type=\"submit\"]'] = {\n            WebkitAppearance: \"button\"\n        }, _ref['button::-moz-focus-inner,\\n    [type=\"button\"]::-moz-focus-inner,\\n    [type=\"reset\"]::-moz-focus-inner,\\n    [type=\"submit\"]::-moz-focus-inner'] = {\n            borderStyle: \"none\",\n            padding: \"0\"\n        }, _ref['button:-moz-focusring,\\n    [type=\"button\"]:-moz-focusring,\\n    [type=\"reset\"]:-moz-focusring,\\n    [type=\"submit\"]:-moz-focusring'] = {\n            outline: \"1px dotted ButtonText\"\n        }, _ref.fieldset = {\n            padding: \"0.35em 0.625em 0.75em\"\n        }, _ref.legend = {\n            boxSizing: \"border-box\",\n            color: \"inherit\",\n            display: \"table\",\n            maxWidth: \"100%\",\n            padding: \"0\",\n            whiteSpace: \"normal\"\n        }, _ref.progress = {\n            verticalAlign: \"baseline\"\n        }, _ref.textarea = {\n            overflow: \"auto\"\n        }, _ref['[type=\"checkbox\"],\\n    [type=\"radio\"]'] = {\n            boxSizing: \"border-box\",\n            padding: \"0\"\n        }, _ref['[type=\"number\"]::-webkit-inner-spin-button,\\n    [type=\"number\"]::-webkit-outer-spin-button'] = {\n            height: \"auto\"\n        }, _ref['[type=\"search\"]'] = {\n            WebkitAppearance: \"textfield\",\n            outlineOffset: \"-2px\"\n        }, _ref['[type=\"search\"]::-webkit-search-decoration'] = {\n            WebkitAppearance: \"none\"\n        }, _ref[\"::-webkit-file-upload-button\"] = {\n            WebkitAppearance: \"button\",\n            font: \"inherit\"\n        }, _ref.details = {\n            display: \"block\"\n        }, _ref.summary = {\n            display: \"list-item\"\n        }, _ref.template = {\n            display: \"none\"\n        }, _ref[\"[hidden]\"] = {\n            display: \"none\"\n        }, _ref),\n        {\n            \"abbr[title]\": {\n                textDecoration: \"underline dotted\"\n            }\n        }\n    ];\n}\nvar _templateObject;\n/**\n * CSS for declaring a radial gradient, including a fallback background-color. The fallback is either the first color-stop or an explicitly passed fallback color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...radialGradient({\n *     colorStops: ['#00FFFF 0%', 'rgba(0, 0, 255, 0) 50%', '#0000FF 95%'],\n *     extent: 'farthest-corner at 45px 45px',\n *     position: 'center',\n *     shape: 'ellipse',\n *   })\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${radialGradient({\n *     colorStops: ['#00FFFF 0%', 'rgba(0, 0, 255, 0) 50%', '#0000FF 95%'],\n *     extent: 'farthest-corner at 45px 45px',\n *     position: 'center',\n *     shape: 'ellipse',\n *   })}\n *`\n *\n * // CSS as JS Output\n *\n * div: {\n *   'backgroundColor': '#00FFFF',\n *   'backgroundImage': 'radial-gradient(center ellipse farthest-corner at 45px 45px, #00FFFF 0%, rgba(0, 0, 255, 0) 50%, #0000FF 95%)',\n * }\n */ function radialGradient(_ref) {\n    var colorStops = _ref.colorStops, _ref$extent = _ref.extent, extent = _ref$extent === void 0 ? \"\" : _ref$extent, fallback = _ref.fallback, _ref$position = _ref.position, position = _ref$position === void 0 ? \"\" : _ref$position, _ref$shape = _ref.shape, shape = _ref$shape === void 0 ? \"\" : _ref$shape;\n    if (!colorStops || colorStops.length < 2) {\n        throw new PolishedError(57);\n    }\n    return {\n        backgroundColor: fallback || colorStops[0].split(\" \")[0],\n        backgroundImage: constructGradientValue(_templateObject || (_templateObject = (0,_babel_runtime_helpers_esm_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_4__[\"default\"])([\n            \"radial-gradient(\",\n            \"\",\n            \"\",\n            \"\",\n            \")\"\n        ])), position, shape, extent, colorStops.join(\", \"))\n    };\n}\n/**\n * A helper to generate a retina background image and non-retina\n * background image. The retina background image will output to a HiDPI media query. The mixin uses\n * a _2x.png filename suffix by default.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *  ...retinaImage('my-img')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${retinaImage('my-img')}\n * `\n *\n * // CSS as JS Output\n * div {\n *   backgroundImage: 'url(my-img.png)',\n *   '@media only screen and (-webkit-min-device-pixel-ratio: 1.3),\n *    only screen and (min--moz-device-pixel-ratio: 1.3),\n *    only screen and (-o-min-device-pixel-ratio: 1.3/1),\n *    only screen and (min-resolution: 144dpi),\n *    only screen and (min-resolution: 1.5dppx)': {\n *     backgroundImage: 'url(my-img_2x.png)',\n *   }\n * }\n */ function retinaImage(filename, backgroundSize, extension, retinaFilename, retinaSuffix) {\n    var _ref;\n    if (extension === void 0) {\n        extension = \"png\";\n    }\n    if (retinaSuffix === void 0) {\n        retinaSuffix = \"_2x\";\n    }\n    if (!filename) {\n        throw new PolishedError(58);\n    }\n    // Replace the dot at the beginning of the passed extension if one exists\n    var ext = extension.replace(/^\\./, \"\");\n    var rFilename = retinaFilename ? retinaFilename + \".\" + ext : \"\" + filename + retinaSuffix + \".\" + ext;\n    return _ref = {\n        backgroundImage: \"url(\" + filename + \".\" + ext + \")\"\n    }, _ref[hiDPI()] = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        backgroundImage: \"url(\" + rFilename + \")\"\n    }, backgroundSize ? {\n        backgroundSize: backgroundSize\n    } : {}), _ref;\n}\n/* eslint-disable key-spacing */ var functionsMap = {\n    easeInBack: \"cubic-bezier(0.600, -0.280, 0.735, 0.045)\",\n    easeInCirc: \"cubic-bezier(0.600,  0.040, 0.980, 0.335)\",\n    easeInCubic: \"cubic-bezier(0.550,  0.055, 0.675, 0.190)\",\n    easeInExpo: \"cubic-bezier(0.950,  0.050, 0.795, 0.035)\",\n    easeInQuad: \"cubic-bezier(0.550,  0.085, 0.680, 0.530)\",\n    easeInQuart: \"cubic-bezier(0.895,  0.030, 0.685, 0.220)\",\n    easeInQuint: \"cubic-bezier(0.755,  0.050, 0.855, 0.060)\",\n    easeInSine: \"cubic-bezier(0.470,  0.000, 0.745, 0.715)\",\n    easeOutBack: \"cubic-bezier(0.175,  0.885, 0.320, 1.275)\",\n    easeOutCubic: \"cubic-bezier(0.215,  0.610, 0.355, 1.000)\",\n    easeOutCirc: \"cubic-bezier(0.075,  0.820, 0.165, 1.000)\",\n    easeOutExpo: \"cubic-bezier(0.190,  1.000, 0.220, 1.000)\",\n    easeOutQuad: \"cubic-bezier(0.250,  0.460, 0.450, 0.940)\",\n    easeOutQuart: \"cubic-bezier(0.165,  0.840, 0.440, 1.000)\",\n    easeOutQuint: \"cubic-bezier(0.230,  1.000, 0.320, 1.000)\",\n    easeOutSine: \"cubic-bezier(0.390,  0.575, 0.565, 1.000)\",\n    easeInOutBack: \"cubic-bezier(0.680, -0.550, 0.265, 1.550)\",\n    easeInOutCirc: \"cubic-bezier(0.785,  0.135, 0.150, 0.860)\",\n    easeInOutCubic: \"cubic-bezier(0.645,  0.045, 0.355, 1.000)\",\n    easeInOutExpo: \"cubic-bezier(1.000,  0.000, 0.000, 1.000)\",\n    easeInOutQuad: \"cubic-bezier(0.455,  0.030, 0.515, 0.955)\",\n    easeInOutQuart: \"cubic-bezier(0.770,  0.000, 0.175, 1.000)\",\n    easeInOutQuint: \"cubic-bezier(0.860,  0.000, 0.070, 1.000)\",\n    easeInOutSine: \"cubic-bezier(0.445,  0.050, 0.550, 0.950)\"\n};\n/* eslint-enable key-spacing */ function getTimingFunction(functionName) {\n    return functionsMap[functionName];\n}\n/**\n * String to represent common easing functions as demonstrated here: (github.com/jaukia/easie).\n *\n * @deprecated - This will be deprecated in v5 in favor of `easeIn`, `easeOut`, `easeInOut`.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   'transitionTimingFunction': timingFunctions('easeInQuad')\n * }\n *\n * // styled-components usage\n *  const div = styled.div`\n *   transitionTimingFunction: ${timingFunctions('easeInQuad')};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'transitionTimingFunction': 'cubic-bezier(0.550,  0.085, 0.680, 0.530)',\n * }\n */ function timingFunctions(timingFunction) {\n    return getTimingFunction(timingFunction);\n}\nvar getBorderWidth = function getBorderWidth(pointingDirection, height, width) {\n    var fullWidth = \"\" + width[0] + (width[1] || \"\");\n    var halfWidth = \"\" + width[0] / 2 + (width[1] || \"\");\n    var fullHeight = \"\" + height[0] + (height[1] || \"\");\n    var halfHeight = \"\" + height[0] / 2 + (height[1] || \"\");\n    switch(pointingDirection){\n        case \"top\":\n            return \"0 \" + halfWidth + \" \" + fullHeight + \" \" + halfWidth;\n        case \"topLeft\":\n            return fullWidth + \" \" + fullHeight + \" 0 0\";\n        case \"left\":\n            return halfHeight + \" \" + fullWidth + \" \" + halfHeight + \" 0\";\n        case \"bottomLeft\":\n            return fullWidth + \" 0 0 \" + fullHeight;\n        case \"bottom\":\n            return fullHeight + \" \" + halfWidth + \" 0 \" + halfWidth;\n        case \"bottomRight\":\n            return \"0 0 \" + fullWidth + \" \" + fullHeight;\n        case \"right\":\n            return halfHeight + \" 0 \" + halfHeight + \" \" + fullWidth;\n        case \"topRight\":\n        default:\n            return \"0 \" + fullWidth + \" \" + fullHeight + \" 0\";\n    }\n};\nvar getBorderColor = function getBorderColor(pointingDirection, foregroundColor) {\n    switch(pointingDirection){\n        case \"top\":\n        case \"bottomRight\":\n            return {\n                borderBottomColor: foregroundColor\n            };\n        case \"right\":\n        case \"bottomLeft\":\n            return {\n                borderLeftColor: foregroundColor\n            };\n        case \"bottom\":\n        case \"topLeft\":\n            return {\n                borderTopColor: foregroundColor\n            };\n        case \"left\":\n        case \"topRight\":\n            return {\n                borderRightColor: foregroundColor\n            };\n        default:\n            throw new PolishedError(59);\n    }\n};\n/**\n * CSS to represent triangle with any pointing direction with an optional background color.\n *\n * @example\n * // Styles as object usage\n *\n * const styles = {\n *   ...triangle({ pointingDirection: 'right', width: '100px', height: '100px', foregroundColor: 'red' })\n * }\n *\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${triangle({ pointingDirection: 'right', width: '100px', height: '100px', foregroundColor: 'red' })}\n *\n *\n * // CSS as JS Output\n *\n * div: {\n *  'borderColor': 'transparent transparent transparent red',\n *  'borderStyle': 'solid',\n *  'borderWidth': '50px 0 50px 100px',\n *  'height': '0',\n *  'width': '0',\n * }\n */ function triangle(_ref) {\n    var pointingDirection = _ref.pointingDirection, height = _ref.height, width = _ref.width, foregroundColor = _ref.foregroundColor, _ref$backgroundColor = _ref.backgroundColor, backgroundColor = _ref$backgroundColor === void 0 ? \"transparent\" : _ref$backgroundColor;\n    var widthAndUnit = getValueAndUnit(width);\n    var heightAndUnit = getValueAndUnit(height);\n    if (isNaN(heightAndUnit[0]) || isNaN(widthAndUnit[0])) {\n        throw new PolishedError(60);\n    }\n    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        width: \"0\",\n        height: \"0\",\n        borderColor: backgroundColor\n    }, getBorderColor(pointingDirection, foregroundColor), {\n        borderStyle: \"solid\",\n        borderWidth: getBorderWidth(pointingDirection, heightAndUnit, widthAndUnit)\n    });\n}\n/**\n * Provides an easy way to change the `wordWrap` property.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...wordWrap('break-word')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${wordWrap('break-word')}\n * `\n *\n * // CSS as JS Output\n *\n * const styles = {\n *   overflowWrap: 'break-word',\n *   wordWrap: 'break-word',\n *   wordBreak: 'break-all',\n * }\n */ function wordWrap(wrap) {\n    if (wrap === void 0) {\n        wrap = \"break-word\";\n    }\n    var wordBreak = wrap === \"break-word\" ? \"break-all\" : wrap;\n    return {\n        overflowWrap: wrap,\n        wordWrap: wrap,\n        wordBreak: wordBreak\n    };\n}\nfunction colorToInt(color) {\n    return Math.round(color * 255);\n}\nfunction convertToInt(red, green, blue) {\n    return colorToInt(red) + \",\" + colorToInt(green) + \",\" + colorToInt(blue);\n}\nfunction hslToRgb(hue, saturation, lightness, convert) {\n    if (convert === void 0) {\n        convert = convertToInt;\n    }\n    if (saturation === 0) {\n        // achromatic\n        return convert(lightness, lightness, lightness);\n    }\n    // formulae from https://en.wikipedia.org/wiki/HSL_and_HSV\n    var huePrime = (hue % 360 + 360) % 360 / 60;\n    var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;\n    var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));\n    var red = 0;\n    var green = 0;\n    var blue = 0;\n    if (huePrime >= 0 && huePrime < 1) {\n        red = chroma;\n        green = secondComponent;\n    } else if (huePrime >= 1 && huePrime < 2) {\n        red = secondComponent;\n        green = chroma;\n    } else if (huePrime >= 2 && huePrime < 3) {\n        green = chroma;\n        blue = secondComponent;\n    } else if (huePrime >= 3 && huePrime < 4) {\n        green = secondComponent;\n        blue = chroma;\n    } else if (huePrime >= 4 && huePrime < 5) {\n        red = secondComponent;\n        blue = chroma;\n    } else if (huePrime >= 5 && huePrime < 6) {\n        red = chroma;\n        blue = secondComponent;\n    }\n    var lightnessModification = lightness - chroma / 2;\n    var finalRed = red + lightnessModification;\n    var finalGreen = green + lightnessModification;\n    var finalBlue = blue + lightnessModification;\n    return convert(finalRed, finalGreen, finalBlue);\n}\nvar namedColorMap = {\n    aliceblue: \"f0f8ff\",\n    antiquewhite: \"faebd7\",\n    aqua: \"00ffff\",\n    aquamarine: \"7fffd4\",\n    azure: \"f0ffff\",\n    beige: \"f5f5dc\",\n    bisque: \"ffe4c4\",\n    black: \"000\",\n    blanchedalmond: \"ffebcd\",\n    blue: \"0000ff\",\n    blueviolet: \"8a2be2\",\n    brown: \"a52a2a\",\n    burlywood: \"deb887\",\n    cadetblue: \"5f9ea0\",\n    chartreuse: \"7fff00\",\n    chocolate: \"d2691e\",\n    coral: \"ff7f50\",\n    cornflowerblue: \"6495ed\",\n    cornsilk: \"fff8dc\",\n    crimson: \"dc143c\",\n    cyan: \"00ffff\",\n    darkblue: \"00008b\",\n    darkcyan: \"008b8b\",\n    darkgoldenrod: \"b8860b\",\n    darkgray: \"a9a9a9\",\n    darkgreen: \"006400\",\n    darkgrey: \"a9a9a9\",\n    darkkhaki: \"bdb76b\",\n    darkmagenta: \"8b008b\",\n    darkolivegreen: \"556b2f\",\n    darkorange: \"ff8c00\",\n    darkorchid: \"9932cc\",\n    darkred: \"8b0000\",\n    darksalmon: \"e9967a\",\n    darkseagreen: \"8fbc8f\",\n    darkslateblue: \"483d8b\",\n    darkslategray: \"2f4f4f\",\n    darkslategrey: \"2f4f4f\",\n    darkturquoise: \"00ced1\",\n    darkviolet: \"9400d3\",\n    deeppink: \"ff1493\",\n    deepskyblue: \"00bfff\",\n    dimgray: \"696969\",\n    dimgrey: \"696969\",\n    dodgerblue: \"1e90ff\",\n    firebrick: \"b22222\",\n    floralwhite: \"fffaf0\",\n    forestgreen: \"228b22\",\n    fuchsia: \"ff00ff\",\n    gainsboro: \"dcdcdc\",\n    ghostwhite: \"f8f8ff\",\n    gold: \"ffd700\",\n    goldenrod: \"daa520\",\n    gray: \"808080\",\n    green: \"008000\",\n    greenyellow: \"adff2f\",\n    grey: \"808080\",\n    honeydew: \"f0fff0\",\n    hotpink: \"ff69b4\",\n    indianred: \"cd5c5c\",\n    indigo: \"4b0082\",\n    ivory: \"fffff0\",\n    khaki: \"f0e68c\",\n    lavender: \"e6e6fa\",\n    lavenderblush: \"fff0f5\",\n    lawngreen: \"7cfc00\",\n    lemonchiffon: \"fffacd\",\n    lightblue: \"add8e6\",\n    lightcoral: \"f08080\",\n    lightcyan: \"e0ffff\",\n    lightgoldenrodyellow: \"fafad2\",\n    lightgray: \"d3d3d3\",\n    lightgreen: \"90ee90\",\n    lightgrey: \"d3d3d3\",\n    lightpink: \"ffb6c1\",\n    lightsalmon: \"ffa07a\",\n    lightseagreen: \"20b2aa\",\n    lightskyblue: \"87cefa\",\n    lightslategray: \"789\",\n    lightslategrey: \"789\",\n    lightsteelblue: \"b0c4de\",\n    lightyellow: \"ffffe0\",\n    lime: \"0f0\",\n    limegreen: \"32cd32\",\n    linen: \"faf0e6\",\n    magenta: \"f0f\",\n    maroon: \"800000\",\n    mediumaquamarine: \"66cdaa\",\n    mediumblue: \"0000cd\",\n    mediumorchid: \"ba55d3\",\n    mediumpurple: \"9370db\",\n    mediumseagreen: \"3cb371\",\n    mediumslateblue: \"7b68ee\",\n    mediumspringgreen: \"00fa9a\",\n    mediumturquoise: \"48d1cc\",\n    mediumvioletred: \"c71585\",\n    midnightblue: \"191970\",\n    mintcream: \"f5fffa\",\n    mistyrose: \"ffe4e1\",\n    moccasin: \"ffe4b5\",\n    navajowhite: \"ffdead\",\n    navy: \"000080\",\n    oldlace: \"fdf5e6\",\n    olive: \"808000\",\n    olivedrab: \"6b8e23\",\n    orange: \"ffa500\",\n    orangered: \"ff4500\",\n    orchid: \"da70d6\",\n    palegoldenrod: \"eee8aa\",\n    palegreen: \"98fb98\",\n    paleturquoise: \"afeeee\",\n    palevioletred: \"db7093\",\n    papayawhip: \"ffefd5\",\n    peachpuff: \"ffdab9\",\n    peru: \"cd853f\",\n    pink: \"ffc0cb\",\n    plum: \"dda0dd\",\n    powderblue: \"b0e0e6\",\n    purple: \"800080\",\n    rebeccapurple: \"639\",\n    red: \"f00\",\n    rosybrown: \"bc8f8f\",\n    royalblue: \"4169e1\",\n    saddlebrown: \"8b4513\",\n    salmon: \"fa8072\",\n    sandybrown: \"f4a460\",\n    seagreen: \"2e8b57\",\n    seashell: \"fff5ee\",\n    sienna: \"a0522d\",\n    silver: \"c0c0c0\",\n    skyblue: \"87ceeb\",\n    slateblue: \"6a5acd\",\n    slategray: \"708090\",\n    slategrey: \"708090\",\n    snow: \"fffafa\",\n    springgreen: \"00ff7f\",\n    steelblue: \"4682b4\",\n    tan: \"d2b48c\",\n    teal: \"008080\",\n    thistle: \"d8bfd8\",\n    tomato: \"ff6347\",\n    turquoise: \"40e0d0\",\n    violet: \"ee82ee\",\n    wheat: \"f5deb3\",\n    white: \"fff\",\n    whitesmoke: \"f5f5f5\",\n    yellow: \"ff0\",\n    yellowgreen: \"9acd32\"\n};\n/**\n * Checks if a string is a CSS named color and returns its equivalent hex value, otherwise returns the original color.\n * @private\n */ function nameToHex(color) {\n    if (typeof color !== \"string\") return color;\n    var normalizedColorName = color.toLowerCase();\n    return namedColorMap[normalizedColorName] ? \"#\" + namedColorMap[normalizedColorName] : color;\n}\nvar hexRegex = /^#[a-fA-F0-9]{6}$/;\nvar hexRgbaRegex = /^#[a-fA-F0-9]{8}$/;\nvar reducedHexRegex = /^#[a-fA-F0-9]{3}$/;\nvar reducedRgbaHexRegex = /^#[a-fA-F0-9]{4}$/;\nvar rgbRegex = /^rgb\\(\\s*(\\d{1,3})\\s*(?:,)?\\s*(\\d{1,3})\\s*(?:,)?\\s*(\\d{1,3})\\s*\\)$/i;\nvar rgbaRegex = /^rgb(?:a)?\\(\\s*(\\d{1,3})\\s*(?:,)?\\s*(\\d{1,3})\\s*(?:,)?\\s*(\\d{1,3})\\s*(?:,|\\/)\\s*([-+]?\\d*[.]?\\d+[%]?)\\s*\\)$/i;\nvar hslRegex = /^hsl\\(\\s*(\\d{0,3}[.]?[0-9]+(?:deg)?)\\s*(?:,)?\\s*(\\d{1,3}[.]?[0-9]?)%\\s*(?:,)?\\s*(\\d{1,3}[.]?[0-9]?)%\\s*\\)$/i;\nvar hslaRegex = /^hsl(?:a)?\\(\\s*(\\d{0,3}[.]?[0-9]+(?:deg)?)\\s*(?:,)?\\s*(\\d{1,3}[.]?[0-9]?)%\\s*(?:,)?\\s*(\\d{1,3}[.]?[0-9]?)%\\s*(?:,|\\/)\\s*([-+]?\\d*[.]?\\d+[%]?)\\s*\\)$/i;\n/**\n * Returns an RgbColor or RgbaColor object. This utility function is only useful\n * if want to extract a color component. With the color util `toColorString` you\n * can convert a RgbColor or RgbaColor object back to a string.\n *\n * @example\n * // Assigns `{ red: 255, green: 0, blue: 0 }` to color1\n * const color1 = parseToRgb('rgb(255, 0, 0)');\n * // Assigns `{ red: 92, green: 102, blue: 112, alpha: 0.75 }` to color2\n * const color2 = parseToRgb('hsla(210, 10%, 40%, 0.75)');\n */ function parseToRgb(color) {\n    if (typeof color !== \"string\") {\n        throw new PolishedError(3);\n    }\n    var normalizedColor = nameToHex(color);\n    if (normalizedColor.match(hexRegex)) {\n        return {\n            red: parseInt(\"\" + normalizedColor[1] + normalizedColor[2], 16),\n            green: parseInt(\"\" + normalizedColor[3] + normalizedColor[4], 16),\n            blue: parseInt(\"\" + normalizedColor[5] + normalizedColor[6], 16)\n        };\n    }\n    if (normalizedColor.match(hexRgbaRegex)) {\n        var alpha = parseFloat((parseInt(\"\" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));\n        return {\n            red: parseInt(\"\" + normalizedColor[1] + normalizedColor[2], 16),\n            green: parseInt(\"\" + normalizedColor[3] + normalizedColor[4], 16),\n            blue: parseInt(\"\" + normalizedColor[5] + normalizedColor[6], 16),\n            alpha: alpha\n        };\n    }\n    if (normalizedColor.match(reducedHexRegex)) {\n        return {\n            red: parseInt(\"\" + normalizedColor[1] + normalizedColor[1], 16),\n            green: parseInt(\"\" + normalizedColor[2] + normalizedColor[2], 16),\n            blue: parseInt(\"\" + normalizedColor[3] + normalizedColor[3], 16)\n        };\n    }\n    if (normalizedColor.match(reducedRgbaHexRegex)) {\n        var _alpha = parseFloat((parseInt(\"\" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));\n        return {\n            red: parseInt(\"\" + normalizedColor[1] + normalizedColor[1], 16),\n            green: parseInt(\"\" + normalizedColor[2] + normalizedColor[2], 16),\n            blue: parseInt(\"\" + normalizedColor[3] + normalizedColor[3], 16),\n            alpha: _alpha\n        };\n    }\n    var rgbMatched = rgbRegex.exec(normalizedColor);\n    if (rgbMatched) {\n        return {\n            red: parseInt(\"\" + rgbMatched[1], 10),\n            green: parseInt(\"\" + rgbMatched[2], 10),\n            blue: parseInt(\"\" + rgbMatched[3], 10)\n        };\n    }\n    var rgbaMatched = rgbaRegex.exec(normalizedColor.substring(0, 50));\n    if (rgbaMatched) {\n        return {\n            red: parseInt(\"\" + rgbaMatched[1], 10),\n            green: parseInt(\"\" + rgbaMatched[2], 10),\n            blue: parseInt(\"\" + rgbaMatched[3], 10),\n            alpha: parseFloat(\"\" + rgbaMatched[4]) > 1 ? parseFloat(\"\" + rgbaMatched[4]) / 100 : parseFloat(\"\" + rgbaMatched[4])\n        };\n    }\n    var hslMatched = hslRegex.exec(normalizedColor);\n    if (hslMatched) {\n        var hue = parseInt(\"\" + hslMatched[1], 10);\n        var saturation = parseInt(\"\" + hslMatched[2], 10) / 100;\n        var lightness = parseInt(\"\" + hslMatched[3], 10) / 100;\n        var rgbColorString = \"rgb(\" + hslToRgb(hue, saturation, lightness) + \")\";\n        var hslRgbMatched = rgbRegex.exec(rgbColorString);\n        if (!hslRgbMatched) {\n            throw new PolishedError(4, normalizedColor, rgbColorString);\n        }\n        return {\n            red: parseInt(\"\" + hslRgbMatched[1], 10),\n            green: parseInt(\"\" + hslRgbMatched[2], 10),\n            blue: parseInt(\"\" + hslRgbMatched[3], 10)\n        };\n    }\n    var hslaMatched = hslaRegex.exec(normalizedColor.substring(0, 50));\n    if (hslaMatched) {\n        var _hue = parseInt(\"\" + hslaMatched[1], 10);\n        var _saturation = parseInt(\"\" + hslaMatched[2], 10) / 100;\n        var _lightness = parseInt(\"\" + hslaMatched[3], 10) / 100;\n        var _rgbColorString = \"rgb(\" + hslToRgb(_hue, _saturation, _lightness) + \")\";\n        var _hslRgbMatched = rgbRegex.exec(_rgbColorString);\n        if (!_hslRgbMatched) {\n            throw new PolishedError(4, normalizedColor, _rgbColorString);\n        }\n        return {\n            red: parseInt(\"\" + _hslRgbMatched[1], 10),\n            green: parseInt(\"\" + _hslRgbMatched[2], 10),\n            blue: parseInt(\"\" + _hslRgbMatched[3], 10),\n            alpha: parseFloat(\"\" + hslaMatched[4]) > 1 ? parseFloat(\"\" + hslaMatched[4]) / 100 : parseFloat(\"\" + hslaMatched[4])\n        };\n    }\n    throw new PolishedError(5);\n}\nfunction rgbToHsl(color) {\n    // make sure rgb are contained in a set of [0, 255]\n    var red = color.red / 255;\n    var green = color.green / 255;\n    var blue = color.blue / 255;\n    var max = Math.max(red, green, blue);\n    var min = Math.min(red, green, blue);\n    var lightness = (max + min) / 2;\n    if (max === min) {\n        // achromatic\n        if (color.alpha !== undefined) {\n            return {\n                hue: 0,\n                saturation: 0,\n                lightness: lightness,\n                alpha: color.alpha\n            };\n        } else {\n            return {\n                hue: 0,\n                saturation: 0,\n                lightness: lightness\n            };\n        }\n    }\n    var hue;\n    var delta = max - min;\n    var saturation = lightness > 0.5 ? delta / (2 - max - min) : delta / (max + min);\n    switch(max){\n        case red:\n            hue = (green - blue) / delta + (green < blue ? 6 : 0);\n            break;\n        case green:\n            hue = (blue - red) / delta + 2;\n            break;\n        default:\n            // blue case\n            hue = (red - green) / delta + 4;\n            break;\n    }\n    hue *= 60;\n    if (color.alpha !== undefined) {\n        return {\n            hue: hue,\n            saturation: saturation,\n            lightness: lightness,\n            alpha: color.alpha\n        };\n    }\n    return {\n        hue: hue,\n        saturation: saturation,\n        lightness: lightness\n    };\n}\n/**\n * Returns an HslColor or HslaColor object. This utility function is only useful\n * if want to extract a color component. With the color util `toColorString` you\n * can convert a HslColor or HslaColor object back to a string.\n *\n * @example\n * // Assigns `{ hue: 0, saturation: 1, lightness: 0.5 }` to color1\n * const color1 = parseToHsl('rgb(255, 0, 0)');\n * // Assigns `{ hue: 128, saturation: 1, lightness: 0.5, alpha: 0.75 }` to color2\n * const color2 = parseToHsl('hsla(128, 100%, 50%, 0.75)');\n */ function parseToHsl(color) {\n    // Note: At a later stage we can optimize this function as right now a hsl\n    // color would be parsed converted to rgb values and converted back to hsl.\n    return rgbToHsl(parseToRgb(color));\n}\n/**\n * Reduces hex values if possible e.g. #ff8866 to #f86\n * @private\n */ var reduceHexValue = function reduceHexValue(value) {\n    if (value.length === 7 && value[1] === value[2] && value[3] === value[4] && value[5] === value[6]) {\n        return \"#\" + value[1] + value[3] + value[5];\n    }\n    return value;\n};\nvar reduceHexValue$1 = reduceHexValue;\nfunction numberToHex(value) {\n    var hex = value.toString(16);\n    return hex.length === 1 ? \"0\" + hex : hex;\n}\nfunction colorToHex(color) {\n    return numberToHex(Math.round(color * 255));\n}\nfunction convertToHex(red, green, blue) {\n    return reduceHexValue$1(\"#\" + colorToHex(red) + colorToHex(green) + colorToHex(blue));\n}\nfunction hslToHex(hue, saturation, lightness) {\n    return hslToRgb(hue, saturation, lightness, convertToHex);\n}\n/**\n * Returns a string value for the color. The returned result is the smallest possible hex notation.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: hsl(359, 0.75, 0.4),\n *   background: hsl({ hue: 360, saturation: 0.75, lightness: 0.4 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${hsl(359, 0.75, 0.4)};\n *   background: ${hsl({ hue: 360, saturation: 0.75, lightness: 0.4 })};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#b3191c\";\n *   background: \"#b3191c\";\n * }\n */ function hsl(value, saturation, lightness) {\n    if (typeof value === \"number\" && typeof saturation === \"number\" && typeof lightness === \"number\") {\n        return hslToHex(value, saturation, lightness);\n    } else if (typeof value === \"object\" && saturation === undefined && lightness === undefined) {\n        return hslToHex(value.hue, value.saturation, value.lightness);\n    }\n    throw new PolishedError(1);\n}\n/**\n * Returns a string value for the color. The returned result is the smallest possible rgba or hex notation.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: hsla(359, 0.75, 0.4, 0.7),\n *   background: hsla({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0,7 }),\n *   background: hsla(359, 0.75, 0.4, 1),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${hsla(359, 0.75, 0.4, 0.7)};\n *   background: ${hsla({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0,7 })};\n *   background: ${hsla(359, 0.75, 0.4, 1)};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"rgba(179,25,28,0.7)\";\n *   background: \"rgba(179,25,28,0.7)\";\n *   background: \"#b3191c\";\n * }\n */ function hsla(value, saturation, lightness, alpha) {\n    if (typeof value === \"number\" && typeof saturation === \"number\" && typeof lightness === \"number\" && typeof alpha === \"number\") {\n        return alpha >= 1 ? hslToHex(value, saturation, lightness) : \"rgba(\" + hslToRgb(value, saturation, lightness) + \",\" + alpha + \")\";\n    } else if (typeof value === \"object\" && saturation === undefined && lightness === undefined && alpha === undefined) {\n        return value.alpha >= 1 ? hslToHex(value.hue, value.saturation, value.lightness) : \"rgba(\" + hslToRgb(value.hue, value.saturation, value.lightness) + \",\" + value.alpha + \")\";\n    }\n    throw new PolishedError(2);\n}\n/**\n * Returns a string value for the color. The returned result is the smallest possible hex notation.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: rgb(255, 205, 100),\n *   background: rgb({ red: 255, green: 205, blue: 100 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${rgb(255, 205, 100)};\n *   background: ${rgb({ red: 255, green: 205, blue: 100 })};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#ffcd64\";\n *   background: \"#ffcd64\";\n * }\n */ function rgb(value, green, blue) {\n    if (typeof value === \"number\" && typeof green === \"number\" && typeof blue === \"number\") {\n        return reduceHexValue$1(\"#\" + numberToHex(value) + numberToHex(green) + numberToHex(blue));\n    } else if (typeof value === \"object\" && green === undefined && blue === undefined) {\n        return reduceHexValue$1(\"#\" + numberToHex(value.red) + numberToHex(value.green) + numberToHex(value.blue));\n    }\n    throw new PolishedError(6);\n}\n/**\n * Returns a string value for the color. The returned result is the smallest possible rgba or hex notation.\n *\n * Can also be used to fade a color by passing a hex value or named CSS color along with an alpha value.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: rgba(255, 205, 100, 0.7),\n *   background: rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 }),\n *   background: rgba(255, 205, 100, 1),\n *   background: rgba('#ffffff', 0.4),\n *   background: rgba('black', 0.7),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${rgba(255, 205, 100, 0.7)};\n *   background: ${rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 })};\n *   background: ${rgba(255, 205, 100, 1)};\n *   background: ${rgba('#ffffff', 0.4)};\n *   background: ${rgba('black', 0.7)};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"rgba(255,205,100,0.7)\";\n *   background: \"rgba(255,205,100,0.7)\";\n *   background: \"#ffcd64\";\n *   background: \"rgba(255,255,255,0.4)\";\n *   background: \"rgba(0,0,0,0.7)\";\n * }\n */ function rgba(firstValue, secondValue, thirdValue, fourthValue) {\n    if (typeof firstValue === \"string\" && typeof secondValue === \"number\") {\n        var rgbValue = parseToRgb(firstValue);\n        return \"rgba(\" + rgbValue.red + \",\" + rgbValue.green + \",\" + rgbValue.blue + \",\" + secondValue + \")\";\n    } else if (typeof firstValue === \"number\" && typeof secondValue === \"number\" && typeof thirdValue === \"number\" && typeof fourthValue === \"number\") {\n        return fourthValue >= 1 ? rgb(firstValue, secondValue, thirdValue) : \"rgba(\" + firstValue + \",\" + secondValue + \",\" + thirdValue + \",\" + fourthValue + \")\";\n    } else if (typeof firstValue === \"object\" && secondValue === undefined && thirdValue === undefined && fourthValue === undefined) {\n        return firstValue.alpha >= 1 ? rgb(firstValue.red, firstValue.green, firstValue.blue) : \"rgba(\" + firstValue.red + \",\" + firstValue.green + \",\" + firstValue.blue + \",\" + firstValue.alpha + \")\";\n    }\n    throw new PolishedError(7);\n}\nvar isRgb = function isRgb(color) {\n    return typeof color.red === \"number\" && typeof color.green === \"number\" && typeof color.blue === \"number\" && (typeof color.alpha !== \"number\" || typeof color.alpha === \"undefined\");\n};\nvar isRgba = function isRgba(color) {\n    return typeof color.red === \"number\" && typeof color.green === \"number\" && typeof color.blue === \"number\" && typeof color.alpha === \"number\";\n};\nvar isHsl = function isHsl(color) {\n    return typeof color.hue === \"number\" && typeof color.saturation === \"number\" && typeof color.lightness === \"number\" && (typeof color.alpha !== \"number\" || typeof color.alpha === \"undefined\");\n};\nvar isHsla = function isHsla(color) {\n    return typeof color.hue === \"number\" && typeof color.saturation === \"number\" && typeof color.lightness === \"number\" && typeof color.alpha === \"number\";\n};\n/**\n * Converts a RgbColor, RgbaColor, HslColor or HslaColor object to a color string.\n * This util is useful in case you only know on runtime which color object is\n * used. Otherwise we recommend to rely on `rgb`, `rgba`, `hsl` or `hsla`.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: toColorString({ red: 255, green: 205, blue: 100 }),\n *   background: toColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 }),\n *   background: toColorString({ hue: 240, saturation: 1, lightness: 0.5 }),\n *   background: toColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${toColorString({ red: 255, green: 205, blue: 100 })};\n *   background: ${toColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 })};\n *   background: ${toColorString({ hue: 240, saturation: 1, lightness: 0.5 })};\n *   background: ${toColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 })};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#ffcd64\";\n *   background: \"rgba(255,205,100,0.72)\";\n *   background: \"#00f\";\n *   background: \"rgba(179,25,25,0.72)\";\n * }\n */ function toColorString(color) {\n    if (typeof color !== \"object\") throw new PolishedError(8);\n    if (isRgba(color)) return rgba(color);\n    if (isRgb(color)) return rgb(color);\n    if (isHsla(color)) return hsla(color);\n    if (isHsl(color)) return hsl(color);\n    throw new PolishedError(8);\n}\n// Type definitions taken from https://github.com/gcanti/flow-static-land/blob/master/src/Fun.js\n// eslint-disable-next-line no-unused-vars\n// eslint-disable-next-line no-unused-vars\n// eslint-disable-next-line no-redeclare\nfunction curried(f, length, acc) {\n    return function fn() {\n        // eslint-disable-next-line prefer-rest-params\n        var combined = acc.concat(Array.prototype.slice.call(arguments));\n        return combined.length >= length ? f.apply(this, combined) : curried(f, length, combined);\n    };\n}\n// eslint-disable-next-line no-redeclare\nfunction curry(f) {\n    // eslint-disable-line no-redeclare\n    return curried(f, f.length, []);\n}\n/**\n * Changes the hue of the color. Hue is a number between 0 to 360. The first\n * argument for adjustHue is the amount of degrees the color is rotated around\n * the color wheel, always producing a positive hue value.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: adjustHue(180, '#448'),\n *   background: adjustHue('180', 'rgba(101,100,205,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${adjustHue(180, '#448')};\n *   background: ${adjustHue('180', 'rgba(101,100,205,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#888844\";\n *   background: \"rgba(136,136,68,0.7)\";\n * }\n */ function adjustHue(degree, color) {\n    if (color === \"transparent\") return color;\n    var hslColor = parseToHsl(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, hslColor, {\n        hue: hslColor.hue + parseFloat(degree)\n    }));\n}\n// prettier-ignore\nvar curriedAdjustHue = curry /* ::<number | string, string, string> */ (adjustHue);\nvar curriedAdjustHue$1 = curriedAdjustHue;\n/**\n * Returns the complement of the provided color. This is identical to adjustHue(180, <color>).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: complement('#448'),\n *   background: complement('rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${complement('#448')};\n *   background: ${complement('rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#884\";\n *   background: \"rgba(153,153,153,0.7)\";\n * }\n */ function complement(color) {\n    if (color === \"transparent\") return color;\n    var hslColor = parseToHsl(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, hslColor, {\n        hue: (hslColor.hue + 180) % 360\n    }));\n}\nfunction guard(lowerBoundary, upperBoundary, value) {\n    return Math.max(lowerBoundary, Math.min(upperBoundary, value));\n}\n/**\n * Returns a string value for the darkened color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: darken(0.2, '#FFCD64'),\n *   background: darken('0.2', 'rgba(255,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${darken(0.2, '#FFCD64')};\n *   background: ${darken('0.2', 'rgba(255,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#ffbd31\";\n *   background: \"rgba(255,189,49,0.7)\";\n * }\n */ function darken(amount, color) {\n    if (color === \"transparent\") return color;\n    var hslColor = parseToHsl(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, hslColor, {\n        lightness: guard(0, 1, hslColor.lightness - parseFloat(amount))\n    }));\n}\n// prettier-ignore\nvar curriedDarken = curry /* ::<number | string, string, string> */ (darken);\nvar curriedDarken$1 = curriedDarken;\n/**\n * Decreases the intensity of a color. Its range is between 0 to 1. The first\n * argument of the desaturate function is the amount by how much the color\n * intensity should be decreased.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: desaturate(0.2, '#CCCD64'),\n *   background: desaturate('0.2', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${desaturate(0.2, '#CCCD64')};\n *   background: ${desaturate('0.2', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#b8b979\";\n *   background: \"rgba(184,185,121,0.7)\";\n * }\n */ function desaturate(amount, color) {\n    if (color === \"transparent\") return color;\n    var hslColor = parseToHsl(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, hslColor, {\n        saturation: guard(0, 1, hslColor.saturation - parseFloat(amount))\n    }));\n}\n// prettier-ignore\nvar curriedDesaturate = curry /* ::<number | string, string, string> */ (desaturate);\nvar curriedDesaturate$1 = curriedDesaturate;\n/**\n * Returns a number (float) representing the luminance of a color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: getLuminance('#CCCD64') >= getLuminance('#0000ff') ? '#CCCD64' : '#0000ff',\n *   background: getLuminance('rgba(58, 133, 255, 1)') >= getLuminance('rgba(255, 57, 149, 1)') ?\n *                             'rgba(58, 133, 255, 1)' :\n *                             'rgba(255, 57, 149, 1)',\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${getLuminance('#CCCD64') >= getLuminance('#0000ff') ? '#CCCD64' : '#0000ff'};\n *   background: ${getLuminance('rgba(58, 133, 255, 1)') >= getLuminance('rgba(255, 57, 149, 1)') ?\n *                             'rgba(58, 133, 255, 1)' :\n *                             'rgba(255, 57, 149, 1)'};\n *\n * // CSS in JS Output\n *\n * div {\n *   background: \"#CCCD64\";\n *   background: \"rgba(58, 133, 255, 1)\";\n * }\n */ function getLuminance(color) {\n    if (color === \"transparent\") return 0;\n    var rgbColor = parseToRgb(color);\n    var _Object$keys$map = Object.keys(rgbColor).map(function(key) {\n        var channel = rgbColor[key] / 255;\n        return channel <= 0.03928 ? channel / 12.92 : Math.pow((channel + 0.055) / 1.055, 2.4);\n    }), r = _Object$keys$map[0], g = _Object$keys$map[1], b = _Object$keys$map[2];\n    return parseFloat((0.2126 * r + 0.7152 * g + 0.0722 * b).toFixed(3));\n}\n/**\n * Returns the contrast ratio between two colors based on\n * [W3's recommended equation for calculating contrast](http://www.w3.org/TR/WCAG20/#contrast-ratiodef).\n *\n * @example\n * const contrastRatio = getContrast('#444', '#fff');\n */ function getContrast(color1, color2) {\n    var luminance1 = getLuminance(color1);\n    var luminance2 = getLuminance(color2);\n    return parseFloat((luminance1 > luminance2 ? (luminance1 + 0.05) / (luminance2 + 0.05) : (luminance2 + 0.05) / (luminance1 + 0.05)).toFixed(2));\n}\n/**\n * Converts the color to a grayscale, by reducing its saturation to 0.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: grayscale('#CCCD64'),\n *   background: grayscale('rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${grayscale('#CCCD64')};\n *   background: ${grayscale('rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#999\";\n *   background: \"rgba(153,153,153,0.7)\";\n * }\n */ function grayscale(color) {\n    if (color === \"transparent\") return color;\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parseToHsl(color), {\n        saturation: 0\n    }));\n}\n/**\n * Converts a HslColor or HslaColor object to a color string.\n * This util is useful in case you only know on runtime which color object is\n * used. Otherwise we recommend to rely on `hsl` or `hsla`.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: hslToColorString({ hue: 240, saturation: 1, lightness: 0.5 }),\n *   background: hslToColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${hslToColorString({ hue: 240, saturation: 1, lightness: 0.5 })};\n *   background: ${hslToColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 })};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#00f\";\n *   background: \"rgba(179,25,25,0.72)\";\n * }\n */ function hslToColorString(color) {\n    if (typeof color === \"object\" && typeof color.hue === \"number\" && typeof color.saturation === \"number\" && typeof color.lightness === \"number\") {\n        if (color.alpha && typeof color.alpha === \"number\") {\n            return hsla({\n                hue: color.hue,\n                saturation: color.saturation,\n                lightness: color.lightness,\n                alpha: color.alpha\n            });\n        }\n        return hsl({\n            hue: color.hue,\n            saturation: color.saturation,\n            lightness: color.lightness\n        });\n    }\n    throw new PolishedError(45);\n}\n/**\n * Inverts the red, green and blue values of a color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: invert('#CCCD64'),\n *   background: invert('rgba(101,100,205,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${invert('#CCCD64')};\n *   background: ${invert('rgba(101,100,205,0.7)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#33329b\";\n *   background: \"rgba(154,155,50,0.7)\";\n * }\n */ function invert(color) {\n    if (color === \"transparent\") return color;\n    // parse color string to rgb\n    var value = parseToRgb(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, value, {\n        red: 255 - value.red,\n        green: 255 - value.green,\n        blue: 255 - value.blue\n    }));\n}\n/**\n * Returns a string value for the lightened color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: lighten(0.2, '#CCCD64'),\n *   background: lighten('0.2', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${lighten(0.2, '#FFCD64')};\n *   background: ${lighten('0.2', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#e5e6b1\";\n *   background: \"rgba(229,230,177,0.7)\";\n * }\n */ function lighten(amount, color) {\n    if (color === \"transparent\") return color;\n    var hslColor = parseToHsl(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, hslColor, {\n        lightness: guard(0, 1, hslColor.lightness + parseFloat(amount))\n    }));\n}\n// prettier-ignore\nvar curriedLighten = curry /* ::<number | string, string, string> */ (lighten);\nvar curriedLighten$1 = curriedLighten;\n/**\n * Determines which contrast guidelines have been met for two colors.\n * Based on the [contrast calculations recommended by W3](https://www.w3.org/WAI/WCAG21/Understanding/contrast-enhanced.html).\n *\n * @example\n * const scores = meetsContrastGuidelines('#444', '#fff');\n */ function meetsContrastGuidelines(color1, color2) {\n    var contrastRatio = getContrast(color1, color2);\n    return {\n        AA: contrastRatio >= 4.5,\n        AALarge: contrastRatio >= 3,\n        AAA: contrastRatio >= 7,\n        AAALarge: contrastRatio >= 4.5\n    };\n}\n/**\n * Mixes the two provided colors together by calculating the average of each of the RGB components weighted to the first color by the provided weight.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: mix(0.5, '#f00', '#00f')\n *   background: mix(0.25, '#f00', '#00f')\n *   background: mix('0.5', 'rgba(255, 0, 0, 0.5)', '#00f')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${mix(0.5, '#f00', '#00f')};\n *   background: ${mix(0.25, '#f00', '#00f')};\n *   background: ${mix('0.5', 'rgba(255, 0, 0, 0.5)', '#00f')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#7f007f\";\n *   background: \"#3f00bf\";\n *   background: \"rgba(63, 0, 191, 0.75)\";\n * }\n */ function mix(weight, color, otherColor) {\n    if (color === \"transparent\") return otherColor;\n    if (otherColor === \"transparent\") return color;\n    if (weight === 0) return otherColor;\n    var parsedColor1 = parseToRgb(color);\n    var color1 = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parsedColor1, {\n        alpha: typeof parsedColor1.alpha === \"number\" ? parsedColor1.alpha : 1\n    });\n    var parsedColor2 = parseToRgb(otherColor);\n    var color2 = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parsedColor2, {\n        alpha: typeof parsedColor2.alpha === \"number\" ? parsedColor2.alpha : 1\n    });\n    // The formula is copied from the original Sass implementation:\n    // http://sass-lang.com/documentation/Sass/Script/Functions.html#mix-instance_method\n    var alphaDelta = color1.alpha - color2.alpha;\n    var x = parseFloat(weight) * 2 - 1;\n    var y = x * alphaDelta === -1 ? x : x + alphaDelta;\n    var z = 1 + x * alphaDelta;\n    var weight1 = (y / z + 1) / 2.0;\n    var weight2 = 1 - weight1;\n    var mixedColor = {\n        red: Math.floor(color1.red * weight1 + color2.red * weight2),\n        green: Math.floor(color1.green * weight1 + color2.green * weight2),\n        blue: Math.floor(color1.blue * weight1 + color2.blue * weight2),\n        alpha: color1.alpha * parseFloat(weight) + color2.alpha * (1 - parseFloat(weight))\n    };\n    return rgba(mixedColor);\n}\n// prettier-ignore\nvar curriedMix = curry /* ::<number | string, string, string, string> */ (mix);\nvar mix$1 = curriedMix;\n/**\n * Increases the opacity of a color. Its range for the amount is between 0 to 1.\n *\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: opacify(0.1, 'rgba(255, 255, 255, 0.9)');\n *   background: opacify(0.2, 'hsla(0, 0%, 100%, 0.5)'),\n *   background: opacify('0.5', 'rgba(255, 0, 0, 0.2)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${opacify(0.1, 'rgba(255, 255, 255, 0.9)')};\n *   background: ${opacify(0.2, 'hsla(0, 0%, 100%, 0.5)')},\n *   background: ${opacify('0.5', 'rgba(255, 0, 0, 0.2)')},\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#fff\";\n *   background: \"rgba(255,255,255,0.7)\";\n *   background: \"rgba(255,0,0,0.7)\";\n * }\n */ function opacify(amount, color) {\n    if (color === \"transparent\") return color;\n    var parsedColor = parseToRgb(color);\n    var alpha = typeof parsedColor.alpha === \"number\" ? parsedColor.alpha : 1;\n    var colorWithAlpha = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parsedColor, {\n        alpha: guard(0, 1, (alpha * 100 + parseFloat(amount) * 100) / 100)\n    });\n    return rgba(colorWithAlpha);\n}\n// prettier-ignore\nvar curriedOpacify = curry /* ::<number | string, string, string> */ (opacify);\nvar curriedOpacify$1 = curriedOpacify;\nvar defaultReturnIfLightColor = \"#000\";\nvar defaultReturnIfDarkColor = \"#fff\";\n/**\n * Returns black or white (or optional passed colors) for best\n * contrast depending on the luminosity of the given color.\n * When passing custom return colors, strict mode ensures that the\n * return color always meets or exceeds WCAG level AA or greater. If this test\n * fails, the default return color (black or white) is returned in place of the\n * custom return color. You can optionally turn off strict mode.\n *\n * Follows [W3C specs for readability](https://www.w3.org/TR/WCAG20-TECHS/G18.html).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   color: readableColor('#000'),\n *   color: readableColor('black', '#001', '#ff8'),\n *   color: readableColor('white', '#001', '#ff8'),\n *   color: readableColor('red', '#333', '#ddd', true)\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   color: ${readableColor('#000')};\n *   color: ${readableColor('black', '#001', '#ff8')};\n *   color: ${readableColor('white', '#001', '#ff8')};\n *   color: ${readableColor('red', '#333', '#ddd', true)};\n * `\n *\n * // CSS in JS Output\n * element {\n *   color: \"#fff\";\n *   color: \"#ff8\";\n *   color: \"#001\";\n *   color: \"#000\";\n * }\n */ function readableColor(color, returnIfLightColor, returnIfDarkColor, strict) {\n    if (returnIfLightColor === void 0) {\n        returnIfLightColor = defaultReturnIfLightColor;\n    }\n    if (returnIfDarkColor === void 0) {\n        returnIfDarkColor = defaultReturnIfDarkColor;\n    }\n    if (strict === void 0) {\n        strict = true;\n    }\n    var isColorLight = getLuminance(color) > 0.179;\n    var preferredReturnColor = isColorLight ? returnIfLightColor : returnIfDarkColor;\n    if (!strict || getContrast(color, preferredReturnColor) >= 4.5) {\n        return preferredReturnColor;\n    }\n    return isColorLight ? defaultReturnIfLightColor : defaultReturnIfDarkColor;\n}\n/**\n * Converts a RgbColor or RgbaColor object to a color string.\n * This util is useful in case you only know on runtime which color object is\n * used. Otherwise we recommend to rely on `rgb` or `rgba`.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: rgbToColorString({ red: 255, green: 205, blue: 100 }),\n *   background: rgbToColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${rgbToColorString({ red: 255, green: 205, blue: 100 })};\n *   background: ${rgbToColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 })};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#ffcd64\";\n *   background: \"rgba(255,205,100,0.72)\";\n * }\n */ function rgbToColorString(color) {\n    if (typeof color === \"object\" && typeof color.red === \"number\" && typeof color.green === \"number\" && typeof color.blue === \"number\") {\n        if (typeof color.alpha === \"number\") {\n            return rgba({\n                red: color.red,\n                green: color.green,\n                blue: color.blue,\n                alpha: color.alpha\n            });\n        }\n        return rgb({\n            red: color.red,\n            green: color.green,\n            blue: color.blue\n        });\n    }\n    throw new PolishedError(46);\n}\n/**\n * Increases the intensity of a color. Its range is between 0 to 1. The first\n * argument of the saturate function is the amount by how much the color\n * intensity should be increased.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: saturate(0.2, '#CCCD64'),\n *   background: saturate('0.2', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${saturate(0.2, '#FFCD64')};\n *   background: ${saturate('0.2', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#e0e250\";\n *   background: \"rgba(224,226,80,0.7)\";\n * }\n */ function saturate(amount, color) {\n    if (color === \"transparent\") return color;\n    var hslColor = parseToHsl(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, hslColor, {\n        saturation: guard(0, 1, hslColor.saturation + parseFloat(amount))\n    }));\n}\n// prettier-ignore\nvar curriedSaturate = curry /* ::<number | string, string, string> */ (saturate);\nvar curriedSaturate$1 = curriedSaturate;\n/**\n * Sets the hue of a color to the provided value. The hue range can be\n * from 0 and 359.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: setHue(42, '#CCCD64'),\n *   background: setHue('244', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${setHue(42, '#CCCD64')};\n *   background: ${setHue('244', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#cdae64\";\n *   background: \"rgba(107,100,205,0.7)\";\n * }\n */ function setHue(hue, color) {\n    if (color === \"transparent\") return color;\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parseToHsl(color), {\n        hue: parseFloat(hue)\n    }));\n}\n// prettier-ignore\nvar curriedSetHue = curry /* ::<number | string, string, string> */ (setHue);\nvar curriedSetHue$1 = curriedSetHue;\n/**\n * Sets the lightness of a color to the provided value. The lightness range can be\n * from 0 and 1.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: setLightness(0.2, '#CCCD64'),\n *   background: setLightness('0.75', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${setLightness(0.2, '#CCCD64')};\n *   background: ${setLightness('0.75', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#4d4d19\";\n *   background: \"rgba(223,224,159,0.7)\";\n * }\n */ function setLightness(lightness, color) {\n    if (color === \"transparent\") return color;\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parseToHsl(color), {\n        lightness: parseFloat(lightness)\n    }));\n}\n// prettier-ignore\nvar curriedSetLightness = curry /* ::<number | string, string, string> */ (setLightness);\nvar curriedSetLightness$1 = curriedSetLightness;\n/**\n * Sets the saturation of a color to the provided value. The saturation range can be\n * from 0 and 1.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: setSaturation(0.2, '#CCCD64'),\n *   background: setSaturation('0.75', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${setSaturation(0.2, '#CCCD64')};\n *   background: ${setSaturation('0.75', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#adad84\";\n *   background: \"rgba(228,229,76,0.7)\";\n * }\n */ function setSaturation(saturation, color) {\n    if (color === \"transparent\") return color;\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parseToHsl(color), {\n        saturation: parseFloat(saturation)\n    }));\n}\n// prettier-ignore\nvar curriedSetSaturation = curry /* ::<number | string, string, string> */ (setSaturation);\nvar curriedSetSaturation$1 = curriedSetSaturation;\n/**\n * Shades a color by mixing it with black. `shade` can produce\n * hue shifts, where as `darken` manipulates the luminance channel and therefore\n * doesn't produce hue shifts.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: shade(0.25, '#00f')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${shade(0.25, '#00f')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#00003f\";\n * }\n */ function shade(percentage, color) {\n    if (color === \"transparent\") return color;\n    return mix$1(parseFloat(percentage), \"rgb(0, 0, 0)\", color);\n}\n// prettier-ignore\nvar curriedShade = curry /* ::<number | string, string, string> */ (shade);\nvar curriedShade$1 = curriedShade;\n/**\n * Tints a color by mixing it with white. `tint` can produce\n * hue shifts, where as `lighten` manipulates the luminance channel and therefore\n * doesn't produce hue shifts.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: tint(0.25, '#00f')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${tint(0.25, '#00f')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#bfbfff\";\n * }\n */ function tint(percentage, color) {\n    if (color === \"transparent\") return color;\n    return mix$1(parseFloat(percentage), \"rgb(255, 255, 255)\", color);\n}\n// prettier-ignore\nvar curriedTint = curry /* ::<number | string, string, string> */ (tint);\nvar curriedTint$1 = curriedTint;\n/**\n * Decreases the opacity of a color. Its range for the amount is between 0 to 1.\n *\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: transparentize(0.1, '#fff'),\n *   background: transparentize(0.2, 'hsl(0, 0%, 100%)'),\n *   background: transparentize('0.5', 'rgba(255, 0, 0, 0.8)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${transparentize(0.1, '#fff')};\n *   background: ${transparentize(0.2, 'hsl(0, 0%, 100%)')};\n *   background: ${transparentize('0.5', 'rgba(255, 0, 0, 0.8)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"rgba(255,255,255,0.9)\";\n *   background: \"rgba(255,255,255,0.8)\";\n *   background: \"rgba(255,0,0,0.3)\";\n * }\n */ function transparentize(amount, color) {\n    if (color === \"transparent\") return color;\n    var parsedColor = parseToRgb(color);\n    var alpha = typeof parsedColor.alpha === \"number\" ? parsedColor.alpha : 1;\n    var colorWithAlpha = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parsedColor, {\n        alpha: guard(0, 1, +(alpha * 100 - parseFloat(amount) * 100).toFixed(2) / 100)\n    });\n    return rgba(colorWithAlpha);\n}\n// prettier-ignore\nvar curriedTransparentize = curry /* ::<number | string, string, string> */ (transparentize);\nvar curriedTransparentize$1 = curriedTransparentize;\n/**\n * Shorthand for easily setting the animation property. Allows either multiple arrays with animations\n * or a single animation spread over the arguments.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...animation(['rotate', '1s', 'ease-in-out'], ['colorchange', '2s'])\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${animation(['rotate', '1s', 'ease-in-out'], ['colorchange', '2s'])}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'animation': 'rotate 1s ease-in-out, colorchange 2s'\n * }\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...animation('rotate', '1s', 'ease-in-out')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${animation('rotate', '1s', 'ease-in-out')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'animation': 'rotate 1s ease-in-out'\n * }\n */ function animation() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    // Allow single or multiple animations passed\n    var multiMode = Array.isArray(args[0]);\n    if (!multiMode && args.length > 8) {\n        throw new PolishedError(64);\n    }\n    var code = args.map(function(arg) {\n        if (multiMode && !Array.isArray(arg) || !multiMode && Array.isArray(arg)) {\n            throw new PolishedError(65);\n        }\n        if (Array.isArray(arg) && arg.length > 8) {\n            throw new PolishedError(66);\n        }\n        return Array.isArray(arg) ? arg.join(\" \") : arg;\n    }).join(\", \");\n    return {\n        animation: code\n    };\n}\n/**\n * Shorthand that accepts any number of backgroundImage values as parameters for creating a single background statement.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...backgroundImages('url(\"/image/background.jpg\")', 'linear-gradient(red, green)')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${backgroundImages('url(\"/image/background.jpg\")', 'linear-gradient(red, green)')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'backgroundImage': 'url(\"/image/background.jpg\"), linear-gradient(red, green)'\n * }\n */ function backgroundImages() {\n    for(var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++){\n        properties[_key] = arguments[_key];\n    }\n    return {\n        backgroundImage: properties.join(\", \")\n    };\n}\n/**\n * Shorthand that accepts any number of background values as parameters for creating a single background statement.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...backgrounds('url(\"/image/background.jpg\")', 'linear-gradient(red, green)', 'center no-repeat')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${backgrounds('url(\"/image/background.jpg\")', 'linear-gradient(red, green)', 'center no-repeat')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'background': 'url(\"/image/background.jpg\"), linear-gradient(red, green), center no-repeat'\n * }\n */ function backgrounds() {\n    for(var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++){\n        properties[_key] = arguments[_key];\n    }\n    return {\n        background: properties.join(\", \")\n    };\n}\nvar sideMap = [\n    \"top\",\n    \"right\",\n    \"bottom\",\n    \"left\"\n];\n/**\n * Shorthand for the border property that splits out individual properties for use with tools like Fela and Styletron. A side keyword can optionally be passed to target only one side's border properties.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...border('1px', 'solid', 'red')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${border('1px', 'solid', 'red')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderColor': 'red',\n *   'borderStyle': 'solid',\n *   'borderWidth': `1px`,\n * }\n *\n * // Styles as object usage\n * const styles = {\n *   ...border('top', '1px', 'solid', 'red')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${border('top', '1px', 'solid', 'red')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopColor': 'red',\n *   'borderTopStyle': 'solid',\n *   'borderTopWidth': `1px`,\n * }\n */ function border(sideKeyword) {\n    for(var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        values[_key - 1] = arguments[_key];\n    }\n    if (typeof sideKeyword === \"string\" && sideMap.indexOf(sideKeyword) >= 0) {\n        var _ref;\n        return _ref = {}, _ref[\"border\" + capitalizeString(sideKeyword) + \"Width\"] = values[0], _ref[\"border\" + capitalizeString(sideKeyword) + \"Style\"] = values[1], _ref[\"border\" + capitalizeString(sideKeyword) + \"Color\"] = values[2], _ref;\n    } else {\n        values.unshift(sideKeyword);\n        return {\n            borderWidth: values[0],\n            borderStyle: values[1],\n            borderColor: values[2]\n        };\n    }\n}\n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...borderColor('red', 'green', 'blue', 'yellow')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${borderColor('red', 'green', 'blue', 'yellow')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopColor': 'red',\n *   'borderRightColor': 'green',\n *   'borderBottomColor': 'blue',\n *   'borderLeftColor': 'yellow'\n * }\n */ function borderColor() {\n    for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){\n        values[_key] = arguments[_key];\n    }\n    return directionalProperty.apply(void 0, [\n        \"borderColor\"\n    ].concat(values));\n}\n/**\n * Shorthand that accepts a value for side and a value for radius and applies the radius value to both corners of the side.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...borderRadius('top', '5px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${borderRadius('top', '5px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopRightRadius': '5px',\n *   'borderTopLeftRadius': '5px',\n * }\n */ function borderRadius(side, radius) {\n    var uppercaseSide = capitalizeString(side);\n    if (!radius && radius !== 0) {\n        throw new PolishedError(62);\n    }\n    if (uppercaseSide === \"Top\" || uppercaseSide === \"Bottom\") {\n        var _ref;\n        return _ref = {}, _ref[\"border\" + uppercaseSide + \"RightRadius\"] = radius, _ref[\"border\" + uppercaseSide + \"LeftRadius\"] = radius, _ref;\n    }\n    if (uppercaseSide === \"Left\" || uppercaseSide === \"Right\") {\n        var _ref2;\n        return _ref2 = {}, _ref2[\"borderTop\" + uppercaseSide + \"Radius\"] = radius, _ref2[\"borderBottom\" + uppercaseSide + \"Radius\"] = radius, _ref2;\n    }\n    throw new PolishedError(63);\n}\n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...borderStyle('solid', 'dashed', 'dotted', 'double')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${borderStyle('solid', 'dashed', 'dotted', 'double')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopStyle': 'solid',\n *   'borderRightStyle': 'dashed',\n *   'borderBottomStyle': 'dotted',\n *   'borderLeftStyle': 'double'\n * }\n */ function borderStyle() {\n    for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){\n        values[_key] = arguments[_key];\n    }\n    return directionalProperty.apply(void 0, [\n        \"borderStyle\"\n    ].concat(values));\n}\n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...borderWidth('12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${borderWidth('12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopWidth': '12px',\n *   'borderRightWidth': '24px',\n *   'borderBottomWidth': '36px',\n *   'borderLeftWidth': '48px'\n * }\n */ function borderWidth() {\n    for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){\n        values[_key] = arguments[_key];\n    }\n    return directionalProperty.apply(void 0, [\n        \"borderWidth\"\n    ].concat(values));\n}\nfunction generateSelectors(template, state) {\n    var stateSuffix = state ? \":\" + state : \"\";\n    return template(stateSuffix);\n}\n/**\n * Function helper that adds an array of states to a template of selectors. Used in textInputs and buttons.\n * @private\n */ function statefulSelectors(states, template, stateMap) {\n    if (!template) throw new PolishedError(67);\n    if (states.length === 0) return generateSelectors(template, null);\n    var selectors = [];\n    for(var i = 0; i < states.length; i += 1){\n        if (stateMap && stateMap.indexOf(states[i]) < 0) {\n            throw new PolishedError(68);\n        }\n        selectors.push(generateSelectors(template, states[i]));\n    }\n    selectors = selectors.join(\",\");\n    return selectors;\n}\nvar stateMap$1 = [\n    undefined,\n    null,\n    \"active\",\n    \"focus\",\n    \"hover\"\n];\nfunction template$1(state) {\n    return \"button\" + state + ',\\n  input[type=\"button\"]' + state + ',\\n  input[type=\"reset\"]' + state + ',\\n  input[type=\"submit\"]' + state;\n}\n/**\n * Populates selectors that target all buttons. You can pass optional states to append to the selectors.\n * @example\n * // Styles as object usage\n * const styles = {\n *   [buttons('active')]: {\n *     'border': 'none'\n *   }\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   > ${buttons('active')} {\n *     border: none;\n *   }\n * `\n *\n * // CSS in JS Output\n *\n *  'button:active,\n *  'input[type=\"button\"]:active,\n *  'input[type=\\\"reset\\\"]:active,\n *  'input[type=\\\"submit\\\"]:active: {\n *   'border': 'none'\n * }\n */ function buttons() {\n    for(var _len = arguments.length, states = new Array(_len), _key = 0; _key < _len; _key++){\n        states[_key] = arguments[_key];\n    }\n    return statefulSelectors(states, template$1, stateMap$1);\n}\n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...margin('12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${margin('12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'marginTop': '12px',\n *   'marginRight': '24px',\n *   'marginBottom': '36px',\n *   'marginLeft': '48px'\n * }\n */ function margin() {\n    for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){\n        values[_key] = arguments[_key];\n    }\n    return directionalProperty.apply(void 0, [\n        \"margin\"\n    ].concat(values));\n}\n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...padding('12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${padding('12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'paddingTop': '12px',\n *   'paddingRight': '24px',\n *   'paddingBottom': '36px',\n *   'paddingLeft': '48px'\n * }\n */ function padding() {\n    for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){\n        values[_key] = arguments[_key];\n    }\n    return directionalProperty.apply(void 0, [\n        \"padding\"\n    ].concat(values));\n}\nvar positionMap = [\n    \"absolute\",\n    \"fixed\",\n    \"relative\",\n    \"static\",\n    \"sticky\"\n];\n/**\n * Shorthand accepts up to five values, including null to skip a value, and maps them to their respective directions. The first value can optionally be a position keyword.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...position('12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${position('12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'top': '12px',\n *   'right': '24px',\n *   'bottom': '36px',\n *   'left': '48px'\n * }\n *\n * // Styles as object usage\n * const styles = {\n *   ...position('absolute', '12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${position('absolute', '12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'position': 'absolute',\n *   'top': '12px',\n *   'right': '24px',\n *   'bottom': '36px',\n *   'left': '48px'\n * }\n */ function position(firstValue) {\n    for(var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        values[_key - 1] = arguments[_key];\n    }\n    if (positionMap.indexOf(firstValue) >= 0 && firstValue) {\n        return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, directionalProperty.apply(void 0, [\n            \"\"\n        ].concat(values)), {\n            position: firstValue\n        });\n    } else {\n        return directionalProperty.apply(void 0, [\n            \"\",\n            firstValue\n        ].concat(values));\n    }\n}\n/**\n * Shorthand to set the height and width properties in a single statement.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...size('300px', '250px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${size('300px', '250px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'height': '300px',\n *   'width': '250px',\n * }\n */ function size(height, width) {\n    if (width === void 0) {\n        width = height;\n    }\n    return {\n        height: height,\n        width: width\n    };\n}\nvar stateMap = [\n    undefined,\n    null,\n    \"active\",\n    \"focus\",\n    \"hover\"\n];\nfunction template(state) {\n    return 'input[type=\"color\"]' + state + ',\\n    input[type=\"date\"]' + state + ',\\n    input[type=\"datetime\"]' + state + ',\\n    input[type=\"datetime-local\"]' + state + ',\\n    input[type=\"email\"]' + state + ',\\n    input[type=\"month\"]' + state + ',\\n    input[type=\"number\"]' + state + ',\\n    input[type=\"password\"]' + state + ',\\n    input[type=\"search\"]' + state + ',\\n    input[type=\"tel\"]' + state + ',\\n    input[type=\"text\"]' + state + ',\\n    input[type=\"time\"]' + state + ',\\n    input[type=\"url\"]' + state + ',\\n    input[type=\"week\"]' + state + \",\\n    input:not([type])\" + state + \",\\n    textarea\" + state;\n}\n/**\n * Populates selectors that target all text inputs. You can pass optional states to append to the selectors.\n * @example\n * // Styles as object usage\n * const styles = {\n *   [textInputs('active')]: {\n *     'border': 'none'\n *   }\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   > ${textInputs('active')} {\n *     border: none;\n *   }\n * `\n *\n * // CSS in JS Output\n *\n *  'input[type=\"color\"]:active,\n *  input[type=\"date\"]:active,\n *  input[type=\"datetime\"]:active,\n *  input[type=\"datetime-local\"]:active,\n *  input[type=\"email\"]:active,\n *  input[type=\"month\"]:active,\n *  input[type=\"number\"]:active,\n *  input[type=\"password\"]:active,\n *  input[type=\"search\"]:active,\n *  input[type=\"tel\"]:active,\n *  input[type=\"text\"]:active,\n *  input[type=\"time\"]:active,\n *  input[type=\"url\"]:active,\n *  input[type=\"week\"]:active,\n *  input:not([type]):active,\n *  textarea:active': {\n *   'border': 'none'\n * }\n */ function textInputs() {\n    for(var _len = arguments.length, states = new Array(_len), _key = 0; _key < _len; _key++){\n        states[_key] = arguments[_key];\n    }\n    return statefulSelectors(states, template, stateMap);\n}\n/**\n * Accepts any number of transition values as parameters for creating a single transition statement. You may also pass an array of properties as the first parameter that you would like to apply the same transition values to (second parameter).\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...transitions('opacity 1.0s ease-in 0s', 'width 2.0s ease-in 2s'),\n *   ...transitions(['color', 'background-color'], '2.0s ease-in 2s')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${transitions('opacity 1.0s ease-in 0s', 'width 2.0s ease-in 2s')};\n *   ${transitions(['color', 'background-color'], '2.0s ease-in 2s'),};\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'transition': 'opacity 1.0s ease-in 0s, width 2.0s ease-in 2s'\n *   'transition': 'color 2.0s ease-in 2s, background-color 2.0s ease-in 2s',\n * }\n */ function transitions() {\n    for(var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++){\n        properties[_key] = arguments[_key];\n    }\n    if (Array.isArray(properties[0]) && properties.length === 2) {\n        var value = properties[1];\n        if (typeof value !== \"string\") {\n            throw new PolishedError(61);\n        }\n        var transitionsString = properties[0].map(function(property) {\n            return property + \" \" + value;\n        }).join(\", \");\n        return {\n            transition: transitionsString\n        };\n    } else {\n        return {\n            transition: properties.join(\", \")\n        };\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcG9saXNoZWQvZGlzdC9wb2xpc2hlZC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTBEO0FBQzRCO0FBQ2hCO0FBQ0k7QUFDc0I7QUFFaEcsU0FBU0s7SUFDUCxJQUFJQztJQUNKLE9BQU9BLE9BQU9DLFVBQVVDLE1BQU0sR0FBRyxHQUFHRixPQUFPLEtBQUtDLFVBQVVDLE1BQU0sSUFBSUYsT0FBT0csWUFBWUYsU0FBUyxDQUFDRCxLQUFLO0FBQ3hHO0FBQ0EsU0FBU0ksU0FBU0MsQ0FBQztJQUNqQixPQUFPLENBQUNBO0FBQ1Y7QUFDQSxTQUFTQyxTQUFTRCxDQUFDLEVBQUVFLENBQUM7SUFDcEIsT0FBT0YsSUFBSUU7QUFDYjtBQUNBLFNBQVNDLFlBQVlILENBQUMsRUFBRUUsQ0FBQztJQUN2QixPQUFPRixJQUFJRTtBQUNiO0FBQ0EsU0FBU0UsZUFBZUosQ0FBQyxFQUFFRSxDQUFDO0lBQzFCLE9BQU9GLElBQUlFO0FBQ2I7QUFDQSxTQUFTRyxTQUFTTCxDQUFDLEVBQUVFLENBQUM7SUFDcEIsT0FBT0YsSUFBSUU7QUFDYjtBQUNBLFNBQVNJO0lBQ1AsT0FBT0MsS0FBS0QsR0FBRyxDQUFDRSxLQUFLLENBQUNELE1BQU1YO0FBQzlCO0FBQ0EsU0FBU2E7SUFDUCxPQUFPRixLQUFLRSxHQUFHLENBQUNELEtBQUssQ0FBQ0QsTUFBTVg7QUFDOUI7QUFDQSxTQUFTYztJQUNQLE9BQU9DLE1BQU1DLEVBQUUsQ0FBQ0osS0FBSyxDQUFDRyxPQUFPZjtBQUMvQjtBQUNBLElBQUlpQixpQkFBaUI7SUFDbkJDLFNBQVM7UUFDUCxLQUFLO1lBQ0hDLE9BQU87Z0JBQ0xDLFFBQVE7Z0JBQ1JDLEdBQUdiO2dCQUNIYyxVQUFVO2dCQUNWQyxZQUFZO2dCQUNaQyxhQUFhO2dCQUNiQyxVQUFVO1lB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Ozs7Ozs7Ozs7OztDQXFDQyxHQUNELFNBQVNXO0lBQ1AsSUFBSyxJQUFJbHVCLE9BQU9qQyxVQUFVQyxNQUFNLEVBQUUwdkIsU0FBUyxJQUFJNXVCLE1BQU1rQixPQUFPRSxPQUFPLEdBQUdBLE9BQU9GLE1BQU1FLE9BQVE7UUFDekZ3dEIsTUFBTSxDQUFDeHRCLEtBQUssR0FBR25DLFNBQVMsQ0FBQ21DLEtBQUs7SUFDaEM7SUFDQSxPQUFPdXRCLGtCQUFrQkMsUUFBUTlhLFVBQVUrYTtBQUM3QztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FxQkMsR0FDRCxTQUFTUTtJQUNQLElBQUssSUFBSW51QixPQUFPakMsVUFBVUMsTUFBTSxFQUFFNHVCLGFBQWEsSUFBSTl0QixNQUFNa0IsT0FBT0UsT0FBTyxHQUFHQSxPQUFPRixNQUFNRSxPQUFRO1FBQzdGMHNCLFVBQVUsQ0FBQzFzQixLQUFLLEdBQUduQyxTQUFTLENBQUNtQyxLQUFLO0lBQ3BDO0lBQ0EsSUFBSXBCLE1BQU0rTyxPQUFPLENBQUMrZSxVQUFVLENBQUMsRUFBRSxLQUFLQSxXQUFXNXVCLE1BQU0sS0FBSyxHQUFHO1FBQzNELElBQUl1SSxRQUFRcW1CLFVBQVUsQ0FBQyxFQUFFO1FBQ3pCLElBQUksT0FBT3JtQixVQUFVLFVBQVU7WUFDN0IsTUFBTSxJQUFJL0YsY0FBYztRQUMxQjtRQUNBLElBQUk0dEIsb0JBQW9CeEIsVUFBVSxDQUFDLEVBQUUsQ0FBQ3pxQixHQUFHLENBQUMsU0FBVTRDLFFBQVE7WUFDMUQsT0FBT0EsV0FBVyxNQUFNd0I7UUFDMUIsR0FBR2hFLElBQUksQ0FBQztRQUNSLE9BQU87WUFDTDhyQixZQUFZRDtRQUNkO0lBQ0YsT0FBTztRQUNMLE9BQU87WUFDTEMsWUFBWXpCLFdBQVdycUIsSUFBSSxDQUFDO1FBQzlCO0lBQ0Y7QUFDRjtBQUVnbEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYmMvLi9ub2RlX21vZHVsZXMvcG9saXNoZWQvZGlzdC9wb2xpc2hlZC5lc20uanM/YzdjOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgX2Fzc2VydFRoaXNJbml0aWFsaXplZCBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQnO1xuaW1wb3J0IF9pbmhlcml0c0xvb3NlIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzTG9vc2UnO1xuaW1wb3J0IF93cmFwTmF0aXZlU3VwZXIgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vd3JhcE5hdGl2ZVN1cGVyJztcbmltcG9ydCBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsTG9vc2UgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdGFnZ2VkVGVtcGxhdGVMaXRlcmFsTG9vc2UnO1xuXG5mdW5jdGlvbiBsYXN0KCkge1xuICB2YXIgX3JlZjtcbiAgcmV0dXJuIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoIC0gMSwgX3JlZiA8IDAgfHwgYXJndW1lbnRzLmxlbmd0aCA8PSBfcmVmID8gdW5kZWZpbmVkIDogYXJndW1lbnRzW19yZWZdO1xufVxuZnVuY3Rpb24gbmVnYXRpb24oYSkge1xuICByZXR1cm4gLWE7XG59XG5mdW5jdGlvbiBhZGRpdGlvbihhLCBiKSB7XG4gIHJldHVybiBhICsgYjtcbn1cbmZ1bmN0aW9uIHN1YnRyYWN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgLSBiO1xufVxuZnVuY3Rpb24gbXVsdGlwbGljYXRpb24oYSwgYikge1xuICByZXR1cm4gYSAqIGI7XG59XG5mdW5jdGlvbiBkaXZpc2lvbihhLCBiKSB7XG4gIHJldHVybiBhIC8gYjtcbn1cbmZ1bmN0aW9uIG1heCgpIHtcbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBtaW4oKSB7XG4gIHJldHVybiBNYXRoLm1pbi5hcHBseShNYXRoLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gY29tbWEoKSB7XG4gIHJldHVybiBBcnJheS5vZi5hcHBseShBcnJheSwgYXJndW1lbnRzKTtcbn1cbnZhciBkZWZhdWx0U3ltYm9scyA9IHtcbiAgc3ltYm9sczoge1xuICAgICcqJzoge1xuICAgICAgaW5maXg6IHtcbiAgICAgICAgc3ltYm9sOiAnKicsXG4gICAgICAgIGY6IG11bHRpcGxpY2F0aW9uLFxuICAgICAgICBub3RhdGlvbjogJ2luZml4JyxcbiAgICAgICAgcHJlY2VkZW5jZTogNCxcbiAgICAgICAgcmlnaHRUb0xlZnQ6IDAsXG4gICAgICAgIGFyZ0NvdW50OiAyXG4gICAgICB9LFxuICAgICAgc3ltYm9sOiAnKicsXG4gICAgICByZWdTeW1ib2w6ICdcXFxcKidcbiAgICB9LFxuICAgICcvJzoge1xuICAgICAgaW5maXg6IHtcbiAgICAgICAgc3ltYm9sOiAnLycsXG4gICAgICAgIGY6IGRpdmlzaW9uLFxuICAgICAgICBub3RhdGlvbjogJ2luZml4JyxcbiAgICAgICAgcHJlY2VkZW5jZTogNCxcbiAgICAgICAgcmlnaHRUb0xlZnQ6IDAsXG4gICAgICAgIGFyZ0NvdW50OiAyXG4gICAgICB9LFxuICAgICAgc3ltYm9sOiAnLycsXG4gICAgICByZWdTeW1ib2w6ICcvJ1xuICAgIH0sXG4gICAgJysnOiB7XG4gICAgICBpbmZpeDoge1xuICAgICAgICBzeW1ib2w6ICcrJyxcbiAgICAgICAgZjogYWRkaXRpb24sXG4gICAgICAgIG5vdGF0aW9uOiAnaW5maXgnLFxuICAgICAgICBwcmVjZWRlbmNlOiAyLFxuICAgICAgICByaWdodFRvTGVmdDogMCxcbiAgICAgICAgYXJnQ291bnQ6IDJcbiAgICAgIH0sXG4gICAgICBwcmVmaXg6IHtcbiAgICAgICAgc3ltYm9sOiAnKycsXG4gICAgICAgIGY6IGxhc3QsXG4gICAgICAgIG5vdGF0aW9uOiAncHJlZml4JyxcbiAgICAgICAgcHJlY2VkZW5jZTogMyxcbiAgICAgICAgcmlnaHRUb0xlZnQ6IDAsXG4gICAgICAgIGFyZ0NvdW50OiAxXG4gICAgICB9LFxuICAgICAgc3ltYm9sOiAnKycsXG4gICAgICByZWdTeW1ib2w6ICdcXFxcKydcbiAgICB9LFxuICAgICctJzoge1xuICAgICAgaW5maXg6IHtcbiAgICAgICAgc3ltYm9sOiAnLScsXG4gICAgICAgIGY6IHN1YnRyYWN0aW9uLFxuICAgICAgICBub3RhdGlvbjogJ2luZml4JyxcbiAgICAgICAgcHJlY2VkZW5jZTogMixcbiAgICAgICAgcmlnaHRUb0xlZnQ6IDAsXG4gICAgICAgIGFyZ0NvdW50OiAyXG4gICAgICB9LFxuICAgICAgcHJlZml4OiB7XG4gICAgICAgIHN5bWJvbDogJy0nLFxuICAgICAgICBmOiBuZWdhdGlvbixcbiAgICAgICAgbm90YXRpb246ICdwcmVmaXgnLFxuICAgICAgICBwcmVjZWRlbmNlOiAzLFxuICAgICAgICByaWdodFRvTGVmdDogMCxcbiAgICAgICAgYXJnQ291bnQ6IDFcbiAgICAgIH0sXG4gICAgICBzeW1ib2w6ICctJyxcbiAgICAgIHJlZ1N5bWJvbDogJy0nXG4gICAgfSxcbiAgICAnLCc6IHtcbiAgICAgIGluZml4OiB7XG4gICAgICAgIHN5bWJvbDogJywnLFxuICAgICAgICBmOiBjb21tYSxcbiAgICAgICAgbm90YXRpb246ICdpbmZpeCcsXG4gICAgICAgIHByZWNlZGVuY2U6IDEsXG4gICAgICAgIHJpZ2h0VG9MZWZ0OiAwLFxuICAgICAgICBhcmdDb3VudDogMlxuICAgICAgfSxcbiAgICAgIHN5bWJvbDogJywnLFxuICAgICAgcmVnU3ltYm9sOiAnLCdcbiAgICB9LFxuICAgICcoJzoge1xuICAgICAgcHJlZml4OiB7XG4gICAgICAgIHN5bWJvbDogJygnLFxuICAgICAgICBmOiBsYXN0LFxuICAgICAgICBub3RhdGlvbjogJ3ByZWZpeCcsXG4gICAgICAgIHByZWNlZGVuY2U6IDAsXG4gICAgICAgIHJpZ2h0VG9MZWZ0OiAwLFxuICAgICAgICBhcmdDb3VudDogMVxuICAgICAgfSxcbiAgICAgIHN5bWJvbDogJygnLFxuICAgICAgcmVnU3ltYm9sOiAnXFxcXCgnXG4gICAgfSxcbiAgICAnKSc6IHtcbiAgICAgIHBvc3RmaXg6IHtcbiAgICAgICAgc3ltYm9sOiAnKScsXG4gICAgICAgIGY6IHVuZGVmaW5lZCxcbiAgICAgICAgbm90YXRpb246ICdwb3N0Zml4JyxcbiAgICAgICAgcHJlY2VkZW5jZTogMCxcbiAgICAgICAgcmlnaHRUb0xlZnQ6IDAsXG4gICAgICAgIGFyZ0NvdW50OiAxXG4gICAgICB9LFxuICAgICAgc3ltYm9sOiAnKScsXG4gICAgICByZWdTeW1ib2w6ICdcXFxcKSdcbiAgICB9LFxuICAgIG1pbjoge1xuICAgICAgZnVuYzoge1xuICAgICAgICBzeW1ib2w6ICdtaW4nLFxuICAgICAgICBmOiBtaW4sXG4gICAgICAgIG5vdGF0aW9uOiAnZnVuYycsXG4gICAgICAgIHByZWNlZGVuY2U6IDAsXG4gICAgICAgIHJpZ2h0VG9MZWZ0OiAwLFxuICAgICAgICBhcmdDb3VudDogMVxuICAgICAgfSxcbiAgICAgIHN5bWJvbDogJ21pbicsXG4gICAgICByZWdTeW1ib2w6ICdtaW5cXFxcYidcbiAgICB9LFxuICAgIG1heDoge1xuICAgICAgZnVuYzoge1xuICAgICAgICBzeW1ib2w6ICdtYXgnLFxuICAgICAgICBmOiBtYXgsXG4gICAgICAgIG5vdGF0aW9uOiAnZnVuYycsXG4gICAgICAgIHByZWNlZGVuY2U6IDAsXG4gICAgICAgIHJpZ2h0VG9MZWZ0OiAwLFxuICAgICAgICBhcmdDb3VudDogMVxuICAgICAgfSxcbiAgICAgIHN5bWJvbDogJ21heCcsXG4gICAgICByZWdTeW1ib2w6ICdtYXhcXFxcYidcbiAgICB9XG4gIH1cbn07XG52YXIgZGVmYXVsdFN5bWJvbE1hcCA9IGRlZmF1bHRTeW1ib2xzO1xuXG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vc3R5bGVkLWNvbXBvbmVudHMvc3R5bGVkLWNvbXBvbmVudHMvYmxvYi9mY2Y2ZjM4MDRjNTdhMTRkZDc5ODRkZmFiN2JjMDZlZTJlZGNhMDQ0L3NyYy91dGlscy9lcnJvci5qc1xuLyoqXG4gKiBQYXJzZSBlcnJvcnMubWQgYW5kIHR1cm4gaXQgaW50byBhIHNpbXBsZSBoYXNoIG9mIGNvZGU6IG1lc3NhZ2VcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBFUlJPUlMgPSB7XG4gIFwiMVwiOiBcIlBhc3NlZCBpbnZhbGlkIGFyZ3VtZW50cyB0byBoc2wsIHBsZWFzZSBwYXNzIG11bHRpcGxlIG51bWJlcnMgZS5nLiBoc2woMzYwLCAwLjc1LCAwLjQpIG9yIGFuIG9iamVjdCBlLmcuIHJnYih7IGh1ZTogMjU1LCBzYXR1cmF0aW9uOiAwLjQsIGxpZ2h0bmVzczogMC43NSB9KS5cXG5cXG5cIixcbiAgXCIyXCI6IFwiUGFzc2VkIGludmFsaWQgYXJndW1lbnRzIHRvIGhzbGEsIHBsZWFzZSBwYXNzIG11bHRpcGxlIG51bWJlcnMgZS5nLiBoc2xhKDM2MCwgMC43NSwgMC40LCAwLjcpIG9yIGFuIG9iamVjdCBlLmcuIHJnYih7IGh1ZTogMjU1LCBzYXR1cmF0aW9uOiAwLjQsIGxpZ2h0bmVzczogMC43NSwgYWxwaGE6IDAuNyB9KS5cXG5cXG5cIixcbiAgXCIzXCI6IFwiUGFzc2VkIGFuIGluY29ycmVjdCBhcmd1bWVudCB0byBhIGNvbG9yIGZ1bmN0aW9uLCBwbGVhc2UgcGFzcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGNvbG9yLlxcblxcblwiLFxuICBcIjRcIjogXCJDb3VsZG4ndCBnZW5lcmF0ZSB2YWxpZCByZ2Igc3RyaW5nIGZyb20gJXMsIGl0IHJldHVybmVkICVzLlxcblxcblwiLFxuICBcIjVcIjogXCJDb3VsZG4ndCBwYXJzZSB0aGUgY29sb3Igc3RyaW5nLiBQbGVhc2UgcHJvdmlkZSB0aGUgY29sb3IgYXMgYSBzdHJpbmcgaW4gaGV4LCByZ2IsIHJnYmEsIGhzbCBvciBoc2xhIG5vdGF0aW9uLlxcblxcblwiLFxuICBcIjZcIjogXCJQYXNzZWQgaW52YWxpZCBhcmd1bWVudHMgdG8gcmdiLCBwbGVhc2UgcGFzcyBtdWx0aXBsZSBudW1iZXJzIGUuZy4gcmdiKDI1NSwgMjA1LCAxMDApIG9yIGFuIG9iamVjdCBlLmcuIHJnYih7IHJlZDogMjU1LCBncmVlbjogMjA1LCBibHVlOiAxMDAgfSkuXFxuXFxuXCIsXG4gIFwiN1wiOiBcIlBhc3NlZCBpbnZhbGlkIGFyZ3VtZW50cyB0byByZ2JhLCBwbGVhc2UgcGFzcyBtdWx0aXBsZSBudW1iZXJzIGUuZy4gcmdiKDI1NSwgMjA1LCAxMDAsIDAuNzUpIG9yIGFuIG9iamVjdCBlLmcuIHJnYih7IHJlZDogMjU1LCBncmVlbjogMjA1LCBibHVlOiAxMDAsIGFscGhhOiAwLjc1IH0pLlxcblxcblwiLFxuICBcIjhcIjogXCJQYXNzZWQgaW52YWxpZCBhcmd1bWVudCB0byB0b0NvbG9yU3RyaW5nLCBwbGVhc2UgcGFzcyBhIFJnYkNvbG9yLCBSZ2JhQ29sb3IsIEhzbENvbG9yIG9yIEhzbGFDb2xvciBvYmplY3QuXFxuXFxuXCIsXG4gIFwiOVwiOiBcIlBsZWFzZSBwcm92aWRlIGEgbnVtYmVyIG9mIHN0ZXBzIHRvIHRoZSBtb2R1bGFyU2NhbGUgaGVscGVyLlxcblxcblwiLFxuICBcIjEwXCI6IFwiUGxlYXNlIHBhc3MgYSBudW1iZXIgb3Igb25lIG9mIHRoZSBwcmVkZWZpbmVkIHNjYWxlcyB0byB0aGUgbW9kdWxhclNjYWxlIGhlbHBlciBhcyB0aGUgcmF0aW8uXFxuXFxuXCIsXG4gIFwiMTFcIjogXCJJbnZhbGlkIHZhbHVlIHBhc3NlZCBhcyBiYXNlIHRvIG1vZHVsYXJTY2FsZSwgZXhwZWN0ZWQgbnVtYmVyIG9yIGVtIHN0cmluZyBidXQgZ290IFxcXCIlc1xcXCJcXG5cXG5cIixcbiAgXCIxMlwiOiBcIkV4cGVjdGVkIGEgc3RyaW5nIGVuZGluZyBpbiBcXFwicHhcXFwiIG9yIGEgbnVtYmVyIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gJXMoKSwgZ290IFxcXCIlc1xcXCIgaW5zdGVhZC5cXG5cXG5cIixcbiAgXCIxM1wiOiBcIkV4cGVjdGVkIGEgc3RyaW5nIGVuZGluZyBpbiBcXFwicHhcXFwiIG9yIGEgbnVtYmVyIHBhc3NlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvICVzKCksIGdvdCBcXFwiJXNcXFwiIGluc3RlYWQuXFxuXFxuXCIsXG4gIFwiMTRcIjogXCJQYXNzZWQgaW52YWxpZCBwaXhlbCB2YWx1ZSAoXFxcIiVzXFxcIikgdG8gJXMoKSwgcGxlYXNlIHBhc3MgYSB2YWx1ZSBsaWtlIFxcXCIxMnB4XFxcIiBvciAxMi5cXG5cXG5cIixcbiAgXCIxNVwiOiBcIlBhc3NlZCBpbnZhbGlkIGJhc2UgdmFsdWUgKFxcXCIlc1xcXCIpIHRvICVzKCksIHBsZWFzZSBwYXNzIGEgdmFsdWUgbGlrZSBcXFwiMTJweFxcXCIgb3IgMTIuXFxuXFxuXCIsXG4gIFwiMTZcIjogXCJZb3UgbXVzdCBwcm92aWRlIGEgdGVtcGxhdGUgdG8gdGhpcyBtZXRob2QuXFxuXFxuXCIsXG4gIFwiMTdcIjogXCJZb3UgcGFzc2VkIGFuIHVuc3VwcG9ydGVkIHNlbGVjdG9yIHN0YXRlIHRvIHRoaXMgbWV0aG9kLlxcblxcblwiLFxuICBcIjE4XCI6IFwibWluU2NyZWVuIGFuZCBtYXhTY3JlZW4gbXVzdCBiZSBwcm92aWRlZCBhcyBzdHJpbmdpZmllZCBudW1iZXJzIHdpdGggdGhlIHNhbWUgdW5pdHMuXFxuXFxuXCIsXG4gIFwiMTlcIjogXCJmcm9tU2l6ZSBhbmQgdG9TaXplIG11c3QgYmUgcHJvdmlkZWQgYXMgc3RyaW5naWZpZWQgbnVtYmVycyB3aXRoIHRoZSBzYW1lIHVuaXRzLlxcblxcblwiLFxuICBcIjIwXCI6IFwiZXhwZWN0cyBlaXRoZXIgYW4gYXJyYXkgb2Ygb2JqZWN0cyBvciBhIHNpbmdsZSBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBwcm9wLCBmcm9tU2l6ZSwgYW5kIHRvU2l6ZS5cXG5cXG5cIixcbiAgXCIyMVwiOiBcImV4cGVjdHMgdGhlIG9iamVjdHMgaW4gdGhlIGZpcnN0IGFyZ3VtZW50IGFycmF5IHRvIGhhdmUgdGhlIHByb3BlcnRpZXMgYHByb3BgLCBgZnJvbVNpemVgLCBhbmQgYHRvU2l6ZWAuXFxuXFxuXCIsXG4gIFwiMjJcIjogXCJleHBlY3RzIHRoZSBmaXJzdCBhcmd1bWVudCBvYmplY3QgdG8gaGF2ZSB0aGUgcHJvcGVydGllcyBgcHJvcGAsIGBmcm9tU2l6ZWAsIGFuZCBgdG9TaXplYC5cXG5cXG5cIixcbiAgXCIyM1wiOiBcImZvbnRGYWNlIGV4cGVjdHMgYSBuYW1lIG9mIGEgZm9udC1mYW1pbHkuXFxuXFxuXCIsXG4gIFwiMjRcIjogXCJmb250RmFjZSBleHBlY3RzIGVpdGhlciB0aGUgcGF0aCB0byB0aGUgZm9udCBmaWxlKHMpIG9yIGEgbmFtZSBvZiBhIGxvY2FsIGNvcHkuXFxuXFxuXCIsXG4gIFwiMjVcIjogXCJmb250RmFjZSBleHBlY3RzIGxvY2FsRm9udHMgdG8gYmUgYW4gYXJyYXkuXFxuXFxuXCIsXG4gIFwiMjZcIjogXCJmb250RmFjZSBleHBlY3RzIGZpbGVGb3JtYXRzIHRvIGJlIGFuIGFycmF5LlxcblxcblwiLFxuICBcIjI3XCI6IFwicmFkaWFsR3JhZGllbnQgcmVxdXJpZXMgYXQgbGVhc3QgMiBjb2xvci1zdG9wcyB0byBwcm9wZXJseSByZW5kZXIuXFxuXFxuXCIsXG4gIFwiMjhcIjogXCJQbGVhc2Ugc3VwcGx5IGEgZmlsZW5hbWUgdG8gcmV0aW5hSW1hZ2UoKSBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXFxuXFxuXCIsXG4gIFwiMjlcIjogXCJQYXNzZWQgaW52YWxpZCBhcmd1bWVudCB0byB0cmlhbmdsZSwgcGxlYXNlIHBhc3MgY29ycmVjdCBwb2ludGluZ0RpcmVjdGlvbiBlLmcuICdyaWdodCcuXFxuXFxuXCIsXG4gIFwiMzBcIjogXCJQYXNzZWQgYW4gaW52YWxpZCB2YWx1ZSB0byBgaGVpZ2h0YCBvciBgd2lkdGhgLiBQbGVhc2UgcHJvdmlkZSBhIHBpeGVsIGJhc2VkIHVuaXQuXFxuXFxuXCIsXG4gIFwiMzFcIjogXCJUaGUgYW5pbWF0aW9uIHNob3J0aGFuZCBvbmx5IHRha2VzIDggYXJndW1lbnRzLiBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHA6Ly9tZG4uaW8vYW5pbWF0aW9uXFxuXFxuXCIsXG4gIFwiMzJcIjogXCJUbyBwYXNzIG11bHRpcGxlIGFuaW1hdGlvbnMgcGxlYXNlIHN1cHBseSB0aGVtIGluIGFycmF5cywgZS5nLiBhbmltYXRpb24oWydyb3RhdGUnLCAnMnMnXSwgWydtb3ZlJywgJzFzJ10pXFxuVG8gcGFzcyBhIHNpbmdsZSBhbmltYXRpb24gcGxlYXNlIHN1cHBseSB0aGVtIGluIHNpbXBsZSB2YWx1ZXMsIGUuZy4gYW5pbWF0aW9uKCdyb3RhdGUnLCAnMnMnKVxcblxcblwiLFxuICBcIjMzXCI6IFwiVGhlIGFuaW1hdGlvbiBzaG9ydGhhbmQgYXJyYXlzIGNhbiBvbmx5IGhhdmUgOCBlbGVtZW50cy4gU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwOi8vbWRuLmlvL2FuaW1hdGlvblxcblxcblwiLFxuICBcIjM0XCI6IFwiYm9yZGVyUmFkaXVzIGV4cGVjdHMgYSByYWRpdXMgdmFsdWUgYXMgYSBzdHJpbmcgb3IgbnVtYmVyIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXFxuXFxuXCIsXG4gIFwiMzVcIjogXCJib3JkZXJSYWRpdXMgZXhwZWN0cyBvbmUgb2YgXFxcInRvcFxcXCIsIFxcXCJib3R0b21cXFwiLCBcXFwibGVmdFxcXCIgb3IgXFxcInJpZ2h0XFxcIiBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXFxuXFxuXCIsXG4gIFwiMzZcIjogXCJQcm9wZXJ0eSBtdXN0IGJlIGEgc3RyaW5nIHZhbHVlLlxcblxcblwiLFxuICBcIjM3XCI6IFwiU3ludGF4IEVycm9yIGF0ICVzLlxcblxcblwiLFxuICBcIjM4XCI6IFwiRm9ybXVsYSBjb250YWlucyBhIGZ1bmN0aW9uIHRoYXQgbmVlZHMgcGFyZW50aGVzZXMgYXQgJXMuXFxuXFxuXCIsXG4gIFwiMzlcIjogXCJGb3JtdWxhIGlzIG1pc3NpbmcgY2xvc2luZyBwYXJlbnRoZXNpcyBhdCAlcy5cXG5cXG5cIixcbiAgXCI0MFwiOiBcIkZvcm11bGEgaGFzIHRvbyBtYW55IGNsb3NpbmcgcGFyZW50aGVzZXMgYXQgJXMuXFxuXFxuXCIsXG4gIFwiNDFcIjogXCJBbGwgdmFsdWVzIGluIGEgZm9ybXVsYSBtdXN0IGhhdmUgdGhlIHNhbWUgdW5pdCBvciBiZSB1bml0bGVzcy5cXG5cXG5cIixcbiAgXCI0MlwiOiBcIlBsZWFzZSBwcm92aWRlIGEgbnVtYmVyIG9mIHN0ZXBzIHRvIHRoZSBtb2R1bGFyU2NhbGUgaGVscGVyLlxcblxcblwiLFxuICBcIjQzXCI6IFwiUGxlYXNlIHBhc3MgYSBudW1iZXIgb3Igb25lIG9mIHRoZSBwcmVkZWZpbmVkIHNjYWxlcyB0byB0aGUgbW9kdWxhclNjYWxlIGhlbHBlciBhcyB0aGUgcmF0aW8uXFxuXFxuXCIsXG4gIFwiNDRcIjogXCJJbnZhbGlkIHZhbHVlIHBhc3NlZCBhcyBiYXNlIHRvIG1vZHVsYXJTY2FsZSwgZXhwZWN0ZWQgbnVtYmVyIG9yIGVtL3JlbSBzdHJpbmcgYnV0IGdvdCAlcy5cXG5cXG5cIixcbiAgXCI0NVwiOiBcIlBhc3NlZCBpbnZhbGlkIGFyZ3VtZW50IHRvIGhzbFRvQ29sb3JTdHJpbmcsIHBsZWFzZSBwYXNzIGEgSHNsQ29sb3Igb3IgSHNsYUNvbG9yIG9iamVjdC5cXG5cXG5cIixcbiAgXCI0NlwiOiBcIlBhc3NlZCBpbnZhbGlkIGFyZ3VtZW50IHRvIHJnYlRvQ29sb3JTdHJpbmcsIHBsZWFzZSBwYXNzIGEgUmdiQ29sb3Igb3IgUmdiYUNvbG9yIG9iamVjdC5cXG5cXG5cIixcbiAgXCI0N1wiOiBcIm1pblNjcmVlbiBhbmQgbWF4U2NyZWVuIG11c3QgYmUgcHJvdmlkZWQgYXMgc3RyaW5naWZpZWQgbnVtYmVycyB3aXRoIHRoZSBzYW1lIHVuaXRzLlxcblxcblwiLFxuICBcIjQ4XCI6IFwiZnJvbVNpemUgYW5kIHRvU2l6ZSBtdXN0IGJlIHByb3ZpZGVkIGFzIHN0cmluZ2lmaWVkIG51bWJlcnMgd2l0aCB0aGUgc2FtZSB1bml0cy5cXG5cXG5cIixcbiAgXCI0OVwiOiBcIkV4cGVjdHMgZWl0aGVyIGFuIGFycmF5IG9mIG9iamVjdHMgb3IgYSBzaW5nbGUgb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgcHJvcCwgZnJvbVNpemUsIGFuZCB0b1NpemUuXFxuXFxuXCIsXG4gIFwiNTBcIjogXCJFeHBlY3RzIHRoZSBvYmplY3RzIGluIHRoZSBmaXJzdCBhcmd1bWVudCBhcnJheSB0byBoYXZlIHRoZSBwcm9wZXJ0aWVzIHByb3AsIGZyb21TaXplLCBhbmQgdG9TaXplLlxcblxcblwiLFxuICBcIjUxXCI6IFwiRXhwZWN0cyB0aGUgZmlyc3QgYXJndW1lbnQgb2JqZWN0IHRvIGhhdmUgdGhlIHByb3BlcnRpZXMgcHJvcCwgZnJvbVNpemUsIGFuZCB0b1NpemUuXFxuXFxuXCIsXG4gIFwiNTJcIjogXCJmb250RmFjZSBleHBlY3RzIGVpdGhlciB0aGUgcGF0aCB0byB0aGUgZm9udCBmaWxlKHMpIG9yIGEgbmFtZSBvZiBhIGxvY2FsIGNvcHkuXFxuXFxuXCIsXG4gIFwiNTNcIjogXCJmb250RmFjZSBleHBlY3RzIGxvY2FsRm9udHMgdG8gYmUgYW4gYXJyYXkuXFxuXFxuXCIsXG4gIFwiNTRcIjogXCJmb250RmFjZSBleHBlY3RzIGZpbGVGb3JtYXRzIHRvIGJlIGFuIGFycmF5LlxcblxcblwiLFxuICBcIjU1XCI6IFwiZm9udEZhY2UgZXhwZWN0cyBhIG5hbWUgb2YgYSBmb250LWZhbWlseS5cXG5cXG5cIixcbiAgXCI1NlwiOiBcImxpbmVhckdyYWRpZW50IHJlcXVyaWVzIGF0IGxlYXN0IDIgY29sb3Itc3RvcHMgdG8gcHJvcGVybHkgcmVuZGVyLlxcblxcblwiLFxuICBcIjU3XCI6IFwicmFkaWFsR3JhZGllbnQgcmVxdXJpZXMgYXQgbGVhc3QgMiBjb2xvci1zdG9wcyB0byBwcm9wZXJseSByZW5kZXIuXFxuXFxuXCIsXG4gIFwiNThcIjogXCJQbGVhc2Ugc3VwcGx5IGEgZmlsZW5hbWUgdG8gcmV0aW5hSW1hZ2UoKSBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXFxuXFxuXCIsXG4gIFwiNTlcIjogXCJQYXNzZWQgaW52YWxpZCBhcmd1bWVudCB0byB0cmlhbmdsZSwgcGxlYXNlIHBhc3MgY29ycmVjdCBwb2ludGluZ0RpcmVjdGlvbiBlLmcuICdyaWdodCcuXFxuXFxuXCIsXG4gIFwiNjBcIjogXCJQYXNzZWQgYW4gaW52YWxpZCB2YWx1ZSB0byBgaGVpZ2h0YCBvciBgd2lkdGhgLiBQbGVhc2UgcHJvdmlkZSBhIHBpeGVsIGJhc2VkIHVuaXQuXFxuXFxuXCIsXG4gIFwiNjFcIjogXCJQcm9wZXJ0eSBtdXN0IGJlIGEgc3RyaW5nIHZhbHVlLlxcblxcblwiLFxuICBcIjYyXCI6IFwiYm9yZGVyUmFkaXVzIGV4cGVjdHMgYSByYWRpdXMgdmFsdWUgYXMgYSBzdHJpbmcgb3IgbnVtYmVyIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXFxuXFxuXCIsXG4gIFwiNjNcIjogXCJib3JkZXJSYWRpdXMgZXhwZWN0cyBvbmUgb2YgXFxcInRvcFxcXCIsIFxcXCJib3R0b21cXFwiLCBcXFwibGVmdFxcXCIgb3IgXFxcInJpZ2h0XFxcIiBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXFxuXFxuXCIsXG4gIFwiNjRcIjogXCJUaGUgYW5pbWF0aW9uIHNob3J0aGFuZCBvbmx5IHRha2VzIDggYXJndW1lbnRzLiBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHA6Ly9tZG4uaW8vYW5pbWF0aW9uLlxcblxcblwiLFxuICBcIjY1XCI6IFwiVG8gcGFzcyBtdWx0aXBsZSBhbmltYXRpb25zIHBsZWFzZSBzdXBwbHkgdGhlbSBpbiBhcnJheXMsIGUuZy4gYW5pbWF0aW9uKFsncm90YXRlJywgJzJzJ10sIFsnbW92ZScsICcxcyddKVxcXFxuVG8gcGFzcyBhIHNpbmdsZSBhbmltYXRpb24gcGxlYXNlIHN1cHBseSB0aGVtIGluIHNpbXBsZSB2YWx1ZXMsIGUuZy4gYW5pbWF0aW9uKCdyb3RhdGUnLCAnMnMnKS5cXG5cXG5cIixcbiAgXCI2NlwiOiBcIlRoZSBhbmltYXRpb24gc2hvcnRoYW5kIGFycmF5cyBjYW4gb25seSBoYXZlIDggZWxlbWVudHMuIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cDovL21kbi5pby9hbmltYXRpb24uXFxuXFxuXCIsXG4gIFwiNjdcIjogXCJZb3UgbXVzdCBwcm92aWRlIGEgdGVtcGxhdGUgdG8gdGhpcyBtZXRob2QuXFxuXFxuXCIsXG4gIFwiNjhcIjogXCJZb3UgcGFzc2VkIGFuIHVuc3VwcG9ydGVkIHNlbGVjdG9yIHN0YXRlIHRvIHRoaXMgbWV0aG9kLlxcblxcblwiLFxuICBcIjY5XCI6IFwiRXhwZWN0ZWQgYSBzdHJpbmcgZW5kaW5nIGluIFxcXCJweFxcXCIgb3IgYSBudW1iZXIgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byAlcygpLCBnb3QgJXMgaW5zdGVhZC5cXG5cXG5cIixcbiAgXCI3MFwiOiBcIkV4cGVjdGVkIGEgc3RyaW5nIGVuZGluZyBpbiBcXFwicHhcXFwiIG9yIGEgbnVtYmVyIHBhc3NlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvICVzKCksIGdvdCAlcyBpbnN0ZWFkLlxcblxcblwiLFxuICBcIjcxXCI6IFwiUGFzc2VkIGludmFsaWQgcGl4ZWwgdmFsdWUgJXMgdG8gJXMoKSwgcGxlYXNlIHBhc3MgYSB2YWx1ZSBsaWtlIFxcXCIxMnB4XFxcIiBvciAxMi5cXG5cXG5cIixcbiAgXCI3MlwiOiBcIlBhc3NlZCBpbnZhbGlkIGJhc2UgdmFsdWUgJXMgdG8gJXMoKSwgcGxlYXNlIHBhc3MgYSB2YWx1ZSBsaWtlIFxcXCIxMnB4XFxcIiBvciAxMi5cXG5cXG5cIixcbiAgXCI3M1wiOiBcIlBsZWFzZSBwcm92aWRlIGEgdmFsaWQgQ1NTIHZhcmlhYmxlLlxcblxcblwiLFxuICBcIjc0XCI6IFwiQ1NTIHZhcmlhYmxlIG5vdCBmb3VuZCBhbmQgbm8gZGVmYXVsdCB3YXMgcHJvdmlkZWQuXFxuXFxuXCIsXG4gIFwiNzVcIjogXCJpbXBvcnRhbnQgcmVxdWlyZXMgYSB2YWxpZCBzdHlsZSBvYmplY3QsIGdvdCBhICVzIGluc3RlYWQuXFxuXFxuXCIsXG4gIFwiNzZcIjogXCJmcm9tU2l6ZSBhbmQgdG9TaXplIG11c3QgYmUgcHJvdmlkZWQgYXMgc3RyaW5naWZpZWQgbnVtYmVycyB3aXRoIHRoZSBzYW1lIHVuaXRzIGFzIG1pblNjcmVlbiBhbmQgbWF4U2NyZWVuLlxcblxcblwiLFxuICBcIjc3XCI6IFwicmVtVG9QeCBleHBlY3RzIGEgdmFsdWUgaW4gXFxcInJlbVxcXCIgYnV0IHlvdSBwcm92aWRlZCBpdCBpbiBcXFwiJXNcXFwiLlxcblxcblwiLFxuICBcIjc4XCI6IFwiYmFzZSBtdXN0IGJlIHNldCBpbiBcXFwicHhcXFwiIG9yIFxcXCIlXFxcIiBidXQgeW91IHNldCBpdCBpbiBcXFwiJXNcXFwiLlxcblwiXG59O1xuXG4vKipcbiAqIHN1cGVyIGJhc2ljIHZlcnNpb24gb2Ygc3ByaW50ZlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZm9ybWF0KCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIHZhciBhID0gYXJnc1swXTtcbiAgdmFyIGIgPSBbXTtcbiAgdmFyIGM7XG4gIGZvciAoYyA9IDE7IGMgPCBhcmdzLmxlbmd0aDsgYyArPSAxKSB7XG4gICAgYi5wdXNoKGFyZ3NbY10pO1xuICB9XG4gIGIuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgIGEgPSBhLnJlcGxhY2UoLyVbYS16XS8sIGQpO1xuICB9KTtcbiAgcmV0dXJuIGE7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGVycm9yIGZpbGUgb3V0IG9mIGVycm9ycy5tZCBmb3IgZGV2ZWxvcG1lbnQgYW5kIGEgc2ltcGxlIHdlYiBsaW5rIHRvIHRoZSBmdWxsIGVycm9yc1xuICogaW4gcHJvZHVjdGlvbiBtb2RlLlxuICogQHByaXZhdGVcbiAqL1xudmFyIFBvbGlzaGVkRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHNMb29zZShQb2xpc2hlZEVycm9yLCBfRXJyb3IpO1xuICBmdW5jdGlvbiBQb2xpc2hlZEVycm9yKGNvZGUpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIF90aGlzID0gX0Vycm9yLmNhbGwodGhpcywgXCJBbiBlcnJvciBvY2N1cnJlZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdHlsZWQtY29tcG9uZW50cy9wb2xpc2hlZC9ibG9iL21haW4vc3JjL2ludGVybmFsSGVscGVycy9lcnJvcnMubWQjXCIgKyBjb2RlICsgXCIgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCIpIHx8IHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG4gICAgICBfdGhpcyA9IF9FcnJvci5jYWxsKHRoaXMsIGZvcm1hdC5hcHBseSh2b2lkIDAsIFtFUlJPUlNbY29kZV1dLmNvbmNhdChhcmdzKSkpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKTtcbiAgfVxuICByZXR1cm4gUG9saXNoZWRFcnJvcjtcbn0oIC8qI19fUFVSRV9fKi9fd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG5cbnZhciB1bml0UmVnRXhwID0gLygoPyFcXHcpYXxuYXxoY3xtY3xkZ3xtZVtyXT98eGV8bmkoPyFbYS16QS1aXSl8bW18Y3B8dHB8eHB8cSg/IXMpfGh2fHhhbXZ8bmltdnx3dnxzbXxzKD8hXFxEfCQpfGdlZHxkYXJnP3xucnV0KS9nO1xuXG4vLyBNZXJnZXMgYWRkaXRpb25hbCBtYXRoIGZ1bmN0aW9uYWxpdHkgaW50byB0aGUgZGVmYXVsdHMuXG5mdW5jdGlvbiBtZXJnZVN5bWJvbE1hcHMoYWRkaXRpb25hbFN5bWJvbHMpIHtcbiAgdmFyIHN5bWJvbE1hcCA9IHt9O1xuICBzeW1ib2xNYXAuc3ltYm9scyA9IGFkZGl0aW9uYWxTeW1ib2xzID8gX2V4dGVuZHMoe30sIGRlZmF1bHRTeW1ib2xNYXAuc3ltYm9scywgYWRkaXRpb25hbFN5bWJvbHMuc3ltYm9scykgOiBfZXh0ZW5kcyh7fSwgZGVmYXVsdFN5bWJvbE1hcC5zeW1ib2xzKTtcbiAgcmV0dXJuIHN5bWJvbE1hcDtcbn1cbmZ1bmN0aW9uIGV4ZWMob3BlcmF0b3JzLCB2YWx1ZXMpIHtcbiAgdmFyIF9yZWY7XG4gIHZhciBvcCA9IG9wZXJhdG9ycy5wb3AoKTtcbiAgdmFsdWVzLnB1c2gob3AuZi5hcHBseShvcCwgKF9yZWYgPSBbXSkuY29uY2F0LmFwcGx5KF9yZWYsIHZhbHVlcy5zcGxpY2UoLW9wLmFyZ0NvdW50KSkpKTtcbiAgcmV0dXJuIG9wLnByZWNlZGVuY2U7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGUoZXhwcmVzc2lvbiwgYWRkaXRpb25hbFN5bWJvbHMpIHtcbiAgdmFyIHN5bWJvbE1hcCA9IG1lcmdlU3ltYm9sTWFwcyhhZGRpdGlvbmFsU3ltYm9scyk7XG4gIHZhciBtYXRjaDtcbiAgdmFyIG9wZXJhdG9ycyA9IFtzeW1ib2xNYXAuc3ltYm9sc1snKCddLnByZWZpeF07XG4gIHZhciB2YWx1ZXMgPSBbXTtcbiAgdmFyIHBhdHRlcm4gPSBuZXcgUmVnRXhwKCAvLyBQYXR0ZXJuIGZvciBudW1iZXJzXG4gIFwiXFxcXGQrKD86XFxcXC5cXFxcZCspP3xcIiArXG4gIC8vIC4uLmFuZCBwYXR0ZXJucyBmb3IgaW5kaXZpZHVhbCBvcGVyYXRvcnMvZnVuY3Rpb24gbmFtZXNcbiAgT2JqZWN0LmtleXMoc3ltYm9sTWFwLnN5bWJvbHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHN5bWJvbE1hcC5zeW1ib2xzW2tleV07XG4gIH0pXG4gIC8vIGxvbmdlciBzeW1ib2xzIHNob3VsZCBiZSBsaXN0ZWQgZmlyc3RcbiAgLy8gJEZsb3dGaXhNZVxuICAuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLnN5bWJvbC5sZW5ndGggLSBhLnN5bWJvbC5sZW5ndGg7XG4gIH0pXG4gIC8vICRGbG93Rml4TWVcbiAgLm1hcChmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIHZhbC5yZWdTeW1ib2w7XG4gIH0pLmpvaW4oJ3wnKSArIFwifChcXFxcUylcIiwgJ2cnKTtcbiAgcGF0dGVybi5sYXN0SW5kZXggPSAwOyAvLyBSZXNldCByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0XG5cbiAgdmFyIGFmdGVyVmFsdWUgPSBmYWxzZTtcbiAgZG8ge1xuICAgIG1hdGNoID0gcGF0dGVybi5leGVjKGV4cHJlc3Npb24pO1xuICAgIHZhciBfcmVmMiA9IG1hdGNoIHx8IFsnKScsIHVuZGVmaW5lZF0sXG4gICAgICB0b2tlbiA9IF9yZWYyWzBdLFxuICAgICAgYmFkID0gX3JlZjJbMV07XG4gICAgdmFyIG5vdE51bWJlciA9IHN5bWJvbE1hcC5zeW1ib2xzW3Rva2VuXTtcbiAgICB2YXIgbm90TmV3VmFsdWUgPSBub3ROdW1iZXIgJiYgIW5vdE51bWJlci5wcmVmaXggJiYgIW5vdE51bWJlci5mdW5jO1xuICAgIHZhciBub3RBZnRlclZhbHVlID0gIW5vdE51bWJlciB8fCAhbm90TnVtYmVyLnBvc3RmaXggJiYgIW5vdE51bWJlci5pbmZpeDtcblxuICAgIC8vIENoZWNrIGZvciBzeW50YXggZXJyb3JzOlxuICAgIGlmIChiYWQgfHwgKGFmdGVyVmFsdWUgPyBub3RBZnRlclZhbHVlIDogbm90TmV3VmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcigzNywgbWF0Y2ggPyBtYXRjaC5pbmRleCA6IGV4cHJlc3Npb24ubGVuZ3RoLCBleHByZXNzaW9uKTtcbiAgICB9XG4gICAgaWYgKGFmdGVyVmFsdWUpIHtcbiAgICAgIC8vIFdlIGVpdGhlciBoYXZlIGFuIGluZml4IG9yIHBvc3RmaXggb3BlcmF0b3IgKHRoZXkgc2hvdWxkIGJlIG11dHVhbGx5IGV4Y2x1c2l2ZSlcbiAgICAgIHZhciBjdXJyID0gbm90TnVtYmVyLnBvc3RmaXggfHwgbm90TnVtYmVyLmluZml4O1xuICAgICAgZG8ge1xuICAgICAgICB2YXIgcHJldiA9IG9wZXJhdG9yc1tvcGVyYXRvcnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICgoY3Vyci5wcmVjZWRlbmNlIC0gcHJldi5wcmVjZWRlbmNlIHx8IHByZXYucmlnaHRUb0xlZnQpID4gMCkgYnJlYWs7XG4gICAgICAgIC8vIEFwcGx5IHByZXZpb3VzIG9wZXJhdG9yLCBzaW5jZSBpdCBoYXMgcHJlY2VkZW5jZSBvdmVyIGN1cnJlbnQgb25lXG4gICAgICB9IHdoaWxlIChleGVjKG9wZXJhdG9ycywgdmFsdWVzKSk7IC8vIEV4aXQgbG9vcCBhZnRlciBleGVjdXRpbmcgYW4gb3BlbmluZyBwYXJlbnRoZXNpcyBvciBmdW5jdGlvblxuICAgICAgYWZ0ZXJWYWx1ZSA9IGN1cnIubm90YXRpb24gPT09ICdwb3N0Zml4JztcbiAgICAgIGlmIChjdXJyLnN5bWJvbCAhPT0gJyknKSB7XG4gICAgICAgIG9wZXJhdG9ycy5wdXNoKGN1cnIpO1xuICAgICAgICAvLyBQb3N0Zml4IGFsd2F5cyBoYXMgcHJlY2VkZW5jZSBvdmVyIGFueSBvcGVyYXRvciB0aGF0IGZvbGxvd3MgYWZ0ZXIgaXRcbiAgICAgICAgaWYgKGFmdGVyVmFsdWUpIGV4ZWMob3BlcmF0b3JzLCB2YWx1ZXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm90TnVtYmVyKSB7XG4gICAgICAvLyBwcmVmaXggb3BlcmF0b3Igb3IgZnVuY3Rpb25cbiAgICAgIG9wZXJhdG9ycy5wdXNoKG5vdE51bWJlci5wcmVmaXggfHwgbm90TnVtYmVyLmZ1bmMpO1xuICAgICAgaWYgKG5vdE51bWJlci5mdW5jKSB7XG4gICAgICAgIC8vIFJlcXVpcmUgYW4gb3BlbmluZyBwYXJlbnRoZXNpc1xuICAgICAgICBtYXRjaCA9IHBhdHRlcm4uZXhlYyhleHByZXNzaW9uKTtcbiAgICAgICAgaWYgKCFtYXRjaCB8fCBtYXRjaFswXSAhPT0gJygnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoMzgsIG1hdGNoID8gbWF0Y2guaW5kZXggOiBleHByZXNzaW9uLmxlbmd0aCwgZXhwcmVzc2lvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbnVtYmVyXG4gICAgICB2YWx1ZXMucHVzaCgrdG9rZW4pO1xuICAgICAgYWZ0ZXJWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9IHdoaWxlIChtYXRjaCAmJiBvcGVyYXRvcnMubGVuZ3RoKTtcbiAgaWYgKG9wZXJhdG9ycy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcigzOSwgbWF0Y2ggPyBtYXRjaC5pbmRleCA6IGV4cHJlc3Npb24ubGVuZ3RoLCBleHByZXNzaW9uKTtcbiAgfSBlbHNlIGlmIChtYXRjaCkge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDQwLCBtYXRjaCA/IG1hdGNoLmluZGV4IDogZXhwcmVzc2lvbi5sZW5ndGgsIGV4cHJlc3Npb24pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZXMucG9wKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJldmVyc2VTdHJpbmcoc3RyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZm9yIGRvaW5nIG1hdGggd2l0aCBDU1MgVW5pdHMuIEFjY2VwdHMgYSBmb3JtdWxhIGFzIGEgc3RyaW5nLiBBbGwgdmFsdWVzIGluIHRoZSBmb3JtdWxhIG11c3QgaGF2ZSB0aGUgc2FtZSB1bml0IChvciBiZSB1bml0bGVzcykuIFN1cHBvcnRzIGNvbXBsZXggZm9ybXVsYXMgdXRsaXppaW5nIGFkZGl0aW9uLCBzdWJ0cmFjdGlvbiwgbXVsdGlwbGljYXRpb24sIGRpdmlzaW9uLCBzcXVhcmUgcm9vdCwgcG93ZXJzLCBmYWN0b3JpYWwsIG1pbiwgbWF4LCBhcyB3ZWxsIGFzIHBhcmVudGhlc2VzIGZvciBvcmRlciBvZiBvcGVyYXRpb24uXG4gKlxuICpJbiBjYXNlcyB3aGVyZSB5b3UgbmVlZCB0byBkbyBjYWxjdWxhdGlvbnMgd2l0aCBtaXhlZCB1bml0cyB3aGVyZSBvbmUgdW5pdCBpcyBhIFtyZWxhdGl2ZSBsZW5ndGggdW5pdF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2xlbmd0aCNSZWxhdGl2ZV9sZW5ndGhfdW5pdHMpLCB5b3Ugd2lsbCB3YW50IHRvIHVzZSBbQ1NTIENhbGNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9jYWxjKS5cbiAqXG4gKiAqd2FybmluZyogV2hpbGUgd2UndmUgZG9uZSBldmVyeXRoaW5nIHBvc3NpYmxlIHRvIGVuc3VyZSBtYXRoIHNhZmVseSBldmFsdXRlcyBmb3JtdWxhcyBleHByZXNzZWQgYXMgc3RyaW5ncywgeW91IHNob3VsZCBhbHdheXMgdXNlIGV4dHJlbWUgY2F1dGlvbiB3aGVuIHBhc3NpbmcgYG1hdGhgIHVzZXIgcHJvdmlkZWQgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgZm9udFNpemU6IG1hdGgoJzEycmVtICsgOHJlbScpLFxuICogICBmb250U2l6ZTogbWF0aCgnKDEycHggKyAycHgpICogMycpLFxuICogICBmb250U2l6ZTogbWF0aCgnM3B4XjIgKyBzcXJ0KDQpJyksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGZvbnRTaXplOiAke21hdGgoJzEycmVtICsgOHJlbScpfTtcbiAqICAgZm9udFNpemU6ICR7bWF0aCgnKDEycHggKyAycHgpICogMycpfTtcbiAqICAgZm9udFNpemU6ICR7bWF0aCgnM3B4XjIgKyBzcXJ0KDQpJyl9O1xuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXY6IHtcbiAqICAgZm9udFNpemU6ICcyMHJlbScsXG4gKiAgIGZvbnRTaXplOiAnNDJweCcsXG4gKiAgIGZvbnRTaXplOiAnMTFweCcsXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIG1hdGgoZm9ybXVsYSwgYWRkaXRpb25hbFN5bWJvbHMpIHtcbiAgdmFyIHJldmVyc2VkRm9ybXVsYSA9IHJldmVyc2VTdHJpbmcoZm9ybXVsYSk7XG4gIHZhciBmb3JtdWxhTWF0Y2ggPSByZXZlcnNlZEZvcm11bGEubWF0Y2godW5pdFJlZ0V4cCk7XG5cbiAgLy8gQ2hlY2sgdGhhdCBhbGwgdW5pdHMgYXJlIHRoZSBzYW1lXG4gIGlmIChmb3JtdWxhTWF0Y2ggJiYgIWZvcm11bGFNYXRjaC5ldmVyeShmdW5jdGlvbiAodW5pdCkge1xuICAgIHJldHVybiB1bml0ID09PSBmb3JtdWxhTWF0Y2hbMF07XG4gIH0pKSB7XG4gICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNDEpO1xuICB9XG4gIHZhciBjbGVhbkZvcm11bGEgPSByZXZlcnNlU3RyaW5nKHJldmVyc2VkRm9ybXVsYS5yZXBsYWNlKHVuaXRSZWdFeHAsICcnKSk7XG4gIHJldHVybiBcIlwiICsgY2FsY3VsYXRlKGNsZWFuRm9ybXVsYSwgYWRkaXRpb25hbFN5bWJvbHMpICsgKGZvcm11bGFNYXRjaCA/IHJldmVyc2VTdHJpbmcoZm9ybXVsYU1hdGNoWzBdKSA6ICcnKTtcbn1cblxudmFyIGNzc1ZhcmlhYmxlUmVnZXggPSAvLS1bXFxTXSovZztcblxuLyoqXG4gKiBGZXRjaGVzIHRoZSB2YWx1ZSBvZiBhIHBhc3NlZCBDU1MgVmFyaWFibGUgaW4gdGhlIDpyb290IHNjb3BlLCBvciBvdGhlcndpc2UgcmV0dXJucyBhIGRlZmF1bHRWYWx1ZSBpZiBwcm92aWRlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAnYmFja2dyb3VuZCc6IGNzc1ZhcignLS1iYWNrZ3JvdW5kLWNvbG9yJyksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7Y3NzVmFyKCctLWJhY2tncm91bmQtY29sb3InKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICAnYmFja2dyb3VuZCc6ICdyZWQnXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGNzc1Zhcihjc3NWYXJpYWJsZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICghY3NzVmFyaWFibGUgfHwgIWNzc1ZhcmlhYmxlLm1hdGNoKGNzc1ZhcmlhYmxlUmVnZXgpKSB7XG4gICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNzMpO1xuICB9XG4gIHZhciB2YXJpYWJsZVZhbHVlO1xuXG4gIC8qIGVzbGludC1kaXNhYmxlICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAhPT0gbnVsbCkge1xuICAgIHZhcmlhYmxlVmFsdWUgPSBnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShjc3NWYXJpYWJsZSk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG4gIGlmICh2YXJpYWJsZVZhbHVlKSB7XG4gICAgcmV0dXJuIHZhcmlhYmxlVmFsdWUudHJpbSgpO1xuICB9IGVsc2UgaWYgKGRlZmF1bHRWYWx1ZSkge1xuICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gIH1cbiAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNzQpO1xufVxuXG4vLyBAcHJpdmF0ZVxuZnVuY3Rpb24gY2FwaXRhbGl6ZVN0cmluZyhzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbn1cblxudmFyIHBvc2l0aW9uTWFwJDEgPSBbJ1RvcCcsICdSaWdodCcsICdCb3R0b20nLCAnTGVmdCddO1xuZnVuY3Rpb24gZ2VuZXJhdGVQcm9wZXJ0eShwcm9wZXJ0eSwgcG9zaXRpb24pIHtcbiAgaWYgKCFwcm9wZXJ0eSkgcmV0dXJuIHBvc2l0aW9uLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBzcGxpdFByb3BlcnR5ID0gcHJvcGVydHkuc3BsaXQoJy0nKTtcbiAgaWYgKHNwbGl0UHJvcGVydHkubGVuZ3RoID4gMSkge1xuICAgIHNwbGl0UHJvcGVydHkuc3BsaWNlKDEsIDAsIHBvc2l0aW9uKTtcbiAgICByZXR1cm4gc3BsaXRQcm9wZXJ0eS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdmFsKSB7XG4gICAgICByZXR1cm4gXCJcIiArIGFjYyArIGNhcGl0YWxpemVTdHJpbmcodmFsKTtcbiAgICB9KTtcbiAgfVxuICB2YXIgam9pbmVkUHJvcGVydHkgPSBwcm9wZXJ0eS5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCBcIiQxXCIgKyBwb3NpdGlvbiArIFwiJDJcIik7XG4gIHJldHVybiBwcm9wZXJ0eSA9PT0gam9pbmVkUHJvcGVydHkgPyBcIlwiICsgcHJvcGVydHkgKyBwb3NpdGlvbiA6IGpvaW5lZFByb3BlcnR5O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVTdHlsZXMocHJvcGVydHksIHZhbHVlc1dpdGhEZWZhdWx0cykge1xuICB2YXIgc3R5bGVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzV2l0aERlZmF1bHRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKHZhbHVlc1dpdGhEZWZhdWx0c1tpXSB8fCB2YWx1ZXNXaXRoRGVmYXVsdHNbaV0gPT09IDApIHtcbiAgICAgIHN0eWxlc1tnZW5lcmF0ZVByb3BlcnR5KHByb3BlcnR5LCBwb3NpdGlvbk1hcCQxW2ldKV0gPSB2YWx1ZXNXaXRoRGVmYXVsdHNbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZXM7XG59XG5cbi8qKlxuICogRW5hYmxlcyBzaG9ydGhhbmQgZm9yIGRpcmVjdGlvbi1iYXNlZCBwcm9wZXJ0aWVzLiBJdCBhY2NlcHRzIGEgcHJvcGVydHkgKGh5cGhlbmF0ZWQgb3IgY2FtZWxDYXNlZCkgYW5kIHVwIHRvIGZvdXIgdmFsdWVzIHRoYXQgbWFwIHRvIHRvcCwgcmlnaHQsIGJvdHRvbSwgYW5kIGxlZnQsIHJlc3BlY3RpdmVseS4gWW91IGNhbiBvcHRpb25hbGx5IHBhc3MgYW4gZW1wdHkgc3RyaW5nIHRvIGdldCBvbmx5IHRoZSBkaXJlY3Rpb25hbCB2YWx1ZXMgYXMgcHJvcGVydGllcy4gWW91IGNhbiBhbHNvIG9wdGlvbmFsbHkgcGFzcyBhIG51bGwgYXJndW1lbnQgZm9yIGEgZGlyZWN0aW9uYWwgdmFsdWUgdG8gaWdub3JlIGl0LlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4uZGlyZWN0aW9uYWxQcm9wZXJ0eSgncGFkZGluZycsICcxMnB4JywgJzI0cHgnLCAnMzZweCcsICc0OHB4JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtkaXJlY3Rpb25hbFByb3BlcnR5KCdwYWRkaW5nJywgJzEycHgnLCAnMjRweCcsICczNnB4JywgJzQ4cHgnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgJ3BhZGRpbmdUb3AnOiAnMTJweCcsXG4gKiAgICdwYWRkaW5nUmlnaHQnOiAnMjRweCcsXG4gKiAgICdwYWRkaW5nQm90dG9tJzogJzM2cHgnLFxuICogICAncGFkZGluZ0xlZnQnOiAnNDhweCdcbiAqIH1cbiAqL1xuZnVuY3Rpb24gZGlyZWN0aW9uYWxQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgdmFsdWVzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICB2YWx1ZXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIC8vICBwcmV0dGllci1pZ25vcmVcbiAgdmFyIGZpcnN0VmFsdWUgPSB2YWx1ZXNbMF0sXG4gICAgX3ZhbHVlcyQgPSB2YWx1ZXNbMV0sXG4gICAgc2Vjb25kVmFsdWUgPSBfdmFsdWVzJCA9PT0gdm9pZCAwID8gZmlyc3RWYWx1ZSA6IF92YWx1ZXMkLFxuICAgIF92YWx1ZXMkMiA9IHZhbHVlc1syXSxcbiAgICB0aGlyZFZhbHVlID0gX3ZhbHVlcyQyID09PSB2b2lkIDAgPyBmaXJzdFZhbHVlIDogX3ZhbHVlcyQyLFxuICAgIF92YWx1ZXMkMyA9IHZhbHVlc1szXSxcbiAgICBmb3VydGhWYWx1ZSA9IF92YWx1ZXMkMyA9PT0gdm9pZCAwID8gc2Vjb25kVmFsdWUgOiBfdmFsdWVzJDM7XG4gIHZhciB2YWx1ZXNXaXRoRGVmYXVsdHMgPSBbZmlyc3RWYWx1ZSwgc2Vjb25kVmFsdWUsIHRoaXJkVmFsdWUsIGZvdXJ0aFZhbHVlXTtcbiAgcmV0dXJuIGdlbmVyYXRlU3R5bGVzKHByb3BlcnR5LCB2YWx1ZXNXaXRoRGVmYXVsdHMpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIGVuZHMgd2l0aCBzb21ldGhpbmdcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVuZHNXaXRoKHN0cmluZywgc3VmZml4KSB7XG4gIHJldHVybiBzdHJpbmcuc3Vic3RyKC1zdWZmaXgubGVuZ3RoKSA9PT0gc3VmZml4O1xufVxuXG52YXIgY3NzUmVnZXgkMSA9IC9eKFsrLV0/KD86XFxkK3xcXGQqXFwuXFxkKykpKFthLXpdKnwlKSQvO1xuXG4vKipcbiAqIFJldHVybnMgYSBnaXZlbiBDU1MgdmFsdWUgbWludXMgaXRzIHVuaXQgb2YgbWVhc3VyZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAnLS1kaW1lbnNpb24nOiBzdHJpcFVuaXQoJzEwMHB4JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgLS1kaW1lbnNpb246ICR7c3RyaXBVbml0KCcxMDBweCcpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgICctLWRpbWVuc2lvbic6IDEwMFxuICogfVxuICovXG5mdW5jdGlvbiBzdHJpcFVuaXQodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHJldHVybiB2YWx1ZTtcbiAgdmFyIG1hdGNoZWRWYWx1ZSA9IHZhbHVlLm1hdGNoKGNzc1JlZ2V4JDEpO1xuICByZXR1cm4gbWF0Y2hlZFZhbHVlID8gcGFyc2VGbG9hdCh2YWx1ZSkgOiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBwaXhlbC10by14IGNvbnZlcnRlcnNcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBweHRvRmFjdG9yeSA9IGZ1bmN0aW9uIHB4dG9GYWN0b3J5KHRvKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocHh2YWwsIGJhc2UpIHtcbiAgICBpZiAoYmFzZSA9PT0gdm9pZCAwKSB7XG4gICAgICBiYXNlID0gJzE2cHgnO1xuICAgIH1cbiAgICB2YXIgbmV3UHh2YWwgPSBweHZhbDtcbiAgICB2YXIgbmV3QmFzZSA9IGJhc2U7XG4gICAgaWYgKHR5cGVvZiBweHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICghZW5kc1dpdGgocHh2YWwsICdweCcpKSB7XG4gICAgICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDY5LCB0bywgcHh2YWwpO1xuICAgICAgfVxuICAgICAgbmV3UHh2YWwgPSBzdHJpcFVuaXQocHh2YWwpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGJhc2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoIWVuZHNXaXRoKGJhc2UsICdweCcpKSB7XG4gICAgICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDcwLCB0bywgYmFzZSk7XG4gICAgICB9XG4gICAgICBuZXdCYXNlID0gc3RyaXBVbml0KGJhc2UpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5ld1B4dmFsID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNzEsIHB4dmFsLCB0byk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmV3QmFzZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDcyLCBiYXNlLCB0byk7XG4gICAgfVxuICAgIHJldHVybiBcIlwiICsgbmV3UHh2YWwgLyBuZXdCYXNlICsgdG87XG4gIH07XG59O1xudmFyIHBpeGVsc3RvID0gcHh0b0ZhY3Rvcnk7XG5cbi8qKlxuICogQ29udmVydCBwaXhlbCB2YWx1ZSB0byBlbXMuIFRoZSBkZWZhdWx0IGJhc2UgdmFsdWUgaXMgMTZweCwgYnV0IGNhbiBiZSBjaGFuZ2VkIGJ5IHBhc3NpbmcgYVxuICogc2Vjb25kIGFyZ3VtZW50IHRvIHRoZSBmdW5jdGlvbi5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBweHZhbFxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbYmFzZT0nMTZweCddXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAnaGVpZ2h0JzogZW0oJzE2cHgnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBoZWlnaHQ6ICR7ZW0oJzE2cHgnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgICdoZWlnaHQnOiAnMWVtJ1xuICogfVxuICovXG52YXIgZW0gPSBwaXhlbHN0bygnZW0nKTtcbnZhciBlbSQxID0gZW07XG5cbnZhciBjc3NSZWdleCA9IC9eKFsrLV0/KD86XFxkK3xcXGQqXFwuXFxkKykpKFthLXpdKnwlKSQvO1xuXG4vKipcbiAqIFJldHVybnMgYSBnaXZlbiBDU1MgdmFsdWUgYW5kIGl0cyB1bml0IGFzIGVsZW1lbnRzIG9mIGFuIGFycmF5LlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgICctLWRpbWVuc2lvbic6IGdldFZhbHVlQW5kVW5pdCgnMTAwcHgnKVswXSxcbiAqICAgJy0tdW5pdCc6IGdldFZhbHVlQW5kVW5pdCgnMTAwcHgnKVsxXSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgLS1kaW1lbnNpb246ICR7Z2V0VmFsdWVBbmRVbml0KCcxMDBweCcpWzBdfTtcbiAqICAgLS11bml0OiAke2dldFZhbHVlQW5kVW5pdCgnMTAwcHgnKVsxXX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICAnLS1kaW1lbnNpb24nOiAxMDAsXG4gKiAgICctLXVuaXQnOiAncHgnLFxuICogfVxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZUFuZFVuaXQodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHJldHVybiBbdmFsdWUsICcnXTtcbiAgdmFyIG1hdGNoZWRWYWx1ZSA9IHZhbHVlLm1hdGNoKGNzc1JlZ2V4KTtcbiAgaWYgKG1hdGNoZWRWYWx1ZSkgcmV0dXJuIFtwYXJzZUZsb2F0KHZhbHVlKSwgbWF0Y2hlZFZhbHVlWzJdXTtcbiAgcmV0dXJuIFt2YWx1ZSwgdW5kZWZpbmVkXTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZm9yIHRhcmdldGluZyBydWxlcyBpbiBhIHN0eWxlIGJsb2NrIGdlbmVyYXRlZCBieSBwb2xpc2hlZCBtb2R1bGVzIHRoYXQgbmVlZCAhaW1wb3J0YW50LWxldmVsIHNwZWNpZmljaXR5LiBDYW4gb3B0aW9uYWxseSBzcGVjaWZ5IGEgcnVsZSAob3IgcnVsZXMpIHRvIHRhcmdldCBzcGVjaWZpYyBydWxlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5pbXBvcnRhbnQoY292ZXIoKSlcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtpbXBvcnRhbnQoY292ZXIoKSl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdjoge1xuICogICAncG9zaXRpb24nOiAnYWJzb2x1dGUgIWltcG9ydGFudCcsXG4gKiAgICd0b3AnOiAnMCAhaW1wb3J0YW50JyxcbiAqICAgJ3JpZ2h0OiAnMCAhaW1wb3J0YW50JyxcbiAqICAgJ2JvdHRvbSc6ICcwICFpbXBvcnRhbnQnLFxuICogICAnbGVmdDogJzAgIWltcG9ydGFudCdcbiAqIH1cbiAqL1xuZnVuY3Rpb24gaW1wb3J0YW50KHN0eWxlQmxvY2ssIHJ1bGVzKSB7XG4gIGlmICh0eXBlb2Ygc3R5bGVCbG9jayAhPT0gJ29iamVjdCcgfHwgc3R5bGVCbG9jayA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDc1LCB0eXBlb2Ygc3R5bGVCbG9jayk7XG4gIH1cbiAgdmFyIG5ld1N0eWxlQmxvY2sgPSB7fTtcbiAgT2JqZWN0LmtleXMoc3R5bGVCbG9jaykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKHR5cGVvZiBzdHlsZUJsb2NrW2tleV0gPT09ICdvYmplY3QnICYmIHN0eWxlQmxvY2tba2V5XSAhPT0gbnVsbCkge1xuICAgICAgbmV3U3R5bGVCbG9ja1trZXldID0gaW1wb3J0YW50KHN0eWxlQmxvY2tba2V5XSwgcnVsZXMpO1xuICAgIH0gZWxzZSBpZiAoIXJ1bGVzIHx8IHJ1bGVzICYmIChydWxlcyA9PT0ga2V5IHx8IHJ1bGVzLmluZGV4T2Yoa2V5KSA+PSAwKSkge1xuICAgICAgbmV3U3R5bGVCbG9ja1trZXldID0gc3R5bGVCbG9ja1trZXldICsgXCIgIWltcG9ydGFudFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdHlsZUJsb2NrW2tleV0gPSBzdHlsZUJsb2NrW2tleV07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5ld1N0eWxlQmxvY2s7XG59XG5cbnZhciByYXRpb05hbWVzID0ge1xuICBtaW5vclNlY29uZDogMS4wNjcsXG4gIG1ham9yU2Vjb25kOiAxLjEyNSxcbiAgbWlub3JUaGlyZDogMS4yLFxuICBtYWpvclRoaXJkOiAxLjI1LFxuICBwZXJmZWN0Rm91cnRoOiAxLjMzMyxcbiAgYXVnRm91cnRoOiAxLjQxNCxcbiAgcGVyZmVjdEZpZnRoOiAxLjUsXG4gIG1pbm9yU2l4dGg6IDEuNixcbiAgZ29sZGVuU2VjdGlvbjogMS42MTgsXG4gIG1ham9yU2l4dGg6IDEuNjY3LFxuICBtaW5vclNldmVudGg6IDEuNzc4LFxuICBtYWpvclNldmVudGg6IDEuODc1LFxuICBvY3RhdmU6IDIsXG4gIG1ham9yVGVudGg6IDIuNSxcbiAgbWFqb3JFbGV2ZW50aDogMi42NjcsXG4gIG1ham9yVHdlbGZ0aDogMyxcbiAgZG91YmxlT2N0YXZlOiA0XG59O1xuZnVuY3Rpb24gZ2V0UmF0aW8ocmF0aW9OYW1lKSB7XG4gIHJldHVybiByYXRpb05hbWVzW3JhdGlvTmFtZV07XG59XG5cbi8qKlxuICogRXN0YWJsaXNoIGNvbnNpc3RlbnQgbWVhc3VyZW1lbnRzIGFuZCBzcGFjaWFsIHJlbGF0aW9uc2hpcHMgdGhyb3VnaG91dCB5b3VyIHByb2plY3RzIGJ5IGluY3JlbWVudGluZyBhbiBlbSBvciByZW0gdmFsdWUgdXAgb3IgZG93biBhIGRlZmluZWQgc2NhbGUuIFdlIHByb3ZpZGUgYSBsaXN0IG9mIGNvbW1vbmx5IHVzZWQgc2NhbGVzIGFzIHByZS1kZWZpbmVkIHZhcmlhYmxlcy5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgICAvLyBJbmNyZW1lbnQgdHdvIHN0ZXBzIHVwIHRoZSBkZWZhdWx0IHNjYWxlXG4gKiAgICdmb250U2l6ZSc6IG1vZHVsYXJTY2FsZSgyKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAgLy8gSW5jcmVtZW50IHR3byBzdGVwcyB1cCB0aGUgZGVmYXVsdCBzY2FsZVxuICogICBmb250U2l6ZTogJHttb2R1bGFyU2NhbGUoMil9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICAnZm9udFNpemUnOiAnMS43NzY4OWVtJ1xuICogfVxuICovXG5mdW5jdGlvbiBtb2R1bGFyU2NhbGUoc3RlcHMsIGJhc2UsIHJhdGlvKSB7XG4gIGlmIChiYXNlID09PSB2b2lkIDApIHtcbiAgICBiYXNlID0gJzFlbSc7XG4gIH1cbiAgaWYgKHJhdGlvID09PSB2b2lkIDApIHtcbiAgICByYXRpbyA9IDEuMzMzO1xuICB9XG4gIGlmICh0eXBlb2Ygc3RlcHMgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNDIpO1xuICB9XG4gIGlmICh0eXBlb2YgcmF0aW8gPT09ICdzdHJpbmcnICYmICFyYXRpb05hbWVzW3JhdGlvXSkge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDQzKTtcbiAgfVxuICB2YXIgX3JlZiA9IHR5cGVvZiBiYXNlID09PSAnc3RyaW5nJyA/IGdldFZhbHVlQW5kVW5pdChiYXNlKSA6IFtiYXNlLCAnJ10sXG4gICAgcmVhbEJhc2UgPSBfcmVmWzBdLFxuICAgIHVuaXQgPSBfcmVmWzFdO1xuICB2YXIgcmVhbFJhdGlvID0gdHlwZW9mIHJhdGlvID09PSAnc3RyaW5nJyA/IGdldFJhdGlvKHJhdGlvKSA6IHJhdGlvO1xuICBpZiAodHlwZW9mIHJlYWxCYXNlID09PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDQ0LCBiYXNlKTtcbiAgfVxuICByZXR1cm4gXCJcIiArIHJlYWxCYXNlICogTWF0aC5wb3cocmVhbFJhdGlvLCBzdGVwcykgKyAodW5pdCB8fCAnJyk7XG59XG5cbi8qKlxuICogQ29udmVydCBwaXhlbCB2YWx1ZSB0byByZW1zLiBUaGUgZGVmYXVsdCBiYXNlIHZhbHVlIGlzIDE2cHgsIGJ1dCBjYW4gYmUgY2hhbmdlZCBieSBwYXNzaW5nIGFcbiAqIHNlY29uZCBhcmd1bWVudCB0byB0aGUgZnVuY3Rpb24uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gcHh2YWxcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW2Jhc2U9JzE2cHgnXVxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgJ2hlaWdodCc6IHJlbSgnMTZweCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGhlaWdodDogJHtyZW0oJzE2cHgnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgICdoZWlnaHQnOiAnMXJlbSdcbiAqIH1cbiAqL1xudmFyIHJlbSA9IHBpeGVsc3RvKCdyZW0nKTtcbnZhciByZW0kMSA9IHJlbTtcblxudmFyIGRlZmF1bHRGb250U2l6ZSA9IDE2O1xuZnVuY3Rpb24gY29udmVydEJhc2UoYmFzZSkge1xuICB2YXIgZGVjb25zdHJ1Y3RlZFZhbHVlID0gZ2V0VmFsdWVBbmRVbml0KGJhc2UpO1xuICBpZiAoZGVjb25zdHJ1Y3RlZFZhbHVlWzFdID09PSAncHgnKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoYmFzZSk7XG4gIH1cbiAgaWYgKGRlY29uc3RydWN0ZWRWYWx1ZVsxXSA9PT0gJyUnKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoYmFzZSkgLyAxMDAgKiBkZWZhdWx0Rm9udFNpemU7XG4gIH1cbiAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNzgsIGRlY29uc3RydWN0ZWRWYWx1ZVsxXSk7XG59XG5mdW5jdGlvbiBnZXRCYXNlRnJvbURvYygpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIHJvb3RGb250U2l6ZSA9IGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5mb250U2l6ZTtcbiAgICByZXR1cm4gcm9vdEZvbnRTaXplID8gY29udmVydEJhc2Uocm9vdEZvbnRTaXplKSA6IGRlZmF1bHRGb250U2l6ZTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBkZWZhdWx0Rm9udFNpemU7XG59XG5cbi8qKlxuICogQ29udmVydCByZW0gdmFsdWVzIHRvIHB4LiBCeSBkZWZhdWx0LCB0aGUgYmFzZSB2YWx1ZSBpcyBwdWxsZWQgZnJvbSB0aGUgZm9udC1zaXplIHByb3BlcnR5IG9uIHRoZSByb290IGVsZW1lbnQgKGlmIGl0IGlzIHNldCBpbiAlIG9yIHB4KS4gSXQgZGVmYXVsdHMgdG8gMTZweCBpZiBub3QgZm91bmQgb24gdGhlIHJvb3QuIFlvdSBjYW4gYWxzbyBvdmVycmlkZSB0aGUgYmFzZSB2YWx1ZSBieSBwcm92aWRpbmcgeW91ciBvd24gYmFzZSBpbiAlIG9yIHB4LlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgJ2hlaWdodCc6IHJlbVRvUHgoJzEuNnJlbScpXG4gKiAgICdoZWlnaHQnOiByZW1Ub1B4KCcxLjZyZW0nLCAnMTBweCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGhlaWdodDogJHtyZW1Ub1B4KCcxLjZyZW0nKX1cbiAqICAgaGVpZ2h0OiAke3JlbVRvUHgoJzEuNnJlbScsICcxMHB4Jyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICAnaGVpZ2h0JzogJzI1LjZweCcsXG4gKiAgICdoZWlnaHQnOiAnMTZweCcsXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHJlbVRvUHgodmFsdWUsIGJhc2UpIHtcbiAgdmFyIGRlY29uc3RydWN0ZWRWYWx1ZSA9IGdldFZhbHVlQW5kVW5pdCh2YWx1ZSk7XG4gIGlmIChkZWNvbnN0cnVjdGVkVmFsdWVbMV0gIT09ICdyZW0nICYmIGRlY29uc3RydWN0ZWRWYWx1ZVsxXSAhPT0gJycpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig3NywgZGVjb25zdHJ1Y3RlZFZhbHVlWzFdKTtcbiAgfVxuICB2YXIgbmV3QmFzZSA9IGJhc2UgPyBjb252ZXJ0QmFzZShiYXNlKSA6IGdldEJhc2VGcm9tRG9jKCk7XG4gIHJldHVybiBkZWNvbnN0cnVjdGVkVmFsdWVbMF0gKiBuZXdCYXNlICsgXCJweFwiO1xufVxuXG52YXIgZnVuY3Rpb25zTWFwJDMgPSB7XG4gIGJhY2s6ICdjdWJpYy1iZXppZXIoMC42MDAsIC0wLjI4MCwgMC43MzUsIDAuMDQ1KScsXG4gIGNpcmM6ICdjdWJpYy1iZXppZXIoMC42MDAsICAwLjA0MCwgMC45ODAsIDAuMzM1KScsXG4gIGN1YmljOiAnY3ViaWMtYmV6aWVyKDAuNTUwLCAgMC4wNTUsIDAuNjc1LCAwLjE5MCknLFxuICBleHBvOiAnY3ViaWMtYmV6aWVyKDAuOTUwLCAgMC4wNTAsIDAuNzk1LCAwLjAzNSknLFxuICBxdWFkOiAnY3ViaWMtYmV6aWVyKDAuNTUwLCAgMC4wODUsIDAuNjgwLCAwLjUzMCknLFxuICBxdWFydDogJ2N1YmljLWJlemllcigwLjg5NSwgIDAuMDMwLCAwLjY4NSwgMC4yMjApJyxcbiAgcXVpbnQ6ICdjdWJpYy1iZXppZXIoMC43NTUsICAwLjA1MCwgMC44NTUsIDAuMDYwKScsXG4gIHNpbmU6ICdjdWJpYy1iZXppZXIoMC40NzAsICAwLjAwMCwgMC43NDUsIDAuNzE1KSdcbn07XG5cbi8qKlxuICogU3RyaW5nIHRvIHJlcHJlc2VudCBjb21tb24gZWFzaW5nIGZ1bmN0aW9ucyBhcyBkZW1vbnN0cmF0ZWQgaGVyZTogKGdpdGh1Yi5jb20vamF1a2lhL2Vhc2llKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAndHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uJzogZWFzZUluKCdxdWFkJylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogJHtlYXNlSW4oJ3F1YWQnKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqICdkaXYnOiB7XG4gKiAgICd0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24nOiAnY3ViaWMtYmV6aWVyKDAuNTUwLCAgMC4wODUsIDAuNjgwLCAwLjUzMCknLFxuICogfVxuICovXG5mdW5jdGlvbiBlYXNlSW4oZnVuY3Rpb25OYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbnNNYXAkM1tmdW5jdGlvbk5hbWUudG9Mb3dlckNhc2UoKS50cmltKCldO1xufVxuXG52YXIgZnVuY3Rpb25zTWFwJDIgPSB7XG4gIGJhY2s6ICdjdWJpYy1iZXppZXIoMC42ODAsIC0wLjU1MCwgMC4yNjUsIDEuNTUwKScsXG4gIGNpcmM6ICdjdWJpYy1iZXppZXIoMC43ODUsICAwLjEzNSwgMC4xNTAsIDAuODYwKScsXG4gIGN1YmljOiAnY3ViaWMtYmV6aWVyKDAuNjQ1LCAgMC4wNDUsIDAuMzU1LCAxLjAwMCknLFxuICBleHBvOiAnY3ViaWMtYmV6aWVyKDEuMDAwLCAgMC4wMDAsIDAuMDAwLCAxLjAwMCknLFxuICBxdWFkOiAnY3ViaWMtYmV6aWVyKDAuNDU1LCAgMC4wMzAsIDAuNTE1LCAwLjk1NSknLFxuICBxdWFydDogJ2N1YmljLWJlemllcigwLjc3MCwgIDAuMDAwLCAwLjE3NSwgMS4wMDApJyxcbiAgcXVpbnQ6ICdjdWJpYy1iZXppZXIoMC44NjAsICAwLjAwMCwgMC4wNzAsIDEuMDAwKScsXG4gIHNpbmU6ICdjdWJpYy1iZXppZXIoMC40NDUsICAwLjA1MCwgMC41NTAsIDAuOTUwKSdcbn07XG5cbi8qKlxuICogU3RyaW5nIHRvIHJlcHJlc2VudCBjb21tb24gZWFzaW5nIGZ1bmN0aW9ucyBhcyBkZW1vbnN0cmF0ZWQgaGVyZTogKGdpdGh1Yi5jb20vamF1a2lhL2Vhc2llKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAndHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uJzogZWFzZUluT3V0KCdxdWFkJylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogJHtlYXNlSW5PdXQoJ3F1YWQnKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqICdkaXYnOiB7XG4gKiAgICd0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24nOiAnY3ViaWMtYmV6aWVyKDAuNDU1LCAgMC4wMzAsIDAuNTE1LCAwLjk1NSknLFxuICogfVxuICovXG5mdW5jdGlvbiBlYXNlSW5PdXQoZnVuY3Rpb25OYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbnNNYXAkMltmdW5jdGlvbk5hbWUudG9Mb3dlckNhc2UoKS50cmltKCldO1xufVxuXG52YXIgZnVuY3Rpb25zTWFwJDEgPSB7XG4gIGJhY2s6ICdjdWJpYy1iZXppZXIoMC4xNzUsICAwLjg4NSwgMC4zMjAsIDEuMjc1KScsXG4gIGN1YmljOiAnY3ViaWMtYmV6aWVyKDAuMjE1LCAgMC42MTAsIDAuMzU1LCAxLjAwMCknLFxuICBjaXJjOiAnY3ViaWMtYmV6aWVyKDAuMDc1LCAgMC44MjAsIDAuMTY1LCAxLjAwMCknLFxuICBleHBvOiAnY3ViaWMtYmV6aWVyKDAuMTkwLCAgMS4wMDAsIDAuMjIwLCAxLjAwMCknLFxuICBxdWFkOiAnY3ViaWMtYmV6aWVyKDAuMjUwLCAgMC40NjAsIDAuNDUwLCAwLjk0MCknLFxuICBxdWFydDogJ2N1YmljLWJlemllcigwLjE2NSwgIDAuODQwLCAwLjQ0MCwgMS4wMDApJyxcbiAgcXVpbnQ6ICdjdWJpYy1iZXppZXIoMC4yMzAsICAxLjAwMCwgMC4zMjAsIDEuMDAwKScsXG4gIHNpbmU6ICdjdWJpYy1iZXppZXIoMC4zOTAsICAwLjU3NSwgMC41NjUsIDEuMDAwKSdcbn07XG5cbi8qKlxuICogU3RyaW5nIHRvIHJlcHJlc2VudCBjb21tb24gZWFzaW5nIGZ1bmN0aW9ucyBhcyBkZW1vbnN0cmF0ZWQgaGVyZTogKGdpdGh1Yi5jb20vamF1a2lhL2Vhc2llKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAndHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uJzogZWFzZU91dCgncXVhZCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqICBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICB0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246ICR7ZWFzZU91dCgncXVhZCcpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogJ2Rpdic6IHtcbiAqICAgJ3RyYW5zaXRpb25UaW1pbmdGdW5jdGlvbic6ICdjdWJpYy1iZXppZXIoMC4yNTAsICAwLjQ2MCwgMC40NTAsIDAuOTQwKScsXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGVhc2VPdXQoZnVuY3Rpb25OYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbnNNYXAkMVtmdW5jdGlvbk5hbWUudG9Mb3dlckNhc2UoKS50cmltKCldO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBDU1MgY2FsYyBmb3JtdWxhIGZvciBsaW5lYXIgaW50ZXJwb2xhdGlvbiBvZiBhIHByb3BlcnR5IGJldHdlZW4gdHdvIHZhbHVlcy4gQWNjZXB0cyBvcHRpb25hbCBtaW5TY3JlZW4gKGRlZmF1bHRzIHRvICczMjBweCcpIGFuZCBtYXhTY3JlZW4gKGRlZmF1bHRzIHRvICcxMjAwcHgnKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBmb250U2l6ZTogYmV0d2VlbignMjBweCcsICcxMDBweCcsICc0MDBweCcsICcxMDAwcHgnKSxcbiAqICAgZm9udFNpemU6IGJldHdlZW4oJzIwcHgnLCAnMTAwcHgnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBmb250U2l6ZTogJHtiZXR3ZWVuKCcyMHB4JywgJzEwMHB4JywgJzQwMHB4JywgJzEwMDBweCcpfTtcbiAqICAgZm9udFNpemU6ICR7YmV0d2VlbignMjBweCcsICcxMDBweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBoMToge1xuICogICAnZm9udFNpemUnOiAnY2FsYygtMzMuMzMzMzMzMzMzMzMzMzRweCArIDEzLjMzMzMzMzMzMzMzMzMzNHZ3KScsXG4gKiAgICdmb250U2l6ZSc6ICdjYWxjKC05LjA5MDkwOTA5MDkwOTA5M3B4ICsgOS4wOTA5MDkwOTA5MDkwOTJ2dyknXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGJldHdlZW4oZnJvbVNpemUsIHRvU2l6ZSwgbWluU2NyZWVuLCBtYXhTY3JlZW4pIHtcbiAgaWYgKG1pblNjcmVlbiA9PT0gdm9pZCAwKSB7XG4gICAgbWluU2NyZWVuID0gJzMyMHB4JztcbiAgfVxuICBpZiAobWF4U2NyZWVuID09PSB2b2lkIDApIHtcbiAgICBtYXhTY3JlZW4gPSAnMTIwMHB4JztcbiAgfVxuICB2YXIgX2dldFZhbHVlQW5kVW5pdCA9IGdldFZhbHVlQW5kVW5pdChmcm9tU2l6ZSksXG4gICAgdW5pdGxlc3NGcm9tU2l6ZSA9IF9nZXRWYWx1ZUFuZFVuaXRbMF0sXG4gICAgZnJvbVNpemVVbml0ID0gX2dldFZhbHVlQW5kVW5pdFsxXTtcbiAgdmFyIF9nZXRWYWx1ZUFuZFVuaXQyID0gZ2V0VmFsdWVBbmRVbml0KHRvU2l6ZSksXG4gICAgdW5pdGxlc3NUb1NpemUgPSBfZ2V0VmFsdWVBbmRVbml0MlswXSxcbiAgICB0b1NpemVVbml0ID0gX2dldFZhbHVlQW5kVW5pdDJbMV07XG4gIHZhciBfZ2V0VmFsdWVBbmRVbml0MyA9IGdldFZhbHVlQW5kVW5pdChtaW5TY3JlZW4pLFxuICAgIHVuaXRsZXNzTWluU2NyZWVuID0gX2dldFZhbHVlQW5kVW5pdDNbMF0sXG4gICAgbWluU2NyZWVuVW5pdCA9IF9nZXRWYWx1ZUFuZFVuaXQzWzFdO1xuICB2YXIgX2dldFZhbHVlQW5kVW5pdDQgPSBnZXRWYWx1ZUFuZFVuaXQobWF4U2NyZWVuKSxcbiAgICB1bml0bGVzc01heFNjcmVlbiA9IF9nZXRWYWx1ZUFuZFVuaXQ0WzBdLFxuICAgIG1heFNjcmVlblVuaXQgPSBfZ2V0VmFsdWVBbmRVbml0NFsxXTtcbiAgaWYgKHR5cGVvZiB1bml0bGVzc01pblNjcmVlbiAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHVuaXRsZXNzTWF4U2NyZWVuICE9PSAnbnVtYmVyJyB8fCAhbWluU2NyZWVuVW5pdCB8fCAhbWF4U2NyZWVuVW5pdCB8fCBtaW5TY3JlZW5Vbml0ICE9PSBtYXhTY3JlZW5Vbml0KSB7XG4gICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNDcpO1xuICB9XG4gIGlmICh0eXBlb2YgdW5pdGxlc3NGcm9tU2l6ZSAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHVuaXRsZXNzVG9TaXplICE9PSAnbnVtYmVyJyB8fCBmcm9tU2l6ZVVuaXQgIT09IHRvU2l6ZVVuaXQpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig0OCk7XG4gIH1cbiAgaWYgKGZyb21TaXplVW5pdCAhPT0gbWluU2NyZWVuVW5pdCB8fCB0b1NpemVVbml0ICE9PSBtYXhTY3JlZW5Vbml0KSB7XG4gICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNzYpO1xuICB9XG4gIHZhciBzbG9wZSA9ICh1bml0bGVzc0Zyb21TaXplIC0gdW5pdGxlc3NUb1NpemUpIC8gKHVuaXRsZXNzTWluU2NyZWVuIC0gdW5pdGxlc3NNYXhTY3JlZW4pO1xuICB2YXIgYmFzZSA9IHVuaXRsZXNzVG9TaXplIC0gc2xvcGUgKiB1bml0bGVzc01heFNjcmVlbjtcbiAgcmV0dXJuIFwiY2FsYyhcIiArIGJhc2UudG9GaXhlZCgyKSArIChmcm9tU2l6ZVVuaXQgfHwgJycpICsgXCIgKyBcIiArICgxMDAgKiBzbG9wZSkudG9GaXhlZCgyKSArIFwidncpXCI7XG59XG5cbi8qKlxuICogQ1NTIHRvIGNvbnRhaW4gYSBmbG9hdCAoY3JlZGl0IHRvIENTU01vam8pLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgICAuLi5jbGVhckZpeCgpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2NsZWFyRml4KCl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqICcmOjphZnRlcic6IHtcbiAqICAgJ2NsZWFyJzogJ2JvdGgnLFxuICogICAnY29udGVudCc6ICdcIlwiJyxcbiAqICAgJ2Rpc3BsYXknOiAndGFibGUnXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGNsZWFyRml4KHBhcmVudCkge1xuICB2YXIgX3JlZjtcbiAgaWYgKHBhcmVudCA9PT0gdm9pZCAwKSB7XG4gICAgcGFyZW50ID0gJyYnO1xuICB9XG4gIHZhciBwc2V1ZG9TZWxlY3RvciA9IHBhcmVudCArIFwiOjphZnRlclwiO1xuICByZXR1cm4gX3JlZiA9IHt9LCBfcmVmW3BzZXVkb1NlbGVjdG9yXSA9IHtcbiAgICBjbGVhcjogJ2JvdGgnLFxuICAgIGNvbnRlbnQ6ICdcIlwiJyxcbiAgICBkaXNwbGF5OiAndGFibGUnXG4gIH0sIF9yZWY7XG59XG5cbi8qKlxuICogQ1NTIHRvIGZ1bGx5IGNvdmVyIGFuIGFyZWEuIENhbiBvcHRpb25hbGx5IGJlIHBhc3NlZCBhbiBvZmZzZXQgdG8gYWN0IGFzIGEgXCJwYWRkaW5nXCIuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4uY292ZXIoKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2NvdmVyKCl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdjoge1xuICogICAncG9zaXRpb24nOiAnYWJzb2x1dGUnLFxuICogICAndG9wJzogJzAnLFxuICogICAncmlnaHQ6ICcwJyxcbiAqICAgJ2JvdHRvbSc6ICcwJyxcbiAqICAgJ2xlZnQ6ICcwJ1xuICogfVxuICovXG5mdW5jdGlvbiBjb3ZlcihvZmZzZXQpIHtcbiAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7XG4gICAgb2Zmc2V0ID0gMDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHRvcDogb2Zmc2V0LFxuICAgIHJpZ2h0OiBvZmZzZXQsXG4gICAgYm90dG9tOiBvZmZzZXQsXG4gICAgbGVmdDogb2Zmc2V0XG4gIH07XG59XG5cbi8qKlxuICogQ1NTIHRvIHJlcHJlc2VudCB0cnVuY2F0ZWQgdGV4dCB3aXRoIGFuIGVsbGlwc2lzLiBZb3UgY2FuIG9wdGlvbmFsbHkgcGFzcyBhIG1heC13aWR0aCBhbmQgbnVtYmVyIG9mIGxpbmVzIGJlZm9yZSB0cnVuY2F0aW5nLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLmVsbGlwc2lzKCcyNTBweCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7ZWxsaXBzaXMoJzI1MHB4Jyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdjoge1xuICogICAnZGlzcGxheSc6ICdpbmxpbmUtYmxvY2snLFxuICogICAnbWF4V2lkdGgnOiAnMjUwcHgnLFxuICogICAnb3ZlcmZsb3cnOiAnaGlkZGVuJyxcbiAqICAgJ3RleHRPdmVyZmxvdyc6ICdlbGxpcHNpcycsXG4gKiAgICd3aGl0ZVNwYWNlJzogJ25vd3JhcCcsXG4gKiAgICd3b3JkV3JhcCc6ICdub3JtYWwnXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGVsbGlwc2lzKHdpZHRoLCBsaW5lcykge1xuICBpZiAobGluZXMgPT09IHZvaWQgMCkge1xuICAgIGxpbmVzID0gMTtcbiAgfVxuICB2YXIgc3R5bGVzID0ge1xuICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgIG1heFdpZHRoOiB3aWR0aCB8fCAnMTAwJScsXG4gICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgIHRleHRPdmVyZmxvdzogJ2VsbGlwc2lzJyxcbiAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgICB3b3JkV3JhcDogJ25vcm1hbCdcbiAgfTtcbiAgcmV0dXJuIGxpbmVzID4gMSA/IF9leHRlbmRzKHt9LCBzdHlsZXMsIHtcbiAgICBXZWJraXRCb3hPcmllbnQ6ICd2ZXJ0aWNhbCcsXG4gICAgV2Via2l0TGluZUNsYW1wOiBsaW5lcyxcbiAgICBkaXNwbGF5OiAnLXdlYmtpdC1ib3gnLFxuICAgIHdoaXRlU3BhY2U6ICdub3JtYWwnXG4gIH0pIDogc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoaXQpIHJldHVybiAoaXQgPSBpdC5jYWxsKG8pKS5uZXh0LmJpbmQoaXQpOyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHJldHVybiBmdW5jdGlvbiAoKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG4vKipcbiAqIFJldHVybnMgYSBzZXQgb2YgbWVkaWEgcXVlcmllcyB0aGF0IHJlc2l6ZXMgYSBwcm9wZXJ0eSAob3Igc2V0IG9mIHByb3BlcnRpZXMpIGJldHdlZW4gYSBwcm92aWRlZCBmcm9tU2l6ZSBhbmQgdG9TaXplLiBBY2NlcHRzIG9wdGlvbmFsIG1pblNjcmVlbiAoZGVmYXVsdHMgdG8gJzMyMHB4JykgYW5kIG1heFNjcmVlbiAoZGVmYXVsdHMgdG8gJzEyMDBweCcpIHRvIGNvbnN0cmFpbiB0aGUgaW50ZXJwb2xhdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5mbHVpZFJhbmdlKFxuICogICAge1xuICogICAgICAgIHByb3A6ICdwYWRkaW5nJyxcbiAqICAgICAgICBmcm9tU2l6ZTogJzIwcHgnLFxuICogICAgICAgIHRvU2l6ZTogJzEwMHB4JyxcbiAqICAgICAgfSxcbiAqICAgICAgJzQwMHB4JyxcbiAqICAgICAgJzEwMDBweCcsXG4gKiAgICApXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7Zmx1aWRSYW5nZShcbiAqICAgICAge1xuICogICAgICAgIHByb3A6ICdwYWRkaW5nJyxcbiAqICAgICAgICBmcm9tU2l6ZTogJzIwcHgnLFxuICogICAgICAgIHRvU2l6ZTogJzEwMHB4JyxcbiAqICAgICAgfSxcbiAqICAgICAgJzQwMHB4JyxcbiAqICAgICAgJzEwMDBweCcsXG4gKiAgICApfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXY6IHtcbiAqICAgXCJAbWVkaWEgKG1pbi13aWR0aDogMTAwMHB4KVwiOiBPYmplY3Qge1xuICogICAgIFwicGFkZGluZ1wiOiBcIjEwMHB4XCIsXG4gKiAgIH0sXG4gKiAgIFwiQG1lZGlhIChtaW4td2lkdGg6IDQwMHB4KVwiOiBPYmplY3Qge1xuICogICAgIFwicGFkZGluZ1wiOiBcImNhbGMoLTMzLjMzMzMzMzMzMzMzMzM0cHggKyAxMy4zMzMzMzMzMzMzMzMzMzR2dylcIixcbiAqICAgfSxcbiAqICAgXCJwYWRkaW5nXCI6IFwiMjBweFwiLFxuICogfVxuICovXG5mdW5jdGlvbiBmbHVpZFJhbmdlKGNzc1Byb3AsIG1pblNjcmVlbiwgbWF4U2NyZWVuKSB7XG4gIGlmIChtaW5TY3JlZW4gPT09IHZvaWQgMCkge1xuICAgIG1pblNjcmVlbiA9ICczMjBweCc7XG4gIH1cbiAgaWYgKG1heFNjcmVlbiA9PT0gdm9pZCAwKSB7XG4gICAgbWF4U2NyZWVuID0gJzEyMDBweCc7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KGNzc1Byb3ApICYmIHR5cGVvZiBjc3NQcm9wICE9PSAnb2JqZWN0JyB8fCBjc3NQcm9wID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNDkpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGNzc1Byb3ApKSB7XG4gICAgdmFyIG1lZGlhUXVlcmllcyA9IHt9O1xuICAgIHZhciBmYWxsYmFja3MgPSB7fTtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKGNzc1Byb3ApLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgdmFyIF9leHRlbmRzMiwgX2V4dGVuZHMzO1xuICAgICAgdmFyIG9iaiA9IF9zdGVwLnZhbHVlO1xuICAgICAgaWYgKCFvYmoucHJvcCB8fCAhb2JqLmZyb21TaXplIHx8ICFvYmoudG9TaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDUwKTtcbiAgICAgIH1cbiAgICAgIGZhbGxiYWNrc1tvYmoucHJvcF0gPSBvYmouZnJvbVNpemU7XG4gICAgICBtZWRpYVF1ZXJpZXNbXCJAbWVkaWEgKG1pbi13aWR0aDogXCIgKyBtaW5TY3JlZW4gKyBcIilcIl0gPSBfZXh0ZW5kcyh7fSwgbWVkaWFRdWVyaWVzW1wiQG1lZGlhIChtaW4td2lkdGg6IFwiICsgbWluU2NyZWVuICsgXCIpXCJdLCAoX2V4dGVuZHMyID0ge30sIF9leHRlbmRzMltvYmoucHJvcF0gPSBiZXR3ZWVuKG9iai5mcm9tU2l6ZSwgb2JqLnRvU2l6ZSwgbWluU2NyZWVuLCBtYXhTY3JlZW4pLCBfZXh0ZW5kczIpKTtcbiAgICAgIG1lZGlhUXVlcmllc1tcIkBtZWRpYSAobWluLXdpZHRoOiBcIiArIG1heFNjcmVlbiArIFwiKVwiXSA9IF9leHRlbmRzKHt9LCBtZWRpYVF1ZXJpZXNbXCJAbWVkaWEgKG1pbi13aWR0aDogXCIgKyBtYXhTY3JlZW4gKyBcIilcIl0sIChfZXh0ZW5kczMgPSB7fSwgX2V4dGVuZHMzW29iai5wcm9wXSA9IG9iai50b1NpemUsIF9leHRlbmRzMykpO1xuICAgIH1cbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGZhbGxiYWNrcywgbWVkaWFRdWVyaWVzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX3JlZiwgX3JlZjIsIF9yZWYzO1xuICAgIGlmICghY3NzUHJvcC5wcm9wIHx8ICFjc3NQcm9wLmZyb21TaXplIHx8ICFjc3NQcm9wLnRvU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNTEpO1xuICAgIH1cbiAgICByZXR1cm4gX3JlZjMgPSB7fSwgX3JlZjNbY3NzUHJvcC5wcm9wXSA9IGNzc1Byb3AuZnJvbVNpemUsIF9yZWYzW1wiQG1lZGlhIChtaW4td2lkdGg6IFwiICsgbWluU2NyZWVuICsgXCIpXCJdID0gKF9yZWYgPSB7fSwgX3JlZltjc3NQcm9wLnByb3BdID0gYmV0d2Vlbihjc3NQcm9wLmZyb21TaXplLCBjc3NQcm9wLnRvU2l6ZSwgbWluU2NyZWVuLCBtYXhTY3JlZW4pLCBfcmVmKSwgX3JlZjNbXCJAbWVkaWEgKG1pbi13aWR0aDogXCIgKyBtYXhTY3JlZW4gKyBcIilcIl0gPSAoX3JlZjIgPSB7fSwgX3JlZjJbY3NzUHJvcC5wcm9wXSA9IGNzc1Byb3AudG9TaXplLCBfcmVmMiksIF9yZWYzO1xuICB9XG59XG5cbnZhciBkYXRhVVJJUmVnZXggPSAvXlxccypkYXRhOihbYS16XStcXC9bYS16LV0rKDtbYS16LV0rPVthLXotXSspPyk/KDtjaGFyc2V0PVthLXowLTktXSspPyg7YmFzZTY0KT8sW2EtejAtOSEkJicsKCkqKyw7PVxcLS5ffjpALz8lXFxzXSpcXHMqJC9pO1xudmFyIGZvcm1hdEhpbnRNYXAgPSB7XG4gIHdvZmY6ICd3b2ZmJyxcbiAgd29mZjI6ICd3b2ZmMicsXG4gIHR0ZjogJ3RydWV0eXBlJyxcbiAgb3RmOiAnb3BlbnR5cGUnLFxuICBlb3Q6ICdlbWJlZGRlZC1vcGVudHlwZScsXG4gIHN2ZzogJ3N2ZycsXG4gIHN2Z3o6ICdzdmcnXG59O1xuZnVuY3Rpb24gZ2VuZXJhdGVGb3JtYXRIaW50KGZvcm1hdCwgZm9ybWF0SGludCkge1xuICBpZiAoIWZvcm1hdEhpbnQpIHJldHVybiAnJztcbiAgcmV0dXJuIFwiIGZvcm1hdChcXFwiXCIgKyBmb3JtYXRIaW50TWFwW2Zvcm1hdF0gKyBcIlxcXCIpXCI7XG59XG5mdW5jdGlvbiBpc0RhdGFVUkkoZm9udEZpbGVQYXRoKSB7XG4gIHJldHVybiAhIWZvbnRGaWxlUGF0aC5yZXBsYWNlKC9cXHMrL2csICcgJykubWF0Y2goZGF0YVVSSVJlZ2V4KTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlRmlsZVJlZmVyZW5jZXMoZm9udEZpbGVQYXRoLCBmaWxlRm9ybWF0cywgZm9ybWF0SGludCkge1xuICBpZiAoaXNEYXRhVVJJKGZvbnRGaWxlUGF0aCkpIHtcbiAgICByZXR1cm4gXCJ1cmwoXFxcIlwiICsgZm9udEZpbGVQYXRoICsgXCJcXFwiKVwiICsgZ2VuZXJhdGVGb3JtYXRIaW50KGZpbGVGb3JtYXRzWzBdLCBmb3JtYXRIaW50KTtcbiAgfVxuICB2YXIgZmlsZUZvbnRSZWZlcmVuY2VzID0gZmlsZUZvcm1hdHMubWFwKGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICByZXR1cm4gXCJ1cmwoXFxcIlwiICsgZm9udEZpbGVQYXRoICsgXCIuXCIgKyBmb3JtYXQgKyBcIlxcXCIpXCIgKyBnZW5lcmF0ZUZvcm1hdEhpbnQoZm9ybWF0LCBmb3JtYXRIaW50KTtcbiAgfSk7XG4gIHJldHVybiBmaWxlRm9udFJlZmVyZW5jZXMuam9pbignLCAnKTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlTG9jYWxSZWZlcmVuY2VzKGxvY2FsRm9udHMpIHtcbiAgdmFyIGxvY2FsRm9udFJlZmVyZW5jZXMgPSBsb2NhbEZvbnRzLm1hcChmdW5jdGlvbiAoZm9udCkge1xuICAgIHJldHVybiBcImxvY2FsKFxcXCJcIiArIGZvbnQgKyBcIlxcXCIpXCI7XG4gIH0pO1xuICByZXR1cm4gbG9jYWxGb250UmVmZXJlbmNlcy5qb2luKCcsICcpO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVTb3VyY2VzKGZvbnRGaWxlUGF0aCwgbG9jYWxGb250cywgZmlsZUZvcm1hdHMsIGZvcm1hdEhpbnQpIHtcbiAgdmFyIGZvbnRSZWZlcmVuY2VzID0gW107XG4gIGlmIChsb2NhbEZvbnRzKSBmb250UmVmZXJlbmNlcy5wdXNoKGdlbmVyYXRlTG9jYWxSZWZlcmVuY2VzKGxvY2FsRm9udHMpKTtcbiAgaWYgKGZvbnRGaWxlUGF0aCkge1xuICAgIGZvbnRSZWZlcmVuY2VzLnB1c2goZ2VuZXJhdGVGaWxlUmVmZXJlbmNlcyhmb250RmlsZVBhdGgsIGZpbGVGb3JtYXRzLCBmb3JtYXRIaW50KSk7XG4gIH1cbiAgcmV0dXJuIGZvbnRSZWZlcmVuY2VzLmpvaW4oJywgJyk7XG59XG5cbi8qKlxuICogQ1NTIGZvciBhIEBmb250LWZhY2UgZGVjbGFyYXRpb24uIERlZmF1bHRzIHRvIGNoZWNrIGZvciBsb2NhbCBjb3BpZXMgb2YgdGhlIGZvbnQgb24gdGhlIHVzZXIncyBtYWNoaW5lLiBZb3UgY2FuIGRpc2FibGUgdGhpcyBieSBwYXNzaW5nIGBudWxsYCB0byBsb2NhbEZvbnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IGJhc2ljIHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgICAuLi5mb250RmFjZSh7XG4gKiAgICAgICdmb250RmFtaWx5JzogJ1NhbnMtUHJvJyxcbiAqICAgICAgJ2ZvbnRGaWxlUGF0aCc6ICdwYXRoL3RvL2ZpbGUnXG4gKiAgICB9KVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIGJhc2ljIHVzYWdlXG4gKiBjb25zdCBHbG9iYWxTdHlsZSA9IGNyZWF0ZUdsb2JhbFN0eWxlYCR7XG4gKiAgIGZvbnRGYWNlKHtcbiAqICAgICAnZm9udEZhbWlseSc6ICdTYW5zLVBybycsXG4gKiAgICAgJ2ZvbnRGaWxlUGF0aCc6ICdwYXRoL3RvL2ZpbGUnXG4gKiAgIH1cbiAqICl9YFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiAnQGZvbnQtZmFjZSc6IHtcbiAqICAgJ2ZvbnRGYW1pbHknOiAnU2Fucy1Qcm8nLFxuICogICAnc3JjJzogJ3VybChcInBhdGgvdG8vZmlsZS5lb3RcIiksIHVybChcInBhdGgvdG8vZmlsZS53b2ZmMlwiKSwgdXJsKFwicGF0aC90by9maWxlLndvZmZcIiksIHVybChcInBhdGgvdG8vZmlsZS50dGZcIiksIHVybChcInBhdGgvdG8vZmlsZS5zdmdcIiknLFxuICogfVxuICovXG5cbmZ1bmN0aW9uIGZvbnRGYWNlKF9yZWYpIHtcbiAgdmFyIGZvbnRGYW1pbHkgPSBfcmVmLmZvbnRGYW1pbHksXG4gICAgZm9udEZpbGVQYXRoID0gX3JlZi5mb250RmlsZVBhdGgsXG4gICAgZm9udFN0cmV0Y2ggPSBfcmVmLmZvbnRTdHJldGNoLFxuICAgIGZvbnRTdHlsZSA9IF9yZWYuZm9udFN0eWxlLFxuICAgIGZvbnRWYXJpYW50ID0gX3JlZi5mb250VmFyaWFudCxcbiAgICBmb250V2VpZ2h0ID0gX3JlZi5mb250V2VpZ2h0LFxuICAgIF9yZWYkZmlsZUZvcm1hdHMgPSBfcmVmLmZpbGVGb3JtYXRzLFxuICAgIGZpbGVGb3JtYXRzID0gX3JlZiRmaWxlRm9ybWF0cyA9PT0gdm9pZCAwID8gWydlb3QnLCAnd29mZjInLCAnd29mZicsICd0dGYnLCAnc3ZnJ10gOiBfcmVmJGZpbGVGb3JtYXRzLFxuICAgIF9yZWYkZm9ybWF0SGludCA9IF9yZWYuZm9ybWF0SGludCxcbiAgICBmb3JtYXRIaW50ID0gX3JlZiRmb3JtYXRIaW50ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkZm9ybWF0SGludCxcbiAgICBfcmVmJGxvY2FsRm9udHMgPSBfcmVmLmxvY2FsRm9udHMsXG4gICAgbG9jYWxGb250cyA9IF9yZWYkbG9jYWxGb250cyA9PT0gdm9pZCAwID8gW2ZvbnRGYW1pbHldIDogX3JlZiRsb2NhbEZvbnRzLFxuICAgIHVuaWNvZGVSYW5nZSA9IF9yZWYudW5pY29kZVJhbmdlLFxuICAgIGZvbnREaXNwbGF5ID0gX3JlZi5mb250RGlzcGxheSxcbiAgICBmb250VmFyaWF0aW9uU2V0dGluZ3MgPSBfcmVmLmZvbnRWYXJpYXRpb25TZXR0aW5ncyxcbiAgICBmb250RmVhdHVyZVNldHRpbmdzID0gX3JlZi5mb250RmVhdHVyZVNldHRpbmdzO1xuICAvLyBFcnJvciBIYW5kbGluZ1xuICBpZiAoIWZvbnRGYW1pbHkpIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDU1KTtcbiAgaWYgKCFmb250RmlsZVBhdGggJiYgIWxvY2FsRm9udHMpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig1Mik7XG4gIH1cbiAgaWYgKGxvY2FsRm9udHMgJiYgIUFycmF5LmlzQXJyYXkobG9jYWxGb250cykpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig1Myk7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KGZpbGVGb3JtYXRzKSkge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDU0KTtcbiAgfVxuICB2YXIgZm9udEZhY2VEZWNsYXJhdGlvbiA9IHtcbiAgICAnQGZvbnQtZmFjZSc6IHtcbiAgICAgIGZvbnRGYW1pbHk6IGZvbnRGYW1pbHksXG4gICAgICBzcmM6IGdlbmVyYXRlU291cmNlcyhmb250RmlsZVBhdGgsIGxvY2FsRm9udHMsIGZpbGVGb3JtYXRzLCBmb3JtYXRIaW50KSxcbiAgICAgIHVuaWNvZGVSYW5nZTogdW5pY29kZVJhbmdlLFxuICAgICAgZm9udFN0cmV0Y2g6IGZvbnRTdHJldGNoLFxuICAgICAgZm9udFN0eWxlOiBmb250U3R5bGUsXG4gICAgICBmb250VmFyaWFudDogZm9udFZhcmlhbnQsXG4gICAgICBmb250V2VpZ2h0OiBmb250V2VpZ2h0LFxuICAgICAgZm9udERpc3BsYXk6IGZvbnREaXNwbGF5LFxuICAgICAgZm9udFZhcmlhdGlvblNldHRpbmdzOiBmb250VmFyaWF0aW9uU2V0dGluZ3MsXG4gICAgICBmb250RmVhdHVyZVNldHRpbmdzOiBmb250RmVhdHVyZVNldHRpbmdzXG4gICAgfVxuICB9O1xuXG4gIC8vIFJlbW92ZXMgdW5kZWZpbmVkIGZpZWxkcyBmb3IgY2xlYW5lciBjc3Mgb2JqZWN0LlxuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShmb250RmFjZURlY2xhcmF0aW9uKSk7XG59XG5cbi8qKlxuICogQ1NTIHRvIGhpZGUgdGV4dCB0byBzaG93IGEgYmFja2dyb3VuZCBpbWFnZSBpbiBhIFNFTy1mcmllbmRseSB3YXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgJ2JhY2tncm91bmRJbWFnZSc6ICd1cmwobG9nby5wbmcpJyxcbiAqICAgLi4uaGlkZVRleHQoKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZEltYWdlOiB1cmwobG9nby5wbmcpO1xuICogICAke2hpZGVUZXh0KCl9O1xuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiAnZGl2Jzoge1xuICogICAnYmFja2dyb3VuZEltYWdlJzogJ3VybChsb2dvLnBuZyknLFxuICogICAndGV4dEluZGVudCc6ICcxMDElJyxcbiAqICAgJ292ZXJmbG93JzogJ2hpZGRlbicsXG4gKiAgICd3aGl0ZVNwYWNlJzogJ25vd3JhcCcsXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGhpZGVUZXh0KCkge1xuICByZXR1cm4ge1xuICAgIHRleHRJbmRlbnQ6ICcxMDElJyxcbiAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgd2hpdGVTcGFjZTogJ25vd3JhcCdcbiAgfTtcbn1cblxuLyoqXG4gKiBDU1MgdG8gaGlkZSBjb250ZW50IHZpc3VhbGx5IGJ1dCByZW1haW4gYWNjZXNzaWJsZSB0byBzY3JlZW4gcmVhZGVycy5cbiAqIGZyb20gW0hUTUw1IEJvaWxlcnBsYXRlXShodHRwczovL2dpdGh1Yi5jb20vaDVicC9odG1sNS1ib2lsZXJwbGF0ZS9ibG9iLzlhMTc2ZjU3YWYxY2ZlOGVjNzAzMDBkYTQ2MjFmYjliMDdlNWZhMzEvc3JjL2Nzcy9tYWluLmNzcyNMMTIxKVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLmhpZGVWaXN1YWxseSgpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2hpZGVWaXN1YWxseSgpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogJ2Rpdic6IHtcbiAqICAgJ2JvcmRlcic6ICcwJyxcbiAqICAgJ2NsaXAnOiAncmVjdCgwIDAgMCAwKScsXG4gKiAgICdoZWlnaHQnOiAnMXB4JyxcbiAqICAgJ21hcmdpbic6ICctMXB4JyxcbiAqICAgJ292ZXJmbG93JzogJ2hpZGRlbicsXG4gKiAgICdwYWRkaW5nJzogJzAnLFxuICogICAncG9zaXRpb24nOiAnYWJzb2x1dGUnLFxuICogICAnd2hpdGVTcGFjZSc6ICdub3dyYXAnLFxuICogICAnd2lkdGgnOiAnMXB4JyxcbiAqIH1cbiAqL1xuZnVuY3Rpb24gaGlkZVZpc3VhbGx5KCkge1xuICByZXR1cm4ge1xuICAgIGJvcmRlcjogJzAnLFxuICAgIGNsaXA6ICdyZWN0KDAgMCAwIDApJyxcbiAgICBoZWlnaHQ6ICcxcHgnLFxuICAgIG1hcmdpbjogJy0xcHgnLFxuICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICBwYWRkaW5nOiAnMCcsXG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgd2hpdGVTcGFjZTogJ25vd3JhcCcsXG4gICAgd2lkdGg6ICcxcHgnXG4gIH07XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbWVkaWEgcXVlcnkgdG8gdGFyZ2V0IEhpRFBJIGRldmljZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICBbaGlEUEkoMS41KV06IHtcbiAqICAgIHdpZHRoOiAyMDBweDtcbiAqICB9XG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7aGlEUEkoMS41KX0ge1xuICogICAgIHdpZHRoOiAyMDBweDtcbiAqICAgfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiAnQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAxLjUpLFxuICogIG9ubHkgc2NyZWVuIGFuZCAobWluLS1tb3otZGV2aWNlLXBpeGVsLXJhdGlvOiAxLjUpLFxuICogIG9ubHkgc2NyZWVuIGFuZCAoLW8tbWluLWRldmljZS1waXhlbC1yYXRpbzogMS41LzEpLFxuICogIG9ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDE0NGRwaSksXG4gKiAgb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMS41ZHBweCknOiB7XG4gKiAgICd3aWR0aCc6ICcyMDBweCcsXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGhpRFBJKHJhdGlvKSB7XG4gIGlmIChyYXRpbyA9PT0gdm9pZCAwKSB7XG4gICAgcmF0aW8gPSAxLjM7XG4gIH1cbiAgcmV0dXJuIFwiXFxuICAgIEBtZWRpYSBvbmx5IHNjcmVlbiBhbmQgKC13ZWJraXQtbWluLWRldmljZS1waXhlbC1yYXRpbzogXCIgKyByYXRpbyArIFwiKSxcXG4gICAgb25seSBzY3JlZW4gYW5kIChtaW4tLW1vei1kZXZpY2UtcGl4ZWwtcmF0aW86IFwiICsgcmF0aW8gKyBcIiksXFxuICAgIG9ubHkgc2NyZWVuIGFuZCAoLW8tbWluLWRldmljZS1waXhlbC1yYXRpbzogXCIgKyByYXRpbyArIFwiLzEpLFxcbiAgICBvbmx5IHNjcmVlbiBhbmQgKG1pbi1yZXNvbHV0aW9uOiBcIiArIE1hdGgucm91bmQocmF0aW8gKiA5NikgKyBcImRwaSksXFxuICAgIG9ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IFwiICsgcmF0aW8gKyBcImRwcHgpXFxuICBcIjtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0R3JhZGllbnRWYWx1ZShsaXRlcmFscykge1xuICB2YXIgdGVtcGxhdGUgPSAnJztcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHN1YnN0aXR1dGlvbnMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHN1YnN0aXR1dGlvbnNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGl0ZXJhbHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0ZW1wbGF0ZSArPSBsaXRlcmFsc1tpXTtcbiAgICBpZiAoaSA9PT0gc3Vic3RpdHV0aW9ucy5sZW5ndGggLSAxICYmIHN1YnN0aXR1dGlvbnNbaV0pIHtcbiAgICAgIHZhciBkZWZpbmVkVmFsdWVzID0gc3Vic3RpdHV0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKHN1YnN0aXR1dGUpIHtcbiAgICAgICAgcmV0dXJuICEhc3Vic3RpdHV0ZTtcbiAgICAgIH0pO1xuICAgICAgLy8gQWRkcyBsZWFkaW5nIGNvbWEgaWYgcHJvcGVydGllcyBwcmVjZWVkIGNvbG9yLXN0b3BzXG4gICAgICBpZiAoZGVmaW5lZFZhbHVlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuc2xpY2UoMCwgLTEpO1xuICAgICAgICB0ZW1wbGF0ZSArPSBcIiwgXCIgKyBzdWJzdGl0dXRpb25zW2ldO1xuICAgICAgICAvLyBObyB0cmFpbGluZyBzcGFjZSBpZiBjb2xvci1zdG9wcyBpcyB0aGUgb25seSBwYXJhbSBwcm92aWRlZFxuICAgICAgfSBlbHNlIGlmIChkZWZpbmVkVmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0ZW1wbGF0ZSArPSBcIlwiICsgc3Vic3RpdHV0aW9uc1tpXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN1YnN0aXR1dGlvbnNbaV0pIHtcbiAgICAgIHRlbXBsYXRlICs9IHN1YnN0aXR1dGlvbnNbaV0gKyBcIiBcIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRlbXBsYXRlLnRyaW0oKTtcbn1cblxudmFyIF90ZW1wbGF0ZU9iamVjdCQxO1xuLyoqXG4gKiBDU1MgZm9yIGRlY2xhcmluZyBhIGxpbmVhciBncmFkaWVudCwgaW5jbHVkaW5nIGEgZmFsbGJhY2sgYmFja2dyb3VuZC1jb2xvci4gVGhlIGZhbGxiYWNrIGlzIGVpdGhlciB0aGUgZmlyc3QgY29sb3Itc3RvcCBvciBhbiBleHBsaWNpdGx5IHBhc3NlZCBmYWxsYmFjayBjb2xvci5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5saW5lYXJHcmFkaWVudCh7XG4gICAgICAgIGNvbG9yU3RvcHM6IFsnIzAwRkZGRiAwJScsICdyZ2JhKDAsIDAsIDI1NSwgMCkgNTAlJywgJyMwMDAwRkYgOTUlJ10sXG4gICAgICAgIHRvRGlyZWN0aW9uOiAndG8gdG9wIHJpZ2h0JyxcbiAgICAgICAgZmFsbGJhY2s6ICcjRkZGJyxcbiAgICAgIH0pXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7bGluZWFyR3JhZGllbnQoe1xuICAgICAgICBjb2xvclN0b3BzOiBbJyMwMEZGRkYgMCUnLCAncmdiYSgwLCAwLCAyNTUsIDApIDUwJScsICcjMDAwMEZGIDk1JSddLFxuICAgICAgICB0b0RpcmVjdGlvbjogJ3RvIHRvcCByaWdodCcsXG4gICAgICAgIGZhbGxiYWNrOiAnI0ZGRicsXG4gICAgICB9KX1cbiAqYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXY6IHtcbiAqICAgJ2JhY2tncm91bmRDb2xvcic6ICcjRkZGJyxcbiAqICAgJ2JhY2tncm91bmRJbWFnZSc6ICdsaW5lYXItZ3JhZGllbnQodG8gdG9wIHJpZ2h0LCAjMDBGRkZGIDAlLCByZ2JhKDAsIDAsIDI1NSwgMCkgNTAlLCAjMDAwMEZGIDk1JSknLFxuICogfVxuICovXG5mdW5jdGlvbiBsaW5lYXJHcmFkaWVudChfcmVmKSB7XG4gIHZhciBjb2xvclN0b3BzID0gX3JlZi5jb2xvclN0b3BzLFxuICAgIGZhbGxiYWNrID0gX3JlZi5mYWxsYmFjayxcbiAgICBfcmVmJHRvRGlyZWN0aW9uID0gX3JlZi50b0RpcmVjdGlvbixcbiAgICB0b0RpcmVjdGlvbiA9IF9yZWYkdG9EaXJlY3Rpb24gPT09IHZvaWQgMCA/ICcnIDogX3JlZiR0b0RpcmVjdGlvbjtcbiAgaWYgKCFjb2xvclN0b3BzIHx8IGNvbG9yU3RvcHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDU2KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGJhY2tncm91bmRDb2xvcjogZmFsbGJhY2sgfHwgY29sb3JTdG9wc1swXS5yZXBsYWNlKC8sXFxzKy9nLCAnLCcpLnNwbGl0KCcgJylbMF0ucmVwbGFjZSgvLCg/PVxcUykvZywgJywgJyksXG4gICAgYmFja2dyb3VuZEltYWdlOiBjb25zdHJ1Y3RHcmFkaWVudFZhbHVlKF90ZW1wbGF0ZU9iamVjdCQxIHx8IChfdGVtcGxhdGVPYmplY3QkMSA9IF90YWdnZWRUZW1wbGF0ZUxpdGVyYWxMb29zZShbXCJsaW5lYXItZ3JhZGllbnQoXCIsIFwiXCIsIFwiKVwiXSkpLCB0b0RpcmVjdGlvbiwgY29sb3JTdG9wcy5qb2luKCcsICcpLnJlcGxhY2UoLywoPz1cXFMpL2csICcsICcpKVxuICB9O1xufVxuXG4vKipcbiAqIENTUyB0byBub3JtYWxpemUgYWJub3JtYWxpdGllcyBhY3Jvc3MgYnJvd3NlcnMgKG5vcm1hbGl6ZS5jc3MgdjguMC4xIHwgTUlUIExpY2Vuc2UgfCBnaXRodWIuY29tL25lY29sYXMvbm9ybWFsaXplLmNzcylcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAgLi4ubm9ybWFsaXplKCksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IEdsb2JhbFN0eWxlID0gY3JlYXRlR2xvYmFsU3R5bGVgJHtub3JtYWxpemUoKX1gXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGh0bWwge1xuICogICBsaW5lSGVpZ2h0OiAxLjE1LFxuICogICB0ZXh0U2l6ZUFkanVzdDogMTAwJSxcbiAqIH0gLi4uXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZSgpIHtcbiAgdmFyIF9yZWY7XG4gIHJldHVybiBbKF9yZWYgPSB7XG4gICAgaHRtbDoge1xuICAgICAgbGluZUhlaWdodDogJzEuMTUnLFxuICAgICAgdGV4dFNpemVBZGp1c3Q6ICcxMDAlJ1xuICAgIH0sXG4gICAgYm9keToge1xuICAgICAgbWFyZ2luOiAnMCdcbiAgICB9LFxuICAgIG1haW46IHtcbiAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICB9LFxuICAgIGgxOiB7XG4gICAgICBmb250U2l6ZTogJzJlbScsXG4gICAgICBtYXJnaW46ICcwLjY3ZW0gMCdcbiAgICB9LFxuICAgIGhyOiB7XG4gICAgICBib3hTaXppbmc6ICdjb250ZW50LWJveCcsXG4gICAgICBoZWlnaHQ6ICcwJyxcbiAgICAgIG92ZXJmbG93OiAndmlzaWJsZSdcbiAgICB9LFxuICAgIHByZToge1xuICAgICAgZm9udEZhbWlseTogJ21vbm9zcGFjZSwgbW9ub3NwYWNlJyxcbiAgICAgIGZvbnRTaXplOiAnMWVtJ1xuICAgIH0sXG4gICAgYToge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnXG4gICAgfSxcbiAgICAnYWJiclt0aXRsZV0nOiB7XG4gICAgICBib3JkZXJCb3R0b206ICdub25lJyxcbiAgICAgIHRleHREZWNvcmF0aW9uOiAndW5kZXJsaW5lJ1xuICAgIH1cbiAgfSwgX3JlZltcImIsXFxuICAgIHN0cm9uZ1wiXSA9IHtcbiAgICBmb250V2VpZ2h0OiAnYm9sZGVyJ1xuICB9LCBfcmVmW1wiY29kZSxcXG4gICAga2JkLFxcbiAgICBzYW1wXCJdID0ge1xuICAgIGZvbnRGYW1pbHk6ICdtb25vc3BhY2UsIG1vbm9zcGFjZScsXG4gICAgZm9udFNpemU6ICcxZW0nXG4gIH0sIF9yZWYuc21hbGwgPSB7XG4gICAgZm9udFNpemU6ICc4MCUnXG4gIH0sIF9yZWZbXCJzdWIsXFxuICAgIHN1cFwiXSA9IHtcbiAgICBmb250U2l6ZTogJzc1JScsXG4gICAgbGluZUhlaWdodDogJzAnLFxuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIHZlcnRpY2FsQWxpZ246ICdiYXNlbGluZSdcbiAgfSwgX3JlZi5zdWIgPSB7XG4gICAgYm90dG9tOiAnLTAuMjVlbSdcbiAgfSwgX3JlZi5zdXAgPSB7XG4gICAgdG9wOiAnLTAuNWVtJ1xuICB9LCBfcmVmLmltZyA9IHtcbiAgICBib3JkZXJTdHlsZTogJ25vbmUnXG4gIH0sIF9yZWZbXCJidXR0b24sXFxuICAgIGlucHV0LFxcbiAgICBvcHRncm91cCxcXG4gICAgc2VsZWN0LFxcbiAgICB0ZXh0YXJlYVwiXSA9IHtcbiAgICBmb250RmFtaWx5OiAnaW5oZXJpdCcsXG4gICAgZm9udFNpemU6ICcxMDAlJyxcbiAgICBsaW5lSGVpZ2h0OiAnMS4xNScsXG4gICAgbWFyZ2luOiAnMCdcbiAgfSwgX3JlZltcImJ1dHRvbixcXG4gICAgaW5wdXRcIl0gPSB7XG4gICAgb3ZlcmZsb3c6ICd2aXNpYmxlJ1xuICB9LCBfcmVmW1wiYnV0dG9uLFxcbiAgICBzZWxlY3RcIl0gPSB7XG4gICAgdGV4dFRyYW5zZm9ybTogJ25vbmUnXG4gIH0sIF9yZWZbXCJidXR0b24sXFxuICAgIGh0bWwgW3R5cGU9XFxcImJ1dHRvblxcXCJdLFxcbiAgICBbdHlwZT1cXFwicmVzZXRcXFwiXSxcXG4gICAgW3R5cGU9XFxcInN1Ym1pdFxcXCJdXCJdID0ge1xuICAgIFdlYmtpdEFwcGVhcmFuY2U6ICdidXR0b24nXG4gIH0sIF9yZWZbXCJidXR0b246Oi1tb3otZm9jdXMtaW5uZXIsXFxuICAgIFt0eXBlPVxcXCJidXR0b25cXFwiXTo6LW1vei1mb2N1cy1pbm5lcixcXG4gICAgW3R5cGU9XFxcInJlc2V0XFxcIl06Oi1tb3otZm9jdXMtaW5uZXIsXFxuICAgIFt0eXBlPVxcXCJzdWJtaXRcXFwiXTo6LW1vei1mb2N1cy1pbm5lclwiXSA9IHtcbiAgICBib3JkZXJTdHlsZTogJ25vbmUnLFxuICAgIHBhZGRpbmc6ICcwJ1xuICB9LCBfcmVmW1wiYnV0dG9uOi1tb3otZm9jdXNyaW5nLFxcbiAgICBbdHlwZT1cXFwiYnV0dG9uXFxcIl06LW1vei1mb2N1c3JpbmcsXFxuICAgIFt0eXBlPVxcXCJyZXNldFxcXCJdOi1tb3otZm9jdXNyaW5nLFxcbiAgICBbdHlwZT1cXFwic3VibWl0XFxcIl06LW1vei1mb2N1c3JpbmdcIl0gPSB7XG4gICAgb3V0bGluZTogJzFweCBkb3R0ZWQgQnV0dG9uVGV4dCdcbiAgfSwgX3JlZi5maWVsZHNldCA9IHtcbiAgICBwYWRkaW5nOiAnMC4zNWVtIDAuNjI1ZW0gMC43NWVtJ1xuICB9LCBfcmVmLmxlZ2VuZCA9IHtcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICBjb2xvcjogJ2luaGVyaXQnLFxuICAgIGRpc3BsYXk6ICd0YWJsZScsXG4gICAgbWF4V2lkdGg6ICcxMDAlJyxcbiAgICBwYWRkaW5nOiAnMCcsXG4gICAgd2hpdGVTcGFjZTogJ25vcm1hbCdcbiAgfSwgX3JlZi5wcm9ncmVzcyA9IHtcbiAgICB2ZXJ0aWNhbEFsaWduOiAnYmFzZWxpbmUnXG4gIH0sIF9yZWYudGV4dGFyZWEgPSB7XG4gICAgb3ZlcmZsb3c6ICdhdXRvJ1xuICB9LCBfcmVmW1wiW3R5cGU9XFxcImNoZWNrYm94XFxcIl0sXFxuICAgIFt0eXBlPVxcXCJyYWRpb1xcXCJdXCJdID0ge1xuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIHBhZGRpbmc6ICcwJ1xuICB9LCBfcmVmW1wiW3R5cGU9XFxcIm51bWJlclxcXCJdOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uLFxcbiAgICBbdHlwZT1cXFwibnVtYmVyXFxcIl06Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b25cIl0gPSB7XG4gICAgaGVpZ2h0OiAnYXV0bydcbiAgfSwgX3JlZlsnW3R5cGU9XCJzZWFyY2hcIl0nXSA9IHtcbiAgICBXZWJraXRBcHBlYXJhbmNlOiAndGV4dGZpZWxkJyxcbiAgICBvdXRsaW5lT2Zmc2V0OiAnLTJweCdcbiAgfSwgX3JlZlsnW3R5cGU9XCJzZWFyY2hcIl06Oi13ZWJraXQtc2VhcmNoLWRlY29yYXRpb24nXSA9IHtcbiAgICBXZWJraXRBcHBlYXJhbmNlOiAnbm9uZSdcbiAgfSwgX3JlZlsnOjotd2Via2l0LWZpbGUtdXBsb2FkLWJ1dHRvbiddID0ge1xuICAgIFdlYmtpdEFwcGVhcmFuY2U6ICdidXR0b24nLFxuICAgIGZvbnQ6ICdpbmhlcml0J1xuICB9LCBfcmVmLmRldGFpbHMgPSB7XG4gICAgZGlzcGxheTogJ2Jsb2NrJ1xuICB9LCBfcmVmLnN1bW1hcnkgPSB7XG4gICAgZGlzcGxheTogJ2xpc3QtaXRlbSdcbiAgfSwgX3JlZi50ZW1wbGF0ZSA9IHtcbiAgICBkaXNwbGF5OiAnbm9uZSdcbiAgfSwgX3JlZlsnW2hpZGRlbl0nXSA9IHtcbiAgICBkaXNwbGF5OiAnbm9uZSdcbiAgfSwgX3JlZiksIHtcbiAgICAnYWJiclt0aXRsZV0nOiB7XG4gICAgICB0ZXh0RGVjb3JhdGlvbjogJ3VuZGVybGluZSBkb3R0ZWQnXG4gICAgfVxuICB9XTtcbn1cblxudmFyIF90ZW1wbGF0ZU9iamVjdDtcbi8qKlxuICogQ1NTIGZvciBkZWNsYXJpbmcgYSByYWRpYWwgZ3JhZGllbnQsIGluY2x1ZGluZyBhIGZhbGxiYWNrIGJhY2tncm91bmQtY29sb3IuIFRoZSBmYWxsYmFjayBpcyBlaXRoZXIgdGhlIGZpcnN0IGNvbG9yLXN0b3Agb3IgYW4gZXhwbGljaXRseSBwYXNzZWQgZmFsbGJhY2sgY29sb3IuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4ucmFkaWFsR3JhZGllbnQoe1xuICogICAgIGNvbG9yU3RvcHM6IFsnIzAwRkZGRiAwJScsICdyZ2JhKDAsIDAsIDI1NSwgMCkgNTAlJywgJyMwMDAwRkYgOTUlJ10sXG4gKiAgICAgZXh0ZW50OiAnZmFydGhlc3QtY29ybmVyIGF0IDQ1cHggNDVweCcsXG4gKiAgICAgcG9zaXRpb246ICdjZW50ZXInLFxuICogICAgIHNoYXBlOiAnZWxsaXBzZScsXG4gKiAgIH0pXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7cmFkaWFsR3JhZGllbnQoe1xuICogICAgIGNvbG9yU3RvcHM6IFsnIzAwRkZGRiAwJScsICdyZ2JhKDAsIDAsIDI1NSwgMCkgNTAlJywgJyMwMDAwRkYgOTUlJ10sXG4gKiAgICAgZXh0ZW50OiAnZmFydGhlc3QtY29ybmVyIGF0IDQ1cHggNDVweCcsXG4gKiAgICAgcG9zaXRpb246ICdjZW50ZXInLFxuICogICAgIHNoYXBlOiAnZWxsaXBzZScsXG4gKiAgIH0pfVxuICpgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdjoge1xuICogICAnYmFja2dyb3VuZENvbG9yJzogJyMwMEZGRkYnLFxuICogICAnYmFja2dyb3VuZEltYWdlJzogJ3JhZGlhbC1ncmFkaWVudChjZW50ZXIgZWxsaXBzZSBmYXJ0aGVzdC1jb3JuZXIgYXQgNDVweCA0NXB4LCAjMDBGRkZGIDAlLCByZ2JhKDAsIDAsIDI1NSwgMCkgNTAlLCAjMDAwMEZGIDk1JSknLFxuICogfVxuICovXG5mdW5jdGlvbiByYWRpYWxHcmFkaWVudChfcmVmKSB7XG4gIHZhciBjb2xvclN0b3BzID0gX3JlZi5jb2xvclN0b3BzLFxuICAgIF9yZWYkZXh0ZW50ID0gX3JlZi5leHRlbnQsXG4gICAgZXh0ZW50ID0gX3JlZiRleHRlbnQgPT09IHZvaWQgMCA/ICcnIDogX3JlZiRleHRlbnQsXG4gICAgZmFsbGJhY2sgPSBfcmVmLmZhbGxiYWNrLFxuICAgIF9yZWYkcG9zaXRpb24gPSBfcmVmLnBvc2l0aW9uLFxuICAgIHBvc2l0aW9uID0gX3JlZiRwb3NpdGlvbiA9PT0gdm9pZCAwID8gJycgOiBfcmVmJHBvc2l0aW9uLFxuICAgIF9yZWYkc2hhcGUgPSBfcmVmLnNoYXBlLFxuICAgIHNoYXBlID0gX3JlZiRzaGFwZSA9PT0gdm9pZCAwID8gJycgOiBfcmVmJHNoYXBlO1xuICBpZiAoIWNvbG9yU3RvcHMgfHwgY29sb3JTdG9wcy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNTcpO1xuICB9XG4gIHJldHVybiB7XG4gICAgYmFja2dyb3VuZENvbG9yOiBmYWxsYmFjayB8fCBjb2xvclN0b3BzWzBdLnNwbGl0KCcgJylbMF0sXG4gICAgYmFja2dyb3VuZEltYWdlOiBjb25zdHJ1Y3RHcmFkaWVudFZhbHVlKF90ZW1wbGF0ZU9iamVjdCB8fCAoX3RlbXBsYXRlT2JqZWN0ID0gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlKFtcInJhZGlhbC1ncmFkaWVudChcIiwgXCJcIiwgXCJcIiwgXCJcIiwgXCIpXCJdKSksIHBvc2l0aW9uLCBzaGFwZSwgZXh0ZW50LCBjb2xvclN0b3BzLmpvaW4oJywgJykpXG4gIH07XG59XG5cbi8qKlxuICogQSBoZWxwZXIgdG8gZ2VuZXJhdGUgYSByZXRpbmEgYmFja2dyb3VuZCBpbWFnZSBhbmQgbm9uLXJldGluYVxuICogYmFja2dyb3VuZCBpbWFnZS4gVGhlIHJldGluYSBiYWNrZ3JvdW5kIGltYWdlIHdpbGwgb3V0cHV0IHRvIGEgSGlEUEkgbWVkaWEgcXVlcnkuIFRoZSBtaXhpbiB1c2VzXG4gKiBhIF8yeC5wbmcgZmlsZW5hbWUgc3VmZml4IGJ5IGRlZmF1bHQuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAuLi5yZXRpbmFJbWFnZSgnbXktaW1nJylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtyZXRpbmFJbWFnZSgnbXktaW1nJyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICogZGl2IHtcbiAqICAgYmFja2dyb3VuZEltYWdlOiAndXJsKG15LWltZy5wbmcpJyxcbiAqICAgJ0BtZWRpYSBvbmx5IHNjcmVlbiBhbmQgKC13ZWJraXQtbWluLWRldmljZS1waXhlbC1yYXRpbzogMS4zKSxcbiAqICAgIG9ubHkgc2NyZWVuIGFuZCAobWluLS1tb3otZGV2aWNlLXBpeGVsLXJhdGlvOiAxLjMpLFxuICogICAgb25seSBzY3JlZW4gYW5kICgtby1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAxLjMvMSksXG4gKiAgICBvbmx5IHNjcmVlbiBhbmQgKG1pbi1yZXNvbHV0aW9uOiAxNDRkcGkpLFxuICogICAgb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMS41ZHBweCknOiB7XG4gKiAgICAgYmFja2dyb3VuZEltYWdlOiAndXJsKG15LWltZ18yeC5wbmcpJyxcbiAqICAgfVxuICogfVxuICovXG5mdW5jdGlvbiByZXRpbmFJbWFnZShmaWxlbmFtZSwgYmFja2dyb3VuZFNpemUsIGV4dGVuc2lvbiwgcmV0aW5hRmlsZW5hbWUsIHJldGluYVN1ZmZpeCkge1xuICB2YXIgX3JlZjtcbiAgaWYgKGV4dGVuc2lvbiA9PT0gdm9pZCAwKSB7XG4gICAgZXh0ZW5zaW9uID0gJ3BuZyc7XG4gIH1cbiAgaWYgKHJldGluYVN1ZmZpeCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0aW5hU3VmZml4ID0gJ18yeCc7XG4gIH1cbiAgaWYgKCFmaWxlbmFtZSkge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDU4KTtcbiAgfVxuICAvLyBSZXBsYWNlIHRoZSBkb3QgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcGFzc2VkIGV4dGVuc2lvbiBpZiBvbmUgZXhpc3RzXG4gIHZhciBleHQgPSBleHRlbnNpb24ucmVwbGFjZSgvXlxcLi8sICcnKTtcbiAgdmFyIHJGaWxlbmFtZSA9IHJldGluYUZpbGVuYW1lID8gcmV0aW5hRmlsZW5hbWUgKyBcIi5cIiArIGV4dCA6IFwiXCIgKyBmaWxlbmFtZSArIHJldGluYVN1ZmZpeCArIFwiLlwiICsgZXh0O1xuICByZXR1cm4gX3JlZiA9IHtcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwidXJsKFwiICsgZmlsZW5hbWUgKyBcIi5cIiArIGV4dCArIFwiKVwiXG4gIH0sIF9yZWZbaGlEUEkoKV0gPSBfZXh0ZW5kcyh7XG4gICAgYmFja2dyb3VuZEltYWdlOiBcInVybChcIiArIHJGaWxlbmFtZSArIFwiKVwiXG4gIH0sIGJhY2tncm91bmRTaXplID8ge1xuICAgIGJhY2tncm91bmRTaXplOiBiYWNrZ3JvdW5kU2l6ZVxuICB9IDoge30pLCBfcmVmO1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBrZXktc3BhY2luZyAqL1xudmFyIGZ1bmN0aW9uc01hcCA9IHtcbiAgZWFzZUluQmFjazogJ2N1YmljLWJlemllcigwLjYwMCwgLTAuMjgwLCAwLjczNSwgMC4wNDUpJyxcbiAgZWFzZUluQ2lyYzogJ2N1YmljLWJlemllcigwLjYwMCwgIDAuMDQwLCAwLjk4MCwgMC4zMzUpJyxcbiAgZWFzZUluQ3ViaWM6ICdjdWJpYy1iZXppZXIoMC41NTAsICAwLjA1NSwgMC42NzUsIDAuMTkwKScsXG4gIGVhc2VJbkV4cG86ICdjdWJpYy1iZXppZXIoMC45NTAsICAwLjA1MCwgMC43OTUsIDAuMDM1KScsXG4gIGVhc2VJblF1YWQ6ICdjdWJpYy1iZXppZXIoMC41NTAsICAwLjA4NSwgMC42ODAsIDAuNTMwKScsXG4gIGVhc2VJblF1YXJ0OiAnY3ViaWMtYmV6aWVyKDAuODk1LCAgMC4wMzAsIDAuNjg1LCAwLjIyMCknLFxuICBlYXNlSW5RdWludDogJ2N1YmljLWJlemllcigwLjc1NSwgIDAuMDUwLCAwLjg1NSwgMC4wNjApJyxcbiAgZWFzZUluU2luZTogJ2N1YmljLWJlemllcigwLjQ3MCwgIDAuMDAwLCAwLjc0NSwgMC43MTUpJyxcbiAgZWFzZU91dEJhY2s6ICdjdWJpYy1iZXppZXIoMC4xNzUsICAwLjg4NSwgMC4zMjAsIDEuMjc1KScsXG4gIGVhc2VPdXRDdWJpYzogJ2N1YmljLWJlemllcigwLjIxNSwgIDAuNjEwLCAwLjM1NSwgMS4wMDApJyxcbiAgZWFzZU91dENpcmM6ICdjdWJpYy1iZXppZXIoMC4wNzUsICAwLjgyMCwgMC4xNjUsIDEuMDAwKScsXG4gIGVhc2VPdXRFeHBvOiAnY3ViaWMtYmV6aWVyKDAuMTkwLCAgMS4wMDAsIDAuMjIwLCAxLjAwMCknLFxuICBlYXNlT3V0UXVhZDogJ2N1YmljLWJlemllcigwLjI1MCwgIDAuNDYwLCAwLjQ1MCwgMC45NDApJyxcbiAgZWFzZU91dFF1YXJ0OiAnY3ViaWMtYmV6aWVyKDAuMTY1LCAgMC44NDAsIDAuNDQwLCAxLjAwMCknLFxuICBlYXNlT3V0UXVpbnQ6ICdjdWJpYy1iZXppZXIoMC4yMzAsICAxLjAwMCwgMC4zMjAsIDEuMDAwKScsXG4gIGVhc2VPdXRTaW5lOiAnY3ViaWMtYmV6aWVyKDAuMzkwLCAgMC41NzUsIDAuNTY1LCAxLjAwMCknLFxuICBlYXNlSW5PdXRCYWNrOiAnY3ViaWMtYmV6aWVyKDAuNjgwLCAtMC41NTAsIDAuMjY1LCAxLjU1MCknLFxuICBlYXNlSW5PdXRDaXJjOiAnY3ViaWMtYmV6aWVyKDAuNzg1LCAgMC4xMzUsIDAuMTUwLCAwLjg2MCknLFxuICBlYXNlSW5PdXRDdWJpYzogJ2N1YmljLWJlemllcigwLjY0NSwgIDAuMDQ1LCAwLjM1NSwgMS4wMDApJyxcbiAgZWFzZUluT3V0RXhwbzogJ2N1YmljLWJlemllcigxLjAwMCwgIDAuMDAwLCAwLjAwMCwgMS4wMDApJyxcbiAgZWFzZUluT3V0UXVhZDogJ2N1YmljLWJlemllcigwLjQ1NSwgIDAuMDMwLCAwLjUxNSwgMC45NTUpJyxcbiAgZWFzZUluT3V0UXVhcnQ6ICdjdWJpYy1iZXppZXIoMC43NzAsICAwLjAwMCwgMC4xNzUsIDEuMDAwKScsXG4gIGVhc2VJbk91dFF1aW50OiAnY3ViaWMtYmV6aWVyKDAuODYwLCAgMC4wMDAsIDAuMDcwLCAxLjAwMCknLFxuICBlYXNlSW5PdXRTaW5lOiAnY3ViaWMtYmV6aWVyKDAuNDQ1LCAgMC4wNTAsIDAuNTUwLCAwLjk1MCknXG59O1xuLyogZXNsaW50LWVuYWJsZSBrZXktc3BhY2luZyAqL1xuXG5mdW5jdGlvbiBnZXRUaW1pbmdGdW5jdGlvbihmdW5jdGlvbk5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uc01hcFtmdW5jdGlvbk5hbWVdO1xufVxuXG4vKipcbiAqIFN0cmluZyB0byByZXByZXNlbnQgY29tbW9uIGVhc2luZyBmdW5jdGlvbnMgYXMgZGVtb25zdHJhdGVkIGhlcmU6IChnaXRodWIuY29tL2phdWtpYS9lYXNpZSkuXG4gKlxuICogQGRlcHJlY2F0ZWQgLSBUaGlzIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB2NSBpbiBmYXZvciBvZiBgZWFzZUluYCwgYGVhc2VPdXRgLCBgZWFzZUluT3V0YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAndHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uJzogdGltaW5nRnVuY3Rpb25zKCdlYXNlSW5RdWFkJylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogJHt0aW1pbmdGdW5jdGlvbnMoJ2Vhc2VJblF1YWQnKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqICdkaXYnOiB7XG4gKiAgICd0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24nOiAnY3ViaWMtYmV6aWVyKDAuNTUwLCAgMC4wODUsIDAuNjgwLCAwLjUzMCknLFxuICogfVxuICovXG5cbmZ1bmN0aW9uIHRpbWluZ0Z1bmN0aW9ucyh0aW1pbmdGdW5jdGlvbikge1xuICByZXR1cm4gZ2V0VGltaW5nRnVuY3Rpb24odGltaW5nRnVuY3Rpb24pO1xufVxuXG52YXIgZ2V0Qm9yZGVyV2lkdGggPSBmdW5jdGlvbiBnZXRCb3JkZXJXaWR0aChwb2ludGluZ0RpcmVjdGlvbiwgaGVpZ2h0LCB3aWR0aCkge1xuICB2YXIgZnVsbFdpZHRoID0gXCJcIiArIHdpZHRoWzBdICsgKHdpZHRoWzFdIHx8ICcnKTtcbiAgdmFyIGhhbGZXaWR0aCA9IFwiXCIgKyB3aWR0aFswXSAvIDIgKyAod2lkdGhbMV0gfHwgJycpO1xuICB2YXIgZnVsbEhlaWdodCA9IFwiXCIgKyBoZWlnaHRbMF0gKyAoaGVpZ2h0WzFdIHx8ICcnKTtcbiAgdmFyIGhhbGZIZWlnaHQgPSBcIlwiICsgaGVpZ2h0WzBdIC8gMiArIChoZWlnaHRbMV0gfHwgJycpO1xuICBzd2l0Y2ggKHBvaW50aW5nRGlyZWN0aW9uKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICAgIHJldHVybiBcIjAgXCIgKyBoYWxmV2lkdGggKyBcIiBcIiArIGZ1bGxIZWlnaHQgKyBcIiBcIiArIGhhbGZXaWR0aDtcbiAgICBjYXNlICd0b3BMZWZ0JzpcbiAgICAgIHJldHVybiBmdWxsV2lkdGggKyBcIiBcIiArIGZ1bGxIZWlnaHQgKyBcIiAwIDBcIjtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHJldHVybiBoYWxmSGVpZ2h0ICsgXCIgXCIgKyBmdWxsV2lkdGggKyBcIiBcIiArIGhhbGZIZWlnaHQgKyBcIiAwXCI7XG4gICAgY2FzZSAnYm90dG9tTGVmdCc6XG4gICAgICByZXR1cm4gZnVsbFdpZHRoICsgXCIgMCAwIFwiICsgZnVsbEhlaWdodDtcbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgcmV0dXJuIGZ1bGxIZWlnaHQgKyBcIiBcIiArIGhhbGZXaWR0aCArIFwiIDAgXCIgKyBoYWxmV2lkdGg7XG4gICAgY2FzZSAnYm90dG9tUmlnaHQnOlxuICAgICAgcmV0dXJuIFwiMCAwIFwiICsgZnVsbFdpZHRoICsgXCIgXCIgKyBmdWxsSGVpZ2h0O1xuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHJldHVybiBoYWxmSGVpZ2h0ICsgXCIgMCBcIiArIGhhbGZIZWlnaHQgKyBcIiBcIiArIGZ1bGxXaWR0aDtcbiAgICBjYXNlICd0b3BSaWdodCc6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcIjAgXCIgKyBmdWxsV2lkdGggKyBcIiBcIiArIGZ1bGxIZWlnaHQgKyBcIiAwXCI7XG4gIH1cbn07XG52YXIgZ2V0Qm9yZGVyQ29sb3IgPSBmdW5jdGlvbiBnZXRCb3JkZXJDb2xvcihwb2ludGluZ0RpcmVjdGlvbiwgZm9yZWdyb3VuZENvbG9yKSB7XG4gIHN3aXRjaCAocG9pbnRpbmdEaXJlY3Rpb24pIHtcbiAgICBjYXNlICd0b3AnOlxuICAgIGNhc2UgJ2JvdHRvbVJpZ2h0JzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJvcmRlckJvdHRvbUNvbG9yOiBmb3JlZ3JvdW5kQ29sb3JcbiAgICAgIH07XG4gICAgY2FzZSAncmlnaHQnOlxuICAgIGNhc2UgJ2JvdHRvbUxlZnQnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYm9yZGVyTGVmdENvbG9yOiBmb3JlZ3JvdW5kQ29sb3JcbiAgICAgIH07XG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICBjYXNlICd0b3BMZWZ0JzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJvcmRlclRvcENvbG9yOiBmb3JlZ3JvdW5kQ29sb3JcbiAgICAgIH07XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgY2FzZSAndG9wUmlnaHQnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYm9yZGVyUmlnaHRDb2xvcjogZm9yZWdyb3VuZENvbG9yXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig1OSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ1NTIHRvIHJlcHJlc2VudCB0cmlhbmdsZSB3aXRoIGFueSBwb2ludGluZyBkaXJlY3Rpb24gd2l0aCBhbiBvcHRpb25hbCBiYWNrZ3JvdW5kIGNvbG9yLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKlxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi50cmlhbmdsZSh7IHBvaW50aW5nRGlyZWN0aW9uOiAncmlnaHQnLCB3aWR0aDogJzEwMHB4JywgaGVpZ2h0OiAnMTAwcHgnLCBmb3JlZ3JvdW5kQ29sb3I6ICdyZWQnIH0pXG4gKiB9XG4gKlxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke3RyaWFuZ2xlKHsgcG9pbnRpbmdEaXJlY3Rpb246ICdyaWdodCcsIHdpZHRoOiAnMTAwcHgnLCBoZWlnaHQ6ICcxMDBweCcsIGZvcmVncm91bmRDb2xvcjogJ3JlZCcgfSl9XG4gKlxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXY6IHtcbiAqICAnYm9yZGVyQ29sb3InOiAndHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgcmVkJyxcbiAqICAnYm9yZGVyU3R5bGUnOiAnc29saWQnLFxuICogICdib3JkZXJXaWR0aCc6ICc1MHB4IDAgNTBweCAxMDBweCcsXG4gKiAgJ2hlaWdodCc6ICcwJyxcbiAqICAnd2lkdGgnOiAnMCcsXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHRyaWFuZ2xlKF9yZWYpIHtcbiAgdmFyIHBvaW50aW5nRGlyZWN0aW9uID0gX3JlZi5wb2ludGluZ0RpcmVjdGlvbixcbiAgICBoZWlnaHQgPSBfcmVmLmhlaWdodCxcbiAgICB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgZm9yZWdyb3VuZENvbG9yID0gX3JlZi5mb3JlZ3JvdW5kQ29sb3IsXG4gICAgX3JlZiRiYWNrZ3JvdW5kQ29sb3IgPSBfcmVmLmJhY2tncm91bmRDb2xvcixcbiAgICBiYWNrZ3JvdW5kQ29sb3IgPSBfcmVmJGJhY2tncm91bmRDb2xvciA9PT0gdm9pZCAwID8gJ3RyYW5zcGFyZW50JyA6IF9yZWYkYmFja2dyb3VuZENvbG9yO1xuICB2YXIgd2lkdGhBbmRVbml0ID0gZ2V0VmFsdWVBbmRVbml0KHdpZHRoKTtcbiAgdmFyIGhlaWdodEFuZFVuaXQgPSBnZXRWYWx1ZUFuZFVuaXQoaGVpZ2h0KTtcbiAgaWYgKGlzTmFOKGhlaWdodEFuZFVuaXRbMF0pIHx8IGlzTmFOKHdpZHRoQW5kVW5pdFswXSkpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig2MCk7XG4gIH1cbiAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICB3aWR0aDogJzAnLFxuICAgIGhlaWdodDogJzAnLFxuICAgIGJvcmRlckNvbG9yOiBiYWNrZ3JvdW5kQ29sb3JcbiAgfSwgZ2V0Qm9yZGVyQ29sb3IocG9pbnRpbmdEaXJlY3Rpb24sIGZvcmVncm91bmRDb2xvciksIHtcbiAgICBib3JkZXJTdHlsZTogJ3NvbGlkJyxcbiAgICBib3JkZXJXaWR0aDogZ2V0Qm9yZGVyV2lkdGgocG9pbnRpbmdEaXJlY3Rpb24sIGhlaWdodEFuZFVuaXQsIHdpZHRoQW5kVW5pdClcbiAgfSk7XG59XG5cbi8qKlxuICogUHJvdmlkZXMgYW4gZWFzeSB3YXkgdG8gY2hhbmdlIHRoZSBgd29yZFdyYXBgIHByb3BlcnR5LlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLndvcmRXcmFwKCdicmVhay13b3JkJylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHt3b3JkV3JhcCgnYnJlYWstd29yZCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIG92ZXJmbG93V3JhcDogJ2JyZWFrLXdvcmQnLFxuICogICB3b3JkV3JhcDogJ2JyZWFrLXdvcmQnLFxuICogICB3b3JkQnJlYWs6ICdicmVhay1hbGwnLFxuICogfVxuICovXG5mdW5jdGlvbiB3b3JkV3JhcCh3cmFwKSB7XG4gIGlmICh3cmFwID09PSB2b2lkIDApIHtcbiAgICB3cmFwID0gJ2JyZWFrLXdvcmQnO1xuICB9XG4gIHZhciB3b3JkQnJlYWsgPSB3cmFwID09PSAnYnJlYWstd29yZCcgPyAnYnJlYWstYWxsJyA6IHdyYXA7XG4gIHJldHVybiB7XG4gICAgb3ZlcmZsb3dXcmFwOiB3cmFwLFxuICAgIHdvcmRXcmFwOiB3cmFwLFxuICAgIHdvcmRCcmVhazogd29yZEJyZWFrXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbG9yVG9JbnQoY29sb3IpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQoY29sb3IgKiAyNTUpO1xufVxuZnVuY3Rpb24gY29udmVydFRvSW50KHJlZCwgZ3JlZW4sIGJsdWUpIHtcbiAgcmV0dXJuIGNvbG9yVG9JbnQocmVkKSArIFwiLFwiICsgY29sb3JUb0ludChncmVlbikgKyBcIixcIiArIGNvbG9yVG9JbnQoYmx1ZSk7XG59XG5mdW5jdGlvbiBoc2xUb1JnYihodWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcywgY29udmVydCkge1xuICBpZiAoY29udmVydCA9PT0gdm9pZCAwKSB7XG4gICAgY29udmVydCA9IGNvbnZlcnRUb0ludDtcbiAgfVxuICBpZiAoc2F0dXJhdGlvbiA9PT0gMCkge1xuICAgIC8vIGFjaHJvbWF0aWNcbiAgICByZXR1cm4gY29udmVydChsaWdodG5lc3MsIGxpZ2h0bmVzcywgbGlnaHRuZXNzKTtcbiAgfVxuXG4gIC8vIGZvcm11bGFlIGZyb20gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSFNMX2FuZF9IU1ZcbiAgdmFyIGh1ZVByaW1lID0gKGh1ZSAlIDM2MCArIDM2MCkgJSAzNjAgLyA2MDtcbiAgdmFyIGNocm9tYSA9ICgxIC0gTWF0aC5hYnMoMiAqIGxpZ2h0bmVzcyAtIDEpKSAqIHNhdHVyYXRpb247XG4gIHZhciBzZWNvbmRDb21wb25lbnQgPSBjaHJvbWEgKiAoMSAtIE1hdGguYWJzKGh1ZVByaW1lICUgMiAtIDEpKTtcbiAgdmFyIHJlZCA9IDA7XG4gIHZhciBncmVlbiA9IDA7XG4gIHZhciBibHVlID0gMDtcbiAgaWYgKGh1ZVByaW1lID49IDAgJiYgaHVlUHJpbWUgPCAxKSB7XG4gICAgcmVkID0gY2hyb21hO1xuICAgIGdyZWVuID0gc2Vjb25kQ29tcG9uZW50O1xuICB9IGVsc2UgaWYgKGh1ZVByaW1lID49IDEgJiYgaHVlUHJpbWUgPCAyKSB7XG4gICAgcmVkID0gc2Vjb25kQ29tcG9uZW50O1xuICAgIGdyZWVuID0gY2hyb21hO1xuICB9IGVsc2UgaWYgKGh1ZVByaW1lID49IDIgJiYgaHVlUHJpbWUgPCAzKSB7XG4gICAgZ3JlZW4gPSBjaHJvbWE7XG4gICAgYmx1ZSA9IHNlY29uZENvbXBvbmVudDtcbiAgfSBlbHNlIGlmIChodWVQcmltZSA+PSAzICYmIGh1ZVByaW1lIDwgNCkge1xuICAgIGdyZWVuID0gc2Vjb25kQ29tcG9uZW50O1xuICAgIGJsdWUgPSBjaHJvbWE7XG4gIH0gZWxzZSBpZiAoaHVlUHJpbWUgPj0gNCAmJiBodWVQcmltZSA8IDUpIHtcbiAgICByZWQgPSBzZWNvbmRDb21wb25lbnQ7XG4gICAgYmx1ZSA9IGNocm9tYTtcbiAgfSBlbHNlIGlmIChodWVQcmltZSA+PSA1ICYmIGh1ZVByaW1lIDwgNikge1xuICAgIHJlZCA9IGNocm9tYTtcbiAgICBibHVlID0gc2Vjb25kQ29tcG9uZW50O1xuICB9XG4gIHZhciBsaWdodG5lc3NNb2RpZmljYXRpb24gPSBsaWdodG5lc3MgLSBjaHJvbWEgLyAyO1xuICB2YXIgZmluYWxSZWQgPSByZWQgKyBsaWdodG5lc3NNb2RpZmljYXRpb247XG4gIHZhciBmaW5hbEdyZWVuID0gZ3JlZW4gKyBsaWdodG5lc3NNb2RpZmljYXRpb247XG4gIHZhciBmaW5hbEJsdWUgPSBibHVlICsgbGlnaHRuZXNzTW9kaWZpY2F0aW9uO1xuICByZXR1cm4gY29udmVydChmaW5hbFJlZCwgZmluYWxHcmVlbiwgZmluYWxCbHVlKTtcbn1cblxudmFyIG5hbWVkQ29sb3JNYXAgPSB7XG4gIGFsaWNlYmx1ZTogJ2YwZjhmZicsXG4gIGFudGlxdWV3aGl0ZTogJ2ZhZWJkNycsXG4gIGFxdWE6ICcwMGZmZmYnLFxuICBhcXVhbWFyaW5lOiAnN2ZmZmQ0JyxcbiAgYXp1cmU6ICdmMGZmZmYnLFxuICBiZWlnZTogJ2Y1ZjVkYycsXG4gIGJpc3F1ZTogJ2ZmZTRjNCcsXG4gIGJsYWNrOiAnMDAwJyxcbiAgYmxhbmNoZWRhbG1vbmQ6ICdmZmViY2QnLFxuICBibHVlOiAnMDAwMGZmJyxcbiAgYmx1ZXZpb2xldDogJzhhMmJlMicsXG4gIGJyb3duOiAnYTUyYTJhJyxcbiAgYnVybHl3b29kOiAnZGViODg3JyxcbiAgY2FkZXRibHVlOiAnNWY5ZWEwJyxcbiAgY2hhcnRyZXVzZTogJzdmZmYwMCcsXG4gIGNob2NvbGF0ZTogJ2QyNjkxZScsXG4gIGNvcmFsOiAnZmY3ZjUwJyxcbiAgY29ybmZsb3dlcmJsdWU6ICc2NDk1ZWQnLFxuICBjb3Juc2lsazogJ2ZmZjhkYycsXG4gIGNyaW1zb246ICdkYzE0M2MnLFxuICBjeWFuOiAnMDBmZmZmJyxcbiAgZGFya2JsdWU6ICcwMDAwOGInLFxuICBkYXJrY3lhbjogJzAwOGI4YicsXG4gIGRhcmtnb2xkZW5yb2Q6ICdiODg2MGInLFxuICBkYXJrZ3JheTogJ2E5YTlhOScsXG4gIGRhcmtncmVlbjogJzAwNjQwMCcsXG4gIGRhcmtncmV5OiAnYTlhOWE5JyxcbiAgZGFya2toYWtpOiAnYmRiNzZiJyxcbiAgZGFya21hZ2VudGE6ICc4YjAwOGInLFxuICBkYXJrb2xpdmVncmVlbjogJzU1NmIyZicsXG4gIGRhcmtvcmFuZ2U6ICdmZjhjMDAnLFxuICBkYXJrb3JjaGlkOiAnOTkzMmNjJyxcbiAgZGFya3JlZDogJzhiMDAwMCcsXG4gIGRhcmtzYWxtb246ICdlOTk2N2EnLFxuICBkYXJrc2VhZ3JlZW46ICc4ZmJjOGYnLFxuICBkYXJrc2xhdGVibHVlOiAnNDgzZDhiJyxcbiAgZGFya3NsYXRlZ3JheTogJzJmNGY0ZicsXG4gIGRhcmtzbGF0ZWdyZXk6ICcyZjRmNGYnLFxuICBkYXJrdHVycXVvaXNlOiAnMDBjZWQxJyxcbiAgZGFya3Zpb2xldDogJzk0MDBkMycsXG4gIGRlZXBwaW5rOiAnZmYxNDkzJyxcbiAgZGVlcHNreWJsdWU6ICcwMGJmZmYnLFxuICBkaW1ncmF5OiAnNjk2OTY5JyxcbiAgZGltZ3JleTogJzY5Njk2OScsXG4gIGRvZGdlcmJsdWU6ICcxZTkwZmYnLFxuICBmaXJlYnJpY2s6ICdiMjIyMjInLFxuICBmbG9yYWx3aGl0ZTogJ2ZmZmFmMCcsXG4gIGZvcmVzdGdyZWVuOiAnMjI4YjIyJyxcbiAgZnVjaHNpYTogJ2ZmMDBmZicsXG4gIGdhaW5zYm9ybzogJ2RjZGNkYycsXG4gIGdob3N0d2hpdGU6ICdmOGY4ZmYnLFxuICBnb2xkOiAnZmZkNzAwJyxcbiAgZ29sZGVucm9kOiAnZGFhNTIwJyxcbiAgZ3JheTogJzgwODA4MCcsXG4gIGdyZWVuOiAnMDA4MDAwJyxcbiAgZ3JlZW55ZWxsb3c6ICdhZGZmMmYnLFxuICBncmV5OiAnODA4MDgwJyxcbiAgaG9uZXlkZXc6ICdmMGZmZjAnLFxuICBob3RwaW5rOiAnZmY2OWI0JyxcbiAgaW5kaWFucmVkOiAnY2Q1YzVjJyxcbiAgaW5kaWdvOiAnNGIwMDgyJyxcbiAgaXZvcnk6ICdmZmZmZjAnLFxuICBraGFraTogJ2YwZTY4YycsXG4gIGxhdmVuZGVyOiAnZTZlNmZhJyxcbiAgbGF2ZW5kZXJibHVzaDogJ2ZmZjBmNScsXG4gIGxhd25ncmVlbjogJzdjZmMwMCcsXG4gIGxlbW9uY2hpZmZvbjogJ2ZmZmFjZCcsXG4gIGxpZ2h0Ymx1ZTogJ2FkZDhlNicsXG4gIGxpZ2h0Y29yYWw6ICdmMDgwODAnLFxuICBsaWdodGN5YW46ICdlMGZmZmYnLFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogJ2ZhZmFkMicsXG4gIGxpZ2h0Z3JheTogJ2QzZDNkMycsXG4gIGxpZ2h0Z3JlZW46ICc5MGVlOTAnLFxuICBsaWdodGdyZXk6ICdkM2QzZDMnLFxuICBsaWdodHBpbms6ICdmZmI2YzEnLFxuICBsaWdodHNhbG1vbjogJ2ZmYTA3YScsXG4gIGxpZ2h0c2VhZ3JlZW46ICcyMGIyYWEnLFxuICBsaWdodHNreWJsdWU6ICc4N2NlZmEnLFxuICBsaWdodHNsYXRlZ3JheTogJzc4OScsXG4gIGxpZ2h0c2xhdGVncmV5OiAnNzg5JyxcbiAgbGlnaHRzdGVlbGJsdWU6ICdiMGM0ZGUnLFxuICBsaWdodHllbGxvdzogJ2ZmZmZlMCcsXG4gIGxpbWU6ICcwZjAnLFxuICBsaW1lZ3JlZW46ICczMmNkMzInLFxuICBsaW5lbjogJ2ZhZjBlNicsXG4gIG1hZ2VudGE6ICdmMGYnLFxuICBtYXJvb246ICc4MDAwMDAnLFxuICBtZWRpdW1hcXVhbWFyaW5lOiAnNjZjZGFhJyxcbiAgbWVkaXVtYmx1ZTogJzAwMDBjZCcsXG4gIG1lZGl1bW9yY2hpZDogJ2JhNTVkMycsXG4gIG1lZGl1bXB1cnBsZTogJzkzNzBkYicsXG4gIG1lZGl1bXNlYWdyZWVuOiAnM2NiMzcxJyxcbiAgbWVkaXVtc2xhdGVibHVlOiAnN2I2OGVlJyxcbiAgbWVkaXVtc3ByaW5nZ3JlZW46ICcwMGZhOWEnLFxuICBtZWRpdW10dXJxdW9pc2U6ICc0OGQxY2MnLFxuICBtZWRpdW12aW9sZXRyZWQ6ICdjNzE1ODUnLFxuICBtaWRuaWdodGJsdWU6ICcxOTE5NzAnLFxuICBtaW50Y3JlYW06ICdmNWZmZmEnLFxuICBtaXN0eXJvc2U6ICdmZmU0ZTEnLFxuICBtb2NjYXNpbjogJ2ZmZTRiNScsXG4gIG5hdmFqb3doaXRlOiAnZmZkZWFkJyxcbiAgbmF2eTogJzAwMDA4MCcsXG4gIG9sZGxhY2U6ICdmZGY1ZTYnLFxuICBvbGl2ZTogJzgwODAwMCcsXG4gIG9saXZlZHJhYjogJzZiOGUyMycsXG4gIG9yYW5nZTogJ2ZmYTUwMCcsXG4gIG9yYW5nZXJlZDogJ2ZmNDUwMCcsXG4gIG9yY2hpZDogJ2RhNzBkNicsXG4gIHBhbGVnb2xkZW5yb2Q6ICdlZWU4YWEnLFxuICBwYWxlZ3JlZW46ICc5OGZiOTgnLFxuICBwYWxldHVycXVvaXNlOiAnYWZlZWVlJyxcbiAgcGFsZXZpb2xldHJlZDogJ2RiNzA5MycsXG4gIHBhcGF5YXdoaXA6ICdmZmVmZDUnLFxuICBwZWFjaHB1ZmY6ICdmZmRhYjknLFxuICBwZXJ1OiAnY2Q4NTNmJyxcbiAgcGluazogJ2ZmYzBjYicsXG4gIHBsdW06ICdkZGEwZGQnLFxuICBwb3dkZXJibHVlOiAnYjBlMGU2JyxcbiAgcHVycGxlOiAnODAwMDgwJyxcbiAgcmViZWNjYXB1cnBsZTogJzYzOScsXG4gIHJlZDogJ2YwMCcsXG4gIHJvc3licm93bjogJ2JjOGY4ZicsXG4gIHJveWFsYmx1ZTogJzQxNjllMScsXG4gIHNhZGRsZWJyb3duOiAnOGI0NTEzJyxcbiAgc2FsbW9uOiAnZmE4MDcyJyxcbiAgc2FuZHlicm93bjogJ2Y0YTQ2MCcsXG4gIHNlYWdyZWVuOiAnMmU4YjU3JyxcbiAgc2Vhc2hlbGw6ICdmZmY1ZWUnLFxuICBzaWVubmE6ICdhMDUyMmQnLFxuICBzaWx2ZXI6ICdjMGMwYzAnLFxuICBza3libHVlOiAnODdjZWViJyxcbiAgc2xhdGVibHVlOiAnNmE1YWNkJyxcbiAgc2xhdGVncmF5OiAnNzA4MDkwJyxcbiAgc2xhdGVncmV5OiAnNzA4MDkwJyxcbiAgc25vdzogJ2ZmZmFmYScsXG4gIHNwcmluZ2dyZWVuOiAnMDBmZjdmJyxcbiAgc3RlZWxibHVlOiAnNDY4MmI0JyxcbiAgdGFuOiAnZDJiNDhjJyxcbiAgdGVhbDogJzAwODA4MCcsXG4gIHRoaXN0bGU6ICdkOGJmZDgnLFxuICB0b21hdG86ICdmZjYzNDcnLFxuICB0dXJxdW9pc2U6ICc0MGUwZDAnLFxuICB2aW9sZXQ6ICdlZTgyZWUnLFxuICB3aGVhdDogJ2Y1ZGViMycsXG4gIHdoaXRlOiAnZmZmJyxcbiAgd2hpdGVzbW9rZTogJ2Y1ZjVmNScsXG4gIHllbGxvdzogJ2ZmMCcsXG4gIHllbGxvd2dyZWVuOiAnOWFjZDMyJ1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdHJpbmcgaXMgYSBDU1MgbmFtZWQgY29sb3IgYW5kIHJldHVybnMgaXRzIGVxdWl2YWxlbnQgaGV4IHZhbHVlLCBvdGhlcndpc2UgcmV0dXJucyB0aGUgb3JpZ2luYWwgY29sb3IuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBuYW1lVG9IZXgoY29sb3IpIHtcbiAgaWYgKHR5cGVvZiBjb2xvciAhPT0gJ3N0cmluZycpIHJldHVybiBjb2xvcjtcbiAgdmFyIG5vcm1hbGl6ZWRDb2xvck5hbWUgPSBjb2xvci50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbmFtZWRDb2xvck1hcFtub3JtYWxpemVkQ29sb3JOYW1lXSA/IFwiI1wiICsgbmFtZWRDb2xvck1hcFtub3JtYWxpemVkQ29sb3JOYW1lXSA6IGNvbG9yO1xufVxuXG52YXIgaGV4UmVnZXggPSAvXiNbYS1mQS1GMC05XXs2fSQvO1xudmFyIGhleFJnYmFSZWdleCA9IC9eI1thLWZBLUYwLTldezh9JC87XG52YXIgcmVkdWNlZEhleFJlZ2V4ID0gL14jW2EtZkEtRjAtOV17M30kLztcbnZhciByZWR1Y2VkUmdiYUhleFJlZ2V4ID0gL14jW2EtZkEtRjAtOV17NH0kLztcbnZhciByZ2JSZWdleCA9IC9ecmdiXFwoXFxzKihcXGR7MSwzfSlcXHMqKD86LCk/XFxzKihcXGR7MSwzfSlcXHMqKD86LCk/XFxzKihcXGR7MSwzfSlcXHMqXFwpJC9pO1xudmFyIHJnYmFSZWdleCA9IC9ecmdiKD86YSk/XFwoXFxzKihcXGR7MSwzfSlcXHMqKD86LCk/XFxzKihcXGR7MSwzfSlcXHMqKD86LCk/XFxzKihcXGR7MSwzfSlcXHMqKD86LHxcXC8pXFxzKihbLStdP1xcZCpbLl0/XFxkK1slXT8pXFxzKlxcKSQvaTtcbnZhciBoc2xSZWdleCA9IC9eaHNsXFwoXFxzKihcXGR7MCwzfVsuXT9bMC05XSsoPzpkZWcpPylcXHMqKD86LCk/XFxzKihcXGR7MSwzfVsuXT9bMC05XT8pJVxccyooPzosKT9cXHMqKFxcZHsxLDN9Wy5dP1swLTldPyklXFxzKlxcKSQvaTtcbnZhciBoc2xhUmVnZXggPSAvXmhzbCg/OmEpP1xcKFxccyooXFxkezAsM31bLl0/WzAtOV0rKD86ZGVnKT8pXFxzKig/OiwpP1xccyooXFxkezEsM31bLl0/WzAtOV0/KSVcXHMqKD86LCk/XFxzKihcXGR7MSwzfVsuXT9bMC05XT8pJVxccyooPzosfFxcLylcXHMqKFstK10/XFxkKlsuXT9cXGQrWyVdPylcXHMqXFwpJC9pO1xuXG4vKipcbiAqIFJldHVybnMgYW4gUmdiQ29sb3Igb3IgUmdiYUNvbG9yIG9iamVjdC4gVGhpcyB1dGlsaXR5IGZ1bmN0aW9uIGlzIG9ubHkgdXNlZnVsXG4gKiBpZiB3YW50IHRvIGV4dHJhY3QgYSBjb2xvciBjb21wb25lbnQuIFdpdGggdGhlIGNvbG9yIHV0aWwgYHRvQ29sb3JTdHJpbmdgIHlvdVxuICogY2FuIGNvbnZlcnQgYSBSZ2JDb2xvciBvciBSZ2JhQ29sb3Igb2JqZWN0IGJhY2sgdG8gYSBzdHJpbmcuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFzc2lnbnMgYHsgcmVkOiAyNTUsIGdyZWVuOiAwLCBibHVlOiAwIH1gIHRvIGNvbG9yMVxuICogY29uc3QgY29sb3IxID0gcGFyc2VUb1JnYigncmdiKDI1NSwgMCwgMCknKTtcbiAqIC8vIEFzc2lnbnMgYHsgcmVkOiA5MiwgZ3JlZW46IDEwMiwgYmx1ZTogMTEyLCBhbHBoYTogMC43NSB9YCB0byBjb2xvcjJcbiAqIGNvbnN0IGNvbG9yMiA9IHBhcnNlVG9SZ2IoJ2hzbGEoMjEwLCAxMCUsIDQwJSwgMC43NSknKTtcbiAqL1xuZnVuY3Rpb24gcGFyc2VUb1JnYihjb2xvcikge1xuICBpZiAodHlwZW9mIGNvbG9yICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDMpO1xuICB9XG4gIHZhciBub3JtYWxpemVkQ29sb3IgPSBuYW1lVG9IZXgoY29sb3IpO1xuICBpZiAobm9ybWFsaXplZENvbG9yLm1hdGNoKGhleFJlZ2V4KSkge1xuICAgIHJldHVybiB7XG4gICAgICByZWQ6IHBhcnNlSW50KFwiXCIgKyBub3JtYWxpemVkQ29sb3JbMV0gKyBub3JtYWxpemVkQ29sb3JbMl0sIDE2KSxcbiAgICAgIGdyZWVuOiBwYXJzZUludChcIlwiICsgbm9ybWFsaXplZENvbG9yWzNdICsgbm9ybWFsaXplZENvbG9yWzRdLCAxNiksXG4gICAgICBibHVlOiBwYXJzZUludChcIlwiICsgbm9ybWFsaXplZENvbG9yWzVdICsgbm9ybWFsaXplZENvbG9yWzZdLCAxNilcbiAgICB9O1xuICB9XG4gIGlmIChub3JtYWxpemVkQ29sb3IubWF0Y2goaGV4UmdiYVJlZ2V4KSkge1xuICAgIHZhciBhbHBoYSA9IHBhcnNlRmxvYXQoKHBhcnNlSW50KFwiXCIgKyBub3JtYWxpemVkQ29sb3JbN10gKyBub3JtYWxpemVkQ29sb3JbOF0sIDE2KSAvIDI1NSkudG9GaXhlZCgyKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZDogcGFyc2VJbnQoXCJcIiArIG5vcm1hbGl6ZWRDb2xvclsxXSArIG5vcm1hbGl6ZWRDb2xvclsyXSwgMTYpLFxuICAgICAgZ3JlZW46IHBhcnNlSW50KFwiXCIgKyBub3JtYWxpemVkQ29sb3JbM10gKyBub3JtYWxpemVkQ29sb3JbNF0sIDE2KSxcbiAgICAgIGJsdWU6IHBhcnNlSW50KFwiXCIgKyBub3JtYWxpemVkQ29sb3JbNV0gKyBub3JtYWxpemVkQ29sb3JbNl0sIDE2KSxcbiAgICAgIGFscGhhOiBhbHBoYVxuICAgIH07XG4gIH1cbiAgaWYgKG5vcm1hbGl6ZWRDb2xvci5tYXRjaChyZWR1Y2VkSGV4UmVnZXgpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZDogcGFyc2VJbnQoXCJcIiArIG5vcm1hbGl6ZWRDb2xvclsxXSArIG5vcm1hbGl6ZWRDb2xvclsxXSwgMTYpLFxuICAgICAgZ3JlZW46IHBhcnNlSW50KFwiXCIgKyBub3JtYWxpemVkQ29sb3JbMl0gKyBub3JtYWxpemVkQ29sb3JbMl0sIDE2KSxcbiAgICAgIGJsdWU6IHBhcnNlSW50KFwiXCIgKyBub3JtYWxpemVkQ29sb3JbM10gKyBub3JtYWxpemVkQ29sb3JbM10sIDE2KVxuICAgIH07XG4gIH1cbiAgaWYgKG5vcm1hbGl6ZWRDb2xvci5tYXRjaChyZWR1Y2VkUmdiYUhleFJlZ2V4KSkge1xuICAgIHZhciBfYWxwaGEgPSBwYXJzZUZsb2F0KChwYXJzZUludChcIlwiICsgbm9ybWFsaXplZENvbG9yWzRdICsgbm9ybWFsaXplZENvbG9yWzRdLCAxNikgLyAyNTUpLnRvRml4ZWQoMikpO1xuICAgIHJldHVybiB7XG4gICAgICByZWQ6IHBhcnNlSW50KFwiXCIgKyBub3JtYWxpemVkQ29sb3JbMV0gKyBub3JtYWxpemVkQ29sb3JbMV0sIDE2KSxcbiAgICAgIGdyZWVuOiBwYXJzZUludChcIlwiICsgbm9ybWFsaXplZENvbG9yWzJdICsgbm9ybWFsaXplZENvbG9yWzJdLCAxNiksXG4gICAgICBibHVlOiBwYXJzZUludChcIlwiICsgbm9ybWFsaXplZENvbG9yWzNdICsgbm9ybWFsaXplZENvbG9yWzNdLCAxNiksXG4gICAgICBhbHBoYTogX2FscGhhXG4gICAgfTtcbiAgfVxuICB2YXIgcmdiTWF0Y2hlZCA9IHJnYlJlZ2V4LmV4ZWMobm9ybWFsaXplZENvbG9yKTtcbiAgaWYgKHJnYk1hdGNoZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVkOiBwYXJzZUludChcIlwiICsgcmdiTWF0Y2hlZFsxXSwgMTApLFxuICAgICAgZ3JlZW46IHBhcnNlSW50KFwiXCIgKyByZ2JNYXRjaGVkWzJdLCAxMCksXG4gICAgICBibHVlOiBwYXJzZUludChcIlwiICsgcmdiTWF0Y2hlZFszXSwgMTApXG4gICAgfTtcbiAgfVxuICB2YXIgcmdiYU1hdGNoZWQgPSByZ2JhUmVnZXguZXhlYyhub3JtYWxpemVkQ29sb3Iuc3Vic3RyaW5nKDAsIDUwKSk7XG4gIGlmIChyZ2JhTWF0Y2hlZCkge1xuICAgIHJldHVybiB7XG4gICAgICByZWQ6IHBhcnNlSW50KFwiXCIgKyByZ2JhTWF0Y2hlZFsxXSwgMTApLFxuICAgICAgZ3JlZW46IHBhcnNlSW50KFwiXCIgKyByZ2JhTWF0Y2hlZFsyXSwgMTApLFxuICAgICAgYmx1ZTogcGFyc2VJbnQoXCJcIiArIHJnYmFNYXRjaGVkWzNdLCAxMCksXG4gICAgICBhbHBoYTogcGFyc2VGbG9hdChcIlwiICsgcmdiYU1hdGNoZWRbNF0pID4gMSA/IHBhcnNlRmxvYXQoXCJcIiArIHJnYmFNYXRjaGVkWzRdKSAvIDEwMCA6IHBhcnNlRmxvYXQoXCJcIiArIHJnYmFNYXRjaGVkWzRdKVxuICAgIH07XG4gIH1cbiAgdmFyIGhzbE1hdGNoZWQgPSBoc2xSZWdleC5leGVjKG5vcm1hbGl6ZWRDb2xvcik7XG4gIGlmIChoc2xNYXRjaGVkKSB7XG4gICAgdmFyIGh1ZSA9IHBhcnNlSW50KFwiXCIgKyBoc2xNYXRjaGVkWzFdLCAxMCk7XG4gICAgdmFyIHNhdHVyYXRpb24gPSBwYXJzZUludChcIlwiICsgaHNsTWF0Y2hlZFsyXSwgMTApIC8gMTAwO1xuICAgIHZhciBsaWdodG5lc3MgPSBwYXJzZUludChcIlwiICsgaHNsTWF0Y2hlZFszXSwgMTApIC8gMTAwO1xuICAgIHZhciByZ2JDb2xvclN0cmluZyA9IFwicmdiKFwiICsgaHNsVG9SZ2IoaHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MpICsgXCIpXCI7XG4gICAgdmFyIGhzbFJnYk1hdGNoZWQgPSByZ2JSZWdleC5leGVjKHJnYkNvbG9yU3RyaW5nKTtcbiAgICBpZiAoIWhzbFJnYk1hdGNoZWQpIHtcbiAgICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDQsIG5vcm1hbGl6ZWRDb2xvciwgcmdiQ29sb3JTdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVkOiBwYXJzZUludChcIlwiICsgaHNsUmdiTWF0Y2hlZFsxXSwgMTApLFxuICAgICAgZ3JlZW46IHBhcnNlSW50KFwiXCIgKyBoc2xSZ2JNYXRjaGVkWzJdLCAxMCksXG4gICAgICBibHVlOiBwYXJzZUludChcIlwiICsgaHNsUmdiTWF0Y2hlZFszXSwgMTApXG4gICAgfTtcbiAgfVxuICB2YXIgaHNsYU1hdGNoZWQgPSBoc2xhUmVnZXguZXhlYyhub3JtYWxpemVkQ29sb3Iuc3Vic3RyaW5nKDAsIDUwKSk7XG4gIGlmIChoc2xhTWF0Y2hlZCkge1xuICAgIHZhciBfaHVlID0gcGFyc2VJbnQoXCJcIiArIGhzbGFNYXRjaGVkWzFdLCAxMCk7XG4gICAgdmFyIF9zYXR1cmF0aW9uID0gcGFyc2VJbnQoXCJcIiArIGhzbGFNYXRjaGVkWzJdLCAxMCkgLyAxMDA7XG4gICAgdmFyIF9saWdodG5lc3MgPSBwYXJzZUludChcIlwiICsgaHNsYU1hdGNoZWRbM10sIDEwKSAvIDEwMDtcbiAgICB2YXIgX3JnYkNvbG9yU3RyaW5nID0gXCJyZ2IoXCIgKyBoc2xUb1JnYihfaHVlLCBfc2F0dXJhdGlvbiwgX2xpZ2h0bmVzcykgKyBcIilcIjtcbiAgICB2YXIgX2hzbFJnYk1hdGNoZWQgPSByZ2JSZWdleC5leGVjKF9yZ2JDb2xvclN0cmluZyk7XG4gICAgaWYgKCFfaHNsUmdiTWF0Y2hlZCkge1xuICAgICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNCwgbm9ybWFsaXplZENvbG9yLCBfcmdiQ29sb3JTdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVkOiBwYXJzZUludChcIlwiICsgX2hzbFJnYk1hdGNoZWRbMV0sIDEwKSxcbiAgICAgIGdyZWVuOiBwYXJzZUludChcIlwiICsgX2hzbFJnYk1hdGNoZWRbMl0sIDEwKSxcbiAgICAgIGJsdWU6IHBhcnNlSW50KFwiXCIgKyBfaHNsUmdiTWF0Y2hlZFszXSwgMTApLFxuICAgICAgYWxwaGE6IHBhcnNlRmxvYXQoXCJcIiArIGhzbGFNYXRjaGVkWzRdKSA+IDEgPyBwYXJzZUZsb2F0KFwiXCIgKyBoc2xhTWF0Y2hlZFs0XSkgLyAxMDAgOiBwYXJzZUZsb2F0KFwiXCIgKyBoc2xhTWF0Y2hlZFs0XSlcbiAgICB9O1xuICB9XG4gIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDUpO1xufVxuXG5mdW5jdGlvbiByZ2JUb0hzbChjb2xvcikge1xuICAvLyBtYWtlIHN1cmUgcmdiIGFyZSBjb250YWluZWQgaW4gYSBzZXQgb2YgWzAsIDI1NV1cbiAgdmFyIHJlZCA9IGNvbG9yLnJlZCAvIDI1NTtcbiAgdmFyIGdyZWVuID0gY29sb3IuZ3JlZW4gLyAyNTU7XG4gIHZhciBibHVlID0gY29sb3IuYmx1ZSAvIDI1NTtcbiAgdmFyIG1heCA9IE1hdGgubWF4KHJlZCwgZ3JlZW4sIGJsdWUpO1xuICB2YXIgbWluID0gTWF0aC5taW4ocmVkLCBncmVlbiwgYmx1ZSk7XG4gIHZhciBsaWdodG5lc3MgPSAobWF4ICsgbWluKSAvIDI7XG4gIGlmIChtYXggPT09IG1pbikge1xuICAgIC8vIGFjaHJvbWF0aWNcbiAgICBpZiAoY29sb3IuYWxwaGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaHVlOiAwLFxuICAgICAgICBzYXR1cmF0aW9uOiAwLFxuICAgICAgICBsaWdodG5lc3M6IGxpZ2h0bmVzcyxcbiAgICAgICAgYWxwaGE6IGNvbG9yLmFscGhhXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBodWU6IDAsXG4gICAgICAgIHNhdHVyYXRpb246IDAsXG4gICAgICAgIGxpZ2h0bmVzczogbGlnaHRuZXNzXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICB2YXIgaHVlO1xuICB2YXIgZGVsdGEgPSBtYXggLSBtaW47XG4gIHZhciBzYXR1cmF0aW9uID0gbGlnaHRuZXNzID4gMC41ID8gZGVsdGEgLyAoMiAtIG1heCAtIG1pbikgOiBkZWx0YSAvIChtYXggKyBtaW4pO1xuICBzd2l0Y2ggKG1heCkge1xuICAgIGNhc2UgcmVkOlxuICAgICAgaHVlID0gKGdyZWVuIC0gYmx1ZSkgLyBkZWx0YSArIChncmVlbiA8IGJsdWUgPyA2IDogMCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGdyZWVuOlxuICAgICAgaHVlID0gKGJsdWUgLSByZWQpIC8gZGVsdGEgKyAyO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGJsdWUgY2FzZVxuICAgICAgaHVlID0gKHJlZCAtIGdyZWVuKSAvIGRlbHRhICsgNDtcbiAgICAgIGJyZWFrO1xuICB9XG4gIGh1ZSAqPSA2MDtcbiAgaWYgKGNvbG9yLmFscGhhICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaHVlOiBodWUsXG4gICAgICBzYXR1cmF0aW9uOiBzYXR1cmF0aW9uLFxuICAgICAgbGlnaHRuZXNzOiBsaWdodG5lc3MsXG4gICAgICBhbHBoYTogY29sb3IuYWxwaGFcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgaHVlOiBodWUsXG4gICAgc2F0dXJhdGlvbjogc2F0dXJhdGlvbixcbiAgICBsaWdodG5lc3M6IGxpZ2h0bmVzc1xuICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gSHNsQ29sb3Igb3IgSHNsYUNvbG9yIG9iamVjdC4gVGhpcyB1dGlsaXR5IGZ1bmN0aW9uIGlzIG9ubHkgdXNlZnVsXG4gKiBpZiB3YW50IHRvIGV4dHJhY3QgYSBjb2xvciBjb21wb25lbnQuIFdpdGggdGhlIGNvbG9yIHV0aWwgYHRvQ29sb3JTdHJpbmdgIHlvdVxuICogY2FuIGNvbnZlcnQgYSBIc2xDb2xvciBvciBIc2xhQ29sb3Igb2JqZWN0IGJhY2sgdG8gYSBzdHJpbmcuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFzc2lnbnMgYHsgaHVlOiAwLCBzYXR1cmF0aW9uOiAxLCBsaWdodG5lc3M6IDAuNSB9YCB0byBjb2xvcjFcbiAqIGNvbnN0IGNvbG9yMSA9IHBhcnNlVG9Ic2woJ3JnYigyNTUsIDAsIDApJyk7XG4gKiAvLyBBc3NpZ25zIGB7IGh1ZTogMTI4LCBzYXR1cmF0aW9uOiAxLCBsaWdodG5lc3M6IDAuNSwgYWxwaGE6IDAuNzUgfWAgdG8gY29sb3IyXG4gKiBjb25zdCBjb2xvcjIgPSBwYXJzZVRvSHNsKCdoc2xhKDEyOCwgMTAwJSwgNTAlLCAwLjc1KScpO1xuICovXG5mdW5jdGlvbiBwYXJzZVRvSHNsKGNvbG9yKSB7XG4gIC8vIE5vdGU6IEF0IGEgbGF0ZXIgc3RhZ2Ugd2UgY2FuIG9wdGltaXplIHRoaXMgZnVuY3Rpb24gYXMgcmlnaHQgbm93IGEgaHNsXG4gIC8vIGNvbG9yIHdvdWxkIGJlIHBhcnNlZCBjb252ZXJ0ZWQgdG8gcmdiIHZhbHVlcyBhbmQgY29udmVydGVkIGJhY2sgdG8gaHNsLlxuICByZXR1cm4gcmdiVG9Ic2wocGFyc2VUb1JnYihjb2xvcikpO1xufVxuXG4vKipcbiAqIFJlZHVjZXMgaGV4IHZhbHVlcyBpZiBwb3NzaWJsZSBlLmcuICNmZjg4NjYgdG8gI2Y4NlxuICogQHByaXZhdGVcbiAqL1xudmFyIHJlZHVjZUhleFZhbHVlID0gZnVuY3Rpb24gcmVkdWNlSGV4VmFsdWUodmFsdWUpIHtcbiAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gNyAmJiB2YWx1ZVsxXSA9PT0gdmFsdWVbMl0gJiYgdmFsdWVbM10gPT09IHZhbHVlWzRdICYmIHZhbHVlWzVdID09PSB2YWx1ZVs2XSkge1xuICAgIHJldHVybiBcIiNcIiArIHZhbHVlWzFdICsgdmFsdWVbM10gKyB2YWx1ZVs1XTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xudmFyIHJlZHVjZUhleFZhbHVlJDEgPSByZWR1Y2VIZXhWYWx1ZTtcblxuZnVuY3Rpb24gbnVtYmVyVG9IZXgodmFsdWUpIHtcbiAgdmFyIGhleCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIGhleC5sZW5ndGggPT09IDEgPyBcIjBcIiArIGhleCA6IGhleDtcbn1cblxuZnVuY3Rpb24gY29sb3JUb0hleChjb2xvcikge1xuICByZXR1cm4gbnVtYmVyVG9IZXgoTWF0aC5yb3VuZChjb2xvciAqIDI1NSkpO1xufVxuZnVuY3Rpb24gY29udmVydFRvSGV4KHJlZCwgZ3JlZW4sIGJsdWUpIHtcbiAgcmV0dXJuIHJlZHVjZUhleFZhbHVlJDEoXCIjXCIgKyBjb2xvclRvSGV4KHJlZCkgKyBjb2xvclRvSGV4KGdyZWVuKSArIGNvbG9yVG9IZXgoYmx1ZSkpO1xufVxuZnVuY3Rpb24gaHNsVG9IZXgoaHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MpIHtcbiAgcmV0dXJuIGhzbFRvUmdiKGh1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzLCBjb252ZXJ0VG9IZXgpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgdmFsdWUgZm9yIHRoZSBjb2xvci4gVGhlIHJldHVybmVkIHJlc3VsdCBpcyB0aGUgc21hbGxlc3QgcG9zc2libGUgaGV4IG5vdGF0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IGhzbCgzNTksIDAuNzUsIDAuNCksXG4gKiAgIGJhY2tncm91bmQ6IGhzbCh7IGh1ZTogMzYwLCBzYXR1cmF0aW9uOiAwLjc1LCBsaWdodG5lc3M6IDAuNCB9KSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtoc2woMzU5LCAwLjc1LCAwLjQpfTtcbiAqICAgYmFja2dyb3VuZDogJHtoc2woeyBodWU6IDM2MCwgc2F0dXJhdGlvbjogMC43NSwgbGlnaHRuZXNzOiAwLjQgfSl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjYjMxOTFjXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2IzMTkxY1wiO1xuICogfVxuICovXG5mdW5jdGlvbiBoc2wodmFsdWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcykge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygc2F0dXJhdGlvbiA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGxpZ2h0bmVzcyA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gaHNsVG9IZXgodmFsdWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBzYXR1cmF0aW9uID09PSB1bmRlZmluZWQgJiYgbGlnaHRuZXNzID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gaHNsVG9IZXgodmFsdWUuaHVlLCB2YWx1ZS5zYXR1cmF0aW9uLCB2YWx1ZS5saWdodG5lc3MpO1xuICB9XG4gIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDEpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgdmFsdWUgZm9yIHRoZSBjb2xvci4gVGhlIHJldHVybmVkIHJlc3VsdCBpcyB0aGUgc21hbGxlc3QgcG9zc2libGUgcmdiYSBvciBoZXggbm90YXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogaHNsYSgzNTksIDAuNzUsIDAuNCwgMC43KSxcbiAqICAgYmFja2dyb3VuZDogaHNsYSh7IGh1ZTogMzYwLCBzYXR1cmF0aW9uOiAwLjc1LCBsaWdodG5lc3M6IDAuNCwgYWxwaGE6IDAsNyB9KSxcbiAqICAgYmFja2dyb3VuZDogaHNsYSgzNTksIDAuNzUsIDAuNCwgMSksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7aHNsYSgzNTksIDAuNzUsIDAuNCwgMC43KX07XG4gKiAgIGJhY2tncm91bmQ6ICR7aHNsYSh7IGh1ZTogMzYwLCBzYXR1cmF0aW9uOiAwLjc1LCBsaWdodG5lc3M6IDAuNCwgYWxwaGE6IDAsNyB9KX07XG4gKiAgIGJhY2tncm91bmQ6ICR7aHNsYSgzNTksIDAuNzUsIDAuNCwgMSl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDE3OSwyNSwyOCwwLjcpXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgxNzksMjUsMjgsMC43KVwiO1xuICogICBiYWNrZ3JvdW5kOiBcIiNiMzE5MWNcIjtcbiAqIH1cbiAqL1xuZnVuY3Rpb24gaHNsYSh2YWx1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzLCBhbHBoYSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygc2F0dXJhdGlvbiA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGxpZ2h0bmVzcyA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGFscGhhID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBhbHBoYSA+PSAxID8gaHNsVG9IZXgodmFsdWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcykgOiBcInJnYmEoXCIgKyBoc2xUb1JnYih2YWx1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzKSArIFwiLFwiICsgYWxwaGEgKyBcIilcIjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHNhdHVyYXRpb24gPT09IHVuZGVmaW5lZCAmJiBsaWdodG5lc3MgPT09IHVuZGVmaW5lZCAmJiBhbHBoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHZhbHVlLmFscGhhID49IDEgPyBoc2xUb0hleCh2YWx1ZS5odWUsIHZhbHVlLnNhdHVyYXRpb24sIHZhbHVlLmxpZ2h0bmVzcykgOiBcInJnYmEoXCIgKyBoc2xUb1JnYih2YWx1ZS5odWUsIHZhbHVlLnNhdHVyYXRpb24sIHZhbHVlLmxpZ2h0bmVzcykgKyBcIixcIiArIHZhbHVlLmFscGhhICsgXCIpXCI7XG4gIH1cbiAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoMik7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyB2YWx1ZSBmb3IgdGhlIGNvbG9yLiBUaGUgcmV0dXJuZWQgcmVzdWx0IGlzIHRoZSBzbWFsbGVzdCBwb3NzaWJsZSBoZXggbm90YXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogcmdiKDI1NSwgMjA1LCAxMDApLFxuICogICBiYWNrZ3JvdW5kOiByZ2IoeyByZWQ6IDI1NSwgZ3JlZW46IDIwNSwgYmx1ZTogMTAwIH0pLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke3JnYigyNTUsIDIwNSwgMTAwKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7cmdiKHsgcmVkOiAyNTUsIGdyZWVuOiAyMDUsIGJsdWU6IDEwMCB9KX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiNmZmNkNjRcIjtcbiAqICAgYmFja2dyb3VuZDogXCIjZmZjZDY0XCI7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHJnYih2YWx1ZSwgZ3JlZW4sIGJsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGdyZWVuID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYmx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gcmVkdWNlSGV4VmFsdWUkMShcIiNcIiArIG51bWJlclRvSGV4KHZhbHVlKSArIG51bWJlclRvSGV4KGdyZWVuKSArIG51bWJlclRvSGV4KGJsdWUpKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIGdyZWVuID09PSB1bmRlZmluZWQgJiYgYmx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlZHVjZUhleFZhbHVlJDEoXCIjXCIgKyBudW1iZXJUb0hleCh2YWx1ZS5yZWQpICsgbnVtYmVyVG9IZXgodmFsdWUuZ3JlZW4pICsgbnVtYmVyVG9IZXgodmFsdWUuYmx1ZSkpO1xuICB9XG4gIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDYpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgdmFsdWUgZm9yIHRoZSBjb2xvci4gVGhlIHJldHVybmVkIHJlc3VsdCBpcyB0aGUgc21hbGxlc3QgcG9zc2libGUgcmdiYSBvciBoZXggbm90YXRpb24uXG4gKlxuICogQ2FuIGFsc28gYmUgdXNlZCB0byBmYWRlIGEgY29sb3IgYnkgcGFzc2luZyBhIGhleCB2YWx1ZSBvciBuYW1lZCBDU1MgY29sb3IgYWxvbmcgd2l0aCBhbiBhbHBoYSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjA1LCAxMDAsIDAuNyksXG4gKiAgIGJhY2tncm91bmQ6IHJnYmEoeyByZWQ6IDI1NSwgZ3JlZW46IDIwNSwgYmx1ZTogMTAwLCBhbHBoYTogMC43IH0pLFxuICogICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjA1LCAxMDAsIDEpLFxuICogICBiYWNrZ3JvdW5kOiByZ2JhKCcjZmZmZmZmJywgMC40KSxcbiAqICAgYmFja2dyb3VuZDogcmdiYSgnYmxhY2snLCAwLjcpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke3JnYmEoMjU1LCAyMDUsIDEwMCwgMC43KX07XG4gKiAgIGJhY2tncm91bmQ6ICR7cmdiYSh7IHJlZDogMjU1LCBncmVlbjogMjA1LCBibHVlOiAxMDAsIGFscGhhOiAwLjcgfSl9O1xuICogICBiYWNrZ3JvdW5kOiAke3JnYmEoMjU1LCAyMDUsIDEwMCwgMSl9O1xuICogICBiYWNrZ3JvdW5kOiAke3JnYmEoJyNmZmZmZmYnLCAwLjQpfTtcbiAqICAgYmFja2dyb3VuZDogJHtyZ2JhKCdibGFjaycsIDAuNyl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDI1NSwyMDUsMTAwLDAuNylcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDI1NSwyMDUsMTAwLDAuNylcIjtcbiAqICAgYmFja2dyb3VuZDogXCIjZmZjZDY0XCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyNTUsMjU1LDI1NSwwLjQpXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgwLDAsMCwwLjcpXCI7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHJnYmEoZmlyc3RWYWx1ZSwgc2Vjb25kVmFsdWUsIHRoaXJkVmFsdWUsIGZvdXJ0aFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgZmlyc3RWYWx1ZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHNlY29uZFZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHZhciByZ2JWYWx1ZSA9IHBhcnNlVG9SZ2IoZmlyc3RWYWx1ZSk7XG4gICAgcmV0dXJuIFwicmdiYShcIiArIHJnYlZhbHVlLnJlZCArIFwiLFwiICsgcmdiVmFsdWUuZ3JlZW4gKyBcIixcIiArIHJnYlZhbHVlLmJsdWUgKyBcIixcIiArIHNlY29uZFZhbHVlICsgXCIpXCI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGZpcnN0VmFsdWUgPT09ICdudW1iZXInICYmIHR5cGVvZiBzZWNvbmRWYWx1ZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHRoaXJkVmFsdWUgPT09ICdudW1iZXInICYmIHR5cGVvZiBmb3VydGhWYWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gZm91cnRoVmFsdWUgPj0gMSA/IHJnYihmaXJzdFZhbHVlLCBzZWNvbmRWYWx1ZSwgdGhpcmRWYWx1ZSkgOiBcInJnYmEoXCIgKyBmaXJzdFZhbHVlICsgXCIsXCIgKyBzZWNvbmRWYWx1ZSArIFwiLFwiICsgdGhpcmRWYWx1ZSArIFwiLFwiICsgZm91cnRoVmFsdWUgKyBcIilcIjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZmlyc3RWYWx1ZSA9PT0gJ29iamVjdCcgJiYgc2Vjb25kVmFsdWUgPT09IHVuZGVmaW5lZCAmJiB0aGlyZFZhbHVlID09PSB1bmRlZmluZWQgJiYgZm91cnRoVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmaXJzdFZhbHVlLmFscGhhID49IDEgPyByZ2IoZmlyc3RWYWx1ZS5yZWQsIGZpcnN0VmFsdWUuZ3JlZW4sIGZpcnN0VmFsdWUuYmx1ZSkgOiBcInJnYmEoXCIgKyBmaXJzdFZhbHVlLnJlZCArIFwiLFwiICsgZmlyc3RWYWx1ZS5ncmVlbiArIFwiLFwiICsgZmlyc3RWYWx1ZS5ibHVlICsgXCIsXCIgKyBmaXJzdFZhbHVlLmFscGhhICsgXCIpXCI7XG4gIH1cbiAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNyk7XG59XG5cbnZhciBpc1JnYiA9IGZ1bmN0aW9uIGlzUmdiKGNvbG9yKSB7XG4gIHJldHVybiB0eXBlb2YgY29sb3IucmVkID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29sb3IuZ3JlZW4gPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5ibHVlID09PSAnbnVtYmVyJyAmJiAodHlwZW9mIGNvbG9yLmFscGhhICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgY29sb3IuYWxwaGEgPT09ICd1bmRlZmluZWQnKTtcbn07XG52YXIgaXNSZ2JhID0gZnVuY3Rpb24gaXNSZ2JhKGNvbG9yKSB7XG4gIHJldHVybiB0eXBlb2YgY29sb3IucmVkID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29sb3IuZ3JlZW4gPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5ibHVlID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29sb3IuYWxwaGEgPT09ICdudW1iZXInO1xufTtcbnZhciBpc0hzbCA9IGZ1bmN0aW9uIGlzSHNsKGNvbG9yKSB7XG4gIHJldHVybiB0eXBlb2YgY29sb3IuaHVlID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29sb3Iuc2F0dXJhdGlvbiA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbG9yLmxpZ2h0bmVzcyA9PT0gJ251bWJlcicgJiYgKHR5cGVvZiBjb2xvci5hbHBoYSAhPT0gJ251bWJlcicgfHwgdHlwZW9mIGNvbG9yLmFscGhhID09PSAndW5kZWZpbmVkJyk7XG59O1xudmFyIGlzSHNsYSA9IGZ1bmN0aW9uIGlzSHNsYShjb2xvcikge1xuICByZXR1cm4gdHlwZW9mIGNvbG9yLmh1ZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbG9yLnNhdHVyYXRpb24gPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5saWdodG5lc3MgPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5hbHBoYSA9PT0gJ251bWJlcic7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgUmdiQ29sb3IsIFJnYmFDb2xvciwgSHNsQ29sb3Igb3IgSHNsYUNvbG9yIG9iamVjdCB0byBhIGNvbG9yIHN0cmluZy5cbiAqIFRoaXMgdXRpbCBpcyB1c2VmdWwgaW4gY2FzZSB5b3Ugb25seSBrbm93IG9uIHJ1bnRpbWUgd2hpY2ggY29sb3Igb2JqZWN0IGlzXG4gKiB1c2VkLiBPdGhlcndpc2Ugd2UgcmVjb21tZW5kIHRvIHJlbHkgb24gYHJnYmAsIGByZ2JhYCwgYGhzbGAgb3IgYGhzbGFgLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IHRvQ29sb3JTdHJpbmcoeyByZWQ6IDI1NSwgZ3JlZW46IDIwNSwgYmx1ZTogMTAwIH0pLFxuICogICBiYWNrZ3JvdW5kOiB0b0NvbG9yU3RyaW5nKHsgcmVkOiAyNTUsIGdyZWVuOiAyMDUsIGJsdWU6IDEwMCwgYWxwaGE6IDAuNzIgfSksXG4gKiAgIGJhY2tncm91bmQ6IHRvQ29sb3JTdHJpbmcoeyBodWU6IDI0MCwgc2F0dXJhdGlvbjogMSwgbGlnaHRuZXNzOiAwLjUgfSksXG4gKiAgIGJhY2tncm91bmQ6IHRvQ29sb3JTdHJpbmcoeyBodWU6IDM2MCwgc2F0dXJhdGlvbjogMC43NSwgbGlnaHRuZXNzOiAwLjQsIGFscGhhOiAwLjcyIH0pLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke3RvQ29sb3JTdHJpbmcoeyByZWQ6IDI1NSwgZ3JlZW46IDIwNSwgYmx1ZTogMTAwIH0pfTtcbiAqICAgYmFja2dyb3VuZDogJHt0b0NvbG9yU3RyaW5nKHsgcmVkOiAyNTUsIGdyZWVuOiAyMDUsIGJsdWU6IDEwMCwgYWxwaGE6IDAuNzIgfSl9O1xuICogICBiYWNrZ3JvdW5kOiAke3RvQ29sb3JTdHJpbmcoeyBodWU6IDI0MCwgc2F0dXJhdGlvbjogMSwgbGlnaHRuZXNzOiAwLjUgfSl9O1xuICogICBiYWNrZ3JvdW5kOiAke3RvQ29sb3JTdHJpbmcoeyBodWU6IDM2MCwgc2F0dXJhdGlvbjogMC43NSwgbGlnaHRuZXNzOiAwLjQsIGFscGhhOiAwLjcyIH0pfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjZmZjZDY0XCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyNTUsMjA1LDEwMCwwLjcyKVwiO1xuICogICBiYWNrZ3JvdW5kOiBcIiMwMGZcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDE3OSwyNSwyNSwwLjcyKVwiO1xuICogfVxuICovXG5cbmZ1bmN0aW9uIHRvQ29sb3JTdHJpbmcoY29sb3IpIHtcbiAgaWYgKHR5cGVvZiBjb2xvciAhPT0gJ29iamVjdCcpIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDgpO1xuICBpZiAoaXNSZ2JhKGNvbG9yKSkgcmV0dXJuIHJnYmEoY29sb3IpO1xuICBpZiAoaXNSZ2IoY29sb3IpKSByZXR1cm4gcmdiKGNvbG9yKTtcbiAgaWYgKGlzSHNsYShjb2xvcikpIHJldHVybiBoc2xhKGNvbG9yKTtcbiAgaWYgKGlzSHNsKGNvbG9yKSkgcmV0dXJuIGhzbChjb2xvcik7XG4gIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDgpO1xufVxuXG4vLyBUeXBlIGRlZmluaXRpb25zIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2djYW50aS9mbG93LXN0YXRpYy1sYW5kL2Jsb2IvbWFzdGVyL3NyYy9GdW4uanNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5mdW5jdGlvbiBjdXJyaWVkKGYsIGxlbmd0aCwgYWNjKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmbigpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgdmFyIGNvbWJpbmVkID0gYWNjLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICByZXR1cm4gY29tYmluZWQubGVuZ3RoID49IGxlbmd0aCA/IGYuYXBwbHkodGhpcywgY29tYmluZWQpIDogY3VycmllZChmLCBsZW5ndGgsIGNvbWJpbmVkKTtcbiAgfTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuZnVuY3Rpb24gY3VycnkoZikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlZGVjbGFyZVxuICByZXR1cm4gY3VycmllZChmLCBmLmxlbmd0aCwgW10pO1xufVxuXG4vKipcbiAqIENoYW5nZXMgdGhlIGh1ZSBvZiB0aGUgY29sb3IuIEh1ZSBpcyBhIG51bWJlciBiZXR3ZWVuIDAgdG8gMzYwLiBUaGUgZmlyc3RcbiAqIGFyZ3VtZW50IGZvciBhZGp1c3RIdWUgaXMgdGhlIGFtb3VudCBvZiBkZWdyZWVzIHRoZSBjb2xvciBpcyByb3RhdGVkIGFyb3VuZFxuICogdGhlIGNvbG9yIHdoZWVsLCBhbHdheXMgcHJvZHVjaW5nIGEgcG9zaXRpdmUgaHVlIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IGFkanVzdEh1ZSgxODAsICcjNDQ4JyksXG4gKiAgIGJhY2tncm91bmQ6IGFkanVzdEh1ZSgnMTgwJywgJ3JnYmEoMTAxLDEwMCwyMDUsMC43KScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke2FkanVzdEh1ZSgxODAsICcjNDQ4Jyl9O1xuICogICBiYWNrZ3JvdW5kOiAke2FkanVzdEh1ZSgnMTgwJywgJ3JnYmEoMTAxLDEwMCwyMDUsMC43KScpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjODg4ODQ0XCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgxMzYsMTM2LDY4LDAuNylcIjtcbiAqIH1cbiAqL1xuZnVuY3Rpb24gYWRqdXN0SHVlKGRlZ3JlZSwgY29sb3IpIHtcbiAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSByZXR1cm4gY29sb3I7XG4gIHZhciBoc2xDb2xvciA9IHBhcnNlVG9Ic2woY29sb3IpO1xuICByZXR1cm4gdG9Db2xvclN0cmluZyhfZXh0ZW5kcyh7fSwgaHNsQ29sb3IsIHtcbiAgICBodWU6IGhzbENvbG9yLmh1ZSArIHBhcnNlRmxvYXQoZGVncmVlKVxuICB9KSk7XG59XG5cbi8vIHByZXR0aWVyLWlnbm9yZVxudmFyIGN1cnJpZWRBZGp1c3RIdWUgPSBjdXJyeSAvKiA6OjxudW1iZXIgfCBzdHJpbmcsIHN0cmluZywgc3RyaW5nPiAqLyhhZGp1c3RIdWUpO1xudmFyIGN1cnJpZWRBZGp1c3RIdWUkMSA9IGN1cnJpZWRBZGp1c3RIdWU7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29tcGxlbWVudCBvZiB0aGUgcHJvdmlkZWQgY29sb3IuIFRoaXMgaXMgaWRlbnRpY2FsIHRvIGFkanVzdEh1ZSgxODAsIDxjb2xvcj4pLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IGNvbXBsZW1lbnQoJyM0NDgnKSxcbiAqICAgYmFja2dyb3VuZDogY29tcGxlbWVudCgncmdiYSgyMDQsMjA1LDEwMCwwLjcpJyksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7Y29tcGxlbWVudCgnIzQ0OCcpfTtcbiAqICAgYmFja2dyb3VuZDogJHtjb21wbGVtZW50KCdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiIzg4NFwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMTUzLDE1MywxNTMsMC43KVwiO1xuICogfVxuICovXG5mdW5jdGlvbiBjb21wbGVtZW50KGNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIGNvbG9yO1xuICB2YXIgaHNsQ29sb3IgPSBwYXJzZVRvSHNsKGNvbG9yKTtcbiAgcmV0dXJuIHRvQ29sb3JTdHJpbmcoX2V4dGVuZHMoe30sIGhzbENvbG9yLCB7XG4gICAgaHVlOiAoaHNsQ29sb3IuaHVlICsgMTgwKSAlIDM2MFxuICB9KSk7XG59XG5cbmZ1bmN0aW9uIGd1YXJkKGxvd2VyQm91bmRhcnksIHVwcGVyQm91bmRhcnksIHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLm1heChsb3dlckJvdW5kYXJ5LCBNYXRoLm1pbih1cHBlckJvdW5kYXJ5LCB2YWx1ZSkpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgdmFsdWUgZm9yIHRoZSBkYXJrZW5lZCBjb2xvci5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBkYXJrZW4oMC4yLCAnI0ZGQ0Q2NCcpLFxuICogICBiYWNrZ3JvdW5kOiBkYXJrZW4oJzAuMicsICdyZ2JhKDI1NSwyMDUsMTAwLDAuNyknKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtkYXJrZW4oMC4yLCAnI0ZGQ0Q2NCcpfTtcbiAqICAgYmFja2dyb3VuZDogJHtkYXJrZW4oJzAuMicsICdyZ2JhKDI1NSwyMDUsMTAwLDAuNyknKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiNmZmJkMzFcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDI1NSwxODksNDksMC43KVwiO1xuICogfVxuICovXG5mdW5jdGlvbiBkYXJrZW4oYW1vdW50LCBjb2xvcikge1xuICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHJldHVybiBjb2xvcjtcbiAgdmFyIGhzbENvbG9yID0gcGFyc2VUb0hzbChjb2xvcik7XG4gIHJldHVybiB0b0NvbG9yU3RyaW5nKF9leHRlbmRzKHt9LCBoc2xDb2xvciwge1xuICAgIGxpZ2h0bmVzczogZ3VhcmQoMCwgMSwgaHNsQ29sb3IubGlnaHRuZXNzIC0gcGFyc2VGbG9hdChhbW91bnQpKVxuICB9KSk7XG59XG5cbi8vIHByZXR0aWVyLWlnbm9yZVxudmFyIGN1cnJpZWREYXJrZW4gPSBjdXJyeSAvKiA6OjxudW1iZXIgfCBzdHJpbmcsIHN0cmluZywgc3RyaW5nPiAqLyhkYXJrZW4pO1xudmFyIGN1cnJpZWREYXJrZW4kMSA9IGN1cnJpZWREYXJrZW47XG5cbi8qKlxuICogRGVjcmVhc2VzIHRoZSBpbnRlbnNpdHkgb2YgYSBjb2xvci4gSXRzIHJhbmdlIGlzIGJldHdlZW4gMCB0byAxLiBUaGUgZmlyc3RcbiAqIGFyZ3VtZW50IG9mIHRoZSBkZXNhdHVyYXRlIGZ1bmN0aW9uIGlzIHRoZSBhbW91bnQgYnkgaG93IG11Y2ggdGhlIGNvbG9yXG4gKiBpbnRlbnNpdHkgc2hvdWxkIGJlIGRlY3JlYXNlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBkZXNhdHVyYXRlKDAuMiwgJyNDQ0NENjQnKSxcbiAqICAgYmFja2dyb3VuZDogZGVzYXR1cmF0ZSgnMC4yJywgJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke2Rlc2F0dXJhdGUoMC4yLCAnI0NDQ0Q2NCcpfTtcbiAqICAgYmFja2dyb3VuZDogJHtkZXNhdHVyYXRlKCcwLjInLCAncmdiYSgyMDQsMjA1LDEwMCwwLjcpJyl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiNiOGI5NzlcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDE4NCwxODUsMTIxLDAuNylcIjtcbiAqIH1cbiAqL1xuZnVuY3Rpb24gZGVzYXR1cmF0ZShhbW91bnQsIGNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIGNvbG9yO1xuICB2YXIgaHNsQ29sb3IgPSBwYXJzZVRvSHNsKGNvbG9yKTtcbiAgcmV0dXJuIHRvQ29sb3JTdHJpbmcoX2V4dGVuZHMoe30sIGhzbENvbG9yLCB7XG4gICAgc2F0dXJhdGlvbjogZ3VhcmQoMCwgMSwgaHNsQ29sb3Iuc2F0dXJhdGlvbiAtIHBhcnNlRmxvYXQoYW1vdW50KSlcbiAgfSkpO1xufVxuXG4vLyBwcmV0dGllci1pZ25vcmVcbnZhciBjdXJyaWVkRGVzYXR1cmF0ZSA9IGN1cnJ5IC8qIDo6PG51bWJlciB8IHN0cmluZywgc3RyaW5nLCBzdHJpbmc+ICovKGRlc2F0dXJhdGUpO1xudmFyIGN1cnJpZWREZXNhdHVyYXRlJDEgPSBjdXJyaWVkRGVzYXR1cmF0ZTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbnVtYmVyIChmbG9hdCkgcmVwcmVzZW50aW5nIHRoZSBsdW1pbmFuY2Ugb2YgYSBjb2xvci5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBnZXRMdW1pbmFuY2UoJyNDQ0NENjQnKSA+PSBnZXRMdW1pbmFuY2UoJyMwMDAwZmYnKSA/ICcjQ0NDRDY0JyA6ICcjMDAwMGZmJyxcbiAqICAgYmFja2dyb3VuZDogZ2V0THVtaW5hbmNlKCdyZ2JhKDU4LCAxMzMsIDI1NSwgMSknKSA+PSBnZXRMdW1pbmFuY2UoJ3JnYmEoMjU1LCA1NywgMTQ5LCAxKScpID9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmdiYSg1OCwgMTMzLCAyNTUsIDEpJyA6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JnYmEoMjU1LCA1NywgMTQ5LCAxKScsXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7Z2V0THVtaW5hbmNlKCcjQ0NDRDY0JykgPj0gZ2V0THVtaW5hbmNlKCcjMDAwMGZmJykgPyAnI0NDQ0Q2NCcgOiAnIzAwMDBmZid9O1xuICogICBiYWNrZ3JvdW5kOiAke2dldEx1bWluYW5jZSgncmdiYSg1OCwgMTMzLCAyNTUsIDEpJykgPj0gZ2V0THVtaW5hbmNlKCdyZ2JhKDI1NSwgNTcsIDE0OSwgMSknKSA/XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JnYmEoNTgsIDEzMywgMjU1LCAxKScgOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyZ2JhKDI1NSwgNTcsIDE0OSwgMSknfTtcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgYmFja2dyb3VuZDogXCIjQ0NDRDY0XCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSg1OCwgMTMzLCAyNTUsIDEpXCI7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGdldEx1bWluYW5jZShjb2xvcikge1xuICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHJldHVybiAwO1xuICB2YXIgcmdiQ29sb3IgPSBwYXJzZVRvUmdiKGNvbG9yKTtcbiAgdmFyIF9PYmplY3Qka2V5cyRtYXAgPSBPYmplY3Qua2V5cyhyZ2JDb2xvcikubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBjaGFubmVsID0gcmdiQ29sb3Jba2V5XSAvIDI1NTtcbiAgICAgIHJldHVybiBjaGFubmVsIDw9IDAuMDM5MjggPyBjaGFubmVsIC8gMTIuOTIgOiBNYXRoLnBvdygoY2hhbm5lbCArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xuICAgIH0pLFxuICAgIHIgPSBfT2JqZWN0JGtleXMkbWFwWzBdLFxuICAgIGcgPSBfT2JqZWN0JGtleXMkbWFwWzFdLFxuICAgIGIgPSBfT2JqZWN0JGtleXMkbWFwWzJdO1xuICByZXR1cm4gcGFyc2VGbG9hdCgoMC4yMTI2ICogciArIDAuNzE1MiAqIGcgKyAwLjA3MjIgKiBiKS50b0ZpeGVkKDMpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb250cmFzdCByYXRpbyBiZXR3ZWVuIHR3byBjb2xvcnMgYmFzZWQgb25cbiAqIFtXMydzIHJlY29tbWVuZGVkIGVxdWF0aW9uIGZvciBjYWxjdWxhdGluZyBjb250cmFzdF0oaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLyNjb250cmFzdC1yYXRpb2RlZikuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGNvbnRyYXN0UmF0aW8gPSBnZXRDb250cmFzdCgnIzQ0NCcsICcjZmZmJyk7XG4gKi9cbmZ1bmN0aW9uIGdldENvbnRyYXN0KGNvbG9yMSwgY29sb3IyKSB7XG4gIHZhciBsdW1pbmFuY2UxID0gZ2V0THVtaW5hbmNlKGNvbG9yMSk7XG4gIHZhciBsdW1pbmFuY2UyID0gZ2V0THVtaW5hbmNlKGNvbG9yMik7XG4gIHJldHVybiBwYXJzZUZsb2F0KChsdW1pbmFuY2UxID4gbHVtaW5hbmNlMiA/IChsdW1pbmFuY2UxICsgMC4wNSkgLyAobHVtaW5hbmNlMiArIDAuMDUpIDogKGx1bWluYW5jZTIgKyAwLjA1KSAvIChsdW1pbmFuY2UxICsgMC4wNSkpLnRvRml4ZWQoMikpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBjb2xvciB0byBhIGdyYXlzY2FsZSwgYnkgcmVkdWNpbmcgaXRzIHNhdHVyYXRpb24gdG8gMC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBncmF5c2NhbGUoJyNDQ0NENjQnKSxcbiAqICAgYmFja2dyb3VuZDogZ3JheXNjYWxlKCdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtncmF5c2NhbGUoJyNDQ0NENjQnKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7Z3JheXNjYWxlKCdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiIzk5OVwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMTUzLDE1MywxNTMsMC43KVwiO1xuICogfVxuICovXG5mdW5jdGlvbiBncmF5c2NhbGUoY29sb3IpIHtcbiAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSByZXR1cm4gY29sb3I7XG4gIHJldHVybiB0b0NvbG9yU3RyaW5nKF9leHRlbmRzKHt9LCBwYXJzZVRvSHNsKGNvbG9yKSwge1xuICAgIHNhdHVyYXRpb246IDBcbiAgfSkpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgSHNsQ29sb3Igb3IgSHNsYUNvbG9yIG9iamVjdCB0byBhIGNvbG9yIHN0cmluZy5cbiAqIFRoaXMgdXRpbCBpcyB1c2VmdWwgaW4gY2FzZSB5b3Ugb25seSBrbm93IG9uIHJ1bnRpbWUgd2hpY2ggY29sb3Igb2JqZWN0IGlzXG4gKiB1c2VkLiBPdGhlcndpc2Ugd2UgcmVjb21tZW5kIHRvIHJlbHkgb24gYGhzbGAgb3IgYGhzbGFgLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IGhzbFRvQ29sb3JTdHJpbmcoeyBodWU6IDI0MCwgc2F0dXJhdGlvbjogMSwgbGlnaHRuZXNzOiAwLjUgfSksXG4gKiAgIGJhY2tncm91bmQ6IGhzbFRvQ29sb3JTdHJpbmcoeyBodWU6IDM2MCwgc2F0dXJhdGlvbjogMC43NSwgbGlnaHRuZXNzOiAwLjQsIGFscGhhOiAwLjcyIH0pLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke2hzbFRvQ29sb3JTdHJpbmcoeyBodWU6IDI0MCwgc2F0dXJhdGlvbjogMSwgbGlnaHRuZXNzOiAwLjUgfSl9O1xuICogICBiYWNrZ3JvdW5kOiAke2hzbFRvQ29sb3JTdHJpbmcoeyBodWU6IDM2MCwgc2F0dXJhdGlvbjogMC43NSwgbGlnaHRuZXNzOiAwLjQsIGFscGhhOiAwLjcyIH0pfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjMDBmXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgxNzksMjUsMjUsMC43MilcIjtcbiAqIH1cbiAqL1xuZnVuY3Rpb24gaHNsVG9Db2xvclN0cmluZyhjb2xvcikge1xuICBpZiAodHlwZW9mIGNvbG9yID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgY29sb3IuaHVlID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29sb3Iuc2F0dXJhdGlvbiA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbG9yLmxpZ2h0bmVzcyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoY29sb3IuYWxwaGEgJiYgdHlwZW9mIGNvbG9yLmFscGhhID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIGhzbGEoe1xuICAgICAgICBodWU6IGNvbG9yLmh1ZSxcbiAgICAgICAgc2F0dXJhdGlvbjogY29sb3Iuc2F0dXJhdGlvbixcbiAgICAgICAgbGlnaHRuZXNzOiBjb2xvci5saWdodG5lc3MsXG4gICAgICAgIGFscGhhOiBjb2xvci5hbHBoYVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBoc2woe1xuICAgICAgaHVlOiBjb2xvci5odWUsXG4gICAgICBzYXR1cmF0aW9uOiBjb2xvci5zYXR1cmF0aW9uLFxuICAgICAgbGlnaHRuZXNzOiBjb2xvci5saWdodG5lc3NcbiAgICB9KTtcbiAgfVxuICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig0NSk7XG59XG5cbi8qKlxuICogSW52ZXJ0cyB0aGUgcmVkLCBncmVlbiBhbmQgYmx1ZSB2YWx1ZXMgb2YgYSBjb2xvci5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBpbnZlcnQoJyNDQ0NENjQnKSxcbiAqICAgYmFja2dyb3VuZDogaW52ZXJ0KCdyZ2JhKDEwMSwxMDAsMjA1LDAuNyknKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtpbnZlcnQoJyNDQ0NENjQnKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7aW52ZXJ0KCdyZ2JhKDEwMSwxMDAsMjA1LDAuNyknKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiMzMzMyOWJcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDE1NCwxNTUsNTAsMC43KVwiO1xuICogfVxuICovXG5mdW5jdGlvbiBpbnZlcnQoY29sb3IpIHtcbiAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSByZXR1cm4gY29sb3I7XG4gIC8vIHBhcnNlIGNvbG9yIHN0cmluZyB0byByZ2JcbiAgdmFyIHZhbHVlID0gcGFyc2VUb1JnYihjb2xvcik7XG4gIHJldHVybiB0b0NvbG9yU3RyaW5nKF9leHRlbmRzKHt9LCB2YWx1ZSwge1xuICAgIHJlZDogMjU1IC0gdmFsdWUucmVkLFxuICAgIGdyZWVuOiAyNTUgLSB2YWx1ZS5ncmVlbixcbiAgICBibHVlOiAyNTUgLSB2YWx1ZS5ibHVlXG4gIH0pKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHZhbHVlIGZvciB0aGUgbGlnaHRlbmVkIGNvbG9yLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IGxpZ2h0ZW4oMC4yLCAnI0NDQ0Q2NCcpLFxuICogICBiYWNrZ3JvdW5kOiBsaWdodGVuKCcwLjInLCAncmdiYSgyMDQsMjA1LDEwMCwwLjcpJyksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7bGlnaHRlbigwLjIsICcjRkZDRDY0Jyl9O1xuICogICBiYWNrZ3JvdW5kOiAke2xpZ2h0ZW4oJzAuMicsICdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiNlNWU2YjFcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDIyOSwyMzAsMTc3LDAuNylcIjtcbiAqIH1cbiAqL1xuZnVuY3Rpb24gbGlnaHRlbihhbW91bnQsIGNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIGNvbG9yO1xuICB2YXIgaHNsQ29sb3IgPSBwYXJzZVRvSHNsKGNvbG9yKTtcbiAgcmV0dXJuIHRvQ29sb3JTdHJpbmcoX2V4dGVuZHMoe30sIGhzbENvbG9yLCB7XG4gICAgbGlnaHRuZXNzOiBndWFyZCgwLCAxLCBoc2xDb2xvci5saWdodG5lc3MgKyBwYXJzZUZsb2F0KGFtb3VudCkpXG4gIH0pKTtcbn1cblxuLy8gcHJldHRpZXItaWdub3JlXG52YXIgY3VycmllZExpZ2h0ZW4gPSBjdXJyeSAvKiA6OjxudW1iZXIgfCBzdHJpbmcsIHN0cmluZywgc3RyaW5nPiAqLyhsaWdodGVuKTtcbnZhciBjdXJyaWVkTGlnaHRlbiQxID0gY3VycmllZExpZ2h0ZW47XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGljaCBjb250cmFzdCBndWlkZWxpbmVzIGhhdmUgYmVlbiBtZXQgZm9yIHR3byBjb2xvcnMuXG4gKiBCYXNlZCBvbiB0aGUgW2NvbnRyYXN0IGNhbGN1bGF0aW9ucyByZWNvbW1lbmRlZCBieSBXM10oaHR0cHM6Ly93d3cudzMub3JnL1dBSS9XQ0FHMjEvVW5kZXJzdGFuZGluZy9jb250cmFzdC1lbmhhbmNlZC5odG1sKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgc2NvcmVzID0gbWVldHNDb250cmFzdEd1aWRlbGluZXMoJyM0NDQnLCAnI2ZmZicpO1xuICovXG5mdW5jdGlvbiBtZWV0c0NvbnRyYXN0R3VpZGVsaW5lcyhjb2xvcjEsIGNvbG9yMikge1xuICB2YXIgY29udHJhc3RSYXRpbyA9IGdldENvbnRyYXN0KGNvbG9yMSwgY29sb3IyKTtcbiAgcmV0dXJuIHtcbiAgICBBQTogY29udHJhc3RSYXRpbyA+PSA0LjUsXG4gICAgQUFMYXJnZTogY29udHJhc3RSYXRpbyA+PSAzLFxuICAgIEFBQTogY29udHJhc3RSYXRpbyA+PSA3LFxuICAgIEFBQUxhcmdlOiBjb250cmFzdFJhdGlvID49IDQuNVxuICB9O1xufVxuXG4vKipcbiAqIE1peGVzIHRoZSB0d28gcHJvdmlkZWQgY29sb3JzIHRvZ2V0aGVyIGJ5IGNhbGN1bGF0aW5nIHRoZSBhdmVyYWdlIG9mIGVhY2ggb2YgdGhlIFJHQiBjb21wb25lbnRzIHdlaWdodGVkIHRvIHRoZSBmaXJzdCBjb2xvciBieSB0aGUgcHJvdmlkZWQgd2VpZ2h0LlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IG1peCgwLjUsICcjZjAwJywgJyMwMGYnKVxuICogICBiYWNrZ3JvdW5kOiBtaXgoMC4yNSwgJyNmMDAnLCAnIzAwZicpXG4gKiAgIGJhY2tncm91bmQ6IG1peCgnMC41JywgJ3JnYmEoMjU1LCAwLCAwLCAwLjUpJywgJyMwMGYnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke21peCgwLjUsICcjZjAwJywgJyMwMGYnKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7bWl4KDAuMjUsICcjZjAwJywgJyMwMGYnKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7bWl4KCcwLjUnLCAncmdiYSgyNTUsIDAsIDAsIDAuNSknLCAnIzAwZicpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiIzdmMDA3ZlwiO1xuICogICBiYWNrZ3JvdW5kOiBcIiMzZjAwYmZcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDYzLCAwLCAxOTEsIDAuNzUpXCI7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIG1peCh3ZWlnaHQsIGNvbG9yLCBvdGhlckNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIG90aGVyQ29sb3I7XG4gIGlmIChvdGhlckNvbG9yID09PSAndHJhbnNwYXJlbnQnKSByZXR1cm4gY29sb3I7XG4gIGlmICh3ZWlnaHQgPT09IDApIHJldHVybiBvdGhlckNvbG9yO1xuICB2YXIgcGFyc2VkQ29sb3IxID0gcGFyc2VUb1JnYihjb2xvcik7XG4gIHZhciBjb2xvcjEgPSBfZXh0ZW5kcyh7fSwgcGFyc2VkQ29sb3IxLCB7XG4gICAgYWxwaGE6IHR5cGVvZiBwYXJzZWRDb2xvcjEuYWxwaGEgPT09ICdudW1iZXInID8gcGFyc2VkQ29sb3IxLmFscGhhIDogMVxuICB9KTtcbiAgdmFyIHBhcnNlZENvbG9yMiA9IHBhcnNlVG9SZ2Iob3RoZXJDb2xvcik7XG4gIHZhciBjb2xvcjIgPSBfZXh0ZW5kcyh7fSwgcGFyc2VkQ29sb3IyLCB7XG4gICAgYWxwaGE6IHR5cGVvZiBwYXJzZWRDb2xvcjIuYWxwaGEgPT09ICdudW1iZXInID8gcGFyc2VkQ29sb3IyLmFscGhhIDogMVxuICB9KTtcblxuICAvLyBUaGUgZm9ybXVsYSBpcyBjb3BpZWQgZnJvbSB0aGUgb3JpZ2luYWwgU2FzcyBpbXBsZW1lbnRhdGlvbjpcbiAgLy8gaHR0cDovL3Nhc3MtbGFuZy5jb20vZG9jdW1lbnRhdGlvbi9TYXNzL1NjcmlwdC9GdW5jdGlvbnMuaHRtbCNtaXgtaW5zdGFuY2VfbWV0aG9kXG4gIHZhciBhbHBoYURlbHRhID0gY29sb3IxLmFscGhhIC0gY29sb3IyLmFscGhhO1xuICB2YXIgeCA9IHBhcnNlRmxvYXQod2VpZ2h0KSAqIDIgLSAxO1xuICB2YXIgeSA9IHggKiBhbHBoYURlbHRhID09PSAtMSA/IHggOiB4ICsgYWxwaGFEZWx0YTtcbiAgdmFyIHogPSAxICsgeCAqIGFscGhhRGVsdGE7XG4gIHZhciB3ZWlnaHQxID0gKHkgLyB6ICsgMSkgLyAyLjA7XG4gIHZhciB3ZWlnaHQyID0gMSAtIHdlaWdodDE7XG4gIHZhciBtaXhlZENvbG9yID0ge1xuICAgIHJlZDogTWF0aC5mbG9vcihjb2xvcjEucmVkICogd2VpZ2h0MSArIGNvbG9yMi5yZWQgKiB3ZWlnaHQyKSxcbiAgICBncmVlbjogTWF0aC5mbG9vcihjb2xvcjEuZ3JlZW4gKiB3ZWlnaHQxICsgY29sb3IyLmdyZWVuICogd2VpZ2h0MiksXG4gICAgYmx1ZTogTWF0aC5mbG9vcihjb2xvcjEuYmx1ZSAqIHdlaWdodDEgKyBjb2xvcjIuYmx1ZSAqIHdlaWdodDIpLFxuICAgIGFscGhhOiBjb2xvcjEuYWxwaGEgKiBwYXJzZUZsb2F0KHdlaWdodCkgKyBjb2xvcjIuYWxwaGEgKiAoMSAtIHBhcnNlRmxvYXQod2VpZ2h0KSlcbiAgfTtcbiAgcmV0dXJuIHJnYmEobWl4ZWRDb2xvcik7XG59XG5cbi8vIHByZXR0aWVyLWlnbm9yZVxudmFyIGN1cnJpZWRNaXggPSBjdXJyeSAvKiA6OjxudW1iZXIgfCBzdHJpbmcsIHN0cmluZywgc3RyaW5nLCBzdHJpbmc+ICovKG1peCk7XG52YXIgbWl4JDEgPSBjdXJyaWVkTWl4O1xuXG4vKipcbiAqIEluY3JlYXNlcyB0aGUgb3BhY2l0eSBvZiBhIGNvbG9yLiBJdHMgcmFuZ2UgZm9yIHRoZSBhbW91bnQgaXMgYmV0d2VlbiAwIHRvIDEuXG4gKlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IG9wYWNpZnkoMC4xLCAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjkpJyk7XG4gKiAgIGJhY2tncm91bmQ6IG9wYWNpZnkoMC4yLCAnaHNsYSgwLCAwJSwgMTAwJSwgMC41KScpLFxuICogICBiYWNrZ3JvdW5kOiBvcGFjaWZ5KCcwLjUnLCAncmdiYSgyNTUsIDAsIDAsIDAuMiknKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtvcGFjaWZ5KDAuMSwgJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC45KScpfTtcbiAqICAgYmFja2dyb3VuZDogJHtvcGFjaWZ5KDAuMiwgJ2hzbGEoMCwgMCUsIDEwMCUsIDAuNSknKX0sXG4gKiAgIGJhY2tncm91bmQ6ICR7b3BhY2lmeSgnMC41JywgJ3JnYmEoMjU1LCAwLCAwLCAwLjIpJyl9LFxuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjZmZmXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyNTUsMjU1LDI1NSwwLjcpXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyNTUsMCwwLDAuNylcIjtcbiAqIH1cbiAqL1xuZnVuY3Rpb24gb3BhY2lmeShhbW91bnQsIGNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIGNvbG9yO1xuICB2YXIgcGFyc2VkQ29sb3IgPSBwYXJzZVRvUmdiKGNvbG9yKTtcbiAgdmFyIGFscGhhID0gdHlwZW9mIHBhcnNlZENvbG9yLmFscGhhID09PSAnbnVtYmVyJyA/IHBhcnNlZENvbG9yLmFscGhhIDogMTtcbiAgdmFyIGNvbG9yV2l0aEFscGhhID0gX2V4dGVuZHMoe30sIHBhcnNlZENvbG9yLCB7XG4gICAgYWxwaGE6IGd1YXJkKDAsIDEsIChhbHBoYSAqIDEwMCArIHBhcnNlRmxvYXQoYW1vdW50KSAqIDEwMCkgLyAxMDApXG4gIH0pO1xuICByZXR1cm4gcmdiYShjb2xvcldpdGhBbHBoYSk7XG59XG5cbi8vIHByZXR0aWVyLWlnbm9yZVxudmFyIGN1cnJpZWRPcGFjaWZ5ID0gY3VycnkgLyogOjo8bnVtYmVyIHwgc3RyaW5nLCBzdHJpbmcsIHN0cmluZz4gKi8ob3BhY2lmeSk7XG52YXIgY3VycmllZE9wYWNpZnkkMSA9IGN1cnJpZWRPcGFjaWZ5O1xuXG52YXIgZGVmYXVsdFJldHVybklmTGlnaHRDb2xvciA9ICcjMDAwJztcbnZhciBkZWZhdWx0UmV0dXJuSWZEYXJrQ29sb3IgPSAnI2ZmZic7XG5cbi8qKlxuICogUmV0dXJucyBibGFjayBvciB3aGl0ZSAob3Igb3B0aW9uYWwgcGFzc2VkIGNvbG9ycykgZm9yIGJlc3RcbiAqIGNvbnRyYXN0IGRlcGVuZGluZyBvbiB0aGUgbHVtaW5vc2l0eSBvZiB0aGUgZ2l2ZW4gY29sb3IuXG4gKiBXaGVuIHBhc3NpbmcgY3VzdG9tIHJldHVybiBjb2xvcnMsIHN0cmljdCBtb2RlIGVuc3VyZXMgdGhhdCB0aGVcbiAqIHJldHVybiBjb2xvciBhbHdheXMgbWVldHMgb3IgZXhjZWVkcyBXQ0FHIGxldmVsIEFBIG9yIGdyZWF0ZXIuIElmIHRoaXMgdGVzdFxuICogZmFpbHMsIHRoZSBkZWZhdWx0IHJldHVybiBjb2xvciAoYmxhY2sgb3Igd2hpdGUpIGlzIHJldHVybmVkIGluIHBsYWNlIG9mIHRoZVxuICogY3VzdG9tIHJldHVybiBjb2xvci4gWW91IGNhbiBvcHRpb25hbGx5IHR1cm4gb2ZmIHN0cmljdCBtb2RlLlxuICpcbiAqIEZvbGxvd3MgW1czQyBzcGVjcyBmb3IgcmVhZGFiaWxpdHldKGh0dHBzOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAtVEVDSFMvRzE4Lmh0bWwpLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGNvbG9yOiByZWFkYWJsZUNvbG9yKCcjMDAwJyksXG4gKiAgIGNvbG9yOiByZWFkYWJsZUNvbG9yKCdibGFjaycsICcjMDAxJywgJyNmZjgnKSxcbiAqICAgY29sb3I6IHJlYWRhYmxlQ29sb3IoJ3doaXRlJywgJyMwMDEnLCAnI2ZmOCcpLFxuICogICBjb2xvcjogcmVhZGFibGVDb2xvcigncmVkJywgJyMzMzMnLCAnI2RkZCcsIHRydWUpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGNvbG9yOiAke3JlYWRhYmxlQ29sb3IoJyMwMDAnKX07XG4gKiAgIGNvbG9yOiAke3JlYWRhYmxlQ29sb3IoJ2JsYWNrJywgJyMwMDEnLCAnI2ZmOCcpfTtcbiAqICAgY29sb3I6ICR7cmVhZGFibGVDb2xvcignd2hpdGUnLCAnIzAwMScsICcjZmY4Jyl9O1xuICogICBjb2xvcjogJHtyZWFkYWJsZUNvbG9yKCdyZWQnLCAnIzMzMycsICcjZGRkJywgdHJ1ZSl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqIGVsZW1lbnQge1xuICogICBjb2xvcjogXCIjZmZmXCI7XG4gKiAgIGNvbG9yOiBcIiNmZjhcIjtcbiAqICAgY29sb3I6IFwiIzAwMVwiO1xuICogICBjb2xvcjogXCIjMDAwXCI7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHJlYWRhYmxlQ29sb3IoY29sb3IsIHJldHVybklmTGlnaHRDb2xvciwgcmV0dXJuSWZEYXJrQ29sb3IsIHN0cmljdCkge1xuICBpZiAocmV0dXJuSWZMaWdodENvbG9yID09PSB2b2lkIDApIHtcbiAgICByZXR1cm5JZkxpZ2h0Q29sb3IgPSBkZWZhdWx0UmV0dXJuSWZMaWdodENvbG9yO1xuICB9XG4gIGlmIChyZXR1cm5JZkRhcmtDb2xvciA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuSWZEYXJrQ29sb3IgPSBkZWZhdWx0UmV0dXJuSWZEYXJrQ29sb3I7XG4gIH1cbiAgaWYgKHN0cmljdCA9PT0gdm9pZCAwKSB7XG4gICAgc3RyaWN0ID0gdHJ1ZTtcbiAgfVxuICB2YXIgaXNDb2xvckxpZ2h0ID0gZ2V0THVtaW5hbmNlKGNvbG9yKSA+IDAuMTc5O1xuICB2YXIgcHJlZmVycmVkUmV0dXJuQ29sb3IgPSBpc0NvbG9yTGlnaHQgPyByZXR1cm5JZkxpZ2h0Q29sb3IgOiByZXR1cm5JZkRhcmtDb2xvcjtcbiAgaWYgKCFzdHJpY3QgfHwgZ2V0Q29udHJhc3QoY29sb3IsIHByZWZlcnJlZFJldHVybkNvbG9yKSA+PSA0LjUpIHtcbiAgICByZXR1cm4gcHJlZmVycmVkUmV0dXJuQ29sb3I7XG4gIH1cbiAgcmV0dXJuIGlzQ29sb3JMaWdodCA/IGRlZmF1bHRSZXR1cm5JZkxpZ2h0Q29sb3IgOiBkZWZhdWx0UmV0dXJuSWZEYXJrQ29sb3I7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBSZ2JDb2xvciBvciBSZ2JhQ29sb3Igb2JqZWN0IHRvIGEgY29sb3Igc3RyaW5nLlxuICogVGhpcyB1dGlsIGlzIHVzZWZ1bCBpbiBjYXNlIHlvdSBvbmx5IGtub3cgb24gcnVudGltZSB3aGljaCBjb2xvciBvYmplY3QgaXNcbiAqIHVzZWQuIE90aGVyd2lzZSB3ZSByZWNvbW1lbmQgdG8gcmVseSBvbiBgcmdiYCBvciBgcmdiYWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogcmdiVG9Db2xvclN0cmluZyh7IHJlZDogMjU1LCBncmVlbjogMjA1LCBibHVlOiAxMDAgfSksXG4gKiAgIGJhY2tncm91bmQ6IHJnYlRvQ29sb3JTdHJpbmcoeyByZWQ6IDI1NSwgZ3JlZW46IDIwNSwgYmx1ZTogMTAwLCBhbHBoYTogMC43MiB9KSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtyZ2JUb0NvbG9yU3RyaW5nKHsgcmVkOiAyNTUsIGdyZWVuOiAyMDUsIGJsdWU6IDEwMCB9KX07XG4gKiAgIGJhY2tncm91bmQ6ICR7cmdiVG9Db2xvclN0cmluZyh7IHJlZDogMjU1LCBncmVlbjogMjA1LCBibHVlOiAxMDAsIGFscGhhOiAwLjcyIH0pfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjZmZjZDY0XCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyNTUsMjA1LDEwMCwwLjcyKVwiO1xuICogfVxuICovXG5mdW5jdGlvbiByZ2JUb0NvbG9yU3RyaW5nKGNvbG9yKSB7XG4gIGlmICh0eXBlb2YgY29sb3IgPT09ICdvYmplY3QnICYmIHR5cGVvZiBjb2xvci5yZWQgPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5ncmVlbiA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbG9yLmJsdWUgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBjb2xvci5hbHBoYSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiByZ2JhKHtcbiAgICAgICAgcmVkOiBjb2xvci5yZWQsXG4gICAgICAgIGdyZWVuOiBjb2xvci5ncmVlbixcbiAgICAgICAgYmx1ZTogY29sb3IuYmx1ZSxcbiAgICAgICAgYWxwaGE6IGNvbG9yLmFscGhhXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJnYih7XG4gICAgICByZWQ6IGNvbG9yLnJlZCxcbiAgICAgIGdyZWVuOiBjb2xvci5ncmVlbixcbiAgICAgIGJsdWU6IGNvbG9yLmJsdWVcbiAgICB9KTtcbiAgfVxuICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig0Nik7XG59XG5cbi8qKlxuICogSW5jcmVhc2VzIHRoZSBpbnRlbnNpdHkgb2YgYSBjb2xvci4gSXRzIHJhbmdlIGlzIGJldHdlZW4gMCB0byAxLiBUaGUgZmlyc3RcbiAqIGFyZ3VtZW50IG9mIHRoZSBzYXR1cmF0ZSBmdW5jdGlvbiBpcyB0aGUgYW1vdW50IGJ5IGhvdyBtdWNoIHRoZSBjb2xvclxuICogaW50ZW5zaXR5IHNob3VsZCBiZSBpbmNyZWFzZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogc2F0dXJhdGUoMC4yLCAnI0NDQ0Q2NCcpLFxuICogICBiYWNrZ3JvdW5kOiBzYXR1cmF0ZSgnMC4yJywgJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke3NhdHVyYXRlKDAuMiwgJyNGRkNENjQnKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7c2F0dXJhdGUoJzAuMicsICdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiNlMGUyNTBcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDIyNCwyMjYsODAsMC43KVwiO1xuICogfVxuICovXG5mdW5jdGlvbiBzYXR1cmF0ZShhbW91bnQsIGNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIGNvbG9yO1xuICB2YXIgaHNsQ29sb3IgPSBwYXJzZVRvSHNsKGNvbG9yKTtcbiAgcmV0dXJuIHRvQ29sb3JTdHJpbmcoX2V4dGVuZHMoe30sIGhzbENvbG9yLCB7XG4gICAgc2F0dXJhdGlvbjogZ3VhcmQoMCwgMSwgaHNsQ29sb3Iuc2F0dXJhdGlvbiArIHBhcnNlRmxvYXQoYW1vdW50KSlcbiAgfSkpO1xufVxuXG4vLyBwcmV0dGllci1pZ25vcmVcbnZhciBjdXJyaWVkU2F0dXJhdGUgPSBjdXJyeSAvKiA6OjxudW1iZXIgfCBzdHJpbmcsIHN0cmluZywgc3RyaW5nPiAqLyhzYXR1cmF0ZSk7XG52YXIgY3VycmllZFNhdHVyYXRlJDEgPSBjdXJyaWVkU2F0dXJhdGU7XG5cbi8qKlxuICogU2V0cyB0aGUgaHVlIG9mIGEgY29sb3IgdG8gdGhlIHByb3ZpZGVkIHZhbHVlLiBUaGUgaHVlIHJhbmdlIGNhbiBiZVxuICogZnJvbSAwIGFuZCAzNTkuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogc2V0SHVlKDQyLCAnI0NDQ0Q2NCcpLFxuICogICBiYWNrZ3JvdW5kOiBzZXRIdWUoJzI0NCcsICdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtzZXRIdWUoNDIsICcjQ0NDRDY0Jyl9O1xuICogICBiYWNrZ3JvdW5kOiAke3NldEh1ZSgnMjQ0JywgJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjY2RhZTY0XCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgxMDcsMTAwLDIwNSwwLjcpXCI7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHNldEh1ZShodWUsIGNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIGNvbG9yO1xuICByZXR1cm4gdG9Db2xvclN0cmluZyhfZXh0ZW5kcyh7fSwgcGFyc2VUb0hzbChjb2xvciksIHtcbiAgICBodWU6IHBhcnNlRmxvYXQoaHVlKVxuICB9KSk7XG59XG5cbi8vIHByZXR0aWVyLWlnbm9yZVxudmFyIGN1cnJpZWRTZXRIdWUgPSBjdXJyeSAvKiA6OjxudW1iZXIgfCBzdHJpbmcsIHN0cmluZywgc3RyaW5nPiAqLyhzZXRIdWUpO1xudmFyIGN1cnJpZWRTZXRIdWUkMSA9IGN1cnJpZWRTZXRIdWU7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlnaHRuZXNzIG9mIGEgY29sb3IgdG8gdGhlIHByb3ZpZGVkIHZhbHVlLiBUaGUgbGlnaHRuZXNzIHJhbmdlIGNhbiBiZVxuICogZnJvbSAwIGFuZCAxLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IHNldExpZ2h0bmVzcygwLjIsICcjQ0NDRDY0JyksXG4gKiAgIGJhY2tncm91bmQ6IHNldExpZ2h0bmVzcygnMC43NScsICdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtzZXRMaWdodG5lc3MoMC4yLCAnI0NDQ0Q2NCcpfTtcbiAqICAgYmFja2dyb3VuZDogJHtzZXRMaWdodG5lc3MoJzAuNzUnLCAncmdiYSgyMDQsMjA1LDEwMCwwLjcpJyl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiM0ZDRkMTlcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDIyMywyMjQsMTU5LDAuNylcIjtcbiAqIH1cbiAqL1xuZnVuY3Rpb24gc2V0TGlnaHRuZXNzKGxpZ2h0bmVzcywgY29sb3IpIHtcbiAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSByZXR1cm4gY29sb3I7XG4gIHJldHVybiB0b0NvbG9yU3RyaW5nKF9leHRlbmRzKHt9LCBwYXJzZVRvSHNsKGNvbG9yKSwge1xuICAgIGxpZ2h0bmVzczogcGFyc2VGbG9hdChsaWdodG5lc3MpXG4gIH0pKTtcbn1cblxuLy8gcHJldHRpZXItaWdub3JlXG52YXIgY3VycmllZFNldExpZ2h0bmVzcyA9IGN1cnJ5IC8qIDo6PG51bWJlciB8IHN0cmluZywgc3RyaW5nLCBzdHJpbmc+ICovKHNldExpZ2h0bmVzcyk7XG52YXIgY3VycmllZFNldExpZ2h0bmVzcyQxID0gY3VycmllZFNldExpZ2h0bmVzcztcblxuLyoqXG4gKiBTZXRzIHRoZSBzYXR1cmF0aW9uIG9mIGEgY29sb3IgdG8gdGhlIHByb3ZpZGVkIHZhbHVlLiBUaGUgc2F0dXJhdGlvbiByYW5nZSBjYW4gYmVcbiAqIGZyb20gMCBhbmQgMS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBzZXRTYXR1cmF0aW9uKDAuMiwgJyNDQ0NENjQnKSxcbiAqICAgYmFja2dyb3VuZDogc2V0U2F0dXJhdGlvbignMC43NScsICdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtzZXRTYXR1cmF0aW9uKDAuMiwgJyNDQ0NENjQnKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7c2V0U2F0dXJhdGlvbignMC43NScsICdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2FkYWQ4NFwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMjI4LDIyOSw3NiwwLjcpXCI7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHNldFNhdHVyYXRpb24oc2F0dXJhdGlvbiwgY29sb3IpIHtcbiAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSByZXR1cm4gY29sb3I7XG4gIHJldHVybiB0b0NvbG9yU3RyaW5nKF9leHRlbmRzKHt9LCBwYXJzZVRvSHNsKGNvbG9yKSwge1xuICAgIHNhdHVyYXRpb246IHBhcnNlRmxvYXQoc2F0dXJhdGlvbilcbiAgfSkpO1xufVxuXG4vLyBwcmV0dGllci1pZ25vcmVcbnZhciBjdXJyaWVkU2V0U2F0dXJhdGlvbiA9IGN1cnJ5IC8qIDo6PG51bWJlciB8IHN0cmluZywgc3RyaW5nLCBzdHJpbmc+ICovKHNldFNhdHVyYXRpb24pO1xudmFyIGN1cnJpZWRTZXRTYXR1cmF0aW9uJDEgPSBjdXJyaWVkU2V0U2F0dXJhdGlvbjtcblxuLyoqXG4gKiBTaGFkZXMgYSBjb2xvciBieSBtaXhpbmcgaXQgd2l0aCBibGFjay4gYHNoYWRlYCBjYW4gcHJvZHVjZVxuICogaHVlIHNoaWZ0cywgd2hlcmUgYXMgYGRhcmtlbmAgbWFuaXB1bGF0ZXMgdGhlIGx1bWluYW5jZSBjaGFubmVsIGFuZCB0aGVyZWZvcmVcbiAqIGRvZXNuJ3QgcHJvZHVjZSBodWUgc2hpZnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IHNoYWRlKDAuMjUsICcjMDBmJylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtzaGFkZSgwLjI1LCAnIzAwZicpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiIzAwMDAzZlwiO1xuICogfVxuICovXG5cbmZ1bmN0aW9uIHNoYWRlKHBlcmNlbnRhZ2UsIGNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIGNvbG9yO1xuICByZXR1cm4gbWl4JDEocGFyc2VGbG9hdChwZXJjZW50YWdlKSwgJ3JnYigwLCAwLCAwKScsIGNvbG9yKTtcbn1cblxuLy8gcHJldHRpZXItaWdub3JlXG52YXIgY3VycmllZFNoYWRlID0gY3VycnkgLyogOjo8bnVtYmVyIHwgc3RyaW5nLCBzdHJpbmcsIHN0cmluZz4gKi8oc2hhZGUpO1xudmFyIGN1cnJpZWRTaGFkZSQxID0gY3VycmllZFNoYWRlO1xuXG4vKipcbiAqIFRpbnRzIGEgY29sb3IgYnkgbWl4aW5nIGl0IHdpdGggd2hpdGUuIGB0aW50YCBjYW4gcHJvZHVjZVxuICogaHVlIHNoaWZ0cywgd2hlcmUgYXMgYGxpZ2h0ZW5gIG1hbmlwdWxhdGVzIHRoZSBsdW1pbmFuY2UgY2hhbm5lbCBhbmQgdGhlcmVmb3JlXG4gKiBkb2Vzbid0IHByb2R1Y2UgaHVlIHNoaWZ0cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiB0aW50KDAuMjUsICcjMDBmJylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHt0aW50KDAuMjUsICcjMDBmJyl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjYmZiZmZmXCI7XG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gdGludChwZXJjZW50YWdlLCBjb2xvcikge1xuICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHJldHVybiBjb2xvcjtcbiAgcmV0dXJuIG1peCQxKHBhcnNlRmxvYXQocGVyY2VudGFnZSksICdyZ2IoMjU1LCAyNTUsIDI1NSknLCBjb2xvcik7XG59XG5cbi8vIHByZXR0aWVyLWlnbm9yZVxudmFyIGN1cnJpZWRUaW50ID0gY3VycnkgLyogOjo8bnVtYmVyIHwgc3RyaW5nLCBzdHJpbmcsIHN0cmluZz4gKi8odGludCk7XG52YXIgY3VycmllZFRpbnQkMSA9IGN1cnJpZWRUaW50O1xuXG4vKipcbiAqIERlY3JlYXNlcyB0aGUgb3BhY2l0eSBvZiBhIGNvbG9yLiBJdHMgcmFuZ2UgZm9yIHRoZSBhbW91bnQgaXMgYmV0d2VlbiAwIHRvIDEuXG4gKlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50aXplKDAuMSwgJyNmZmYnKSxcbiAqICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnRpemUoMC4yLCAnaHNsKDAsIDAlLCAxMDAlKScpLFxuICogICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudGl6ZSgnMC41JywgJ3JnYmEoMjU1LCAwLCAwLCAwLjgpJyksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7dHJhbnNwYXJlbnRpemUoMC4xLCAnI2ZmZicpfTtcbiAqICAgYmFja2dyb3VuZDogJHt0cmFuc3BhcmVudGl6ZSgwLjIsICdoc2woMCwgMCUsIDEwMCUpJyl9O1xuICogICBiYWNrZ3JvdW5kOiAke3RyYW5zcGFyZW50aXplKCcwLjUnLCAncmdiYSgyNTUsIDAsIDAsIDAuOCknKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMjU1LDI1NSwyNTUsMC45KVwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMjU1LDI1NSwyNTUsMC44KVwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMjU1LDAsMCwwLjMpXCI7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHRyYW5zcGFyZW50aXplKGFtb3VudCwgY29sb3IpIHtcbiAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSByZXR1cm4gY29sb3I7XG4gIHZhciBwYXJzZWRDb2xvciA9IHBhcnNlVG9SZ2IoY29sb3IpO1xuICB2YXIgYWxwaGEgPSB0eXBlb2YgcGFyc2VkQ29sb3IuYWxwaGEgPT09ICdudW1iZXInID8gcGFyc2VkQ29sb3IuYWxwaGEgOiAxO1xuICB2YXIgY29sb3JXaXRoQWxwaGEgPSBfZXh0ZW5kcyh7fSwgcGFyc2VkQ29sb3IsIHtcbiAgICBhbHBoYTogZ3VhcmQoMCwgMSwgKyhhbHBoYSAqIDEwMCAtIHBhcnNlRmxvYXQoYW1vdW50KSAqIDEwMCkudG9GaXhlZCgyKSAvIDEwMClcbiAgfSk7XG4gIHJldHVybiByZ2JhKGNvbG9yV2l0aEFscGhhKTtcbn1cblxuLy8gcHJldHRpZXItaWdub3JlXG52YXIgY3VycmllZFRyYW5zcGFyZW50aXplID0gY3VycnkgLyogOjo8bnVtYmVyIHwgc3RyaW5nLCBzdHJpbmcsIHN0cmluZz4gKi8odHJhbnNwYXJlbnRpemUpO1xudmFyIGN1cnJpZWRUcmFuc3BhcmVudGl6ZSQxID0gY3VycmllZFRyYW5zcGFyZW50aXplO1xuXG4vKipcbiAqIFNob3J0aGFuZCBmb3IgZWFzaWx5IHNldHRpbmcgdGhlIGFuaW1hdGlvbiBwcm9wZXJ0eS4gQWxsb3dzIGVpdGhlciBtdWx0aXBsZSBhcnJheXMgd2l0aCBhbmltYXRpb25zXG4gKiBvciBhIHNpbmdsZSBhbmltYXRpb24gc3ByZWFkIG92ZXIgdGhlIGFyZ3VtZW50cy5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLmFuaW1hdGlvbihbJ3JvdGF0ZScsICcxcycsICdlYXNlLWluLW91dCddLCBbJ2NvbG9yY2hhbmdlJywgJzJzJ10pXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7YW5pbWF0aW9uKFsncm90YXRlJywgJzFzJywgJ2Vhc2UtaW4tb3V0J10sIFsnY29sb3JjaGFuZ2UnLCAnMnMnXSl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdiB7XG4gKiAgICdhbmltYXRpb24nOiAncm90YXRlIDFzIGVhc2UtaW4tb3V0LCBjb2xvcmNoYW5nZSAycydcbiAqIH1cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLmFuaW1hdGlvbigncm90YXRlJywgJzFzJywgJ2Vhc2UtaW4tb3V0JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHthbmltYXRpb24oJ3JvdGF0ZScsICcxcycsICdlYXNlLWluLW91dCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAnYW5pbWF0aW9uJzogJ3JvdGF0ZSAxcyBlYXNlLWluLW91dCdcbiAqIH1cbiAqL1xuZnVuY3Rpb24gYW5pbWF0aW9uKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIC8vIEFsbG93IHNpbmdsZSBvciBtdWx0aXBsZSBhbmltYXRpb25zIHBhc3NlZFxuICB2YXIgbXVsdGlNb2RlID0gQXJyYXkuaXNBcnJheShhcmdzWzBdKTtcbiAgaWYgKCFtdWx0aU1vZGUgJiYgYXJncy5sZW5ndGggPiA4KSB7XG4gICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNjQpO1xuICB9XG4gIHZhciBjb2RlID0gYXJncy5tYXAoZnVuY3Rpb24gKGFyZykge1xuICAgIGlmIChtdWx0aU1vZGUgJiYgIUFycmF5LmlzQXJyYXkoYXJnKSB8fCAhbXVsdGlNb2RlICYmIEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNjUpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpICYmIGFyZy5sZW5ndGggPiA4KSB7XG4gICAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig2Nik7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZykgPyBhcmcuam9pbignICcpIDogYXJnO1xuICB9KS5qb2luKCcsICcpO1xuICByZXR1cm4ge1xuICAgIGFuaW1hdGlvbjogY29kZVxuICB9O1xufVxuXG4vKipcbiAqIFNob3J0aGFuZCB0aGF0IGFjY2VwdHMgYW55IG51bWJlciBvZiBiYWNrZ3JvdW5kSW1hZ2UgdmFsdWVzIGFzIHBhcmFtZXRlcnMgZm9yIGNyZWF0aW5nIGEgc2luZ2xlIGJhY2tncm91bmQgc3RhdGVtZW50LlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4uYmFja2dyb3VuZEltYWdlcygndXJsKFwiL2ltYWdlL2JhY2tncm91bmQuanBnXCIpJywgJ2xpbmVhci1ncmFkaWVudChyZWQsIGdyZWVuKScpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7YmFja2dyb3VuZEltYWdlcygndXJsKFwiL2ltYWdlL2JhY2tncm91bmQuanBnXCIpJywgJ2xpbmVhci1ncmFkaWVudChyZWQsIGdyZWVuKScpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAnYmFja2dyb3VuZEltYWdlJzogJ3VybChcIi9pbWFnZS9iYWNrZ3JvdW5kLmpwZ1wiKSwgbGluZWFyLWdyYWRpZW50KHJlZCwgZ3JlZW4pJ1xuICogfVxuICovXG5mdW5jdGlvbiBiYWNrZ3JvdW5kSW1hZ2VzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcHJvcGVydGllcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBwcm9wZXJ0aWVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIHJldHVybiB7XG4gICAgYmFja2dyb3VuZEltYWdlOiBwcm9wZXJ0aWVzLmpvaW4oJywgJylcbiAgfTtcbn1cblxuLyoqXG4gKiBTaG9ydGhhbmQgdGhhdCBhY2NlcHRzIGFueSBudW1iZXIgb2YgYmFja2dyb3VuZCB2YWx1ZXMgYXMgcGFyYW1ldGVycyBmb3IgY3JlYXRpbmcgYSBzaW5nbGUgYmFja2dyb3VuZCBzdGF0ZW1lbnQuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5iYWNrZ3JvdW5kcygndXJsKFwiL2ltYWdlL2JhY2tncm91bmQuanBnXCIpJywgJ2xpbmVhci1ncmFkaWVudChyZWQsIGdyZWVuKScsICdjZW50ZXIgbm8tcmVwZWF0JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtiYWNrZ3JvdW5kcygndXJsKFwiL2ltYWdlL2JhY2tncm91bmQuanBnXCIpJywgJ2xpbmVhci1ncmFkaWVudChyZWQsIGdyZWVuKScsICdjZW50ZXIgbm8tcmVwZWF0Jyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdiB7XG4gKiAgICdiYWNrZ3JvdW5kJzogJ3VybChcIi9pbWFnZS9iYWNrZ3JvdW5kLmpwZ1wiKSwgbGluZWFyLWdyYWRpZW50KHJlZCwgZ3JlZW4pLCBjZW50ZXIgbm8tcmVwZWF0J1xuICogfVxuICovXG5mdW5jdGlvbiBiYWNrZ3JvdW5kcygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHByb3BlcnRpZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgcHJvcGVydGllc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGJhY2tncm91bmQ6IHByb3BlcnRpZXMuam9pbignLCAnKVxuICB9O1xufVxuXG52YXIgc2lkZU1hcCA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J107XG5cbi8qKlxuICogU2hvcnRoYW5kIGZvciB0aGUgYm9yZGVyIHByb3BlcnR5IHRoYXQgc3BsaXRzIG91dCBpbmRpdmlkdWFsIHByb3BlcnRpZXMgZm9yIHVzZSB3aXRoIHRvb2xzIGxpa2UgRmVsYSBhbmQgU3R5bGV0cm9uLiBBIHNpZGUga2V5d29yZCBjYW4gb3B0aW9uYWxseSBiZSBwYXNzZWQgdG8gdGFyZ2V0IG9ubHkgb25lIHNpZGUncyBib3JkZXIgcHJvcGVydGllcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5ib3JkZXIoJzFweCcsICdzb2xpZCcsICdyZWQnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2JvcmRlcignMXB4JywgJ3NvbGlkJywgJ3JlZCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAnYm9yZGVyQ29sb3InOiAncmVkJyxcbiAqICAgJ2JvcmRlclN0eWxlJzogJ3NvbGlkJyxcbiAqICAgJ2JvcmRlcldpZHRoJzogYDFweGAsXG4gKiB9XG4gKlxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5ib3JkZXIoJ3RvcCcsICcxcHgnLCAnc29saWQnLCAncmVkJylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtib3JkZXIoJ3RvcCcsICcxcHgnLCAnc29saWQnLCAncmVkJyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdiB7XG4gKiAgICdib3JkZXJUb3BDb2xvcic6ICdyZWQnLFxuICogICAnYm9yZGVyVG9wU3R5bGUnOiAnc29saWQnLFxuICogICAnYm9yZGVyVG9wV2lkdGgnOiBgMXB4YCxcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiBib3JkZXIoc2lkZUtleXdvcmQpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHZhbHVlcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgdmFsdWVzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICBpZiAodHlwZW9mIHNpZGVLZXl3b3JkID09PSAnc3RyaW5nJyAmJiBzaWRlTWFwLmluZGV4T2Yoc2lkZUtleXdvcmQpID49IDApIHtcbiAgICB2YXIgX3JlZjtcbiAgICByZXR1cm4gX3JlZiA9IHt9LCBfcmVmW1wiYm9yZGVyXCIgKyBjYXBpdGFsaXplU3RyaW5nKHNpZGVLZXl3b3JkKSArIFwiV2lkdGhcIl0gPSB2YWx1ZXNbMF0sIF9yZWZbXCJib3JkZXJcIiArIGNhcGl0YWxpemVTdHJpbmcoc2lkZUtleXdvcmQpICsgXCJTdHlsZVwiXSA9IHZhbHVlc1sxXSwgX3JlZltcImJvcmRlclwiICsgY2FwaXRhbGl6ZVN0cmluZyhzaWRlS2V5d29yZCkgKyBcIkNvbG9yXCJdID0gdmFsdWVzWzJdLCBfcmVmO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlcy51bnNoaWZ0KHNpZGVLZXl3b3JkKTtcbiAgICByZXR1cm4ge1xuICAgICAgYm9yZGVyV2lkdGg6IHZhbHVlc1swXSxcbiAgICAgIGJvcmRlclN0eWxlOiB2YWx1ZXNbMV0sXG4gICAgICBib3JkZXJDb2xvcjogdmFsdWVzWzJdXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0aGFuZCB0aGF0IGFjY2VwdHMgdXAgdG8gZm91ciB2YWx1ZXMsIGluY2x1ZGluZyBudWxsIHRvIHNraXAgYSB2YWx1ZSwgYW5kIG1hcHMgdGhlbSB0byB0aGVpciByZXNwZWN0aXZlIGRpcmVjdGlvbnMuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5ib3JkZXJDb2xvcigncmVkJywgJ2dyZWVuJywgJ2JsdWUnLCAneWVsbG93JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtib3JkZXJDb2xvcigncmVkJywgJ2dyZWVuJywgJ2JsdWUnLCAneWVsbG93Jyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdiB7XG4gKiAgICdib3JkZXJUb3BDb2xvcic6ICdyZWQnLFxuICogICAnYm9yZGVyUmlnaHRDb2xvcic6ICdncmVlbicsXG4gKiAgICdib3JkZXJCb3R0b21Db2xvcic6ICdibHVlJyxcbiAqICAgJ2JvcmRlckxlZnRDb2xvcic6ICd5ZWxsb3cnXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGJvcmRlckNvbG9yKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgdmFsdWVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHZhbHVlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICByZXR1cm4gZGlyZWN0aW9uYWxQcm9wZXJ0eS5hcHBseSh2b2lkIDAsIFsnYm9yZGVyQ29sb3InXS5jb25jYXQodmFsdWVzKSk7XG59XG5cbi8qKlxuICogU2hvcnRoYW5kIHRoYXQgYWNjZXB0cyBhIHZhbHVlIGZvciBzaWRlIGFuZCBhIHZhbHVlIGZvciByYWRpdXMgYW5kIGFwcGxpZXMgdGhlIHJhZGl1cyB2YWx1ZSB0byBib3RoIGNvcm5lcnMgb2YgdGhlIHNpZGUuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5ib3JkZXJSYWRpdXMoJ3RvcCcsICc1cHgnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2JvcmRlclJhZGl1cygndG9wJywgJzVweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAnYm9yZGVyVG9wUmlnaHRSYWRpdXMnOiAnNXB4JyxcbiAqICAgJ2JvcmRlclRvcExlZnRSYWRpdXMnOiAnNXB4JyxcbiAqIH1cbiAqL1xuZnVuY3Rpb24gYm9yZGVyUmFkaXVzKHNpZGUsIHJhZGl1cykge1xuICB2YXIgdXBwZXJjYXNlU2lkZSA9IGNhcGl0YWxpemVTdHJpbmcoc2lkZSk7XG4gIGlmICghcmFkaXVzICYmIHJhZGl1cyAhPT0gMCkge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDYyKTtcbiAgfVxuICBpZiAodXBwZXJjYXNlU2lkZSA9PT0gJ1RvcCcgfHwgdXBwZXJjYXNlU2lkZSA9PT0gJ0JvdHRvbScpIHtcbiAgICB2YXIgX3JlZjtcbiAgICByZXR1cm4gX3JlZiA9IHt9LCBfcmVmW1wiYm9yZGVyXCIgKyB1cHBlcmNhc2VTaWRlICsgXCJSaWdodFJhZGl1c1wiXSA9IHJhZGl1cywgX3JlZltcImJvcmRlclwiICsgdXBwZXJjYXNlU2lkZSArIFwiTGVmdFJhZGl1c1wiXSA9IHJhZGl1cywgX3JlZjtcbiAgfVxuICBpZiAodXBwZXJjYXNlU2lkZSA9PT0gJ0xlZnQnIHx8IHVwcGVyY2FzZVNpZGUgPT09ICdSaWdodCcpIHtcbiAgICB2YXIgX3JlZjI7XG4gICAgcmV0dXJuIF9yZWYyID0ge30sIF9yZWYyW1wiYm9yZGVyVG9wXCIgKyB1cHBlcmNhc2VTaWRlICsgXCJSYWRpdXNcIl0gPSByYWRpdXMsIF9yZWYyW1wiYm9yZGVyQm90dG9tXCIgKyB1cHBlcmNhc2VTaWRlICsgXCJSYWRpdXNcIl0gPSByYWRpdXMsIF9yZWYyO1xuICB9XG4gIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDYzKTtcbn1cblxuLyoqXG4gKiBTaG9ydGhhbmQgdGhhdCBhY2NlcHRzIHVwIHRvIGZvdXIgdmFsdWVzLCBpbmNsdWRpbmcgbnVsbCB0byBza2lwIGEgdmFsdWUsIGFuZCBtYXBzIHRoZW0gdG8gdGhlaXIgcmVzcGVjdGl2ZSBkaXJlY3Rpb25zLlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4uYm9yZGVyU3R5bGUoJ3NvbGlkJywgJ2Rhc2hlZCcsICdkb3R0ZWQnLCAnZG91YmxlJylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtib3JkZXJTdHlsZSgnc29saWQnLCAnZGFzaGVkJywgJ2RvdHRlZCcsICdkb3VibGUnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgJ2JvcmRlclRvcFN0eWxlJzogJ3NvbGlkJyxcbiAqICAgJ2JvcmRlclJpZ2h0U3R5bGUnOiAnZGFzaGVkJyxcbiAqICAgJ2JvcmRlckJvdHRvbVN0eWxlJzogJ2RvdHRlZCcsXG4gKiAgICdib3JkZXJMZWZ0U3R5bGUnOiAnZG91YmxlJ1xuICogfVxuICovXG5mdW5jdGlvbiBib3JkZXJTdHlsZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHZhbHVlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICB2YWx1ZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgcmV0dXJuIGRpcmVjdGlvbmFsUHJvcGVydHkuYXBwbHkodm9pZCAwLCBbJ2JvcmRlclN0eWxlJ10uY29uY2F0KHZhbHVlcykpO1xufVxuXG4vKipcbiAqIFNob3J0aGFuZCB0aGF0IGFjY2VwdHMgdXAgdG8gZm91ciB2YWx1ZXMsIGluY2x1ZGluZyBudWxsIHRvIHNraXAgYSB2YWx1ZSwgYW5kIG1hcHMgdGhlbSB0byB0aGVpciByZXNwZWN0aXZlIGRpcmVjdGlvbnMuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5ib3JkZXJXaWR0aCgnMTJweCcsICcyNHB4JywgJzM2cHgnLCAnNDhweCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7Ym9yZGVyV2lkdGgoJzEycHgnLCAnMjRweCcsICczNnB4JywgJzQ4cHgnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgJ2JvcmRlclRvcFdpZHRoJzogJzEycHgnLFxuICogICAnYm9yZGVyUmlnaHRXaWR0aCc6ICcyNHB4JyxcbiAqICAgJ2JvcmRlckJvdHRvbVdpZHRoJzogJzM2cHgnLFxuICogICAnYm9yZGVyTGVmdFdpZHRoJzogJzQ4cHgnXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGJvcmRlcldpZHRoKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgdmFsdWVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHZhbHVlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICByZXR1cm4gZGlyZWN0aW9uYWxQcm9wZXJ0eS5hcHBseSh2b2lkIDAsIFsnYm9yZGVyV2lkdGgnXS5jb25jYXQodmFsdWVzKSk7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlU2VsZWN0b3JzKHRlbXBsYXRlLCBzdGF0ZSkge1xuICB2YXIgc3RhdGVTdWZmaXggPSBzdGF0ZSA/IFwiOlwiICsgc3RhdGUgOiAnJztcbiAgcmV0dXJuIHRlbXBsYXRlKHN0YXRlU3VmZml4KTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBoZWxwZXIgdGhhdCBhZGRzIGFuIGFycmF5IG9mIHN0YXRlcyB0byBhIHRlbXBsYXRlIG9mIHNlbGVjdG9ycy4gVXNlZCBpbiB0ZXh0SW5wdXRzIGFuZCBidXR0b25zLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc3RhdGVmdWxTZWxlY3RvcnMoc3RhdGVzLCB0ZW1wbGF0ZSwgc3RhdGVNYXApIHtcbiAgaWYgKCF0ZW1wbGF0ZSkgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNjcpO1xuICBpZiAoc3RhdGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGdlbmVyYXRlU2VsZWN0b3JzKHRlbXBsYXRlLCBudWxsKTtcbiAgdmFyIHNlbGVjdG9ycyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChzdGF0ZU1hcCAmJiBzdGF0ZU1hcC5pbmRleE9mKHN0YXRlc1tpXSkgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig2OCk7XG4gICAgfVxuICAgIHNlbGVjdG9ycy5wdXNoKGdlbmVyYXRlU2VsZWN0b3JzKHRlbXBsYXRlLCBzdGF0ZXNbaV0pKTtcbiAgfVxuICBzZWxlY3RvcnMgPSBzZWxlY3RvcnMuam9pbignLCcpO1xuICByZXR1cm4gc2VsZWN0b3JzO1xufVxuXG52YXIgc3RhdGVNYXAkMSA9IFt1bmRlZmluZWQsIG51bGwsICdhY3RpdmUnLCAnZm9jdXMnLCAnaG92ZXInXTtcbmZ1bmN0aW9uIHRlbXBsYXRlJDEoc3RhdGUpIHtcbiAgcmV0dXJuIFwiYnV0dG9uXCIgKyBzdGF0ZSArIFwiLFxcbiAgaW5wdXRbdHlwZT1cXFwiYnV0dG9uXFxcIl1cIiArIHN0YXRlICsgXCIsXFxuICBpbnB1dFt0eXBlPVxcXCJyZXNldFxcXCJdXCIgKyBzdGF0ZSArIFwiLFxcbiAgaW5wdXRbdHlwZT1cXFwic3VibWl0XFxcIl1cIiArIHN0YXRlO1xufVxuXG4vKipcbiAqIFBvcHVsYXRlcyBzZWxlY3RvcnMgdGhhdCB0YXJnZXQgYWxsIGJ1dHRvbnMuIFlvdSBjYW4gcGFzcyBvcHRpb25hbCBzdGF0ZXMgdG8gYXBwZW5kIHRvIHRoZSBzZWxlY3RvcnMuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBbYnV0dG9ucygnYWN0aXZlJyldOiB7XG4gKiAgICAgJ2JvcmRlcic6ICdub25lJ1xuICogICB9XG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgID4gJHtidXR0b25zKCdhY3RpdmUnKX0ge1xuICogICAgIGJvcmRlcjogbm9uZTtcbiAqICAgfVxuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiAgJ2J1dHRvbjphY3RpdmUsXG4gKiAgJ2lucHV0W3R5cGU9XCJidXR0b25cIl06YWN0aXZlLFxuICogICdpbnB1dFt0eXBlPVxcXCJyZXNldFxcXCJdOmFjdGl2ZSxcbiAqICAnaW5wdXRbdHlwZT1cXFwic3VibWl0XFxcIl06YWN0aXZlOiB7XG4gKiAgICdib3JkZXInOiAnbm9uZSdcbiAqIH1cbiAqL1xuZnVuY3Rpb24gYnV0dG9ucygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHN0YXRlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzdGF0ZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgcmV0dXJuIHN0YXRlZnVsU2VsZWN0b3JzKHN0YXRlcywgdGVtcGxhdGUkMSwgc3RhdGVNYXAkMSk7XG59XG5cbi8qKlxuICogU2hvcnRoYW5kIHRoYXQgYWNjZXB0cyB1cCB0byBmb3VyIHZhbHVlcywgaW5jbHVkaW5nIG51bGwgdG8gc2tpcCBhIHZhbHVlLCBhbmQgbWFwcyB0aGVtIHRvIHRoZWlyIHJlc3BlY3RpdmUgZGlyZWN0aW9ucy5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLm1hcmdpbignMTJweCcsICcyNHB4JywgJzM2cHgnLCAnNDhweCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7bWFyZ2luKCcxMnB4JywgJzI0cHgnLCAnMzZweCcsICc0OHB4Jyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdiB7XG4gKiAgICdtYXJnaW5Ub3AnOiAnMTJweCcsXG4gKiAgICdtYXJnaW5SaWdodCc6ICcyNHB4JyxcbiAqICAgJ21hcmdpbkJvdHRvbSc6ICczNnB4JyxcbiAqICAgJ21hcmdpbkxlZnQnOiAnNDhweCdcbiAqIH1cbiAqL1xuZnVuY3Rpb24gbWFyZ2luKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgdmFsdWVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHZhbHVlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICByZXR1cm4gZGlyZWN0aW9uYWxQcm9wZXJ0eS5hcHBseSh2b2lkIDAsIFsnbWFyZ2luJ10uY29uY2F0KHZhbHVlcykpO1xufVxuXG4vKipcbiAqIFNob3J0aGFuZCB0aGF0IGFjY2VwdHMgdXAgdG8gZm91ciB2YWx1ZXMsIGluY2x1ZGluZyBudWxsIHRvIHNraXAgYSB2YWx1ZSwgYW5kIG1hcHMgdGhlbSB0byB0aGVpciByZXNwZWN0aXZlIGRpcmVjdGlvbnMuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5wYWRkaW5nKCcxMnB4JywgJzI0cHgnLCAnMzZweCcsICc0OHB4JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtwYWRkaW5nKCcxMnB4JywgJzI0cHgnLCAnMzZweCcsICc0OHB4Jyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdiB7XG4gKiAgICdwYWRkaW5nVG9wJzogJzEycHgnLFxuICogICAncGFkZGluZ1JpZ2h0JzogJzI0cHgnLFxuICogICAncGFkZGluZ0JvdHRvbSc6ICczNnB4JyxcbiAqICAgJ3BhZGRpbmdMZWZ0JzogJzQ4cHgnXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHBhZGRpbmcoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCB2YWx1ZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgdmFsdWVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIHJldHVybiBkaXJlY3Rpb25hbFByb3BlcnR5LmFwcGx5KHZvaWQgMCwgWydwYWRkaW5nJ10uY29uY2F0KHZhbHVlcykpO1xufVxuXG52YXIgcG9zaXRpb25NYXAgPSBbJ2Fic29sdXRlJywgJ2ZpeGVkJywgJ3JlbGF0aXZlJywgJ3N0YXRpYycsICdzdGlja3knXTtcblxuLyoqXG4gKiBTaG9ydGhhbmQgYWNjZXB0cyB1cCB0byBmaXZlIHZhbHVlcywgaW5jbHVkaW5nIG51bGwgdG8gc2tpcCBhIHZhbHVlLCBhbmQgbWFwcyB0aGVtIHRvIHRoZWlyIHJlc3BlY3RpdmUgZGlyZWN0aW9ucy4gVGhlIGZpcnN0IHZhbHVlIGNhbiBvcHRpb25hbGx5IGJlIGEgcG9zaXRpb24ga2V5d29yZC5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLnBvc2l0aW9uKCcxMnB4JywgJzI0cHgnLCAnMzZweCcsICc0OHB4JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtwb3NpdGlvbignMTJweCcsICcyNHB4JywgJzM2cHgnLCAnNDhweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAndG9wJzogJzEycHgnLFxuICogICAncmlnaHQnOiAnMjRweCcsXG4gKiAgICdib3R0b20nOiAnMzZweCcsXG4gKiAgICdsZWZ0JzogJzQ4cHgnXG4gKiB9XG4gKlxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5wb3NpdGlvbignYWJzb2x1dGUnLCAnMTJweCcsICcyNHB4JywgJzM2cHgnLCAnNDhweCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7cG9zaXRpb24oJ2Fic29sdXRlJywgJzEycHgnLCAnMjRweCcsICczNnB4JywgJzQ4cHgnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgJ3Bvc2l0aW9uJzogJ2Fic29sdXRlJyxcbiAqICAgJ3RvcCc6ICcxMnB4JyxcbiAqICAgJ3JpZ2h0JzogJzI0cHgnLFxuICogICAnYm90dG9tJzogJzM2cHgnLFxuICogICAnbGVmdCc6ICc0OHB4J1xuICogfVxuICovXG5mdW5jdGlvbiBwb3NpdGlvbihmaXJzdFZhbHVlKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCB2YWx1ZXMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHZhbHVlc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgaWYgKHBvc2l0aW9uTWFwLmluZGV4T2YoZmlyc3RWYWx1ZSkgPj0gMCAmJiBmaXJzdFZhbHVlKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBkaXJlY3Rpb25hbFByb3BlcnR5LmFwcGx5KHZvaWQgMCwgWycnXS5jb25jYXQodmFsdWVzKSksIHtcbiAgICAgIHBvc2l0aW9uOiBmaXJzdFZhbHVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRpcmVjdGlvbmFsUHJvcGVydHkuYXBwbHkodm9pZCAwLCBbJycsIGZpcnN0VmFsdWVdLmNvbmNhdCh2YWx1ZXMpKTtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0aGFuZCB0byBzZXQgdGhlIGhlaWdodCBhbmQgd2lkdGggcHJvcGVydGllcyBpbiBhIHNpbmdsZSBzdGF0ZW1lbnQuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5zaXplKCczMDBweCcsICcyNTBweCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7c2l6ZSgnMzAwcHgnLCAnMjUwcHgnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgJ2hlaWdodCc6ICczMDBweCcsXG4gKiAgICd3aWR0aCc6ICcyNTBweCcsXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHNpemUoaGVpZ2h0LCB3aWR0aCkge1xuICBpZiAod2lkdGggPT09IHZvaWQgMCkge1xuICAgIHdpZHRoID0gaGVpZ2h0O1xuICB9XG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgd2lkdGg6IHdpZHRoXG4gIH07XG59XG5cbnZhciBzdGF0ZU1hcCA9IFt1bmRlZmluZWQsIG51bGwsICdhY3RpdmUnLCAnZm9jdXMnLCAnaG92ZXInXTtcbmZ1bmN0aW9uIHRlbXBsYXRlKHN0YXRlKSB7XG4gIHJldHVybiBcImlucHV0W3R5cGU9XFxcImNvbG9yXFxcIl1cIiArIHN0YXRlICsgXCIsXFxuICAgIGlucHV0W3R5cGU9XFxcImRhdGVcXFwiXVwiICsgc3RhdGUgKyBcIixcXG4gICAgaW5wdXRbdHlwZT1cXFwiZGF0ZXRpbWVcXFwiXVwiICsgc3RhdGUgKyBcIixcXG4gICAgaW5wdXRbdHlwZT1cXFwiZGF0ZXRpbWUtbG9jYWxcXFwiXVwiICsgc3RhdGUgKyBcIixcXG4gICAgaW5wdXRbdHlwZT1cXFwiZW1haWxcXFwiXVwiICsgc3RhdGUgKyBcIixcXG4gICAgaW5wdXRbdHlwZT1cXFwibW9udGhcXFwiXVwiICsgc3RhdGUgKyBcIixcXG4gICAgaW5wdXRbdHlwZT1cXFwibnVtYmVyXFxcIl1cIiArIHN0YXRlICsgXCIsXFxuICAgIGlucHV0W3R5cGU9XFxcInBhc3N3b3JkXFxcIl1cIiArIHN0YXRlICsgXCIsXFxuICAgIGlucHV0W3R5cGU9XFxcInNlYXJjaFxcXCJdXCIgKyBzdGF0ZSArIFwiLFxcbiAgICBpbnB1dFt0eXBlPVxcXCJ0ZWxcXFwiXVwiICsgc3RhdGUgKyBcIixcXG4gICAgaW5wdXRbdHlwZT1cXFwidGV4dFxcXCJdXCIgKyBzdGF0ZSArIFwiLFxcbiAgICBpbnB1dFt0eXBlPVxcXCJ0aW1lXFxcIl1cIiArIHN0YXRlICsgXCIsXFxuICAgIGlucHV0W3R5cGU9XFxcInVybFxcXCJdXCIgKyBzdGF0ZSArIFwiLFxcbiAgICBpbnB1dFt0eXBlPVxcXCJ3ZWVrXFxcIl1cIiArIHN0YXRlICsgXCIsXFxuICAgIGlucHV0Om5vdChbdHlwZV0pXCIgKyBzdGF0ZSArIFwiLFxcbiAgICB0ZXh0YXJlYVwiICsgc3RhdGU7XG59XG5cbi8qKlxuICogUG9wdWxhdGVzIHNlbGVjdG9ycyB0aGF0IHRhcmdldCBhbGwgdGV4dCBpbnB1dHMuIFlvdSBjYW4gcGFzcyBvcHRpb25hbCBzdGF0ZXMgdG8gYXBwZW5kIHRvIHRoZSBzZWxlY3RvcnMuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBbdGV4dElucHV0cygnYWN0aXZlJyldOiB7XG4gKiAgICAgJ2JvcmRlcic6ICdub25lJ1xuICogICB9XG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgID4gJHt0ZXh0SW5wdXRzKCdhY3RpdmUnKX0ge1xuICogICAgIGJvcmRlcjogbm9uZTtcbiAqICAgfVxuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiAgJ2lucHV0W3R5cGU9XCJjb2xvclwiXTphY3RpdmUsXG4gKiAgaW5wdXRbdHlwZT1cImRhdGVcIl06YWN0aXZlLFxuICogIGlucHV0W3R5cGU9XCJkYXRldGltZVwiXTphY3RpdmUsXG4gKiAgaW5wdXRbdHlwZT1cImRhdGV0aW1lLWxvY2FsXCJdOmFjdGl2ZSxcbiAqICBpbnB1dFt0eXBlPVwiZW1haWxcIl06YWN0aXZlLFxuICogIGlucHV0W3R5cGU9XCJtb250aFwiXTphY3RpdmUsXG4gKiAgaW5wdXRbdHlwZT1cIm51bWJlclwiXTphY3RpdmUsXG4gKiAgaW5wdXRbdHlwZT1cInBhc3N3b3JkXCJdOmFjdGl2ZSxcbiAqICBpbnB1dFt0eXBlPVwic2VhcmNoXCJdOmFjdGl2ZSxcbiAqICBpbnB1dFt0eXBlPVwidGVsXCJdOmFjdGl2ZSxcbiAqICBpbnB1dFt0eXBlPVwidGV4dFwiXTphY3RpdmUsXG4gKiAgaW5wdXRbdHlwZT1cInRpbWVcIl06YWN0aXZlLFxuICogIGlucHV0W3R5cGU9XCJ1cmxcIl06YWN0aXZlLFxuICogIGlucHV0W3R5cGU9XCJ3ZWVrXCJdOmFjdGl2ZSxcbiAqICBpbnB1dDpub3QoW3R5cGVdKTphY3RpdmUsXG4gKiAgdGV4dGFyZWE6YWN0aXZlJzoge1xuICogICAnYm9yZGVyJzogJ25vbmUnXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHRleHRJbnB1dHMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzdGF0ZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgc3RhdGVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIHJldHVybiBzdGF0ZWZ1bFNlbGVjdG9ycyhzdGF0ZXMsIHRlbXBsYXRlLCBzdGF0ZU1hcCk7XG59XG5cbi8qKlxuICogQWNjZXB0cyBhbnkgbnVtYmVyIG9mIHRyYW5zaXRpb24gdmFsdWVzIGFzIHBhcmFtZXRlcnMgZm9yIGNyZWF0aW5nIGEgc2luZ2xlIHRyYW5zaXRpb24gc3RhdGVtZW50LiBZb3UgbWF5IGFsc28gcGFzcyBhbiBhcnJheSBvZiBwcm9wZXJ0aWVzIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIgdGhhdCB5b3Ugd291bGQgbGlrZSB0byBhcHBseSB0aGUgc2FtZSB0cmFuc2l0aW9uIHZhbHVlcyB0byAoc2Vjb25kIHBhcmFtZXRlcikuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi50cmFuc2l0aW9ucygnb3BhY2l0eSAxLjBzIGVhc2UtaW4gMHMnLCAnd2lkdGggMi4wcyBlYXNlLWluIDJzJyksXG4gKiAgIC4uLnRyYW5zaXRpb25zKFsnY29sb3InLCAnYmFja2dyb3VuZC1jb2xvciddLCAnMi4wcyBlYXNlLWluIDJzJylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHt0cmFuc2l0aW9ucygnb3BhY2l0eSAxLjBzIGVhc2UtaW4gMHMnLCAnd2lkdGggMi4wcyBlYXNlLWluIDJzJyl9O1xuICogICAke3RyYW5zaXRpb25zKFsnY29sb3InLCAnYmFja2dyb3VuZC1jb2xvciddLCAnMi4wcyBlYXNlLWluIDJzJyksfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgJ3RyYW5zaXRpb24nOiAnb3BhY2l0eSAxLjBzIGVhc2UtaW4gMHMsIHdpZHRoIDIuMHMgZWFzZS1pbiAycydcbiAqICAgJ3RyYW5zaXRpb24nOiAnY29sb3IgMi4wcyBlYXNlLWluIDJzLCBiYWNrZ3JvdW5kLWNvbG9yIDIuMHMgZWFzZS1pbiAycycsXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHRyYW5zaXRpb25zKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcHJvcGVydGllcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBwcm9wZXJ0aWVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BlcnRpZXNbMF0pICYmIHByb3BlcnRpZXMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvcGVydGllc1sxXTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNjEpO1xuICAgIH1cbiAgICB2YXIgdHJhbnNpdGlvbnNTdHJpbmcgPSBwcm9wZXJ0aWVzWzBdLm1hcChmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiBwcm9wZXJ0eSArIFwiIFwiICsgdmFsdWU7XG4gICAgfSkuam9pbignLCAnKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbnNTdHJpbmdcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICB0cmFuc2l0aW9uOiBwcm9wZXJ0aWVzLmpvaW4oJywgJylcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCB7IGN1cnJpZWRBZGp1c3RIdWUkMSBhcyBhZGp1c3RIdWUsIGFuaW1hdGlvbiwgYmFja2dyb3VuZEltYWdlcywgYmFja2dyb3VuZHMsIGJldHdlZW4sIGJvcmRlciwgYm9yZGVyQ29sb3IsIGJvcmRlclJhZGl1cywgYm9yZGVyU3R5bGUsIGJvcmRlcldpZHRoLCBidXR0b25zLCBjbGVhckZpeCwgY29tcGxlbWVudCwgY292ZXIsIGNzc1ZhciwgY3VycmllZERhcmtlbiQxIGFzIGRhcmtlbiwgY3VycmllZERlc2F0dXJhdGUkMSBhcyBkZXNhdHVyYXRlLCBkaXJlY3Rpb25hbFByb3BlcnR5LCBlYXNlSW4sIGVhc2VJbk91dCwgZWFzZU91dCwgZWxsaXBzaXMsIGVtJDEgYXMgZW0sIGZsdWlkUmFuZ2UsIGZvbnRGYWNlLCBnZXRDb250cmFzdCwgZ2V0THVtaW5hbmNlLCBnZXRWYWx1ZUFuZFVuaXQsIGdyYXlzY2FsZSwgaGlEUEksIGhpZGVUZXh0LCBoaWRlVmlzdWFsbHksIGhzbCwgaHNsVG9Db2xvclN0cmluZywgaHNsYSwgaW1wb3J0YW50LCBpbnZlcnQsIGN1cnJpZWRMaWdodGVuJDEgYXMgbGlnaHRlbiwgbGluZWFyR3JhZGllbnQsIG1hcmdpbiwgbWF0aCwgbWVldHNDb250cmFzdEd1aWRlbGluZXMsIG1peCQxIGFzIG1peCwgbW9kdWxhclNjYWxlLCBub3JtYWxpemUsIGN1cnJpZWRPcGFjaWZ5JDEgYXMgb3BhY2lmeSwgcGFkZGluZywgcGFyc2VUb0hzbCwgcGFyc2VUb1JnYiwgcG9zaXRpb24sIHJhZGlhbEdyYWRpZW50LCByZWFkYWJsZUNvbG9yLCByZW0kMSBhcyByZW0sIHJlbVRvUHgsIHJldGluYUltYWdlLCByZ2IsIHJnYlRvQ29sb3JTdHJpbmcsIHJnYmEsIGN1cnJpZWRTYXR1cmF0ZSQxIGFzIHNhdHVyYXRlLCBjdXJyaWVkU2V0SHVlJDEgYXMgc2V0SHVlLCBjdXJyaWVkU2V0TGlnaHRuZXNzJDEgYXMgc2V0TGlnaHRuZXNzLCBjdXJyaWVkU2V0U2F0dXJhdGlvbiQxIGFzIHNldFNhdHVyYXRpb24sIGN1cnJpZWRTaGFkZSQxIGFzIHNoYWRlLCBzaXplLCBzdHJpcFVuaXQsIHRleHRJbnB1dHMsIHRpbWluZ0Z1bmN0aW9ucywgY3VycmllZFRpbnQkMSBhcyB0aW50LCB0b0NvbG9yU3RyaW5nLCB0cmFuc2l0aW9ucywgY3VycmllZFRyYW5zcGFyZW50aXplJDEgYXMgdHJhbnNwYXJlbnRpemUsIHRyaWFuZ2xlLCB3b3JkV3JhcCB9O1xuIl0sIm5hbWVzIjpbIl9leHRlbmRzIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIl9pbmhlcml0c0xvb3NlIiwiX3dyYXBOYXRpdmVTdXBlciIsIl90YWdnZWRUZW1wbGF0ZUxpdGVyYWxMb29zZSIsImxhc3QiLCJfcmVmIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwibmVnYXRpb24iLCJhIiwiYWRkaXRpb24iLCJiIiwic3VidHJhY3Rpb24iLCJtdWx0aXBsaWNhdGlvbiIsImRpdmlzaW9uIiwibWF4IiwiTWF0aCIsImFwcGx5IiwibWluIiwiY29tbWEiLCJBcnJheSIsIm9mIiwiZGVmYXVsdFN5bWJvbHMiLCJzeW1ib2xzIiwiaW5maXgiLCJzeW1ib2wiLCJmIiwibm90YXRpb24iLCJwcmVjZWRlbmNlIiwicmlnaHRUb0xlZnQiLCJhcmdDb3VudCIsInJlZ1N5bWJvbCIsInByZWZpeCIsInBvc3RmaXgiLCJmdW5jIiwiZGVmYXVsdFN5bWJvbE1hcCIsIkVSUk9SUyIsImZvcm1hdCIsIl9sZW4iLCJhcmdzIiwiX2tleSIsImMiLCJwdXNoIiwiZm9yRWFjaCIsImQiLCJyZXBsYWNlIiwiUG9saXNoZWRFcnJvciIsIl9FcnJvciIsImNvZGUiLCJfdGhpcyIsInByb2Nlc3MiLCJjYWxsIiwiX2xlbjIiLCJfa2V5MiIsImNvbmNhdCIsIkVycm9yIiwidW5pdFJlZ0V4cCIsIm1lcmdlU3ltYm9sTWFwcyIsImFkZGl0aW9uYWxTeW1ib2xzIiwic3ltYm9sTWFwIiwiZXhlYyIsIm9wZXJhdG9ycyIsInZhbHVlcyIsIm9wIiwicG9wIiwic3BsaWNlIiwiY2FsY3VsYXRlIiwiZXhwcmVzc2lvbiIsIm1hdGNoIiwicGF0dGVybiIsIlJlZ0V4cCIsIk9iamVjdCIsImtleXMiLCJtYXAiLCJrZXkiLCJzb3J0IiwidmFsIiwiam9pbiIsImxhc3RJbmRleCIsImFmdGVyVmFsdWUiLCJfcmVmMiIsInRva2VuIiwiYmFkIiwibm90TnVtYmVyIiwibm90TmV3VmFsdWUiLCJub3RBZnRlclZhbHVlIiwiaW5kZXgiLCJjdXJyIiwicHJldiIsInJldmVyc2VTdHJpbmciLCJzdHIiLCJzcGxpdCIsInJldmVyc2UiLCJtYXRoIiwiZm9ybXVsYSIsInJldmVyc2VkRm9ybXVsYSIsImZvcm11bGFNYXRjaCIsImV2ZXJ5IiwidW5pdCIsImNsZWFuRm9ybXVsYSIsImNzc1ZhcmlhYmxlUmVnZXgiLCJjc3NWYXIiLCJjc3NWYXJpYWJsZSIsImRlZmF1bHRWYWx1ZSIsInZhcmlhYmxlVmFsdWUiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwidHJpbSIsImNhcGl0YWxpemVTdHJpbmciLCJzdHJpbmciLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwicG9zaXRpb25NYXAkMSIsImdlbmVyYXRlUHJvcGVydHkiLCJwcm9wZXJ0eSIsInBvc2l0aW9uIiwidG9Mb3dlckNhc2UiLCJzcGxpdFByb3BlcnR5IiwicmVkdWNlIiwiYWNjIiwiam9pbmVkUHJvcGVydHkiLCJnZW5lcmF0ZVN0eWxlcyIsInZhbHVlc1dpdGhEZWZhdWx0cyIsInN0eWxlcyIsImkiLCJkaXJlY3Rpb25hbFByb3BlcnR5IiwiZmlyc3RWYWx1ZSIsIl92YWx1ZXMkIiwic2Vjb25kVmFsdWUiLCJfdmFsdWVzJDIiLCJ0aGlyZFZhbHVlIiwiX3ZhbHVlcyQzIiwiZm91cnRoVmFsdWUiLCJlbmRzV2l0aCIsInN1ZmZpeCIsInN1YnN0ciIsImNzc1JlZ2V4JDEiLCJzdHJpcFVuaXQiLCJ2YWx1ZSIsIm1hdGNoZWRWYWx1ZSIsInBhcnNlRmxvYXQiLCJweHRvRmFjdG9yeSIsInRvIiwicHh2YWwiLCJiYXNlIiwibmV3UHh2YWwiLCJuZXdCYXNlIiwicGl4ZWxzdG8iLCJlbSIsImVtJDEiLCJjc3NSZWdleCIsImdldFZhbHVlQW5kVW5pdCIsImltcG9ydGFudCIsInN0eWxlQmxvY2siLCJydWxlcyIsIm5ld1N0eWxlQmxvY2siLCJpbmRleE9mIiwicmF0aW9OYW1lcyIsIm1pbm9yU2Vjb25kIiwibWFqb3JTZWNvbmQiLCJtaW5vclRoaXJkIiwibWFqb3JUaGlyZCIsInBlcmZlY3RGb3VydGgiLCJhdWdGb3VydGgiLCJwZXJmZWN0RmlmdGgiLCJtaW5vclNpeHRoIiwiZ29sZGVuU2VjdGlvbiIsIm1ham9yU2l4dGgiLCJtaW5vclNldmVudGgiLCJtYWpvclNldmVudGgiLCJvY3RhdmUiLCJtYWpvclRlbnRoIiwibWFqb3JFbGV2ZW50aCIsIm1ham9yVHdlbGZ0aCIsImRvdWJsZU9jdGF2ZSIsImdldFJhdGlvIiwicmF0aW9OYW1lIiwibW9kdWxhclNjYWxlIiwic3RlcHMiLCJyYXRpbyIsInJlYWxCYXNlIiwicmVhbFJhdGlvIiwicG93IiwicmVtIiwicmVtJDEiLCJkZWZhdWx0Rm9udFNpemUiLCJjb252ZXJ0QmFzZSIsImRlY29uc3RydWN0ZWRWYWx1ZSIsImdldEJhc2VGcm9tRG9jIiwicm9vdEZvbnRTaXplIiwiZm9udFNpemUiLCJyZW1Ub1B4IiwiZnVuY3Rpb25zTWFwJDMiLCJiYWNrIiwiY2lyYyIsImN1YmljIiwiZXhwbyIsInF1YWQiLCJxdWFydCIsInF1aW50Iiwic2luZSIsImVhc2VJbiIsImZ1bmN0aW9uTmFtZSIsImZ1bmN0aW9uc01hcCQyIiwiZWFzZUluT3V0IiwiZnVuY3Rpb25zTWFwJDEiLCJlYXNlT3V0IiwiYmV0d2VlbiIsImZyb21TaXplIiwidG9TaXplIiwibWluU2NyZWVuIiwibWF4U2NyZWVuIiwiX2dldFZhbHVlQW5kVW5pdCIsInVuaXRsZXNzRnJvbVNpemUiLCJmcm9tU2l6ZVVuaXQiLCJfZ2V0VmFsdWVBbmRVbml0MiIsInVuaXRsZXNzVG9TaXplIiwidG9TaXplVW5pdCIsIl9nZXRWYWx1ZUFuZFVuaXQzIiwidW5pdGxlc3NNaW5TY3JlZW4iLCJtaW5TY3JlZW5Vbml0IiwiX2dldFZhbHVlQW5kVW5pdDQiLCJ1bml0bGVzc01heFNjcmVlbiIsIm1heFNjcmVlblVuaXQiLCJzbG9wZSIsInRvRml4ZWQiLCJjbGVhckZpeCIsInBhcmVudCIsInBzZXVkb1NlbGVjdG9yIiwiY2xlYXIiLCJjb250ZW50IiwiZGlzcGxheSIsImNvdmVyIiwib2Zmc2V0IiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0IiwiZWxsaXBzaXMiLCJ3aWR0aCIsImxpbmVzIiwibWF4V2lkdGgiLCJvdmVyZmxvdyIsInRleHRPdmVyZmxvdyIsIndoaXRlU3BhY2UiLCJ3b3JkV3JhcCIsIldlYmtpdEJveE9yaWVudCIsIldlYmtpdExpbmVDbGFtcCIsIl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UiLCJvIiwiYWxsb3dBcnJheUxpa2UiLCJpdCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwibmV4dCIsImJpbmQiLCJpc0FycmF5IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiZG9uZSIsIlR5cGVFcnJvciIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwibiIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiZnJvbSIsInRlc3QiLCJhcnIiLCJsZW4iLCJhcnIyIiwiZmx1aWRSYW5nZSIsImNzc1Byb3AiLCJtZWRpYVF1ZXJpZXMiLCJmYWxsYmFja3MiLCJfaXRlcmF0b3IiLCJfc3RlcCIsIl9leHRlbmRzMiIsIl9leHRlbmRzMyIsIm9iaiIsInByb3AiLCJfcmVmMyIsImRhdGFVUklSZWdleCIsImZvcm1hdEhpbnRNYXAiLCJ3b2ZmIiwid29mZjIiLCJ0dGYiLCJvdGYiLCJlb3QiLCJzdmciLCJzdmd6IiwiZ2VuZXJhdGVGb3JtYXRIaW50IiwiZm9ybWF0SGludCIsImlzRGF0YVVSSSIsImZvbnRGaWxlUGF0aCIsImdlbmVyYXRlRmlsZVJlZmVyZW5jZXMiLCJmaWxlRm9ybWF0cyIsImZpbGVGb250UmVmZXJlbmNlcyIsImdlbmVyYXRlTG9jYWxSZWZlcmVuY2VzIiwibG9jYWxGb250cyIsImxvY2FsRm9udFJlZmVyZW5jZXMiLCJmb250IiwiZ2VuZXJhdGVTb3VyY2VzIiwiZm9udFJlZmVyZW5jZXMiLCJmb250RmFjZSIsImZvbnRGYW1pbHkiLCJmb250U3RyZXRjaCIsImZvbnRTdHlsZSIsImZvbnRWYXJpYW50IiwiZm9udFdlaWdodCIsIl9yZWYkZmlsZUZvcm1hdHMiLCJfcmVmJGZvcm1hdEhpbnQiLCJfcmVmJGxvY2FsRm9udHMiLCJ1bmljb2RlUmFuZ2UiLCJmb250RGlzcGxheSIsImZvbnRWYXJpYXRpb25TZXR0aW5ncyIsImZvbnRGZWF0dXJlU2V0dGluZ3MiLCJmb250RmFjZURlY2xhcmF0aW9uIiwic3JjIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiaGlkZVRleHQiLCJ0ZXh0SW5kZW50IiwiaGlkZVZpc3VhbGx5IiwiYm9yZGVyIiwiY2xpcCIsImhlaWdodCIsIm1hcmdpbiIsInBhZGRpbmciLCJoaURQSSIsInJvdW5kIiwiY29uc3RydWN0R3JhZGllbnRWYWx1ZSIsImxpdGVyYWxzIiwidGVtcGxhdGUiLCJzdWJzdGl0dXRpb25zIiwiZGVmaW5lZFZhbHVlcyIsImZpbHRlciIsInN1YnN0aXR1dGUiLCJfdGVtcGxhdGVPYmplY3QkMSIsImxpbmVhckdyYWRpZW50IiwiY29sb3JTdG9wcyIsImZhbGxiYWNrIiwiX3JlZiR0b0RpcmVjdGlvbiIsInRvRGlyZWN0aW9uIiwiYmFja2dyb3VuZENvbG9yIiwiYmFja2dyb3VuZEltYWdlIiwibm9ybWFsaXplIiwiaHRtbCIsImxpbmVIZWlnaHQiLCJ0ZXh0U2l6ZUFkanVzdCIsImJvZHkiLCJtYWluIiwiaDEiLCJociIsImJveFNpemluZyIsInByZSIsImJvcmRlckJvdHRvbSIsInRleHREZWNvcmF0aW9uIiwic21hbGwiLCJ2ZXJ0aWNhbEFsaWduIiwic3ViIiwic3VwIiwiaW1nIiwiYm9yZGVyU3R5bGUiLCJ0ZXh0VHJhbnNmb3JtIiwiV2Via2l0QXBwZWFyYW5jZSIsIm91dGxpbmUiLCJmaWVsZHNldCIsImxlZ2VuZCIsImNvbG9yIiwicHJvZ3Jlc3MiLCJ0ZXh0YXJlYSIsIm91dGxpbmVPZmZzZXQiLCJkZXRhaWxzIiwic3VtbWFyeSIsIl90ZW1wbGF0ZU9iamVjdCIsInJhZGlhbEdyYWRpZW50IiwiX3JlZiRleHRlbnQiLCJleHRlbnQiLCJfcmVmJHBvc2l0aW9uIiwiX3JlZiRzaGFwZSIsInNoYXBlIiwicmV0aW5hSW1hZ2UiLCJmaWxlbmFtZSIsImJhY2tncm91bmRTaXplIiwiZXh0ZW5zaW9uIiwicmV0aW5hRmlsZW5hbWUiLCJyZXRpbmFTdWZmaXgiLCJleHQiLCJyRmlsZW5hbWUiLCJmdW5jdGlvbnNNYXAiLCJlYXNlSW5CYWNrIiwiZWFzZUluQ2lyYyIsImVhc2VJbkN1YmljIiwiZWFzZUluRXhwbyIsImVhc2VJblF1YWQiLCJlYXNlSW5RdWFydCIsImVhc2VJblF1aW50IiwiZWFzZUluU2luZSIsImVhc2VPdXRCYWNrIiwiZWFzZU91dEN1YmljIiwiZWFzZU91dENpcmMiLCJlYXNlT3V0RXhwbyIsImVhc2VPdXRRdWFkIiwiZWFzZU91dFF1YXJ0IiwiZWFzZU91dFF1aW50IiwiZWFzZU91dFNpbmUiLCJlYXNlSW5PdXRCYWNrIiwiZWFzZUluT3V0Q2lyYyIsImVhc2VJbk91dEN1YmljIiwiZWFzZUluT3V0RXhwbyIsImVhc2VJbk91dFF1YWQiLCJlYXNlSW5PdXRRdWFydCIsImVhc2VJbk91dFF1aW50IiwiZWFzZUluT3V0U2luZSIsImdldFRpbWluZ0Z1bmN0aW9uIiwidGltaW5nRnVuY3Rpb25zIiwidGltaW5nRnVuY3Rpb24iLCJnZXRCb3JkZXJXaWR0aCIsInBvaW50aW5nRGlyZWN0aW9uIiwiZnVsbFdpZHRoIiwiaGFsZldpZHRoIiwiZnVsbEhlaWdodCIsImhhbGZIZWlnaHQiLCJnZXRCb3JkZXJDb2xvciIsImZvcmVncm91bmRDb2xvciIsImJvcmRlckJvdHRvbUNvbG9yIiwiYm9yZGVyTGVmdENvbG9yIiwiYm9yZGVyVG9wQ29sb3IiLCJib3JkZXJSaWdodENvbG9yIiwidHJpYW5nbGUiLCJfcmVmJGJhY2tncm91bmRDb2xvciIsIndpZHRoQW5kVW5pdCIsImhlaWdodEFuZFVuaXQiLCJpc05hTiIsImJvcmRlckNvbG9yIiwiYm9yZGVyV2lkdGgiLCJ3cmFwIiwid29yZEJyZWFrIiwib3ZlcmZsb3dXcmFwIiwiY29sb3JUb0ludCIsImNvbnZlcnRUb0ludCIsInJlZCIsImdyZWVuIiwiYmx1ZSIsImhzbFRvUmdiIiwiaHVlIiwic2F0dXJhdGlvbiIsImxpZ2h0bmVzcyIsImNvbnZlcnQiLCJodWVQcmltZSIsImNocm9tYSIsImFicyIsInNlY29uZENvbXBvbmVudCIsImxpZ2h0bmVzc01vZGlmaWNhdGlvbiIsImZpbmFsUmVkIiwiZmluYWxHcmVlbiIsImZpbmFsQmx1ZSIsIm5hbWVkQ29sb3JNYXAiLCJhbGljZWJsdWUiLCJhbnRpcXVld2hpdGUiLCJhcXVhIiwiYXF1YW1hcmluZSIsImF6dXJlIiwiYmVpZ2UiLCJiaXNxdWUiLCJibGFjayIsImJsYW5jaGVkYWxtb25kIiwiYmx1ZXZpb2xldCIsImJyb3duIiwiYnVybHl3b29kIiwiY2FkZXRibHVlIiwiY2hhcnRyZXVzZSIsImNob2NvbGF0ZSIsImNvcmFsIiwiY29ybmZsb3dlcmJsdWUiLCJjb3Juc2lsayIsImNyaW1zb24iLCJjeWFuIiwiZGFya2JsdWUiLCJkYXJrY3lhbiIsImRhcmtnb2xkZW5yb2QiLCJkYXJrZ3JheSIsImRhcmtncmVlbiIsImRhcmtncmV5IiwiZGFya2toYWtpIiwiZGFya21hZ2VudGEiLCJkYXJrb2xpdmVncmVlbiIsImRhcmtvcmFuZ2UiLCJkYXJrb3JjaGlkIiwiZGFya3JlZCIsImRhcmtzYWxtb24iLCJkYXJrc2VhZ3JlZW4iLCJkYXJrc2xhdGVibHVlIiwiZGFya3NsYXRlZ3JheSIsImRhcmtzbGF0ZWdyZXkiLCJkYXJrdHVycXVvaXNlIiwiZGFya3Zpb2xldCIsImRlZXBwaW5rIiwiZGVlcHNreWJsdWUiLCJkaW1ncmF5IiwiZGltZ3JleSIsImRvZGdlcmJsdWUiLCJmaXJlYnJpY2siLCJmbG9yYWx3aGl0ZSIsImZvcmVzdGdyZWVuIiwiZnVjaHNpYSIsImdhaW5zYm9ybyIsImdob3N0d2hpdGUiLCJnb2xkIiwiZ29sZGVucm9kIiwiZ3JheSIsImdyZWVueWVsbG93IiwiZ3JleSIsImhvbmV5ZGV3IiwiaG90cGluayIsImluZGlhbnJlZCIsImluZGlnbyIsIml2b3J5Iiwia2hha2kiLCJsYXZlbmRlciIsImxhdmVuZGVyYmx1c2giLCJsYXduZ3JlZW4iLCJsZW1vbmNoaWZmb24iLCJsaWdodGJsdWUiLCJsaWdodGNvcmFsIiwibGlnaHRjeWFuIiwibGlnaHRnb2xkZW5yb2R5ZWxsb3ciLCJsaWdodGdyYXkiLCJsaWdodGdyZWVuIiwibGlnaHRncmV5IiwibGlnaHRwaW5rIiwibGlnaHRzYWxtb24iLCJsaWdodHNlYWdyZWVuIiwibGlnaHRza3libHVlIiwibGlnaHRzbGF0ZWdyYXkiLCJsaWdodHNsYXRlZ3JleSIsImxpZ2h0c3RlZWxibHVlIiwibGlnaHR5ZWxsb3ciLCJsaW1lIiwibGltZWdyZWVuIiwibGluZW4iLCJtYWdlbnRhIiwibWFyb29uIiwibWVkaXVtYXF1YW1hcmluZSIsIm1lZGl1bWJsdWUiLCJtZWRpdW1vcmNoaWQiLCJtZWRpdW1wdXJwbGUiLCJtZWRpdW1zZWFncmVlbiIsIm1lZGl1bXNsYXRlYmx1ZSIsIm1lZGl1bXNwcmluZ2dyZWVuIiwibWVkaXVtdHVycXVvaXNlIiwibWVkaXVtdmlvbGV0cmVkIiwibWlkbmlnaHRibHVlIiwibWludGNyZWFtIiwibWlzdHlyb3NlIiwibW9jY2FzaW4iLCJuYXZham93aGl0ZSIsIm5hdnkiLCJvbGRsYWNlIiwib2xpdmUiLCJvbGl2ZWRyYWIiLCJvcmFuZ2UiLCJvcmFuZ2VyZWQiLCJvcmNoaWQiLCJwYWxlZ29sZGVucm9kIiwicGFsZWdyZWVuIiwicGFsZXR1cnF1b2lzZSIsInBhbGV2aW9sZXRyZWQiLCJwYXBheWF3aGlwIiwicGVhY2hwdWZmIiwicGVydSIsInBpbmsiLCJwbHVtIiwicG93ZGVyYmx1ZSIsInB1cnBsZSIsInJlYmVjY2FwdXJwbGUiLCJyb3N5YnJvd24iLCJyb3lhbGJsdWUiLCJzYWRkbGVicm93biIsInNhbG1vbiIsInNhbmR5YnJvd24iLCJzZWFncmVlbiIsInNlYXNoZWxsIiwic2llbm5hIiwic2lsdmVyIiwic2t5Ymx1ZSIsInNsYXRlYmx1ZSIsInNsYXRlZ3JheSIsInNsYXRlZ3JleSIsInNub3ciLCJzcHJpbmdncmVlbiIsInN0ZWVsYmx1ZSIsInRhbiIsInRlYWwiLCJ0aGlzdGxlIiwidG9tYXRvIiwidHVycXVvaXNlIiwidmlvbGV0Iiwid2hlYXQiLCJ3aGl0ZSIsIndoaXRlc21va2UiLCJ5ZWxsb3ciLCJ5ZWxsb3dncmVlbiIsIm5hbWVUb0hleCIsIm5vcm1hbGl6ZWRDb2xvck5hbWUiLCJoZXhSZWdleCIsImhleFJnYmFSZWdleCIsInJlZHVjZWRIZXhSZWdleCIsInJlZHVjZWRSZ2JhSGV4UmVnZXgiLCJyZ2JSZWdleCIsInJnYmFSZWdleCIsImhzbFJlZ2V4IiwiaHNsYVJlZ2V4IiwicGFyc2VUb1JnYiIsIm5vcm1hbGl6ZWRDb2xvciIsInBhcnNlSW50IiwiYWxwaGEiLCJfYWxwaGEiLCJyZ2JNYXRjaGVkIiwicmdiYU1hdGNoZWQiLCJzdWJzdHJpbmciLCJoc2xNYXRjaGVkIiwicmdiQ29sb3JTdHJpbmciLCJoc2xSZ2JNYXRjaGVkIiwiaHNsYU1hdGNoZWQiLCJfaHVlIiwiX3NhdHVyYXRpb24iLCJfbGlnaHRuZXNzIiwiX3JnYkNvbG9yU3RyaW5nIiwiX2hzbFJnYk1hdGNoZWQiLCJyZ2JUb0hzbCIsImRlbHRhIiwicGFyc2VUb0hzbCIsInJlZHVjZUhleFZhbHVlIiwicmVkdWNlSGV4VmFsdWUkMSIsIm51bWJlclRvSGV4IiwiaGV4IiwiY29sb3JUb0hleCIsImNvbnZlcnRUb0hleCIsImhzbFRvSGV4IiwiaHNsIiwiaHNsYSIsInJnYiIsInJnYmEiLCJyZ2JWYWx1ZSIsImlzUmdiIiwiaXNSZ2JhIiwiaXNIc2wiLCJpc0hzbGEiLCJ0b0NvbG9yU3RyaW5nIiwiY3VycmllZCIsImZuIiwiY29tYmluZWQiLCJjdXJyeSIsImFkanVzdEh1ZSIsImRlZ3JlZSIsImhzbENvbG9yIiwiY3VycmllZEFkanVzdEh1ZSIsImN1cnJpZWRBZGp1c3RIdWUkMSIsImNvbXBsZW1lbnQiLCJndWFyZCIsImxvd2VyQm91bmRhcnkiLCJ1cHBlckJvdW5kYXJ5IiwiZGFya2VuIiwiYW1vdW50IiwiY3VycmllZERhcmtlbiIsImN1cnJpZWREYXJrZW4kMSIsImRlc2F0dXJhdGUiLCJjdXJyaWVkRGVzYXR1cmF0ZSIsImN1cnJpZWREZXNhdHVyYXRlJDEiLCJnZXRMdW1pbmFuY2UiLCJyZ2JDb2xvciIsIl9PYmplY3Qka2V5cyRtYXAiLCJjaGFubmVsIiwiciIsImciLCJnZXRDb250cmFzdCIsImNvbG9yMSIsImNvbG9yMiIsImx1bWluYW5jZTEiLCJsdW1pbmFuY2UyIiwiZ3JheXNjYWxlIiwiaHNsVG9Db2xvclN0cmluZyIsImludmVydCIsImxpZ2h0ZW4iLCJjdXJyaWVkTGlnaHRlbiIsImN1cnJpZWRMaWdodGVuJDEiLCJtZWV0c0NvbnRyYXN0R3VpZGVsaW5lcyIsImNvbnRyYXN0UmF0aW8iLCJBQSIsIkFBTGFyZ2UiLCJBQUEiLCJBQUFMYXJnZSIsIm1peCIsIndlaWdodCIsIm90aGVyQ29sb3IiLCJwYXJzZWRDb2xvcjEiLCJwYXJzZWRDb2xvcjIiLCJhbHBoYURlbHRhIiwieCIsInkiLCJ6Iiwid2VpZ2h0MSIsIndlaWdodDIiLCJtaXhlZENvbG9yIiwiZmxvb3IiLCJjdXJyaWVkTWl4IiwibWl4JDEiLCJvcGFjaWZ5IiwicGFyc2VkQ29sb3IiLCJjb2xvcldpdGhBbHBoYSIsImN1cnJpZWRPcGFjaWZ5IiwiY3VycmllZE9wYWNpZnkkMSIsImRlZmF1bHRSZXR1cm5JZkxpZ2h0Q29sb3IiLCJkZWZhdWx0UmV0dXJuSWZEYXJrQ29sb3IiLCJyZWFkYWJsZUNvbG9yIiwicmV0dXJuSWZMaWdodENvbG9yIiwicmV0dXJuSWZEYXJrQ29sb3IiLCJzdHJpY3QiLCJpc0NvbG9yTGlnaHQiLCJwcmVmZXJyZWRSZXR1cm5Db2xvciIsInJnYlRvQ29sb3JTdHJpbmciLCJzYXR1cmF0ZSIsImN1cnJpZWRTYXR1cmF0ZSIsImN1cnJpZWRTYXR1cmF0ZSQxIiwic2V0SHVlIiwiY3VycmllZFNldEh1ZSIsImN1cnJpZWRTZXRIdWUkMSIsInNldExpZ2h0bmVzcyIsImN1cnJpZWRTZXRMaWdodG5lc3MiLCJjdXJyaWVkU2V0TGlnaHRuZXNzJDEiLCJzZXRTYXR1cmF0aW9uIiwiY3VycmllZFNldFNhdHVyYXRpb24iLCJjdXJyaWVkU2V0U2F0dXJhdGlvbiQxIiwic2hhZGUiLCJwZXJjZW50YWdlIiwiY3VycmllZFNoYWRlIiwiY3VycmllZFNoYWRlJDEiLCJ0aW50IiwiY3VycmllZFRpbnQiLCJjdXJyaWVkVGludCQxIiwidHJhbnNwYXJlbnRpemUiLCJjdXJyaWVkVHJhbnNwYXJlbnRpemUiLCJjdXJyaWVkVHJhbnNwYXJlbnRpemUkMSIsImFuaW1hdGlvbiIsIm11bHRpTW9kZSIsImFyZyIsImJhY2tncm91bmRJbWFnZXMiLCJwcm9wZXJ0aWVzIiwiYmFja2dyb3VuZHMiLCJiYWNrZ3JvdW5kIiwic2lkZU1hcCIsInNpZGVLZXl3b3JkIiwidW5zaGlmdCIsImJvcmRlclJhZGl1cyIsInNpZGUiLCJyYWRpdXMiLCJ1cHBlcmNhc2VTaWRlIiwiZ2VuZXJhdGVTZWxlY3RvcnMiLCJzdGF0ZSIsInN0YXRlU3VmZml4Iiwic3RhdGVmdWxTZWxlY3RvcnMiLCJzdGF0ZXMiLCJzdGF0ZU1hcCIsInNlbGVjdG9ycyIsInN0YXRlTWFwJDEiLCJ0ZW1wbGF0ZSQxIiwiYnV0dG9ucyIsInBvc2l0aW9uTWFwIiwic2l6ZSIsInRleHRJbnB1dHMiLCJ0cmFuc2l0aW9ucyIsInRyYW5zaXRpb25zU3RyaW5nIiwidHJhbnNpdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/polished/dist/polished.esm.js\n");

/***/ })

};
;
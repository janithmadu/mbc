"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@codemirror";
exports.ids = ["vendor-chunks/@codemirror"];
exports.modules = {

/***/ "(ssr)/./node_modules/@codemirror/autocomplete/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@codemirror/autocomplete/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CompletionContext: () => (/* binding */ CompletionContext),\n/* harmony export */   acceptCompletion: () => (/* binding */ acceptCompletion),\n/* harmony export */   autocompletion: () => (/* binding */ autocompletion),\n/* harmony export */   clearSnippet: () => (/* binding */ clearSnippet),\n/* harmony export */   closeBrackets: () => (/* binding */ closeBrackets),\n/* harmony export */   closeBracketsKeymap: () => (/* binding */ closeBracketsKeymap),\n/* harmony export */   closeCompletion: () => (/* binding */ closeCompletion),\n/* harmony export */   completeAnyWord: () => (/* binding */ completeAnyWord),\n/* harmony export */   completeFromList: () => (/* binding */ completeFromList),\n/* harmony export */   completionKeymap: () => (/* binding */ completionKeymap),\n/* harmony export */   completionStatus: () => (/* binding */ completionStatus),\n/* harmony export */   currentCompletions: () => (/* binding */ currentCompletions),\n/* harmony export */   deleteBracketPair: () => (/* binding */ deleteBracketPair),\n/* harmony export */   hasNextSnippetField: () => (/* binding */ hasNextSnippetField),\n/* harmony export */   hasPrevSnippetField: () => (/* binding */ hasPrevSnippetField),\n/* harmony export */   ifIn: () => (/* binding */ ifIn),\n/* harmony export */   ifNotIn: () => (/* binding */ ifNotIn),\n/* harmony export */   insertBracket: () => (/* binding */ insertBracket),\n/* harmony export */   insertCompletionText: () => (/* binding */ insertCompletionText),\n/* harmony export */   moveCompletionSelection: () => (/* binding */ moveCompletionSelection),\n/* harmony export */   nextSnippetField: () => (/* binding */ nextSnippetField),\n/* harmony export */   pickedCompletion: () => (/* binding */ pickedCompletion),\n/* harmony export */   prevSnippetField: () => (/* binding */ prevSnippetField),\n/* harmony export */   selectedCompletion: () => (/* binding */ selectedCompletion),\n/* harmony export */   selectedCompletionIndex: () => (/* binding */ selectedCompletionIndex),\n/* harmony export */   setSelectedCompletion: () => (/* binding */ setSelectedCompletion),\n/* harmony export */   snippet: () => (/* binding */ snippet),\n/* harmony export */   snippetCompletion: () => (/* binding */ snippetCompletion),\n/* harmony export */   snippetKeymap: () => (/* binding */ snippetKeymap),\n/* harmony export */   startCompletion: () => (/* binding */ startCompletion)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/language */ \"(ssr)/./node_modules/@codemirror/language/dist/index.js\");\n\n\n\n/**\nAn instance of this is passed to completion source functions.\n*/ class CompletionContext {\n    /**\n    Create a new completion context. (Mostly useful for testing\n    completion sources—in the editor, the extension will create\n    these for you.)\n    */ constructor(/**\n    The editor state that the completion happens in.\n    */ state, /**\n    The position at which the completion is happening.\n    */ pos, /**\n    Indicates whether completion was activated explicitly, or\n    implicitly by typing. The usual way to respond to this is to\n    only return completions when either there is part of a\n    completable entity before the cursor, or `explicit` is true.\n    */ explicit){\n        this.state = state;\n        this.pos = pos;\n        this.explicit = explicit;\n        /**\n        @internal\n        */ this.abortListeners = [];\n    }\n    /**\n    Get the extent, content, and (if there is a token) type of the\n    token before `this.pos`.\n    */ tokenBefore(types) {\n        let token = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(this.state).resolveInner(this.pos, -1);\n        while(token && types.indexOf(token.name) < 0)token = token.parent;\n        return token ? {\n            from: token.from,\n            to: this.pos,\n            text: this.state.sliceDoc(token.from, this.pos),\n            type: token.type\n        } : null;\n    }\n    /**\n    Get the match of the given expression directly before the\n    cursor.\n    */ matchBefore(expr) {\n        let line = this.state.doc.lineAt(this.pos);\n        let start = Math.max(line.from, this.pos - 250);\n        let str = line.text.slice(start - line.from, this.pos - line.from);\n        let found = str.search(ensureAnchor(expr, false));\n        return found < 0 ? null : {\n            from: start + found,\n            to: this.pos,\n            text: str.slice(found)\n        };\n    }\n    /**\n    Yields true when the query has been aborted. Can be useful in\n    asynchronous queries to avoid doing work that will be ignored.\n    */ get aborted() {\n        return this.abortListeners == null;\n    }\n    /**\n    Allows you to register abort handlers, which will be called when\n    the query is\n    [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).\n    */ addEventListener(type, listener) {\n        if (type == \"abort\" && this.abortListeners) this.abortListeners.push(listener);\n    }\n}\nfunction toSet(chars) {\n    let flat = Object.keys(chars).join(\"\");\n    let words = /\\w/.test(flat);\n    if (words) flat = flat.replace(/\\w/g, \"\");\n    return `[${words ? \"\\\\w\" : \"\"}${flat.replace(/[^\\w\\s]/g, \"\\\\$&\")}]`;\n}\nfunction prefixMatch(options) {\n    let first = Object.create(null), rest = Object.create(null);\n    for (let { label } of options){\n        first[label[0]] = true;\n        for(let i = 1; i < label.length; i++)rest[label[i]] = true;\n    }\n    let source = toSet(first) + toSet(rest) + \"*$\";\n    return [\n        new RegExp(\"^\" + source),\n        new RegExp(source)\n    ];\n}\n/**\nGiven a a fixed array of options, return an autocompleter that\ncompletes them.\n*/ function completeFromList(list) {\n    let options = list.map((o)=>typeof o == \"string\" ? {\n            label: o\n        } : o);\n    let [validFor, match] = options.every((o)=>/^\\w+$/.test(o.label)) ? [\n        /\\w*$/,\n        /\\w+$/\n    ] : prefixMatch(options);\n    return (context)=>{\n        let token = context.matchBefore(match);\n        return token || context.explicit ? {\n            from: token ? token.from : context.pos,\n            options,\n            validFor\n        } : null;\n    };\n}\n/**\nWrap the given completion source so that it will only fire when the\ncursor is in a syntax node with one of the given names.\n*/ function ifIn(nodes, source) {\n    return (context)=>{\n        for(let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent){\n            if (nodes.indexOf(pos.name) > -1) return source(context);\n            if (pos.type.isTop) break;\n        }\n        return null;\n    };\n}\n/**\nWrap the given completion source so that it will not fire when the\ncursor is in a syntax node with one of the given names.\n*/ function ifNotIn(nodes, source) {\n    return (context)=>{\n        for(let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent){\n            if (nodes.indexOf(pos.name) > -1) return null;\n            if (pos.type.isTop) break;\n        }\n        return source(context);\n    };\n}\nclass Option {\n    constructor(completion, source, match, score){\n        this.completion = completion;\n        this.source = source;\n        this.match = match;\n        this.score = score;\n    }\n}\nfunction cur(state) {\n    return state.selection.main.from;\n}\n// Make sure the given regexp has a $ at its end and, if `start` is\n// true, a ^ at its start.\nfunction ensureAnchor(expr, start) {\n    var _a;\n    let { source } = expr;\n    let addStart = start && source[0] != \"^\", addEnd = source[source.length - 1] != \"$\";\n    if (!addStart && !addEnd) return expr;\n    return new RegExp(`${addStart ? \"^\" : \"\"}(?:${source})${addEnd ? \"$\" : \"\"}`, (_a = expr.flags) !== null && _a !== void 0 ? _a : expr.ignoreCase ? \"i\" : \"\");\n}\n/**\nThis annotation is added to transactions that are produced by\npicking a completion.\n*/ const pickedCompletion = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();\n/**\nHelper function that returns a transaction spec which inserts a\ncompletion's text in the main selection range, and any other\nselection range that has the same text in front of it.\n*/ function insertCompletionText(state, text, from, to) {\n    let { main } = state.selection, fromOff = from - main.from, toOff = to - main.from;\n    return Object.assign(Object.assign({}, state.changeByRange((range)=>{\n        if (range != main && from != to && state.sliceDoc(range.from + fromOff, range.from + toOff) != state.sliceDoc(from, to)) return {\n            range\n        };\n        return {\n            changes: {\n                from: range.from + fromOff,\n                to: to == main.from ? range.to : range.from + toOff,\n                insert: text\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.from + fromOff + text.length)\n        };\n    })), {\n        scrollIntoView: true,\n        userEvent: \"input.complete\"\n    });\n}\nconst SourceCache = /*@__PURE__*/ new WeakMap();\nfunction asSource(source) {\n    if (!Array.isArray(source)) return source;\n    let known = SourceCache.get(source);\n    if (!known) SourceCache.set(source, known = completeFromList(source));\n    return known;\n}\nconst startCompletionEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst closeCompletionEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\n// A pattern matcher for fuzzy completion matching. Create an instance\n// once for a pattern, and then use that to match any number of\n// completions.\nclass FuzzyMatcher {\n    constructor(pattern){\n        this.pattern = pattern;\n        this.chars = [];\n        this.folded = [];\n        // Buffers reused by calls to `match` to track matched character\n        // positions.\n        this.any = [];\n        this.precise = [];\n        this.byWord = [];\n        this.score = 0;\n        this.matched = [];\n        for(let p = 0; p < pattern.length;){\n            let char = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(pattern, p), size = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(char);\n            this.chars.push(char);\n            let part = pattern.slice(p, p + size), upper = part.toUpperCase();\n            this.folded.push((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(upper == part ? part.toLowerCase() : upper, 0));\n            p += size;\n        }\n        this.astral = pattern.length != this.chars.length;\n    }\n    ret(score, matched) {\n        this.score = score;\n        this.matched = matched;\n        return true;\n    }\n    // Matches a given word (completion) against the pattern (input).\n    // Will return a boolean indicating whether there was a match and,\n    // on success, set `this.score` to the score, `this.matched` to an\n    // array of `from, to` pairs indicating the matched parts of `word`.\n    //\n    // The score is a number that is more negative the worse the match\n    // is. See `Penalty` above.\n    match(word) {\n        if (this.pattern.length == 0) return this.ret(-100 /* Penalty.NotFull */ , []);\n        if (word.length < this.pattern.length) return false;\n        let { chars, folded, any, precise, byWord } = this;\n        // For single-character queries, only match when they occur right\n        // at the start\n        if (chars.length == 1) {\n            let first = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, 0), firstSize = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(first);\n            let score = firstSize == word.length ? 0 : -100 /* Penalty.NotFull */ ;\n            if (first == chars[0]) ;\n            else if (first == folded[0]) score += -200 /* Penalty.CaseFold */ ;\n            else return false;\n            return this.ret(score, [\n                0,\n                firstSize\n            ]);\n        }\n        let direct = word.indexOf(this.pattern);\n        if (direct == 0) return this.ret(word.length == this.pattern.length ? 0 : -100 /* Penalty.NotFull */ , [\n            0,\n            this.pattern.length\n        ]);\n        let len = chars.length, anyTo = 0;\n        if (direct < 0) {\n            for(let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len;){\n                let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, i);\n                if (next == chars[anyTo] || next == folded[anyTo]) any[anyTo++] = i;\n                i += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\n            }\n            // No match, exit immediately\n            if (anyTo < len) return false;\n        }\n        // This tracks the extent of the precise (non-folded, not\n        // necessarily adjacent) match\n        let preciseTo = 0;\n        // Tracks whether there is a match that hits only characters that\n        // appear to be starting words. `byWordFolded` is set to true when\n        // a case folded character is encountered in such a match\n        let byWordTo = 0, byWordFolded = false;\n        // If we've found a partial adjacent match, these track its state\n        let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;\n        let hasLower = /[a-z]/.test(word), wordAdjacent = true;\n        // Go over the option's text, scanning for the various kinds of matches\n        for(let i = 0, e = Math.min(word.length, 200), prevType = 0 /* Tp.NonWord */ ; i < e && byWordTo < len;){\n            let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, i);\n            if (direct < 0) {\n                if (preciseTo < len && next == chars[preciseTo]) precise[preciseTo++] = i;\n                if (adjacentTo < len) {\n                    if (next == chars[adjacentTo] || next == folded[adjacentTo]) {\n                        if (adjacentTo == 0) adjacentStart = i;\n                        adjacentEnd = i + 1;\n                        adjacentTo++;\n                    } else {\n                        adjacentTo = 0;\n                    }\n                }\n            }\n            let ch, type = next < 0xff ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 /* Tp.Lower */  : next >= 65 && next <= 90 ? 1 /* Tp.Upper */  : 0 /* Tp.NonWord */  : (ch = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(next)) != ch.toLowerCase() ? 1 /* Tp.Upper */  : ch != ch.toUpperCase() ? 2 /* Tp.Lower */  : 0 /* Tp.NonWord */ ;\n            if (!i || type == 1 /* Tp.Upper */  && hasLower || prevType == 0 /* Tp.NonWord */  && type != 0 /* Tp.NonWord */ ) {\n                if (chars[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true)) byWord[byWordTo++] = i;\n                else if (byWord.length) wordAdjacent = false;\n            }\n            prevType = type;\n            i += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\n        }\n        if (byWordTo == len && byWord[0] == 0 && wordAdjacent) return this.result(-100 /* Penalty.ByWord */  + (byWordFolded ? -200 /* Penalty.CaseFold */  : 0), byWord, word);\n        if (adjacentTo == len && adjacentStart == 0) return this.ret(-200 /* Penalty.CaseFold */  - word.length + (adjacentEnd == word.length ? 0 : -100 /* Penalty.NotFull */ ), [\n            0,\n            adjacentEnd\n        ]);\n        if (direct > -1) return this.ret(-700 /* Penalty.NotStart */  - word.length, [\n            direct,\n            direct + this.pattern.length\n        ]);\n        if (adjacentTo == len) return this.ret(-200 /* Penalty.CaseFold */  + -700 /* Penalty.NotStart */  - word.length, [\n            adjacentStart,\n            adjacentEnd\n        ]);\n        if (byWordTo == len) return this.result(-100 /* Penalty.ByWord */  + (byWordFolded ? -200 /* Penalty.CaseFold */  : 0) + -700 /* Penalty.NotStart */  + (wordAdjacent ? 0 : -1100 /* Penalty.Gap */ ), byWord, word);\n        return chars.length == 2 ? false : this.result((any[0] ? -700 /* Penalty.NotStart */  : 0) + -200 /* Penalty.CaseFold */  + -1100 /* Penalty.Gap */ , any, word);\n    }\n    result(score, positions, word) {\n        let result = [], i = 0;\n        for (let pos of positions){\n            let to = pos + (this.astral ? (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, pos)) : 1);\n            if (i && result[i - 1] == pos) result[i - 1] = to;\n            else {\n                result[i++] = pos;\n                result[i++] = to;\n            }\n        }\n        return this.ret(score - word.length, result);\n    }\n}\nconst completionConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\n            activateOnTyping: true,\n            activateOnTypingDelay: 100,\n            selectOnOpen: true,\n            override: null,\n            closeOnBlur: true,\n            maxRenderedOptions: 100,\n            defaultKeymap: true,\n            tooltipClass: ()=>\"\",\n            optionClass: ()=>\"\",\n            aboveCursor: false,\n            icons: true,\n            addToOptions: [],\n            positionInfo: defaultPositionInfo,\n            compareCompletions: (a, b)=>a.label.localeCompare(b.label),\n            interactionDelay: 75,\n            updateSyncTime: 100\n        }, {\n            defaultKeymap: (a, b)=>a && b,\n            closeOnBlur: (a, b)=>a && b,\n            icons: (a, b)=>a && b,\n            tooltipClass: (a, b)=>(c)=>joinClass(a(c), b(c)),\n            optionClass: (a, b)=>(c)=>joinClass(a(c), b(c)),\n            addToOptions: (a, b)=>a.concat(b)\n        });\n    }\n});\nfunction joinClass(a, b) {\n    return a ? b ? a + \" \" + b : a : b;\n}\nfunction defaultPositionInfo(view, list, option, info, space, tooltip) {\n    let rtl = view.textDirection == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.RTL, left = rtl, narrow = false;\n    let side = \"top\", offset, maxWidth;\n    let spaceLeft = list.left - space.left, spaceRight = space.right - list.right;\n    let infoWidth = info.right - info.left, infoHeight = info.bottom - info.top;\n    if (left && spaceLeft < Math.min(infoWidth, spaceRight)) left = false;\n    else if (!left && spaceRight < Math.min(infoWidth, spaceLeft)) left = true;\n    if (infoWidth <= (left ? spaceLeft : spaceRight)) {\n        offset = Math.max(space.top, Math.min(option.top, space.bottom - infoHeight)) - list.top;\n        maxWidth = Math.min(400 /* Info.Width */ , left ? spaceLeft : spaceRight);\n    } else {\n        narrow = true;\n        maxWidth = Math.min(400 /* Info.Width */ , (rtl ? list.right : space.right - list.left) - 30 /* Info.Margin */ );\n        let spaceBelow = space.bottom - list.bottom;\n        if (spaceBelow >= infoHeight || spaceBelow > list.top) {\n            offset = option.bottom - list.top;\n        } else {\n            side = \"bottom\";\n            offset = list.bottom - option.top;\n        }\n    }\n    let scaleY = (list.bottom - list.top) / tooltip.offsetHeight;\n    let scaleX = (list.right - list.left) / tooltip.offsetWidth;\n    return {\n        style: `${side}: ${offset / scaleY}px; max-width: ${maxWidth / scaleX}px`,\n        class: \"cm-completionInfo-\" + (narrow ? rtl ? \"left-narrow\" : \"right-narrow\" : left ? \"left\" : \"right\")\n    };\n}\nfunction optionContent(config) {\n    let content = config.addToOptions.slice();\n    if (config.icons) content.push({\n        render (completion) {\n            let icon = document.createElement(\"div\");\n            icon.classList.add(\"cm-completionIcon\");\n            if (completion.type) icon.classList.add(...completion.type.split(/\\s+/g).map((cls)=>\"cm-completionIcon-\" + cls));\n            icon.setAttribute(\"aria-hidden\", \"true\");\n            return icon;\n        },\n        position: 20\n    });\n    content.push({\n        render (completion, _s, _v, match) {\n            let labelElt = document.createElement(\"span\");\n            labelElt.className = \"cm-completionLabel\";\n            let label = completion.displayLabel || completion.label, off = 0;\n            for(let j = 0; j < match.length;){\n                let from = match[j++], to = match[j++];\n                if (from > off) labelElt.appendChild(document.createTextNode(label.slice(off, from)));\n                let span = labelElt.appendChild(document.createElement(\"span\"));\n                span.appendChild(document.createTextNode(label.slice(from, to)));\n                span.className = \"cm-completionMatchedText\";\n                off = to;\n            }\n            if (off < label.length) labelElt.appendChild(document.createTextNode(label.slice(off)));\n            return labelElt;\n        },\n        position: 50\n    }, {\n        render (completion) {\n            if (!completion.detail) return null;\n            let detailElt = document.createElement(\"span\");\n            detailElt.className = \"cm-completionDetail\";\n            detailElt.textContent = completion.detail;\n            return detailElt;\n        },\n        position: 80\n    });\n    return content.sort((a, b)=>a.position - b.position).map((a)=>a.render);\n}\nfunction rangeAroundSelected(total, selected, max) {\n    if (total <= max) return {\n        from: 0,\n        to: total\n    };\n    if (selected < 0) selected = 0;\n    if (selected <= total >> 1) {\n        let off = Math.floor(selected / max);\n        return {\n            from: off * max,\n            to: (off + 1) * max\n        };\n    }\n    let off = Math.floor((total - selected) / max);\n    return {\n        from: total - (off + 1) * max,\n        to: total - off * max\n    };\n}\nclass CompletionTooltip {\n    constructor(view, stateField, applyCompletion){\n        this.view = view;\n        this.stateField = stateField;\n        this.applyCompletion = applyCompletion;\n        this.info = null;\n        this.infoDestroy = null;\n        this.placeInfoReq = {\n            read: ()=>this.measureInfo(),\n            write: (pos)=>this.placeInfo(pos),\n            key: this\n        };\n        this.space = null;\n        this.currentClass = \"\";\n        let cState = view.state.field(stateField);\n        let { options, selected } = cState.open;\n        let config = view.state.facet(completionConfig);\n        this.optionContent = optionContent(config);\n        this.optionClass = config.optionClass;\n        this.tooltipClass = config.tooltipClass;\n        this.range = rangeAroundSelected(options.length, selected, config.maxRenderedOptions);\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-tooltip-autocomplete\";\n        this.updateTooltipClass(view.state);\n        this.dom.addEventListener(\"mousedown\", (e)=>{\n            let { options } = view.state.field(stateField).open;\n            for(let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode){\n                if (dom.nodeName == \"LI\" && (match = /-(\\d+)$/.exec(dom.id)) && +match[1] < options.length) {\n                    this.applyCompletion(view, options[+match[1]]);\n                    e.preventDefault();\n                    return;\n                }\n            }\n        });\n        this.dom.addEventListener(\"focusout\", (e)=>{\n            let state = view.state.field(this.stateField, false);\n            if (state && state.tooltip && view.state.facet(completionConfig).closeOnBlur && e.relatedTarget != view.contentDOM) view.dispatch({\n                effects: closeCompletionEffect.of(null)\n            });\n        });\n        this.showOptions(options, cState.id);\n    }\n    mount() {\n        this.updateSel();\n    }\n    showOptions(options, id) {\n        if (this.list) this.list.remove();\n        this.list = this.dom.appendChild(this.createListBox(options, id, this.range));\n        this.list.addEventListener(\"scroll\", ()=>{\n            if (this.info) this.view.requestMeasure(this.placeInfoReq);\n        });\n    }\n    update(update) {\n        var _a;\n        let cState = update.state.field(this.stateField);\n        let prevState = update.startState.field(this.stateField);\n        this.updateTooltipClass(update.state);\n        if (cState != prevState) {\n            let { options, selected, disabled } = cState.open;\n            if (!prevState.open || prevState.open.options != options) {\n                this.range = rangeAroundSelected(options.length, selected, update.state.facet(completionConfig).maxRenderedOptions);\n                this.showOptions(options, cState.id);\n            }\n            this.updateSel();\n            if (disabled != ((_a = prevState.open) === null || _a === void 0 ? void 0 : _a.disabled)) this.dom.classList.toggle(\"cm-tooltip-autocomplete-disabled\", !!disabled);\n        }\n    }\n    updateTooltipClass(state) {\n        let cls = this.tooltipClass(state);\n        if (cls != this.currentClass) {\n            for (let c of this.currentClass.split(\" \"))if (c) this.dom.classList.remove(c);\n            for (let c of cls.split(\" \"))if (c) this.dom.classList.add(c);\n            this.currentClass = cls;\n        }\n    }\n    positioned(space) {\n        this.space = space;\n        if (this.info) this.view.requestMeasure(this.placeInfoReq);\n    }\n    updateSel() {\n        let cState = this.view.state.field(this.stateField), open = cState.open;\n        if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {\n            this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);\n            this.showOptions(open.options, cState.id);\n        }\n        if (this.updateSelectedOption(open.selected)) {\n            this.destroyInfo();\n            let { completion } = open.options[open.selected];\n            let { info } = completion;\n            if (!info) return;\n            let infoResult = typeof info === \"string\" ? document.createTextNode(info) : info(completion);\n            if (!infoResult) return;\n            if (\"then\" in infoResult) {\n                infoResult.then((obj)=>{\n                    if (obj && this.view.state.field(this.stateField, false) == cState) this.addInfoPane(obj, completion);\n                }).catch((e)=>(0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, e, \"completion info\"));\n            } else {\n                this.addInfoPane(infoResult, completion);\n            }\n        }\n    }\n    addInfoPane(content, completion) {\n        this.destroyInfo();\n        let wrap = this.info = document.createElement(\"div\");\n        wrap.className = \"cm-tooltip cm-completionInfo\";\n        if (content.nodeType != null) {\n            wrap.appendChild(content);\n            this.infoDestroy = null;\n        } else {\n            let { dom, destroy } = content;\n            wrap.appendChild(dom);\n            this.infoDestroy = destroy || null;\n        }\n        this.dom.appendChild(wrap);\n        this.view.requestMeasure(this.placeInfoReq);\n    }\n    updateSelectedOption(selected) {\n        let set = null;\n        for(let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++){\n            if (opt.nodeName != \"LI\" || !opt.id) {\n                i--; // A section header\n            } else if (i == selected) {\n                if (!opt.hasAttribute(\"aria-selected\")) {\n                    opt.setAttribute(\"aria-selected\", \"true\");\n                    set = opt;\n                }\n            } else {\n                if (opt.hasAttribute(\"aria-selected\")) opt.removeAttribute(\"aria-selected\");\n            }\n        }\n        if (set) scrollIntoView(this.list, set);\n        return set;\n    }\n    measureInfo() {\n        let sel = this.dom.querySelector(\"[aria-selected]\");\n        if (!sel || !this.info) return null;\n        let listRect = this.dom.getBoundingClientRect();\n        let infoRect = this.info.getBoundingClientRect();\n        let selRect = sel.getBoundingClientRect();\n        let space = this.space;\n        if (!space) {\n            let win = this.dom.ownerDocument.defaultView || window;\n            space = {\n                left: 0,\n                top: 0,\n                right: win.innerWidth,\n                bottom: win.innerHeight\n            };\n        }\n        if (selRect.top > Math.min(space.bottom, listRect.bottom) - 10 || selRect.bottom < Math.max(space.top, listRect.top) + 10) return null;\n        return this.view.state.facet(completionConfig).positionInfo(this.view, listRect, selRect, infoRect, space, this.dom);\n    }\n    placeInfo(pos) {\n        if (this.info) {\n            if (pos) {\n                if (pos.style) this.info.style.cssText = pos.style;\n                this.info.className = \"cm-tooltip cm-completionInfo \" + (pos.class || \"\");\n            } else {\n                this.info.style.cssText = \"top: -1e6px\";\n            }\n        }\n    }\n    createListBox(options, id, range) {\n        const ul = document.createElement(\"ul\");\n        ul.id = id;\n        ul.setAttribute(\"role\", \"listbox\");\n        ul.setAttribute(\"aria-expanded\", \"true\");\n        ul.setAttribute(\"aria-label\", this.view.state.phrase(\"Completions\"));\n        let curSection = null;\n        for(let i = range.from; i < range.to; i++){\n            let { completion, match } = options[i], { section } = completion;\n            if (section) {\n                let name = typeof section == \"string\" ? section : section.name;\n                if (name != curSection && (i > range.from || range.from == 0)) {\n                    curSection = name;\n                    if (typeof section != \"string\" && section.header) {\n                        ul.appendChild(section.header(section));\n                    } else {\n                        let header = ul.appendChild(document.createElement(\"completion-section\"));\n                        header.textContent = name;\n                    }\n                }\n            }\n            const li = ul.appendChild(document.createElement(\"li\"));\n            li.id = id + \"-\" + i;\n            li.setAttribute(\"role\", \"option\");\n            let cls = this.optionClass(completion);\n            if (cls) li.className = cls;\n            for (let source of this.optionContent){\n                let node = source(completion, this.view.state, this.view, match);\n                if (node) li.appendChild(node);\n            }\n        }\n        if (range.from) ul.classList.add(\"cm-completionListIncompleteTop\");\n        if (range.to < options.length) ul.classList.add(\"cm-completionListIncompleteBottom\");\n        return ul;\n    }\n    destroyInfo() {\n        if (this.info) {\n            if (this.infoDestroy) this.infoDestroy();\n            this.info.remove();\n            this.info = null;\n        }\n    }\n    destroy() {\n        this.destroyInfo();\n    }\n}\nfunction completionTooltip(stateField, applyCompletion) {\n    return (view)=>new CompletionTooltip(view, stateField, applyCompletion);\n}\nfunction scrollIntoView(container, element) {\n    let parent = container.getBoundingClientRect();\n    let self = element.getBoundingClientRect();\n    let scaleY = parent.height / container.offsetHeight;\n    if (self.top < parent.top) container.scrollTop -= (parent.top - self.top) / scaleY;\n    else if (self.bottom > parent.bottom) container.scrollTop += (self.bottom - parent.bottom) / scaleY;\n}\n// Used to pick a preferred option when two options with the same\n// label occur in the result.\nfunction score(option) {\n    return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);\n}\nfunction sortOptions(active, state) {\n    let options = [];\n    let sections = null;\n    let addOption = (option)=>{\n        options.push(option);\n        let { section } = option.completion;\n        if (section) {\n            if (!sections) sections = [];\n            let name = typeof section == \"string\" ? section : section.name;\n            if (!sections.some((s)=>s.name == name)) sections.push(typeof section == \"string\" ? {\n                name\n            } : section);\n        }\n    };\n    for (let a of active)if (a.hasResult()) {\n        let getMatch = a.result.getMatch;\n        if (a.result.filter === false) {\n            for (let option of a.result.options){\n                addOption(new Option(option, a.source, getMatch ? getMatch(option) : [], 1e9 - options.length));\n            }\n        } else {\n            let matcher = new FuzzyMatcher(state.sliceDoc(a.from, a.to));\n            for (let option of a.result.options)if (matcher.match(option.label)) {\n                let matched = !option.displayLabel ? matcher.matched : getMatch ? getMatch(option, matcher.matched) : [];\n                addOption(new Option(option, a.source, matched, matcher.score + (option.boost || 0)));\n            }\n        }\n    }\n    if (sections) {\n        let sectionOrder = Object.create(null), pos = 0;\n        let cmp = (a, b)=>{\n            var _a, _b;\n            return ((_a = a.rank) !== null && _a !== void 0 ? _a : 1e9) - ((_b = b.rank) !== null && _b !== void 0 ? _b : 1e9) || (a.name < b.name ? -1 : 1);\n        };\n        for (let s of sections.sort(cmp)){\n            pos -= 1e5;\n            sectionOrder[s.name] = pos;\n        }\n        for (let option of options){\n            let { section } = option.completion;\n            if (section) option.score += sectionOrder[typeof section == \"string\" ? section : section.name];\n        }\n    }\n    let result = [], prev = null;\n    let compare = state.facet(completionConfig).compareCompletions;\n    for (let opt of options.sort((a, b)=>b.score - a.score || compare(a.completion, b.completion))){\n        let cur = opt.completion;\n        if (!prev || prev.label != cur.label || prev.detail != cur.detail || prev.type != null && cur.type != null && prev.type != cur.type || prev.apply != cur.apply || prev.boost != cur.boost) result.push(opt);\n        else if (score(opt.completion) > score(prev)) result[result.length - 1] = opt;\n        prev = opt.completion;\n    }\n    return result;\n}\nclass CompletionDialog {\n    constructor(options, attrs, tooltip, timestamp, selected, disabled){\n        this.options = options;\n        this.attrs = attrs;\n        this.tooltip = tooltip;\n        this.timestamp = timestamp;\n        this.selected = selected;\n        this.disabled = disabled;\n    }\n    setSelected(selected, id) {\n        return selected == this.selected || selected >= this.options.length ? this : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected, this.disabled);\n    }\n    static build(active, state, id, prev, conf) {\n        let options = sortOptions(active, state);\n        if (!options.length) {\n            return prev && active.some((a)=>a.state == 1 /* State.Pending */ ) ? new CompletionDialog(prev.options, prev.attrs, prev.tooltip, prev.timestamp, prev.selected, true) : null;\n        }\n        let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;\n        if (prev && prev.selected != selected && prev.selected != -1) {\n            let selectedValue = prev.options[prev.selected].completion;\n            for(let i = 0; i < options.length; i++)if (options[i].completion == selectedValue) {\n                selected = i;\n                break;\n            }\n        }\n        return new CompletionDialog(options, makeAttrs(id, selected), {\n            pos: active.reduce((a, b)=>b.hasResult() ? Math.min(a, b.from) : a, 1e8),\n            create: createTooltip,\n            above: conf.aboveCursor\n        }, prev ? prev.timestamp : Date.now(), selected, false);\n    }\n    map(changes) {\n        return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), {\n            pos: changes.mapPos(this.tooltip.pos)\n        }), this.timestamp, this.selected, this.disabled);\n    }\n}\nclass CompletionState {\n    constructor(active, id, open){\n        this.active = active;\n        this.id = id;\n        this.open = open;\n    }\n    static start() {\n        return new CompletionState(none, \"cm-ac-\" + Math.floor(Math.random() * 2e6).toString(36), null);\n    }\n    update(tr) {\n        let { state } = tr, conf = state.facet(completionConfig);\n        let sources = conf.override || state.languageDataAt(\"autocomplete\", cur(state)).map(asSource);\n        let active = sources.map((source)=>{\n            let value = this.active.find((s)=>s.source == source) || new ActiveSource(source, this.active.some((a)=>a.state != 0 /* State.Inactive */ ) ? 1 /* State.Pending */  : 0 /* State.Inactive */ );\n            return value.update(tr, conf);\n        });\n        if (active.length == this.active.length && active.every((a, i)=>a == this.active[i])) active = this.active;\n        let open = this.open;\n        if (open && tr.docChanged) open = open.map(tr.changes);\n        if (tr.selection || active.some((a)=>a.hasResult() && tr.changes.touchesRange(a.from, a.to)) || !sameResults(active, this.active)) open = CompletionDialog.build(active, state, this.id, open, conf);\n        else if (open && open.disabled && !active.some((a)=>a.state == 1 /* State.Pending */ )) open = null;\n        if (!open && active.every((a)=>a.state != 1 /* State.Pending */ ) && active.some((a)=>a.hasResult())) active = active.map((a)=>a.hasResult() ? new ActiveSource(a.source, 0 /* State.Inactive */ ) : a);\n        for (let effect of tr.effects)if (effect.is(setSelectedEffect)) open = open && open.setSelected(effect.value, this.id);\n        return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);\n    }\n    get tooltip() {\n        return this.open ? this.open.tooltip : null;\n    }\n    get attrs() {\n        return this.open ? this.open.attrs : baseAttrs;\n    }\n}\nfunction sameResults(a, b) {\n    if (a == b) return true;\n    for(let iA = 0, iB = 0;;){\n        while(iA < a.length && !a[iA].hasResult)iA++;\n        while(iB < b.length && !b[iB].hasResult)iB++;\n        let endA = iA == a.length, endB = iB == b.length;\n        if (endA || endB) return endA == endB;\n        if (a[iA++].result != b[iB++].result) return false;\n    }\n}\nconst baseAttrs = {\n    \"aria-autocomplete\": \"list\"\n};\nfunction makeAttrs(id, selected) {\n    let result = {\n        \"aria-autocomplete\": \"list\",\n        \"aria-haspopup\": \"listbox\",\n        \"aria-controls\": id\n    };\n    if (selected > -1) result[\"aria-activedescendant\"] = id + \"-\" + selected;\n    return result;\n}\nconst none = [];\nfunction getUserEvent(tr) {\n    return tr.isUserEvent(\"input.type\") ? \"input\" : tr.isUserEvent(\"delete.backward\") ? \"delete\" : null;\n}\nclass ActiveSource {\n    constructor(source, state, explicitPos = -1){\n        this.source = source;\n        this.state = state;\n        this.explicitPos = explicitPos;\n    }\n    hasResult() {\n        return false;\n    }\n    update(tr, conf) {\n        let event = getUserEvent(tr), value = this;\n        if (event) value = value.handleUserEvent(tr, event, conf);\n        else if (tr.docChanged) value = value.handleChange(tr);\n        else if (tr.selection && value.state != 0 /* State.Inactive */ ) value = new ActiveSource(value.source, 0 /* State.Inactive */ );\n        for (let effect of tr.effects){\n            if (effect.is(startCompletionEffect)) value = new ActiveSource(value.source, 1 /* State.Pending */ , effect.value ? cur(tr.state) : -1);\n            else if (effect.is(closeCompletionEffect)) value = new ActiveSource(value.source, 0 /* State.Inactive */ );\n            else if (effect.is(setActiveEffect)) {\n                for (let active of effect.value)if (active.source == value.source) value = active;\n            }\n        }\n        return value;\n    }\n    handleUserEvent(tr, type, conf) {\n        return type == \"delete\" || !conf.activateOnTyping ? this.map(tr.changes) : new ActiveSource(this.source, 1 /* State.Pending */ );\n    }\n    handleChange(tr) {\n        return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0 /* State.Inactive */ ) : this.map(tr.changes);\n    }\n    map(changes) {\n        return changes.empty || this.explicitPos < 0 ? this : new ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));\n    }\n}\nclass ActiveResult extends ActiveSource {\n    constructor(source, explicitPos, result, from, to){\n        super(source, 2 /* State.Result */ , explicitPos);\n        this.result = result;\n        this.from = from;\n        this.to = to;\n    }\n    hasResult() {\n        return true;\n    }\n    handleUserEvent(tr, type, conf) {\n        var _a;\n        let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);\n        let pos = cur(tr.state);\n        if ((this.explicitPos < 0 ? pos <= from : pos < this.from) || pos > to || type == \"delete\" && cur(tr.startState) == this.from) return new ActiveSource(this.source, type == \"input\" && conf.activateOnTyping ? 1 /* State.Pending */  : 0 /* State.Inactive */ );\n        let explicitPos = this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos), updated;\n        if (checkValid(this.result.validFor, tr.state, from, to)) return new ActiveResult(this.source, explicitPos, this.result, from, to);\n        if (this.result.update && (updated = this.result.update(this.result, from, to, new CompletionContext(tr.state, pos, explicitPos >= 0)))) return new ActiveResult(this.source, explicitPos, updated, updated.from, (_a = updated.to) !== null && _a !== void 0 ? _a : cur(tr.state));\n        return new ActiveSource(this.source, 1 /* State.Pending */ , explicitPos);\n    }\n    handleChange(tr) {\n        return tr.changes.touchesRange(this.from, this.to) ? new ActiveSource(this.source, 0 /* State.Inactive */ ) : this.map(tr.changes);\n    }\n    map(mapping) {\n        return mapping.empty ? this : new ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));\n    }\n}\nfunction checkValid(validFor, state, from, to) {\n    if (!validFor) return false;\n    let text = state.sliceDoc(from, to);\n    return typeof validFor == \"function\" ? validFor(text, from, to, state) : ensureAnchor(validFor, true).test(text);\n}\nconst setActiveEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\n    map (sources, mapping) {\n        return sources.map((s)=>s.map(mapping));\n    }\n});\nconst setSelectedEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst completionState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return CompletionState.start();\n    },\n    update (value, tr) {\n        return value.update(tr);\n    },\n    provide: (f)=>[\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showTooltip.from(f, (val)=>val.tooltip),\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.contentAttributes.from(f, (state)=>state.attrs)\n        ]\n});\nfunction applyCompletion(view, option) {\n    const apply = option.completion.apply || option.completion.label;\n    let result = view.state.field(completionState).active.find((a)=>a.source == option.source);\n    if (!(result instanceof ActiveResult)) return false;\n    if (typeof apply == \"string\") view.dispatch(Object.assign(Object.assign({}, insertCompletionText(view.state, apply, result.from, result.to)), {\n        annotations: pickedCompletion.of(option.completion)\n    }));\n    else apply(view, option.completion, result.from, result.to);\n    return true;\n}\nconst createTooltip = /*@__PURE__*/ completionTooltip(completionState, applyCompletion);\n/**\nReturns a command that moves the completion selection forward or\nbackward by the given amount.\n*/ function moveCompletionSelection(forward, by = \"option\") {\n    return (view)=>{\n        let cState = view.state.field(completionState, false);\n        if (!cState || !cState.open || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay) return false;\n        let step = 1, tooltip;\n        if (by == \"page\" && (tooltip = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getTooltip)(view, cState.open.tooltip))) step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector(\"li\").offsetHeight) - 1);\n        let { length } = cState.open.options;\n        let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;\n        if (selected < 0) selected = by == \"page\" ? 0 : length - 1;\n        else if (selected >= length) selected = by == \"page\" ? length - 1 : 0;\n        view.dispatch({\n            effects: setSelectedEffect.of(selected)\n        });\n        return true;\n    };\n}\n/**\nAccept the current completion.\n*/ const acceptCompletion = (view)=>{\n    let cState = view.state.field(completionState, false);\n    if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay) return false;\n    return applyCompletion(view, cState.open.options[cState.open.selected]);\n};\n/**\nExplicitly start autocompletion.\n*/ const startCompletion = (view)=>{\n    let cState = view.state.field(completionState, false);\n    if (!cState) return false;\n    view.dispatch({\n        effects: startCompletionEffect.of(true)\n    });\n    return true;\n};\n/**\nClose the currently active completion.\n*/ const closeCompletion = (view)=>{\n    let cState = view.state.field(completionState, false);\n    if (!cState || !cState.active.some((a)=>a.state != 0 /* State.Inactive */ )) return false;\n    view.dispatch({\n        effects: closeCompletionEffect.of(null)\n    });\n    return true;\n};\nclass RunningQuery {\n    constructor(active, context){\n        this.active = active;\n        this.context = context;\n        this.time = Date.now();\n        this.updates = [];\n        // Note that 'undefined' means 'not done yet', whereas 'null' means\n        // 'query returned null'.\n        this.done = undefined;\n    }\n}\nconst MaxUpdateCount = 50, MinAbortTime = 1000;\nconst completionPlugin = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.debounceUpdate = -1;\n        this.running = [];\n        this.debounceAccept = -1;\n        this.pendingStart = false;\n        this.composing = 0 /* CompositionState.None */ ;\n        for (let active of view.state.field(completionState).active)if (active.state == 1 /* State.Pending */ ) this.startQuery(active);\n    }\n    update(update) {\n        let cState = update.state.field(completionState);\n        if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState) return;\n        let doesReset = update.transactions.some((tr)=>{\n            return (tr.selection || tr.docChanged) && !getUserEvent(tr);\n        });\n        for(let i = 0; i < this.running.length; i++){\n            let query = this.running[i];\n            if (doesReset || query.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {\n                for (let handler of query.context.abortListeners){\n                    try {\n                        handler();\n                    } catch (e) {\n                        (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, e);\n                    }\n                }\n                query.context.abortListeners = null;\n                this.running.splice(i--, 1);\n            } else {\n                query.updates.push(...update.transactions);\n            }\n        }\n        if (this.debounceUpdate > -1) clearTimeout(this.debounceUpdate);\n        if (update.transactions.some((tr)=>tr.effects.some((e)=>e.is(startCompletionEffect)))) this.pendingStart = true;\n        let delay = this.pendingStart ? 50 : update.state.facet(completionConfig).activateOnTypingDelay;\n        this.debounceUpdate = cState.active.some((a)=>a.state == 1 /* State.Pending */  && !this.running.some((q)=>q.active.source == a.source)) ? setTimeout(()=>this.startUpdate(), delay) : -1;\n        if (this.composing != 0 /* CompositionState.None */ ) for (let tr of update.transactions){\n            if (getUserEvent(tr) == \"input\") this.composing = 2 /* CompositionState.Changed */ ;\n            else if (this.composing == 2 /* CompositionState.Changed */  && tr.selection) this.composing = 3 /* CompositionState.ChangedAndMoved */ ;\n        }\n    }\n    startUpdate() {\n        this.debounceUpdate = -1;\n        this.pendingStart = false;\n        let { state } = this.view, cState = state.field(completionState);\n        for (let active of cState.active){\n            if (active.state == 1 /* State.Pending */  && !this.running.some((r)=>r.active.source == active.source)) this.startQuery(active);\n        }\n    }\n    startQuery(active) {\n        let { state } = this.view, pos = cur(state);\n        let context = new CompletionContext(state, pos, active.explicitPos == pos);\n        let pending = new RunningQuery(active, context);\n        this.running.push(pending);\n        Promise.resolve(active.source(context)).then((result)=>{\n            if (!pending.context.aborted) {\n                pending.done = result || null;\n                this.scheduleAccept();\n            }\n        }, (err)=>{\n            this.view.dispatch({\n                effects: closeCompletionEffect.of(null)\n            });\n            (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, err);\n        });\n    }\n    scheduleAccept() {\n        if (this.running.every((q)=>q.done !== undefined)) this.accept();\n        else if (this.debounceAccept < 0) this.debounceAccept = setTimeout(()=>this.accept(), this.view.state.facet(completionConfig).updateSyncTime);\n    }\n    // For each finished query in this.running, try to create a result\n    // or, if appropriate, restart the query.\n    accept() {\n        var _a;\n        if (this.debounceAccept > -1) clearTimeout(this.debounceAccept);\n        this.debounceAccept = -1;\n        let updated = [];\n        let conf = this.view.state.facet(completionConfig);\n        for(let i = 0; i < this.running.length; i++){\n            let query = this.running[i];\n            if (query.done === undefined) continue;\n            this.running.splice(i--, 1);\n            if (query.done) {\n                let active = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : cur(query.updates.length ? query.updates[0].startState : this.view.state));\n                // Replay the transactions that happened since the start of\n                // the request and see if that preserves the result\n                for (let tr of query.updates)active = active.update(tr, conf);\n                if (active.hasResult()) {\n                    updated.push(active);\n                    continue;\n                }\n            }\n            let current = this.view.state.field(completionState).active.find((a)=>a.source == query.active.source);\n            if (current && current.state == 1 /* State.Pending */ ) {\n                if (query.done == null) {\n                    // Explicitly failed. Should clear the pending status if it\n                    // hasn't been re-set in the meantime.\n                    let active = new ActiveSource(query.active.source, 0 /* State.Inactive */ );\n                    for (let tr of query.updates)active = active.update(tr, conf);\n                    if (active.state != 1 /* State.Pending */ ) updated.push(active);\n                } else {\n                    // Cleared by subsequent transactions. Restart.\n                    this.startQuery(current);\n                }\n            }\n        }\n        if (updated.length) this.view.dispatch({\n            effects: setActiveEffect.of(updated)\n        });\n    }\n}, {\n    eventHandlers: {\n        blur (event) {\n            let state = this.view.state.field(completionState, false);\n            if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur) {\n                let dialog = state.open && (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getTooltip)(this.view, state.open.tooltip);\n                if (!dialog || !dialog.dom.contains(event.relatedTarget)) setTimeout(()=>this.view.dispatch({\n                        effects: closeCompletionEffect.of(null)\n                    }), 10);\n            }\n        },\n        compositionstart () {\n            this.composing = 1 /* CompositionState.Started */ ;\n        },\n        compositionend () {\n            if (this.composing == 3 /* CompositionState.ChangedAndMoved */ ) {\n                // Safari fires compositionend events synchronously, possibly\n                // from inside an update, so dispatch asynchronously to avoid reentrancy\n                setTimeout(()=>this.view.dispatch({\n                        effects: startCompletionEffect.of(false)\n                    }), 20);\n            }\n            this.composing = 0 /* CompositionState.None */ ;\n        }\n    }\n});\nconst baseTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-tooltip.cm-tooltip-autocomplete\": {\n        \"& > ul\": {\n            fontFamily: \"monospace\",\n            whiteSpace: \"nowrap\",\n            overflow: \"hidden auto\",\n            maxWidth_fallback: \"700px\",\n            maxWidth: \"min(700px, 95vw)\",\n            minWidth: \"250px\",\n            maxHeight: \"10em\",\n            height: \"100%\",\n            listStyle: \"none\",\n            margin: 0,\n            padding: 0,\n            \"& > li, & > completion-section\": {\n                padding: \"1px 3px\",\n                lineHeight: 1.2\n            },\n            \"& > li\": {\n                overflowX: \"hidden\",\n                textOverflow: \"ellipsis\",\n                cursor: \"pointer\"\n            },\n            \"& > completion-section\": {\n                display: \"list-item\",\n                borderBottom: \"1px solid silver\",\n                paddingLeft: \"0.5em\",\n                opacity: 0.7\n            }\n        }\n    },\n    \"&light .cm-tooltip-autocomplete ul li[aria-selected]\": {\n        background: \"#17c\",\n        color: \"white\"\n    },\n    \"&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]\": {\n        background: \"#777\"\n    },\n    \"&dark .cm-tooltip-autocomplete ul li[aria-selected]\": {\n        background: \"#347\",\n        color: \"white\"\n    },\n    \"&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]\": {\n        background: \"#444\"\n    },\n    \".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after\": {\n        content: '\"\\xb7\\xb7\\xb7\"',\n        opacity: 0.5,\n        display: \"block\",\n        textAlign: \"center\"\n    },\n    \".cm-tooltip.cm-completionInfo\": {\n        position: \"absolute\",\n        padding: \"3px 9px\",\n        width: \"max-content\",\n        maxWidth: `${400 /* Info.Width */ }px`,\n        boxSizing: \"border-box\"\n    },\n    \".cm-completionInfo.cm-completionInfo-left\": {\n        right: \"100%\"\n    },\n    \".cm-completionInfo.cm-completionInfo-right\": {\n        left: \"100%\"\n    },\n    \".cm-completionInfo.cm-completionInfo-left-narrow\": {\n        right: `${30 /* Info.Margin */ }px`\n    },\n    \".cm-completionInfo.cm-completionInfo-right-narrow\": {\n        left: `${30 /* Info.Margin */ }px`\n    },\n    \"&light .cm-snippetField\": {\n        backgroundColor: \"#00000022\"\n    },\n    \"&dark .cm-snippetField\": {\n        backgroundColor: \"#ffffff22\"\n    },\n    \".cm-snippetFieldPosition\": {\n        verticalAlign: \"text-top\",\n        width: 0,\n        height: \"1.15em\",\n        display: \"inline-block\",\n        margin: \"0 -0.7px -.7em\",\n        borderLeft: \"1.4px dotted #888\"\n    },\n    \".cm-completionMatchedText\": {\n        textDecoration: \"underline\"\n    },\n    \".cm-completionDetail\": {\n        marginLeft: \"0.5em\",\n        fontStyle: \"italic\"\n    },\n    \".cm-completionIcon\": {\n        fontSize: \"90%\",\n        width: \".8em\",\n        display: \"inline-block\",\n        textAlign: \"center\",\n        paddingRight: \".6em\",\n        opacity: \"0.6\",\n        boxSizing: \"content-box\"\n    },\n    \".cm-completionIcon-function, .cm-completionIcon-method\": {\n        \"&:after\": {\n            content: \"'ƒ'\"\n        }\n    },\n    \".cm-completionIcon-class\": {\n        \"&:after\": {\n            content: \"'○'\"\n        }\n    },\n    \".cm-completionIcon-interface\": {\n        \"&:after\": {\n            content: \"'◌'\"\n        }\n    },\n    \".cm-completionIcon-variable\": {\n        \"&:after\": {\n            content: \"'\\uD835\\uDC65'\"\n        }\n    },\n    \".cm-completionIcon-constant\": {\n        \"&:after\": {\n            content: \"'\\uD835\\uDC36'\"\n        }\n    },\n    \".cm-completionIcon-type\": {\n        \"&:after\": {\n            content: \"'\\uD835\\uDC61'\"\n        }\n    },\n    \".cm-completionIcon-enum\": {\n        \"&:after\": {\n            content: \"'∪'\"\n        }\n    },\n    \".cm-completionIcon-property\": {\n        \"&:after\": {\n            content: \"'□'\"\n        }\n    },\n    \".cm-completionIcon-keyword\": {\n        \"&:after\": {\n            content: \"'\\uD83D\\uDD11︎'\"\n        } // Disable emoji rendering\n    },\n    \".cm-completionIcon-namespace\": {\n        \"&:after\": {\n            content: \"'▢'\"\n        }\n    },\n    \".cm-completionIcon-text\": {\n        \"&:after\": {\n            content: \"'abc'\",\n            fontSize: \"50%\",\n            verticalAlign: \"middle\"\n        }\n    }\n});\nclass FieldPos {\n    constructor(field, line, from, to){\n        this.field = field;\n        this.line = line;\n        this.from = from;\n        this.to = to;\n    }\n}\nclass FieldRange {\n    constructor(field, from, to){\n        this.field = field;\n        this.from = from;\n        this.to = to;\n    }\n    map(changes) {\n        let from = changes.mapPos(this.from, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackDel);\n        let to = changes.mapPos(this.to, 1, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackDel);\n        return from == null || to == null ? null : new FieldRange(this.field, from, to);\n    }\n}\nclass Snippet {\n    constructor(lines, fieldPositions){\n        this.lines = lines;\n        this.fieldPositions = fieldPositions;\n    }\n    instantiate(state, pos) {\n        let text = [], lineStart = [\n            pos\n        ];\n        let lineObj = state.doc.lineAt(pos), baseIndent = /^\\s*/.exec(lineObj.text)[0];\n        for (let line of this.lines){\n            if (text.length) {\n                let indent = baseIndent, tabs = /^\\t*/.exec(line)[0].length;\n                for(let i = 0; i < tabs; i++)indent += state.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.indentUnit);\n                lineStart.push(pos + indent.length - tabs);\n                line = indent + line.slice(tabs);\n            }\n            text.push(line);\n            pos += line.length + 1;\n        }\n        let ranges = this.fieldPositions.map((pos)=>new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to));\n        return {\n            text,\n            ranges\n        };\n    }\n    static parse(template) {\n        let fields = [];\n        let lines = [], positions = [], m;\n        for (let line of template.split(/\\r\\n?|\\n/)){\n            while(m = /[#$]\\{(?:(\\d+)(?::([^}]*))?|([^}]*))\\}/.exec(line)){\n                let seq = m[1] ? +m[1] : null, name = m[2] || m[3] || \"\", found = -1;\n                for(let i = 0; i < fields.length; i++){\n                    if (seq != null ? fields[i].seq == seq : name ? fields[i].name == name : false) found = i;\n                }\n                if (found < 0) {\n                    let i = 0;\n                    while(i < fields.length && (seq == null || fields[i].seq != null && fields[i].seq < seq))i++;\n                    fields.splice(i, 0, {\n                        seq,\n                        name\n                    });\n                    found = i;\n                    for (let pos of positions)if (pos.field >= found) pos.field++;\n                }\n                positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));\n                line = line.slice(0, m.index) + name + line.slice(m.index + m[0].length);\n            }\n            for(let esc; esc = /\\\\([{}])/.exec(line);){\n                line = line.slice(0, esc.index) + esc[1] + line.slice(esc.index + esc[0].length);\n                for (let pos of positions)if (pos.line == lines.length && pos.from > esc.index) {\n                    pos.from--;\n                    pos.to--;\n                }\n            }\n            lines.push(line);\n        }\n        return new Snippet(lines, positions);\n    }\n}\nlet fieldMarker = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.widget({\n    widget: /*@__PURE__*/ new class extends _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.WidgetType {\n        toDOM() {\n            let span = document.createElement(\"span\");\n            span.className = \"cm-snippetFieldPosition\";\n            return span;\n        }\n        ignoreEvent() {\n            return false;\n        }\n    }\n});\nlet fieldRange = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-snippetField\"\n});\nclass ActiveSnippet {\n    constructor(ranges, active){\n        this.ranges = ranges;\n        this.active = active;\n        this.deco = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.set(ranges.map((r)=>(r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)));\n    }\n    map(changes) {\n        let ranges = [];\n        for (let r of this.ranges){\n            let mapped = r.map(changes);\n            if (!mapped) return null;\n            ranges.push(mapped);\n        }\n        return new ActiveSnippet(ranges, this.active);\n    }\n    selectionInsideField(sel) {\n        return sel.ranges.every((range)=>this.ranges.some((r)=>r.field == this.active && r.from <= range.from && r.to >= range.to));\n    }\n}\nconst setActive = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\n    map (value, changes) {\n        return value && value.map(changes);\n    }\n});\nconst moveToField = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst snippetState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return null;\n    },\n    update (value, tr) {\n        for (let effect of tr.effects){\n            if (effect.is(setActive)) return effect.value;\n            if (effect.is(moveToField) && value) return new ActiveSnippet(value.ranges, effect.value);\n        }\n        if (value && tr.docChanged) value = value.map(tr.changes);\n        if (value && tr.selection && !value.selectionInsideField(tr.selection)) value = null;\n        return value;\n    },\n    provide: (f)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.decorations.from(f, (val)=>val ? val.deco : _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none)\n});\nfunction fieldSelection(ranges, field) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges.filter((r)=>r.field == field).map((r)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.from, r.to)));\n}\n/**\nConvert a snippet template to a function that can\n[apply](https://codemirror.net/6/docs/ref/#autocomplete.Completion.apply) it. Snippets are written\nusing syntax like this:\n\n    \"for (let ${index} = 0; ${index} < ${end}; ${index}++) {\\n\\t${}\\n}\"\n\nEach `${}` placeholder (you may also use `#{}`) indicates a field\nthat the user can fill in. Its name, if any, will be the default\ncontent for the field.\n\nWhen the snippet is activated by calling the returned function,\nthe code is inserted at the given position. Newlines in the\ntemplate are indented by the indentation of the start line, plus\none [indent unit](https://codemirror.net/6/docs/ref/#language.indentUnit) per tab character after\nthe newline.\n\nOn activation, (all instances of) the first field are selected.\nThe user can move between fields with Tab and Shift-Tab as long as\nthe fields are active. Moving to the last field or moving the\ncursor out of the current field deactivates the fields.\n\nThe order of fields defaults to textual order, but you can add\nnumbers to placeholders (`${1}` or `${1:defaultText}`) to provide\na custom order.\n\nTo include a literal `{` or `}` in your template, put a backslash\nin front of it. This will be removed and the brace will not be\ninterpreted as indicating a placeholder.\n*/ function snippet(template) {\n    let snippet = Snippet.parse(template);\n    return (editor, completion, from, to)=>{\n        let { text, ranges } = snippet.instantiate(editor.state, from);\n        let spec = {\n            changes: {\n                from,\n                to,\n                insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of(text)\n            },\n            scrollIntoView: true,\n            annotations: completion ? [\n                pickedCompletion.of(completion),\n                _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.userEvent.of(\"input.complete\")\n            ] : undefined\n        };\n        if (ranges.length) spec.selection = fieldSelection(ranges, 0);\n        if (ranges.some((r)=>r.field > 0)) {\n            let active = new ActiveSnippet(ranges, 0);\n            let effects = spec.effects = [\n                setActive.of(active)\n            ];\n            if (editor.state.field(snippetState, false) === undefined) effects.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of([\n                snippetState,\n                addSnippetKeymap,\n                snippetPointerHandler,\n                baseTheme\n            ]));\n        }\n        editor.dispatch(editor.state.update(spec));\n    };\n}\nfunction moveField(dir) {\n    return ({ state, dispatch })=>{\n        let active = state.field(snippetState, false);\n        if (!active || dir < 0 && active.active == 0) return false;\n        let next = active.active + dir, last = dir > 0 && !active.ranges.some((r)=>r.field == next + dir);\n        dispatch(state.update({\n            selection: fieldSelection(active.ranges, next),\n            effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next)),\n            scrollIntoView: true\n        }));\n        return true;\n    };\n}\n/**\nA command that clears the active snippet, if any.\n*/ const clearSnippet = ({ state, dispatch })=>{\n    let active = state.field(snippetState, false);\n    if (!active) return false;\n    dispatch(state.update({\n        effects: setActive.of(null)\n    }));\n    return true;\n};\n/**\nMove to the next snippet field, if available.\n*/ const nextSnippetField = /*@__PURE__*/ moveField(1);\n/**\nMove to the previous snippet field, if available.\n*/ const prevSnippetField = /*@__PURE__*/ moveField(-1);\n/**\nCheck if there is an active snippet with a next field for\n`nextSnippetField` to move to.\n*/ function hasNextSnippetField(state) {\n    let active = state.field(snippetState, false);\n    return !!(active && active.ranges.some((r)=>r.field == active.active + 1));\n}\n/**\nReturns true if there is an active snippet and a previous field\nfor `prevSnippetField` to move to.\n*/ function hasPrevSnippetField(state) {\n    let active = state.field(snippetState, false);\n    return !!(active && active.active > 0);\n}\nconst defaultSnippetKeymap = [\n    {\n        key: \"Tab\",\n        run: nextSnippetField,\n        shift: prevSnippetField\n    },\n    {\n        key: \"Escape\",\n        run: clearSnippet\n    }\n];\n/**\nA facet that can be used to configure the key bindings used by\nsnippets. The default binds Tab to\n[`nextSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.nextSnippetField), Shift-Tab to\n[`prevSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.prevSnippetField), and Escape\nto [`clearSnippet`](https://codemirror.net/6/docs/ref/#autocomplete.clearSnippet).\n*/ const snippetKeymap = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (maps) {\n        return maps.length ? maps[0] : defaultSnippetKeymap;\n    }\n});\nconst addSnippetKeymap = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.highest(/*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.keymap.compute([\n    snippetKeymap\n], (state)=>state.facet(snippetKeymap)));\n/**\nCreate a completion from a snippet. Returns an object with the\nproperties from `completion`, plus an `apply` function that\napplies the snippet.\n*/ function snippetCompletion(template, completion) {\n    return Object.assign(Object.assign({}, completion), {\n        apply: snippet(template)\n    });\n}\nconst snippetPointerHandler = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.domEventHandlers({\n    mousedown (event, view) {\n        let active = view.state.field(snippetState, false), pos;\n        if (!active || (pos = view.posAtCoords({\n            x: event.clientX,\n            y: event.clientY\n        })) == null) return false;\n        let match = active.ranges.find((r)=>r.from <= pos && r.to >= pos);\n        if (!match || match.field == active.active) return false;\n        view.dispatch({\n            selection: fieldSelection(active.ranges, match.field),\n            effects: setActive.of(active.ranges.some((r)=>r.field > match.field) ? new ActiveSnippet(active.ranges, match.field) : null),\n            scrollIntoView: true\n        });\n        return true;\n    }\n});\nfunction wordRE(wordChars) {\n    let escaped = wordChars.replace(/[\\]\\-\\\\]/g, \"\\\\$&\");\n    try {\n        return new RegExp(`[\\\\p{Alphabetic}\\\\p{Number}_${escaped}]+`, \"ug\");\n    } catch (_a) {\n        return new RegExp(`[\\w${escaped}]`, \"g\");\n    }\n}\nfunction mapRE(re, f) {\n    return new RegExp(f(re.source), re.unicode ? \"u\" : \"\");\n}\nconst wordCaches = /*@__PURE__*/ Object.create(null);\nfunction wordCache(wordChars) {\n    return wordCaches[wordChars] || (wordCaches[wordChars] = new WeakMap);\n}\nfunction storeWords(doc, wordRE, result, seen, ignoreAt) {\n    for(let lines = doc.iterLines(), pos = 0; !lines.next().done;){\n        let { value } = lines, m;\n        wordRE.lastIndex = 0;\n        while(m = wordRE.exec(value)){\n            if (!seen[m[0]] && pos + m.index != ignoreAt) {\n                result.push({\n                    type: \"text\",\n                    label: m[0]\n                });\n                seen[m[0]] = true;\n                if (result.length >= 2000 /* C.MaxList */ ) return;\n            }\n        }\n        pos += value.length + 1;\n    }\n}\nfunction collectWords(doc, cache, wordRE, to, ignoreAt) {\n    let big = doc.length >= 1000 /* C.MinCacheLen */ ;\n    let cached = big && cache.get(doc);\n    if (cached) return cached;\n    let result = [], seen = Object.create(null);\n    if (doc.children) {\n        let pos = 0;\n        for (let ch of doc.children){\n            if (ch.length >= 1000 /* C.MinCacheLen */ ) {\n                for (let c of collectWords(ch, cache, wordRE, to - pos, ignoreAt - pos)){\n                    if (!seen[c.label]) {\n                        seen[c.label] = true;\n                        result.push(c);\n                    }\n                }\n            } else {\n                storeWords(ch, wordRE, result, seen, ignoreAt - pos);\n            }\n            pos += ch.length + 1;\n        }\n    } else {\n        storeWords(doc, wordRE, result, seen, ignoreAt);\n    }\n    if (big && result.length < 2000 /* C.MaxList */ ) cache.set(doc, result);\n    return result;\n}\n/**\nA completion source that will scan the document for words (using a\n[character categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer)), and\nreturn those as completions.\n*/ const completeAnyWord = (context)=>{\n    let wordChars = context.state.languageDataAt(\"wordChars\", context.pos).join(\"\");\n    let re = wordRE(wordChars);\n    let token = context.matchBefore(mapRE(re, (s)=>s + \"$\"));\n    if (!token && !context.explicit) return null;\n    let from = token ? token.from : context.pos;\n    let options = collectWords(context.state.doc, wordCache(wordChars), re, 50000 /* C.Range */ , from);\n    return {\n        from,\n        options,\n        validFor: mapRE(re, (s)=>\"^\" + s)\n    };\n};\nconst defaults = {\n    brackets: [\n        \"(\",\n        \"[\",\n        \"{\",\n        \"'\",\n        '\"'\n    ],\n    before: \")]}:;>\",\n    stringPrefixes: []\n};\nconst closeBracketEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\n    map (value, mapping) {\n        let mapped = mapping.mapPos(value, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackAfter);\n        return mapped == null ? undefined : mapped;\n    }\n});\nconst closedBracket = /*@__PURE__*/ new class extends _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeValue {\n};\nclosedBracket.startSide = 1;\nclosedBracket.endSide = -1;\nconst bracketState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSet.empty;\n    },\n    update (value, tr) {\n        value = value.map(tr.changes);\n        if (tr.selection) {\n            let line = tr.state.doc.lineAt(tr.selection.main.head);\n            value = value.update({\n                filter: (from)=>from >= line.from && from <= line.to\n            });\n        }\n        for (let effect of tr.effects)if (effect.is(closeBracketEffect)) value = value.update({\n            add: [\n                closedBracket.range(effect.value, effect.value + 1)\n            ]\n        });\n        return value;\n    }\n});\n/**\nExtension to enable bracket-closing behavior. When a closeable\nbracket is typed, its closing bracket is immediately inserted\nafter the cursor. When closing a bracket directly in front of a\nclosing bracket inserted by the extension, the cursor moves over\nthat bracket.\n*/ function closeBrackets() {\n    return [\n        inputHandler,\n        bracketState\n    ];\n}\nconst definedClosing = \"()[]{}<>\";\nfunction closing(ch) {\n    for(let i = 0; i < definedClosing.length; i += 2)if (definedClosing.charCodeAt(i) == ch) return definedClosing.charAt(i + 1);\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(ch < 128 ? ch : ch + 1);\n}\nfunction config(state, pos) {\n    return state.languageDataAt(\"closeBrackets\", pos)[0] || defaults;\n}\nconst android = typeof navigator == \"object\" && /*@__PURE__*/ /Android\\b/.test(navigator.userAgent);\nconst inputHandler = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.inputHandler.of((view, from, to, insert)=>{\n    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly) return false;\n    let sel = view.state.selection.main;\n    if (insert.length > 2 || insert.length == 2 && (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(insert, 0)) == 1 || from != sel.from || to != sel.to) return false;\n    let tr = insertBracket(view.state, insert);\n    if (!tr) return false;\n    view.dispatch(tr);\n    return true;\n});\n/**\nCommand that implements deleting a pair of matching brackets when\nthe cursor is between them.\n*/ const deleteBracketPair = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    let conf = config(state, state.selection.main.head);\n    let tokens = conf.brackets || defaults.brackets;\n    let dont = null, changes = state.changeByRange((range)=>{\n        if (range.empty) {\n            let before = prevChar(state.doc, range.head);\n            for (let token of tokens){\n                if (token == before && nextChar(state.doc, range.head) == closing((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(token, 0))) return {\n                    changes: {\n                        from: range.head - token.length,\n                        to: range.head + token.length\n                    },\n                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head - token.length)\n                };\n            }\n        }\n        return {\n            range: dont = range\n        };\n    });\n    if (!dont) dispatch(state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"delete.backward\"\n    }));\n    return !dont;\n};\n/**\nClose-brackets related key bindings. Binds Backspace to\n[`deleteBracketPair`](https://codemirror.net/6/docs/ref/#autocomplete.deleteBracketPair).\n*/ const closeBracketsKeymap = [\n    {\n        key: \"Backspace\",\n        run: deleteBracketPair\n    }\n];\n/**\nImplements the extension's behavior on text insertion. If the\ngiven string counts as a bracket in the language around the\nselection, and replacing the selection with it requires custom\nbehavior (inserting a closing version or skipping past a\npreviously-closed bracket), this function returns a transaction\nrepresenting that custom behavior. (You only need this if you want\nto programmatically insert brackets—the\n[`closeBrackets`](https://codemirror.net/6/docs/ref/#autocomplete.closeBrackets) extension will\ntake care of running this for user input.)\n*/ function insertBracket(state, bracket) {\n    let conf = config(state, state.selection.main.head);\n    let tokens = conf.brackets || defaults.brackets;\n    for (let tok of tokens){\n        let closed = closing((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(tok, 0));\n        if (bracket == tok) return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf) : handleOpen(state, tok, closed, conf.before || defaults.before);\n        if (bracket == closed && closedBracketAt(state, state.selection.main.from)) return handleClose(state, tok, closed);\n    }\n    return null;\n}\nfunction closedBracketAt(state, pos) {\n    let found = false;\n    state.field(bracketState).between(0, state.doc.length, (from)=>{\n        if (from == pos) found = true;\n    });\n    return found;\n}\nfunction nextChar(doc, pos) {\n    let next = doc.sliceString(pos, pos + 2);\n    return next.slice(0, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(next, 0)));\n}\nfunction prevChar(doc, pos) {\n    let prev = doc.sliceString(pos - 2, pos);\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(prev, 0)) == prev.length ? prev : prev.slice(1);\n}\nfunction handleOpen(state, open, close, closeBefore) {\n    let dont = null, changes = state.changeByRange((range)=>{\n        if (!range.empty) return {\n            changes: [\n                {\n                    insert: open,\n                    from: range.from\n                },\n                {\n                    insert: close,\n                    from: range.to\n                }\n            ],\n            effects: closeBracketEffect.of(range.to + open.length),\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor + open.length, range.head + open.length)\n        };\n        let next = nextChar(state.doc, range.head);\n        if (!next || /\\s/.test(next) || closeBefore.indexOf(next) > -1) return {\n            changes: {\n                insert: open + close,\n                from: range.head\n            },\n            effects: closeBracketEffect.of(range.head + open.length),\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head + open.length)\n        };\n        return {\n            range: dont = range\n        };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input.type\"\n    });\n}\nfunction handleClose(state, _open, close) {\n    let dont = null, changes = state.changeByRange((range)=>{\n        if (range.empty && nextChar(state.doc, range.head) == close) return {\n            changes: {\n                from: range.head,\n                to: range.head + close.length,\n                insert: close\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head + close.length)\n        };\n        return dont = {\n            range\n        };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input.type\"\n    });\n}\n// Handles cases where the open and close token are the same, and\n// possibly triple quotes (as in `\"\"\"abc\"\"\"`-style quoting).\nfunction handleSame(state, token, allowTriple, config) {\n    let stringPrefixes = config.stringPrefixes || defaults.stringPrefixes;\n    let dont = null, changes = state.changeByRange((range)=>{\n        if (!range.empty) return {\n            changes: [\n                {\n                    insert: token,\n                    from: range.from\n                },\n                {\n                    insert: token,\n                    from: range.to\n                }\n            ],\n            effects: closeBracketEffect.of(range.to + token.length),\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor + token.length, range.head + token.length)\n        };\n        let pos = range.head, next = nextChar(state.doc, pos), start;\n        if (next == token) {\n            if (nodeStart(state, pos)) {\n                return {\n                    changes: {\n                        insert: token + token,\n                        from: pos\n                    },\n                    effects: closeBracketEffect.of(pos + token.length),\n                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length)\n                };\n            } else if (closedBracketAt(state, pos)) {\n                let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;\n                let content = isTriple ? token + token + token : token;\n                return {\n                    changes: {\n                        from: pos,\n                        to: pos + content.length,\n                        insert: content\n                    },\n                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + content.length)\n                };\n            }\n        } else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token && (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 && nodeStart(state, start)) {\n            return {\n                changes: {\n                    insert: token + token + token + token,\n                    from: pos\n                },\n                effects: closeBracketEffect.of(pos + token.length),\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length)\n            };\n        } else if (state.charCategorizer(pos)(next) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) {\n            if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes)) return {\n                changes: {\n                    insert: token + token,\n                    from: pos\n                },\n                effects: closeBracketEffect.of(pos + token.length),\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length)\n            };\n        }\n        return {\n            range: dont = range\n        };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input.type\"\n    });\n}\nfunction nodeStart(state, pos) {\n    let tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(state).resolveInner(pos + 1);\n    return tree.parent && tree.from == pos;\n}\nfunction probablyInString(state, pos, quoteToken, prefixes) {\n    let node = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(state).resolveInner(pos, -1);\n    let maxPrefix = prefixes.reduce((m, p)=>Math.max(m, p.length), 0);\n    for(let i = 0; i < 5; i++){\n        let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));\n        let quotePos = start.indexOf(quoteToken);\n        if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {\n            let first = node.firstChild;\n            while(first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos){\n                if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken) return false;\n                first = first.firstChild;\n            }\n            return true;\n        }\n        let parent = node.to == pos && node.parent;\n        if (!parent) break;\n        node = parent;\n    }\n    return false;\n}\nfunction canStartStringAt(state, pos, prefixes) {\n    let charCat = state.charCategorizer(pos);\n    if (charCat(state.sliceDoc(pos - 1, pos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) return pos;\n    for (let prefix of prefixes){\n        let start = pos - prefix.length;\n        if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) return start;\n    }\n    return -1;\n}\n/**\nReturns an extension that enables autocompletion.\n*/ function autocompletion(config = {}) {\n    return [\n        completionState,\n        completionConfig.of(config),\n        completionPlugin,\n        completionKeymapExt,\n        baseTheme\n    ];\n}\n/**\nBasic keybindings for autocompletion.\n\n - Ctrl-Space: [`startCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.startCompletion)\n - Escape: [`closeCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.closeCompletion)\n - ArrowDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true)`\n - ArrowUp: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(false)`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - Enter: [`acceptCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.acceptCompletion)\n*/ const completionKeymap = [\n    {\n        key: \"Ctrl-Space\",\n        run: startCompletion\n    },\n    {\n        key: \"Escape\",\n        run: closeCompletion\n    },\n    {\n        key: \"ArrowDown\",\n        run: /*@__PURE__*/ moveCompletionSelection(true)\n    },\n    {\n        key: \"ArrowUp\",\n        run: /*@__PURE__*/ moveCompletionSelection(false)\n    },\n    {\n        key: \"PageDown\",\n        run: /*@__PURE__*/ moveCompletionSelection(true, \"page\")\n    },\n    {\n        key: \"PageUp\",\n        run: /*@__PURE__*/ moveCompletionSelection(false, \"page\")\n    },\n    {\n        key: \"Enter\",\n        run: acceptCompletion\n    }\n];\nconst completionKeymapExt = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.highest(/*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.keymap.computeN([\n    completionConfig\n], (state)=>state.facet(completionConfig).defaultKeymap ? [\n        completionKeymap\n    ] : []));\n/**\nGet the current completion status. When completions are available,\nthis will return `\"active\"`. When completions are pending (in the\nprocess of being queried), this returns `\"pending\"`. Otherwise, it\nreturns `null`.\n*/ function completionStatus(state) {\n    let cState = state.field(completionState, false);\n    return cState && cState.active.some((a)=>a.state == 1 /* State.Pending */ ) ? \"pending\" : cState && cState.active.some((a)=>a.state != 0 /* State.Inactive */ ) ? \"active\" : null;\n}\nconst completionArrayCache = /*@__PURE__*/ new WeakMap;\n/**\nReturns the available completions as an array.\n*/ function currentCompletions(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    if (!open || open.disabled) return [];\n    let completions = completionArrayCache.get(open.options);\n    if (!completions) completionArrayCache.set(open.options, completions = open.options.map((o)=>o.completion));\n    return completions;\n}\n/**\nReturn the currently selected completion, if any.\n*/ function selectedCompletion(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    return open && !open.disabled && open.selected >= 0 ? open.options[open.selected].completion : null;\n}\n/**\nReturns the currently selected position in the active completion\nlist, or null if no completions are active.\n*/ function selectedCompletionIndex(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    return open && !open.disabled && open.selected >= 0 ? open.selected : null;\n}\n/**\nCreate an effect that can be attached to a transaction to change\nthe currently selected completion.\n*/ function setSelectedCompletion(index) {\n    return setSelectedEffect.of(index);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvYXV0b2NvbXBsZXRlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdPO0FBQ3BGO0FBQzlFO0FBRTlEOztBQUVBLEdBQ0EsTUFBTTJCO0lBQ0Y7Ozs7SUFJQSxHQUNBQyxZQUNBOztJQUVBLEdBQ0FDLEtBQUssRUFDTDs7SUFFQSxHQUNBQyxHQUFHLEVBQ0g7Ozs7O0lBS0EsR0FDQUMsUUFBUSxDQUFFO1FBQ04sSUFBSSxDQUFDRixLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDQyxRQUFRLEdBQUdBO1FBQ2hCOztRQUVBLEdBQ0EsSUFBSSxDQUFDQyxjQUFjLEdBQUcsRUFBRTtJQUM1QjtJQUNBOzs7SUFHQSxHQUNBQyxZQUFZQyxLQUFLLEVBQUU7UUFDZixJQUFJQyxRQUFRVixnRUFBVUEsQ0FBQyxJQUFJLENBQUNJLEtBQUssRUFBRU8sWUFBWSxDQUFDLElBQUksQ0FBQ04sR0FBRyxFQUFFLENBQUM7UUFDM0QsTUFBT0ssU0FBU0QsTUFBTUcsT0FBTyxDQUFDRixNQUFNRyxJQUFJLElBQUksRUFDeENILFFBQVFBLE1BQU1JLE1BQU07UUFDeEIsT0FBT0osUUFBUTtZQUFFSyxNQUFNTCxNQUFNSyxJQUFJO1lBQUVDLElBQUksSUFBSSxDQUFDWCxHQUFHO1lBQzNDWSxNQUFNLElBQUksQ0FBQ2IsS0FBSyxDQUFDYyxRQUFRLENBQUNSLE1BQU1LLElBQUksRUFBRSxJQUFJLENBQUNWLEdBQUc7WUFDOUNjLE1BQU1ULE1BQU1TLElBQUk7UUFBQyxJQUFJO0lBQzdCO0lBQ0E7OztJQUdBLEdBQ0FDLFlBQVlDLElBQUksRUFBRTtRQUNkLElBQUlDLE9BQU8sSUFBSSxDQUFDbEIsS0FBSyxDQUFDbUIsR0FBRyxDQUFDQyxNQUFNLENBQUMsSUFBSSxDQUFDbkIsR0FBRztRQUN6QyxJQUFJb0Is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QzRMLEtBQUtmLFFBQVEsQ0FBQyxDQUFDdkosVUFBVSxHQUFHO0FBQ25HO0FBQ0E7OztBQUdBLEdBQ0EsU0FBU2toQix3QkFBd0JubEIsS0FBSztJQUNsQyxJQUFJc0U7SUFDSixJQUFJaUssT0FBTyxDQUFDakssS0FBS3RFLE1BQU1zTyxLQUFLLENBQUNzSSxpQkFBaUIsTUFBSyxNQUFPLFFBQVF0UyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdpSyxJQUFJO0lBQ2xHLE9BQU9BLFFBQVEsQ0FBQ0EsS0FBS3dCLFFBQVEsSUFBSXhCLEtBQUtmLFFBQVEsSUFBSSxJQUFJZSxLQUFLZixRQUFRLEdBQUc7QUFDMUU7QUFDQTs7O0FBR0EsR0FDQSxTQUFTNFgsc0JBQXNCbEksS0FBSztJQUNoQyxPQUFPeEgsa0JBQWtCckcsRUFBRSxDQUFDNk47QUFDaEM7QUFFNmhCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWJjLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2F1dG9jb21wbGV0ZS9kaXN0L2luZGV4LmpzP2ExMDMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQW5ub3RhdGlvbiwgU3RhdGVFZmZlY3QsIEVkaXRvclNlbGVjdGlvbiwgY29kZVBvaW50QXQsIGNvZGVQb2ludFNpemUsIGZyb21Db2RlUG9pbnQsIEZhY2V0LCBjb21iaW5lQ29uZmlnLCBTdGF0ZUZpZWxkLCBQcmVjLCBUZXh0LCBUcmFuc2FjdGlvbiwgTWFwTW9kZSwgUmFuZ2VWYWx1ZSwgUmFuZ2VTZXQsIENoYXJDYXRlZ29yeSB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IERpcmVjdGlvbiwgbG9nRXhjZXB0aW9uLCBzaG93VG9vbHRpcCwgRWRpdG9yVmlldywgVmlld1BsdWdpbiwgZ2V0VG9vbHRpcCwgRGVjb3JhdGlvbiwgV2lkZ2V0VHlwZSwga2V5bWFwIH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQgeyBzeW50YXhUcmVlLCBpbmRlbnRVbml0IH0gZnJvbSAnQGNvZGVtaXJyb3IvbGFuZ3VhZ2UnO1xuXG4vKipcbkFuIGluc3RhbmNlIG9mIHRoaXMgaXMgcGFzc2VkIHRvIGNvbXBsZXRpb24gc291cmNlIGZ1bmN0aW9ucy5cbiovXG5jbGFzcyBDb21wbGV0aW9uQ29udGV4dCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IGNvbXBsZXRpb24gY29udGV4dC4gKE1vc3RseSB1c2VmdWwgZm9yIHRlc3RpbmdcbiAgICBjb21wbGV0aW9uIHNvdXJjZXPigJRpbiB0aGUgZWRpdG9yLCB0aGUgZXh0ZW5zaW9uIHdpbGwgY3JlYXRlXG4gICAgdGhlc2UgZm9yIHlvdS4pXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgZWRpdG9yIHN0YXRlIHRoYXQgdGhlIGNvbXBsZXRpb24gaGFwcGVucyBpbi5cbiAgICAqL1xuICAgIHN0YXRlLCBcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gYXQgd2hpY2ggdGhlIGNvbXBsZXRpb24gaXMgaGFwcGVuaW5nLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciBjb21wbGV0aW9uIHdhcyBhY3RpdmF0ZWQgZXhwbGljaXRseSwgb3JcbiAgICBpbXBsaWNpdGx5IGJ5IHR5cGluZy4gVGhlIHVzdWFsIHdheSB0byByZXNwb25kIHRvIHRoaXMgaXMgdG9cbiAgICBvbmx5IHJldHVybiBjb21wbGV0aW9ucyB3aGVuIGVpdGhlciB0aGVyZSBpcyBwYXJ0IG9mIGFcbiAgICBjb21wbGV0YWJsZSBlbnRpdHkgYmVmb3JlIHRoZSBjdXJzb3IsIG9yIGBleHBsaWNpdGAgaXMgdHJ1ZS5cbiAgICAqL1xuICAgIGV4cGxpY2l0KSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuZXhwbGljaXQgPSBleHBsaWNpdDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmFib3J0TGlzdGVuZXJzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZXh0ZW50LCBjb250ZW50LCBhbmQgKGlmIHRoZXJlIGlzIGEgdG9rZW4pIHR5cGUgb2YgdGhlXG4gICAgdG9rZW4gYmVmb3JlIGB0aGlzLnBvc2AuXG4gICAgKi9cbiAgICB0b2tlbkJlZm9yZSh0eXBlcykge1xuICAgICAgICBsZXQgdG9rZW4gPSBzeW50YXhUcmVlKHRoaXMuc3RhdGUpLnJlc29sdmVJbm5lcih0aGlzLnBvcywgLTEpO1xuICAgICAgICB3aGlsZSAodG9rZW4gJiYgdHlwZXMuaW5kZXhPZih0b2tlbi5uYW1lKSA8IDApXG4gICAgICAgICAgICB0b2tlbiA9IHRva2VuLnBhcmVudDtcbiAgICAgICAgcmV0dXJuIHRva2VuID8geyBmcm9tOiB0b2tlbi5mcm9tLCB0bzogdGhpcy5wb3MsXG4gICAgICAgICAgICB0ZXh0OiB0aGlzLnN0YXRlLnNsaWNlRG9jKHRva2VuLmZyb20sIHRoaXMucG9zKSxcbiAgICAgICAgICAgIHR5cGU6IHRva2VuLnR5cGUgfSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbWF0Y2ggb2YgdGhlIGdpdmVuIGV4cHJlc3Npb24gZGlyZWN0bHkgYmVmb3JlIHRoZVxuICAgIGN1cnNvci5cbiAgICAqL1xuICAgIG1hdGNoQmVmb3JlKGV4cHIpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQodGhpcy5wb3MpO1xuICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChsaW5lLmZyb20sIHRoaXMucG9zIC0gMjUwKTtcbiAgICAgICAgbGV0IHN0ciA9IGxpbmUudGV4dC5zbGljZShzdGFydCAtIGxpbmUuZnJvbSwgdGhpcy5wb3MgLSBsaW5lLmZyb20pO1xuICAgICAgICBsZXQgZm91bmQgPSBzdHIuc2VhcmNoKGVuc3VyZUFuY2hvcihleHByLCBmYWxzZSkpO1xuICAgICAgICByZXR1cm4gZm91bmQgPCAwID8gbnVsbCA6IHsgZnJvbTogc3RhcnQgKyBmb3VuZCwgdG86IHRoaXMucG9zLCB0ZXh0OiBzdHIuc2xpY2UoZm91bmQpIH07XG4gICAgfVxuICAgIC8qKlxuICAgIFlpZWxkcyB0cnVlIHdoZW4gdGhlIHF1ZXJ5IGhhcyBiZWVuIGFib3J0ZWQuIENhbiBiZSB1c2VmdWwgaW5cbiAgICBhc3luY2hyb25vdXMgcXVlcmllcyB0byBhdm9pZCBkb2luZyB3b3JrIHRoYXQgd2lsbCBiZSBpZ25vcmVkLlxuICAgICovXG4gICAgZ2V0IGFib3J0ZWQoKSB7IHJldHVybiB0aGlzLmFib3J0TGlzdGVuZXJzID09IG51bGw7IH1cbiAgICAvKipcbiAgICBBbGxvd3MgeW91IHRvIHJlZ2lzdGVyIGFib3J0IGhhbmRsZXJzLCB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gICAgdGhlIHF1ZXJ5IGlzXG4gICAgW2Fib3J0ZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLkNvbXBsZXRpb25Db250ZXh0LmFib3J0ZWQpLlxuICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAodHlwZSA9PSBcImFib3J0XCIgJiYgdGhpcy5hYm9ydExpc3RlbmVycylcbiAgICAgICAgICAgIHRoaXMuYWJvcnRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfVxufVxuZnVuY3Rpb24gdG9TZXQoY2hhcnMpIHtcbiAgICBsZXQgZmxhdCA9IE9iamVjdC5rZXlzKGNoYXJzKS5qb2luKFwiXCIpO1xuICAgIGxldCB3b3JkcyA9IC9cXHcvLnRlc3QoZmxhdCk7XG4gICAgaWYgKHdvcmRzKVxuICAgICAgICBmbGF0ID0gZmxhdC5yZXBsYWNlKC9cXHcvZywgXCJcIik7XG4gICAgcmV0dXJuIGBbJHt3b3JkcyA/IFwiXFxcXHdcIiA6IFwiXCJ9JHtmbGF0LnJlcGxhY2UoL1teXFx3XFxzXS9nLCBcIlxcXFwkJlwiKX1dYDtcbn1cbmZ1bmN0aW9uIHByZWZpeE1hdGNoKG9wdGlvbnMpIHtcbiAgICBsZXQgZmlyc3QgPSBPYmplY3QuY3JlYXRlKG51bGwpLCByZXN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCB7IGxhYmVsIH0gb2Ygb3B0aW9ucykge1xuICAgICAgICBmaXJzdFtsYWJlbFswXV0gPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxhYmVsLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcmVzdFtsYWJlbFtpXV0gPSB0cnVlO1xuICAgIH1cbiAgICBsZXQgc291cmNlID0gdG9TZXQoZmlyc3QpICsgdG9TZXQocmVzdCkgKyBcIiokXCI7XG4gICAgcmV0dXJuIFtuZXcgUmVnRXhwKFwiXlwiICsgc291cmNlKSwgbmV3IFJlZ0V4cChzb3VyY2UpXTtcbn1cbi8qKlxuR2l2ZW4gYSBhIGZpeGVkIGFycmF5IG9mIG9wdGlvbnMsIHJldHVybiBhbiBhdXRvY29tcGxldGVyIHRoYXRcbmNvbXBsZXRlcyB0aGVtLlxuKi9cbmZ1bmN0aW9uIGNvbXBsZXRlRnJvbUxpc3QobGlzdCkge1xuICAgIGxldCBvcHRpb25zID0gbGlzdC5tYXAobyA9PiB0eXBlb2YgbyA9PSBcInN0cmluZ1wiID8geyBsYWJlbDogbyB9IDogbyk7XG4gICAgbGV0IFt2YWxpZEZvciwgbWF0Y2hdID0gb3B0aW9ucy5ldmVyeShvID0+IC9eXFx3KyQvLnRlc3Qoby5sYWJlbCkpID8gWy9cXHcqJC8sIC9cXHcrJC9dIDogcHJlZml4TWF0Y2gob3B0aW9ucyk7XG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGxldCB0b2tlbiA9IGNvbnRleHQubWF0Y2hCZWZvcmUobWF0Y2gpO1xuICAgICAgICByZXR1cm4gdG9rZW4gfHwgY29udGV4dC5leHBsaWNpdCA/IHsgZnJvbTogdG9rZW4gPyB0b2tlbi5mcm9tIDogY29udGV4dC5wb3MsIG9wdGlvbnMsIHZhbGlkRm9yIH0gOiBudWxsO1xuICAgIH07XG59XG4vKipcbldyYXAgdGhlIGdpdmVuIGNvbXBsZXRpb24gc291cmNlIHNvIHRoYXQgaXQgd2lsbCBvbmx5IGZpcmUgd2hlbiB0aGVcbmN1cnNvciBpcyBpbiBhIHN5bnRheCBub2RlIHdpdGggb25lIG9mIHRoZSBnaXZlbiBuYW1lcy5cbiovXG5mdW5jdGlvbiBpZkluKG5vZGVzLCBzb3VyY2UpIHtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gc3ludGF4VHJlZShjb250ZXh0LnN0YXRlKS5yZXNvbHZlSW5uZXIoY29udGV4dC5wb3MsIC0xKTsgcG9zOyBwb3MgPSBwb3MucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAobm9kZXMuaW5kZXhPZihwb3MubmFtZSkgPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlKGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKHBvcy50eXBlLmlzVG9wKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG59XG4vKipcbldyYXAgdGhlIGdpdmVuIGNvbXBsZXRpb24gc291cmNlIHNvIHRoYXQgaXQgd2lsbCBub3QgZmlyZSB3aGVuIHRoZVxuY3Vyc29yIGlzIGluIGEgc3ludGF4IG5vZGUgd2l0aCBvbmUgb2YgdGhlIGdpdmVuIG5hbWVzLlxuKi9cbmZ1bmN0aW9uIGlmTm90SW4obm9kZXMsIHNvdXJjZSkge1xuICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBwb3MgPSBzeW50YXhUcmVlKGNvbnRleHQuc3RhdGUpLnJlc29sdmVJbm5lcihjb250ZXh0LnBvcywgLTEpOyBwb3M7IHBvcyA9IHBvcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChub2Rlcy5pbmRleE9mKHBvcy5uYW1lKSA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKHBvcy50eXBlLmlzVG9wKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2UoY29udGV4dCk7XG4gICAgfTtcbn1cbmNsYXNzIE9wdGlvbiB7XG4gICAgY29uc3RydWN0b3IoY29tcGxldGlvbiwgc291cmNlLCBtYXRjaCwgc2NvcmUpIHtcbiAgICAgICAgdGhpcy5jb21wbGV0aW9uID0gY29tcGxldGlvbjtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMubWF0Y2ggPSBtYXRjaDtcbiAgICAgICAgdGhpcy5zY29yZSA9IHNjb3JlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGN1cihzdGF0ZSkgeyByZXR1cm4gc3RhdGUuc2VsZWN0aW9uLm1haW4uZnJvbTsgfVxuLy8gTWFrZSBzdXJlIHRoZSBnaXZlbiByZWdleHAgaGFzIGEgJCBhdCBpdHMgZW5kIGFuZCwgaWYgYHN0YXJ0YCBpc1xuLy8gdHJ1ZSwgYSBeIGF0IGl0cyBzdGFydC5cbmZ1bmN0aW9uIGVuc3VyZUFuY2hvcihleHByLCBzdGFydCkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgeyBzb3VyY2UgfSA9IGV4cHI7XG4gICAgbGV0IGFkZFN0YXJ0ID0gc3RhcnQgJiYgc291cmNlWzBdICE9IFwiXlwiLCBhZGRFbmQgPSBzb3VyY2Vbc291cmNlLmxlbmd0aCAtIDFdICE9IFwiJFwiO1xuICAgIGlmICghYWRkU3RhcnQgJiYgIWFkZEVuZClcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYCR7YWRkU3RhcnQgPyBcIl5cIiA6IFwiXCJ9KD86JHtzb3VyY2V9KSR7YWRkRW5kID8gXCIkXCIgOiBcIlwifWAsIChfYSA9IGV4cHIuZmxhZ3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChleHByLmlnbm9yZUNhc2UgPyBcImlcIiA6IFwiXCIpKTtcbn1cbi8qKlxuVGhpcyBhbm5vdGF0aW9uIGlzIGFkZGVkIHRvIHRyYW5zYWN0aW9ucyB0aGF0IGFyZSBwcm9kdWNlZCBieVxucGlja2luZyBhIGNvbXBsZXRpb24uXG4qL1xuY29uc3QgcGlja2VkQ29tcGxldGlvbiA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5IZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdHJhbnNhY3Rpb24gc3BlYyB3aGljaCBpbnNlcnRzIGFcbmNvbXBsZXRpb24ncyB0ZXh0IGluIHRoZSBtYWluIHNlbGVjdGlvbiByYW5nZSwgYW5kIGFueSBvdGhlclxuc2VsZWN0aW9uIHJhbmdlIHRoYXQgaGFzIHRoZSBzYW1lIHRleHQgaW4gZnJvbnQgb2YgaXQuXG4qL1xuZnVuY3Rpb24gaW5zZXJ0Q29tcGxldGlvblRleHQoc3RhdGUsIHRleHQsIGZyb20sIHRvKSB7XG4gICAgbGV0IHsgbWFpbiB9ID0gc3RhdGUuc2VsZWN0aW9uLCBmcm9tT2ZmID0gZnJvbSAtIG1haW4uZnJvbSwgdG9PZmYgPSB0byAtIG1haW4uZnJvbTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgaWYgKHJhbmdlICE9IG1haW4gJiYgZnJvbSAhPSB0byAmJlxuICAgICAgICAgICAgc3RhdGUuc2xpY2VEb2MocmFuZ2UuZnJvbSArIGZyb21PZmYsIHJhbmdlLmZyb20gKyB0b09mZikgIT0gc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pKVxuICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuZnJvbSArIGZyb21PZmYsIHRvOiB0byA9PSBtYWluLmZyb20gPyByYW5nZS50byA6IHJhbmdlLmZyb20gKyB0b09mZiwgaW5zZXJ0OiB0ZXh0IH0sXG4gICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5mcm9tICsgZnJvbU9mZiArIHRleHQubGVuZ3RoKVxuICAgICAgICB9O1xuICAgIH0pKSwgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0LmNvbXBsZXRlXCIgfSk7XG59XG5jb25zdCBTb3VyY2VDYWNoZSA9IC8qQF9fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gYXNTb3VyY2Uoc291cmNlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNvdXJjZSkpXG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgbGV0IGtub3duID0gU291cmNlQ2FjaGUuZ2V0KHNvdXJjZSk7XG4gICAgaWYgKCFrbm93bilcbiAgICAgICAgU291cmNlQ2FjaGUuc2V0KHNvdXJjZSwga25vd24gPSBjb21wbGV0ZUZyb21MaXN0KHNvdXJjZSkpO1xuICAgIHJldHVybiBrbm93bjtcbn1cbmNvbnN0IHN0YXJ0Q29tcGxldGlvbkVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IGNsb3NlQ29tcGxldGlvbkVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcblxuLy8gQSBwYXR0ZXJuIG1hdGNoZXIgZm9yIGZ1enp5IGNvbXBsZXRpb24gbWF0Y2hpbmcuIENyZWF0ZSBhbiBpbnN0YW5jZVxuLy8gb25jZSBmb3IgYSBwYXR0ZXJuLCBhbmQgdGhlbiB1c2UgdGhhdCB0byBtYXRjaCBhbnkgbnVtYmVyIG9mXG4vLyBjb21wbGV0aW9ucy5cbmNsYXNzIEZ1enp5TWF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgICAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICAgICAgICB0aGlzLmNoYXJzID0gW107XG4gICAgICAgIHRoaXMuZm9sZGVkID0gW107XG4gICAgICAgIC8vIEJ1ZmZlcnMgcmV1c2VkIGJ5IGNhbGxzIHRvIGBtYXRjaGAgdG8gdHJhY2sgbWF0Y2hlZCBjaGFyYWN0ZXJcbiAgICAgICAgLy8gcG9zaXRpb25zLlxuICAgICAgICB0aGlzLmFueSA9IFtdO1xuICAgICAgICB0aGlzLnByZWNpc2UgPSBbXTtcbiAgICAgICAgdGhpcy5ieVdvcmQgPSBbXTtcbiAgICAgICAgdGhpcy5zY29yZSA9IDA7XG4gICAgICAgIHRoaXMubWF0Y2hlZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IHBhdHRlcm4ubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGNoYXIgPSBjb2RlUG9pbnRBdChwYXR0ZXJuLCBwKSwgc2l6ZSA9IGNvZGVQb2ludFNpemUoY2hhcik7XG4gICAgICAgICAgICB0aGlzLmNoYXJzLnB1c2goY2hhcik7XG4gICAgICAgICAgICBsZXQgcGFydCA9IHBhdHRlcm4uc2xpY2UocCwgcCArIHNpemUpLCB1cHBlciA9IHBhcnQudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuZm9sZGVkLnB1c2goY29kZVBvaW50QXQodXBwZXIgPT0gcGFydCA/IHBhcnQudG9Mb3dlckNhc2UoKSA6IHVwcGVyLCAwKSk7XG4gICAgICAgICAgICBwICs9IHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hc3RyYWwgPSBwYXR0ZXJuLmxlbmd0aCAhPSB0aGlzLmNoYXJzLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0KHNjb3JlLCBtYXRjaGVkKSB7XG4gICAgICAgIHRoaXMuc2NvcmUgPSBzY29yZTtcbiAgICAgICAgdGhpcy5tYXRjaGVkID0gbWF0Y2hlZDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIE1hdGNoZXMgYSBnaXZlbiB3b3JkIChjb21wbGV0aW9uKSBhZ2FpbnN0IHRoZSBwYXR0ZXJuIChpbnB1dCkuXG4gICAgLy8gV2lsbCByZXR1cm4gYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGVyZSB3YXMgYSBtYXRjaCBhbmQsXG4gICAgLy8gb24gc3VjY2Vzcywgc2V0IGB0aGlzLnNjb3JlYCB0byB0aGUgc2NvcmUsIGB0aGlzLm1hdGNoZWRgIHRvIGFuXG4gICAgLy8gYXJyYXkgb2YgYGZyb20sIHRvYCBwYWlycyBpbmRpY2F0aW5nIHRoZSBtYXRjaGVkIHBhcnRzIG9mIGB3b3JkYC5cbiAgICAvL1xuICAgIC8vIFRoZSBzY29yZSBpcyBhIG51bWJlciB0aGF0IGlzIG1vcmUgbmVnYXRpdmUgdGhlIHdvcnNlIHRoZSBtYXRjaFxuICAgIC8vIGlzLiBTZWUgYFBlbmFsdHlgIGFib3ZlLlxuICAgIG1hdGNoKHdvcmQpIHtcbiAgICAgICAgaWYgKHRoaXMucGF0dGVybi5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldCgtMTAwIC8qIFBlbmFsdHkuTm90RnVsbCAqLywgW10pO1xuICAgICAgICBpZiAod29yZC5sZW5ndGggPCB0aGlzLnBhdHRlcm4ubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgeyBjaGFycywgZm9sZGVkLCBhbnksIHByZWNpc2UsIGJ5V29yZCB9ID0gdGhpcztcbiAgICAgICAgLy8gRm9yIHNpbmdsZS1jaGFyYWN0ZXIgcXVlcmllcywgb25seSBtYXRjaCB3aGVuIHRoZXkgb2NjdXIgcmlnaHRcbiAgICAgICAgLy8gYXQgdGhlIHN0YXJ0XG4gICAgICAgIGlmIChjaGFycy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gY29kZVBvaW50QXQod29yZCwgMCksIGZpcnN0U2l6ZSA9IGNvZGVQb2ludFNpemUoZmlyc3QpO1xuICAgICAgICAgICAgbGV0IHNjb3JlID0gZmlyc3RTaXplID09IHdvcmQubGVuZ3RoID8gMCA6IC0xMDAgLyogUGVuYWx0eS5Ob3RGdWxsICovO1xuICAgICAgICAgICAgaWYgKGZpcnN0ID09IGNoYXJzWzBdKSA7XG4gICAgICAgICAgICBlbHNlIGlmIChmaXJzdCA9PSBmb2xkZWRbMF0pXG4gICAgICAgICAgICAgICAgc2NvcmUgKz0gLTIwMCAvKiBQZW5hbHR5LkNhc2VGb2xkICovO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldChzY29yZSwgWzAsIGZpcnN0U2l6ZV0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkaXJlY3QgPSB3b3JkLmluZGV4T2YodGhpcy5wYXR0ZXJuKTtcbiAgICAgICAgaWYgKGRpcmVjdCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV0KHdvcmQubGVuZ3RoID09IHRoaXMucGF0dGVybi5sZW5ndGggPyAwIDogLTEwMCAvKiBQZW5hbHR5Lk5vdEZ1bGwgKi8sIFswLCB0aGlzLnBhdHRlcm4ubGVuZ3RoXSk7XG4gICAgICAgIGxldCBsZW4gPSBjaGFycy5sZW5ndGgsIGFueVRvID0gMDtcbiAgICAgICAgaWYgKGRpcmVjdCA8IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBlID0gTWF0aC5taW4od29yZC5sZW5ndGgsIDIwMCk7IGkgPCBlICYmIGFueVRvIDwgbGVuOykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY29kZVBvaW50QXQod29yZCwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPT0gY2hhcnNbYW55VG9dIHx8IG5leHQgPT0gZm9sZGVkW2FueVRvXSlcbiAgICAgICAgICAgICAgICAgICAgYW55W2FueVRvKytdID0gaTtcbiAgICAgICAgICAgICAgICBpICs9IGNvZGVQb2ludFNpemUobmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBObyBtYXRjaCwgZXhpdCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgaWYgKGFueVRvIDwgbGVuKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIHRyYWNrcyB0aGUgZXh0ZW50IG9mIHRoZSBwcmVjaXNlIChub24tZm9sZGVkLCBub3RcbiAgICAgICAgLy8gbmVjZXNzYXJpbHkgYWRqYWNlbnQpIG1hdGNoXG4gICAgICAgIGxldCBwcmVjaXNlVG8gPSAwO1xuICAgICAgICAvLyBUcmFja3Mgd2hldGhlciB0aGVyZSBpcyBhIG1hdGNoIHRoYXQgaGl0cyBvbmx5IGNoYXJhY3RlcnMgdGhhdFxuICAgICAgICAvLyBhcHBlYXIgdG8gYmUgc3RhcnRpbmcgd29yZHMuIGBieVdvcmRGb2xkZWRgIGlzIHNldCB0byB0cnVlIHdoZW5cbiAgICAgICAgLy8gYSBjYXNlIGZvbGRlZCBjaGFyYWN0ZXIgaXMgZW5jb3VudGVyZWQgaW4gc3VjaCBhIG1hdGNoXG4gICAgICAgIGxldCBieVdvcmRUbyA9IDAsIGJ5V29yZEZvbGRlZCA9IGZhbHNlO1xuICAgICAgICAvLyBJZiB3ZSd2ZSBmb3VuZCBhIHBhcnRpYWwgYWRqYWNlbnQgbWF0Y2gsIHRoZXNlIHRyYWNrIGl0cyBzdGF0ZVxuICAgICAgICBsZXQgYWRqYWNlbnRUbyA9IDAsIGFkamFjZW50U3RhcnQgPSAtMSwgYWRqYWNlbnRFbmQgPSAtMTtcbiAgICAgICAgbGV0IGhhc0xvd2VyID0gL1thLXpdLy50ZXN0KHdvcmQpLCB3b3JkQWRqYWNlbnQgPSB0cnVlO1xuICAgICAgICAvLyBHbyBvdmVyIHRoZSBvcHRpb24ncyB0ZXh0LCBzY2FubmluZyBmb3IgdGhlIHZhcmlvdXMga2luZHMgb2YgbWF0Y2hlc1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgZSA9IE1hdGgubWluKHdvcmQubGVuZ3RoLCAyMDApLCBwcmV2VHlwZSA9IDAgLyogVHAuTm9uV29yZCAqLzsgaSA8IGUgJiYgYnlXb3JkVG8gPCBsZW47KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGNvZGVQb2ludEF0KHdvcmQsIGkpO1xuICAgICAgICAgICAgaWYgKGRpcmVjdCA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocHJlY2lzZVRvIDwgbGVuICYmIG5leHQgPT0gY2hhcnNbcHJlY2lzZVRvXSlcbiAgICAgICAgICAgICAgICAgICAgcHJlY2lzZVtwcmVjaXNlVG8rK10gPSBpO1xuICAgICAgICAgICAgICAgIGlmIChhZGphY2VudFRvIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09IGNoYXJzW2FkamFjZW50VG9dIHx8IG5leHQgPT0gZm9sZGVkW2FkamFjZW50VG9dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRqYWNlbnRUbyA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkamFjZW50U3RhcnQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnRFbmQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkamFjZW50VG8rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkamFjZW50VG8gPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNoLCB0eXBlID0gbmV4dCA8IDB4ZmZcbiAgICAgICAgICAgICAgICA/IChuZXh0ID49IDQ4ICYmIG5leHQgPD0gNTcgfHwgbmV4dCA+PSA5NyAmJiBuZXh0IDw9IDEyMiA/IDIgLyogVHAuTG93ZXIgKi8gOiBuZXh0ID49IDY1ICYmIG5leHQgPD0gOTAgPyAxIC8qIFRwLlVwcGVyICovIDogMCAvKiBUcC5Ob25Xb3JkICovKVxuICAgICAgICAgICAgICAgIDogKChjaCA9IGZyb21Db2RlUG9pbnQobmV4dCkpICE9IGNoLnRvTG93ZXJDYXNlKCkgPyAxIC8qIFRwLlVwcGVyICovIDogY2ggIT0gY2gudG9VcHBlckNhc2UoKSA/IDIgLyogVHAuTG93ZXIgKi8gOiAwIC8qIFRwLk5vbldvcmQgKi8pO1xuICAgICAgICAgICAgaWYgKCFpIHx8IHR5cGUgPT0gMSAvKiBUcC5VcHBlciAqLyAmJiBoYXNMb3dlciB8fCBwcmV2VHlwZSA9PSAwIC8qIFRwLk5vbldvcmQgKi8gJiYgdHlwZSAhPSAwIC8qIFRwLk5vbldvcmQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnNbYnlXb3JkVG9dID09IG5leHQgfHwgKGZvbGRlZFtieVdvcmRUb10gPT0gbmV4dCAmJiAoYnlXb3JkRm9sZGVkID0gdHJ1ZSkpKVxuICAgICAgICAgICAgICAgICAgICBieVdvcmRbYnlXb3JkVG8rK10gPSBpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJ5V29yZC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHdvcmRBZGphY2VudCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldlR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgaSArPSBjb2RlUG9pbnRTaXplKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChieVdvcmRUbyA9PSBsZW4gJiYgYnlXb3JkWzBdID09IDAgJiYgd29yZEFkamFjZW50KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0KC0xMDAgLyogUGVuYWx0eS5CeVdvcmQgKi8gKyAoYnlXb3JkRm9sZGVkID8gLTIwMCAvKiBQZW5hbHR5LkNhc2VGb2xkICovIDogMCksIGJ5V29yZCwgd29yZCk7XG4gICAgICAgIGlmIChhZGphY2VudFRvID09IGxlbiAmJiBhZGphY2VudFN0YXJ0ID09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXQoLTIwMCAvKiBQZW5hbHR5LkNhc2VGb2xkICovIC0gd29yZC5sZW5ndGggKyAoYWRqYWNlbnRFbmQgPT0gd29yZC5sZW5ndGggPyAwIDogLTEwMCAvKiBQZW5hbHR5Lk5vdEZ1bGwgKi8pLCBbMCwgYWRqYWNlbnRFbmRdKTtcbiAgICAgICAgaWYgKGRpcmVjdCA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV0KC03MDAgLyogUGVuYWx0eS5Ob3RTdGFydCAqLyAtIHdvcmQubGVuZ3RoLCBbZGlyZWN0LCBkaXJlY3QgKyB0aGlzLnBhdHRlcm4ubGVuZ3RoXSk7XG4gICAgICAgIGlmIChhZGphY2VudFRvID09IGxlbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldCgtMjAwIC8qIFBlbmFsdHkuQ2FzZUZvbGQgKi8gKyAtNzAwIC8qIFBlbmFsdHkuTm90U3RhcnQgKi8gLSB3b3JkLmxlbmd0aCwgW2FkamFjZW50U3RhcnQsIGFkamFjZW50RW5kXSk7XG4gICAgICAgIGlmIChieVdvcmRUbyA9PSBsZW4pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQoLTEwMCAvKiBQZW5hbHR5LkJ5V29yZCAqLyArIChieVdvcmRGb2xkZWQgPyAtMjAwIC8qIFBlbmFsdHkuQ2FzZUZvbGQgKi8gOiAwKSArIC03MDAgLyogUGVuYWx0eS5Ob3RTdGFydCAqLyArXG4gICAgICAgICAgICAgICAgKHdvcmRBZGphY2VudCA/IDAgOiAtMTEwMCAvKiBQZW5hbHR5LkdhcCAqLyksIGJ5V29yZCwgd29yZCk7XG4gICAgICAgIHJldHVybiBjaGFycy5sZW5ndGggPT0gMiA/IGZhbHNlXG4gICAgICAgICAgICA6IHRoaXMucmVzdWx0KChhbnlbMF0gPyAtNzAwIC8qIFBlbmFsdHkuTm90U3RhcnQgKi8gOiAwKSArIC0yMDAgLyogUGVuYWx0eS5DYXNlRm9sZCAqLyArIC0xMTAwIC8qIFBlbmFsdHkuR2FwICovLCBhbnksIHdvcmQpO1xuICAgIH1cbiAgICByZXN1bHQoc2NvcmUsIHBvc2l0aW9ucywgd29yZCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW10sIGkgPSAwO1xuICAgICAgICBmb3IgKGxldCBwb3Mgb2YgcG9zaXRpb25zKSB7XG4gICAgICAgICAgICBsZXQgdG8gPSBwb3MgKyAodGhpcy5hc3RyYWwgPyBjb2RlUG9pbnRTaXplKGNvZGVQb2ludEF0KHdvcmQsIHBvcykpIDogMSk7XG4gICAgICAgICAgICBpZiAoaSAmJiByZXN1bHRbaSAtIDFdID09IHBvcylcbiAgICAgICAgICAgICAgICByZXN1bHRbaSAtIDFdID0gdG87XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaSsrXSA9IHBvcztcbiAgICAgICAgICAgICAgICByZXN1bHRbaSsrXSA9IHRvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJldChzY29yZSAtIHdvcmQubGVuZ3RoLCByZXN1bHQpO1xuICAgIH1cbn1cblxuY29uc3QgY29tcGxldGlvbkNvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICBhY3RpdmF0ZU9uVHlwaW5nOiB0cnVlLFxuICAgICAgICAgICAgYWN0aXZhdGVPblR5cGluZ0RlbGF5OiAxMDAsXG4gICAgICAgICAgICBzZWxlY3RPbk9wZW46IHRydWUsXG4gICAgICAgICAgICBvdmVycmlkZTogbnVsbCxcbiAgICAgICAgICAgIGNsb3NlT25CbHVyOiB0cnVlLFxuICAgICAgICAgICAgbWF4UmVuZGVyZWRPcHRpb25zOiAxMDAsXG4gICAgICAgICAgICBkZWZhdWx0S2V5bWFwOiB0cnVlLFxuICAgICAgICAgICAgdG9vbHRpcENsYXNzOiAoKSA9PiBcIlwiLFxuICAgICAgICAgICAgb3B0aW9uQ2xhc3M6ICgpID0+IFwiXCIsXG4gICAgICAgICAgICBhYm92ZUN1cnNvcjogZmFsc2UsXG4gICAgICAgICAgICBpY29uczogdHJ1ZSxcbiAgICAgICAgICAgIGFkZFRvT3B0aW9uczogW10sXG4gICAgICAgICAgICBwb3NpdGlvbkluZm86IGRlZmF1bHRQb3NpdGlvbkluZm8sXG4gICAgICAgICAgICBjb21wYXJlQ29tcGxldGlvbnM6IChhLCBiKSA9PiBhLmxhYmVsLmxvY2FsZUNvbXBhcmUoYi5sYWJlbCksXG4gICAgICAgICAgICBpbnRlcmFjdGlvbkRlbGF5OiA3NSxcbiAgICAgICAgICAgIHVwZGF0ZVN5bmNUaW1lOiAxMDBcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgZGVmYXVsdEtleW1hcDogKGEsIGIpID0+IGEgJiYgYixcbiAgICAgICAgICAgIGNsb3NlT25CbHVyOiAoYSwgYikgPT4gYSAmJiBiLFxuICAgICAgICAgICAgaWNvbnM6IChhLCBiKSA9PiBhICYmIGIsXG4gICAgICAgICAgICB0b29sdGlwQ2xhc3M6IChhLCBiKSA9PiBjID0+IGpvaW5DbGFzcyhhKGMpLCBiKGMpKSxcbiAgICAgICAgICAgIG9wdGlvbkNsYXNzOiAoYSwgYikgPT4gYyA9PiBqb2luQ2xhc3MoYShjKSwgYihjKSksXG4gICAgICAgICAgICBhZGRUb09wdGlvbnM6IChhLCBiKSA9PiBhLmNvbmNhdChiKVxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGpvaW5DbGFzcyhhLCBiKSB7XG4gICAgcmV0dXJuIGEgPyBiID8gYSArIFwiIFwiICsgYiA6IGEgOiBiO1xufVxuZnVuY3Rpb24gZGVmYXVsdFBvc2l0aW9uSW5mbyh2aWV3LCBsaXN0LCBvcHRpb24sIGluZm8sIHNwYWNlLCB0b29sdGlwKSB7XG4gICAgbGV0IHJ0bCA9IHZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uUlRMLCBsZWZ0ID0gcnRsLCBuYXJyb3cgPSBmYWxzZTtcbiAgICBsZXQgc2lkZSA9IFwidG9wXCIsIG9mZnNldCwgbWF4V2lkdGg7XG4gICAgbGV0IHNwYWNlTGVmdCA9IGxpc3QubGVmdCAtIHNwYWNlLmxlZnQsIHNwYWNlUmlnaHQgPSBzcGFjZS5yaWdodCAtIGxpc3QucmlnaHQ7XG4gICAgbGV0IGluZm9XaWR0aCA9IGluZm8ucmlnaHQgLSBpbmZvLmxlZnQsIGluZm9IZWlnaHQgPSBpbmZvLmJvdHRvbSAtIGluZm8udG9wO1xuICAgIGlmIChsZWZ0ICYmIHNwYWNlTGVmdCA8IE1hdGgubWluKGluZm9XaWR0aCwgc3BhY2VSaWdodCkpXG4gICAgICAgIGxlZnQgPSBmYWxzZTtcbiAgICBlbHNlIGlmICghbGVmdCAmJiBzcGFjZVJpZ2h0IDwgTWF0aC5taW4oaW5mb1dpZHRoLCBzcGFjZUxlZnQpKVxuICAgICAgICBsZWZ0ID0gdHJ1ZTtcbiAgICBpZiAoaW5mb1dpZHRoIDw9IChsZWZ0ID8gc3BhY2VMZWZ0IDogc3BhY2VSaWdodCkpIHtcbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgoc3BhY2UudG9wLCBNYXRoLm1pbihvcHRpb24udG9wLCBzcGFjZS5ib3R0b20gLSBpbmZvSGVpZ2h0KSkgLSBsaXN0LnRvcDtcbiAgICAgICAgbWF4V2lkdGggPSBNYXRoLm1pbig0MDAgLyogSW5mby5XaWR0aCAqLywgbGVmdCA/IHNwYWNlTGVmdCA6IHNwYWNlUmlnaHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbmFycm93ID0gdHJ1ZTtcbiAgICAgICAgbWF4V2lkdGggPSBNYXRoLm1pbig0MDAgLyogSW5mby5XaWR0aCAqLywgKHJ0bCA/IGxpc3QucmlnaHQgOiBzcGFjZS5yaWdodCAtIGxpc3QubGVmdCkgLSAzMCAvKiBJbmZvLk1hcmdpbiAqLyk7XG4gICAgICAgIGxldCBzcGFjZUJlbG93ID0gc3BhY2UuYm90dG9tIC0gbGlzdC5ib3R0b207XG4gICAgICAgIGlmIChzcGFjZUJlbG93ID49IGluZm9IZWlnaHQgfHwgc3BhY2VCZWxvdyA+IGxpc3QudG9wKSB7IC8vIEJlbG93IHRoZSBjb21wbGV0aW9uXG4gICAgICAgICAgICBvZmZzZXQgPSBvcHRpb24uYm90dG9tIC0gbGlzdC50b3A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIEFib3ZlIGl0XG4gICAgICAgICAgICBzaWRlID0gXCJib3R0b21cIjtcbiAgICAgICAgICAgIG9mZnNldCA9IGxpc3QuYm90dG9tIC0gb3B0aW9uLnRvcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc2NhbGVZID0gKGxpc3QuYm90dG9tIC0gbGlzdC50b3ApIC8gdG9vbHRpcC5vZmZzZXRIZWlnaHQ7XG4gICAgbGV0IHNjYWxlWCA9IChsaXN0LnJpZ2h0IC0gbGlzdC5sZWZ0KSAvIHRvb2x0aXAub2Zmc2V0V2lkdGg7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3R5bGU6IGAke3NpZGV9OiAke29mZnNldCAvIHNjYWxlWX1weDsgbWF4LXdpZHRoOiAke21heFdpZHRoIC8gc2NhbGVYfXB4YCxcbiAgICAgICAgY2xhc3M6IFwiY20tY29tcGxldGlvbkluZm8tXCIgKyAobmFycm93ID8gKHJ0bCA/IFwibGVmdC1uYXJyb3dcIiA6IFwicmlnaHQtbmFycm93XCIpIDogbGVmdCA/IFwibGVmdFwiIDogXCJyaWdodFwiKVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIG9wdGlvbkNvbnRlbnQoY29uZmlnKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBjb25maWcuYWRkVG9PcHRpb25zLnNsaWNlKCk7XG4gICAgaWYgKGNvbmZpZy5pY29ucylcbiAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgIHJlbmRlcihjb21wbGV0aW9uKSB7XG4gICAgICAgICAgICAgICAgbGV0IGljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgIGljb24uY2xhc3NMaXN0LmFkZChcImNtLWNvbXBsZXRpb25JY29uXCIpO1xuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0aW9uLnR5cGUpXG4gICAgICAgICAgICAgICAgICAgIGljb24uY2xhc3NMaXN0LmFkZCguLi5jb21wbGV0aW9uLnR5cGUuc3BsaXQoL1xccysvZykubWFwKGNscyA9PiBcImNtLWNvbXBsZXRpb25JY29uLVwiICsgY2xzKSk7XG4gICAgICAgICAgICAgICAgaWNvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGljb247XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9zaXRpb246IDIwXG4gICAgICAgIH0pO1xuICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgIHJlbmRlcihjb21wbGV0aW9uLCBfcywgX3YsIG1hdGNoKSB7XG4gICAgICAgICAgICBsZXQgbGFiZWxFbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgIGxhYmVsRWx0LmNsYXNzTmFtZSA9IFwiY20tY29tcGxldGlvbkxhYmVsXCI7XG4gICAgICAgICAgICBsZXQgbGFiZWwgPSBjb21wbGV0aW9uLmRpc3BsYXlMYWJlbCB8fCBjb21wbGV0aW9uLmxhYmVsLCBvZmYgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRjaC5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBtYXRjaFtqKytdLCB0byA9IG1hdGNoW2orK107XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPiBvZmYpXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsRWx0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxhYmVsLnNsaWNlKG9mZiwgZnJvbSkpKTtcbiAgICAgICAgICAgICAgICBsZXQgc3BhbiA9IGxhYmVsRWx0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpKTtcbiAgICAgICAgICAgICAgICBzcGFuLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxhYmVsLnNsaWNlKGZyb20sIHRvKSkpO1xuICAgICAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS1jb21wbGV0aW9uTWF0Y2hlZFRleHRcIjtcbiAgICAgICAgICAgICAgICBvZmYgPSB0bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmYgPCBsYWJlbC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbGFiZWxFbHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGFiZWwuc2xpY2Uob2ZmKSkpO1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVsRWx0O1xuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbjogNTBcbiAgICB9LCB7XG4gICAgICAgIHJlbmRlcihjb21wbGV0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIWNvbXBsZXRpb24uZGV0YWlsKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IGRldGFpbEVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgZGV0YWlsRWx0LmNsYXNzTmFtZSA9IFwiY20tY29tcGxldGlvbkRldGFpbFwiO1xuICAgICAgICAgICAgZGV0YWlsRWx0LnRleHRDb250ZW50ID0gY29tcGxldGlvbi5kZXRhaWw7XG4gICAgICAgICAgICByZXR1cm4gZGV0YWlsRWx0O1xuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbjogODBcbiAgICB9KTtcbiAgICByZXR1cm4gY29udGVudC5zb3J0KChhLCBiKSA9PiBhLnBvc2l0aW9uIC0gYi5wb3NpdGlvbikubWFwKGEgPT4gYS5yZW5kZXIpO1xufVxuZnVuY3Rpb24gcmFuZ2VBcm91bmRTZWxlY3RlZCh0b3RhbCwgc2VsZWN0ZWQsIG1heCkge1xuICAgIGlmICh0b3RhbCA8PSBtYXgpXG4gICAgICAgIHJldHVybiB7IGZyb206IDAsIHRvOiB0b3RhbCB9O1xuICAgIGlmIChzZWxlY3RlZCA8IDApXG4gICAgICAgIHNlbGVjdGVkID0gMDtcbiAgICBpZiAoc2VsZWN0ZWQgPD0gKHRvdGFsID4+IDEpKSB7XG4gICAgICAgIGxldCBvZmYgPSBNYXRoLmZsb29yKHNlbGVjdGVkIC8gbWF4KTtcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogb2ZmICogbWF4LCB0bzogKG9mZiArIDEpICogbWF4IH07XG4gICAgfVxuICAgIGxldCBvZmYgPSBNYXRoLmZsb29yKCh0b3RhbCAtIHNlbGVjdGVkKSAvIG1heCk7XG4gICAgcmV0dXJuIHsgZnJvbTogdG90YWwgLSAob2ZmICsgMSkgKiBtYXgsIHRvOiB0b3RhbCAtIG9mZiAqIG1heCB9O1xufVxuY2xhc3MgQ29tcGxldGlvblRvb2x0aXAge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIHN0YXRlRmllbGQsIGFwcGx5Q29tcGxldGlvbikge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnN0YXRlRmllbGQgPSBzdGF0ZUZpZWxkO1xuICAgICAgICB0aGlzLmFwcGx5Q29tcGxldGlvbiA9IGFwcGx5Q29tcGxldGlvbjtcbiAgICAgICAgdGhpcy5pbmZvID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbmZvRGVzdHJveSA9IG51bGw7XG4gICAgICAgIHRoaXMucGxhY2VJbmZvUmVxID0ge1xuICAgICAgICAgICAgcmVhZDogKCkgPT4gdGhpcy5tZWFzdXJlSW5mbygpLFxuICAgICAgICAgICAgd3JpdGU6IChwb3MpID0+IHRoaXMucGxhY2VJbmZvKHBvcyksXG4gICAgICAgICAgICBrZXk6IHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zcGFjZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudENsYXNzID0gXCJcIjtcbiAgICAgICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoc3RhdGVGaWVsZCk7XG4gICAgICAgIGxldCB7IG9wdGlvbnMsIHNlbGVjdGVkIH0gPSBjU3RhdGUub3BlbjtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZyk7XG4gICAgICAgIHRoaXMub3B0aW9uQ29udGVudCA9IG9wdGlvbkNvbnRlbnQoY29uZmlnKTtcbiAgICAgICAgdGhpcy5vcHRpb25DbGFzcyA9IGNvbmZpZy5vcHRpb25DbGFzcztcbiAgICAgICAgdGhpcy50b29sdGlwQ2xhc3MgPSBjb25maWcudG9vbHRpcENsYXNzO1xuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2VBcm91bmRTZWxlY3RlZChvcHRpb25zLmxlbmd0aCwgc2VsZWN0ZWQsIGNvbmZpZy5tYXhSZW5kZXJlZE9wdGlvbnMpO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tdG9vbHRpcC1hdXRvY29tcGxldGVcIjtcbiAgICAgICAgdGhpcy51cGRhdGVUb29sdGlwQ2xhc3Modmlldy5zdGF0ZSk7XG4gICAgICAgIHRoaXMuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgKGUpID0+IHtcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IHZpZXcuc3RhdGUuZmllbGQoc3RhdGVGaWVsZCkub3BlbjtcbiAgICAgICAgICAgIGZvciAobGV0IGRvbSA9IGUudGFyZ2V0LCBtYXRjaDsgZG9tICYmIGRvbSAhPSB0aGlzLmRvbTsgZG9tID0gZG9tLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiTElcIiAmJiAobWF0Y2ggPSAvLShcXGQrKSQvLmV4ZWMoZG9tLmlkKSkgJiYgK21hdGNoWzFdIDwgb3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBseUNvbXBsZXRpb24odmlldywgb3B0aW9uc1srbWF0Y2hbMV1dKTtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIChlKSA9PiB7XG4gICAgICAgICAgICBsZXQgc3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKHRoaXMuc3RhdGVGaWVsZCwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKHN0YXRlICYmIHN0YXRlLnRvb2x0aXAgJiYgdmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5jbG9zZU9uQmx1ciAmJlxuICAgICAgICAgICAgICAgIGUucmVsYXRlZFRhcmdldCAhPSB2aWV3LmNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IGNsb3NlQ29tcGxldGlvbkVmZmVjdC5vZihudWxsKSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2hvd09wdGlvbnMob3B0aW9ucywgY1N0YXRlLmlkKTtcbiAgICB9XG4gICAgbW91bnQoKSB7IHRoaXMudXBkYXRlU2VsKCk7IH1cbiAgICBzaG93T3B0aW9ucyhvcHRpb25zLCBpZCkge1xuICAgICAgICBpZiAodGhpcy5saXN0KVxuICAgICAgICAgICAgdGhpcy5saXN0LnJlbW92ZSgpO1xuICAgICAgICB0aGlzLmxpc3QgPSB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZUxpc3RCb3gob3B0aW9ucywgaWQsIHRoaXMucmFuZ2UpKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5mbylcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5wbGFjZUluZm9SZXEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBjU3RhdGUgPSB1cGRhdGUuc3RhdGUuZmllbGQodGhpcy5zdGF0ZUZpZWxkKTtcbiAgICAgICAgbGV0IHByZXZTdGF0ZSA9IHVwZGF0ZS5zdGFydFN0YXRlLmZpZWxkKHRoaXMuc3RhdGVGaWVsZCk7XG4gICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcENsYXNzKHVwZGF0ZS5zdGF0ZSk7XG4gICAgICAgIGlmIChjU3RhdGUgIT0gcHJldlN0YXRlKSB7XG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zLCBzZWxlY3RlZCwgZGlzYWJsZWQgfSA9IGNTdGF0ZS5vcGVuO1xuICAgICAgICAgICAgaWYgKCFwcmV2U3RhdGUub3BlbiB8fCBwcmV2U3RhdGUub3Blbi5vcHRpb25zICE9IG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2VBcm91bmRTZWxlY3RlZChvcHRpb25zLmxlbmd0aCwgc2VsZWN0ZWQsIHVwZGF0ZS5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5tYXhSZW5kZXJlZE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvd09wdGlvbnMob3B0aW9ucywgY1N0YXRlLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsKCk7XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQgIT0gKChfYSA9IHByZXZTdGF0ZS5vcGVuKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzYWJsZWQpKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC50b2dnbGUoXCJjbS10b29sdGlwLWF1dG9jb21wbGV0ZS1kaXNhYmxlZFwiLCAhIWRpc2FibGVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVUb29sdGlwQ2xhc3Moc3RhdGUpIHtcbiAgICAgICAgbGV0IGNscyA9IHRoaXMudG9vbHRpcENsYXNzKHN0YXRlKTtcbiAgICAgICAgaWYgKGNscyAhPSB0aGlzLmN1cnJlbnRDbGFzcykge1xuICAgICAgICAgICAgZm9yIChsZXQgYyBvZiB0aGlzLmN1cnJlbnRDbGFzcy5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICAgICAgaWYgKGMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5yZW1vdmUoYyk7XG4gICAgICAgICAgICBmb3IgKGxldCBjIG9mIGNscy5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICAgICAgaWYgKGMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoYyk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDbGFzcyA9IGNscztcbiAgICAgICAgfVxuICAgIH1cbiAgICBwb3NpdGlvbmVkKHNwYWNlKSB7XG4gICAgICAgIHRoaXMuc3BhY2UgPSBzcGFjZTtcbiAgICAgICAgaWYgKHRoaXMuaW5mbylcbiAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLnBsYWNlSW5mb1JlcSk7XG4gICAgfVxuICAgIHVwZGF0ZVNlbCgpIHtcbiAgICAgICAgbGV0IGNTdGF0ZSA9IHRoaXMudmlldy5zdGF0ZS5maWVsZCh0aGlzLnN0YXRlRmllbGQpLCBvcGVuID0gY1N0YXRlLm9wZW47XG4gICAgICAgIGlmIChvcGVuLnNlbGVjdGVkID4gLTEgJiYgb3Blbi5zZWxlY3RlZCA8IHRoaXMucmFuZ2UuZnJvbSB8fCBvcGVuLnNlbGVjdGVkID49IHRoaXMucmFuZ2UudG8pIHtcbiAgICAgICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZUFyb3VuZFNlbGVjdGVkKG9wZW4ub3B0aW9ucy5sZW5ndGgsIG9wZW4uc2VsZWN0ZWQsIHRoaXMudmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5tYXhSZW5kZXJlZE9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5zaG93T3B0aW9ucyhvcGVuLm9wdGlvbnMsIGNTdGF0ZS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU2VsZWN0ZWRPcHRpb24ob3Blbi5zZWxlY3RlZCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveUluZm8oKTtcbiAgICAgICAgICAgIGxldCB7IGNvbXBsZXRpb24gfSA9IG9wZW4ub3B0aW9uc1tvcGVuLnNlbGVjdGVkXTtcbiAgICAgICAgICAgIGxldCB7IGluZm8gfSA9IGNvbXBsZXRpb247XG4gICAgICAgICAgICBpZiAoIWluZm8pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IGluZm9SZXN1bHQgPSB0eXBlb2YgaW5mbyA9PT0gXCJzdHJpbmdcIiA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGluZm8pIDogaW5mbyhjb21wbGV0aW9uKTtcbiAgICAgICAgICAgIGlmICghaW5mb1Jlc3VsdClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoXCJ0aGVuXCIgaW4gaW5mb1Jlc3VsdCkge1xuICAgICAgICAgICAgICAgIGluZm9SZXN1bHQudGhlbihvYmogPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqICYmIHRoaXMudmlldy5zdGF0ZS5maWVsZCh0aGlzLnN0YXRlRmllbGQsIGZhbHNlKSA9PSBjU3RhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEluZm9QYW5lKG9iaiwgY29tcGxldGlvbik7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZSA9PiBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlLCBcImNvbXBsZXRpb24gaW5mb1wiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEluZm9QYW5lKGluZm9SZXN1bHQsIGNvbXBsZXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEluZm9QYW5lKGNvbnRlbnQsIGNvbXBsZXRpb24pIHtcbiAgICAgICAgdGhpcy5kZXN0cm95SW5mbygpO1xuICAgICAgICBsZXQgd3JhcCA9IHRoaXMuaW5mbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHdyYXAuY2xhc3NOYW1lID0gXCJjbS10b29sdGlwIGNtLWNvbXBsZXRpb25JbmZvXCI7XG4gICAgICAgIGlmIChjb250ZW50Lm5vZGVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdyYXAuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICAgICAgICB0aGlzLmluZm9EZXN0cm95ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCB7IGRvbSwgZGVzdHJveSB9ID0gY29udGVudDtcbiAgICAgICAgICAgIHdyYXAuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICAgICAgICAgIHRoaXMuaW5mb0Rlc3Ryb3kgPSBkZXN0cm95IHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQod3JhcCk7XG4gICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLnBsYWNlSW5mb1JlcSk7XG4gICAgfVxuICAgIHVwZGF0ZVNlbGVjdGVkT3B0aW9uKHNlbGVjdGVkKSB7XG4gICAgICAgIGxldCBzZXQgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBvcHQgPSB0aGlzLmxpc3QuZmlyc3RDaGlsZCwgaSA9IHRoaXMucmFuZ2UuZnJvbTsgb3B0OyBvcHQgPSBvcHQubmV4dFNpYmxpbmcsIGkrKykge1xuICAgICAgICAgICAgaWYgKG9wdC5ub2RlTmFtZSAhPSBcIkxJXCIgfHwgIW9wdC5pZCkge1xuICAgICAgICAgICAgICAgIGktLTsgLy8gQSBzZWN0aW9uIGhlYWRlclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaSA9PSBzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIGlmICghb3B0Lmhhc0F0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0LnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgXCJ0cnVlXCIpO1xuICAgICAgICAgICAgICAgICAgICBzZXQgPSBvcHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdC5oYXNBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpKVxuICAgICAgICAgICAgICAgICAgICBvcHQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0KVxuICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXcodGhpcy5saXN0LCBzZXQpO1xuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH1cbiAgICBtZWFzdXJlSW5mbygpIHtcbiAgICAgICAgbGV0IHNlbCA9IHRoaXMuZG9tLnF1ZXJ5U2VsZWN0b3IoXCJbYXJpYS1zZWxlY3RlZF1cIik7XG4gICAgICAgIGlmICghc2VsIHx8ICF0aGlzLmluZm8pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGxpc3RSZWN0ID0gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCBpbmZvUmVjdCA9IHRoaXMuaW5mby5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IHNlbFJlY3QgPSBzZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCBzcGFjZSA9IHRoaXMuc3BhY2U7XG4gICAgICAgIGlmICghc3BhY2UpIHtcbiAgICAgICAgICAgIGxldCB3aW4gPSB0aGlzLmRvbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgICAgICAgICAgIHNwYWNlID0geyBsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiB3aW4uaW5uZXJXaWR0aCwgYm90dG9tOiB3aW4uaW5uZXJIZWlnaHQgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsUmVjdC50b3AgPiBNYXRoLm1pbihzcGFjZS5ib3R0b20sIGxpc3RSZWN0LmJvdHRvbSkgLSAxMCB8fFxuICAgICAgICAgICAgc2VsUmVjdC5ib3R0b20gPCBNYXRoLm1heChzcGFjZS50b3AsIGxpc3RSZWN0LnRvcCkgKyAxMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLnBvc2l0aW9uSW5mbyh0aGlzLnZpZXcsIGxpc3RSZWN0LCBzZWxSZWN0LCBpbmZvUmVjdCwgc3BhY2UsIHRoaXMuZG9tKTtcbiAgICB9XG4gICAgcGxhY2VJbmZvKHBvcykge1xuICAgICAgICBpZiAodGhpcy5pbmZvKSB7XG4gICAgICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvcy5zdHlsZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmZvLnN0eWxlLmNzc1RleHQgPSBwb3Muc3R5bGU7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvLmNsYXNzTmFtZSA9IFwiY20tdG9vbHRpcCBjbS1jb21wbGV0aW9uSW5mbyBcIiArIChwb3MuY2xhc3MgfHwgXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZm8uc3R5bGUuY3NzVGV4dCA9IFwidG9wOiAtMWU2cHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVMaXN0Qm94KG9wdGlvbnMsIGlkLCByYW5nZSkge1xuICAgICAgICBjb25zdCB1bCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ1bFwiKTtcbiAgICAgICAgdWwuaWQgPSBpZDtcbiAgICAgICAgdWwuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImxpc3Rib3hcIik7XG4gICAgICAgIHVsLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgXCJ0cnVlXCIpO1xuICAgICAgICB1bC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHRoaXMudmlldy5zdGF0ZS5waHJhc2UoXCJDb21wbGV0aW9uc1wiKSk7XG4gICAgICAgIGxldCBjdXJTZWN0aW9uID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHJhbmdlLmZyb207IGkgPCByYW5nZS50bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyBjb21wbGV0aW9uLCBtYXRjaCB9ID0gb3B0aW9uc1tpXSwgeyBzZWN0aW9uIH0gPSBjb21wbGV0aW9uO1xuICAgICAgICAgICAgaWYgKHNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IHR5cGVvZiBzZWN0aW9uID09IFwic3RyaW5nXCIgPyBzZWN0aW9uIDogc2VjdGlvbi5uYW1lO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lICE9IGN1clNlY3Rpb24gJiYgKGkgPiByYW5nZS5mcm9tIHx8IHJhbmdlLmZyb20gPT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyU2VjdGlvbiA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VjdGlvbiAhPSBcInN0cmluZ1wiICYmIHNlY3Rpb24uaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bC5hcHBlbmRDaGlsZChzZWN0aW9uLmhlYWRlcihzZWN0aW9uKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaGVhZGVyID0gdWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNvbXBsZXRpb24tc2VjdGlvblwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIudGV4dENvbnRlbnQgPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGkgPSB1bC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIikpO1xuICAgICAgICAgICAgbGkuaWQgPSBpZCArIFwiLVwiICsgaTtcbiAgICAgICAgICAgIGxpLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJvcHRpb25cIik7XG4gICAgICAgICAgICBsZXQgY2xzID0gdGhpcy5vcHRpb25DbGFzcyhjb21wbGV0aW9uKTtcbiAgICAgICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICAgICAgbGkuY2xhc3NOYW1lID0gY2xzO1xuICAgICAgICAgICAgZm9yIChsZXQgc291cmNlIG9mIHRoaXMub3B0aW9uQ29udGVudCkge1xuICAgICAgICAgICAgICAgIGxldCBub2RlID0gc291cmNlKGNvbXBsZXRpb24sIHRoaXMudmlldy5zdGF0ZSwgdGhpcy52aWV3LCBtYXRjaCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGxpLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyYW5nZS5mcm9tKVxuICAgICAgICAgICAgdWwuY2xhc3NMaXN0LmFkZChcImNtLWNvbXBsZXRpb25MaXN0SW5jb21wbGV0ZVRvcFwiKTtcbiAgICAgICAgaWYgKHJhbmdlLnRvIDwgb3B0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICB1bC5jbGFzc0xpc3QuYWRkKFwiY20tY29tcGxldGlvbkxpc3RJbmNvbXBsZXRlQm90dG9tXCIpO1xuICAgICAgICByZXR1cm4gdWw7XG4gICAgfVxuICAgIGRlc3Ryb3lJbmZvKCkge1xuICAgICAgICBpZiAodGhpcy5pbmZvKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmZvRGVzdHJveSlcbiAgICAgICAgICAgICAgICB0aGlzLmluZm9EZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmluZm8ucmVtb3ZlKCk7XG4gICAgICAgICAgICB0aGlzLmluZm8gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveUluZm8oKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wbGV0aW9uVG9vbHRpcChzdGF0ZUZpZWxkLCBhcHBseUNvbXBsZXRpb24pIHtcbiAgICByZXR1cm4gKHZpZXcpID0+IG5ldyBDb21wbGV0aW9uVG9vbHRpcCh2aWV3LCBzdGF0ZUZpZWxkLCBhcHBseUNvbXBsZXRpb24pO1xufVxuZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXcoY29udGFpbmVyLCBlbGVtZW50KSB7XG4gICAgbGV0IHBhcmVudCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgc2VsZiA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHNjYWxlWSA9IHBhcmVudC5oZWlnaHQgLyBjb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuICAgIGlmIChzZWxmLnRvcCA8IHBhcmVudC50b3ApXG4gICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgLT0gKHBhcmVudC50b3AgLSBzZWxmLnRvcCkgLyBzY2FsZVk7XG4gICAgZWxzZSBpZiAoc2VsZi5ib3R0b20gPiBwYXJlbnQuYm90dG9tKVxuICAgICAgICBjb250YWluZXIuc2Nyb2xsVG9wICs9IChzZWxmLmJvdHRvbSAtIHBhcmVudC5ib3R0b20pIC8gc2NhbGVZO1xufVxuXG4vLyBVc2VkIHRvIHBpY2sgYSBwcmVmZXJyZWQgb3B0aW9uIHdoZW4gdHdvIG9wdGlvbnMgd2l0aCB0aGUgc2FtZVxuLy8gbGFiZWwgb2NjdXIgaW4gdGhlIHJlc3VsdC5cbmZ1bmN0aW9uIHNjb3JlKG9wdGlvbikge1xuICAgIHJldHVybiAob3B0aW9uLmJvb3N0IHx8IDApICogMTAwICsgKG9wdGlvbi5hcHBseSA/IDEwIDogMCkgKyAob3B0aW9uLmluZm8gPyA1IDogMCkgK1xuICAgICAgICAob3B0aW9uLnR5cGUgPyAxIDogMCk7XG59XG5mdW5jdGlvbiBzb3J0T3B0aW9ucyhhY3RpdmUsIHN0YXRlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBbXTtcbiAgICBsZXQgc2VjdGlvbnMgPSBudWxsO1xuICAgIGxldCBhZGRPcHRpb24gPSAob3B0aW9uKSA9PiB7XG4gICAgICAgIG9wdGlvbnMucHVzaChvcHRpb24pO1xuICAgICAgICBsZXQgeyBzZWN0aW9uIH0gPSBvcHRpb24uY29tcGxldGlvbjtcbiAgICAgICAgaWYgKHNlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICghc2VjdGlvbnMpXG4gICAgICAgICAgICAgICAgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGxldCBuYW1lID0gdHlwZW9mIHNlY3Rpb24gPT0gXCJzdHJpbmdcIiA/IHNlY3Rpb24gOiBzZWN0aW9uLm5hbWU7XG4gICAgICAgICAgICBpZiAoIXNlY3Rpb25zLnNvbWUocyA9PiBzLm5hbWUgPT0gbmFtZSkpXG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh0eXBlb2Ygc2VjdGlvbiA9PSBcInN0cmluZ1wiID8geyBuYW1lIH0gOiBzZWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZm9yIChsZXQgYSBvZiBhY3RpdmUpXG4gICAgICAgIGlmIChhLmhhc1Jlc3VsdCgpKSB7XG4gICAgICAgICAgICBsZXQgZ2V0TWF0Y2ggPSBhLnJlc3VsdC5nZXRNYXRjaDtcbiAgICAgICAgICAgIGlmIChhLnJlc3VsdC5maWx0ZXIgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgb3B0aW9uIG9mIGEucmVzdWx0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkT3B0aW9uKG5ldyBPcHRpb24ob3B0aW9uLCBhLnNvdXJjZSwgZ2V0TWF0Y2ggPyBnZXRNYXRjaChvcHRpb24pIDogW10sIDFlOSAtIG9wdGlvbnMubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoZXIgPSBuZXcgRnV6enlNYXRjaGVyKHN0YXRlLnNsaWNlRG9jKGEuZnJvbSwgYS50bykpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG9wdGlvbiBvZiBhLnJlc3VsdC5vcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlci5tYXRjaChvcHRpb24ubGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWF0Y2hlZCA9ICFvcHRpb24uZGlzcGxheUxhYmVsID8gbWF0Y2hlci5tYXRjaGVkIDogZ2V0TWF0Y2ggPyBnZXRNYXRjaChvcHRpb24sIG1hdGNoZXIubWF0Y2hlZCkgOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE9wdGlvbihuZXcgT3B0aW9uKG9wdGlvbiwgYS5zb3VyY2UsIG1hdGNoZWQsIG1hdGNoZXIuc2NvcmUgKyAob3B0aW9uLmJvb3N0IHx8IDApKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIGlmIChzZWN0aW9ucykge1xuICAgICAgICBsZXQgc2VjdGlvbk9yZGVyID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgcG9zID0gMDtcbiAgICAgICAgbGV0IGNtcCA9IChhLCBiKSA9PiB7IHZhciBfYSwgX2I7IHJldHVybiAoKF9hID0gYS5yYW5rKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxZTkpIC0gKChfYiA9IGIucmFuaykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMWU5KSB8fCAoYS5uYW1lIDwgYi5uYW1lID8gLTEgOiAxKTsgfTtcbiAgICAgICAgZm9yIChsZXQgcyBvZiBzZWN0aW9ucy5zb3J0KGNtcCkpIHtcbiAgICAgICAgICAgIHBvcyAtPSAxZTU7XG4gICAgICAgICAgICBzZWN0aW9uT3JkZXJbcy5uYW1lXSA9IHBvcztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBvcHRpb24gb2Ygb3B0aW9ucykge1xuICAgICAgICAgICAgbGV0IHsgc2VjdGlvbiB9ID0gb3B0aW9uLmNvbXBsZXRpb247XG4gICAgICAgICAgICBpZiAoc2VjdGlvbilcbiAgICAgICAgICAgICAgICBvcHRpb24uc2NvcmUgKz0gc2VjdGlvbk9yZGVyW3R5cGVvZiBzZWN0aW9uID09IFwic3RyaW5nXCIgPyBzZWN0aW9uIDogc2VjdGlvbi5uYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gW10sIHByZXYgPSBudWxsO1xuICAgIGxldCBjb21wYXJlID0gc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuY29tcGFyZUNvbXBsZXRpb25zO1xuICAgIGZvciAobGV0IG9wdCBvZiBvcHRpb25zLnNvcnQoKGEsIGIpID0+IChiLnNjb3JlIC0gYS5zY29yZSkgfHwgY29tcGFyZShhLmNvbXBsZXRpb24sIGIuY29tcGxldGlvbikpKSB7XG4gICAgICAgIGxldCBjdXIgPSBvcHQuY29tcGxldGlvbjtcbiAgICAgICAgaWYgKCFwcmV2IHx8IHByZXYubGFiZWwgIT0gY3VyLmxhYmVsIHx8IHByZXYuZGV0YWlsICE9IGN1ci5kZXRhaWwgfHxcbiAgICAgICAgICAgIChwcmV2LnR5cGUgIT0gbnVsbCAmJiBjdXIudHlwZSAhPSBudWxsICYmIHByZXYudHlwZSAhPSBjdXIudHlwZSkgfHxcbiAgICAgICAgICAgIHByZXYuYXBwbHkgIT0gY3VyLmFwcGx5IHx8IHByZXYuYm9vc3QgIT0gY3VyLmJvb3N0KVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gob3B0KTtcbiAgICAgICAgZWxzZSBpZiAoc2NvcmUob3B0LmNvbXBsZXRpb24pID4gc2NvcmUocHJldikpXG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gb3B0O1xuICAgICAgICBwcmV2ID0gb3B0LmNvbXBsZXRpb247XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jbGFzcyBDb21wbGV0aW9uRGlhbG9nIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBhdHRycywgdG9vbHRpcCwgdGltZXN0YW1wLCBzZWxlY3RlZCwgZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLnRvb2x0aXAgPSB0b29sdGlwO1xuICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgfVxuICAgIHNldFNlbGVjdGVkKHNlbGVjdGVkLCBpZCkge1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQgPT0gdGhpcy5zZWxlY3RlZCB8fCBzZWxlY3RlZCA+PSB0aGlzLm9wdGlvbnMubGVuZ3RoID8gdGhpc1xuICAgICAgICAgICAgOiBuZXcgQ29tcGxldGlvbkRpYWxvZyh0aGlzLm9wdGlvbnMsIG1ha2VBdHRycyhpZCwgc2VsZWN0ZWQpLCB0aGlzLnRvb2x0aXAsIHRoaXMudGltZXN0YW1wLCBzZWxlY3RlZCwgdGhpcy5kaXNhYmxlZCk7XG4gICAgfVxuICAgIHN0YXRpYyBidWlsZChhY3RpdmUsIHN0YXRlLCBpZCwgcHJldiwgY29uZikge1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHNvcnRPcHRpb25zKGFjdGl2ZSwgc3RhdGUpO1xuICAgICAgICBpZiAoIW9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldiAmJiBhY3RpdmUuc29tZShhID0+IGEuc3RhdGUgPT0gMSAvKiBTdGF0ZS5QZW5kaW5nICovKSA/XG4gICAgICAgICAgICAgICAgbmV3IENvbXBsZXRpb25EaWFsb2cocHJldi5vcHRpb25zLCBwcmV2LmF0dHJzLCBwcmV2LnRvb2x0aXAsIHByZXYudGltZXN0YW1wLCBwcmV2LnNlbGVjdGVkLCB0cnVlKSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNlbGVjdGVkID0gc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuc2VsZWN0T25PcGVuID8gMCA6IC0xO1xuICAgICAgICBpZiAocHJldiAmJiBwcmV2LnNlbGVjdGVkICE9IHNlbGVjdGVkICYmIHByZXYuc2VsZWN0ZWQgIT0gLTEpIHtcbiAgICAgICAgICAgIGxldCBzZWxlY3RlZFZhbHVlID0gcHJldi5vcHRpb25zW3ByZXYuc2VsZWN0ZWRdLmNvbXBsZXRpb247XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNbaV0uY29tcGxldGlvbiA9PSBzZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gaTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxldGlvbkRpYWxvZyhvcHRpb25zLCBtYWtlQXR0cnMoaWQsIHNlbGVjdGVkKSwge1xuICAgICAgICAgICAgcG9zOiBhY3RpdmUucmVkdWNlKChhLCBiKSA9PiBiLmhhc1Jlc3VsdCgpID8gTWF0aC5taW4oYSwgYi5mcm9tKSA6IGEsIDFlOCksXG4gICAgICAgICAgICBjcmVhdGU6IGNyZWF0ZVRvb2x0aXAsXG4gICAgICAgICAgICBhYm92ZTogY29uZi5hYm92ZUN1cnNvcixcbiAgICAgICAgfSwgcHJldiA/IHByZXYudGltZXN0YW1wIDogRGF0ZS5ub3coKSwgc2VsZWN0ZWQsIGZhbHNlKTtcbiAgICB9XG4gICAgbWFwKGNoYW5nZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV0aW9uRGlhbG9nKHRoaXMub3B0aW9ucywgdGhpcy5hdHRycywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnRvb2x0aXApLCB7IHBvczogY2hhbmdlcy5tYXBQb3ModGhpcy50b29sdGlwLnBvcykgfSksIHRoaXMudGltZXN0YW1wLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmRpc2FibGVkKTtcbiAgICB9XG59XG5jbGFzcyBDb21wbGV0aW9uU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKGFjdGl2ZSwgaWQsIG9wZW4pIHtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5vcGVuID0gb3BlbjtcbiAgICB9XG4gICAgc3RhdGljIHN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXRpb25TdGF0ZShub25lLCBcImNtLWFjLVwiICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMmU2KS50b1N0cmluZygzNiksIG51bGwpO1xuICAgIH1cbiAgICB1cGRhdGUodHIpIHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHRyLCBjb25mID0gc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZyk7XG4gICAgICAgIGxldCBzb3VyY2VzID0gY29uZi5vdmVycmlkZSB8fFxuICAgICAgICAgICAgc3RhdGUubGFuZ3VhZ2VEYXRhQXQoXCJhdXRvY29tcGxldGVcIiwgY3VyKHN0YXRlKSkubWFwKGFzU291cmNlKTtcbiAgICAgICAgbGV0IGFjdGl2ZSA9IHNvdXJjZXMubWFwKHNvdXJjZSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmFjdGl2ZS5maW5kKHMgPT4gcy5zb3VyY2UgPT0gc291cmNlKSB8fFxuICAgICAgICAgICAgICAgIG5ldyBBY3RpdmVTb3VyY2Uoc291cmNlLCB0aGlzLmFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSAhPSAwIC8qIFN0YXRlLkluYWN0aXZlICovKSA/IDEgLyogU3RhdGUuUGVuZGluZyAqLyA6IDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnVwZGF0ZSh0ciwgY29uZik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYWN0aXZlLmxlbmd0aCA9PSB0aGlzLmFjdGl2ZS5sZW5ndGggJiYgYWN0aXZlLmV2ZXJ5KChhLCBpKSA9PiBhID09IHRoaXMuYWN0aXZlW2ldKSlcbiAgICAgICAgICAgIGFjdGl2ZSA9IHRoaXMuYWN0aXZlO1xuICAgICAgICBsZXQgb3BlbiA9IHRoaXMub3BlbjtcbiAgICAgICAgaWYgKG9wZW4gJiYgdHIuZG9jQ2hhbmdlZClcbiAgICAgICAgICAgIG9wZW4gPSBvcGVuLm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgaWYgKHRyLnNlbGVjdGlvbiB8fCBhY3RpdmUuc29tZShhID0+IGEuaGFzUmVzdWx0KCkgJiYgdHIuY2hhbmdlcy50b3VjaGVzUmFuZ2UoYS5mcm9tLCBhLnRvKSkgfHxcbiAgICAgICAgICAgICFzYW1lUmVzdWx0cyhhY3RpdmUsIHRoaXMuYWN0aXZlKSlcbiAgICAgICAgICAgIG9wZW4gPSBDb21wbGV0aW9uRGlhbG9nLmJ1aWxkKGFjdGl2ZSwgc3RhdGUsIHRoaXMuaWQsIG9wZW4sIGNvbmYpO1xuICAgICAgICBlbHNlIGlmIChvcGVuICYmIG9wZW4uZGlzYWJsZWQgJiYgIWFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSA9PSAxIC8qIFN0YXRlLlBlbmRpbmcgKi8pKVxuICAgICAgICAgICAgb3BlbiA9IG51bGw7XG4gICAgICAgIGlmICghb3BlbiAmJiBhY3RpdmUuZXZlcnkoYSA9PiBhLnN0YXRlICE9IDEgLyogU3RhdGUuUGVuZGluZyAqLykgJiYgYWN0aXZlLnNvbWUoYSA9PiBhLmhhc1Jlc3VsdCgpKSlcbiAgICAgICAgICAgIGFjdGl2ZSA9IGFjdGl2ZS5tYXAoYSA9PiBhLmhhc1Jlc3VsdCgpID8gbmV3IEFjdGl2ZVNvdXJjZShhLnNvdXJjZSwgMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLykgOiBhKTtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldFNlbGVjdGVkRWZmZWN0KSlcbiAgICAgICAgICAgICAgICBvcGVuID0gb3BlbiAmJiBvcGVuLnNldFNlbGVjdGVkKGVmZmVjdC52YWx1ZSwgdGhpcy5pZCk7XG4gICAgICAgIHJldHVybiBhY3RpdmUgPT0gdGhpcy5hY3RpdmUgJiYgb3BlbiA9PSB0aGlzLm9wZW4gPyB0aGlzIDogbmV3IENvbXBsZXRpb25TdGF0ZShhY3RpdmUsIHRoaXMuaWQsIG9wZW4pO1xuICAgIH1cbiAgICBnZXQgdG9vbHRpcCgpIHsgcmV0dXJuIHRoaXMub3BlbiA/IHRoaXMub3Blbi50b29sdGlwIDogbnVsbDsgfVxuICAgIGdldCBhdHRycygpIHsgcmV0dXJuIHRoaXMub3BlbiA/IHRoaXMub3Blbi5hdHRycyA6IGJhc2VBdHRyczsgfVxufVxuZnVuY3Rpb24gc2FtZVJlc3VsdHMoYSwgYikge1xuICAgIGlmIChhID09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGZvciAobGV0IGlBID0gMCwgaUIgPSAwOzspIHtcbiAgICAgICAgd2hpbGUgKGlBIDwgYS5sZW5ndGggJiYgIWFbaUFdLmhhc1Jlc3VsdClcbiAgICAgICAgICAgIGlBKys7XG4gICAgICAgIHdoaWxlIChpQiA8IGIubGVuZ3RoICYmICFiW2lCXS5oYXNSZXN1bHQpXG4gICAgICAgICAgICBpQisrO1xuICAgICAgICBsZXQgZW5kQSA9IGlBID09IGEubGVuZ3RoLCBlbmRCID0gaUIgPT0gYi5sZW5ndGg7XG4gICAgICAgIGlmIChlbmRBIHx8IGVuZEIpXG4gICAgICAgICAgICByZXR1cm4gZW5kQSA9PSBlbmRCO1xuICAgICAgICBpZiAoYVtpQSsrXS5yZXN1bHQgIT0gYltpQisrXS5yZXN1bHQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuY29uc3QgYmFzZUF0dHJzID0ge1xuICAgIFwiYXJpYS1hdXRvY29tcGxldGVcIjogXCJsaXN0XCJcbn07XG5mdW5jdGlvbiBtYWtlQXR0cnMoaWQsIHNlbGVjdGVkKSB7XG4gICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgXCJhcmlhLWF1dG9jb21wbGV0ZVwiOiBcImxpc3RcIixcbiAgICAgICAgXCJhcmlhLWhhc3BvcHVwXCI6IFwibGlzdGJveFwiLFxuICAgICAgICBcImFyaWEtY29udHJvbHNcIjogaWRcbiAgICB9O1xuICAgIGlmIChzZWxlY3RlZCA+IC0xKVxuICAgICAgICByZXN1bHRbXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIl0gPSBpZCArIFwiLVwiICsgc2VsZWN0ZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IG5vbmUgPSBbXTtcbmZ1bmN0aW9uIGdldFVzZXJFdmVudCh0cikge1xuICAgIHJldHVybiB0ci5pc1VzZXJFdmVudChcImlucHV0LnR5cGVcIikgPyBcImlucHV0XCIgOiB0ci5pc1VzZXJFdmVudChcImRlbGV0ZS5iYWNrd2FyZFwiKSA/IFwiZGVsZXRlXCIgOiBudWxsO1xufVxuY2xhc3MgQWN0aXZlU291cmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHN0YXRlLCBleHBsaWNpdFBvcyA9IC0xKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMuZXhwbGljaXRQb3MgPSBleHBsaWNpdFBvcztcbiAgICB9XG4gICAgaGFzUmVzdWx0KCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICB1cGRhdGUodHIsIGNvbmYpIHtcbiAgICAgICAgbGV0IGV2ZW50ID0gZ2V0VXNlckV2ZW50KHRyKSwgdmFsdWUgPSB0aGlzO1xuICAgICAgICBpZiAoZXZlbnQpXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmhhbmRsZVVzZXJFdmVudCh0ciwgZXZlbnQsIGNvbmYpO1xuICAgICAgICBlbHNlIGlmICh0ci5kb2NDaGFuZ2VkKVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5oYW5kbGVDaGFuZ2UodHIpO1xuICAgICAgICBlbHNlIGlmICh0ci5zZWxlY3Rpb24gJiYgdmFsdWUuc3RhdGUgIT0gMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLylcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IEFjdGl2ZVNvdXJjZSh2YWx1ZS5zb3VyY2UsIDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzdGFydENvbXBsZXRpb25FZmZlY3QpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IEFjdGl2ZVNvdXJjZSh2YWx1ZS5zb3VyY2UsIDEgLyogU3RhdGUuUGVuZGluZyAqLywgZWZmZWN0LnZhbHVlID8gY3VyKHRyLnN0YXRlKSA6IC0xKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyhjbG9zZUNvbXBsZXRpb25FZmZlY3QpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IEFjdGl2ZVNvdXJjZSh2YWx1ZS5zb3VyY2UsIDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pO1xuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKHNldEFjdGl2ZUVmZmVjdCkpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYWN0aXZlIG9mIGVmZmVjdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZS5zb3VyY2UgPT0gdmFsdWUuc291cmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhY3RpdmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBoYW5kbGVVc2VyRXZlbnQodHIsIHR5cGUsIGNvbmYpIHtcbiAgICAgICAgcmV0dXJuIHR5cGUgPT0gXCJkZWxldGVcIiB8fCAhY29uZi5hY3RpdmF0ZU9uVHlwaW5nID8gdGhpcy5tYXAodHIuY2hhbmdlcykgOiBuZXcgQWN0aXZlU291cmNlKHRoaXMuc291cmNlLCAxIC8qIFN0YXRlLlBlbmRpbmcgKi8pO1xuICAgIH1cbiAgICBoYW5kbGVDaGFuZ2UodHIpIHtcbiAgICAgICAgcmV0dXJuIHRyLmNoYW5nZXMudG91Y2hlc1JhbmdlKGN1cih0ci5zdGFydFN0YXRlKSkgPyBuZXcgQWN0aXZlU291cmNlKHRoaXMuc291cmNlLCAwIC8qIFN0YXRlLkluYWN0aXZlICovKSA6IHRoaXMubWFwKHRyLmNoYW5nZXMpO1xuICAgIH1cbiAgICBtYXAoY2hhbmdlcykge1xuICAgICAgICByZXR1cm4gY2hhbmdlcy5lbXB0eSB8fCB0aGlzLmV4cGxpY2l0UG9zIDwgMCA/IHRoaXMgOiBuZXcgQWN0aXZlU291cmNlKHRoaXMuc291cmNlLCB0aGlzLnN0YXRlLCBjaGFuZ2VzLm1hcFBvcyh0aGlzLmV4cGxpY2l0UG9zKSk7XG4gICAgfVxufVxuY2xhc3MgQWN0aXZlUmVzdWx0IGV4dGVuZHMgQWN0aXZlU291cmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIGV4cGxpY2l0UG9zLCByZXN1bHQsIGZyb20sIHRvKSB7XG4gICAgICAgIHN1cGVyKHNvdXJjZSwgMiAvKiBTdGF0ZS5SZXN1bHQgKi8sIGV4cGxpY2l0UG9zKTtcbiAgICAgICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG4gICAgaGFzUmVzdWx0KCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGhhbmRsZVVzZXJFdmVudCh0ciwgdHlwZSwgY29uZikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBmcm9tID0gdHIuY2hhbmdlcy5tYXBQb3ModGhpcy5mcm9tKSwgdG8gPSB0ci5jaGFuZ2VzLm1hcFBvcyh0aGlzLnRvLCAxKTtcbiAgICAgICAgbGV0IHBvcyA9IGN1cih0ci5zdGF0ZSk7XG4gICAgICAgIGlmICgodGhpcy5leHBsaWNpdFBvcyA8IDAgPyBwb3MgPD0gZnJvbSA6IHBvcyA8IHRoaXMuZnJvbSkgfHxcbiAgICAgICAgICAgIHBvcyA+IHRvIHx8XG4gICAgICAgICAgICB0eXBlID09IFwiZGVsZXRlXCIgJiYgY3VyKHRyLnN0YXJ0U3RhdGUpID09IHRoaXMuZnJvbSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlU291cmNlKHRoaXMuc291cmNlLCB0eXBlID09IFwiaW5wdXRcIiAmJiBjb25mLmFjdGl2YXRlT25UeXBpbmcgPyAxIC8qIFN0YXRlLlBlbmRpbmcgKi8gOiAwIC8qIFN0YXRlLkluYWN0aXZlICovKTtcbiAgICAgICAgbGV0IGV4cGxpY2l0UG9zID0gdGhpcy5leHBsaWNpdFBvcyA8IDAgPyAtMSA6IHRyLmNoYW5nZXMubWFwUG9zKHRoaXMuZXhwbGljaXRQb3MpLCB1cGRhdGVkO1xuICAgICAgICBpZiAoY2hlY2tWYWxpZCh0aGlzLnJlc3VsdC52YWxpZEZvciwgdHIuc3RhdGUsIGZyb20sIHRvKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlUmVzdWx0KHRoaXMuc291cmNlLCBleHBsaWNpdFBvcywgdGhpcy5yZXN1bHQsIGZyb20sIHRvKTtcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0LnVwZGF0ZSAmJlxuICAgICAgICAgICAgKHVwZGF0ZWQgPSB0aGlzLnJlc3VsdC51cGRhdGUodGhpcy5yZXN1bHQsIGZyb20sIHRvLCBuZXcgQ29tcGxldGlvbkNvbnRleHQodHIuc3RhdGUsIHBvcywgZXhwbGljaXRQb3MgPj0gMCkpKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlUmVzdWx0KHRoaXMuc291cmNlLCBleHBsaWNpdFBvcywgdXBkYXRlZCwgdXBkYXRlZC5mcm9tLCAoX2EgPSB1cGRhdGVkLnRvKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjdXIodHIuc3RhdGUpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIDEgLyogU3RhdGUuUGVuZGluZyAqLywgZXhwbGljaXRQb3MpO1xuICAgIH1cbiAgICBoYW5kbGVDaGFuZ2UodHIpIHtcbiAgICAgICAgcmV0dXJuIHRyLmNoYW5nZXMudG91Y2hlc1JhbmdlKHRoaXMuZnJvbSwgdGhpcy50bykgPyBuZXcgQWN0aXZlU291cmNlKHRoaXMuc291cmNlLCAwIC8qIFN0YXRlLkluYWN0aXZlICovKSA6IHRoaXMubWFwKHRyLmNoYW5nZXMpO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICByZXR1cm4gbWFwcGluZy5lbXB0eSA/IHRoaXMgOlxuICAgICAgICAgICAgbmV3IEFjdGl2ZVJlc3VsdCh0aGlzLnNvdXJjZSwgdGhpcy5leHBsaWNpdFBvcyA8IDAgPyAtMSA6IG1hcHBpbmcubWFwUG9zKHRoaXMuZXhwbGljaXRQb3MpLCB0aGlzLnJlc3VsdCwgbWFwcGluZy5tYXBQb3ModGhpcy5mcm9tKSwgbWFwcGluZy5tYXBQb3ModGhpcy50bywgMSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrVmFsaWQodmFsaWRGb3IsIHN0YXRlLCBmcm9tLCB0bykge1xuICAgIGlmICghdmFsaWRGb3IpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgdGV4dCA9IHN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKTtcbiAgICByZXR1cm4gdHlwZW9mIHZhbGlkRm9yID09IFwiZnVuY3Rpb25cIiA/IHZhbGlkRm9yKHRleHQsIGZyb20sIHRvLCBzdGF0ZSkgOiBlbnN1cmVBbmNob3IodmFsaWRGb3IsIHRydWUpLnRlc3QodGV4dCk7XG59XG5jb25zdCBzZXRBY3RpdmVFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHtcbiAgICBtYXAoc291cmNlcywgbWFwcGluZykgeyByZXR1cm4gc291cmNlcy5tYXAocyA9PiBzLm1hcChtYXBwaW5nKSk7IH1cbn0pO1xuY29uc3Qgc2V0U2VsZWN0ZWRFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBjb21wbGV0aW9uU3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIENvbXBsZXRpb25TdGF0ZS5zdGFydCgpOyB9LFxuICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHsgcmV0dXJuIHZhbHVlLnVwZGF0ZSh0cik7IH0sXG4gICAgcHJvdmlkZTogZiA9PiBbXG4gICAgICAgIHNob3dUb29sdGlwLmZyb20oZiwgdmFsID0+IHZhbC50b29sdGlwKSxcbiAgICAgICAgRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcy5mcm9tKGYsIHN0YXRlID0+IHN0YXRlLmF0dHJzKVxuICAgIF1cbn0pO1xuZnVuY3Rpb24gYXBwbHlDb21wbGV0aW9uKHZpZXcsIG9wdGlvbikge1xuICAgIGNvbnN0IGFwcGx5ID0gb3B0aW9uLmNvbXBsZXRpb24uYXBwbHkgfHwgb3B0aW9uLmNvbXBsZXRpb24ubGFiZWw7XG4gICAgbGV0IHJlc3VsdCA9IHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlKS5hY3RpdmUuZmluZChhID0+IGEuc291cmNlID09IG9wdGlvbi5zb3VyY2UpO1xuICAgIGlmICghKHJlc3VsdCBpbnN0YW5jZW9mIEFjdGl2ZVJlc3VsdCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIGFwcGx5ID09IFwic3RyaW5nXCIpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbnNlcnRDb21wbGV0aW9uVGV4dCh2aWV3LnN0YXRlLCBhcHBseSwgcmVzdWx0LmZyb20sIHJlc3VsdC50bykpLCB7IGFubm90YXRpb25zOiBwaWNrZWRDb21wbGV0aW9uLm9mKG9wdGlvbi5jb21wbGV0aW9uKSB9KSk7XG4gICAgZWxzZVxuICAgICAgICBhcHBseSh2aWV3LCBvcHRpb24uY29tcGxldGlvbiwgcmVzdWx0LmZyb20sIHJlc3VsdC50byk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBjcmVhdGVUb29sdGlwID0gLypAX19QVVJFX18qL2NvbXBsZXRpb25Ub29sdGlwKGNvbXBsZXRpb25TdGF0ZSwgYXBwbHlDb21wbGV0aW9uKTtcblxuLyoqXG5SZXR1cm5zIGEgY29tbWFuZCB0aGF0IG1vdmVzIHRoZSBjb21wbGV0aW9uIHNlbGVjdGlvbiBmb3J3YXJkIG9yXG5iYWNrd2FyZCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuKi9cbmZ1bmN0aW9uIG1vdmVDb21wbGV0aW9uU2VsZWN0aW9uKGZvcndhcmQsIGJ5ID0gXCJvcHRpb25cIikge1xuICAgIHJldHVybiAodmlldykgPT4ge1xuICAgICAgICBsZXQgY1N0YXRlID0gdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICAgICAgaWYgKCFjU3RhdGUgfHwgIWNTdGF0ZS5vcGVuIHx8IGNTdGF0ZS5vcGVuLmRpc2FibGVkIHx8XG4gICAgICAgICAgICBEYXRlLm5vdygpIC0gY1N0YXRlLm9wZW4udGltZXN0YW1wIDwgdmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5pbnRlcmFjdGlvbkRlbGF5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc3RlcCA9IDEsIHRvb2x0aXA7XG4gICAgICAgIGlmIChieSA9PSBcInBhZ2VcIiAmJiAodG9vbHRpcCA9IGdldFRvb2x0aXAodmlldywgY1N0YXRlLm9wZW4udG9vbHRpcCkpKVxuICAgICAgICAgICAgc3RlcCA9IE1hdGgubWF4KDIsIE1hdGguZmxvb3IodG9vbHRpcC5kb20ub2Zmc2V0SGVpZ2h0IC9cbiAgICAgICAgICAgICAgICB0b29sdGlwLmRvbS5xdWVyeVNlbGVjdG9yKFwibGlcIikub2Zmc2V0SGVpZ2h0KSAtIDEpO1xuICAgICAgICBsZXQgeyBsZW5ndGggfSA9IGNTdGF0ZS5vcGVuLm9wdGlvbnM7XG4gICAgICAgIGxldCBzZWxlY3RlZCA9IGNTdGF0ZS5vcGVuLnNlbGVjdGVkID4gLTEgPyBjU3RhdGUub3Blbi5zZWxlY3RlZCArIHN0ZXAgKiAoZm9yd2FyZCA/IDEgOiAtMSkgOiBmb3J3YXJkID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChzZWxlY3RlZCA8IDApXG4gICAgICAgICAgICBzZWxlY3RlZCA9IGJ5ID09IFwicGFnZVwiID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICAgIGVsc2UgaWYgKHNlbGVjdGVkID49IGxlbmd0aClcbiAgICAgICAgICAgIHNlbGVjdGVkID0gYnkgPT0gXCJwYWdlXCIgPyBsZW5ndGggLSAxIDogMDtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldFNlbGVjdGVkRWZmZWN0Lm9mKHNlbGVjdGVkKSB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuQWNjZXB0IHRoZSBjdXJyZW50IGNvbXBsZXRpb24uXG4qL1xuY29uc3QgYWNjZXB0Q29tcGxldGlvbiA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKHZpZXcuc3RhdGUucmVhZE9ubHkgfHwgIWNTdGF0ZSB8fCAhY1N0YXRlLm9wZW4gfHwgY1N0YXRlLm9wZW4uc2VsZWN0ZWQgPCAwIHx8IGNTdGF0ZS5vcGVuLmRpc2FibGVkIHx8XG4gICAgICAgIERhdGUubm93KCkgLSBjU3RhdGUub3Blbi50aW1lc3RhbXAgPCB2aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLmludGVyYWN0aW9uRGVsYXkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gYXBwbHlDb21wbGV0aW9uKHZpZXcsIGNTdGF0ZS5vcGVuLm9wdGlvbnNbY1N0YXRlLm9wZW4uc2VsZWN0ZWRdKTtcbn07XG4vKipcbkV4cGxpY2l0bHkgc3RhcnQgYXV0b2NvbXBsZXRpb24uXG4qL1xuY29uc3Qgc3RhcnRDb21wbGV0aW9uID0gKHZpZXcpID0+IHtcbiAgICBsZXQgY1N0YXRlID0gdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWNTdGF0ZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzdGFydENvbXBsZXRpb25FZmZlY3Qub2YodHJ1ZSkgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5DbG9zZSB0aGUgY3VycmVudGx5IGFjdGl2ZSBjb21wbGV0aW9uLlxuKi9cbmNvbnN0IGNsb3NlQ29tcGxldGlvbiA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFjU3RhdGUgfHwgIWNTdGF0ZS5hY3RpdmUuc29tZShhID0+IGEuc3RhdGUgIT0gMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLykpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogY2xvc2VDb21wbGV0aW9uRWZmZWN0Lm9mKG51bGwpIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmNsYXNzIFJ1bm5pbmdRdWVyeSB7XG4gICAgY29uc3RydWN0b3IoYWN0aXZlLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnVwZGF0ZXMgPSBbXTtcbiAgICAgICAgLy8gTm90ZSB0aGF0ICd1bmRlZmluZWQnIG1lYW5zICdub3QgZG9uZSB5ZXQnLCB3aGVyZWFzICdudWxsJyBtZWFuc1xuICAgICAgICAvLyAncXVlcnkgcmV0dXJuZWQgbnVsbCcuXG4gICAgICAgIHRoaXMuZG9uZSA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG5jb25zdCBNYXhVcGRhdGVDb3VudCA9IDUwLCBNaW5BYm9ydFRpbWUgPSAxMDAwO1xuY29uc3QgY29tcGxldGlvblBsdWdpbiA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmRlYm91bmNlVXBkYXRlID0gLTE7XG4gICAgICAgIHRoaXMucnVubmluZyA9IFtdO1xuICAgICAgICB0aGlzLmRlYm91bmNlQWNjZXB0ID0gLTE7XG4gICAgICAgIHRoaXMucGVuZGluZ1N0YXJ0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29tcG9zaW5nID0gMCAvKiBDb21wb3NpdGlvblN0YXRlLk5vbmUgKi87XG4gICAgICAgIGZvciAobGV0IGFjdGl2ZSBvZiB2aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSkuYWN0aXZlKVxuICAgICAgICAgICAgaWYgKGFjdGl2ZS5zdGF0ZSA9PSAxIC8qIFN0YXRlLlBlbmRpbmcgKi8pXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFF1ZXJ5KGFjdGl2ZSk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IGNTdGF0ZSA9IHVwZGF0ZS5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUpO1xuICAgICAgICBpZiAoIXVwZGF0ZS5zZWxlY3Rpb25TZXQgJiYgIXVwZGF0ZS5kb2NDaGFuZ2VkICYmIHVwZGF0ZS5zdGFydFN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSkgPT0gY1N0YXRlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZG9lc1Jlc2V0ID0gdXBkYXRlLnRyYW5zYWN0aW9ucy5zb21lKHRyID0+IHtcbiAgICAgICAgICAgIHJldHVybiAodHIuc2VsZWN0aW9uIHx8IHRyLmRvY0NoYW5nZWQpICYmICFnZXRVc2VyRXZlbnQodHIpO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJ1bm5pbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IHRoaXMucnVubmluZ1tpXTtcbiAgICAgICAgICAgIGlmIChkb2VzUmVzZXQgfHxcbiAgICAgICAgICAgICAgICBxdWVyeS51cGRhdGVzLmxlbmd0aCArIHVwZGF0ZS50cmFuc2FjdGlvbnMubGVuZ3RoID4gTWF4VXBkYXRlQ291bnQgJiYgRGF0ZS5ub3coKSAtIHF1ZXJ5LnRpbWUgPiBNaW5BYm9ydFRpbWUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBoYW5kbGVyIG9mIHF1ZXJ5LmNvbnRleHQuYWJvcnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHRoaXMudmlldy5zdGF0ZSwgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcXVlcnkuY29udGV4dC5hYm9ydExpc3RlbmVycyA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5uaW5nLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVlcnkudXBkYXRlcy5wdXNoKC4uLnVwZGF0ZS50cmFuc2FjdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRlYm91bmNlVXBkYXRlID4gLTEpXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWJvdW5jZVVwZGF0ZSk7XG4gICAgICAgIGlmICh1cGRhdGUudHJhbnNhY3Rpb25zLnNvbWUodHIgPT4gdHIuZWZmZWN0cy5zb21lKGUgPT4gZS5pcyhzdGFydENvbXBsZXRpb25FZmZlY3QpKSkpXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdTdGFydCA9IHRydWU7XG4gICAgICAgIGxldCBkZWxheSA9IHRoaXMucGVuZGluZ1N0YXJ0ID8gNTAgOiB1cGRhdGUuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuYWN0aXZhdGVPblR5cGluZ0RlbGF5O1xuICAgICAgICB0aGlzLmRlYm91bmNlVXBkYXRlID0gY1N0YXRlLmFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSA9PSAxIC8qIFN0YXRlLlBlbmRpbmcgKi8gJiYgIXRoaXMucnVubmluZy5zb21lKHEgPT4gcS5hY3RpdmUuc291cmNlID09IGEuc291cmNlKSlcbiAgICAgICAgICAgID8gc2V0VGltZW91dCgoKSA9PiB0aGlzLnN0YXJ0VXBkYXRlKCksIGRlbGF5KSA6IC0xO1xuICAgICAgICBpZiAodGhpcy5jb21wb3NpbmcgIT0gMCAvKiBDb21wb3NpdGlvblN0YXRlLk5vbmUgKi8pXG4gICAgICAgICAgICBmb3IgKGxldCB0ciBvZiB1cGRhdGUudHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdldFVzZXJFdmVudCh0cikgPT0gXCJpbnB1dFwiKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvc2luZyA9IDIgLyogQ29tcG9zaXRpb25TdGF0ZS5DaGFuZ2VkICovO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY29tcG9zaW5nID09IDIgLyogQ29tcG9zaXRpb25TdGF0ZS5DaGFuZ2VkICovICYmIHRyLnNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb3NpbmcgPSAzIC8qIENvbXBvc2l0aW9uU3RhdGUuQ2hhbmdlZEFuZE1vdmVkICovO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydFVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5kZWJvdW5jZVVwZGF0ZSA9IC0xO1xuICAgICAgICB0aGlzLnBlbmRpbmdTdGFydCA9IGZhbHNlO1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdGhpcy52aWV3LCBjU3RhdGUgPSBzdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUpO1xuICAgICAgICBmb3IgKGxldCBhY3RpdmUgb2YgY1N0YXRlLmFjdGl2ZSkge1xuICAgICAgICAgICAgaWYgKGFjdGl2ZS5zdGF0ZSA9PSAxIC8qIFN0YXRlLlBlbmRpbmcgKi8gJiYgIXRoaXMucnVubmluZy5zb21lKHIgPT4gci5hY3RpdmUuc291cmNlID09IGFjdGl2ZS5zb3VyY2UpKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRRdWVyeShhY3RpdmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0UXVlcnkoYWN0aXZlKSB7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0aGlzLnZpZXcsIHBvcyA9IGN1cihzdGF0ZSk7XG4gICAgICAgIGxldCBjb250ZXh0ID0gbmV3IENvbXBsZXRpb25Db250ZXh0KHN0YXRlLCBwb3MsIGFjdGl2ZS5leHBsaWNpdFBvcyA9PSBwb3MpO1xuICAgICAgICBsZXQgcGVuZGluZyA9IG5ldyBSdW5uaW5nUXVlcnkoYWN0aXZlLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy5ydW5uaW5nLnB1c2gocGVuZGluZyk7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZShhY3RpdmUuc291cmNlKGNvbnRleHQpKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICBpZiAoIXBlbmRpbmcuY29udGV4dC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgcGVuZGluZy5kb25lID0gcmVzdWx0IHx8IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZUFjY2VwdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogY2xvc2VDb21wbGV0aW9uRWZmZWN0Lm9mKG51bGwpIH0pO1xuICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHRoaXMudmlldy5zdGF0ZSwgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNjaGVkdWxlQWNjZXB0KCkge1xuICAgICAgICBpZiAodGhpcy5ydW5uaW5nLmV2ZXJ5KHEgPT4gcS5kb25lICE9PSB1bmRlZmluZWQpKVxuICAgICAgICAgICAgdGhpcy5hY2NlcHQoKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5kZWJvdW5jZUFjY2VwdCA8IDApXG4gICAgICAgICAgICB0aGlzLmRlYm91bmNlQWNjZXB0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmFjY2VwdCgpLCB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykudXBkYXRlU3luY1RpbWUpO1xuICAgIH1cbiAgICAvLyBGb3IgZWFjaCBmaW5pc2hlZCBxdWVyeSBpbiB0aGlzLnJ1bm5pbmcsIHRyeSB0byBjcmVhdGUgYSByZXN1bHRcbiAgICAvLyBvciwgaWYgYXBwcm9wcmlhdGUsIHJlc3RhcnQgdGhlIHF1ZXJ5LlxuICAgIGFjY2VwdCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5kZWJvdW5jZUFjY2VwdCA+IC0xKVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVib3VuY2VBY2NlcHQpO1xuICAgICAgICB0aGlzLmRlYm91bmNlQWNjZXB0ID0gLTE7XG4gICAgICAgIGxldCB1cGRhdGVkID0gW107XG4gICAgICAgIGxldCBjb25mID0gdGhpcy52aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucnVubmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5ydW5uaW5nW2ldO1xuICAgICAgICAgICAgaWYgKHF1ZXJ5LmRvbmUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHRoaXMucnVubmluZy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgIGlmIChxdWVyeS5kb25lKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFjdGl2ZSA9IG5ldyBBY3RpdmVSZXN1bHQocXVlcnkuYWN0aXZlLnNvdXJjZSwgcXVlcnkuYWN0aXZlLmV4cGxpY2l0UG9zLCBxdWVyeS5kb25lLCBxdWVyeS5kb25lLmZyb20sIChfYSA9IHF1ZXJ5LmRvbmUudG8pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGN1cihxdWVyeS51cGRhdGVzLmxlbmd0aCA/IHF1ZXJ5LnVwZGF0ZXNbMF0uc3RhcnRTdGF0ZSA6IHRoaXMudmlldy5zdGF0ZSkpO1xuICAgICAgICAgICAgICAgIC8vIFJlcGxheSB0aGUgdHJhbnNhY3Rpb25zIHRoYXQgaGFwcGVuZWQgc2luY2UgdGhlIHN0YXJ0IG9mXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJlcXVlc3QgYW5kIHNlZSBpZiB0aGF0IHByZXNlcnZlcyB0aGUgcmVzdWx0XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdHIgb2YgcXVlcnkudXBkYXRlcylcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlID0gYWN0aXZlLnVwZGF0ZSh0ciwgY29uZik7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZS5oYXNSZXN1bHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLnB1c2goYWN0aXZlKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlKS5hY3RpdmUuZmluZChhID0+IGEuc291cmNlID09IHF1ZXJ5LmFjdGl2ZS5zb3VyY2UpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudC5zdGF0ZSA9PSAxIC8qIFN0YXRlLlBlbmRpbmcgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAocXVlcnkuZG9uZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgZmFpbGVkLiBTaG91bGQgY2xlYXIgdGhlIHBlbmRpbmcgc3RhdHVzIGlmIGl0XG4gICAgICAgICAgICAgICAgICAgIC8vIGhhc24ndCBiZWVuIHJlLXNldCBpbiB0aGUgbWVhbnRpbWUuXG4gICAgICAgICAgICAgICAgICAgIGxldCBhY3RpdmUgPSBuZXcgQWN0aXZlU291cmNlKHF1ZXJ5LmFjdGl2ZS5zb3VyY2UsIDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0ciBvZiBxdWVyeS51cGRhdGVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlID0gYWN0aXZlLnVwZGF0ZSh0ciwgY29uZik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmUuc3RhdGUgIT0gMSAvKiBTdGF0ZS5QZW5kaW5nICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC5wdXNoKGFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDbGVhcmVkIGJ5IHN1YnNlcXVlbnQgdHJhbnNhY3Rpb25zLiBSZXN0YXJ0LlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UXVlcnkoY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVkLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldEFjdGl2ZUVmZmVjdC5vZih1cGRhdGVkKSB9KTtcbiAgICB9XG59LCB7XG4gICAgZXZlbnRIYW5kbGVyczoge1xuICAgICAgICBibHVyKGV2ZW50KSB7XG4gICAgICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoc3RhdGUgJiYgc3RhdGUudG9vbHRpcCAmJiB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuY2xvc2VPbkJsdXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlhbG9nID0gc3RhdGUub3BlbiAmJiBnZXRUb29sdGlwKHRoaXMudmlldywgc3RhdGUub3Blbi50b29sdGlwKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRpYWxvZyB8fCAhZGlhbG9nLmRvbS5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSlcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBjbG9zZUNvbXBsZXRpb25FZmZlY3Qub2YobnVsbCkgfSksIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29tcG9zaXRpb25zdGFydCgpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nID0gMSAvKiBDb21wb3NpdGlvblN0YXRlLlN0YXJ0ZWQgKi87XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBvc2l0aW9uZW5kKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9zaW5nID09IDMgLyogQ29tcG9zaXRpb25TdGF0ZS5DaGFuZ2VkQW5kTW92ZWQgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgZmlyZXMgY29tcG9zaXRpb25lbmQgZXZlbnRzIHN5bmNocm9ub3VzbHksIHBvc3NpYmx5XG4gICAgICAgICAgICAgICAgLy8gZnJvbSBpbnNpZGUgYW4gdXBkYXRlLCBzbyBkaXNwYXRjaCBhc3luY2hyb25vdXNseSB0byBhdm9pZCByZWVudHJhbmN5XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzdGFydENvbXBsZXRpb25FZmZlY3Qub2YoZmFsc2UpIH0pLCAyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbXBvc2luZyA9IDAgLyogQ29tcG9zaXRpb25TdGF0ZS5Ob25lICovO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmNvbnN0IGJhc2VUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tdG9vbHRpcC5jbS10b29sdGlwLWF1dG9jb21wbGV0ZVwiOiB7XG4gICAgICAgIFwiJiA+IHVsXCI6IHtcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IFwibW9ub3NwYWNlXCIsXG4gICAgICAgICAgICB3aGl0ZVNwYWNlOiBcIm5vd3JhcFwiLFxuICAgICAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuIGF1dG9cIixcbiAgICAgICAgICAgIG1heFdpZHRoX2ZhbGxiYWNrOiBcIjcwMHB4XCIsXG4gICAgICAgICAgICBtYXhXaWR0aDogXCJtaW4oNzAwcHgsIDk1dncpXCIsXG4gICAgICAgICAgICBtaW5XaWR0aDogXCIyNTBweFwiLFxuICAgICAgICAgICAgbWF4SGVpZ2h0OiBcIjEwZW1cIixcbiAgICAgICAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgICAgICBsaXN0U3R5bGU6IFwibm9uZVwiLFxuICAgICAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgIFwiJiA+IGxpLCAmID4gY29tcGxldGlvbi1zZWN0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiBcIjFweCAzcHhcIixcbiAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiAxLjJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIiYgPiBsaVwiOiB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dYOiBcImhpZGRlblwiLFxuICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdzogXCJlbGxpcHNpc1wiLFxuICAgICAgICAgICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIiYgPiBjb21wbGV0aW9uLXNlY3Rpb25cIjoge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwibGlzdC1pdGVtXCIsXG4gICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tOiBcIjFweCBzb2xpZCBzaWx2ZXJcIixcbiAgICAgICAgICAgICAgICBwYWRkaW5nTGVmdDogXCIwLjVlbVwiLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuN1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tdG9vbHRpcC1hdXRvY29tcGxldGUgdWwgbGlbYXJpYS1zZWxlY3RlZF1cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMxN2NcIixcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS10b29sdGlwLWF1dG9jb21wbGV0ZS1kaXNhYmxlZCB1bCBsaVthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzc3N1wiLFxuICAgIH0sXG4gICAgXCImZGFyayAuY20tdG9vbHRpcC1hdXRvY29tcGxldGUgdWwgbGlbYXJpYS1zZWxlY3RlZF1cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMzNDdcIixcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlLWRpc2FibGVkIHVsIGxpW2FyaWEtc2VsZWN0ZWRdXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjNDQ0XCIsXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uTGlzdEluY29tcGxldGVUb3A6YmVmb3JlLCAuY20tY29tcGxldGlvbkxpc3RJbmNvbXBsZXRlQm90dG9tOmFmdGVyXCI6IHtcbiAgICAgICAgY29udGVudDogJ1wiwrfCt8K3XCInLFxuICAgICAgICBvcGFjaXR5OiAwLjUsXG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiXG4gICAgfSxcbiAgICBcIi5jbS10b29sdGlwLmNtLWNvbXBsZXRpb25JbmZvXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgcGFkZGluZzogXCIzcHggOXB4XCIsXG4gICAgICAgIHdpZHRoOiBcIm1heC1jb250ZW50XCIsXG4gICAgICAgIG1heFdpZHRoOiBgJHs0MDAgLyogSW5mby5XaWR0aCAqL31weGAsXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCJcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JbmZvLmNtLWNvbXBsZXRpb25JbmZvLWxlZnRcIjogeyByaWdodDogXCIxMDAlXCIgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSW5mby5jbS1jb21wbGV0aW9uSW5mby1yaWdodFwiOiB7IGxlZnQ6IFwiMTAwJVwiIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkluZm8uY20tY29tcGxldGlvbkluZm8tbGVmdC1uYXJyb3dcIjogeyByaWdodDogYCR7MzAgLyogSW5mby5NYXJnaW4gKi99cHhgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkluZm8uY20tY29tcGxldGlvbkluZm8tcmlnaHQtbmFycm93XCI6IHsgbGVmdDogYCR7MzAgLyogSW5mby5NYXJnaW4gKi99cHhgIH0sXG4gICAgXCImbGlnaHQgLmNtLXNuaXBwZXRGaWVsZFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjMDAwMDAwMjJcIiB9LFxuICAgIFwiJmRhcmsgLmNtLXNuaXBwZXRGaWVsZFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmZmZmZmMjJcIiB9LFxuICAgIFwiLmNtLXNuaXBwZXRGaWVsZFBvc2l0aW9uXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJ0ZXh0LXRvcFwiLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiBcIjEuMTVlbVwiLFxuICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLFxuICAgICAgICBtYXJnaW46IFwiMCAtMC43cHggLS43ZW1cIixcbiAgICAgICAgYm9yZGVyTGVmdDogXCIxLjRweCBkb3R0ZWQgIzg4OFwiXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uTWF0Y2hlZFRleHRcIjoge1xuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIlxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkRldGFpbFwiOiB7XG4gICAgICAgIG1hcmdpbkxlZnQ6IFwiMC41ZW1cIixcbiAgICAgICAgZm9udFN0eWxlOiBcIml0YWxpY1wiXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvblwiOiB7XG4gICAgICAgIGZvbnRTaXplOiBcIjkwJVwiLFxuICAgICAgICB3aWR0aDogXCIuOGVtXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgICAgICAgcGFkZGluZ1JpZ2h0OiBcIi42ZW1cIixcbiAgICAgICAgb3BhY2l0eTogXCIwLjZcIixcbiAgICAgICAgYm94U2l6aW5nOiBcImNvbnRlbnQtYm94XCJcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWZ1bmN0aW9uLCAuY20tY29tcGxldGlvbkljb24tbWV0aG9kXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCInxpInXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tY2xhc3NcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifil4snXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24taW50ZXJmYWNlXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn4peMJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLXZhcmlhYmxlXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn8J2RpSdcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1jb25zdGFudFwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ/CdkLYnXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tdHlwZVwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ/CdkaEnXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tZW51bVwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ+KIqidcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1wcm9wZXJ0eVwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ+KWoSdcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1rZXl3b3JkXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn8J+UkVxcdUZFMEUnXCIgfSAvLyBEaXNhYmxlIGVtb2ppIHJlbmRlcmluZ1xuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tbmFtZXNwYWNlXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn4paiJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLXRleHRcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIidhYmMnXCIsIGZvbnRTaXplOiBcIjUwJVwiLCB2ZXJ0aWNhbEFsaWduOiBcIm1pZGRsZVwiIH1cbiAgICB9XG59KTtcblxuY2xhc3MgRmllbGRQb3Mge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBsaW5lLCBmcm9tLCB0bykge1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG59XG5jbGFzcyBGaWVsZFJhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIGxldCBmcm9tID0gY2hhbmdlcy5tYXBQb3ModGhpcy5mcm9tLCAtMSwgTWFwTW9kZS5UcmFja0RlbCk7XG4gICAgICAgIGxldCB0byA9IGNoYW5nZXMubWFwUG9zKHRoaXMudG8sIDEsIE1hcE1vZGUuVHJhY2tEZWwpO1xuICAgICAgICByZXR1cm4gZnJvbSA9PSBudWxsIHx8IHRvID09IG51bGwgPyBudWxsIDogbmV3IEZpZWxkUmFuZ2UodGhpcy5maWVsZCwgZnJvbSwgdG8pO1xuICAgIH1cbn1cbmNsYXNzIFNuaXBwZXQge1xuICAgIGNvbnN0cnVjdG9yKGxpbmVzLCBmaWVsZFBvc2l0aW9ucykge1xuICAgICAgICB0aGlzLmxpbmVzID0gbGluZXM7XG4gICAgICAgIHRoaXMuZmllbGRQb3NpdGlvbnMgPSBmaWVsZFBvc2l0aW9ucztcbiAgICB9XG4gICAgaW5zdGFudGlhdGUoc3RhdGUsIHBvcykge1xuICAgICAgICBsZXQgdGV4dCA9IFtdLCBsaW5lU3RhcnQgPSBbcG9zXTtcbiAgICAgICAgbGV0IGxpbmVPYmogPSBzdGF0ZS5kb2MubGluZUF0KHBvcyksIGJhc2VJbmRlbnQgPSAvXlxccyovLmV4ZWMobGluZU9iai50ZXh0KVswXTtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0aGlzLmxpbmVzKSB7XG4gICAgICAgICAgICBpZiAodGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZW50ID0gYmFzZUluZGVudCwgdGFicyA9IC9eXFx0Ki8uZXhlYyhsaW5lKVswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWJzOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGluZGVudCArPSBzdGF0ZS5mYWNldChpbmRlbnRVbml0KTtcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQucHVzaChwb3MgKyBpbmRlbnQubGVuZ3RoIC0gdGFicyk7XG4gICAgICAgICAgICAgICAgbGluZSA9IGluZGVudCArIGxpbmUuc2xpY2UodGFicyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0LnB1c2gobGluZSk7XG4gICAgICAgICAgICBwb3MgKz0gbGluZS5sZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGxldCByYW5nZXMgPSB0aGlzLmZpZWxkUG9zaXRpb25zLm1hcChwb3MgPT4gbmV3IEZpZWxkUmFuZ2UocG9zLmZpZWxkLCBsaW5lU3RhcnRbcG9zLmxpbmVdICsgcG9zLmZyb20sIGxpbmVTdGFydFtwb3MubGluZV0gKyBwb3MudG8pKTtcbiAgICAgICAgcmV0dXJuIHsgdGV4dCwgcmFuZ2VzIH07XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZSh0ZW1wbGF0ZSkge1xuICAgICAgICBsZXQgZmllbGRzID0gW107XG4gICAgICAgIGxldCBsaW5lcyA9IFtdLCBwb3NpdGlvbnMgPSBbXSwgbTtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0ZW1wbGF0ZS5zcGxpdCgvXFxyXFxuP3xcXG4vKSkge1xuICAgICAgICAgICAgd2hpbGUgKG0gPSAvWyMkXVxceyg/OihcXGQrKSg/OjooW159XSopKT98KFtefV0qKSlcXH0vLmV4ZWMobGluZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2VxID0gbVsxXSA/ICttWzFdIDogbnVsbCwgbmFtZSA9IG1bMl0gfHwgbVszXSB8fCBcIlwiLCBmb3VuZCA9IC0xO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXEgIT0gbnVsbCA/IGZpZWxkc1tpXS5zZXEgPT0gc2VxIDogbmFtZSA/IGZpZWxkc1tpXS5uYW1lID09IG5hbWUgOiBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgZmllbGRzLmxlbmd0aCAmJiAoc2VxID09IG51bGwgfHwgKGZpZWxkc1tpXS5zZXEgIT0gbnVsbCAmJiBmaWVsZHNbaV0uc2VxIDwgc2VxKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkcy5zcGxpY2UoaSwgMCwgeyBzZXEsIG5hbWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcG9zIG9mIHBvc2l0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3MuZmllbGQgPj0gZm91bmQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zLmZpZWxkKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKG5ldyBGaWVsZFBvcyhmb3VuZCwgbGluZXMubGVuZ3RoLCBtLmluZGV4LCBtLmluZGV4ICsgbmFtZS5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZSgwLCBtLmluZGV4KSArIG5hbWUgKyBsaW5lLnNsaWNlKG0uaW5kZXggKyBtWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBlc2M7IGVzYyA9IC9cXFxcKFt7fV0pLy5leGVjKGxpbmUpOykge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIGVzYy5pbmRleCkgKyBlc2NbMV0gKyBsaW5lLnNsaWNlKGVzYy5pbmRleCArIGVzY1swXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyBvZiBwb3NpdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MubGluZSA9PSBsaW5lcy5sZW5ndGggJiYgcG9zLmZyb20gPiBlc2MuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcy5mcm9tLS07XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MudG8tLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNuaXBwZXQobGluZXMsIHBvc2l0aW9ucyk7XG4gICAgfVxufVxubGV0IGZpZWxkTWFya2VyID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ud2lkZ2V0KHsgd2lkZ2V0OiAvKkBfX1BVUkVfXyovbmV3IGNsYXNzIGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgICAgIHRvRE9NKCkge1xuICAgICAgICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS1zbmlwcGV0RmllbGRQb3NpdGlvblwiO1xuICAgICAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgICAgIH1cbiAgICAgICAgaWdub3JlRXZlbnQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIH0gfSk7XG5sZXQgZmllbGRSYW5nZSA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1zbmlwcGV0RmllbGRcIiB9KTtcbmNsYXNzIEFjdGl2ZVNuaXBwZXQge1xuICAgIGNvbnN0cnVjdG9yKHJhbmdlcywgYWN0aXZlKSB7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgdGhpcy5kZWNvID0gRGVjb3JhdGlvbi5zZXQocmFuZ2VzLm1hcChyID0+IChyLmZyb20gPT0gci50byA/IGZpZWxkTWFya2VyIDogZmllbGRSYW5nZSkucmFuZ2Uoci5mcm9tLCByLnRvKSkpO1xuICAgIH1cbiAgICBtYXAoY2hhbmdlcykge1xuICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHIgb2YgdGhpcy5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBtYXBwZWQgPSByLm1hcChjaGFuZ2VzKTtcbiAgICAgICAgICAgIGlmICghbWFwcGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2gobWFwcGVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVNuaXBwZXQocmFuZ2VzLCB0aGlzLmFjdGl2ZSk7XG4gICAgfVxuICAgIHNlbGVjdGlvbkluc2lkZUZpZWxkKHNlbCkge1xuICAgICAgICByZXR1cm4gc2VsLnJhbmdlcy5ldmVyeShyYW5nZSA9PiB0aGlzLnJhbmdlcy5zb21lKHIgPT4gci5maWVsZCA9PSB0aGlzLmFjdGl2ZSAmJiByLmZyb20gPD0gcmFuZ2UuZnJvbSAmJiByLnRvID49IHJhbmdlLnRvKSk7XG4gICAgfVxufVxuY29uc3Qgc2V0QWN0aXZlID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7XG4gICAgbWFwKHZhbHVlLCBjaGFuZ2VzKSB7IHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5tYXAoY2hhbmdlcyk7IH1cbn0pO1xuY29uc3QgbW92ZVRvRmllbGQgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBzbmlwcGV0U3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXRBY3RpdmUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBlZmZlY3QudmFsdWU7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKG1vdmVUb0ZpZWxkKSAmJiB2YWx1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVNuaXBwZXQodmFsdWUucmFuZ2VzLCBlZmZlY3QudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0ci5kb2NDaGFuZ2VkKVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAodHIuY2hhbmdlcyk7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0ci5zZWxlY3Rpb24gJiYgIXZhbHVlLnNlbGVjdGlvbkluc2lkZUZpZWxkKHRyLnNlbGVjdGlvbikpXG4gICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gRWRpdG9yVmlldy5kZWNvcmF0aW9ucy5mcm9tKGYsIHZhbCA9PiB2YWwgPyB2YWwuZGVjbyA6IERlY29yYXRpb24ubm9uZSlcbn0pO1xuZnVuY3Rpb24gZmllbGRTZWxlY3Rpb24ocmFuZ2VzLCBmaWVsZCkge1xuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcy5maWx0ZXIociA9PiByLmZpZWxkID09IGZpZWxkKS5tYXAociA9PiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2Uoci5mcm9tLCByLnRvKSkpO1xufVxuLyoqXG5Db252ZXJ0IGEgc25pcHBldCB0ZW1wbGF0ZSB0byBhIGZ1bmN0aW9uIHRoYXQgY2FuXG5bYXBwbHldKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLkNvbXBsZXRpb24uYXBwbHkpIGl0LiBTbmlwcGV0cyBhcmUgd3JpdHRlblxudXNpbmcgc3ludGF4IGxpa2UgdGhpczpcblxuICAgIFwiZm9yIChsZXQgJHtpbmRleH0gPSAwOyAke2luZGV4fSA8ICR7ZW5kfTsgJHtpbmRleH0rKykge1xcblxcdCR7fVxcbn1cIlxuXG5FYWNoIGAke31gIHBsYWNlaG9sZGVyICh5b3UgbWF5IGFsc28gdXNlIGAje31gKSBpbmRpY2F0ZXMgYSBmaWVsZFxudGhhdCB0aGUgdXNlciBjYW4gZmlsbCBpbi4gSXRzIG5hbWUsIGlmIGFueSwgd2lsbCBiZSB0aGUgZGVmYXVsdFxuY29udGVudCBmb3IgdGhlIGZpZWxkLlxuXG5XaGVuIHRoZSBzbmlwcGV0IGlzIGFjdGl2YXRlZCBieSBjYWxsaW5nIHRoZSByZXR1cm5lZCBmdW5jdGlvbixcbnRoZSBjb2RlIGlzIGluc2VydGVkIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi4gTmV3bGluZXMgaW4gdGhlXG50ZW1wbGF0ZSBhcmUgaW5kZW50ZWQgYnkgdGhlIGluZGVudGF0aW9uIG9mIHRoZSBzdGFydCBsaW5lLCBwbHVzXG5vbmUgW2luZGVudCB1bml0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFVuaXQpIHBlciB0YWIgY2hhcmFjdGVyIGFmdGVyXG50aGUgbmV3bGluZS5cblxuT24gYWN0aXZhdGlvbiwgKGFsbCBpbnN0YW5jZXMgb2YpIHRoZSBmaXJzdCBmaWVsZCBhcmUgc2VsZWN0ZWQuXG5UaGUgdXNlciBjYW4gbW92ZSBiZXR3ZWVuIGZpZWxkcyB3aXRoIFRhYiBhbmQgU2hpZnQtVGFiIGFzIGxvbmcgYXNcbnRoZSBmaWVsZHMgYXJlIGFjdGl2ZS4gTW92aW5nIHRvIHRoZSBsYXN0IGZpZWxkIG9yIG1vdmluZyB0aGVcbmN1cnNvciBvdXQgb2YgdGhlIGN1cnJlbnQgZmllbGQgZGVhY3RpdmF0ZXMgdGhlIGZpZWxkcy5cblxuVGhlIG9yZGVyIG9mIGZpZWxkcyBkZWZhdWx0cyB0byB0ZXh0dWFsIG9yZGVyLCBidXQgeW91IGNhbiBhZGRcbm51bWJlcnMgdG8gcGxhY2Vob2xkZXJzIChgJHsxfWAgb3IgYCR7MTpkZWZhdWx0VGV4dH1gKSB0byBwcm92aWRlXG5hIGN1c3RvbSBvcmRlci5cblxuVG8gaW5jbHVkZSBhIGxpdGVyYWwgYHtgIG9yIGB9YCBpbiB5b3VyIHRlbXBsYXRlLCBwdXQgYSBiYWNrc2xhc2hcbmluIGZyb250IG9mIGl0LiBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBhbmQgdGhlIGJyYWNlIHdpbGwgbm90IGJlXG5pbnRlcnByZXRlZCBhcyBpbmRpY2F0aW5nIGEgcGxhY2Vob2xkZXIuXG4qL1xuZnVuY3Rpb24gc25pcHBldCh0ZW1wbGF0ZSkge1xuICAgIGxldCBzbmlwcGV0ID0gU25pcHBldC5wYXJzZSh0ZW1wbGF0ZSk7XG4gICAgcmV0dXJuIChlZGl0b3IsIGNvbXBsZXRpb24sIGZyb20sIHRvKSA9PiB7XG4gICAgICAgIGxldCB7IHRleHQsIHJhbmdlcyB9ID0gc25pcHBldC5pbnN0YW50aWF0ZShlZGl0b3Iuc3RhdGUsIGZyb20pO1xuICAgICAgICBsZXQgc3BlYyA9IHtcbiAgICAgICAgICAgIGNoYW5nZXM6IHsgZnJvbSwgdG8sIGluc2VydDogVGV4dC5vZih0ZXh0KSB9LFxuICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgICAgICBhbm5vdGF0aW9uczogY29tcGxldGlvbiA/IFtwaWNrZWRDb21wbGV0aW9uLm9mKGNvbXBsZXRpb24pLCBUcmFuc2FjdGlvbi51c2VyRXZlbnQub2YoXCJpbnB1dC5jb21wbGV0ZVwiKV0gOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICBzcGVjLnNlbGVjdGlvbiA9IGZpZWxkU2VsZWN0aW9uKHJhbmdlcywgMCk7XG4gICAgICAgIGlmIChyYW5nZXMuc29tZShyID0+IHIuZmllbGQgPiAwKSkge1xuICAgICAgICAgICAgbGV0IGFjdGl2ZSA9IG5ldyBBY3RpdmVTbmlwcGV0KHJhbmdlcywgMCk7XG4gICAgICAgICAgICBsZXQgZWZmZWN0cyA9IHNwZWMuZWZmZWN0cyA9IFtzZXRBY3RpdmUub2YoYWN0aXZlKV07XG4gICAgICAgICAgICBpZiAoZWRpdG9yLnN0YXRlLmZpZWxkKHNuaXBwZXRTdGF0ZSwgZmFsc2UpID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgZWZmZWN0cy5wdXNoKFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihbc25pcHBldFN0YXRlLCBhZGRTbmlwcGV0S2V5bWFwLCBzbmlwcGV0UG9pbnRlckhhbmRsZXIsIGJhc2VUaGVtZV0pKTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3IuZGlzcGF0Y2goZWRpdG9yLnN0YXRlLnVwZGF0ZShzcGVjKSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1vdmVGaWVsZChkaXIpIHtcbiAgICByZXR1cm4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgbGV0IGFjdGl2ZSA9IHN0YXRlLmZpZWxkKHNuaXBwZXRTdGF0ZSwgZmFsc2UpO1xuICAgICAgICBpZiAoIWFjdGl2ZSB8fCBkaXIgPCAwICYmIGFjdGl2ZS5hY3RpdmUgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IG5leHQgPSBhY3RpdmUuYWN0aXZlICsgZGlyLCBsYXN0ID0gZGlyID4gMCAmJiAhYWN0aXZlLnJhbmdlcy5zb21lKHIgPT4gci5maWVsZCA9PSBuZXh0ICsgZGlyKTtcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHtcbiAgICAgICAgICAgIHNlbGVjdGlvbjogZmllbGRTZWxlY3Rpb24oYWN0aXZlLnJhbmdlcywgbmV4dCksXG4gICAgICAgICAgICBlZmZlY3RzOiBzZXRBY3RpdmUub2YobGFzdCA/IG51bGwgOiBuZXcgQWN0aXZlU25pcHBldChhY3RpdmUucmFuZ2VzLCBuZXh0KSksXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbkEgY29tbWFuZCB0aGF0IGNsZWFycyB0aGUgYWN0aXZlIHNuaXBwZXQsIGlmIGFueS5cbiovXG5jb25zdCBjbGVhclNuaXBwZXQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCBhY3RpdmUgPSBzdGF0ZS5maWVsZChzbmlwcGV0U3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWFjdGl2ZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IGVmZmVjdHM6IHNldEFjdGl2ZS5vZihudWxsKSB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRvIHRoZSBuZXh0IHNuaXBwZXQgZmllbGQsIGlmIGF2YWlsYWJsZS5cbiovXG5jb25zdCBuZXh0U25pcHBldEZpZWxkID0gLypAX19QVVJFX18qL21vdmVGaWVsZCgxKTtcbi8qKlxuTW92ZSB0byB0aGUgcHJldmlvdXMgc25pcHBldCBmaWVsZCwgaWYgYXZhaWxhYmxlLlxuKi9cbmNvbnN0IHByZXZTbmlwcGV0RmllbGQgPSAvKkBfX1BVUkVfXyovbW92ZUZpZWxkKC0xKTtcbi8qKlxuQ2hlY2sgaWYgdGhlcmUgaXMgYW4gYWN0aXZlIHNuaXBwZXQgd2l0aCBhIG5leHQgZmllbGQgZm9yXG5gbmV4dFNuaXBwZXRGaWVsZGAgdG8gbW92ZSB0by5cbiovXG5mdW5jdGlvbiBoYXNOZXh0U25pcHBldEZpZWxkKHN0YXRlKSB7XG4gICAgbGV0IGFjdGl2ZSA9IHN0YXRlLmZpZWxkKHNuaXBwZXRTdGF0ZSwgZmFsc2UpO1xuICAgIHJldHVybiAhIShhY3RpdmUgJiYgYWN0aXZlLnJhbmdlcy5zb21lKHIgPT4gci5maWVsZCA9PSBhY3RpdmUuYWN0aXZlICsgMSkpO1xufVxuLyoqXG5SZXR1cm5zIHRydWUgaWYgdGhlcmUgaXMgYW4gYWN0aXZlIHNuaXBwZXQgYW5kIGEgcHJldmlvdXMgZmllbGRcbmZvciBgcHJldlNuaXBwZXRGaWVsZGAgdG8gbW92ZSB0by5cbiovXG5mdW5jdGlvbiBoYXNQcmV2U25pcHBldEZpZWxkKHN0YXRlKSB7XG4gICAgbGV0IGFjdGl2ZSA9IHN0YXRlLmZpZWxkKHNuaXBwZXRTdGF0ZSwgZmFsc2UpO1xuICAgIHJldHVybiAhIShhY3RpdmUgJiYgYWN0aXZlLmFjdGl2ZSA+IDApO1xufVxuY29uc3QgZGVmYXVsdFNuaXBwZXRLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiVGFiXCIsIHJ1bjogbmV4dFNuaXBwZXRGaWVsZCwgc2hpZnQ6IHByZXZTbmlwcGV0RmllbGQgfSxcbiAgICB7IGtleTogXCJFc2NhcGVcIiwgcnVuOiBjbGVhclNuaXBwZXQgfVxuXTtcbi8qKlxuQSBmYWNldCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbmZpZ3VyZSB0aGUga2V5IGJpbmRpbmdzIHVzZWQgYnlcbnNuaXBwZXRzLiBUaGUgZGVmYXVsdCBiaW5kcyBUYWIgdG9cbltgbmV4dFNuaXBwZXRGaWVsZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLm5leHRTbmlwcGV0RmllbGQpLCBTaGlmdC1UYWIgdG9cbltgcHJldlNuaXBwZXRGaWVsZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLnByZXZTbmlwcGV0RmllbGQpLCBhbmQgRXNjYXBlXG50byBbYGNsZWFyU25pcHBldGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmNsZWFyU25pcHBldCkuXG4qL1xuY29uc3Qgc25pcHBldEtleW1hcCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUobWFwcykgeyByZXR1cm4gbWFwcy5sZW5ndGggPyBtYXBzWzBdIDogZGVmYXVsdFNuaXBwZXRLZXltYXA7IH1cbn0pO1xuY29uc3QgYWRkU25pcHBldEtleW1hcCA9IC8qQF9fUFVSRV9fKi9QcmVjLmhpZ2hlc3QoLypAX19QVVJFX18qL2tleW1hcC5jb21wdXRlKFtzbmlwcGV0S2V5bWFwXSwgc3RhdGUgPT4gc3RhdGUuZmFjZXQoc25pcHBldEtleW1hcCkpKTtcbi8qKlxuQ3JlYXRlIGEgY29tcGxldGlvbiBmcm9tIGEgc25pcHBldC4gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGVcbnByb3BlcnRpZXMgZnJvbSBgY29tcGxldGlvbmAsIHBsdXMgYW4gYGFwcGx5YCBmdW5jdGlvbiB0aGF0XG5hcHBsaWVzIHRoZSBzbmlwcGV0LlxuKi9cbmZ1bmN0aW9uIHNuaXBwZXRDb21wbGV0aW9uKHRlbXBsYXRlLCBjb21wbGV0aW9uKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29tcGxldGlvbiksIHsgYXBwbHk6IHNuaXBwZXQodGVtcGxhdGUpIH0pO1xufVxuY29uc3Qgc25pcHBldFBvaW50ZXJIYW5kbGVyID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuZG9tRXZlbnRIYW5kbGVycyh7XG4gICAgbW91c2Vkb3duKGV2ZW50LCB2aWV3KSB7XG4gICAgICAgIGxldCBhY3RpdmUgPSB2aWV3LnN0YXRlLmZpZWxkKHNuaXBwZXRTdGF0ZSwgZmFsc2UpLCBwb3M7XG4gICAgICAgIGlmICghYWN0aXZlIHx8IChwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9KSkgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IG1hdGNoID0gYWN0aXZlLnJhbmdlcy5maW5kKHIgPT4gci5mcm9tIDw9IHBvcyAmJiByLnRvID49IHBvcyk7XG4gICAgICAgIGlmICghbWF0Y2ggfHwgbWF0Y2guZmllbGQgPT0gYWN0aXZlLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICBzZWxlY3Rpb246IGZpZWxkU2VsZWN0aW9uKGFjdGl2ZS5yYW5nZXMsIG1hdGNoLmZpZWxkKSxcbiAgICAgICAgICAgIGVmZmVjdHM6IHNldEFjdGl2ZS5vZihhY3RpdmUucmFuZ2VzLnNvbWUociA9PiByLmZpZWxkID4gbWF0Y2guZmllbGQpXG4gICAgICAgICAgICAgICAgPyBuZXcgQWN0aXZlU25pcHBldChhY3RpdmUucmFuZ2VzLCBtYXRjaC5maWVsZCkgOiBudWxsKSxcbiAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gd29yZFJFKHdvcmRDaGFycykge1xuICAgIGxldCBlc2NhcGVkID0gd29yZENoYXJzLnJlcGxhY2UoL1tcXF1cXC1cXFxcXS9nLCBcIlxcXFwkJlwiKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChgW1xcXFxwe0FscGhhYmV0aWN9XFxcXHB7TnVtYmVyfV8ke2VzY2FwZWR9XStgLCBcInVnXCIpO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYFtcXHcke2VzY2FwZWR9XWAsIFwiZ1wiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXBSRShyZSwgZikge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGYocmUuc291cmNlKSwgcmUudW5pY29kZSA/IFwidVwiIDogXCJcIik7XG59XG5jb25zdCB3b3JkQ2FjaGVzID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiB3b3JkQ2FjaGUod29yZENoYXJzKSB7XG4gICAgcmV0dXJuIHdvcmRDYWNoZXNbd29yZENoYXJzXSB8fCAod29yZENhY2hlc1t3b3JkQ2hhcnNdID0gbmV3IFdlYWtNYXApO1xufVxuZnVuY3Rpb24gc3RvcmVXb3Jkcyhkb2MsIHdvcmRSRSwgcmVzdWx0LCBzZWVuLCBpZ25vcmVBdCkge1xuICAgIGZvciAobGV0IGxpbmVzID0gZG9jLml0ZXJMaW5lcygpLCBwb3MgPSAwOyAhbGluZXMubmV4dCgpLmRvbmU7KSB7XG4gICAgICAgIGxldCB7IHZhbHVlIH0gPSBsaW5lcywgbTtcbiAgICAgICAgd29yZFJFLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChtID0gd29yZFJFLmV4ZWModmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoIXNlZW5bbVswXV0gJiYgcG9zICsgbS5pbmRleCAhPSBpZ25vcmVBdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgdHlwZTogXCJ0ZXh0XCIsIGxhYmVsOiBtWzBdIH0pO1xuICAgICAgICAgICAgICAgIHNlZW5bbVswXV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID49IDIwMDAgLyogQy5NYXhMaXN0ICovKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IHZhbHVlLmxlbmd0aCArIDE7XG4gICAgfVxufVxuZnVuY3Rpb24gY29sbGVjdFdvcmRzKGRvYywgY2FjaGUsIHdvcmRSRSwgdG8sIGlnbm9yZUF0KSB7XG4gICAgbGV0IGJpZyA9IGRvYy5sZW5ndGggPj0gMTAwMCAvKiBDLk1pbkNhY2hlTGVuICovO1xuICAgIGxldCBjYWNoZWQgPSBiaWcgJiYgY2FjaGUuZ2V0KGRvYyk7XG4gICAgaWYgKGNhY2hlZClcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICBsZXQgcmVzdWx0ID0gW10sIHNlZW4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmIChkb2MuY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoIG9mIGRvYy5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoLmxlbmd0aCA+PSAxMDAwIC8qIEMuTWluQ2FjaGVMZW4gKi8pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjIG9mIGNvbGxlY3RXb3JkcyhjaCwgY2FjaGUsIHdvcmRSRSwgdG8gLSBwb3MsIGlnbm9yZUF0IC0gcG9zKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlZW5bYy5sYWJlbF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZW5bYy5sYWJlbF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdG9yZVdvcmRzKGNoLCB3b3JkUkUsIHJlc3VsdCwgc2VlbiwgaWdub3JlQXQgLSBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zICs9IGNoLmxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0b3JlV29yZHMoZG9jLCB3b3JkUkUsIHJlc3VsdCwgc2VlbiwgaWdub3JlQXQpO1xuICAgIH1cbiAgICBpZiAoYmlnICYmIHJlc3VsdC5sZW5ndGggPCAyMDAwIC8qIEMuTWF4TGlzdCAqLylcbiAgICAgICAgY2FjaGUuc2V0KGRvYywgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5BIGNvbXBsZXRpb24gc291cmNlIHRoYXQgd2lsbCBzY2FuIHRoZSBkb2N1bWVudCBmb3Igd29yZHMgKHVzaW5nIGFcbltjaGFyYWN0ZXIgY2F0ZWdvcml6ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhckNhdGVnb3JpemVyKSksIGFuZFxucmV0dXJuIHRob3NlIGFzIGNvbXBsZXRpb25zLlxuKi9cbmNvbnN0IGNvbXBsZXRlQW55V29yZCA9IGNvbnRleHQgPT4ge1xuICAgIGxldCB3b3JkQ2hhcnMgPSBjb250ZXh0LnN0YXRlLmxhbmd1YWdlRGF0YUF0KFwid29yZENoYXJzXCIsIGNvbnRleHQucG9zKS5qb2luKFwiXCIpO1xuICAgIGxldCByZSA9IHdvcmRSRSh3b3JkQ2hhcnMpO1xuICAgIGxldCB0b2tlbiA9IGNvbnRleHQubWF0Y2hCZWZvcmUobWFwUkUocmUsIHMgPT4gcyArIFwiJFwiKSk7XG4gICAgaWYgKCF0b2tlbiAmJiAhY29udGV4dC5leHBsaWNpdClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGZyb20gPSB0b2tlbiA/IHRva2VuLmZyb20gOiBjb250ZXh0LnBvcztcbiAgICBsZXQgb3B0aW9ucyA9IGNvbGxlY3RXb3Jkcyhjb250ZXh0LnN0YXRlLmRvYywgd29yZENhY2hlKHdvcmRDaGFycyksIHJlLCA1MDAwMCAvKiBDLlJhbmdlICovLCBmcm9tKTtcbiAgICByZXR1cm4geyBmcm9tLCBvcHRpb25zLCB2YWxpZEZvcjogbWFwUkUocmUsIHMgPT4gXCJeXCIgKyBzKSB9O1xufTtcblxuY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgYnJhY2tldHM6IFtcIihcIiwgXCJbXCIsIFwie1wiLCBcIidcIiwgJ1wiJ10sXG4gICAgYmVmb3JlOiBcIildfTo7PlwiLFxuICAgIHN0cmluZ1ByZWZpeGVzOiBbXVxufTtcbmNvbnN0IGNsb3NlQnJhY2tldEVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoe1xuICAgIG1hcCh2YWx1ZSwgbWFwcGluZykge1xuICAgICAgICBsZXQgbWFwcGVkID0gbWFwcGluZy5tYXBQb3ModmFsdWUsIC0xLCBNYXBNb2RlLlRyYWNrQWZ0ZXIpO1xuICAgICAgICByZXR1cm4gbWFwcGVkID09IG51bGwgPyB1bmRlZmluZWQgOiBtYXBwZWQ7XG4gICAgfVxufSk7XG5jb25zdCBjbG9zZWRCcmFja2V0ID0gLypAX19QVVJFX18qL25ldyBjbGFzcyBleHRlbmRzIFJhbmdlVmFsdWUge1xufTtcbmNsb3NlZEJyYWNrZXQuc3RhcnRTaWRlID0gMTtcbmNsb3NlZEJyYWNrZXQuZW5kU2lkZSA9IC0xO1xuY29uc3QgYnJhY2tldFN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiBSYW5nZVNldC5lbXB0eTsgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUubWFwKHRyLmNoYW5nZXMpO1xuICAgICAgICBpZiAodHIuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHRyLnN0YXRlLmRvYy5saW5lQXQodHIuc2VsZWN0aW9uLm1haW4uaGVhZCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnVwZGF0ZSh7IGZpbHRlcjogZnJvbSA9PiBmcm9tID49IGxpbmUuZnJvbSAmJiBmcm9tIDw9IGxpbmUudG8gfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKGNsb3NlQnJhY2tldEVmZmVjdCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS51cGRhdGUoeyBhZGQ6IFtjbG9zZWRCcmFja2V0LnJhbmdlKGVmZmVjdC52YWx1ZSwgZWZmZWN0LnZhbHVlICsgMSldIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufSk7XG4vKipcbkV4dGVuc2lvbiB0byBlbmFibGUgYnJhY2tldC1jbG9zaW5nIGJlaGF2aW9yLiBXaGVuIGEgY2xvc2VhYmxlXG5icmFja2V0IGlzIHR5cGVkLCBpdHMgY2xvc2luZyBicmFja2V0IGlzIGltbWVkaWF0ZWx5IGluc2VydGVkXG5hZnRlciB0aGUgY3Vyc29yLiBXaGVuIGNsb3NpbmcgYSBicmFja2V0IGRpcmVjdGx5IGluIGZyb250IG9mIGFcbmNsb3NpbmcgYnJhY2tldCBpbnNlcnRlZCBieSB0aGUgZXh0ZW5zaW9uLCB0aGUgY3Vyc29yIG1vdmVzIG92ZXJcbnRoYXQgYnJhY2tldC5cbiovXG5mdW5jdGlvbiBjbG9zZUJyYWNrZXRzKCkge1xuICAgIHJldHVybiBbaW5wdXRIYW5kbGVyLCBicmFja2V0U3RhdGVdO1xufVxuY29uc3QgZGVmaW5lZENsb3NpbmcgPSBcIigpW117fTw+XCI7XG5mdW5jdGlvbiBjbG9zaW5nKGNoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWZpbmVkQ2xvc2luZy5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgaWYgKGRlZmluZWRDbG9zaW5nLmNoYXJDb2RlQXQoaSkgPT0gY2gpXG4gICAgICAgICAgICByZXR1cm4gZGVmaW5lZENsb3NpbmcuY2hhckF0KGkgKyAxKTtcbiAgICByZXR1cm4gZnJvbUNvZGVQb2ludChjaCA8IDEyOCA/IGNoIDogY2ggKyAxKTtcbn1cbmZ1bmN0aW9uIGNvbmZpZyhzdGF0ZSwgcG9zKSB7XG4gICAgcmV0dXJuIHN0YXRlLmxhbmd1YWdlRGF0YUF0KFwiY2xvc2VCcmFja2V0c1wiLCBwb3MpWzBdIHx8IGRlZmF1bHRzO1xufVxuY29uc3QgYW5kcm9pZCA9IHR5cGVvZiBuYXZpZ2F0b3IgPT0gXCJvYmplY3RcIiAmJiAvKkBfX1BVUkVfXyovL0FuZHJvaWRcXGIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCBpbnB1dEhhbmRsZXIgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5pbnB1dEhhbmRsZXIub2YoKHZpZXcsIGZyb20sIHRvLCBpbnNlcnQpID0+IHtcbiAgICBpZiAoKGFuZHJvaWQgPyB2aWV3LmNvbXBvc2luZyA6IHZpZXcuY29tcG9zaXRpb25TdGFydGVkKSB8fCB2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgaWYgKGluc2VydC5sZW5ndGggPiAyIHx8IGluc2VydC5sZW5ndGggPT0gMiAmJiBjb2RlUG9pbnRTaXplKGNvZGVQb2ludEF0KGluc2VydCwgMCkpID09IDEgfHxcbiAgICAgICAgZnJvbSAhPSBzZWwuZnJvbSB8fCB0byAhPSBzZWwudG8pXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgdHIgPSBpbnNlcnRCcmFja2V0KHZpZXcuc3RhdGUsIGluc2VydCk7XG4gICAgaWYgKCF0cilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcbkNvbW1hbmQgdGhhdCBpbXBsZW1lbnRzIGRlbGV0aW5nIGEgcGFpciBvZiBtYXRjaGluZyBicmFja2V0cyB3aGVuXG50aGUgY3Vyc29yIGlzIGJldHdlZW4gdGhlbS5cbiovXG5jb25zdCBkZWxldGVCcmFja2V0UGFpciA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNvbmYgPSBjb25maWcoc3RhdGUsIHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgIGxldCB0b2tlbnMgPSBjb25mLmJyYWNrZXRzIHx8IGRlZmF1bHRzLmJyYWNrZXRzO1xuICAgIGxldCBkb250ID0gbnVsbCwgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSBwcmV2Q2hhcihzdGF0ZS5kb2MsIHJhbmdlLmhlYWQpO1xuICAgICAgICAgICAgZm9yIChsZXQgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09IGJlZm9yZSAmJiBuZXh0Q2hhcihzdGF0ZS5kb2MsIHJhbmdlLmhlYWQpID09IGNsb3NpbmcoY29kZVBvaW50QXQodG9rZW4sIDApKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiByYW5nZS5oZWFkIC0gdG9rZW4ubGVuZ3RoLCB0bzogcmFuZ2UuaGVhZCArIHRva2VuLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuaGVhZCAtIHRva2VuLmxlbmd0aCkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByYW5nZTogZG9udCA9IHJhbmdlIH07XG4gICAgfSk7XG4gICAgaWYgKCFkb250KVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImRlbGV0ZS5iYWNrd2FyZFwiIH0pKTtcbiAgICByZXR1cm4gIWRvbnQ7XG59O1xuLyoqXG5DbG9zZS1icmFja2V0cyByZWxhdGVkIGtleSBiaW5kaW5ncy4gQmluZHMgQmFja3NwYWNlIHRvXG5bYGRlbGV0ZUJyYWNrZXRQYWlyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuZGVsZXRlQnJhY2tldFBhaXIpLlxuKi9cbmNvbnN0IGNsb3NlQnJhY2tldHNLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiQmFja3NwYWNlXCIsIHJ1bjogZGVsZXRlQnJhY2tldFBhaXIgfVxuXTtcbi8qKlxuSW1wbGVtZW50cyB0aGUgZXh0ZW5zaW9uJ3MgYmVoYXZpb3Igb24gdGV4dCBpbnNlcnRpb24uIElmIHRoZVxuZ2l2ZW4gc3RyaW5nIGNvdW50cyBhcyBhIGJyYWNrZXQgaW4gdGhlIGxhbmd1YWdlIGFyb3VuZCB0aGVcbnNlbGVjdGlvbiwgYW5kIHJlcGxhY2luZyB0aGUgc2VsZWN0aW9uIHdpdGggaXQgcmVxdWlyZXMgY3VzdG9tXG5iZWhhdmlvciAoaW5zZXJ0aW5nIGEgY2xvc2luZyB2ZXJzaW9uIG9yIHNraXBwaW5nIHBhc3QgYVxucHJldmlvdXNseS1jbG9zZWQgYnJhY2tldCksIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHRyYW5zYWN0aW9uXG5yZXByZXNlbnRpbmcgdGhhdCBjdXN0b20gYmVoYXZpb3IuIChZb3Ugb25seSBuZWVkIHRoaXMgaWYgeW91IHdhbnRcbnRvIHByb2dyYW1tYXRpY2FsbHkgaW5zZXJ0IGJyYWNrZXRz4oCUdGhlXG5bYGNsb3NlQnJhY2tldHNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5jbG9zZUJyYWNrZXRzKSBleHRlbnNpb24gd2lsbFxudGFrZSBjYXJlIG9mIHJ1bm5pbmcgdGhpcyBmb3IgdXNlciBpbnB1dC4pXG4qL1xuZnVuY3Rpb24gaW5zZXJ0QnJhY2tldChzdGF0ZSwgYnJhY2tldCkge1xuICAgIGxldCBjb25mID0gY29uZmlnKHN0YXRlLCBzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKTtcbiAgICBsZXQgdG9rZW5zID0gY29uZi5icmFja2V0cyB8fCBkZWZhdWx0cy5icmFja2V0cztcbiAgICBmb3IgKGxldCB0b2sgb2YgdG9rZW5zKSB7XG4gICAgICAgIGxldCBjbG9zZWQgPSBjbG9zaW5nKGNvZGVQb2ludEF0KHRvaywgMCkpO1xuICAgICAgICBpZiAoYnJhY2tldCA9PSB0b2spXG4gICAgICAgICAgICByZXR1cm4gY2xvc2VkID09IHRvayA/IGhhbmRsZVNhbWUoc3RhdGUsIHRvaywgdG9rZW5zLmluZGV4T2YodG9rICsgdG9rICsgdG9rKSA+IC0xLCBjb25mKVxuICAgICAgICAgICAgICAgIDogaGFuZGxlT3BlbihzdGF0ZSwgdG9rLCBjbG9zZWQsIGNvbmYuYmVmb3JlIHx8IGRlZmF1bHRzLmJlZm9yZSk7XG4gICAgICAgIGlmIChicmFja2V0ID09IGNsb3NlZCAmJiBjbG9zZWRCcmFja2V0QXQoc3RhdGUsIHN0YXRlLnNlbGVjdGlvbi5tYWluLmZyb20pKVxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUNsb3NlKHN0YXRlLCB0b2ssIGNsb3NlZCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY2xvc2VkQnJhY2tldEF0KHN0YXRlLCBwb3MpIHtcbiAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICBzdGF0ZS5maWVsZChicmFja2V0U3RhdGUpLmJldHdlZW4oMCwgc3RhdGUuZG9jLmxlbmd0aCwgZnJvbSA9PiB7XG4gICAgICAgIGlmIChmcm9tID09IHBvcylcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBuZXh0Q2hhcihkb2MsIHBvcykge1xuICAgIGxldCBuZXh0ID0gZG9jLnNsaWNlU3RyaW5nKHBvcywgcG9zICsgMik7XG4gICAgcmV0dXJuIG5leHQuc2xpY2UoMCwgY29kZVBvaW50U2l6ZShjb2RlUG9pbnRBdChuZXh0LCAwKSkpO1xufVxuZnVuY3Rpb24gcHJldkNoYXIoZG9jLCBwb3MpIHtcbiAgICBsZXQgcHJldiA9IGRvYy5zbGljZVN0cmluZyhwb3MgLSAyLCBwb3MpO1xuICAgIHJldHVybiBjb2RlUG9pbnRTaXplKGNvZGVQb2ludEF0KHByZXYsIDApKSA9PSBwcmV2Lmxlbmd0aCA/IHByZXYgOiBwcmV2LnNsaWNlKDEpO1xufVxuZnVuY3Rpb24gaGFuZGxlT3BlbihzdGF0ZSwgb3BlbiwgY2xvc2UsIGNsb3NlQmVmb3JlKSB7XG4gICAgbGV0IGRvbnQgPSBudWxsLCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBbeyBpbnNlcnQ6IG9wZW4sIGZyb206IHJhbmdlLmZyb20gfSwgeyBpbnNlcnQ6IGNsb3NlLCBmcm9tOiByYW5nZS50byB9XSxcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiBjbG9zZUJyYWNrZXRFZmZlY3Qub2YocmFuZ2UudG8gKyBvcGVuLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5yYW5nZShyYW5nZS5hbmNob3IgKyBvcGVuLmxlbmd0aCwgcmFuZ2UuaGVhZCArIG9wZW4ubGVuZ3RoKSB9O1xuICAgICAgICBsZXQgbmV4dCA9IG5leHRDaGFyKHN0YXRlLmRvYywgcmFuZ2UuaGVhZCk7XG4gICAgICAgIGlmICghbmV4dCB8fCAvXFxzLy50ZXN0KG5leHQpIHx8IGNsb3NlQmVmb3JlLmluZGV4T2YobmV4dCkgPiAtMSlcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgaW5zZXJ0OiBvcGVuICsgY2xvc2UsIGZyb206IHJhbmdlLmhlYWQgfSxcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiBjbG9zZUJyYWNrZXRFZmZlY3Qub2YocmFuZ2UuaGVhZCArIG9wZW4ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5oZWFkICsgb3Blbi5sZW5ndGgpIH07XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiBkb250ID0gcmFuZ2UgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZG9udCA/IG51bGwgOiBzdGF0ZS51cGRhdGUoY2hhbmdlcywge1xuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnR5cGVcIlxuICAgIH0pO1xufVxuZnVuY3Rpb24gaGFuZGxlQ2xvc2Uoc3RhdGUsIF9vcGVuLCBjbG9zZSkge1xuICAgIGxldCBkb250ID0gbnVsbCwgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkgJiYgbmV4dENoYXIoc3RhdGUuZG9jLCByYW5nZS5oZWFkKSA9PSBjbG9zZSlcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuaGVhZCwgdG86IHJhbmdlLmhlYWQgKyBjbG9zZS5sZW5ndGgsIGluc2VydDogY2xvc2UgfSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5oZWFkICsgY2xvc2UubGVuZ3RoKSB9O1xuICAgICAgICByZXR1cm4gZG9udCA9IHsgcmFuZ2UgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZG9udCA/IG51bGwgOiBzdGF0ZS51cGRhdGUoY2hhbmdlcywge1xuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnR5cGVcIlxuICAgIH0pO1xufVxuLy8gSGFuZGxlcyBjYXNlcyB3aGVyZSB0aGUgb3BlbiBhbmQgY2xvc2UgdG9rZW4gYXJlIHRoZSBzYW1lLCBhbmRcbi8vIHBvc3NpYmx5IHRyaXBsZSBxdW90ZXMgKGFzIGluIGBcIlwiXCJhYmNcIlwiXCJgLXN0eWxlIHF1b3RpbmcpLlxuZnVuY3Rpb24gaGFuZGxlU2FtZShzdGF0ZSwgdG9rZW4sIGFsbG93VHJpcGxlLCBjb25maWcpIHtcbiAgICBsZXQgc3RyaW5nUHJlZml4ZXMgPSBjb25maWcuc3RyaW5nUHJlZml4ZXMgfHwgZGVmYXVsdHMuc3RyaW5nUHJlZml4ZXM7XG4gICAgbGV0IGRvbnQgPSBudWxsLCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBbeyBpbnNlcnQ6IHRva2VuLCBmcm9tOiByYW5nZS5mcm9tIH0sIHsgaW5zZXJ0OiB0b2tlbiwgZnJvbTogcmFuZ2UudG8gfV0sXG4gICAgICAgICAgICAgICAgZWZmZWN0czogY2xvc2VCcmFja2V0RWZmZWN0Lm9mKHJhbmdlLnRvICsgdG9rZW4ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmFuY2hvciArIHRva2VuLmxlbmd0aCwgcmFuZ2UuaGVhZCArIHRva2VuLmxlbmd0aCkgfTtcbiAgICAgICAgbGV0IHBvcyA9IHJhbmdlLmhlYWQsIG5leHQgPSBuZXh0Q2hhcihzdGF0ZS5kb2MsIHBvcyksIHN0YXJ0O1xuICAgICAgICBpZiAobmV4dCA9PSB0b2tlbikge1xuICAgICAgICAgICAgaWYgKG5vZGVTdGFydChzdGF0ZSwgcG9zKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgaW5zZXJ0OiB0b2tlbiArIHRva2VuLCBmcm9tOiBwb3MgfSxcbiAgICAgICAgICAgICAgICAgICAgZWZmZWN0czogY2xvc2VCcmFja2V0RWZmZWN0Lm9mKHBvcyArIHRva2VuLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcyArIHRva2VuLmxlbmd0aCkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNsb3NlZEJyYWNrZXRBdChzdGF0ZSwgcG9zKSkge1xuICAgICAgICAgICAgICAgIGxldCBpc1RyaXBsZSA9IGFsbG93VHJpcGxlICYmIHN0YXRlLnNsaWNlRG9jKHBvcywgcG9zICsgdG9rZW4ubGVuZ3RoICogMykgPT0gdG9rZW4gKyB0b2tlbiArIHRva2VuO1xuICAgICAgICAgICAgICAgIGxldCBjb250ZW50ID0gaXNUcmlwbGUgPyB0b2tlbiArIHRva2VuICsgdG9rZW4gOiB0b2tlbjtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IHBvcywgdG86IHBvcyArIGNvbnRlbnQubGVuZ3RoLCBpbnNlcnQ6IGNvbnRlbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zICsgY29udGVudC5sZW5ndGgpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWxsb3dUcmlwbGUgJiYgc3RhdGUuc2xpY2VEb2MocG9zIC0gMiAqIHRva2VuLmxlbmd0aCwgcG9zKSA9PSB0b2tlbiArIHRva2VuICYmXG4gICAgICAgICAgICAoc3RhcnQgPSBjYW5TdGFydFN0cmluZ0F0KHN0YXRlLCBwb3MgLSAyICogdG9rZW4ubGVuZ3RoLCBzdHJpbmdQcmVmaXhlcykpID4gLTEgJiZcbiAgICAgICAgICAgIG5vZGVTdGFydChzdGF0ZSwgc3RhcnQpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGluc2VydDogdG9rZW4gKyB0b2tlbiArIHRva2VuICsgdG9rZW4sIGZyb206IHBvcyB9LFxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihwb3MgKyB0b2tlbi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcyArIHRva2VuLmxlbmd0aCkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocG9zKShuZXh0KSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCkge1xuICAgICAgICAgICAgaWYgKGNhblN0YXJ0U3RyaW5nQXQoc3RhdGUsIHBvcywgc3RyaW5nUHJlZml4ZXMpID4gLTEgJiYgIXByb2JhYmx5SW5TdHJpbmcoc3RhdGUsIHBvcywgdG9rZW4sIHN0cmluZ1ByZWZpeGVzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGluc2VydDogdG9rZW4gKyB0b2tlbiwgZnJvbTogcG9zIH0sXG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihwb3MgKyB0b2tlbi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MgKyB0b2tlbi5sZW5ndGgpIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IGRvbnQgPSByYW5nZSB9O1xuICAgIH0pO1xuICAgIHJldHVybiBkb250ID8gbnVsbCA6IHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7XG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQudHlwZVwiXG4gICAgfSk7XG59XG5mdW5jdGlvbiBub2RlU3RhcnQoc3RhdGUsIHBvcykge1xuICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHBvcyArIDEpO1xuICAgIHJldHVybiB0cmVlLnBhcmVudCAmJiB0cmVlLmZyb20gPT0gcG9zO1xufVxuZnVuY3Rpb24gcHJvYmFibHlJblN0cmluZyhzdGF0ZSwgcG9zLCBxdW90ZVRva2VuLCBwcmVmaXhlcykge1xuICAgIGxldCBub2RlID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHBvcywgLTEpO1xuICAgIGxldCBtYXhQcmVmaXggPSBwcmVmaXhlcy5yZWR1Y2UoKG0sIHApID0+IE1hdGgubWF4KG0sIHAubGVuZ3RoKSwgMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gc3RhdGUuc2xpY2VEb2Mobm9kZS5mcm9tLCBNYXRoLm1pbihub2RlLnRvLCBub2RlLmZyb20gKyBxdW90ZVRva2VuLmxlbmd0aCArIG1heFByZWZpeCkpO1xuICAgICAgICBsZXQgcXVvdGVQb3MgPSBzdGFydC5pbmRleE9mKHF1b3RlVG9rZW4pO1xuICAgICAgICBpZiAoIXF1b3RlUG9zIHx8IHF1b3RlUG9zID4gLTEgJiYgcHJlZml4ZXMuaW5kZXhPZihzdGFydC5zbGljZSgwLCBxdW90ZVBvcykpID4gLTEpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHdoaWxlIChmaXJzdCAmJiBmaXJzdC5mcm9tID09IG5vZGUuZnJvbSAmJiBmaXJzdC50byAtIGZpcnN0LmZyb20gPiBxdW90ZVRva2VuLmxlbmd0aCArIHF1b3RlUG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNsaWNlRG9jKGZpcnN0LnRvIC0gcXVvdGVUb2tlbi5sZW5ndGgsIGZpcnN0LnRvKSA9PSBxdW90ZVRva2VuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmaXJzdC5maXJzdENoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUudG8gPT0gcG9zICYmIG5vZGUucGFyZW50O1xuICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBub2RlID0gcGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjYW5TdGFydFN0cmluZ0F0KHN0YXRlLCBwb3MsIHByZWZpeGVzKSB7XG4gICAgbGV0IGNoYXJDYXQgPSBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocG9zKTtcbiAgICBpZiAoY2hhckNhdChzdGF0ZS5zbGljZURvYyhwb3MgLSAxLCBwb3MpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZClcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICBmb3IgKGxldCBwcmVmaXggb2YgcHJlZml4ZXMpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gcG9zIC0gcHJlZml4Lmxlbmd0aDtcbiAgICAgICAgaWYgKHN0YXRlLnNsaWNlRG9jKHN0YXJ0LCBwb3MpID09IHByZWZpeCAmJiBjaGFyQ2F0KHN0YXRlLnNsaWNlRG9jKHN0YXJ0IC0gMSwgc3RhcnQpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZClcbiAgICAgICAgICAgIHJldHVybiBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyBhdXRvY29tcGxldGlvbi5cbiovXG5mdW5jdGlvbiBhdXRvY29tcGxldGlvbihjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGNvbXBsZXRpb25TdGF0ZSxcbiAgICAgICAgY29tcGxldGlvbkNvbmZpZy5vZihjb25maWcpLFxuICAgICAgICBjb21wbGV0aW9uUGx1Z2luLFxuICAgICAgICBjb21wbGV0aW9uS2V5bWFwRXh0LFxuICAgICAgICBiYXNlVGhlbWVcbiAgICBdO1xufVxuLyoqXG5CYXNpYyBrZXliaW5kaW5ncyBmb3IgYXV0b2NvbXBsZXRpb24uXG5cbiAtIEN0cmwtU3BhY2U6IFtgc3RhcnRDb21wbGV0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuc3RhcnRDb21wbGV0aW9uKVxuIC0gRXNjYXBlOiBbYGNsb3NlQ29tcGxldGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmNsb3NlQ29tcGxldGlvbilcbiAtIEFycm93RG93bjogW2Btb3ZlQ29tcGxldGlvblNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLm1vdmVDb21wbGV0aW9uU2VsZWN0aW9uKWAodHJ1ZSlgXG4gLSBBcnJvd1VwOiBbYG1vdmVDb21wbGV0aW9uU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUubW92ZUNvbXBsZXRpb25TZWxlY3Rpb24pYChmYWxzZSlgXG4gLSBQYWdlRG93bjogW2Btb3ZlQ29tcGxldGlvblNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLm1vdmVDb21wbGV0aW9uU2VsZWN0aW9uKWAodHJ1ZSwgXCJwYWdlXCIpYFxuIC0gUGFnZURvd246IFtgbW92ZUNvbXBsZXRpb25TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5tb3ZlQ29tcGxldGlvblNlbGVjdGlvbilgKHRydWUsIFwicGFnZVwiKWBcbiAtIEVudGVyOiBbYGFjY2VwdENvbXBsZXRpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5hY2NlcHRDb21wbGV0aW9uKVxuKi9cbmNvbnN0IGNvbXBsZXRpb25LZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiQ3RybC1TcGFjZVwiLCBydW46IHN0YXJ0Q29tcGxldGlvbiB9LFxuICAgIHsga2V5OiBcIkVzY2FwZVwiLCBydW46IGNsb3NlQ29tcGxldGlvbiB9LFxuICAgIHsga2V5OiBcIkFycm93RG93blwiLCBydW46IC8qQF9fUFVSRV9fKi9tb3ZlQ29tcGxldGlvblNlbGVjdGlvbih0cnVlKSB9LFxuICAgIHsga2V5OiBcIkFycm93VXBcIiwgcnVuOiAvKkBfX1BVUkVfXyovbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24oZmFsc2UpIH0sXG4gICAgeyBrZXk6IFwiUGFnZURvd25cIiwgcnVuOiAvKkBfX1BVUkVfXyovbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24odHJ1ZSwgXCJwYWdlXCIpIH0sXG4gICAgeyBrZXk6IFwiUGFnZVVwXCIsIHJ1bjogLypAX19QVVJFX18qL21vdmVDb21wbGV0aW9uU2VsZWN0aW9uKGZhbHNlLCBcInBhZ2VcIikgfSxcbiAgICB7IGtleTogXCJFbnRlclwiLCBydW46IGFjY2VwdENvbXBsZXRpb24gfVxuXTtcbmNvbnN0IGNvbXBsZXRpb25LZXltYXBFeHQgPSAvKkBfX1BVUkVfXyovUHJlYy5oaWdoZXN0KC8qQF9fUFVSRV9fKi9rZXltYXAuY29tcHV0ZU4oW2NvbXBsZXRpb25Db25maWddLCBzdGF0ZSA9PiBzdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5kZWZhdWx0S2V5bWFwID8gW2NvbXBsZXRpb25LZXltYXBdIDogW10pKTtcbi8qKlxuR2V0IHRoZSBjdXJyZW50IGNvbXBsZXRpb24gc3RhdHVzLiBXaGVuIGNvbXBsZXRpb25zIGFyZSBhdmFpbGFibGUsXG50aGlzIHdpbGwgcmV0dXJuIGBcImFjdGl2ZVwiYC4gV2hlbiBjb21wbGV0aW9ucyBhcmUgcGVuZGluZyAoaW4gdGhlXG5wcm9jZXNzIG9mIGJlaW5nIHF1ZXJpZWQpLCB0aGlzIHJldHVybnMgYFwicGVuZGluZ1wiYC4gT3RoZXJ3aXNlLCBpdFxucmV0dXJucyBgbnVsbGAuXG4qL1xuZnVuY3Rpb24gY29tcGxldGlvblN0YXR1cyhzdGF0ZSkge1xuICAgIGxldCBjU3RhdGUgPSBzdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICByZXR1cm4gY1N0YXRlICYmIGNTdGF0ZS5hY3RpdmUuc29tZShhID0+IGEuc3RhdGUgPT0gMSAvKiBTdGF0ZS5QZW5kaW5nICovKSA/IFwicGVuZGluZ1wiXG4gICAgICAgIDogY1N0YXRlICYmIGNTdGF0ZS5hY3RpdmUuc29tZShhID0+IGEuc3RhdGUgIT0gMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLykgPyBcImFjdGl2ZVwiIDogbnVsbDtcbn1cbmNvbnN0IGNvbXBsZXRpb25BcnJheUNhY2hlID0gLypAX19QVVJFX18qL25ldyBXZWFrTWFwO1xuLyoqXG5SZXR1cm5zIHRoZSBhdmFpbGFibGUgY29tcGxldGlvbnMgYXMgYW4gYXJyYXkuXG4qL1xuZnVuY3Rpb24gY3VycmVudENvbXBsZXRpb25zKHN0YXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBvcGVuID0gKF9hID0gc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcGVuO1xuICAgIGlmICghb3BlbiB8fCBvcGVuLmRpc2FibGVkKVxuICAgICAgICByZXR1cm4gW107XG4gICAgbGV0IGNvbXBsZXRpb25zID0gY29tcGxldGlvbkFycmF5Q2FjaGUuZ2V0KG9wZW4ub3B0aW9ucyk7XG4gICAgaWYgKCFjb21wbGV0aW9ucylcbiAgICAgICAgY29tcGxldGlvbkFycmF5Q2FjaGUuc2V0KG9wZW4ub3B0aW9ucywgY29tcGxldGlvbnMgPSBvcGVuLm9wdGlvbnMubWFwKG8gPT4gby5jb21wbGV0aW9uKSk7XG4gICAgcmV0dXJuIGNvbXBsZXRpb25zO1xufVxuLyoqXG5SZXR1cm4gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBjb21wbGV0aW9uLCBpZiBhbnkuXG4qL1xuZnVuY3Rpb24gc2VsZWN0ZWRDb21wbGV0aW9uKHN0YXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBvcGVuID0gKF9hID0gc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcGVuO1xuICAgIHJldHVybiBvcGVuICYmICFvcGVuLmRpc2FibGVkICYmIG9wZW4uc2VsZWN0ZWQgPj0gMCA/IG9wZW4ub3B0aW9uc1tvcGVuLnNlbGVjdGVkXS5jb21wbGV0aW9uIDogbnVsbDtcbn1cbi8qKlxuUmV0dXJucyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHBvc2l0aW9uIGluIHRoZSBhY3RpdmUgY29tcGxldGlvblxubGlzdCwgb3IgbnVsbCBpZiBubyBjb21wbGV0aW9ucyBhcmUgYWN0aXZlLlxuKi9cbmZ1bmN0aW9uIHNlbGVjdGVkQ29tcGxldGlvbkluZGV4KHN0YXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBvcGVuID0gKF9hID0gc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcGVuO1xuICAgIHJldHVybiBvcGVuICYmICFvcGVuLmRpc2FibGVkICYmIG9wZW4uc2VsZWN0ZWQgPj0gMCA/IG9wZW4uc2VsZWN0ZWQgOiBudWxsO1xufVxuLyoqXG5DcmVhdGUgYW4gZWZmZWN0IHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGEgdHJhbnNhY3Rpb24gdG8gY2hhbmdlXG50aGUgY3VycmVudGx5IHNlbGVjdGVkIGNvbXBsZXRpb24uXG4qL1xuZnVuY3Rpb24gc2V0U2VsZWN0ZWRDb21wbGV0aW9uKGluZGV4KSB7XG4gICAgcmV0dXJuIHNldFNlbGVjdGVkRWZmZWN0Lm9mKGluZGV4KTtcbn1cblxuZXhwb3J0IHsgQ29tcGxldGlvbkNvbnRleHQsIGFjY2VwdENvbXBsZXRpb24sIGF1dG9jb21wbGV0aW9uLCBjbGVhclNuaXBwZXQsIGNsb3NlQnJhY2tldHMsIGNsb3NlQnJhY2tldHNLZXltYXAsIGNsb3NlQ29tcGxldGlvbiwgY29tcGxldGVBbnlXb3JkLCBjb21wbGV0ZUZyb21MaXN0LCBjb21wbGV0aW9uS2V5bWFwLCBjb21wbGV0aW9uU3RhdHVzLCBjdXJyZW50Q29tcGxldGlvbnMsIGRlbGV0ZUJyYWNrZXRQYWlyLCBoYXNOZXh0U25pcHBldEZpZWxkLCBoYXNQcmV2U25pcHBldEZpZWxkLCBpZkluLCBpZk5vdEluLCBpbnNlcnRCcmFja2V0LCBpbnNlcnRDb21wbGV0aW9uVGV4dCwgbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24sIG5leHRTbmlwcGV0RmllbGQsIHBpY2tlZENvbXBsZXRpb24sIHByZXZTbmlwcGV0RmllbGQsIHNlbGVjdGVkQ29tcGxldGlvbiwgc2VsZWN0ZWRDb21wbGV0aW9uSW5kZXgsIHNldFNlbGVjdGVkQ29tcGxldGlvbiwgc25pcHBldCwgc25pcHBldENvbXBsZXRpb24sIHNuaXBwZXRLZXltYXAsIHN0YXJ0Q29tcGxldGlvbiB9O1xuIl0sIm5hbWVzIjpbIkFubm90YXRpb24iLCJTdGF0ZUVmZmVjdCIsIkVkaXRvclNlbGVjdGlvbiIsImNvZGVQb2ludEF0IiwiY29kZVBvaW50U2l6ZSIsImZyb21Db2RlUG9pbnQiLCJGYWNldCIsImNvbWJpbmVDb25maWciLCJTdGF0ZUZpZWxkIiwiUHJlYyIsIlRleHQiLCJUcmFuc2FjdGlvbiIsIk1hcE1vZGUiLCJSYW5nZVZhbHVlIiwiUmFuZ2VTZXQiLCJDaGFyQ2F0ZWdvcnkiLCJEaXJlY3Rpb24iLCJsb2dFeGNlcHRpb24iLCJzaG93VG9vbHRpcCIsIkVkaXRvclZpZXciLCJWaWV3UGx1Z2luIiwiZ2V0VG9vbHRpcCIsIkRlY29yYXRpb24iLCJXaWRnZXRUeXBlIiwia2V5bWFwIiwic3ludGF4VHJlZSIsImluZGVudFVuaXQiLCJDb21wbGV0aW9uQ29udGV4dCIsImNvbnN0cnVjdG9yIiwic3RhdGUiLCJwb3MiLCJleHBsaWNpdCIsImFib3J0TGlzdGVuZXJzIiwidG9rZW5CZWZvcmUiLCJ0eXBlcyIsInRva2VuIiwicmVzb2x2ZUlubmVyIiwiaW5kZXhPZiIsIm5hbWUiLCJwYXJlbnQiLCJmcm9tIiwidG8iLCJ0ZXh0Iiwic2xpY2VEb2MiLCJ0eXBlIiwibWF0Y2hCZWZvcmUiLCJleHByIiwibGluZSIsImRvYyIsImxpbmVBdCIsInN0YXJ0IiwiTWF0aCIsIm1heCIsInN0ciIsInNsaWNlIiwiZm91bmQiLCJzZWFyY2giLCJlbnN1cmVBbmNob3IiLCJhYm9ydGVkIiwiYWRkRXZlbnRMaXN0ZW5lciIsImxpc3RlbmVyIiwicHVzaCIsInRvU2V0IiwiY2hhcnMiLCJmbGF0IiwiT2JqZWN0Iiwia2V5cyIsImpvaW4iLCJ3b3JkcyIsInRlc3QiLCJyZXBsYWNlIiwicHJlZml4TWF0Y2giLCJvcHRpb25zIiwiZmlyc3QiLCJjcmVhdGUiLCJyZXN0IiwibGFiZWwiLCJpIiwibGVuZ3RoIiwic291cmNlIiwiUmVnRXhwIiwiY29tcGxldGVGcm9tTGlzdCIsImxpc3QiLCJtYXAiLCJvIiwidmFsaWRGb3IiLCJtYXRjaCIsImV2ZXJ5IiwiY29udGV4dCIsImlmSW4iLCJub2RlcyIsImlzVG9wIiwiaWZOb3RJbiIsIk9wdGlvbiIsImNvbXBsZXRpb24iLCJzY29yZSIsImN1ciIsInNlbGVjdGlvbiIsIm1haW4iLCJfYSIsImFkZFN0YXJ0IiwiYWRkRW5kIiwiZmxhZ3MiLCJpZ25vcmVDYXNlIiwicGlja2VkQ29tcGxldGlvbiIsImRlZmluZSIsImluc2VydENvbXBsZXRpb25UZXh0IiwiZnJvbU9mZiIsInRvT2ZmIiwiYXNzaWduIiwiY2hhbmdlQnlSYW5nZSIsInJhbmdlIiwiY2hhbmdlcyIsImluc2VydCIsImN1cnNvciIsInNjcm9sbEludG9WaWV3IiwidXNlckV2ZW50IiwiU291cmNlQ2FjaGUiLCJXZWFrTWFwIiwiYXNTb3VyY2UiLCJBcnJheSIsImlzQXJyYXkiLCJrbm93biIsImdldCIsInNldCIsInN0YXJ0Q29tcGxldGlvbkVmZmVjdCIsImNsb3NlQ29tcGxldGlvbkVmZmVjdCIsIkZ1enp5TWF0Y2hlciIsInBhdHRlcm4iLCJmb2xkZWQiLCJhbnkiLCJwcmVjaXNlIiwiYnlXb3JkIiwibWF0Y2hlZCIsInAiLCJjaGFyIiwic2l6ZSIsInBhcnQiLCJ1cHBlciIsInRvVXBwZXJDYXNlIiwidG9Mb3dlckNhc2UiLCJhc3RyYWwiLCJyZXQiLCJ3b3JkIiwiZmlyc3RTaXplIiwiZGlyZWN0IiwibGVuIiwiYW55VG8iLCJlIiwibWluIiwibmV4dCIsInByZWNpc2VUbyIsImJ5V29yZFRvIiwiYnlXb3JkRm9sZGVkIiwiYWRqYWNlbnRUbyIsImFkamFjZW50U3RhcnQiLCJhZGphY2VudEVuZCIsImhhc0xvd2VyIiwid29yZEFkamFjZW50IiwicHJldlR5cGUiLCJjaCIsInJlc3VsdCIsInBvc2l0aW9ucyIsImNvbXBsZXRpb25Db25maWciLCJjb21iaW5lIiwiY29uZmlncyIsImFjdGl2YXRlT25UeXBpbmciLCJhY3RpdmF0ZU9uVHlwaW5nRGVsYXkiLCJzZWxlY3RPbk9wZW4iLCJvdmVycmlkZSIsImNsb3NlT25CbHVyIiwibWF4UmVuZGVyZWRPcHRpb25zIiwiZGVmYXVsdEtleW1hcCIsInRvb2x0aXBDbGFzcyIsIm9wdGlvbkNsYXNzIiwiYWJvdmVDdXJzb3IiLCJpY29ucyIsImFkZFRvT3B0aW9ucyIsInBvc2l0aW9uSW5mbyIsImRlZmF1bHRQb3NpdGlvbkluZm8iLCJjb21wYXJlQ29tcGxldGlvbnMiLCJhIiwiYiIsImxvY2FsZUNvbXBhcmUiLCJpbnRlcmFjdGlvbkRlbGF5IiwidXBkYXRlU3luY1RpbWUiLCJjIiwiam9pbkNsYXNzIiwiY29uY2F0IiwidmlldyIsIm9wdGlvbiIsImluZm8iLCJzcGFjZSIsInRvb2x0aXAiLCJydGwiLCJ0ZXh0RGlyZWN0aW9uIiwiUlRMIiwibGVmdCIsIm5hcnJvdyIsInNpZGUiLCJvZmZzZXQiLCJtYXhXaWR0aCIsInNwYWNlTGVmdCIsInNwYWNlUmlnaHQiLCJyaWdodCIsImluZm9XaWR0aCIsImluZm9IZWlnaHQiLCJib3R0b20iLCJ0b3AiLCJzcGFjZUJlbG93Iiwic2NhbGVZIiwib2Zmc2V0SGVpZ2h0Iiwic2NhbGVYIiwib2Zmc2V0V2lkdGgiLCJzdHlsZSIsImNsYXNzIiwib3B0aW9uQ29udGVudCIsImNvbmZpZyIsImNvbnRlbnQiLCJyZW5kZXIiLCJpY29uIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NMaXN0IiwiYWRkIiwic3BsaXQiLCJjbHMiLCJzZXRBdHRyaWJ1dGUiLCJwb3NpdGlvbiIsIl9zIiwiX3YiLCJsYWJlbEVsdCIsImNsYXNzTmFtZSIsImRpc3BsYXlMYWJlbCIsIm9mZiIsImoiLCJhcHBlbmRDaGlsZCIsImNyZWF0ZVRleHROb2RlIiwic3BhbiIsImRldGFpbCIsImRldGFpbEVsdCIsInRleHRDb250ZW50Iiwic29ydCIsInJhbmdlQXJvdW5kU2VsZWN0ZWQiLCJ0b3RhbCIsInNlbGVjdGVkIiwiZmxvb3IiLCJDb21wbGV0aW9uVG9vbHRpcCIsInN0YXRlRmllbGQiLCJhcHBseUNvbXBsZXRpb24iLCJpbmZvRGVzdHJveSIsInBsYWNlSW5mb1JlcSIsInJlYWQiLCJtZWFzdXJlSW5mbyIsIndyaXRlIiwicGxhY2VJbmZvIiwia2V5IiwiY3VycmVudENsYXNzIiwiY1N0YXRlIiwiZmllbGQiLCJvcGVuIiwiZmFjZXQiLCJkb20iLCJ1cGRhdGVUb29sdGlwQ2xhc3MiLCJ0YXJnZXQiLCJwYXJlbnROb2RlIiwibm9kZU5hbWUiLCJleGVjIiwiaWQiLCJwcmV2ZW50RGVmYXVsdCIsInJlbGF0ZWRUYXJnZXQiLCJjb250ZW50RE9NIiwiZGlzcGF0Y2giLCJlZmZlY3RzIiwib2YiLCJzaG93T3B0aW9ucyIsIm1vdW50IiwidXBkYXRlU2VsIiwicmVtb3ZlIiwiY3JlYXRlTGlzdEJveCIsInJlcXVlc3RNZWFzdXJlIiwidXBkYXRlIiwicHJldlN0YXRlIiwic3RhcnRTdGF0ZSIsImRpc2FibGVkIiwidG9nZ2xlIiwicG9zaXRpb25lZCIsInVwZGF0ZVNlbGVjdGVkT3B0aW9uIiwiZGVzdHJveUluZm8iLCJpbmZvUmVzdWx0IiwidGhlbiIsIm9iaiIsImFkZEluZm9QYW5lIiwiY2F0Y2giLCJ3cmFwIiwibm9kZVR5cGUiLCJkZXN0cm95Iiwib3B0IiwiZmlyc3RDaGlsZCIsIm5leHRTaWJsaW5nIiwiaGFzQXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwic2VsIiwicXVlcnlTZWxlY3RvciIsImxpc3RSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiaW5mb1JlY3QiLCJzZWxSZWN0Iiwid2luIiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3Iiwid2luZG93IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwiY3NzVGV4dCIsInVsIiwicGhyYXNlIiwiY3VyU2VjdGlvbiIsInNlY3Rpb24iLCJoZWFkZXIiLCJsaSIsIm5vZGUiLCJjb21wbGV0aW9uVG9vbHRpcCIsImNvbnRhaW5lciIsImVsZW1lbnQiLCJzZWxmIiwiaGVpZ2h0Iiwic2Nyb2xsVG9wIiwiYm9vc3QiLCJhcHBseSIsInNvcnRPcHRpb25zIiwiYWN0aXZlIiwic2VjdGlvbnMiLCJhZGRPcHRpb24iLCJzb21lIiwicyIsImhhc1Jlc3VsdCIsImdldE1hdGNoIiwiZmlsdGVyIiwibWF0Y2hlciIsInNlY3Rpb25PcmRlciIsImNtcCIsIl9iIiwicmFuayIsInByZXYiLCJjb21wYXJlIiwiQ29tcGxldGlvbkRpYWxvZyIsImF0dHJzIiwidGltZXN0YW1wIiwic2V0U2VsZWN0ZWQiLCJtYWtlQXR0cnMiLCJidWlsZCIsImNvbmYiLCJzZWxlY3RlZFZhbHVlIiwicmVkdWNlIiwiY3JlYXRlVG9vbHRpcCIsImFib3ZlIiwiRGF0ZSIsIm5vdyIsIm1hcFBvcyIsIkNvbXBsZXRpb25TdGF0ZSIsIm5vbmUiLCJyYW5kb20iLCJ0b1N0cmluZyIsInRyIiwic291cmNlcyIsImxhbmd1YWdlRGF0YUF0IiwidmFsdWUiLCJmaW5kIiwiQWN0aXZlU291cmNlIiwiZG9jQ2hhbmdlZCIsInRvdWNoZXNSYW5nZSIsInNhbWVSZXN1bHRzIiwiZWZmZWN0IiwiaXMiLCJzZXRTZWxlY3RlZEVmZmVjdCIsImJhc2VBdHRycyIsImlBIiwiaUIiLCJlbmRBIiwiZW5kQiIsImdldFVzZXJFdmVudCIsImlzVXNlckV2ZW50IiwiZXhwbGljaXRQb3MiLCJldmVudCIsImhhbmRsZVVzZXJFdmVudCIsImhhbmRsZUNoYW5nZSIsInNldEFjdGl2ZUVmZmVjdCIsImVtcHR5IiwiQWN0aXZlUmVzdWx0IiwidXBkYXRlZCIsImNoZWNrVmFsaWQiLCJtYXBwaW5nIiwiY29tcGxldGlvblN0YXRlIiwicHJvdmlkZSIsImYiLCJ2YWwiLCJjb250ZW50QXR0cmlidXRlcyIsImFubm90YXRpb25zIiwibW92ZUNvbXBsZXRpb25TZWxlY3Rpb24iLCJmb3J3YXJkIiwiYnkiLCJzdGVwIiwiYWNjZXB0Q29tcGxldGlvbiIsInJlYWRPbmx5Iiwic3RhcnRDb21wbGV0aW9uIiwiY2xvc2VDb21wbGV0aW9uIiwiUnVubmluZ1F1ZXJ5IiwidGltZSIsInVwZGF0ZXMiLCJkb25lIiwidW5kZWZpbmVkIiwiTWF4VXBkYXRlQ291bnQiLCJNaW5BYm9ydFRpbWUiLCJjb21wbGV0aW9uUGx1Z2luIiwiZnJvbUNsYXNzIiwiZGVib3VuY2VVcGRhdGUiLCJydW5uaW5nIiwiZGVib3VuY2VBY2NlcHQiLCJwZW5kaW5nU3RhcnQiLCJjb21wb3NpbmciLCJzdGFydFF1ZXJ5Iiwic2VsZWN0aW9uU2V0IiwiZG9lc1Jlc2V0IiwidHJhbnNhY3Rpb25zIiwicXVlcnkiLCJoYW5kbGVyIiwic3BsaWNlIiwiY2xlYXJUaW1lb3V0IiwiZGVsYXkiLCJxIiwic2V0VGltZW91dCIsInN0YXJ0VXBkYXRlIiwiciIsInBlbmRpbmciLCJQcm9taXNlIiwicmVzb2x2ZSIsInNjaGVkdWxlQWNjZXB0IiwiZXJyIiwiYWNjZXB0IiwiY3VycmVudCIsImV2ZW50SGFuZGxlcnMiLCJibHVyIiwiZGlhbG9nIiwiY29udGFpbnMiLCJjb21wb3NpdGlvbnN0YXJ0IiwiY29tcG9zaXRpb25lbmQiLCJiYXNlVGhlbWUiLCJmb250RmFtaWx5Iiwid2hpdGVTcGFjZSIsIm92ZXJmbG93IiwibWF4V2lkdGhfZmFsbGJhY2siLCJtaW5XaWR0aCIsIm1heEhlaWdodCIsImxpc3RTdHlsZSIsIm1hcmdpbiIsInBhZGRpbmciLCJsaW5lSGVpZ2h0Iiwib3ZlcmZsb3dYIiwidGV4dE92ZXJmbG93IiwiZGlzcGxheSIsImJvcmRlckJvdHRvbSIsInBhZGRpbmdMZWZ0Iiwib3BhY2l0eSIsImJhY2tncm91bmQiLCJjb2xvciIsInRleHRBbGlnbiIsIndpZHRoIiwiYm94U2l6aW5nIiwiYmFja2dyb3VuZENvbG9yIiwidmVydGljYWxBbGlnbiIsImJvcmRlckxlZnQiLCJ0ZXh0RGVjb3JhdGlvbiIsIm1hcmdpbkxlZnQiLCJmb250U3R5bGUiLCJmb250U2l6ZSIsInBhZGRpbmdSaWdodCIsIkZpZWxkUG9zIiwiRmllbGRSYW5nZSIsIlRyYWNrRGVsIiwiU25pcHBldCIsImxpbmVzIiwiZmllbGRQb3NpdGlvbnMiLCJpbnN0YW50aWF0ZSIsImxpbmVTdGFydCIsImxpbmVPYmoiLCJiYXNlSW5kZW50IiwiaW5kZW50IiwidGFicyIsInJhbmdlcyIsInBhcnNlIiwidGVtcGxhdGUiLCJmaWVsZHMiLCJtIiwic2VxIiwiaW5kZXgiLCJlc2MiLCJmaWVsZE1hcmtlciIsIndpZGdldCIsInRvRE9NIiwiaWdub3JlRXZlbnQiLCJmaWVsZFJhbmdlIiwibWFyayIsIkFjdGl2ZVNuaXBwZXQiLCJkZWNvIiwibWFwcGVkIiwic2VsZWN0aW9uSW5zaWRlRmllbGQiLCJzZXRBY3RpdmUiLCJtb3ZlVG9GaWVsZCIsInNuaXBwZXRTdGF0ZSIsImRlY29yYXRpb25zIiwiZmllbGRTZWxlY3Rpb24iLCJzbmlwcGV0IiwiZWRpdG9yIiwic3BlYyIsImFwcGVuZENvbmZpZyIsImFkZFNuaXBwZXRLZXltYXAiLCJzbmlwcGV0UG9pbnRlckhhbmRsZXIiLCJtb3ZlRmllbGQiLCJkaXIiLCJsYXN0IiwiY2xlYXJTbmlwcGV0IiwibmV4dFNuaXBwZXRGaWVsZCIsInByZXZTbmlwcGV0RmllbGQiLCJoYXNOZXh0U25pcHBldEZpZWxkIiwiaGFzUHJldlNuaXBwZXRGaWVsZCIsImRlZmF1bHRTbmlwcGV0S2V5bWFwIiwicnVuIiwic2hpZnQiLCJzbmlwcGV0S2V5bWFwIiwibWFwcyIsImhpZ2hlc3QiLCJjb21wdXRlIiwic25pcHBldENvbXBsZXRpb24iLCJkb21FdmVudEhhbmRsZXJzIiwibW91c2Vkb3duIiwicG9zQXRDb29yZHMiLCJ4IiwiY2xpZW50WCIsInkiLCJjbGllbnRZIiwid29yZFJFIiwid29yZENoYXJzIiwiZXNjYXBlZCIsIm1hcFJFIiwicmUiLCJ1bmljb2RlIiwid29yZENhY2hlcyIsIndvcmRDYWNoZSIsInN0b3JlV29yZHMiLCJzZWVuIiwiaWdub3JlQXQiLCJpdGVyTGluZXMiLCJsYXN0SW5kZXgiLCJjb2xsZWN0V29yZHMiLCJjYWNoZSIsImJpZyIsImNhY2hlZCIsImNoaWxkcmVuIiwiY29tcGxldGVBbnlXb3JkIiwiZGVmYXVsdHMiLCJicmFja2V0cyIsImJlZm9yZSIsInN0cmluZ1ByZWZpeGVzIiwiY2xvc2VCcmFja2V0RWZmZWN0IiwiVHJhY2tBZnRlciIsImNsb3NlZEJyYWNrZXQiLCJzdGFydFNpZGUiLCJlbmRTaWRlIiwiYnJhY2tldFN0YXRlIiwiaGVhZCIsImNsb3NlQnJhY2tldHMiLCJpbnB1dEhhbmRsZXIiLCJkZWZpbmVkQ2xvc2luZyIsImNsb3NpbmciLCJjaGFyQ29kZUF0IiwiY2hhckF0IiwiYW5kcm9pZCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImNvbXBvc2l0aW9uU3RhcnRlZCIsImluc2VydEJyYWNrZXQiLCJkZWxldGVCcmFja2V0UGFpciIsInRva2VucyIsImRvbnQiLCJwcmV2Q2hhciIsIm5leHRDaGFyIiwiY2xvc2VCcmFja2V0c0tleW1hcCIsImJyYWNrZXQiLCJ0b2siLCJjbG9zZWQiLCJoYW5kbGVTYW1lIiwiaGFuZGxlT3BlbiIsImNsb3NlZEJyYWNrZXRBdCIsImhhbmRsZUNsb3NlIiwiYmV0d2VlbiIsInNsaWNlU3RyaW5nIiwiY2xvc2UiLCJjbG9zZUJlZm9yZSIsImFuY2hvciIsIl9vcGVuIiwiYWxsb3dUcmlwbGUiLCJub2RlU3RhcnQiLCJpc1RyaXBsZSIsImNhblN0YXJ0U3RyaW5nQXQiLCJjaGFyQ2F0ZWdvcml6ZXIiLCJXb3JkIiwicHJvYmFibHlJblN0cmluZyIsInRyZWUiLCJxdW90ZVRva2VuIiwicHJlZml4ZXMiLCJtYXhQcmVmaXgiLCJxdW90ZVBvcyIsImNoYXJDYXQiLCJwcmVmaXgiLCJhdXRvY29tcGxldGlvbiIsImNvbXBsZXRpb25LZXltYXBFeHQiLCJjb21wbGV0aW9uS2V5bWFwIiwiY29tcHV0ZU4iLCJjb21wbGV0aW9uU3RhdHVzIiwiY29tcGxldGlvbkFycmF5Q2FjaGUiLCJjdXJyZW50Q29tcGxldGlvbnMiLCJjb21wbGV0aW9ucyIsInNlbGVjdGVkQ29tcGxldGlvbiIsInNlbGVjdGVkQ29tcGxldGlvbkluZGV4Iiwic2V0U2VsZWN0ZWRDb21wbGV0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/autocomplete/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/commands/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@codemirror/commands/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blockComment: () => (/* binding */ blockComment),\n/* harmony export */   blockUncomment: () => (/* binding */ blockUncomment),\n/* harmony export */   copyLineDown: () => (/* binding */ copyLineDown),\n/* harmony export */   copyLineUp: () => (/* binding */ copyLineUp),\n/* harmony export */   cursorCharBackward: () => (/* binding */ cursorCharBackward),\n/* harmony export */   cursorCharForward: () => (/* binding */ cursorCharForward),\n/* harmony export */   cursorCharLeft: () => (/* binding */ cursorCharLeft),\n/* harmony export */   cursorCharRight: () => (/* binding */ cursorCharRight),\n/* harmony export */   cursorDocEnd: () => (/* binding */ cursorDocEnd),\n/* harmony export */   cursorDocStart: () => (/* binding */ cursorDocStart),\n/* harmony export */   cursorGroupBackward: () => (/* binding */ cursorGroupBackward),\n/* harmony export */   cursorGroupForward: () => (/* binding */ cursorGroupForward),\n/* harmony export */   cursorGroupLeft: () => (/* binding */ cursorGroupLeft),\n/* harmony export */   cursorGroupRight: () => (/* binding */ cursorGroupRight),\n/* harmony export */   cursorLineBoundaryBackward: () => (/* binding */ cursorLineBoundaryBackward),\n/* harmony export */   cursorLineBoundaryForward: () => (/* binding */ cursorLineBoundaryForward),\n/* harmony export */   cursorLineBoundaryLeft: () => (/* binding */ cursorLineBoundaryLeft),\n/* harmony export */   cursorLineBoundaryRight: () => (/* binding */ cursorLineBoundaryRight),\n/* harmony export */   cursorLineDown: () => (/* binding */ cursorLineDown),\n/* harmony export */   cursorLineEnd: () => (/* binding */ cursorLineEnd),\n/* harmony export */   cursorLineStart: () => (/* binding */ cursorLineStart),\n/* harmony export */   cursorLineUp: () => (/* binding */ cursorLineUp),\n/* harmony export */   cursorMatchingBracket: () => (/* binding */ cursorMatchingBracket),\n/* harmony export */   cursorPageDown: () => (/* binding */ cursorPageDown),\n/* harmony export */   cursorPageUp: () => (/* binding */ cursorPageUp),\n/* harmony export */   cursorSubwordBackward: () => (/* binding */ cursorSubwordBackward),\n/* harmony export */   cursorSubwordForward: () => (/* binding */ cursorSubwordForward),\n/* harmony export */   cursorSyntaxLeft: () => (/* binding */ cursorSyntaxLeft),\n/* harmony export */   cursorSyntaxRight: () => (/* binding */ cursorSyntaxRight),\n/* harmony export */   defaultKeymap: () => (/* binding */ defaultKeymap),\n/* harmony export */   deleteCharBackward: () => (/* binding */ deleteCharBackward),\n/* harmony export */   deleteCharForward: () => (/* binding */ deleteCharForward),\n/* harmony export */   deleteGroupBackward: () => (/* binding */ deleteGroupBackward),\n/* harmony export */   deleteGroupForward: () => (/* binding */ deleteGroupForward),\n/* harmony export */   deleteLine: () => (/* binding */ deleteLine),\n/* harmony export */   deleteLineBoundaryBackward: () => (/* binding */ deleteLineBoundaryBackward),\n/* harmony export */   deleteLineBoundaryForward: () => (/* binding */ deleteLineBoundaryForward),\n/* harmony export */   deleteToLineEnd: () => (/* binding */ deleteToLineEnd),\n/* harmony export */   deleteToLineStart: () => (/* binding */ deleteToLineStart),\n/* harmony export */   deleteTrailingWhitespace: () => (/* binding */ deleteTrailingWhitespace),\n/* harmony export */   emacsStyleKeymap: () => (/* binding */ emacsStyleKeymap),\n/* harmony export */   history: () => (/* binding */ history),\n/* harmony export */   historyField: () => (/* binding */ historyField),\n/* harmony export */   historyKeymap: () => (/* binding */ historyKeymap),\n/* harmony export */   indentLess: () => (/* binding */ indentLess),\n/* harmony export */   indentMore: () => (/* binding */ indentMore),\n/* harmony export */   indentSelection: () => (/* binding */ indentSelection),\n/* harmony export */   indentWithTab: () => (/* binding */ indentWithTab),\n/* harmony export */   insertBlankLine: () => (/* binding */ insertBlankLine),\n/* harmony export */   insertNewline: () => (/* binding */ insertNewline),\n/* harmony export */   insertNewlineAndIndent: () => (/* binding */ insertNewlineAndIndent),\n/* harmony export */   insertTab: () => (/* binding */ insertTab),\n/* harmony export */   invertedEffects: () => (/* binding */ invertedEffects),\n/* harmony export */   isolateHistory: () => (/* binding */ isolateHistory),\n/* harmony export */   lineComment: () => (/* binding */ lineComment),\n/* harmony export */   lineUncomment: () => (/* binding */ lineUncomment),\n/* harmony export */   moveLineDown: () => (/* binding */ moveLineDown),\n/* harmony export */   moveLineUp: () => (/* binding */ moveLineUp),\n/* harmony export */   redo: () => (/* binding */ redo),\n/* harmony export */   redoDepth: () => (/* binding */ redoDepth),\n/* harmony export */   redoSelection: () => (/* binding */ redoSelection),\n/* harmony export */   selectAll: () => (/* binding */ selectAll),\n/* harmony export */   selectCharBackward: () => (/* binding */ selectCharBackward),\n/* harmony export */   selectCharForward: () => (/* binding */ selectCharForward),\n/* harmony export */   selectCharLeft: () => (/* binding */ selectCharLeft),\n/* harmony export */   selectCharRight: () => (/* binding */ selectCharRight),\n/* harmony export */   selectDocEnd: () => (/* binding */ selectDocEnd),\n/* harmony export */   selectDocStart: () => (/* binding */ selectDocStart),\n/* harmony export */   selectGroupBackward: () => (/* binding */ selectGroupBackward),\n/* harmony export */   selectGroupForward: () => (/* binding */ selectGroupForward),\n/* harmony export */   selectGroupLeft: () => (/* binding */ selectGroupLeft),\n/* harmony export */   selectGroupRight: () => (/* binding */ selectGroupRight),\n/* harmony export */   selectLine: () => (/* binding */ selectLine),\n/* harmony export */   selectLineBoundaryBackward: () => (/* binding */ selectLineBoundaryBackward),\n/* harmony export */   selectLineBoundaryForward: () => (/* binding */ selectLineBoundaryForward),\n/* harmony export */   selectLineBoundaryLeft: () => (/* binding */ selectLineBoundaryLeft),\n/* harmony export */   selectLineBoundaryRight: () => (/* binding */ selectLineBoundaryRight),\n/* harmony export */   selectLineDown: () => (/* binding */ selectLineDown),\n/* harmony export */   selectLineEnd: () => (/* binding */ selectLineEnd),\n/* harmony export */   selectLineStart: () => (/* binding */ selectLineStart),\n/* harmony export */   selectLineUp: () => (/* binding */ selectLineUp),\n/* harmony export */   selectMatchingBracket: () => (/* binding */ selectMatchingBracket),\n/* harmony export */   selectPageDown: () => (/* binding */ selectPageDown),\n/* harmony export */   selectPageUp: () => (/* binding */ selectPageUp),\n/* harmony export */   selectParentSyntax: () => (/* binding */ selectParentSyntax),\n/* harmony export */   selectSubwordBackward: () => (/* binding */ selectSubwordBackward),\n/* harmony export */   selectSubwordForward: () => (/* binding */ selectSubwordForward),\n/* harmony export */   selectSyntaxLeft: () => (/* binding */ selectSyntaxLeft),\n/* harmony export */   selectSyntaxRight: () => (/* binding */ selectSyntaxRight),\n/* harmony export */   simplifySelection: () => (/* binding */ simplifySelection),\n/* harmony export */   splitLine: () => (/* binding */ splitLine),\n/* harmony export */   standardKeymap: () => (/* binding */ standardKeymap),\n/* harmony export */   toggleBlockComment: () => (/* binding */ toggleBlockComment),\n/* harmony export */   toggleBlockCommentByLine: () => (/* binding */ toggleBlockCommentByLine),\n/* harmony export */   toggleComment: () => (/* binding */ toggleComment),\n/* harmony export */   toggleLineComment: () => (/* binding */ toggleLineComment),\n/* harmony export */   transposeChars: () => (/* binding */ transposeChars),\n/* harmony export */   undo: () => (/* binding */ undo),\n/* harmony export */   undoDepth: () => (/* binding */ undoDepth),\n/* harmony export */   undoSelection: () => (/* binding */ undoSelection)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/language */ \"(ssr)/./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n\n\n\n\n/**\nComment or uncomment the current selection. Will use line comments\nif available, otherwise falling back to block comments.\n*/ const toggleComment = (target)=>{\n    let { state } = target, line = state.doc.lineAt(state.selection.main.from), config = getConfig(target.state, line.from);\n    return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;\n};\nfunction command(f, option) {\n    return ({ state, dispatch })=>{\n        if (state.readOnly) return false;\n        let tr = f(option, state);\n        if (!tr) return false;\n        dispatch(state.update(tr));\n        return true;\n    };\n}\n/**\nComment or uncomment the current selection using line comments.\nThe line comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/ const toggleLineComment = /*@__PURE__*/ command(changeLineComment, 0 /* CommentOption.Toggle */ );\n/**\nComment the current selection using line comments.\n*/ const lineComment = /*@__PURE__*/ command(changeLineComment, 1 /* CommentOption.Comment */ );\n/**\nUncomment the current selection using line comments.\n*/ const lineUncomment = /*@__PURE__*/ command(changeLineComment, 2 /* CommentOption.Uncomment */ );\n/**\nComment or uncomment the current selection using block comments.\nThe block comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/ const toggleBlockComment = /*@__PURE__*/ command(changeBlockComment, 0 /* CommentOption.Toggle */ );\n/**\nComment the current selection using block comments.\n*/ const blockComment = /*@__PURE__*/ command(changeBlockComment, 1 /* CommentOption.Comment */ );\n/**\nUncomment the current selection using block comments.\n*/ const blockUncomment = /*@__PURE__*/ command(changeBlockComment, 2 /* CommentOption.Uncomment */ );\n/**\nComment or uncomment the lines around the current selection using\nblock comments.\n*/ const toggleBlockCommentByLine = /*@__PURE__*/ command((o, s)=>changeBlockComment(o, s, selectedLineRanges(s)), 0 /* CommentOption.Toggle */ );\nfunction getConfig(state, pos) {\n    let data = state.languageDataAt(\"commentTokens\", pos);\n    return data.length ? data[0] : {};\n}\nconst SearchMargin = 50;\n/**\nDetermines if the given range is block-commented in the given\nstate.\n*/ function findBlockComment(state, { open, close }, from, to) {\n    let textBefore = state.sliceDoc(from - SearchMargin, from);\n    let textAfter = state.sliceDoc(to, to + SearchMargin);\n    let spaceBefore = /\\s*$/.exec(textBefore)[0].length, spaceAfter = /^\\s*/.exec(textAfter)[0].length;\n    let beforeOff = textBefore.length - spaceBefore;\n    if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {\n        return {\n            open: {\n                pos: from - spaceBefore,\n                margin: spaceBefore && 1\n            },\n            close: {\n                pos: to + spaceAfter,\n                margin: spaceAfter && 1\n            }\n        };\n    }\n    let startText, endText;\n    if (to - from <= 2 * SearchMargin) {\n        startText = endText = state.sliceDoc(from, to);\n    } else {\n        startText = state.sliceDoc(from, from + SearchMargin);\n        endText = state.sliceDoc(to - SearchMargin, to);\n    }\n    let startSpace = /^\\s*/.exec(startText)[0].length, endSpace = /\\s*$/.exec(endText)[0].length;\n    let endOff = endText.length - endSpace - close.length;\n    if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {\n        return {\n            open: {\n                pos: from + startSpace + open.length,\n                margin: /\\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0\n            },\n            close: {\n                pos: to - endSpace - close.length,\n                margin: /\\s/.test(endText.charAt(endOff - 1)) ? 1 : 0\n            }\n        };\n    }\n    return null;\n}\nfunction selectedLineRanges(state) {\n    let ranges = [];\n    for (let r of state.selection.ranges){\n        let fromLine = state.doc.lineAt(r.from);\n        let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);\n        let last = ranges.length - 1;\n        if (last >= 0 && ranges[last].to > fromLine.from) ranges[last].to = toLine.to;\n        else ranges.push({\n            from: fromLine.from + /^\\s*/.exec(fromLine.text)[0].length,\n            to: toLine.to\n        });\n    }\n    return ranges;\n}\n// Performs toggle, comment and uncomment of block comments in\n// languages that support them.\nfunction changeBlockComment(option, state, ranges = state.selection.ranges) {\n    let tokens = ranges.map((r)=>getConfig(state, r.from).block);\n    if (!tokens.every((c)=>c)) return null;\n    let comments = ranges.map((r, i)=>findBlockComment(state, tokens[i], r.from, r.to));\n    if (option != 2 /* CommentOption.Uncomment */  && !comments.every((c)=>c)) {\n        return {\n            changes: state.changes(ranges.map((range, i)=>{\n                if (comments[i]) return [];\n                return [\n                    {\n                        from: range.from,\n                        insert: tokens[i].open + \" \"\n                    },\n                    {\n                        from: range.to,\n                        insert: \" \" + tokens[i].close\n                    }\n                ];\n            }))\n        };\n    } else if (option != 1 /* CommentOption.Comment */  && comments.some((c)=>c)) {\n        let changes = [];\n        for(let i = 0, comment; i < comments.length; i++)if (comment = comments[i]) {\n            let token = tokens[i], { open, close } = comment;\n            changes.push({\n                from: open.pos - token.open.length,\n                to: open.pos + open.margin\n            }, {\n                from: close.pos - close.margin,\n                to: close.pos + token.close.length\n            });\n        }\n        return {\n            changes\n        };\n    }\n    return null;\n}\n// Performs toggle, comment and uncomment of line comments.\nfunction changeLineComment(option, state, ranges = state.selection.ranges) {\n    let lines = [];\n    let prevLine = -1;\n    for (let { from, to } of ranges){\n        let startI = lines.length, minIndent = 1e9;\n        let token = getConfig(state, from).line;\n        if (!token) continue;\n        for(let pos = from; pos <= to;){\n            let line = state.doc.lineAt(pos);\n            if (line.from > prevLine && (from == to || to > line.from)) {\n                prevLine = line.from;\n                let indent = /^\\s*/.exec(line.text)[0].length;\n                let empty = indent == line.length;\n                let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;\n                if (indent < line.text.length && indent < minIndent) minIndent = indent;\n                lines.push({\n                    line,\n                    comment,\n                    token,\n                    indent,\n                    empty,\n                    single: false\n                });\n            }\n            pos = line.to + 1;\n        }\n        if (minIndent < 1e9) {\n            for(let i = startI; i < lines.length; i++)if (lines[i].indent < lines[i].line.text.length) lines[i].indent = minIndent;\n        }\n        if (lines.length == startI + 1) lines[startI].single = true;\n    }\n    if (option != 2 /* CommentOption.Uncomment */  && lines.some((l)=>l.comment < 0 && (!l.empty || l.single))) {\n        let changes = [];\n        for (let { line, token, indent, empty, single } of lines)if (single || !empty) changes.push({\n            from: line.from + indent,\n            insert: token + \" \"\n        });\n        let changeSet = state.changes(changes);\n        return {\n            changes: changeSet,\n            selection: state.selection.map(changeSet, 1)\n        };\n    } else if (option != 1 /* CommentOption.Comment */  && lines.some((l)=>l.comment >= 0)) {\n        let changes = [];\n        for (let { line, comment, token } of lines)if (comment >= 0) {\n            let from = line.from + comment, to = from + token.length;\n            if (line.text[to - line.from] == \" \") to++;\n            changes.push({\n                from,\n                to\n            });\n        }\n        return {\n            changes\n        };\n    }\n    return null;\n}\nconst fromHistory = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();\n/**\nTransaction annotation that will prevent that transaction from\nbeing combined with other transactions in the undo history. Given\n`\"before\"`, it'll prevent merging with previous transactions. With\n`\"after\"`, subsequent transactions won't be combined with this\none. With `\"full\"`, the transaction is isolated on both sides.\n*/ const isolateHistory = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();\n/**\nThis facet provides a way to register functions that, given a\ntransaction, provide a set of effects that the history should\nstore when inverting the transaction. This can be used to\nintegrate some kinds of effects in the history, so that they can\nbe undone (and redone again).\n*/ const invertedEffects = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define();\nconst historyConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\n            minDepth: 100,\n            newGroupDelay: 500,\n            joinToEvent: (_t, isAdjacent)=>isAdjacent\n        }, {\n            minDepth: Math.max,\n            newGroupDelay: Math.min,\n            joinToEvent: (a, b)=>(tr, adj)=>a(tr, adj) || b(tr, adj)\n        });\n    }\n});\nconst historyField_ = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return HistoryState.empty;\n    },\n    update (state, tr) {\n        let config = tr.state.facet(historyConfig);\n        let fromHist = tr.annotation(fromHistory);\n        if (fromHist) {\n            let item = HistEvent.fromTransaction(tr, fromHist.selection), from = fromHist.side;\n            let other = from == 0 /* BranchName.Done */  ? state.undone : state.done;\n            if (item) other = updateBranch(other, other.length, config.minDepth, item);\n            else other = addSelection(other, tr.startState.selection);\n            return new HistoryState(from == 0 /* BranchName.Done */  ? fromHist.rest : other, from == 0 /* BranchName.Done */  ? other : fromHist.rest);\n        }\n        let isolate = tr.annotation(isolateHistory);\n        if (isolate == \"full\" || isolate == \"before\") state = state.isolate();\n        if (tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.addToHistory) === false) return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;\n        let event = HistEvent.fromTransaction(tr);\n        let time = tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.time), userEvent = tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.userEvent);\n        if (event) state = state.addChanges(event, time, userEvent, config, tr);\n        else if (tr.selection) state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);\n        if (isolate == \"full\" || isolate == \"after\") state = state.isolate();\n        return state;\n    },\n    toJSON (value) {\n        return {\n            done: value.done.map((e)=>e.toJSON()),\n            undone: value.undone.map((e)=>e.toJSON())\n        };\n    },\n    fromJSON (json) {\n        return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));\n    }\n});\n/**\nCreate a history extension with the given configuration.\n*/ function history(config = {}) {\n    return [\n        historyField_,\n        historyConfig.of(config),\n        _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.domEventHandlers({\n            beforeinput (e, view) {\n                let command = e.inputType == \"historyUndo\" ? undo : e.inputType == \"historyRedo\" ? redo : null;\n                if (!command) return false;\n                e.preventDefault();\n                return command(view);\n            }\n        })\n    ];\n}\n/**\nThe state field used to store the history data. Should probably\nonly be used when you want to\n[serialize](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) or\n[deserialize](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) state objects in a way\nthat preserves history.\n*/ const historyField = historyField_;\nfunction cmd(side, selection) {\n    return function({ state, dispatch }) {\n        if (!selection && state.readOnly) return false;\n        let historyState = state.field(historyField_, false);\n        if (!historyState) return false;\n        let tr = historyState.pop(side, state, selection);\n        if (!tr) return false;\n        dispatch(tr);\n        return true;\n    };\n}\n/**\nUndo a single group of history events. Returns false if no group\nwas available.\n*/ const undo = /*@__PURE__*/ cmd(0 /* BranchName.Done */ , false);\n/**\nRedo a group of history events. Returns false if no group was\navailable.\n*/ const redo = /*@__PURE__*/ cmd(1 /* BranchName.Undone */ , false);\n/**\nUndo a change or selection change.\n*/ const undoSelection = /*@__PURE__*/ cmd(0 /* BranchName.Done */ , true);\n/**\nRedo a change or selection change.\n*/ const redoSelection = /*@__PURE__*/ cmd(1 /* BranchName.Undone */ , true);\nfunction depth(side) {\n    return function(state) {\n        let histState = state.field(historyField_, false);\n        if (!histState) return 0;\n        let branch = side == 0 /* BranchName.Done */  ? histState.done : histState.undone;\n        return branch.length - (branch.length && !branch[0].changes ? 1 : 0);\n    };\n}\n/**\nThe amount of undoable change events available in a given state.\n*/ const undoDepth = /*@__PURE__*/ depth(0 /* BranchName.Done */ );\n/**\nThe amount of redoable change events available in a given state.\n*/ const redoDepth = /*@__PURE__*/ depth(1 /* BranchName.Undone */ );\n// History events store groups of changes or effects that need to be\n// undone/redone together.\nclass HistEvent {\n    constructor(// The changes in this event. Normal events hold at least one\n    // change or effect. But it may be necessary to store selection\n    // events before the first change, in which case a special type of\n    // instance is created which doesn't hold any changes, with\n    // changes == startSelection == undefined\n    changes, // The effects associated with this event\n    effects, // Accumulated mapping (from addToHistory==false) that should be\n    // applied to events below this one.\n    mapped, // The selection before this event\n    startSelection, // Stores selection changes after this event, to be used for\n    // selection undo/redo.\n    selectionsAfter){\n        this.changes = changes;\n        this.effects = effects;\n        this.mapped = mapped;\n        this.startSelection = startSelection;\n        this.selectionsAfter = selectionsAfter;\n    }\n    setSelAfter(after) {\n        return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);\n    }\n    toJSON() {\n        var _a, _b, _c;\n        return {\n            changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),\n            mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),\n            startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),\n            selectionsAfter: this.selectionsAfter.map((s)=>s.toJSON())\n        };\n    }\n    static fromJSON(json) {\n        return new HistEvent(json.changes && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.ChangeSet.fromJSON(json.changes), [], json.mapped && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.ChangeDesc.fromJSON(json.mapped), json.startSelection && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.fromJSON));\n    }\n    // This does not check `addToHistory` and such, it assumes the\n    // transaction needs to be converted to an item. Returns null when\n    // there are no changes or effects in the transaction.\n    static fromTransaction(tr, selection) {\n        let effects = none;\n        for (let invert of tr.startState.facet(invertedEffects)){\n            let result = invert(tr);\n            if (result.length) effects = effects.concat(result);\n        }\n        if (!effects.length && tr.changes.empty) return null;\n        return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, selection || tr.startState.selection, none);\n    }\n    static selection(selections) {\n        return new HistEvent(undefined, none, undefined, undefined, selections);\n    }\n}\nfunction updateBranch(branch, to, maxLen, newEvent) {\n    let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;\n    let newBranch = branch.slice(start, to);\n    newBranch.push(newEvent);\n    return newBranch;\n}\nfunction isAdjacent(a, b) {\n    let ranges = [], isAdjacent = false;\n    a.iterChangedRanges((f, t)=>ranges.push(f, t));\n    b.iterChangedRanges((_f, _t, f, t)=>{\n        for(let i = 0; i < ranges.length;){\n            let from = ranges[i++], to = ranges[i++];\n            if (t >= from && f <= to) isAdjacent = true;\n        }\n    });\n    return isAdjacent;\n}\nfunction eqSelectionShape(a, b) {\n    return a.ranges.length == b.ranges.length && a.ranges.filter((r, i)=>r.empty != b.ranges[i].empty).length === 0;\n}\nfunction conc(a, b) {\n    return !a.length ? b : !b.length ? a : a.concat(b);\n}\nconst none = [];\nconst MaxSelectionsPerEvent = 200;\nfunction addSelection(branch, selection) {\n    if (!branch.length) {\n        return [\n            HistEvent.selection([\n                selection\n            ])\n        ];\n    } else {\n        let lastEvent = branch[branch.length - 1];\n        let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));\n        if (sels.length && sels[sels.length - 1].eq(selection)) return branch;\n        sels.push(selection);\n        return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));\n    }\n}\n// Assumes the top item has one or more selectionAfter values\nfunction popSelection(branch) {\n    let last = branch[branch.length - 1];\n    let newBranch = branch.slice();\n    newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));\n    return newBranch;\n}\n// Add a mapping to the top event in the given branch. If this maps\n// away all the changes and effects in that item, drop it and\n// propagate the mapping to the next item.\nfunction addMappingToBranch(branch, mapping) {\n    if (!branch.length) return branch;\n    let length = branch.length, selections = none;\n    while(length){\n        let event = mapEvent(branch[length - 1], mapping, selections);\n        if (event.changes && !event.changes.empty || event.effects.length) {\n            let result = branch.slice(0, length);\n            result[length - 1] = event;\n            return result;\n        } else {\n            mapping = event.mapped;\n            length--;\n            selections = event.selectionsAfter;\n        }\n    }\n    return selections.length ? [\n        HistEvent.selection(selections)\n    ] : none;\n}\nfunction mapEvent(event, mapping, extraSelections) {\n    let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s)=>s.map(mapping)) : none, extraSelections);\n    // Change-less events don't store mappings (they are always the last event in a branch)\n    if (!event.changes) return HistEvent.selection(selections);\n    let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);\n    let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;\n    return new HistEvent(mappedChanges, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);\n}\nconst joinableUserEvent = /^(input\\.type|delete)($|\\.)/;\nclass HistoryState {\n    constructor(done, undone, prevTime = 0, prevUserEvent = undefined){\n        this.done = done;\n        this.undone = undone;\n        this.prevTime = prevTime;\n        this.prevUserEvent = prevUserEvent;\n    }\n    isolate() {\n        return this.prevTime ? new HistoryState(this.done, this.undone) : this;\n    }\n    addChanges(event, time, userEvent, config, tr) {\n        let done = this.done, lastEvent = done[done.length - 1];\n        if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < config.newGroupDelay && config.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes)) || // For compose (but not compose.start) events, always join with previous event\n        userEvent == \"input.type.compose\")) {\n            done = updateBranch(done, done.length - 1, config.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));\n        } else {\n            done = updateBranch(done, done.length, config.minDepth, event);\n        }\n        return new HistoryState(done, none, time, userEvent);\n    }\n    addSelection(selection, time, userEvent, newGroupDelay) {\n        let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;\n        if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection)) return this;\n        return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);\n    }\n    addMapping(mapping) {\n        return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);\n    }\n    pop(side, state, onlySelection) {\n        let branch = side == 0 /* BranchName.Done */  ? this.done : this.undone;\n        if (branch.length == 0) return null;\n        let event = branch[branch.length - 1], selection = event.selectionsAfter[0] || state.selection;\n        if (onlySelection && event.selectionsAfter.length) {\n            return state.update({\n                selection: event.selectionsAfter[event.selectionsAfter.length - 1],\n                annotations: fromHistory.of({\n                    side,\n                    rest: popSelection(branch),\n                    selection\n                }),\n                userEvent: side == 0 /* BranchName.Done */  ? \"select.undo\" : \"select.redo\",\n                scrollIntoView: true\n            });\n        } else if (!event.changes) {\n            return null;\n        } else {\n            let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);\n            if (event.mapped) rest = addMappingToBranch(rest, event.mapped);\n            return state.update({\n                changes: event.changes,\n                selection: event.startSelection,\n                effects: event.effects,\n                annotations: fromHistory.of({\n                    side,\n                    rest,\n                    selection\n                }),\n                filter: false,\n                userEvent: side == 0 /* BranchName.Done */  ? \"undo\" : \"redo\",\n                scrollIntoView: true\n            });\n        }\n    }\n}\nHistoryState.empty = /*@__PURE__*/ new HistoryState(none, none);\n/**\nDefault key bindings for the undo history.\n\n- Mod-z: [`undo`](https://codemirror.net/6/docs/ref/#commands.undo).\n- Mod-y (Mod-Shift-z on macOS) + Ctrl-Shift-z on Linux: [`redo`](https://codemirror.net/6/docs/ref/#commands.redo).\n- Mod-u: [`undoSelection`](https://codemirror.net/6/docs/ref/#commands.undoSelection).\n- Alt-u (Mod-Shift-u on macOS): [`redoSelection`](https://codemirror.net/6/docs/ref/#commands.redoSelection).\n*/ const historyKeymap = [\n    {\n        key: \"Mod-z\",\n        run: undo,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-y\",\n        mac: \"Mod-Shift-z\",\n        run: redo,\n        preventDefault: true\n    },\n    {\n        linux: \"Ctrl-Shift-z\",\n        run: redo,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-u\",\n        run: undoSelection,\n        preventDefault: true\n    },\n    {\n        key: \"Alt-u\",\n        mac: \"Mod-Shift-u\",\n        run: redoSelection,\n        preventDefault: true\n    }\n];\nfunction updateSel(sel, by) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(sel.ranges.map(by), sel.mainIndex);\n}\nfunction setSel(state, selection) {\n    return state.update({\n        selection,\n        scrollIntoView: true,\n        userEvent: \"select\"\n    });\n}\nfunction moveSel({ state, dispatch }, how) {\n    let selection = updateSel(state.selection, how);\n    if (selection.eq(state.selection, true)) return false;\n    dispatch(setSel(state, selection));\n    return true;\n}\nfunction rangeEnd(range, forward) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(forward ? range.to : range.from);\n}\nfunction cursorByChar(view, forward) {\n    return moveSel(view, (range)=>range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));\n}\nfunction ltrAtCursor(view) {\n    return view.textDirectionAt(view.state.selection.main.head) == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR;\n}\n/**\nMove the selection one character to the left (which is backward in\nleft-to-right text, forward in right-to-left text).\n*/ const cursorCharLeft = (view)=>cursorByChar(view, !ltrAtCursor(view));\n/**\nMove the selection one character to the right.\n*/ const cursorCharRight = (view)=>cursorByChar(view, ltrAtCursor(view));\n/**\nMove the selection one character forward.\n*/ const cursorCharForward = (view)=>cursorByChar(view, true);\n/**\nMove the selection one character backward.\n*/ const cursorCharBackward = (view)=>cursorByChar(view, false);\nfunction cursorByGroup(view, forward) {\n    return moveSel(view, (range)=>range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection to the left across one group of word or\nnon-word (but also non-space) characters.\n*/ const cursorGroupLeft = (view)=>cursorByGroup(view, !ltrAtCursor(view));\n/**\nMove the selection one group to the right.\n*/ const cursorGroupRight = (view)=>cursorByGroup(view, ltrAtCursor(view));\n/**\nMove the selection one group forward.\n*/ const cursorGroupForward = (view)=>cursorByGroup(view, true);\n/**\nMove the selection one group backward.\n*/ const cursorGroupBackward = (view)=>cursorByGroup(view, false);\nconst segmenter = typeof Intl != \"undefined\" && Intl.Segmenter ? /*@__PURE__*/ new Intl.Segmenter(undefined, {\n    granularity: \"word\"\n}) : null;\nfunction moveBySubword(view, range, forward) {\n    let categorize = view.state.charCategorizer(range.from);\n    let cat = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space, pos = range.from, steps = 0;\n    let done = false, sawUpper = false, sawLower = false;\n    let step = (next)=>{\n        if (done) return false;\n        pos += forward ? next.length : -next.length;\n        let nextCat = categorize(next), ahead;\n        if (nextCat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && next.charCodeAt(0) < 128 && /[\\W_]/.test(next)) nextCat = -1; // Treat word punctuation specially\n        if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space) cat = nextCat;\n        if (cat != nextCat) return false;\n        if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) {\n            if (next.toLowerCase() == next) {\n                if (!forward && sawUpper) return false;\n                sawLower = true;\n            } else if (sawLower) {\n                if (forward) return false;\n                done = true;\n            } else {\n                if (sawUpper && forward && categorize(ahead = view.state.sliceDoc(pos, pos + 1)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && ahead.toLowerCase() == ahead) return false;\n                sawUpper = true;\n            }\n        }\n        steps++;\n        return true;\n    };\n    let end = view.moveByChar(range, forward, (start)=>{\n        step(start);\n        return step;\n    });\n    if (segmenter && cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && end.from == range.from + steps * (forward ? 1 : -1)) {\n        let from = Math.min(range.head, end.head), to = Math.max(range.head, end.head);\n        let skipped = view.state.sliceDoc(from, to);\n        if (skipped.length > 1 && /[\\u4E00-\\uffff]/.test(skipped)) {\n            let segments = Array.from(segmenter.segment(skipped));\n            if (segments.length > 1) {\n                if (forward) return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head + segments[1].index, -1);\n                return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(end.head + segments[segments.length - 1].index, 1);\n            }\n        }\n    }\n    return end;\n}\nfunction cursorBySubword(view, forward) {\n    return moveSel(view, (range)=>range.empty ? moveBySubword(view, range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection one group or camel-case subword forward.\n*/ const cursorSubwordForward = (view)=>cursorBySubword(view, true);\n/**\nMove the selection one group or camel-case subword backward.\n*/ const cursorSubwordBackward = (view)=>cursorBySubword(view, false);\nfunction interestingNode(state, node, bracketProp) {\n    if (node.type.prop(bracketProp)) return true;\n    let len = node.to - node.from;\n    return len && (len > 2 || /[^\\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;\n}\nfunction moveBySyntax(state, start, forward) {\n    let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(start.head);\n    let bracketProp = forward ? _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.openedBy;\n    // Scan forward through child nodes to see if there's an interesting\n    // node ahead.\n    for(let at = start.head;;){\n        let next = forward ? pos.childAfter(at) : pos.childBefore(at);\n        if (!next) break;\n        if (interestingNode(state, next, bracketProp)) pos = next;\n        else at = forward ? next.to : next.from;\n    }\n    let bracket = pos.type.prop(bracketProp), match, newPos;\n    if (bracket && (match = forward ? (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, pos.from, 1) : (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, pos.to, -1)) && match.matched) newPos = forward ? match.end.to : match.end.from;\n    else newPos = forward ? pos.to : pos.from;\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(newPos, forward ? -1 : 1);\n}\n/**\nMove the cursor over the next syntactic element to the left.\n*/ const cursorSyntaxLeft = (view)=>moveSel(view, (range)=>moveBySyntax(view.state, range, !ltrAtCursor(view)));\n/**\nMove the cursor over the next syntactic element to the right.\n*/ const cursorSyntaxRight = (view)=>moveSel(view, (range)=>moveBySyntax(view.state, range, ltrAtCursor(view)));\nfunction cursorByLine(view, forward) {\n    return moveSel(view, (range)=>{\n        if (!range.empty) return rangeEnd(range, forward);\n        let moved = view.moveVertically(range, forward);\n        return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);\n    });\n}\n/**\nMove the selection one line up.\n*/ const cursorLineUp = (view)=>cursorByLine(view, false);\n/**\nMove the selection one line down.\n*/ const cursorLineDown = (view)=>cursorByLine(view, true);\nfunction pageInfo(view) {\n    let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;\n    let marginTop = 0, marginBottom = 0, height;\n    if (selfScroll) {\n        for (let source of view.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollMargins)){\n            let margins = source(view);\n            if (margins === null || margins === void 0 ? void 0 : margins.top) marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);\n            if (margins === null || margins === void 0 ? void 0 : margins.bottom) marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);\n        }\n        height = view.scrollDOM.clientHeight - marginTop - marginBottom;\n    } else {\n        height = (view.dom.ownerDocument.defaultView || window).innerHeight;\n    }\n    return {\n        marginTop,\n        marginBottom,\n        selfScroll,\n        height: Math.max(view.defaultLineHeight, height - 5)\n    };\n}\nfunction cursorByPage(view, forward) {\n    let page = pageInfo(view);\n    let { state } = view, selection = updateSel(state.selection, (range)=>{\n        return range.empty ? view.moveVertically(range, forward, page.height) : rangeEnd(range, forward);\n    });\n    if (selection.eq(state.selection)) return false;\n    let effect;\n    if (page.selfScroll) {\n        let startPos = view.coordsAtPos(state.selection.main.head);\n        let scrollRect = view.scrollDOM.getBoundingClientRect();\n        let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;\n        if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom) effect = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(selection.main.head, {\n            y: \"start\",\n            yMargin: startPos.top - scrollTop\n        });\n    }\n    view.dispatch(setSel(state, selection), {\n        effects: effect\n    });\n    return true;\n}\n/**\nMove the selection one page up.\n*/ const cursorPageUp = (view)=>cursorByPage(view, false);\n/**\nMove the selection one page down.\n*/ const cursorPageDown = (view)=>cursorByPage(view, true);\nfunction moveByLineBoundary(view, start, forward) {\n    let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);\n    if (moved.head == start.head && moved.head != (forward ? line.to : line.from)) moved = view.moveToLineBoundary(start, forward, false);\n    if (!forward && moved.head == line.from && line.length) {\n        let space = /^\\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;\n        if (space && start.head != line.from + space) moved = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(line.from + space);\n    }\n    return moved;\n}\n/**\nMove the selection to the next line wrap point, or to the end of\nthe line if there isn't one left on this line.\n*/ const cursorLineBoundaryForward = (view)=>moveSel(view, (range)=>moveByLineBoundary(view, range, true));\n/**\nMove the selection to previous line wrap point, or failing that to\nthe start of the line. If the line is indented, and the cursor\nisn't already at the end of the indentation, this will move to the\nend of the indentation instead of the start of the line.\n*/ const cursorLineBoundaryBackward = (view)=>moveSel(view, (range)=>moveByLineBoundary(view, range, false));\n/**\nMove the selection one line wrap point to the left.\n*/ const cursorLineBoundaryLeft = (view)=>moveSel(view, (range)=>moveByLineBoundary(view, range, !ltrAtCursor(view)));\n/**\nMove the selection one line wrap point to the right.\n*/ const cursorLineBoundaryRight = (view)=>moveSel(view, (range)=>moveByLineBoundary(view, range, ltrAtCursor(view)));\n/**\nMove the selection to the start of the line.\n*/ const cursorLineStart = (view)=>moveSel(view, (range)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));\n/**\nMove the selection to the end of the line.\n*/ const cursorLineEnd = (view)=>moveSel(view, (range)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));\nfunction toMatchingBracket(state, dispatch, extend) {\n    let found = false, selection = updateSel(state.selection, (range)=>{\n        let matching = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head, -1) || (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head, 1) || range.head > 0 && (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head - 1, 1) || range.head < state.doc.length && (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head + 1, -1);\n        if (!matching || !matching.end) return range;\n        found = true;\n        let head = matching.start.from == range.head ? matching.end.to : matching.end.from;\n        return extend ? _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor, head) : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(head);\n    });\n    if (!found) return false;\n    dispatch(setSel(state, selection));\n    return true;\n}\n/**\nMove the selection to the bracket matching the one it is currently\non, if any.\n*/ const cursorMatchingBracket = ({ state, dispatch })=>toMatchingBracket(state, dispatch, false);\n/**\nExtend the selection to the bracket matching the one the selection\nhead is currently on, if any.\n*/ const selectMatchingBracket = ({ state, dispatch })=>toMatchingBracket(state, dispatch, true);\nfunction extendSel(view, how) {\n    let selection = updateSel(view.state.selection, (range)=>{\n        let head = how(range);\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || undefined);\n    });\n    if (selection.eq(view.state.selection)) return false;\n    view.dispatch(setSel(view.state, selection));\n    return true;\n}\nfunction selectByChar(view, forward) {\n    return extendSel(view, (range)=>view.moveByChar(range, forward));\n}\n/**\nMove the selection head one character to the left, while leaving\nthe anchor in place.\n*/ const selectCharLeft = (view)=>selectByChar(view, !ltrAtCursor(view));\n/**\nMove the selection head one character to the right.\n*/ const selectCharRight = (view)=>selectByChar(view, ltrAtCursor(view));\n/**\nMove the selection head one character forward.\n*/ const selectCharForward = (view)=>selectByChar(view, true);\n/**\nMove the selection head one character backward.\n*/ const selectCharBackward = (view)=>selectByChar(view, false);\nfunction selectByGroup(view, forward) {\n    return extendSel(view, (range)=>view.moveByGroup(range, forward));\n}\n/**\nMove the selection head one [group](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) to\nthe left.\n*/ const selectGroupLeft = (view)=>selectByGroup(view, !ltrAtCursor(view));\n/**\nMove the selection head one group to the right.\n*/ const selectGroupRight = (view)=>selectByGroup(view, ltrAtCursor(view));\n/**\nMove the selection head one group forward.\n*/ const selectGroupForward = (view)=>selectByGroup(view, true);\n/**\nMove the selection head one group backward.\n*/ const selectGroupBackward = (view)=>selectByGroup(view, false);\nfunction selectBySubword(view, forward) {\n    return extendSel(view, (range)=>moveBySubword(view, range, forward));\n}\n/**\nMove the selection head one group or camel-case subword forward.\n*/ const selectSubwordForward = (view)=>selectBySubword(view, true);\n/**\nMove the selection head one group or subword backward.\n*/ const selectSubwordBackward = (view)=>selectBySubword(view, false);\n/**\nMove the selection head over the next syntactic element to the left.\n*/ const selectSyntaxLeft = (view)=>extendSel(view, (range)=>moveBySyntax(view.state, range, !ltrAtCursor(view)));\n/**\nMove the selection head over the next syntactic element to the right.\n*/ const selectSyntaxRight = (view)=>extendSel(view, (range)=>moveBySyntax(view.state, range, ltrAtCursor(view)));\nfunction selectByLine(view, forward) {\n    return extendSel(view, (range)=>view.moveVertically(range, forward));\n}\n/**\nMove the selection head one line up.\n*/ const selectLineUp = (view)=>selectByLine(view, false);\n/**\nMove the selection head one line down.\n*/ const selectLineDown = (view)=>selectByLine(view, true);\nfunction selectByPage(view, forward) {\n    return extendSel(view, (range)=>view.moveVertically(range, forward, pageInfo(view).height));\n}\n/**\nMove the selection head one page up.\n*/ const selectPageUp = (view)=>selectByPage(view, false);\n/**\nMove the selection head one page down.\n*/ const selectPageDown = (view)=>selectByPage(view, true);\n/**\nMove the selection head to the next line boundary.\n*/ const selectLineBoundaryForward = (view)=>extendSel(view, (range)=>moveByLineBoundary(view, range, true));\n/**\nMove the selection head to the previous line boundary.\n*/ const selectLineBoundaryBackward = (view)=>extendSel(view, (range)=>moveByLineBoundary(view, range, false));\n/**\nMove the selection head one line boundary to the left.\n*/ const selectLineBoundaryLeft = (view)=>extendSel(view, (range)=>moveByLineBoundary(view, range, !ltrAtCursor(view)));\n/**\nMove the selection head one line boundary to the right.\n*/ const selectLineBoundaryRight = (view)=>extendSel(view, (range)=>moveByLineBoundary(view, range, ltrAtCursor(view)));\n/**\nMove the selection head to the start of the line.\n*/ const selectLineStart = (view)=>extendSel(view, (range)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).from));\n/**\nMove the selection head to the end of the line.\n*/ const selectLineEnd = (view)=>extendSel(view, (range)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).to));\n/**\nMove the selection to the start of the document.\n*/ const cursorDocStart = ({ state, dispatch })=>{\n    dispatch(setSel(state, {\n        anchor: 0\n    }));\n    return true;\n};\n/**\nMove the selection to the end of the document.\n*/ const cursorDocEnd = ({ state, dispatch })=>{\n    dispatch(setSel(state, {\n        anchor: state.doc.length\n    }));\n    return true;\n};\n/**\nMove the selection head to the start of the document.\n*/ const selectDocStart = ({ state, dispatch })=>{\n    dispatch(setSel(state, {\n        anchor: state.selection.main.anchor,\n        head: 0\n    }));\n    return true;\n};\n/**\nMove the selection head to the end of the document.\n*/ const selectDocEnd = ({ state, dispatch })=>{\n    dispatch(setSel(state, {\n        anchor: state.selection.main.anchor,\n        head: state.doc.length\n    }));\n    return true;\n};\n/**\nSelect the entire document.\n*/ const selectAll = ({ state, dispatch })=>{\n    dispatch(state.update({\n        selection: {\n            anchor: 0,\n            head: state.doc.length\n        },\n        userEvent: \"select\"\n    }));\n    return true;\n};\n/**\nExpand the selection to cover entire lines.\n*/ const selectLine = ({ state, dispatch })=>{\n    let ranges = selectedLineBlocks(state).map(({ from, to })=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(from, Math.min(to + 1, state.doc.length)));\n    dispatch(state.update({\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges),\n        userEvent: \"select\"\n    }));\n    return true;\n};\n/**\nSelect the next syntactic construct that is larger than the\nselection. Note that this will only work insofar as the language\n[provider](https://codemirror.net/6/docs/ref/#language.language) you use builds up a full\nsyntax tree.\n*/ const selectParentSyntax = ({ state, dispatch })=>{\n    let selection = updateSel(state.selection, (range)=>{\n        var _a;\n        let stack = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveStack(range.from, 1);\n        for(let cur = stack; cur; cur = cur.next){\n            let { node } = cur;\n            if ((node.from < range.from && node.to >= range.to || node.to > range.to && node.from <= range.from) && ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.parent)) return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(node.to, node.from);\n        }\n        return range;\n    });\n    dispatch(setSel(state, selection));\n    return true;\n};\n/**\nSimplify the current selection. When multiple ranges are selected,\nreduce it to its main range. Otherwise, if the selection is\nnon-empty, convert it to a cursor selection.\n*/ const simplifySelection = ({ state, dispatch })=>{\n    let cur = state.selection, selection = null;\n    if (cur.ranges.length > 1) selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create([\n        cur.main\n    ]);\n    else if (!cur.main.empty) selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create([\n        _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(cur.main.head)\n    ]);\n    if (!selection) return false;\n    dispatch(setSel(state, selection));\n    return true;\n};\nfunction deleteBy(target, by) {\n    if (target.state.readOnly) return false;\n    let event = \"delete.selection\", { state } = target;\n    let changes = state.changeByRange((range)=>{\n        let { from, to } = range;\n        if (from == to) {\n            let towards = by(range);\n            if (towards < from) {\n                event = \"delete.backward\";\n                towards = skipAtomic(target, towards, false);\n            } else if (towards > from) {\n                event = \"delete.forward\";\n                towards = skipAtomic(target, towards, true);\n            }\n            from = Math.min(from, towards);\n            to = Math.max(to, towards);\n        } else {\n            from = skipAtomic(target, from, false);\n            to = skipAtomic(target, to, true);\n        }\n        return from == to ? {\n            range\n        } : {\n            changes: {\n                from,\n                to\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(from, from < range.head ? -1 : 1)\n        };\n    });\n    if (changes.changes.empty) return false;\n    target.dispatch(state.update(changes, {\n        scrollIntoView: true,\n        userEvent: event,\n        effects: event == \"delete.selection\" ? _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(state.phrase(\"Selection deleted\")) : undefined\n    }));\n    return true;\n}\nfunction skipAtomic(target, pos, forward) {\n    if (target instanceof _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView) for (let ranges of target.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.atomicRanges).map((f)=>f(target)))ranges.between(pos, pos, (from, to)=>{\n        if (from < pos && to > pos) pos = forward ? to : from;\n    });\n    return pos;\n}\nconst deleteByChar = (target, forward)=>deleteBy(target, (range)=>{\n        let pos = range.from, { state } = target, line = state.doc.lineAt(pos), before, targetPos;\n        if (!forward && pos > line.from && pos < line.from + 200 && !/[^ \\t]/.test(before = line.text.slice(0, pos - line.from))) {\n            if (before[before.length - 1] == \"\t\") return pos - 1;\n            let col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(before, state.tabSize), drop = col % (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state) || (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state);\n            for(let i = 0; i < drop && before[before.length - 1 - i] == \" \"; i++)pos--;\n            targetPos = pos;\n        } else {\n            targetPos = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, forward, forward) + line.from;\n            if (targetPos == pos && line.number != (forward ? state.doc.lines : 1)) targetPos += forward ? 1 : -1;\n            else if (!forward && /[\\ufe00-\\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from))) targetPos = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, targetPos - line.from, false, false) + line.from;\n        }\n        return targetPos;\n    });\n/**\nDelete the selection, or, for cursor selections, the character\nbefore the cursor.\n*/ const deleteCharBackward = (view)=>deleteByChar(view, false);\n/**\nDelete the selection or the character after the cursor.\n*/ const deleteCharForward = (view)=>deleteByChar(view, true);\nconst deleteByGroup = (target, forward)=>deleteBy(target, (range)=>{\n        let pos = range.head, { state } = target, line = state.doc.lineAt(pos);\n        let categorize = state.charCategorizer(pos);\n        for(let cat = null;;){\n            if (pos == (forward ? line.to : line.from)) {\n                if (pos == range.head && line.number != (forward ? state.doc.lines : 1)) pos += forward ? 1 : -1;\n                break;\n            }\n            let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, forward) + line.from;\n            let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);\n            let nextCat = categorize(nextChar);\n            if (cat != null && nextCat != cat) break;\n            if (nextChar != \" \" || pos != range.head) cat = nextCat;\n            pos = next;\n        }\n        return pos;\n    });\n/**\nDelete the selection or backward until the end of the next\n[group](https://codemirror.net/6/docs/ref/#view.EditorView.moveByGroup), only skipping groups of\nwhitespace when they consist of a single space.\n*/ const deleteGroupBackward = (target)=>deleteByGroup(target, false);\n/**\nDelete the selection or forward until the end of the next group.\n*/ const deleteGroupForward = (target)=>deleteByGroup(target, true);\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe end of the line. If the cursor is directly at the end of the\nline, delete the line break after it.\n*/ const deleteToLineEnd = (view)=>deleteBy(view, (range)=>{\n        let lineEnd = view.lineBlockAt(range.head).to;\n        return range.head < lineEnd ? lineEnd : Math.min(view.state.doc.length, range.head + 1);\n    });\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe start of the line. If the cursor is directly at the start of the\nline, delete the line break before it.\n*/ const deleteToLineStart = (view)=>deleteBy(view, (range)=>{\n        let lineStart = view.lineBlockAt(range.head).from;\n        return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);\n    });\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe start of the line or the next line wrap before the cursor.\n*/ const deleteLineBoundaryBackward = (view)=>deleteBy(view, (range)=>{\n        let lineStart = view.moveToLineBoundary(range, false).head;\n        return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);\n    });\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe end of the line or the next line wrap after the cursor.\n*/ const deleteLineBoundaryForward = (view)=>deleteBy(view, (range)=>{\n        let lineStart = view.moveToLineBoundary(range, true).head;\n        return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);\n    });\n/**\nDelete all whitespace directly before a line end from the\ndocument.\n*/ const deleteTrailingWhitespace = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    let changes = [];\n    for(let pos = 0, prev = \"\", iter = state.doc.iter();;){\n        iter.next();\n        if (iter.lineBreak || iter.done) {\n            let trailing = prev.search(/\\s+$/);\n            if (trailing > -1) changes.push({\n                from: pos - (prev.length - trailing),\n                to: pos\n            });\n            if (iter.done) break;\n            prev = \"\";\n        } else {\n            prev = iter.value;\n        }\n        pos += iter.value.length;\n    }\n    if (!changes.length) return false;\n    dispatch(state.update({\n        changes,\n        userEvent: \"delete\"\n    }));\n    return true;\n};\n/**\nReplace each selection range with a line break, leaving the cursor\non the line before the break.\n*/ const splitLine = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    let changes = state.changeByRange((range)=>{\n        return {\n            changes: {\n                from: range.from,\n                to: range.to,\n                insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of([\n                    \"\",\n                    \"\"\n                ])\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.from)\n        };\n    });\n    dispatch(state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input\"\n    }));\n    return true;\n};\n/**\nFlip the characters before and after the cursor(s).\n*/ const transposeChars = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    let changes = state.changeByRange((range)=>{\n        if (!range.empty || range.from == 0 || range.from == state.doc.length) return {\n            range\n        };\n        let pos = range.from, line = state.doc.lineAt(pos);\n        let from = pos == line.from ? pos - 1 : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, false) + line.from;\n        let to = pos == line.to ? pos + 1 : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, true) + line.from;\n        return {\n            changes: {\n                from,\n                to,\n                insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos))\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(to)\n        };\n    });\n    if (changes.changes.empty) return false;\n    dispatch(state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"move.character\"\n    }));\n    return true;\n};\nfunction selectedLineBlocks(state) {\n    let blocks = [], upto = -1;\n    for (let range of state.selection.ranges){\n        let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);\n        if (!range.empty && range.to == endLine.from) endLine = state.doc.lineAt(range.to - 1);\n        if (upto >= startLine.number) {\n            let prev = blocks[blocks.length - 1];\n            prev.to = endLine.to;\n            prev.ranges.push(range);\n        } else {\n            blocks.push({\n                from: startLine.from,\n                to: endLine.to,\n                ranges: [\n                    range\n                ]\n            });\n        }\n        upto = endLine.number + 1;\n    }\n    return blocks;\n}\nfunction moveLine(state, dispatch, forward) {\n    if (state.readOnly) return false;\n    let changes = [], ranges = [];\n    for (let block of selectedLineBlocks(state)){\n        if (forward ? block.to == state.doc.length : block.from == 0) continue;\n        let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);\n        let size = nextLine.length + 1;\n        if (forward) {\n            changes.push({\n                from: block.to,\n                to: nextLine.to\n            }, {\n                from: block.from,\n                insert: nextLine.text + state.lineBreak\n            });\n            for (let r of block.ranges)ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));\n        } else {\n            changes.push({\n                from: nextLine.from,\n                to: block.from\n            }, {\n                from: block.to,\n                insert: state.lineBreak + nextLine.text\n            });\n            for (let r of block.ranges)ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.anchor - size, r.head - size));\n        }\n    }\n    if (!changes.length) return false;\n    dispatch(state.update({\n        changes,\n        scrollIntoView: true,\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges, state.selection.mainIndex),\n        userEvent: \"move.line\"\n    }));\n    return true;\n}\n/**\nMove the selected lines up one line.\n*/ const moveLineUp = ({ state, dispatch })=>moveLine(state, dispatch, false);\n/**\nMove the selected lines down one line.\n*/ const moveLineDown = ({ state, dispatch })=>moveLine(state, dispatch, true);\nfunction copyLine(state, dispatch, forward) {\n    if (state.readOnly) return false;\n    let changes = [];\n    for (let block of selectedLineBlocks(state)){\n        if (forward) changes.push({\n            from: block.from,\n            insert: state.doc.slice(block.from, block.to) + state.lineBreak\n        });\n        else changes.push({\n            from: block.to,\n            insert: state.lineBreak + state.doc.slice(block.from, block.to)\n        });\n    }\n    dispatch(state.update({\n        changes,\n        scrollIntoView: true,\n        userEvent: \"input.copyline\"\n    }));\n    return true;\n}\n/**\nCreate a copy of the selected lines. Keep the selection in the top copy.\n*/ const copyLineUp = ({ state, dispatch })=>copyLine(state, dispatch, false);\n/**\nCreate a copy of the selected lines. Keep the selection in the bottom copy.\n*/ const copyLineDown = ({ state, dispatch })=>copyLine(state, dispatch, true);\n/**\nDelete selected lines.\n*/ const deleteLine = (view)=>{\n    if (view.state.readOnly) return false;\n    let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to })=>{\n        if (from > 0) from--;\n        else if (to < state.doc.length) to++;\n        return {\n            from,\n            to\n        };\n    }));\n    let selection = updateSel(state.selection, (range)=>view.moveVertically(range, true)).map(changes);\n    view.dispatch({\n        changes,\n        selection,\n        scrollIntoView: true,\n        userEvent: \"delete.line\"\n    });\n    return true;\n};\n/**\nReplace the selection with a newline.\n*/ const insertNewline = ({ state, dispatch })=>{\n    dispatch(state.update(state.replaceSelection(state.lineBreak), {\n        scrollIntoView: true,\n        userEvent: \"input\"\n    }));\n    return true;\n};\nfunction isBetweenBrackets(state, pos) {\n    if (/\\(\\)|\\[\\]|\\{\\}/.test(state.sliceDoc(pos - 1, pos + 1))) return {\n        from: pos,\n        to: pos\n    };\n    let context = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(pos);\n    let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;\n    if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from && !/\\S/.test(state.sliceDoc(before.to, after.from))) return {\n        from: before.to,\n        to: after.from\n    };\n    return null;\n}\n/**\nReplace the selection with a newline and indent the newly created\nline(s). If the current line consists only of whitespace, this\nwill also delete that whitespace. When the cursor is between\nmatching brackets, an additional newline will be inserted after\nthe cursor.\n*/ const insertNewlineAndIndent = /*@__PURE__*/ newlineAndIndent(false);\n/**\nCreate a blank, indented line below the current line.\n*/ const insertBlankLine = /*@__PURE__*/ newlineAndIndent(true);\nfunction newlineAndIndent(atEof) {\n    return ({ state, dispatch })=>{\n        if (state.readOnly) return false;\n        let changes = state.changeByRange((range)=>{\n            let { from, to } = range, line = state.doc.lineAt(from);\n            let explode = !atEof && from == to && isBetweenBrackets(state, from);\n            if (atEof) from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;\n            let cx = new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.IndentContext(state, {\n                simulateBreak: from,\n                simulateDoubleBreak: !!explode\n            });\n            let indent = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentation)(cx, from);\n            if (indent == null) indent = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(/^\\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);\n            while(to < line.to && /\\s/.test(line.text[to - line.from]))to++;\n            if (explode) ({ from, to } = explode);\n            else if (from > line.from && from < line.from + 100 && !/\\S/.test(line.text.slice(0, from))) from = line.from;\n            let insert = [\n                \"\",\n                (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, indent)\n            ];\n            if (explode) insert.push((0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, cx.lineIndent(line.from, -1)));\n            return {\n                changes: {\n                    from,\n                    to,\n                    insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of(insert)\n                },\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(from + 1 + insert[1].length)\n            };\n        });\n        dispatch(state.update(changes, {\n            scrollIntoView: true,\n            userEvent: \"input\"\n        }));\n        return true;\n    };\n}\nfunction changeBySelectedLine(state, f) {\n    let atLine = -1;\n    return state.changeByRange((range)=>{\n        let changes = [];\n        for(let pos = range.from; pos <= range.to;){\n            let line = state.doc.lineAt(pos);\n            if (line.number > atLine && (range.empty || range.to > line.from)) {\n                f(line, changes, range);\n                atLine = line.number;\n            }\n            pos = line.to + 1;\n        }\n        let changeSet = state.changes(changes);\n        return {\n            changes,\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))\n        };\n    });\n}\n/**\nAuto-indent the selected lines. This uses the [indentation service\nfacet](https://codemirror.net/6/docs/ref/#language.indentService) as source for auto-indent\ninformation.\n*/ const indentSelection = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    let updated = Object.create(null);\n    let context = new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.IndentContext(state, {\n        overrideIndentation: (start)=>{\n            let found = updated[start];\n            return found == null ? -1 : found;\n        }\n    });\n    let changes = changeBySelectedLine(state, (line, changes, range)=>{\n        let indent = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentation)(context, line.from);\n        if (indent == null) return;\n        if (!/\\S/.test(line.text)) indent = 0;\n        let cur = /^\\s*/.exec(line.text)[0];\n        let norm = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, indent);\n        if (cur != norm || range.from < line.from + cur.length) {\n            updated[line.from] = indent;\n            changes.push({\n                from: line.from,\n                to: line.from + cur.length,\n                insert: norm\n            });\n        }\n    });\n    if (!changes.changes.empty) dispatch(state.update(changes, {\n        userEvent: \"indent\"\n    }));\n    return true;\n};\n/**\nAdd a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation to all selected\nlines.\n*/ const indentMore = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    dispatch(state.update(changeBySelectedLine(state, (line, changes)=>{\n        changes.push({\n            from: line.from,\n            insert: state.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentUnit)\n        });\n    }), {\n        userEvent: \"input.indent\"\n    }));\n    return true;\n};\n/**\nRemove a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation from all\nselected lines.\n*/ const indentLess = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    dispatch(state.update(changeBySelectedLine(state, (line, changes)=>{\n        let space = /^\\s*/.exec(line.text)[0];\n        if (!space) return;\n        let col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(space, state.tabSize), keep = 0;\n        let insert = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, Math.max(0, col - (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state)));\n        while(keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep))keep++;\n        changes.push({\n            from: line.from + keep,\n            to: line.from + space.length,\n            insert: insert.slice(keep)\n        });\n    }), {\n        userEvent: \"delete.dedent\"\n    }));\n    return true;\n};\n/**\nInsert a tab character at the cursor or, if something is selected,\nuse [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) to indent the entire\nselection.\n*/ const insertTab = ({ state, dispatch })=>{\n    if (state.selection.ranges.some((r)=>!r.empty)) return indentMore({\n        state,\n        dispatch\n    });\n    dispatch(state.update(state.replaceSelection(\"\t\"), {\n        scrollIntoView: true,\n        userEvent: \"input\"\n    }));\n    return true;\n};\n/**\nArray of key bindings containing the Emacs-style bindings that are\navailable on macOS by default.\n\n - Ctrl-b: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - Ctrl-f: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-p: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - Ctrl-n: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Ctrl-a: [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Ctrl-e: [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - Ctrl-d: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-h: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Ctrl-k: [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd)\n - Ctrl-Alt-h: [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-o: [`splitLine`](https://codemirror.net/6/docs/ref/#commands.splitLine)\n - Ctrl-t: [`transposeChars`](https://codemirror.net/6/docs/ref/#commands.transposeChars)\n - Ctrl-v: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown)\n - Alt-v: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp)\n*/ const emacsStyleKeymap = [\n    {\n        key: \"Ctrl-b\",\n        run: cursorCharLeft,\n        shift: selectCharLeft,\n        preventDefault: true\n    },\n    {\n        key: \"Ctrl-f\",\n        run: cursorCharRight,\n        shift: selectCharRight\n    },\n    {\n        key: \"Ctrl-p\",\n        run: cursorLineUp,\n        shift: selectLineUp\n    },\n    {\n        key: \"Ctrl-n\",\n        run: cursorLineDown,\n        shift: selectLineDown\n    },\n    {\n        key: \"Ctrl-a\",\n        run: cursorLineStart,\n        shift: selectLineStart\n    },\n    {\n        key: \"Ctrl-e\",\n        run: cursorLineEnd,\n        shift: selectLineEnd\n    },\n    {\n        key: \"Ctrl-d\",\n        run: deleteCharForward\n    },\n    {\n        key: \"Ctrl-h\",\n        run: deleteCharBackward\n    },\n    {\n        key: \"Ctrl-k\",\n        run: deleteToLineEnd\n    },\n    {\n        key: \"Ctrl-Alt-h\",\n        run: deleteGroupBackward\n    },\n    {\n        key: \"Ctrl-o\",\n        run: splitLine\n    },\n    {\n        key: \"Ctrl-t\",\n        run: transposeChars\n    },\n    {\n        key: \"Ctrl-v\",\n        run: cursorPageDown\n    }\n];\n/**\nAn array of key bindings closely sticking to platform-standard or\nwidely used bindings. (This includes the bindings from\n[`emacsStyleKeymap`](https://codemirror.net/6/docs/ref/#commands.emacsStyleKeymap), with their `key`\nproperty changed to `mac`.)\n\n - ArrowLeft: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - ArrowRight: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-ArrowLeft (Alt-ArrowLeft on macOS): [`cursorGroupLeft`](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) ([`selectGroupLeft`](https://codemirror.net/6/docs/ref/#commands.selectGroupLeft) with Shift)\n - Ctrl-ArrowRight (Alt-ArrowRight on macOS): [`cursorGroupRight`](https://codemirror.net/6/docs/ref/#commands.cursorGroupRight) ([`selectGroupRight`](https://codemirror.net/6/docs/ref/#commands.selectGroupRight) with Shift)\n - Cmd-ArrowLeft (on macOS): [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Cmd-ArrowRight (on macOS): [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - ArrowUp: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - ArrowDown: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Cmd-ArrowUp (on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Cmd-ArrowDown (on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Ctrl-ArrowUp (on macOS): [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - Ctrl-ArrowDown (on macOS): [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - PageUp: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - PageDown: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - Home: [`cursorLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryBackward) ([`selectLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryBackward) with Shift)\n - End: [`cursorLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryForward) ([`selectLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryForward) with Shift)\n - Ctrl-Home (Cmd-Home on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Ctrl-End (Cmd-Home on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Enter: [`insertNewlineAndIndent`](https://codemirror.net/6/docs/ref/#commands.insertNewlineAndIndent)\n - Ctrl-a (Cmd-a on macOS): [`selectAll`](https://codemirror.net/6/docs/ref/#commands.selectAll)\n - Backspace: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Delete: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-Backspace (Alt-Backspace on macOS): [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-Delete (Alt-Delete on macOS): [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)\n - Cmd-Backspace (macOS): [`deleteLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryBackward).\n - Cmd-Delete (macOS): [`deleteLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryForward).\n*/ const standardKeymap = /*@__PURE__*/ [\n    {\n        key: \"ArrowLeft\",\n        run: cursorCharLeft,\n        shift: selectCharLeft,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-ArrowLeft\",\n        mac: \"Alt-ArrowLeft\",\n        run: cursorGroupLeft,\n        shift: selectGroupLeft,\n        preventDefault: true\n    },\n    {\n        mac: \"Cmd-ArrowLeft\",\n        run: cursorLineBoundaryLeft,\n        shift: selectLineBoundaryLeft,\n        preventDefault: true\n    },\n    {\n        key: \"ArrowRight\",\n        run: cursorCharRight,\n        shift: selectCharRight,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-ArrowRight\",\n        mac: \"Alt-ArrowRight\",\n        run: cursorGroupRight,\n        shift: selectGroupRight,\n        preventDefault: true\n    },\n    {\n        mac: \"Cmd-ArrowRight\",\n        run: cursorLineBoundaryRight,\n        shift: selectLineBoundaryRight,\n        preventDefault: true\n    },\n    {\n        key: \"ArrowUp\",\n        run: cursorLineUp,\n        shift: selectLineUp,\n        preventDefault: true\n    },\n    {\n        mac: \"Cmd-ArrowUp\",\n        run: cursorDocStart,\n        shift: selectDocStart\n    },\n    {\n        mac: \"Ctrl-ArrowUp\",\n        run: cursorPageUp,\n        shift: selectPageUp\n    },\n    {\n        key: \"ArrowDown\",\n        run: cursorLineDown,\n        shift: selectLineDown,\n        preventDefault: true\n    },\n    {\n        mac: \"Cmd-ArrowDown\",\n        run: cursorDocEnd,\n        shift: selectDocEnd\n    },\n    {\n        mac: \"Ctrl-ArrowDown\",\n        run: cursorPageDown,\n        shift: selectPageDown\n    },\n    {\n        key: \"PageUp\",\n        run: cursorPageUp,\n        shift: selectPageUp\n    },\n    {\n        key: \"PageDown\",\n        run: cursorPageDown,\n        shift: selectPageDown\n    },\n    {\n        key: \"Home\",\n        run: cursorLineBoundaryBackward,\n        shift: selectLineBoundaryBackward,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-Home\",\n        run: cursorDocStart,\n        shift: selectDocStart\n    },\n    {\n        key: \"End\",\n        run: cursorLineBoundaryForward,\n        shift: selectLineBoundaryForward,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-End\",\n        run: cursorDocEnd,\n        shift: selectDocEnd\n    },\n    {\n        key: \"Enter\",\n        run: insertNewlineAndIndent\n    },\n    {\n        key: \"Mod-a\",\n        run: selectAll\n    },\n    {\n        key: \"Backspace\",\n        run: deleteCharBackward,\n        shift: deleteCharBackward\n    },\n    {\n        key: \"Delete\",\n        run: deleteCharForward\n    },\n    {\n        key: \"Mod-Backspace\",\n        mac: \"Alt-Backspace\",\n        run: deleteGroupBackward\n    },\n    {\n        key: \"Mod-Delete\",\n        mac: \"Alt-Delete\",\n        run: deleteGroupForward\n    },\n    {\n        mac: \"Mod-Backspace\",\n        run: deleteLineBoundaryBackward\n    },\n    {\n        mac: \"Mod-Delete\",\n        run: deleteLineBoundaryForward\n    }\n].concat(/*@__PURE__*/ emacsStyleKeymap.map((b)=>({\n        mac: b.key,\n        run: b.run,\n        shift: b.shift\n    })));\n/**\nThe default keymap. Includes all bindings from\n[`standardKeymap`](https://codemirror.net/6/docs/ref/#commands.standardKeymap) plus the following:\n\n- Alt-ArrowLeft (Ctrl-ArrowLeft on macOS): [`cursorSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxLeft) ([`selectSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxLeft) with Shift)\n- Alt-ArrowRight (Ctrl-ArrowRight on macOS): [`cursorSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxRight) ([`selectSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxRight) with Shift)\n- Alt-ArrowUp: [`moveLineUp`](https://codemirror.net/6/docs/ref/#commands.moveLineUp)\n- Alt-ArrowDown: [`moveLineDown`](https://codemirror.net/6/docs/ref/#commands.moveLineDown)\n- Shift-Alt-ArrowUp: [`copyLineUp`](https://codemirror.net/6/docs/ref/#commands.copyLineUp)\n- Shift-Alt-ArrowDown: [`copyLineDown`](https://codemirror.net/6/docs/ref/#commands.copyLineDown)\n- Escape: [`simplifySelection`](https://codemirror.net/6/docs/ref/#commands.simplifySelection)\n- Ctrl-Enter (Cmd-Enter on macOS): [`insertBlankLine`](https://codemirror.net/6/docs/ref/#commands.insertBlankLine)\n- Alt-l (Ctrl-l on macOS): [`selectLine`](https://codemirror.net/6/docs/ref/#commands.selectLine)\n- Ctrl-i (Cmd-i on macOS): [`selectParentSyntax`](https://codemirror.net/6/docs/ref/#commands.selectParentSyntax)\n- Ctrl-[ (Cmd-[ on macOS): [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess)\n- Ctrl-] (Cmd-] on macOS): [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore)\n- Ctrl-Alt-\\\\ (Cmd-Alt-\\\\ on macOS): [`indentSelection`](https://codemirror.net/6/docs/ref/#commands.indentSelection)\n- Shift-Ctrl-k (Shift-Cmd-k on macOS): [`deleteLine`](https://codemirror.net/6/docs/ref/#commands.deleteLine)\n- Shift-Ctrl-\\\\ (Shift-Cmd-\\\\ on macOS): [`cursorMatchingBracket`](https://codemirror.net/6/docs/ref/#commands.cursorMatchingBracket)\n- Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](https://codemirror.net/6/docs/ref/#commands.toggleComment).\n- Shift-Alt-a: [`toggleBlockComment`](https://codemirror.net/6/docs/ref/#commands.toggleBlockComment).\n*/ const defaultKeymap = /*@__PURE__*/ [\n    {\n        key: \"Alt-ArrowLeft\",\n        mac: \"Ctrl-ArrowLeft\",\n        run: cursorSyntaxLeft,\n        shift: selectSyntaxLeft\n    },\n    {\n        key: \"Alt-ArrowRight\",\n        mac: \"Ctrl-ArrowRight\",\n        run: cursorSyntaxRight,\n        shift: selectSyntaxRight\n    },\n    {\n        key: \"Alt-ArrowUp\",\n        run: moveLineUp\n    },\n    {\n        key: \"Shift-Alt-ArrowUp\",\n        run: copyLineUp\n    },\n    {\n        key: \"Alt-ArrowDown\",\n        run: moveLineDown\n    },\n    {\n        key: \"Shift-Alt-ArrowDown\",\n        run: copyLineDown\n    },\n    {\n        key: \"Escape\",\n        run: simplifySelection\n    },\n    {\n        key: \"Mod-Enter\",\n        run: insertBlankLine\n    },\n    {\n        key: \"Alt-l\",\n        mac: \"Ctrl-l\",\n        run: selectLine\n    },\n    {\n        key: \"Mod-i\",\n        run: selectParentSyntax,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-[\",\n        run: indentLess\n    },\n    {\n        key: \"Mod-]\",\n        run: indentMore\n    },\n    {\n        key: \"Mod-Alt-\\\\\",\n        run: indentSelection\n    },\n    {\n        key: \"Shift-Mod-k\",\n        run: deleteLine\n    },\n    {\n        key: \"Shift-Mod-\\\\\",\n        run: cursorMatchingBracket\n    },\n    {\n        key: \"Mod-/\",\n        run: toggleComment\n    },\n    {\n        key: \"Alt-A\",\n        run: toggleBlockComment\n    }\n].concat(standardKeymap);\n/**\nA binding that binds Tab to [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) and\nShift-Tab to [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess).\nPlease see the [Tab example](../../examples/tab/) before using\nthis.\n*/ const indentWithTab = {\n    key: \"Tab\",\n    run: indentMore,\n    shift: indentLess\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvY29tbWFuZHMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzTTtBQUM3STtBQUNnRjtBQUNoRztBQUV6Qzs7O0FBR0EsR0FDQSxNQUFNdUIsZ0JBQWdCQyxDQUFBQTtJQUNsQixJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHRCxRQUFRRSxPQUFPRCxNQUFNRSxHQUFHLENBQUNDLE1BQU0sQ0FBQ0gsTUFBTUksU0FBUyxDQUFDQyxJQUFJLENBQUNDLElBQUksR0FBR0MsU0FBU0MsVUFBVVQsT0FBT0MsS0FBSyxFQUFFQyxLQUFLSyxJQUFJO0lBQ3RILE9BQU9DLE9BQU9OLElBQUksR0FBR1Esa0JBQWtCVixVQUFVUSxPQUFPRyxLQUFLLEdBQUdDLHlCQUF5QlosVUFBVTtBQUN2RztBQUNBLFNBQVNhLFFBQVFDLENBQUMsRUFBRUMsTUFBTTtJQUN0QixPQUFPLENBQUMsRUFBRWQsS0FBSyxFQUFFZSxRQUFRLEVBQUU7UUFDdkIsSUFBSWYsTUFBTWdCLFFBQVEsRUFDZCxPQUFPO1FBQ1gsSUFBSUMsS0FBS0osRUFBRUMsUUFBUWQ7UUFDbkIsSUFBSSxDQUFDaUIsSUFDRCxPQUFPO1FBQ1hGLFNBQVNmLE1BQU1rQixNQUFNLENBQUNEO1FBQ3RCLE9BQU87SUFDWDtBQUNKO0FBQ0E7Ozs7O0FBS0EsR0FDQSxNQUFNUixvQkFBb0IsV0FBVyxHQUFFRyxRQUFRTyxtQkFBbUIsRUFBRSx3QkFBd0I7QUFDNUY7O0FBRUEsR0FDQSxNQUFNQyxjQUFjLFdBQVcsR0FBRVIsUUFBUU8sbUJBQW1CLEVBQUUseUJBQXlCO0FBQ3ZGOztBQUVBLEdBQ0EsTUFBTUUsZ0JBQWdCLFdBQVcsR0FBRVQsUUFBUU8sbUJBQW1CLEVBQUUs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QUNnUztBQUNUOzs7OztBQUtBLEdBQ0EsTUFBTUUsZ0JBQWdCO0lBQUU5UCxLQUFLO0lBQU9DLEtBQUtxUDtJQUFZSyxPQUFPSjtBQUFXO0FBRTRwRCIsInNvdXJjZXMiOlsid2VicGFjazovL21iYy8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9jb21tYW5kcy9kaXN0L2luZGV4LmpzP2JmMmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQW5ub3RhdGlvbiwgRmFjZXQsIGNvbWJpbmVDb25maWcsIFN0YXRlRmllbGQsIFRyYW5zYWN0aW9uLCBDaGFuZ2VTZXQsIENoYW5nZURlc2MsIEVkaXRvclNlbGVjdGlvbiwgU3RhdGVFZmZlY3QsIFRleHQsIGZpbmRDbHVzdGVyQnJlYWssIGNvdW50Q29sdW1uLCBDaGFyQ2F0ZWdvcnkgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgeyBFZGl0b3JWaWV3LCBEaXJlY3Rpb24gfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IEluZGVudENvbnRleHQsIGdldEluZGVudGF0aW9uLCBpbmRlbnRTdHJpbmcsIG1hdGNoQnJhY2tldHMsIHN5bnRheFRyZWUsIGdldEluZGVudFVuaXQsIGluZGVudFVuaXQgfSBmcm9tICdAY29kZW1pcnJvci9sYW5ndWFnZSc7XG5pbXBvcnQgeyBOb2RlUHJvcCB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuXG4vKipcbkNvbW1lbnQgb3IgdW5jb21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbi4gV2lsbCB1c2UgbGluZSBjb21tZW50c1xuaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgZmFsbGluZyBiYWNrIHRvIGJsb2NrIGNvbW1lbnRzLlxuKi9cbmNvbnN0IHRvZ2dsZUNvbW1lbnQgPSB0YXJnZXQgPT4ge1xuICAgIGxldCB7IHN0YXRlIH0gPSB0YXJnZXQsIGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHN0YXRlLnNlbGVjdGlvbi5tYWluLmZyb20pLCBjb25maWcgPSBnZXRDb25maWcodGFyZ2V0LnN0YXRlLCBsaW5lLmZyb20pO1xuICAgIHJldHVybiBjb25maWcubGluZSA/IHRvZ2dsZUxpbmVDb21tZW50KHRhcmdldCkgOiBjb25maWcuYmxvY2sgPyB0b2dnbGVCbG9ja0NvbW1lbnRCeUxpbmUodGFyZ2V0KSA6IGZhbHNlO1xufTtcbmZ1bmN0aW9uIGNvbW1hbmQoZiwgb3B0aW9uKSB7XG4gICAgcmV0dXJuICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHRyID0gZihvcHRpb24sIHN0YXRlKTtcbiAgICAgICAgaWYgKCF0cilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHRyKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbkNvbW1lbnQgb3IgdW5jb21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZyBsaW5lIGNvbW1lbnRzLlxuVGhlIGxpbmUgY29tbWVudCBzeW50YXggaXMgdGFrZW4gZnJvbSB0aGVcbltgY29tbWVudFRva2Vuc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuQ29tbWVudFRva2VucykgW2xhbmd1YWdlXG5kYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KS5cbiovXG5jb25zdCB0b2dnbGVMaW5lQ29tbWVudCA9IC8qQF9fUFVSRV9fKi9jb21tYW5kKGNoYW5nZUxpbmVDb21tZW50LCAwIC8qIENvbW1lbnRPcHRpb24uVG9nZ2xlICovKTtcbi8qKlxuQ29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgbGluZSBjb21tZW50cy5cbiovXG5jb25zdCBsaW5lQ29tbWVudCA9IC8qQF9fUFVSRV9fKi9jb21tYW5kKGNoYW5nZUxpbmVDb21tZW50LCAxIC8qIENvbW1lbnRPcHRpb24uQ29tbWVudCAqLyk7XG4vKipcblVuY29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgbGluZSBjb21tZW50cy5cbiovXG5jb25zdCBsaW5lVW5jb21tZW50ID0gLypAX19QVVJFX18qL2NvbW1hbmQoY2hhbmdlTGluZUNvbW1lbnQsIDIgLyogQ29tbWVudE9wdGlvbi5VbmNvbW1lbnQgKi8pO1xuLyoqXG5Db21tZW50IG9yIHVuY29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgYmxvY2sgY29tbWVudHMuXG5UaGUgYmxvY2sgY29tbWVudCBzeW50YXggaXMgdGFrZW4gZnJvbSB0aGVcbltgY29tbWVudFRva2Vuc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuQ29tbWVudFRva2VucykgW2xhbmd1YWdlXG5kYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KS5cbiovXG5jb25zdCB0b2dnbGVCbG9ja0NvbW1lbnQgPSAvKkBfX1BVUkVfXyovY29tbWFuZChjaGFuZ2VCbG9ja0NvbW1lbnQsIDAgLyogQ29tbWVudE9wdGlvbi5Ub2dnbGUgKi8pO1xuLyoqXG5Db21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZyBibG9jayBjb21tZW50cy5cbiovXG5jb25zdCBibG9ja0NvbW1lbnQgPSAvKkBfX1BVUkVfXyovY29tbWFuZChjaGFuZ2VCbG9ja0NvbW1lbnQsIDEgLyogQ29tbWVudE9wdGlvbi5Db21tZW50ICovKTtcbi8qKlxuVW5jb21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZyBibG9jayBjb21tZW50cy5cbiovXG5jb25zdCBibG9ja1VuY29tbWVudCA9IC8qQF9fUFVSRV9fKi9jb21tYW5kKGNoYW5nZUJsb2NrQ29tbWVudCwgMiAvKiBDb21tZW50T3B0aW9uLlVuY29tbWVudCAqLyk7XG4vKipcbkNvbW1lbnQgb3IgdW5jb21tZW50IHRoZSBsaW5lcyBhcm91bmQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nXG5ibG9jayBjb21tZW50cy5cbiovXG5jb25zdCB0b2dnbGVCbG9ja0NvbW1lbnRCeUxpbmUgPSAvKkBfX1BVUkVfXyovY29tbWFuZCgobywgcykgPT4gY2hhbmdlQmxvY2tDb21tZW50KG8sIHMsIHNlbGVjdGVkTGluZVJhbmdlcyhzKSksIDAgLyogQ29tbWVudE9wdGlvbi5Ub2dnbGUgKi8pO1xuZnVuY3Rpb24gZ2V0Q29uZmlnKHN0YXRlLCBwb3MpIHtcbiAgICBsZXQgZGF0YSA9IHN0YXRlLmxhbmd1YWdlRGF0YUF0KFwiY29tbWVudFRva2Vuc1wiLCBwb3MpO1xuICAgIHJldHVybiBkYXRhLmxlbmd0aCA/IGRhdGFbMF0gOiB7fTtcbn1cbmNvbnN0IFNlYXJjaE1hcmdpbiA9IDUwO1xuLyoqXG5EZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiByYW5nZSBpcyBibG9jay1jb21tZW50ZWQgaW4gdGhlIGdpdmVuXG5zdGF0ZS5cbiovXG5mdW5jdGlvbiBmaW5kQmxvY2tDb21tZW50KHN0YXRlLCB7IG9wZW4sIGNsb3NlIH0sIGZyb20sIHRvKSB7XG4gICAgbGV0IHRleHRCZWZvcmUgPSBzdGF0ZS5zbGljZURvYyhmcm9tIC0gU2VhcmNoTWFyZ2luLCBmcm9tKTtcbiAgICBsZXQgdGV4dEFmdGVyID0gc3RhdGUuc2xpY2VEb2ModG8sIHRvICsgU2VhcmNoTWFyZ2luKTtcbiAgICBsZXQgc3BhY2VCZWZvcmUgPSAvXFxzKiQvLmV4ZWModGV4dEJlZm9yZSlbMF0ubGVuZ3RoLCBzcGFjZUFmdGVyID0gL15cXHMqLy5leGVjKHRleHRBZnRlcilbMF0ubGVuZ3RoO1xuICAgIGxldCBiZWZvcmVPZmYgPSB0ZXh0QmVmb3JlLmxlbmd0aCAtIHNwYWNlQmVmb3JlO1xuICAgIGlmICh0ZXh0QmVmb3JlLnNsaWNlKGJlZm9yZU9mZiAtIG9wZW4ubGVuZ3RoLCBiZWZvcmVPZmYpID09IG9wZW4gJiZcbiAgICAgICAgdGV4dEFmdGVyLnNsaWNlKHNwYWNlQWZ0ZXIsIHNwYWNlQWZ0ZXIgKyBjbG9zZS5sZW5ndGgpID09IGNsb3NlKSB7XG4gICAgICAgIHJldHVybiB7IG9wZW46IHsgcG9zOiBmcm9tIC0gc3BhY2VCZWZvcmUsIG1hcmdpbjogc3BhY2VCZWZvcmUgJiYgMSB9LFxuICAgICAgICAgICAgY2xvc2U6IHsgcG9zOiB0byArIHNwYWNlQWZ0ZXIsIG1hcmdpbjogc3BhY2VBZnRlciAmJiAxIH0gfTtcbiAgICB9XG4gICAgbGV0IHN0YXJ0VGV4dCwgZW5kVGV4dDtcbiAgICBpZiAodG8gLSBmcm9tIDw9IDIgKiBTZWFyY2hNYXJnaW4pIHtcbiAgICAgICAgc3RhcnRUZXh0ID0gZW5kVGV4dCA9IHN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0YXJ0VGV4dCA9IHN0YXRlLnNsaWNlRG9jKGZyb20sIGZyb20gKyBTZWFyY2hNYXJnaW4pO1xuICAgICAgICBlbmRUZXh0ID0gc3RhdGUuc2xpY2VEb2ModG8gLSBTZWFyY2hNYXJnaW4sIHRvKTtcbiAgICB9XG4gICAgbGV0IHN0YXJ0U3BhY2UgPSAvXlxccyovLmV4ZWMoc3RhcnRUZXh0KVswXS5sZW5ndGgsIGVuZFNwYWNlID0gL1xccyokLy5leGVjKGVuZFRleHQpWzBdLmxlbmd0aDtcbiAgICBsZXQgZW5kT2ZmID0gZW5kVGV4dC5sZW5ndGggLSBlbmRTcGFjZSAtIGNsb3NlLmxlbmd0aDtcbiAgICBpZiAoc3RhcnRUZXh0LnNsaWNlKHN0YXJ0U3BhY2UsIHN0YXJ0U3BhY2UgKyBvcGVuLmxlbmd0aCkgPT0gb3BlbiAmJlxuICAgICAgICBlbmRUZXh0LnNsaWNlKGVuZE9mZiwgZW5kT2ZmICsgY2xvc2UubGVuZ3RoKSA9PSBjbG9zZSkge1xuICAgICAgICByZXR1cm4geyBvcGVuOiB7IHBvczogZnJvbSArIHN0YXJ0U3BhY2UgKyBvcGVuLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBtYXJnaW46IC9cXHMvLnRlc3Qoc3RhcnRUZXh0LmNoYXJBdChzdGFydFNwYWNlICsgb3Blbi5sZW5ndGgpKSA/IDEgOiAwIH0sXG4gICAgICAgICAgICBjbG9zZTogeyBwb3M6IHRvIC0gZW5kU3BhY2UgLSBjbG9zZS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAvXFxzLy50ZXN0KGVuZFRleHQuY2hhckF0KGVuZE9mZiAtIDEpKSA/IDEgOiAwIH0gfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzZWxlY3RlZExpbmVSYW5nZXMoc3RhdGUpIHtcbiAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgZm9yIChsZXQgciBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgIGxldCBmcm9tTGluZSA9IHN0YXRlLmRvYy5saW5lQXQoci5mcm9tKTtcbiAgICAgICAgbGV0IHRvTGluZSA9IHIudG8gPD0gZnJvbUxpbmUudG8gPyBmcm9tTGluZSA6IHN0YXRlLmRvYy5saW5lQXQoci50byk7XG4gICAgICAgIGxldCBsYXN0ID0gcmFuZ2VzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChsYXN0ID49IDAgJiYgcmFuZ2VzW2xhc3RdLnRvID4gZnJvbUxpbmUuZnJvbSlcbiAgICAgICAgICAgIHJhbmdlc1tsYXN0XS50byA9IHRvTGluZS50bztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tOiBmcm9tTGluZS5mcm9tICsgL15cXHMqLy5leGVjKGZyb21MaW5lLnRleHQpWzBdLmxlbmd0aCwgdG86IHRvTGluZS50byB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlcztcbn1cbi8vIFBlcmZvcm1zIHRvZ2dsZSwgY29tbWVudCBhbmQgdW5jb21tZW50IG9mIGJsb2NrIGNvbW1lbnRzIGluXG4vLyBsYW5ndWFnZXMgdGhhdCBzdXBwb3J0IHRoZW0uXG5mdW5jdGlvbiBjaGFuZ2VCbG9ja0NvbW1lbnQob3B0aW9uLCBzdGF0ZSwgcmFuZ2VzID0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgIGxldCB0b2tlbnMgPSByYW5nZXMubWFwKHIgPT4gZ2V0Q29uZmlnKHN0YXRlLCByLmZyb20pLmJsb2NrKTtcbiAgICBpZiAoIXRva2Vucy5ldmVyeShjID0+IGMpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgY29tbWVudHMgPSByYW5nZXMubWFwKChyLCBpKSA9PiBmaW5kQmxvY2tDb21tZW50KHN0YXRlLCB0b2tlbnNbaV0sIHIuZnJvbSwgci50bykpO1xuICAgIGlmIChvcHRpb24gIT0gMiAvKiBDb21tZW50T3B0aW9uLlVuY29tbWVudCAqLyAmJiAhY29tbWVudHMuZXZlcnkoYyA9PiBjKSkge1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBzdGF0ZS5jaGFuZ2VzKHJhbmdlcy5tYXAoKHJhbmdlLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1lbnRzW2ldKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt7IGZyb206IHJhbmdlLmZyb20sIGluc2VydDogdG9rZW5zW2ldLm9wZW4gKyBcIiBcIiB9LCB7IGZyb206IHJhbmdlLnRvLCBpbnNlcnQ6IFwiIFwiICsgdG9rZW5zW2ldLmNsb3NlIH1dO1xuICAgICAgICAgICAgfSkpIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbiAhPSAxIC8qIENvbW1lbnRPcHRpb24uQ29tbWVudCAqLyAmJiBjb21tZW50cy5zb21lKGMgPT4gYykpIHtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGNvbW1lbnQ7IGkgPCBjb21tZW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChjb21tZW50ID0gY29tbWVudHNbaV0pIHtcbiAgICAgICAgICAgICAgICBsZXQgdG9rZW4gPSB0b2tlbnNbaV0sIHsgb3BlbiwgY2xvc2UgfSA9IGNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogb3Blbi5wb3MgLSB0b2tlbi5vcGVuLmxlbmd0aCwgdG86IG9wZW4ucG9zICsgb3Blbi5tYXJnaW4gfSwgeyBmcm9tOiBjbG9zZS5wb3MgLSBjbG9zZS5tYXJnaW4sIHRvOiBjbG9zZS5wb3MgKyB0b2tlbi5jbG9zZS5sZW5ndGggfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXMgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vLyBQZXJmb3JtcyB0b2dnbGUsIGNvbW1lbnQgYW5kIHVuY29tbWVudCBvZiBsaW5lIGNvbW1lbnRzLlxuZnVuY3Rpb24gY2hhbmdlTGluZUNvbW1lbnQob3B0aW9uLCBzdGF0ZSwgcmFuZ2VzID0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGxldCBwcmV2TGluZSA9IC0xO1xuICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiByYW5nZXMpIHtcbiAgICAgICAgbGV0IHN0YXJ0SSA9IGxpbmVzLmxlbmd0aCwgbWluSW5kZW50ID0gMWU5O1xuICAgICAgICBsZXQgdG9rZW4gPSBnZXRDb25maWcoc3RhdGUsIGZyb20pLmxpbmU7XG4gICAgICAgIGlmICghdG9rZW4pXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gZnJvbTsgcG9zIDw9IHRvOykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAobGluZS5mcm9tID4gcHJldkxpbmUgJiYgKGZyb20gPT0gdG8gfHwgdG8gPiBsaW5lLmZyb20pKSB7XG4gICAgICAgICAgICAgICAgcHJldkxpbmUgPSBsaW5lLmZyb207XG4gICAgICAgICAgICAgICAgbGV0IGluZGVudCA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgZW1wdHkgPSBpbmRlbnQgPT0gbGluZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IGNvbW1lbnQgPSBsaW5lLnRleHQuc2xpY2UoaW5kZW50LCBpbmRlbnQgKyB0b2tlbi5sZW5ndGgpID09IHRva2VuID8gaW5kZW50IDogLTE7XG4gICAgICAgICAgICAgICAgaWYgKGluZGVudCA8IGxpbmUudGV4dC5sZW5ndGggJiYgaW5kZW50IDwgbWluSW5kZW50KVxuICAgICAgICAgICAgICAgICAgICBtaW5JbmRlbnQgPSBpbmRlbnQ7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaCh7IGxpbmUsIGNvbW1lbnQsIHRva2VuLCBpbmRlbnQsIGVtcHR5LCBzaW5nbGU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gbGluZS50byArIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbkluZGVudCA8IDFlOSlcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydEk7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAobGluZXNbaV0uaW5kZW50IDwgbGluZXNbaV0ubGluZS50ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbGluZXNbaV0uaW5kZW50ID0gbWluSW5kZW50O1xuICAgICAgICBpZiAobGluZXMubGVuZ3RoID09IHN0YXJ0SSArIDEpXG4gICAgICAgICAgICBsaW5lc1tzdGFydEldLnNpbmdsZSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvcHRpb24gIT0gMiAvKiBDb21tZW50T3B0aW9uLlVuY29tbWVudCAqLyAmJiBsaW5lcy5zb21lKGwgPT4gbC5jb21tZW50IDwgMCAmJiAoIWwuZW1wdHkgfHwgbC5zaW5nbGUpKSkge1xuICAgICAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB7IGxpbmUsIHRva2VuLCBpbmRlbnQsIGVtcHR5LCBzaW5nbGUgfSBvZiBsaW5lcylcbiAgICAgICAgICAgIGlmIChzaW5nbGUgfHwgIWVtcHR5KVxuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSArIGluZGVudCwgaW5zZXJ0OiB0b2tlbiArIFwiIFwiIH0pO1xuICAgICAgICBsZXQgY2hhbmdlU2V0ID0gc3RhdGUuY2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogY2hhbmdlU2V0LCBzZWxlY3Rpb246IHN0YXRlLnNlbGVjdGlvbi5tYXAoY2hhbmdlU2V0LCAxKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb24gIT0gMSAvKiBDb21tZW50T3B0aW9uLkNvbW1lbnQgKi8gJiYgbGluZXMuc29tZShsID0+IGwuY29tbWVudCA+PSAwKSkge1xuICAgICAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB7IGxpbmUsIGNvbW1lbnQsIHRva2VuIH0gb2YgbGluZXMpXG4gICAgICAgICAgICBpZiAoY29tbWVudCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBsaW5lLmZyb20gKyBjb21tZW50LCB0byA9IGZyb20gKyB0b2tlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUudGV4dFt0byAtIGxpbmUuZnJvbV0gPT0gXCIgXCIpXG4gICAgICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXMgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IGZyb21IaXN0b3J5ID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG4vKipcblRyYW5zYWN0aW9uIGFubm90YXRpb24gdGhhdCB3aWxsIHByZXZlbnQgdGhhdCB0cmFuc2FjdGlvbiBmcm9tXG5iZWluZyBjb21iaW5lZCB3aXRoIG90aGVyIHRyYW5zYWN0aW9ucyBpbiB0aGUgdW5kbyBoaXN0b3J5LiBHaXZlblxuYFwiYmVmb3JlXCJgLCBpdCdsbCBwcmV2ZW50IG1lcmdpbmcgd2l0aCBwcmV2aW91cyB0cmFuc2FjdGlvbnMuIFdpdGhcbmBcImFmdGVyXCJgLCBzdWJzZXF1ZW50IHRyYW5zYWN0aW9ucyB3b24ndCBiZSBjb21iaW5lZCB3aXRoIHRoaXNcbm9uZS4gV2l0aCBgXCJmdWxsXCJgLCB0aGUgdHJhbnNhY3Rpb24gaXMgaXNvbGF0ZWQgb24gYm90aCBzaWRlcy5cbiovXG5jb25zdCBpc29sYXRlSGlzdG9yeSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5UaGlzIGZhY2V0IHByb3ZpZGVzIGEgd2F5IHRvIHJlZ2lzdGVyIGZ1bmN0aW9ucyB0aGF0LCBnaXZlbiBhXG50cmFuc2FjdGlvbiwgcHJvdmlkZSBhIHNldCBvZiBlZmZlY3RzIHRoYXQgdGhlIGhpc3Rvcnkgc2hvdWxkXG5zdG9yZSB3aGVuIGludmVydGluZyB0aGUgdHJhbnNhY3Rpb24uIFRoaXMgY2FuIGJlIHVzZWQgdG9cbmludGVncmF0ZSBzb21lIGtpbmRzIG9mIGVmZmVjdHMgaW4gdGhlIGhpc3RvcnksIHNvIHRoYXQgdGhleSBjYW5cbmJlIHVuZG9uZSAoYW5kIHJlZG9uZSBhZ2FpbikuXG4qL1xuY29uc3QgaW52ZXJ0ZWRFZmZlY3RzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgaGlzdG9yeUNvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICBtaW5EZXB0aDogMTAwLFxuICAgICAgICAgICAgbmV3R3JvdXBEZWxheTogNTAwLFxuICAgICAgICAgICAgam9pblRvRXZlbnQ6IChfdCwgaXNBZGphY2VudCkgPT4gaXNBZGphY2VudCxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbWluRGVwdGg6IE1hdGgubWF4LFxuICAgICAgICAgICAgbmV3R3JvdXBEZWxheTogTWF0aC5taW4sXG4gICAgICAgICAgICBqb2luVG9FdmVudDogKGEsIGIpID0+ICh0ciwgYWRqKSA9PiBhKHRyLCBhZGopIHx8IGIodHIsIGFkailcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5jb25zdCBoaXN0b3J5RmllbGRfID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7XG4gICAgICAgIHJldHVybiBIaXN0b3J5U3RhdGUuZW1wdHk7XG4gICAgfSxcbiAgICB1cGRhdGUoc3RhdGUsIHRyKSB7XG4gICAgICAgIGxldCBjb25maWcgPSB0ci5zdGF0ZS5mYWNldChoaXN0b3J5Q29uZmlnKTtcbiAgICAgICAgbGV0IGZyb21IaXN0ID0gdHIuYW5ub3RhdGlvbihmcm9tSGlzdG9yeSk7XG4gICAgICAgIGlmIChmcm9tSGlzdCkge1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBIaXN0RXZlbnQuZnJvbVRyYW5zYWN0aW9uKHRyLCBmcm9tSGlzdC5zZWxlY3Rpb24pLCBmcm9tID0gZnJvbUhpc3Quc2lkZTtcbiAgICAgICAgICAgIGxldCBvdGhlciA9IGZyb20gPT0gMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8gPyBzdGF0ZS51bmRvbmUgOiBzdGF0ZS5kb25lO1xuICAgICAgICAgICAgaWYgKGl0ZW0pXG4gICAgICAgICAgICAgICAgb3RoZXIgPSB1cGRhdGVCcmFuY2gob3RoZXIsIG90aGVyLmxlbmd0aCwgY29uZmlnLm1pbkRlcHRoLCBpdGVtKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvdGhlciA9IGFkZFNlbGVjdGlvbihvdGhlciwgdHIuc3RhcnRTdGF0ZS5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoZnJvbSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IGZyb21IaXN0LnJlc3QgOiBvdGhlciwgZnJvbSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IG90aGVyIDogZnJvbUhpc3QucmVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlzb2xhdGUgPSB0ci5hbm5vdGF0aW9uKGlzb2xhdGVIaXN0b3J5KTtcbiAgICAgICAgaWYgKGlzb2xhdGUgPT0gXCJmdWxsXCIgfHwgaXNvbGF0ZSA9PSBcImJlZm9yZVwiKVxuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS5pc29sYXRlKCk7XG4gICAgICAgIGlmICh0ci5hbm5vdGF0aW9uKFRyYW5zYWN0aW9uLmFkZFRvSGlzdG9yeSkgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuICF0ci5jaGFuZ2VzLmVtcHR5ID8gc3RhdGUuYWRkTWFwcGluZyh0ci5jaGFuZ2VzLmRlc2MpIDogc3RhdGU7XG4gICAgICAgIGxldCBldmVudCA9IEhpc3RFdmVudC5mcm9tVHJhbnNhY3Rpb24odHIpO1xuICAgICAgICBsZXQgdGltZSA9IHRyLmFubm90YXRpb24oVHJhbnNhY3Rpb24udGltZSksIHVzZXJFdmVudCA9IHRyLmFubm90YXRpb24oVHJhbnNhY3Rpb24udXNlckV2ZW50KTtcbiAgICAgICAgaWYgKGV2ZW50KVxuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS5hZGRDaGFuZ2VzKGV2ZW50LCB0aW1lLCB1c2VyRXZlbnQsIGNvbmZpZywgdHIpO1xuICAgICAgICBlbHNlIGlmICh0ci5zZWxlY3Rpb24pXG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLmFkZFNlbGVjdGlvbih0ci5zdGFydFN0YXRlLnNlbGVjdGlvbiwgdGltZSwgdXNlckV2ZW50LCBjb25maWcubmV3R3JvdXBEZWxheSk7XG4gICAgICAgIGlmIChpc29sYXRlID09IFwiZnVsbFwiIHx8IGlzb2xhdGUgPT0gXCJhZnRlclwiKVxuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS5pc29sYXRlKCk7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuICAgIHRvSlNPTih2YWx1ZSkge1xuICAgICAgICByZXR1cm4geyBkb25lOiB2YWx1ZS5kb25lLm1hcChlID0+IGUudG9KU09OKCkpLCB1bmRvbmU6IHZhbHVlLnVuZG9uZS5tYXAoZSA9PiBlLnRvSlNPTigpKSB9O1xuICAgIH0sXG4gICAgZnJvbUpTT04oanNvbikge1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShqc29uLmRvbmUubWFwKEhpc3RFdmVudC5mcm9tSlNPTiksIGpzb24udW5kb25lLm1hcChIaXN0RXZlbnQuZnJvbUpTT04pKTtcbiAgICB9XG59KTtcbi8qKlxuQ3JlYXRlIGEgaGlzdG9yeSBleHRlbnNpb24gd2l0aCB0aGUgZ2l2ZW4gY29uZmlndXJhdGlvbi5cbiovXG5mdW5jdGlvbiBoaXN0b3J5KGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgaGlzdG9yeUZpZWxkXyxcbiAgICAgICAgaGlzdG9yeUNvbmZpZy5vZihjb25maWcpLFxuICAgICAgICBFZGl0b3JWaWV3LmRvbUV2ZW50SGFuZGxlcnMoe1xuICAgICAgICAgICAgYmVmb3JlaW5wdXQoZSwgdmlldykge1xuICAgICAgICAgICAgICAgIGxldCBjb21tYW5kID0gZS5pbnB1dFR5cGUgPT0gXCJoaXN0b3J5VW5kb1wiID8gdW5kbyA6IGUuaW5wdXRUeXBlID09IFwiaGlzdG9yeVJlZG9cIiA/IHJlZG8gOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghY29tbWFuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZCh2aWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICBdO1xufVxuLyoqXG5UaGUgc3RhdGUgZmllbGQgdXNlZCB0byBzdG9yZSB0aGUgaGlzdG9yeSBkYXRhLiBTaG91bGQgcHJvYmFibHlcbm9ubHkgYmUgdXNlZCB3aGVuIHlvdSB3YW50IHRvXG5bc2VyaWFsaXplXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnRvSlNPTikgb3JcbltkZXNlcmlhbGl6ZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5mcm9tSlNPTikgc3RhdGUgb2JqZWN0cyBpbiBhIHdheVxudGhhdCBwcmVzZXJ2ZXMgaGlzdG9yeS5cbiovXG5jb25zdCBoaXN0b3J5RmllbGQgPSBoaXN0b3J5RmllbGRfO1xuZnVuY3Rpb24gY21kKHNpZGUsIHNlbGVjdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkge1xuICAgICAgICBpZiAoIXNlbGVjdGlvbiAmJiBzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGhpc3RvcnlTdGF0ZSA9IHN0YXRlLmZpZWxkKGhpc3RvcnlGaWVsZF8sIGZhbHNlKTtcbiAgICAgICAgaWYgKCFoaXN0b3J5U3RhdGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB0ciA9IGhpc3RvcnlTdGF0ZS5wb3Aoc2lkZSwgc3RhdGUsIHNlbGVjdGlvbik7XG4gICAgICAgIGlmICghdHIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuVW5kbyBhIHNpbmdsZSBncm91cCBvZiBoaXN0b3J5IGV2ZW50cy4gUmV0dXJucyBmYWxzZSBpZiBubyBncm91cFxud2FzIGF2YWlsYWJsZS5cbiovXG5jb25zdCB1bmRvID0gLypAX19QVVJFX18qL2NtZCgwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLywgZmFsc2UpO1xuLyoqXG5SZWRvIGEgZ3JvdXAgb2YgaGlzdG9yeSBldmVudHMuIFJldHVybnMgZmFsc2UgaWYgbm8gZ3JvdXAgd2FzXG5hdmFpbGFibGUuXG4qL1xuY29uc3QgcmVkbyA9IC8qQF9fUFVSRV9fKi9jbWQoMSAvKiBCcmFuY2hOYW1lLlVuZG9uZSAqLywgZmFsc2UpO1xuLyoqXG5VbmRvIGEgY2hhbmdlIG9yIHNlbGVjdGlvbiBjaGFuZ2UuXG4qL1xuY29uc3QgdW5kb1NlbGVjdGlvbiA9IC8qQF9fUFVSRV9fKi9jbWQoMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8sIHRydWUpO1xuLyoqXG5SZWRvIGEgY2hhbmdlIG9yIHNlbGVjdGlvbiBjaGFuZ2UuXG4qL1xuY29uc3QgcmVkb1NlbGVjdGlvbiA9IC8qQF9fUFVSRV9fKi9jbWQoMSAvKiBCcmFuY2hOYW1lLlVuZG9uZSAqLywgdHJ1ZSk7XG5mdW5jdGlvbiBkZXB0aChzaWRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICBsZXQgaGlzdFN0YXRlID0gc3RhdGUuZmllbGQoaGlzdG9yeUZpZWxkXywgZmFsc2UpO1xuICAgICAgICBpZiAoIWhpc3RTdGF0ZSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgYnJhbmNoID0gc2lkZSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IGhpc3RTdGF0ZS5kb25lIDogaGlzdFN0YXRlLnVuZG9uZTtcbiAgICAgICAgcmV0dXJuIGJyYW5jaC5sZW5ndGggLSAoYnJhbmNoLmxlbmd0aCAmJiAhYnJhbmNoWzBdLmNoYW5nZXMgPyAxIDogMCk7XG4gICAgfTtcbn1cbi8qKlxuVGhlIGFtb3VudCBvZiB1bmRvYWJsZSBjaGFuZ2UgZXZlbnRzIGF2YWlsYWJsZSBpbiBhIGdpdmVuIHN0YXRlLlxuKi9cbmNvbnN0IHVuZG9EZXB0aCA9IC8qQF9fUFVSRV9fKi9kZXB0aCgwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyk7XG4vKipcblRoZSBhbW91bnQgb2YgcmVkb2FibGUgY2hhbmdlIGV2ZW50cyBhdmFpbGFibGUgaW4gYSBnaXZlbiBzdGF0ZS5cbiovXG5jb25zdCByZWRvRGVwdGggPSAvKkBfX1BVUkVfXyovZGVwdGgoMSAvKiBCcmFuY2hOYW1lLlVuZG9uZSAqLyk7XG4vLyBIaXN0b3J5IGV2ZW50cyBzdG9yZSBncm91cHMgb2YgY2hhbmdlcyBvciBlZmZlY3RzIHRoYXQgbmVlZCB0byBiZVxuLy8gdW5kb25lL3JlZG9uZSB0b2dldGhlci5cbmNsYXNzIEhpc3RFdmVudCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gVGhlIGNoYW5nZXMgaW4gdGhpcyBldmVudC4gTm9ybWFsIGV2ZW50cyBob2xkIGF0IGxlYXN0IG9uZVxuICAgIC8vIGNoYW5nZSBvciBlZmZlY3QuIEJ1dCBpdCBtYXkgYmUgbmVjZXNzYXJ5IHRvIHN0b3JlIHNlbGVjdGlvblxuICAgIC8vIGV2ZW50cyBiZWZvcmUgdGhlIGZpcnN0IGNoYW5nZSwgaW4gd2hpY2ggY2FzZSBhIHNwZWNpYWwgdHlwZSBvZlxuICAgIC8vIGluc3RhbmNlIGlzIGNyZWF0ZWQgd2hpY2ggZG9lc24ndCBob2xkIGFueSBjaGFuZ2VzLCB3aXRoXG4gICAgLy8gY2hhbmdlcyA9PSBzdGFydFNlbGVjdGlvbiA9PSB1bmRlZmluZWRcbiAgICBjaGFuZ2VzLCBcbiAgICAvLyBUaGUgZWZmZWN0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBldmVudFxuICAgIGVmZmVjdHMsIFxuICAgIC8vIEFjY3VtdWxhdGVkIG1hcHBpbmcgKGZyb20gYWRkVG9IaXN0b3J5PT1mYWxzZSkgdGhhdCBzaG91bGQgYmVcbiAgICAvLyBhcHBsaWVkIHRvIGV2ZW50cyBiZWxvdyB0aGlzIG9uZS5cbiAgICBtYXBwZWQsIFxuICAgIC8vIFRoZSBzZWxlY3Rpb24gYmVmb3JlIHRoaXMgZXZlbnRcbiAgICBzdGFydFNlbGVjdGlvbiwgXG4gICAgLy8gU3RvcmVzIHNlbGVjdGlvbiBjaGFuZ2VzIGFmdGVyIHRoaXMgZXZlbnQsIHRvIGJlIHVzZWQgZm9yXG4gICAgLy8gc2VsZWN0aW9uIHVuZG8vcmVkby5cbiAgICBzZWxlY3Rpb25zQWZ0ZXIpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gY2hhbmdlcztcbiAgICAgICAgdGhpcy5lZmZlY3RzID0gZWZmZWN0cztcbiAgICAgICAgdGhpcy5tYXBwZWQgPSBtYXBwZWQ7XG4gICAgICAgIHRoaXMuc3RhcnRTZWxlY3Rpb24gPSBzdGFydFNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25zQWZ0ZXIgPSBzZWxlY3Rpb25zQWZ0ZXI7XG4gICAgfVxuICAgIHNldFNlbEFmdGVyKGFmdGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdEV2ZW50KHRoaXMuY2hhbmdlcywgdGhpcy5lZmZlY3RzLCB0aGlzLm1hcHBlZCwgdGhpcy5zdGFydFNlbGVjdGlvbiwgYWZ0ZXIpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhbmdlczogKF9hID0gdGhpcy5jaGFuZ2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9KU09OKCksXG4gICAgICAgICAgICBtYXBwZWQ6IChfYiA9IHRoaXMubWFwcGVkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudG9KU09OKCksXG4gICAgICAgICAgICBzdGFydFNlbGVjdGlvbjogKF9jID0gdGhpcy5zdGFydFNlbGVjdGlvbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvSlNPTigpLFxuICAgICAgICAgICAgc2VsZWN0aW9uc0FmdGVyOiB0aGlzLnNlbGVjdGlvbnNBZnRlci5tYXAocyA9PiBzLnRvSlNPTigpKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RFdmVudChqc29uLmNoYW5nZXMgJiYgQ2hhbmdlU2V0LmZyb21KU09OKGpzb24uY2hhbmdlcyksIFtdLCBqc29uLm1hcHBlZCAmJiBDaGFuZ2VEZXNjLmZyb21KU09OKGpzb24ubWFwcGVkKSwganNvbi5zdGFydFNlbGVjdGlvbiAmJiBFZGl0b3JTZWxlY3Rpb24uZnJvbUpTT04oanNvbi5zdGFydFNlbGVjdGlvbiksIGpzb24uc2VsZWN0aW9uc0FmdGVyLm1hcChFZGl0b3JTZWxlY3Rpb24uZnJvbUpTT04pKTtcbiAgICB9XG4gICAgLy8gVGhpcyBkb2VzIG5vdCBjaGVjayBgYWRkVG9IaXN0b3J5YCBhbmQgc3VjaCwgaXQgYXNzdW1lcyB0aGVcbiAgICAvLyB0cmFuc2FjdGlvbiBuZWVkcyB0byBiZSBjb252ZXJ0ZWQgdG8gYW4gaXRlbS4gUmV0dXJucyBudWxsIHdoZW5cbiAgICAvLyB0aGVyZSBhcmUgbm8gY2hhbmdlcyBvciBlZmZlY3RzIGluIHRoZSB0cmFuc2FjdGlvbi5cbiAgICBzdGF0aWMgZnJvbVRyYW5zYWN0aW9uKHRyLCBzZWxlY3Rpb24pIHtcbiAgICAgICAgbGV0IGVmZmVjdHMgPSBub25lO1xuICAgICAgICBmb3IgKGxldCBpbnZlcnQgb2YgdHIuc3RhcnRTdGF0ZS5mYWNldChpbnZlcnRlZEVmZmVjdHMpKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gaW52ZXJ0KHRyKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGVmZmVjdHMgPSBlZmZlY3RzLmNvbmNhdChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZWZmZWN0cy5sZW5ndGggJiYgdHIuY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RFdmVudCh0ci5jaGFuZ2VzLmludmVydCh0ci5zdGFydFN0YXRlLmRvYyksIGVmZmVjdHMsIHVuZGVmaW5lZCwgc2VsZWN0aW9uIHx8IHRyLnN0YXJ0U3RhdGUuc2VsZWN0aW9uLCBub25lKTtcbiAgICB9XG4gICAgc3RhdGljIHNlbGVjdGlvbihzZWxlY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdEV2ZW50KHVuZGVmaW5lZCwgbm9uZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHNlbGVjdGlvbnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUJyYW5jaChicmFuY2gsIHRvLCBtYXhMZW4sIG5ld0V2ZW50KSB7XG4gICAgbGV0IHN0YXJ0ID0gdG8gKyAxID4gbWF4TGVuICsgMjAgPyB0byAtIG1heExlbiAtIDEgOiAwO1xuICAgIGxldCBuZXdCcmFuY2ggPSBicmFuY2guc2xpY2Uoc3RhcnQsIHRvKTtcbiAgICBuZXdCcmFuY2gucHVzaChuZXdFdmVudCk7XG4gICAgcmV0dXJuIG5ld0JyYW5jaDtcbn1cbmZ1bmN0aW9uIGlzQWRqYWNlbnQoYSwgYikge1xuICAgIGxldCByYW5nZXMgPSBbXSwgaXNBZGphY2VudCA9IGZhbHNlO1xuICAgIGEuaXRlckNoYW5nZWRSYW5nZXMoKGYsIHQpID0+IHJhbmdlcy5wdXNoKGYsIHQpKTtcbiAgICBiLml0ZXJDaGFuZ2VkUmFuZ2VzKChfZiwgX3QsIGYsIHQpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGZyb20gPSByYW5nZXNbaSsrXSwgdG8gPSByYW5nZXNbaSsrXTtcbiAgICAgICAgICAgIGlmICh0ID49IGZyb20gJiYgZiA8PSB0bylcbiAgICAgICAgICAgICAgICBpc0FkamFjZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpc0FkamFjZW50O1xufVxuZnVuY3Rpb24gZXFTZWxlY3Rpb25TaGFwZShhLCBiKSB7XG4gICAgcmV0dXJuIGEucmFuZ2VzLmxlbmd0aCA9PSBiLnJhbmdlcy5sZW5ndGggJiZcbiAgICAgICAgYS5yYW5nZXMuZmlsdGVyKChyLCBpKSA9PiByLmVtcHR5ICE9IGIucmFuZ2VzW2ldLmVtcHR5KS5sZW5ndGggPT09IDA7XG59XG5mdW5jdGlvbiBjb25jKGEsIGIpIHtcbiAgICByZXR1cm4gIWEubGVuZ3RoID8gYiA6ICFiLmxlbmd0aCA/IGEgOiBhLmNvbmNhdChiKTtcbn1cbmNvbnN0IG5vbmUgPSBbXTtcbmNvbnN0IE1heFNlbGVjdGlvbnNQZXJFdmVudCA9IDIwMDtcbmZ1bmN0aW9uIGFkZFNlbGVjdGlvbihicmFuY2gsIHNlbGVjdGlvbikge1xuICAgIGlmICghYnJhbmNoLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW0hpc3RFdmVudC5zZWxlY3Rpb24oW3NlbGVjdGlvbl0pXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBsYXN0RXZlbnQgPSBicmFuY2hbYnJhbmNoLmxlbmd0aCAtIDFdO1xuICAgICAgICBsZXQgc2VscyA9IGxhc3RFdmVudC5zZWxlY3Rpb25zQWZ0ZXIuc2xpY2UoTWF0aC5tYXgoMCwgbGFzdEV2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGggLSBNYXhTZWxlY3Rpb25zUGVyRXZlbnQpKTtcbiAgICAgICAgaWYgKHNlbHMubGVuZ3RoICYmIHNlbHNbc2Vscy5sZW5ndGggLSAxXS5lcShzZWxlY3Rpb24pKVxuICAgICAgICAgICAgcmV0dXJuIGJyYW5jaDtcbiAgICAgICAgc2Vscy5wdXNoKHNlbGVjdGlvbik7XG4gICAgICAgIHJldHVybiB1cGRhdGVCcmFuY2goYnJhbmNoLCBicmFuY2gubGVuZ3RoIC0gMSwgMWU5LCBsYXN0RXZlbnQuc2V0U2VsQWZ0ZXIoc2VscykpO1xuICAgIH1cbn1cbi8vIEFzc3VtZXMgdGhlIHRvcCBpdGVtIGhhcyBvbmUgb3IgbW9yZSBzZWxlY3Rpb25BZnRlciB2YWx1ZXNcbmZ1bmN0aW9uIHBvcFNlbGVjdGlvbihicmFuY2gpIHtcbiAgICBsZXQgbGFzdCA9IGJyYW5jaFticmFuY2gubGVuZ3RoIC0gMV07XG4gICAgbGV0IG5ld0JyYW5jaCA9IGJyYW5jaC5zbGljZSgpO1xuICAgIG5ld0JyYW5jaFticmFuY2gubGVuZ3RoIC0gMV0gPSBsYXN0LnNldFNlbEFmdGVyKGxhc3Quc2VsZWN0aW9uc0FmdGVyLnNsaWNlKDAsIGxhc3Quc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCAtIDEpKTtcbiAgICByZXR1cm4gbmV3QnJhbmNoO1xufVxuLy8gQWRkIGEgbWFwcGluZyB0byB0aGUgdG9wIGV2ZW50IGluIHRoZSBnaXZlbiBicmFuY2guIElmIHRoaXMgbWFwc1xuLy8gYXdheSBhbGwgdGhlIGNoYW5nZXMgYW5kIGVmZmVjdHMgaW4gdGhhdCBpdGVtLCBkcm9wIGl0IGFuZFxuLy8gcHJvcGFnYXRlIHRoZSBtYXBwaW5nIHRvIHRoZSBuZXh0IGl0ZW0uXG5mdW5jdGlvbiBhZGRNYXBwaW5nVG9CcmFuY2goYnJhbmNoLCBtYXBwaW5nKSB7XG4gICAgaWYgKCFicmFuY2gubGVuZ3RoKVxuICAgICAgICByZXR1cm4gYnJhbmNoO1xuICAgIGxldCBsZW5ndGggPSBicmFuY2gubGVuZ3RoLCBzZWxlY3Rpb25zID0gbm9uZTtcbiAgICB3aGlsZSAobGVuZ3RoKSB7XG4gICAgICAgIGxldCBldmVudCA9IG1hcEV2ZW50KGJyYW5jaFtsZW5ndGggLSAxXSwgbWFwcGluZywgc2VsZWN0aW9ucyk7XG4gICAgICAgIGlmIChldmVudC5jaGFuZ2VzICYmICFldmVudC5jaGFuZ2VzLmVtcHR5IHx8IGV2ZW50LmVmZmVjdHMubGVuZ3RoKSB7IC8vIEV2ZW50IHN1cnZpdmVkIG1hcHBpbmdcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBicmFuY2guc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICAgICAgICAgIHJlc3VsdFtsZW5ndGggLSAxXSA9IGV2ZW50O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gRHJvcCB0aGlzIGV2ZW50LCBzaW5jZSB0aGVyZSdzIG5vIGNoYW5nZXMgb3IgZWZmZWN0cyBsZWZ0XG4gICAgICAgICAgICBtYXBwaW5nID0gZXZlbnQubWFwcGVkO1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBzZWxlY3Rpb25zID0gZXZlbnQuc2VsZWN0aW9uc0FmdGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3Rpb25zLmxlbmd0aCA/IFtIaXN0RXZlbnQuc2VsZWN0aW9uKHNlbGVjdGlvbnMpXSA6IG5vbmU7XG59XG5mdW5jdGlvbiBtYXBFdmVudChldmVudCwgbWFwcGluZywgZXh0cmFTZWxlY3Rpb25zKSB7XG4gICAgbGV0IHNlbGVjdGlvbnMgPSBjb25jKGV2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGggPyBldmVudC5zZWxlY3Rpb25zQWZ0ZXIubWFwKHMgPT4gcy5tYXAobWFwcGluZykpIDogbm9uZSwgZXh0cmFTZWxlY3Rpb25zKTtcbiAgICAvLyBDaGFuZ2UtbGVzcyBldmVudHMgZG9uJ3Qgc3RvcmUgbWFwcGluZ3MgKHRoZXkgYXJlIGFsd2F5cyB0aGUgbGFzdCBldmVudCBpbiBhIGJyYW5jaClcbiAgICBpZiAoIWV2ZW50LmNoYW5nZXMpXG4gICAgICAgIHJldHVybiBIaXN0RXZlbnQuc2VsZWN0aW9uKHNlbGVjdGlvbnMpO1xuICAgIGxldCBtYXBwZWRDaGFuZ2VzID0gZXZlbnQuY2hhbmdlcy5tYXAobWFwcGluZyksIGJlZm9yZSA9IG1hcHBpbmcubWFwRGVzYyhldmVudC5jaGFuZ2VzLCB0cnVlKTtcbiAgICBsZXQgZnVsbE1hcHBpbmcgPSBldmVudC5tYXBwZWQgPyBldmVudC5tYXBwZWQuY29tcG9zZURlc2MoYmVmb3JlKSA6IGJlZm9yZTtcbiAgICByZXR1cm4gbmV3IEhpc3RFdmVudChtYXBwZWRDaGFuZ2VzLCBTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGV2ZW50LmVmZmVjdHMsIG1hcHBpbmcpLCBmdWxsTWFwcGluZywgZXZlbnQuc3RhcnRTZWxlY3Rpb24ubWFwKGJlZm9yZSksIHNlbGVjdGlvbnMpO1xufVxuY29uc3Qgam9pbmFibGVVc2VyRXZlbnQgPSAvXihpbnB1dFxcLnR5cGV8ZGVsZXRlKSgkfFxcLikvO1xuY2xhc3MgSGlzdG9yeVN0YXRlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb25lLCB1bmRvbmUsIHByZXZUaW1lID0gMCwgcHJldlVzZXJFdmVudCA9IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmRvbmUgPSBkb25lO1xuICAgICAgICB0aGlzLnVuZG9uZSA9IHVuZG9uZTtcbiAgICAgICAgdGhpcy5wcmV2VGltZSA9IHByZXZUaW1lO1xuICAgICAgICB0aGlzLnByZXZVc2VyRXZlbnQgPSBwcmV2VXNlckV2ZW50O1xuICAgIH1cbiAgICBpc29sYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2VGltZSA/IG5ldyBIaXN0b3J5U3RhdGUodGhpcy5kb25lLCB0aGlzLnVuZG9uZSkgOiB0aGlzO1xuICAgIH1cbiAgICBhZGRDaGFuZ2VzKGV2ZW50LCB0aW1lLCB1c2VyRXZlbnQsIGNvbmZpZywgdHIpIHtcbiAgICAgICAgbGV0IGRvbmUgPSB0aGlzLmRvbmUsIGxhc3RFdmVudCA9IGRvbmVbZG9uZS5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3RFdmVudCAmJiBsYXN0RXZlbnQuY2hhbmdlcyAmJiAhbGFzdEV2ZW50LmNoYW5nZXMuZW1wdHkgJiYgZXZlbnQuY2hhbmdlcyAmJlxuICAgICAgICAgICAgKCF1c2VyRXZlbnQgfHwgam9pbmFibGVVc2VyRXZlbnQudGVzdCh1c2VyRXZlbnQpKSAmJlxuICAgICAgICAgICAgKCghbGFzdEV2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICB0aW1lIC0gdGhpcy5wcmV2VGltZSA8IGNvbmZpZy5uZXdHcm91cERlbGF5ICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLmpvaW5Ub0V2ZW50KHRyLCBpc0FkamFjZW50KGxhc3RFdmVudC5jaGFuZ2VzLCBldmVudC5jaGFuZ2VzKSkpIHx8XG4gICAgICAgICAgICAgICAgLy8gRm9yIGNvbXBvc2UgKGJ1dCBub3QgY29tcG9zZS5zdGFydCkgZXZlbnRzLCBhbHdheXMgam9pbiB3aXRoIHByZXZpb3VzIGV2ZW50XG4gICAgICAgICAgICAgICAgdXNlckV2ZW50ID09IFwiaW5wdXQudHlwZS5jb21wb3NlXCIpKSB7XG4gICAgICAgICAgICBkb25lID0gdXBkYXRlQnJhbmNoKGRvbmUsIGRvbmUubGVuZ3RoIC0gMSwgY29uZmlnLm1pbkRlcHRoLCBuZXcgSGlzdEV2ZW50KGV2ZW50LmNoYW5nZXMuY29tcG9zZShsYXN0RXZlbnQuY2hhbmdlcyksIGNvbmMoZXZlbnQuZWZmZWN0cywgbGFzdEV2ZW50LmVmZmVjdHMpLCBsYXN0RXZlbnQubWFwcGVkLCBsYXN0RXZlbnQuc3RhcnRTZWxlY3Rpb24sIG5vbmUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvbmUgPSB1cGRhdGVCcmFuY2goZG9uZSwgZG9uZS5sZW5ndGgsIGNvbmZpZy5taW5EZXB0aCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGRvbmUsIG5vbmUsIHRpbWUsIHVzZXJFdmVudCk7XG4gICAgfVxuICAgIGFkZFNlbGVjdGlvbihzZWxlY3Rpb24sIHRpbWUsIHVzZXJFdmVudCwgbmV3R3JvdXBEZWxheSkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuZG9uZS5sZW5ndGggPyB0aGlzLmRvbmVbdGhpcy5kb25lLmxlbmd0aCAtIDFdLnNlbGVjdGlvbnNBZnRlciA6IG5vbmU7XG4gICAgICAgIGlmIChsYXN0Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIHRpbWUgLSB0aGlzLnByZXZUaW1lIDwgbmV3R3JvdXBEZWxheSAmJlxuICAgICAgICAgICAgdXNlckV2ZW50ID09IHRoaXMucHJldlVzZXJFdmVudCAmJiB1c2VyRXZlbnQgJiYgL15zZWxlY3QoJHxcXC4pLy50ZXN0KHVzZXJFdmVudCkgJiZcbiAgICAgICAgICAgIGVxU2VsZWN0aW9uU2hhcGUobGFzdFtsYXN0Lmxlbmd0aCAtIDFdLCBzZWxlY3Rpb24pKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGFkZFNlbGVjdGlvbih0aGlzLmRvbmUsIHNlbGVjdGlvbiksIHRoaXMudW5kb25lLCB0aW1lLCB1c2VyRXZlbnQpO1xuICAgIH1cbiAgICBhZGRNYXBwaW5nKG1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoYWRkTWFwcGluZ1RvQnJhbmNoKHRoaXMuZG9uZSwgbWFwcGluZyksIGFkZE1hcHBpbmdUb0JyYW5jaCh0aGlzLnVuZG9uZSwgbWFwcGluZyksIHRoaXMucHJldlRpbWUsIHRoaXMucHJldlVzZXJFdmVudCk7XG4gICAgfVxuICAgIHBvcChzaWRlLCBzdGF0ZSwgb25seVNlbGVjdGlvbikge1xuICAgICAgICBsZXQgYnJhbmNoID0gc2lkZSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IHRoaXMuZG9uZSA6IHRoaXMudW5kb25lO1xuICAgICAgICBpZiAoYnJhbmNoLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBldmVudCA9IGJyYW5jaFticmFuY2gubGVuZ3RoIC0gMV0sIHNlbGVjdGlvbiA9IGV2ZW50LnNlbGVjdGlvbnNBZnRlclswXSB8fCBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGlmIChvbmx5U2VsZWN0aW9uICYmIGV2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS51cGRhdGUoe1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogZXZlbnQuc2VsZWN0aW9uc0FmdGVyW2V2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uczogZnJvbUhpc3Rvcnkub2YoeyBzaWRlLCByZXN0OiBwb3BTZWxlY3Rpb24oYnJhbmNoKSwgc2VsZWN0aW9uIH0pLFxuICAgICAgICAgICAgICAgIHVzZXJFdmVudDogc2lkZSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IFwic2VsZWN0LnVuZG9cIiA6IFwic2VsZWN0LnJlZG9cIixcbiAgICAgICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWV2ZW50LmNoYW5nZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHJlc3QgPSBicmFuY2gubGVuZ3RoID09IDEgPyBub25lIDogYnJhbmNoLnNsaWNlKDAsIGJyYW5jaC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGlmIChldmVudC5tYXBwZWQpXG4gICAgICAgICAgICAgICAgcmVzdCA9IGFkZE1hcHBpbmdUb0JyYW5jaChyZXN0LCBldmVudC5tYXBwZWQpO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgY2hhbmdlczogZXZlbnQuY2hhbmdlcyxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IGV2ZW50LnN0YXJ0U2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IGV2ZW50LmVmZmVjdHMsXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbnM6IGZyb21IaXN0b3J5Lm9mKHsgc2lkZSwgcmVzdCwgc2VsZWN0aW9uIH0pLFxuICAgICAgICAgICAgICAgIGZpbHRlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgdXNlckV2ZW50OiBzaWRlID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gXCJ1bmRvXCIgOiBcInJlZG9cIixcbiAgICAgICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5IaXN0b3J5U3RhdGUuZW1wdHkgPSAvKkBfX1BVUkVfXyovbmV3IEhpc3RvcnlTdGF0ZShub25lLCBub25lKTtcbi8qKlxuRGVmYXVsdCBrZXkgYmluZGluZ3MgZm9yIHRoZSB1bmRvIGhpc3RvcnkuXG5cbi0gTW9kLXo6IFtgdW5kb2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMudW5kbykuXG4tIE1vZC15IChNb2QtU2hpZnQteiBvbiBtYWNPUykgKyBDdHJsLVNoaWZ0LXogb24gTGludXg6IFtgcmVkb2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMucmVkbykuXG4tIE1vZC11OiBbYHVuZG9TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnVuZG9TZWxlY3Rpb24pLlxuLSBBbHQtdSAoTW9kLVNoaWZ0LXUgb24gbWFjT1MpOiBbYHJlZG9TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnJlZG9TZWxlY3Rpb24pLlxuKi9cbmNvbnN0IGhpc3RvcnlLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiTW9kLXpcIiwgcnVuOiB1bmRvLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC15XCIsIG1hYzogXCJNb2QtU2hpZnQtelwiLCBydW46IHJlZG8sIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBsaW51eDogXCJDdHJsLVNoaWZ0LXpcIiwgcnVuOiByZWRvLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC11XCIsIHJ1bjogdW5kb1NlbGVjdGlvbiwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJBbHQtdVwiLCBtYWM6IFwiTW9kLVNoaWZ0LXVcIiwgcnVuOiByZWRvU2VsZWN0aW9uLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9XG5dO1xuXG5mdW5jdGlvbiB1cGRhdGVTZWwoc2VsLCBieSkge1xuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHNlbC5yYW5nZXMubWFwKGJ5KSwgc2VsLm1haW5JbmRleCk7XG59XG5mdW5jdGlvbiBzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikge1xuICAgIHJldHVybiBzdGF0ZS51cGRhdGUoeyBzZWxlY3Rpb24sIHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwic2VsZWN0XCIgfSk7XG59XG5mdW5jdGlvbiBtb3ZlU2VsKHsgc3RhdGUsIGRpc3BhdGNoIH0sIGhvdykge1xuICAgIGxldCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwoc3RhdGUuc2VsZWN0aW9uLCBob3cpO1xuICAgIGlmIChzZWxlY3Rpb24uZXEoc3RhdGUuc2VsZWN0aW9uLCB0cnVlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgc2VsZWN0aW9uKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkge1xuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZvcndhcmQgPyByYW5nZS50byA6IHJhbmdlLmZyb20pO1xufVxuZnVuY3Rpb24gY3Vyc29yQnlDaGFyKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiByYW5nZS5lbXB0eSA/IHZpZXcubW92ZUJ5Q2hhcihyYW5nZSwgZm9yd2FyZCkgOiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkpO1xufVxuZnVuY3Rpb24gbHRyQXRDdXJzb3Iodmlldykge1xuICAgIHJldHVybiB2aWV3LnRleHREaXJlY3Rpb25BdCh2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpID09IERpcmVjdGlvbi5MVFI7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgY2hhcmFjdGVyIHRvIHRoZSBsZWZ0ICh3aGljaCBpcyBiYWNrd2FyZCBpblxubGVmdC10by1yaWdodCB0ZXh0LCBmb3J3YXJkIGluIHJpZ2h0LXRvLWxlZnQgdGV4dCkuXG4qL1xuY29uc3QgY3Vyc29yQ2hhckxlZnQgPSB2aWV3ID0+IGN1cnNvckJ5Q2hhcih2aWV3LCAhbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGNoYXJhY3RlciB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3QgY3Vyc29yQ2hhclJpZ2h0ID0gdmlldyA9PiBjdXJzb3JCeUNoYXIodmlldywgbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGNoYXJhY3RlciBmb3J3YXJkLlxuKi9cbmNvbnN0IGN1cnNvckNoYXJGb3J3YXJkID0gdmlldyA9PiBjdXJzb3JCeUNoYXIodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgY2hhcmFjdGVyIGJhY2t3YXJkLlxuKi9cbmNvbnN0IGN1cnNvckNoYXJCYWNrd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlDaGFyKHZpZXcsIGZhbHNlKTtcbmZ1bmN0aW9uIGN1cnNvckJ5R3JvdXAodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IHJhbmdlLmVtcHR5ID8gdmlldy5tb3ZlQnlHcm91cChyYW5nZSwgZm9yd2FyZCkgOiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGxlZnQgYWNyb3NzIG9uZSBncm91cCBvZiB3b3JkIG9yXG5ub24td29yZCAoYnV0IGFsc28gbm9uLXNwYWNlKSBjaGFyYWN0ZXJzLlxuKi9cbmNvbnN0IGN1cnNvckdyb3VwTGVmdCA9IHZpZXcgPT4gY3Vyc29yQnlHcm91cCh2aWV3LCAhbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGdyb3VwIHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBjdXJzb3JHcm91cFJpZ2h0ID0gdmlldyA9PiBjdXJzb3JCeUdyb3VwKHZpZXcsIGx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBncm91cCBmb3J3YXJkLlxuKi9cbmNvbnN0IGN1cnNvckdyb3VwRm9yd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlHcm91cCh2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBncm91cCBiYWNrd2FyZC5cbiovXG5jb25zdCBjdXJzb3JHcm91cEJhY2t3YXJkID0gdmlldyA9PiBjdXJzb3JCeUdyb3VwKHZpZXcsIGZhbHNlKTtcbmNvbnN0IHNlZ21lbnRlciA9IHR5cGVvZiBJbnRsICE9IFwidW5kZWZpbmVkXCIgJiYgSW50bC5TZWdtZW50ZXIgP1xuICAgIC8qQF9fUFVSRV9fKi9uZXcgKEludGwuU2VnbWVudGVyKSh1bmRlZmluZWQsIHsgZ3JhbnVsYXJpdHk6IFwid29yZFwiIH0pIDogbnVsbDtcbmZ1bmN0aW9uIG1vdmVCeVN1YndvcmQodmlldywgcmFuZ2UsIGZvcndhcmQpIHtcbiAgICBsZXQgY2F0ZWdvcml6ZSA9IHZpZXcuc3RhdGUuY2hhckNhdGVnb3JpemVyKHJhbmdlLmZyb20pO1xuICAgIGxldCBjYXQgPSBDaGFyQ2F0ZWdvcnkuU3BhY2UsIHBvcyA9IHJhbmdlLmZyb20sIHN0ZXBzID0gMDtcbiAgICBsZXQgZG9uZSA9IGZhbHNlLCBzYXdVcHBlciA9IGZhbHNlLCBzYXdMb3dlciA9IGZhbHNlO1xuICAgIGxldCBzdGVwID0gKG5leHQpID0+IHtcbiAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHBvcyArPSBmb3J3YXJkID8gbmV4dC5sZW5ndGggOiAtbmV4dC5sZW5ndGg7XG4gICAgICAgIGxldCBuZXh0Q2F0ID0gY2F0ZWdvcml6ZShuZXh0KSwgYWhlYWQ7XG4gICAgICAgIGlmIChuZXh0Q2F0ID09IENoYXJDYXRlZ29yeS5Xb3JkICYmIG5leHQuY2hhckNvZGVBdCgwKSA8IDEyOCAmJiAvW1xcV19dLy50ZXN0KG5leHQpKVxuICAgICAgICAgICAgbmV4dENhdCA9IC0xOyAvLyBUcmVhdCB3b3JkIHB1bmN0dWF0aW9uIHNwZWNpYWxseVxuICAgICAgICBpZiAoY2F0ID09IENoYXJDYXRlZ29yeS5TcGFjZSlcbiAgICAgICAgICAgIGNhdCA9IG5leHRDYXQ7XG4gICAgICAgIGlmIChjYXQgIT0gbmV4dENhdClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGNhdCA9PSBDaGFyQ2F0ZWdvcnkuV29yZCkge1xuICAgICAgICAgICAgaWYgKG5leHQudG9Mb3dlckNhc2UoKSA9PSBuZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3J3YXJkICYmIHNhd1VwcGVyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2F3TG93ZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2F3TG93ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yd2FyZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHNhd1VwcGVyICYmIGZvcndhcmQgJiYgY2F0ZWdvcml6ZShhaGVhZCA9IHZpZXcuc3RhdGUuc2xpY2VEb2MocG9zLCBwb3MgKyAxKSkgPT0gQ2hhckNhdGVnb3J5LldvcmQgJiZcbiAgICAgICAgICAgICAgICAgICAgYWhlYWQudG9Mb3dlckNhc2UoKSA9PSBhaGVhZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHNhd1VwcGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGVwcysrO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGxldCBlbmQgPSB2aWV3Lm1vdmVCeUNoYXIocmFuZ2UsIGZvcndhcmQsIHN0YXJ0ID0+IHtcbiAgICAgICAgc3RlcChzdGFydCk7XG4gICAgICAgIHJldHVybiBzdGVwO1xuICAgIH0pO1xuICAgIGlmIChzZWdtZW50ZXIgJiYgY2F0ID09IENoYXJDYXRlZ29yeS5Xb3JkICYmIGVuZC5mcm9tID09IHJhbmdlLmZyb20gKyBzdGVwcyAqIChmb3J3YXJkID8gMSA6IC0xKSkge1xuICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWluKHJhbmdlLmhlYWQsIGVuZC5oZWFkKSwgdG8gPSBNYXRoLm1heChyYW5nZS5oZWFkLCBlbmQuaGVhZCk7XG4gICAgICAgIGxldCBza2lwcGVkID0gdmlldy5zdGF0ZS5zbGljZURvYyhmcm9tLCB0byk7XG4gICAgICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDEgJiYgL1tcXHU0RTAwLVxcdWZmZmZdLy50ZXN0KHNraXBwZWQpKSB7XG4gICAgICAgICAgICBsZXQgc2VnbWVudHMgPSBBcnJheS5mcm9tKHNlZ21lbnRlci5zZWdtZW50KHNraXBwZWQpKTtcbiAgICAgICAgICAgIGlmIChzZWdtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcndhcmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmhlYWQgKyBzZWdtZW50c1sxXS5pbmRleCwgLTEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGVuZC5oZWFkICsgc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0uaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbmQ7XG59XG5mdW5jdGlvbiBjdXJzb3JCeVN1YndvcmQodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IHJhbmdlLmVtcHR5ID8gbW92ZUJ5U3Vid29yZCh2aWV3LCByYW5nZSwgZm9yd2FyZCkgOiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGdyb3VwIG9yIGNhbWVsLWNhc2Ugc3Vid29yZCBmb3J3YXJkLlxuKi9cbmNvbnN0IGN1cnNvclN1YndvcmRGb3J3YXJkID0gdmlldyA9PiBjdXJzb3JCeVN1YndvcmQodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgZ3JvdXAgb3IgY2FtZWwtY2FzZSBzdWJ3b3JkIGJhY2t3YXJkLlxuKi9cbmNvbnN0IGN1cnNvclN1YndvcmRCYWNrd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlTdWJ3b3JkKHZpZXcsIGZhbHNlKTtcbmZ1bmN0aW9uIGludGVyZXN0aW5nTm9kZShzdGF0ZSwgbm9kZSwgYnJhY2tldFByb3ApIHtcbiAgICBpZiAobm9kZS50eXBlLnByb3AoYnJhY2tldFByb3ApKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgbGVuID0gbm9kZS50byAtIG5vZGUuZnJvbTtcbiAgICByZXR1cm4gbGVuICYmIChsZW4gPiAyIHx8IC9bXlxccywuOzpdLy50ZXN0KHN0YXRlLnNsaWNlRG9jKG5vZGUuZnJvbSwgbm9kZS50bykpKSB8fCBub2RlLmZpcnN0Q2hpbGQ7XG59XG5mdW5jdGlvbiBtb3ZlQnlTeW50YXgoc3RhdGUsIHN0YXJ0LCBmb3J3YXJkKSB7XG4gICAgbGV0IHBvcyA9IHN5bnRheFRyZWUoc3RhdGUpLnJlc29sdmVJbm5lcihzdGFydC5oZWFkKTtcbiAgICBsZXQgYnJhY2tldFByb3AgPSBmb3J3YXJkID8gTm9kZVByb3AuY2xvc2VkQnkgOiBOb2RlUHJvcC5vcGVuZWRCeTtcbiAgICAvLyBTY2FuIGZvcndhcmQgdGhyb3VnaCBjaGlsZCBub2RlcyB0byBzZWUgaWYgdGhlcmUncyBhbiBpbnRlcmVzdGluZ1xuICAgIC8vIG5vZGUgYWhlYWQuXG4gICAgZm9yIChsZXQgYXQgPSBzdGFydC5oZWFkOzspIHtcbiAgICAgICAgbGV0IG5leHQgPSBmb3J3YXJkID8gcG9zLmNoaWxkQWZ0ZXIoYXQpIDogcG9zLmNoaWxkQmVmb3JlKGF0KTtcbiAgICAgICAgaWYgKCFuZXh0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChpbnRlcmVzdGluZ05vZGUoc3RhdGUsIG5leHQsIGJyYWNrZXRQcm9wKSlcbiAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGF0ID0gZm9yd2FyZCA/IG5leHQudG8gOiBuZXh0LmZyb207XG4gICAgfVxuICAgIGxldCBicmFja2V0ID0gcG9zLnR5cGUucHJvcChicmFja2V0UHJvcCksIG1hdGNoLCBuZXdQb3M7XG4gICAgaWYgKGJyYWNrZXQgJiYgKG1hdGNoID0gZm9yd2FyZCA/IG1hdGNoQnJhY2tldHMoc3RhdGUsIHBvcy5mcm9tLCAxKSA6IG1hdGNoQnJhY2tldHMoc3RhdGUsIHBvcy50bywgLTEpKSAmJiBtYXRjaC5tYXRjaGVkKVxuICAgICAgICBuZXdQb3MgPSBmb3J3YXJkID8gbWF0Y2guZW5kLnRvIDogbWF0Y2guZW5kLmZyb207XG4gICAgZWxzZVxuICAgICAgICBuZXdQb3MgPSBmb3J3YXJkID8gcG9zLnRvIDogcG9zLmZyb207XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobmV3UG9zLCBmb3J3YXJkID8gLTEgOiAxKTtcbn1cbi8qKlxuTW92ZSB0aGUgY3Vyc29yIG92ZXIgdGhlIG5leHQgc3ludGFjdGljIGVsZW1lbnQgdG8gdGhlIGxlZnQuXG4qL1xuY29uc3QgY3Vyc29yU3ludGF4TGVmdCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlTeW50YXgodmlldy5zdGF0ZSwgcmFuZ2UsICFsdHJBdEN1cnNvcih2aWV3KSkpO1xuLyoqXG5Nb3ZlIHRoZSBjdXJzb3Igb3ZlciB0aGUgbmV4dCBzeW50YWN0aWMgZWxlbWVudCB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3QgY3Vyc29yU3ludGF4UmlnaHQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5U3ludGF4KHZpZXcuc3RhdGUsIHJhbmdlLCBsdHJBdEN1cnNvcih2aWV3KSkpO1xuZnVuY3Rpb24gY3Vyc29yQnlMaW5lKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiB7XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpO1xuICAgICAgICBsZXQgbW92ZWQgPSB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkKTtcbiAgICAgICAgcmV0dXJuIG1vdmVkLmhlYWQgIT0gcmFuZ2UuaGVhZCA/IG1vdmVkIDogdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkocmFuZ2UsIGZvcndhcmQpO1xuICAgIH0pO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGxpbmUgdXAuXG4qL1xuY29uc3QgY3Vyc29yTGluZVVwID0gdmlldyA9PiBjdXJzb3JCeUxpbmUodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGxpbmUgZG93bi5cbiovXG5jb25zdCBjdXJzb3JMaW5lRG93biA9IHZpZXcgPT4gY3Vyc29yQnlMaW5lKHZpZXcsIHRydWUpO1xuZnVuY3Rpb24gcGFnZUluZm8odmlldykge1xuICAgIGxldCBzZWxmU2Nyb2xsID0gdmlldy5zY3JvbGxET00uY2xpZW50SGVpZ2h0IDwgdmlldy5zY3JvbGxET00uc2Nyb2xsSGVpZ2h0IC0gMjtcbiAgICBsZXQgbWFyZ2luVG9wID0gMCwgbWFyZ2luQm90dG9tID0gMCwgaGVpZ2h0O1xuICAgIGlmIChzZWxmU2Nyb2xsKSB7XG4gICAgICAgIGZvciAobGV0IHNvdXJjZSBvZiB2aWV3LnN0YXRlLmZhY2V0KEVkaXRvclZpZXcuc2Nyb2xsTWFyZ2lucykpIHtcbiAgICAgICAgICAgIGxldCBtYXJnaW5zID0gc291cmNlKHZpZXcpO1xuICAgICAgICAgICAgaWYgKG1hcmdpbnMgPT09IG51bGwgfHwgbWFyZ2lucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFyZ2lucy50b3ApXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wID0gTWF0aC5tYXgobWFyZ2lucyA9PT0gbnVsbCB8fCBtYXJnaW5zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJnaW5zLnRvcCwgbWFyZ2luVG9wKTtcbiAgICAgICAgICAgIGlmIChtYXJnaW5zID09PSBudWxsIHx8IG1hcmdpbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmdpbnMuYm90dG9tKVxuICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbSA9IE1hdGgubWF4KG1hcmdpbnMgPT09IG51bGwgfHwgbWFyZ2lucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFyZ2lucy5ib3R0b20sIG1hcmdpbkJvdHRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgaGVpZ2h0ID0gdmlldy5zY3JvbGxET00uY2xpZW50SGVpZ2h0IC0gbWFyZ2luVG9wIC0gbWFyZ2luQm90dG9tO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaGVpZ2h0ID0gKHZpZXcuZG9tLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93KS5pbm5lckhlaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWFyZ2luVG9wLCBtYXJnaW5Cb3R0b20sIHNlbGZTY3JvbGwsXG4gICAgICAgIGhlaWdodDogTWF0aC5tYXgodmlldy5kZWZhdWx0TGluZUhlaWdodCwgaGVpZ2h0IC0gNSkgfTtcbn1cbmZ1bmN0aW9uIGN1cnNvckJ5UGFnZSh2aWV3LCBmb3J3YXJkKSB7XG4gICAgbGV0IHBhZ2UgPSBwYWdlSW5mbyh2aWV3KTtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHN0YXRlLnNlbGVjdGlvbiwgcmFuZ2UgPT4ge1xuICAgICAgICByZXR1cm4gcmFuZ2UuZW1wdHkgPyB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkLCBwYWdlLmhlaWdodClcbiAgICAgICAgICAgIDogcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpO1xuICAgIH0pO1xuICAgIGlmIChzZWxlY3Rpb24uZXEoc3RhdGUuc2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBlZmZlY3Q7XG4gICAgaWYgKHBhZ2Uuc2VsZlNjcm9sbCkge1xuICAgICAgICBsZXQgc3RhcnRQb3MgPSB2aWV3LmNvb3Jkc0F0UG9zKHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgICAgICBsZXQgc2Nyb2xsUmVjdCA9IHZpZXcuc2Nyb2xsRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgc2Nyb2xsVG9wID0gc2Nyb2xsUmVjdC50b3AgKyBwYWdlLm1hcmdpblRvcCwgc2Nyb2xsQm90dG9tID0gc2Nyb2xsUmVjdC5ib3R0b20gLSBwYWdlLm1hcmdpbkJvdHRvbTtcbiAgICAgICAgaWYgKHN0YXJ0UG9zICYmIHN0YXJ0UG9zLnRvcCA+IHNjcm9sbFRvcCAmJiBzdGFydFBvcy5ib3R0b20gPCBzY3JvbGxCb3R0b20pXG4gICAgICAgICAgICBlZmZlY3QgPSBFZGl0b3JWaWV3LnNjcm9sbEludG9WaWV3KHNlbGVjdGlvbi5tYWluLmhlYWQsIHsgeTogXCJzdGFydFwiLCB5TWFyZ2luOiBzdGFydFBvcy50b3AgLSBzY3JvbGxUb3AgfSk7XG4gICAgfVxuICAgIHZpZXcuZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pLCB7IGVmZmVjdHM6IGVmZmVjdCB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBwYWdlIHVwLlxuKi9cbmNvbnN0IGN1cnNvclBhZ2VVcCA9IHZpZXcgPT4gY3Vyc29yQnlQYWdlKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBwYWdlIGRvd24uXG4qL1xuY29uc3QgY3Vyc29yUGFnZURvd24gPSB2aWV3ID0+IGN1cnNvckJ5UGFnZSh2aWV3LCB0cnVlKTtcbmZ1bmN0aW9uIG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCBzdGFydCwgZm9yd2FyZCkge1xuICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdChzdGFydC5oZWFkKSwgbW92ZWQgPSB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShzdGFydCwgZm9yd2FyZCk7XG4gICAgaWYgKG1vdmVkLmhlYWQgPT0gc3RhcnQuaGVhZCAmJiBtb3ZlZC5oZWFkICE9IChmb3J3YXJkID8gbGluZS50byA6IGxpbmUuZnJvbSkpXG4gICAgICAgIG1vdmVkID0gdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkoc3RhcnQsIGZvcndhcmQsIGZhbHNlKTtcbiAgICBpZiAoIWZvcndhcmQgJiYgbW92ZWQuaGVhZCA9PSBsaW5lLmZyb20gJiYgbGluZS5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHNwYWNlID0gL15cXHMqLy5leGVjKHZpZXcuc3RhdGUuc2xpY2VEb2MobGluZS5mcm9tLCBNYXRoLm1pbihsaW5lLmZyb20gKyAxMDAsIGxpbmUudG8pKSlbMF0ubGVuZ3RoO1xuICAgICAgICBpZiAoc3BhY2UgJiYgc3RhcnQuaGVhZCAhPSBsaW5lLmZyb20gKyBzcGFjZSlcbiAgICAgICAgICAgIG1vdmVkID0gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihsaW5lLmZyb20gKyBzcGFjZSk7XG4gICAgfVxuICAgIHJldHVybiBtb3ZlZDtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBuZXh0IGxpbmUgd3JhcCBwb2ludCwgb3IgdG8gdGhlIGVuZCBvZlxudGhlIGxpbmUgaWYgdGhlcmUgaXNuJ3Qgb25lIGxlZnQgb24gdGhpcyBsaW5lLlxuKi9cbmNvbnN0IGN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCB0cnVlKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byBwcmV2aW91cyBsaW5lIHdyYXAgcG9pbnQsIG9yIGZhaWxpbmcgdGhhdCB0b1xudGhlIHN0YXJ0IG9mIHRoZSBsaW5lLiBJZiB0aGUgbGluZSBpcyBpbmRlbnRlZCwgYW5kIHRoZSBjdXJzb3Jcbmlzbid0IGFscmVhZHkgYXQgdGhlIGVuZCBvZiB0aGUgaW5kZW50YXRpb24sIHRoaXMgd2lsbCBtb3ZlIHRvIHRoZVxuZW5kIG9mIHRoZSBpbmRlbnRhdGlvbiBpbnN0ZWFkIG9mIHRoZSBzdGFydCBvZiB0aGUgbGluZS5cbiovXG5jb25zdCBjdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsIGZhbHNlKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgbGluZSB3cmFwIHBvaW50IHRvIHRoZSBsZWZ0LlxuKi9cbmNvbnN0IGN1cnNvckxpbmVCb3VuZGFyeUxlZnQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCAhbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBsaW5lIHdyYXAgcG9pbnQgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IGN1cnNvckxpbmVCb3VuZGFyeVJpZ2h0ID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBzdGFydCBvZiB0aGUgbGluZS5cbiovXG5jb25zdCBjdXJzb3JMaW5lU3RhcnQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLmhlYWQpLmZyb20sIDEpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4qL1xuY29uc3QgY3Vyc29yTGluZUVuZCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHZpZXcubGluZUJsb2NrQXQocmFuZ2UuaGVhZCkudG8sIC0xKSk7XG5mdW5jdGlvbiB0b01hdGNoaW5nQnJhY2tldChzdGF0ZSwgZGlzcGF0Y2gsIGV4dGVuZCkge1xuICAgIGxldCBmb3VuZCA9IGZhbHNlLCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwoc3RhdGUuc2VsZWN0aW9uLCByYW5nZSA9PiB7XG4gICAgICAgIGxldCBtYXRjaGluZyA9IG1hdGNoQnJhY2tldHMoc3RhdGUsIHJhbmdlLmhlYWQsIC0xKVxuICAgICAgICAgICAgfHwgbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcmFuZ2UuaGVhZCwgMSlcbiAgICAgICAgICAgIHx8IChyYW5nZS5oZWFkID4gMCAmJiBtYXRjaEJyYWNrZXRzKHN0YXRlLCByYW5nZS5oZWFkIC0gMSwgMSkpXG4gICAgICAgICAgICB8fCAocmFuZ2UuaGVhZCA8IHN0YXRlLmRvYy5sZW5ndGggJiYgbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcmFuZ2UuaGVhZCArIDEsIC0xKSk7XG4gICAgICAgIGlmICghbWF0Y2hpbmcgfHwgIW1hdGNoaW5nLmVuZClcbiAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICBsZXQgaGVhZCA9IG1hdGNoaW5nLnN0YXJ0LmZyb20gPT0gcmFuZ2UuaGVhZCA/IG1hdGNoaW5nLmVuZC50byA6IG1hdGNoaW5nLmVuZC5mcm9tO1xuICAgICAgICByZXR1cm4gZXh0ZW5kID8gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmFuY2hvciwgaGVhZCkgOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGhlYWQpO1xuICAgIH0pO1xuICAgIGlmICghZm91bmQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGJyYWNrZXQgbWF0Y2hpbmcgdGhlIG9uZSBpdCBpcyBjdXJyZW50bHlcbm9uLCBpZiBhbnkuXG4qL1xuY29uc3QgY3Vyc29yTWF0Y2hpbmdCcmFja2V0ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHRvTWF0Y2hpbmdCcmFja2V0KHN0YXRlLCBkaXNwYXRjaCwgZmFsc2UpO1xuLyoqXG5FeHRlbmQgdGhlIHNlbGVjdGlvbiB0byB0aGUgYnJhY2tldCBtYXRjaGluZyB0aGUgb25lIHRoZSBzZWxlY3Rpb25cbmhlYWQgaXMgY3VycmVudGx5IG9uLCBpZiBhbnkuXG4qL1xuY29uc3Qgc2VsZWN0TWF0Y2hpbmdCcmFja2V0ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHRvTWF0Y2hpbmdCcmFja2V0KHN0YXRlLCBkaXNwYXRjaCwgdHJ1ZSk7XG5mdW5jdGlvbiBleHRlbmRTZWwodmlldywgaG93KSB7XG4gICAgbGV0IHNlbGVjdGlvbiA9IHVwZGF0ZVNlbCh2aWV3LnN0YXRlLnNlbGVjdGlvbiwgcmFuZ2UgPT4ge1xuICAgICAgICBsZXQgaGVhZCA9IGhvdyhyYW5nZSk7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UocmFuZ2UuYW5jaG9yLCBoZWFkLmhlYWQsIGhlYWQuZ29hbENvbHVtbiwgaGVhZC5iaWRpTGV2ZWwgfHwgdW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgICBpZiAoc2VsZWN0aW9uLmVxKHZpZXcuc3RhdGUuc2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goc2V0U2VsKHZpZXcuc3RhdGUsIHNlbGVjdGlvbikpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc2VsZWN0QnlDaGFyKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IHZpZXcubW92ZUJ5Q2hhcihyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgY2hhcmFjdGVyIHRvIHRoZSBsZWZ0LCB3aGlsZSBsZWF2aW5nXG50aGUgYW5jaG9yIGluIHBsYWNlLlxuKi9cbmNvbnN0IHNlbGVjdENoYXJMZWZ0ID0gdmlldyA9PiBzZWxlY3RCeUNoYXIodmlldywgIWx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGNoYXJhY3RlciB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3Qgc2VsZWN0Q2hhclJpZ2h0ID0gdmlldyA9PiBzZWxlY3RCeUNoYXIodmlldywgbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgY2hhcmFjdGVyIGZvcndhcmQuXG4qL1xuY29uc3Qgc2VsZWN0Q2hhckZvcndhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5Q2hhcih2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGNoYXJhY3RlciBiYWNrd2FyZC5cbiovXG5jb25zdCBzZWxlY3RDaGFyQmFja3dhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5Q2hhcih2aWV3LCBmYWxzZSk7XG5mdW5jdGlvbiBzZWxlY3RCeUdyb3VwKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IHZpZXcubW92ZUJ5R3JvdXAocmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIFtncm91cF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JHcm91cExlZnQpIHRvXG50aGUgbGVmdC5cbiovXG5jb25zdCBzZWxlY3RHcm91cExlZnQgPSB2aWV3ID0+IHNlbGVjdEJ5R3JvdXAodmlldywgIWx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBzZWxlY3RHcm91cFJpZ2h0ID0gdmlldyA9PiBzZWxlY3RCeUdyb3VwKHZpZXcsIGx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIGZvcndhcmQuXG4qL1xuY29uc3Qgc2VsZWN0R3JvdXBGb3J3YXJkID0gdmlldyA9PiBzZWxlY3RCeUdyb3VwKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgZ3JvdXAgYmFja3dhcmQuXG4qL1xuY29uc3Qgc2VsZWN0R3JvdXBCYWNrd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlHcm91cCh2aWV3LCBmYWxzZSk7XG5mdW5jdGlvbiBzZWxlY3RCeVN1YndvcmQodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5U3Vid29yZCh2aWV3LCByYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgZ3JvdXAgb3IgY2FtZWwtY2FzZSBzdWJ3b3JkIGZvcndhcmQuXG4qL1xuY29uc3Qgc2VsZWN0U3Vid29yZEZvcndhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5U3Vid29yZCh2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIG9yIHN1YndvcmQgYmFja3dhcmQuXG4qL1xuY29uc3Qgc2VsZWN0U3Vid29yZEJhY2t3YXJkID0gdmlldyA9PiBzZWxlY3RCeVN1YndvcmQodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvdmVyIHRoZSBuZXh0IHN5bnRhY3RpYyBlbGVtZW50IHRvIHRoZSBsZWZ0LlxuKi9cbmNvbnN0IHNlbGVjdFN5bnRheExlZnQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlTeW50YXgodmlldy5zdGF0ZSwgcmFuZ2UsICFsdHJBdEN1cnNvcih2aWV3KSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvdmVyIHRoZSBuZXh0IHN5bnRhY3RpYyBlbGVtZW50IHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBzZWxlY3RTeW50YXhSaWdodCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeVN5bnRheCh2aWV3LnN0YXRlLCByYW5nZSwgbHRyQXRDdXJzb3IodmlldykpKTtcbmZ1bmN0aW9uIHNlbGVjdEJ5TGluZSh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBsaW5lIHVwLlxuKi9cbmNvbnN0IHNlbGVjdExpbmVVcCA9IHZpZXcgPT4gc2VsZWN0QnlMaW5lKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGxpbmUgZG93bi5cbiovXG5jb25zdCBzZWxlY3RMaW5lRG93biA9IHZpZXcgPT4gc2VsZWN0QnlMaW5lKHZpZXcsIHRydWUpO1xuZnVuY3Rpb24gc2VsZWN0QnlQYWdlKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IHZpZXcubW92ZVZlcnRpY2FsbHkocmFuZ2UsIGZvcndhcmQsIHBhZ2VJbmZvKHZpZXcpLmhlaWdodCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgcGFnZSB1cC5cbiovXG5jb25zdCBzZWxlY3RQYWdlVXAgPSB2aWV3ID0+IHNlbGVjdEJ5UGFnZSh2aWV3LCBmYWxzZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBwYWdlIGRvd24uXG4qL1xuY29uc3Qgc2VsZWN0UGFnZURvd24gPSB2aWV3ID0+IHNlbGVjdEJ5UGFnZSh2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIG5leHQgbGluZSBib3VuZGFyeS5cbiovXG5jb25zdCBzZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCB0cnVlKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBwcmV2aW91cyBsaW5lIGJvdW5kYXJ5LlxuKi9cbmNvbnN0IHNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCBmYWxzZSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgbGluZSBib3VuZGFyeSB0byB0aGUgbGVmdC5cbiovXG5jb25zdCBzZWxlY3RMaW5lQm91bmRhcnlMZWZ0ID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCAhbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGxpbmUgYm91bmRhcnkgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IHNlbGVjdExpbmVCb3VuZGFyeVJpZ2h0ID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCBsdHJBdEN1cnNvcih2aWV3KSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgc3RhcnQgb2YgdGhlIGxpbmUuXG4qL1xuY29uc3Qgc2VsZWN0TGluZVN0YXJ0ID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLmhlYWQpLmZyb20pKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIGVuZCBvZiB0aGUgbGluZS5cbiovXG5jb25zdCBzZWxlY3RMaW5lRW5kID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLmhlYWQpLnRvKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgc3RhcnQgb2YgdGhlIGRvY3VtZW50LlxuKi9cbmNvbnN0IGN1cnNvckRvY1N0YXJ0ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHsgYW5jaG9yOiAwIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cbiovXG5jb25zdCBjdXJzb3JEb2NFbmQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgeyBhbmNob3I6IHN0YXRlLmRvYy5sZW5ndGggfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIHN0YXJ0IG9mIHRoZSBkb2N1bWVudC5cbiovXG5jb25zdCBzZWxlY3REb2NTdGFydCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCB7IGFuY2hvcjogc3RhdGUuc2VsZWN0aW9uLm1haW4uYW5jaG9yLCBoZWFkOiAwIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuKi9cbmNvbnN0IHNlbGVjdERvY0VuZCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCB7IGFuY2hvcjogc3RhdGUuc2VsZWN0aW9uLm1haW4uYW5jaG9yLCBoZWFkOiBzdGF0ZS5kb2MubGVuZ3RoIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblNlbGVjdCB0aGUgZW50aXJlIGRvY3VtZW50LlxuKi9cbmNvbnN0IHNlbGVjdEFsbCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHsgc2VsZWN0aW9uOiB7IGFuY2hvcjogMCwgaGVhZDogc3RhdGUuZG9jLmxlbmd0aCB9LCB1c2VyRXZlbnQ6IFwic2VsZWN0XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuRXhwYW5kIHRoZSBzZWxlY3Rpb24gdG8gY292ZXIgZW50aXJlIGxpbmVzLlxuKi9cbmNvbnN0IHNlbGVjdExpbmUgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCByYW5nZXMgPSBzZWxlY3RlZExpbmVCbG9ja3Moc3RhdGUpLm1hcCgoeyBmcm9tLCB0byB9KSA9PiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSwgTWF0aC5taW4odG8gKyAxLCBzdGF0ZS5kb2MubGVuZ3RoKSkpO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMpLCB1c2VyRXZlbnQ6IFwic2VsZWN0XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuU2VsZWN0IHRoZSBuZXh0IHN5bnRhY3RpYyBjb25zdHJ1Y3QgdGhhdCBpcyBsYXJnZXIgdGhhbiB0aGVcbnNlbGVjdGlvbi4gTm90ZSB0aGF0IHRoaXMgd2lsbCBvbmx5IHdvcmsgaW5zb2ZhciBhcyB0aGUgbGFuZ3VhZ2Vcbltwcm92aWRlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5sYW5ndWFnZSkgeW91IHVzZSBidWlsZHMgdXAgYSBmdWxsXG5zeW50YXggdHJlZS5cbiovXG5jb25zdCBzZWxlY3RQYXJlbnRTeW50YXggPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwoc3RhdGUuc2VsZWN0aW9uLCByYW5nZSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IHN0YWNrID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZVN0YWNrKHJhbmdlLmZyb20sIDEpO1xuICAgICAgICBmb3IgKGxldCBjdXIgPSBzdGFjazsgY3VyOyBjdXIgPSBjdXIubmV4dCkge1xuICAgICAgICAgICAgbGV0IHsgbm9kZSB9ID0gY3VyO1xuICAgICAgICAgICAgaWYgKCgobm9kZS5mcm9tIDwgcmFuZ2UuZnJvbSAmJiBub2RlLnRvID49IHJhbmdlLnRvKSB8fFxuICAgICAgICAgICAgICAgIChub2RlLnRvID4gcmFuZ2UudG8gJiYgbm9kZS5mcm9tIDw9IHJhbmdlLmZyb20pKSAmJlxuICAgICAgICAgICAgICAgICgoX2EgPSBub2RlLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhcmVudCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShub2RlLnRvLCBub2RlLmZyb20pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9KTtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuU2ltcGxpZnkgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBXaGVuIG11bHRpcGxlIHJhbmdlcyBhcmUgc2VsZWN0ZWQsXG5yZWR1Y2UgaXQgdG8gaXRzIG1haW4gcmFuZ2UuIE90aGVyd2lzZSwgaWYgdGhlIHNlbGVjdGlvbiBpc1xubm9uLWVtcHR5LCBjb252ZXJ0IGl0IHRvIGEgY3Vyc29yIHNlbGVjdGlvbi5cbiovXG5jb25zdCBzaW1wbGlmeVNlbGVjdGlvbiA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IGN1ciA9IHN0YXRlLnNlbGVjdGlvbiwgc2VsZWN0aW9uID0gbnVsbDtcbiAgICBpZiAoY3VyLnJhbmdlcy5sZW5ndGggPiAxKVxuICAgICAgICBzZWxlY3Rpb24gPSBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKFtjdXIubWFpbl0pO1xuICAgIGVsc2UgaWYgKCFjdXIubWFpbi5lbXB0eSlcbiAgICAgICAgc2VsZWN0aW9uID0gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShbRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihjdXIubWFpbi5oZWFkKV0pO1xuICAgIGlmICghc2VsZWN0aW9uKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBkZWxldGVCeSh0YXJnZXQsIGJ5KSB7XG4gICAgaWYgKHRhcmdldC5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBldmVudCA9IFwiZGVsZXRlLnNlbGVjdGlvblwiLCB7IHN0YXRlIH0gPSB0YXJnZXQ7XG4gICAgbGV0IGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHJhbmdlO1xuICAgICAgICBpZiAoZnJvbSA9PSB0bykge1xuICAgICAgICAgICAgbGV0IHRvd2FyZHMgPSBieShyYW5nZSk7XG4gICAgICAgICAgICBpZiAodG93YXJkcyA8IGZyb20pIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IFwiZGVsZXRlLmJhY2t3YXJkXCI7XG4gICAgICAgICAgICAgICAgdG93YXJkcyA9IHNraXBBdG9taWModGFyZ2V0LCB0b3dhcmRzLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b3dhcmRzID4gZnJvbSkge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gXCJkZWxldGUuZm9yd2FyZFwiO1xuICAgICAgICAgICAgICAgIHRvd2FyZHMgPSBza2lwQXRvbWljKHRhcmdldCwgdG93YXJkcywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcm9tID0gTWF0aC5taW4oZnJvbSwgdG93YXJkcyk7XG4gICAgICAgICAgICB0byA9IE1hdGgubWF4KHRvLCB0b3dhcmRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZyb20gPSBza2lwQXRvbWljKHRhcmdldCwgZnJvbSwgZmFsc2UpO1xuICAgICAgICAgICAgdG8gPSBza2lwQXRvbWljKHRhcmdldCwgdG8sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcm9tID09IHRvID8geyByYW5nZSB9IDogeyBjaGFuZ2VzOiB7IGZyb20sIHRvIH0sIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZyb20sIGZyb20gPCByYW5nZS5oZWFkID8gLTEgOiAxKSB9O1xuICAgIH0pO1xuICAgIGlmIChjaGFuZ2VzLmNoYW5nZXMuZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0YXJnZXQuZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHtcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgIHVzZXJFdmVudDogZXZlbnQsXG4gICAgICAgIGVmZmVjdHM6IGV2ZW50ID09IFwiZGVsZXRlLnNlbGVjdGlvblwiID8gRWRpdG9yVmlldy5hbm5vdW5jZS5vZihzdGF0ZS5waHJhc2UoXCJTZWxlY3Rpb24gZGVsZXRlZFwiKSkgOiB1bmRlZmluZWRcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBza2lwQXRvbWljKHRhcmdldCwgcG9zLCBmb3J3YXJkKSB7XG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEVkaXRvclZpZXcpXG4gICAgICAgIGZvciAobGV0IHJhbmdlcyBvZiB0YXJnZXQuc3RhdGUuZmFjZXQoRWRpdG9yVmlldy5hdG9taWNSYW5nZXMpLm1hcChmID0+IGYodGFyZ2V0KSkpXG4gICAgICAgICAgICByYW5nZXMuYmV0d2Vlbihwb3MsIHBvcywgKGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPCBwb3MgJiYgdG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGZvcndhcmQgPyB0byA6IGZyb207XG4gICAgICAgICAgICB9KTtcbiAgICByZXR1cm4gcG9zO1xufVxuY29uc3QgZGVsZXRlQnlDaGFyID0gKHRhcmdldCwgZm9yd2FyZCkgPT4gZGVsZXRlQnkodGFyZ2V0LCByYW5nZSA9PiB7XG4gICAgbGV0IHBvcyA9IHJhbmdlLmZyb20sIHsgc3RhdGUgfSA9IHRhcmdldCwgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKSwgYmVmb3JlLCB0YXJnZXRQb3M7XG4gICAgaWYgKCFmb3J3YXJkICYmIHBvcyA+IGxpbmUuZnJvbSAmJiBwb3MgPCBsaW5lLmZyb20gKyAyMDAgJiZcbiAgICAgICAgIS9bXiBcXHRdLy50ZXN0KGJlZm9yZSA9IGxpbmUudGV4dC5zbGljZSgwLCBwb3MgLSBsaW5lLmZyb20pKSkge1xuICAgICAgICBpZiAoYmVmb3JlW2JlZm9yZS5sZW5ndGggLSAxXSA9PSBcIlxcdFwiKVxuICAgICAgICAgICAgcmV0dXJuIHBvcyAtIDE7XG4gICAgICAgIGxldCBjb2wgPSBjb3VudENvbHVtbihiZWZvcmUsIHN0YXRlLnRhYlNpemUpLCBkcm9wID0gY29sICUgZ2V0SW5kZW50VW5pdChzdGF0ZSkgfHwgZ2V0SW5kZW50VW5pdChzdGF0ZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHJvcCAmJiBiZWZvcmVbYmVmb3JlLmxlbmd0aCAtIDEgLSBpXSA9PSBcIiBcIjsgaSsrKVxuICAgICAgICAgICAgcG9zLS07XG4gICAgICAgIHRhcmdldFBvcyA9IHBvcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRhcmdldFBvcyA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBwb3MgLSBsaW5lLmZyb20sIGZvcndhcmQsIGZvcndhcmQpICsgbGluZS5mcm9tO1xuICAgICAgICBpZiAodGFyZ2V0UG9zID09IHBvcyAmJiBsaW5lLm51bWJlciAhPSAoZm9yd2FyZCA/IHN0YXRlLmRvYy5saW5lcyA6IDEpKVxuICAgICAgICAgICAgdGFyZ2V0UG9zICs9IGZvcndhcmQgPyAxIDogLTE7XG4gICAgICAgIGVsc2UgaWYgKCFmb3J3YXJkICYmIC9bXFx1ZmUwMC1cXHVmZTBmXS8udGVzdChsaW5lLnRleHQuc2xpY2UodGFyZ2V0UG9zIC0gbGluZS5mcm9tLCBwb3MgLSBsaW5lLmZyb20pKSlcbiAgICAgICAgICAgIHRhcmdldFBvcyA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCB0YXJnZXRQb3MgLSBsaW5lLmZyb20sIGZhbHNlLCBmYWxzZSkgKyBsaW5lLmZyb207XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRQb3M7XG59KTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24sIG9yLCBmb3IgY3Vyc29yIHNlbGVjdGlvbnMsIHRoZSBjaGFyYWN0ZXJcbmJlZm9yZSB0aGUgY3Vyc29yLlxuKi9cbmNvbnN0IGRlbGV0ZUNoYXJCYWNrd2FyZCA9IHZpZXcgPT4gZGVsZXRlQnlDaGFyKHZpZXcsIGZhbHNlKTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24gb3IgdGhlIGNoYXJhY3RlciBhZnRlciB0aGUgY3Vyc29yLlxuKi9cbmNvbnN0IGRlbGV0ZUNoYXJGb3J3YXJkID0gdmlldyA9PiBkZWxldGVCeUNoYXIodmlldywgdHJ1ZSk7XG5jb25zdCBkZWxldGVCeUdyb3VwID0gKHRhcmdldCwgZm9yd2FyZCkgPT4gZGVsZXRlQnkodGFyZ2V0LCByYW5nZSA9PiB7XG4gICAgbGV0IHBvcyA9IHJhbmdlLmhlYWQsIHsgc3RhdGUgfSA9IHRhcmdldCwgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICBsZXQgY2F0ZWdvcml6ZSA9IHN0YXRlLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgIGZvciAobGV0IGNhdCA9IG51bGw7Oykge1xuICAgICAgICBpZiAocG9zID09IChmb3J3YXJkID8gbGluZS50byA6IGxpbmUuZnJvbSkpIHtcbiAgICAgICAgICAgIGlmIChwb3MgPT0gcmFuZ2UuaGVhZCAmJiBsaW5lLm51bWJlciAhPSAoZm9yd2FyZCA/IHN0YXRlLmRvYy5saW5lcyA6IDEpKVxuICAgICAgICAgICAgICAgIHBvcyArPSBmb3J3YXJkID8gMSA6IC0xO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHQgPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgcG9zIC0gbGluZS5mcm9tLCBmb3J3YXJkKSArIGxpbmUuZnJvbTtcbiAgICAgICAgbGV0IG5leHRDaGFyID0gbGluZS50ZXh0LnNsaWNlKE1hdGgubWluKHBvcywgbmV4dCkgLSBsaW5lLmZyb20sIE1hdGgubWF4KHBvcywgbmV4dCkgLSBsaW5lLmZyb20pO1xuICAgICAgICBsZXQgbmV4dENhdCA9IGNhdGVnb3JpemUobmV4dENoYXIpO1xuICAgICAgICBpZiAoY2F0ICE9IG51bGwgJiYgbmV4dENhdCAhPSBjYXQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKG5leHRDaGFyICE9IFwiIFwiIHx8IHBvcyAhPSByYW5nZS5oZWFkKVxuICAgICAgICAgICAgY2F0ID0gbmV4dENhdDtcbiAgICAgICAgcG9zID0gbmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHBvcztcbn0pO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiBvciBiYWNrd2FyZCB1bnRpbCB0aGUgZW5kIG9mIHRoZSBuZXh0XG5bZ3JvdXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3Lm1vdmVCeUdyb3VwKSwgb25seSBza2lwcGluZyBncm91cHMgb2ZcbndoaXRlc3BhY2Ugd2hlbiB0aGV5IGNvbnNpc3Qgb2YgYSBzaW5nbGUgc3BhY2UuXG4qL1xuY29uc3QgZGVsZXRlR3JvdXBCYWNrd2FyZCA9IHRhcmdldCA9PiBkZWxldGVCeUdyb3VwKHRhcmdldCwgZmFsc2UpO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiBvciBmb3J3YXJkIHVudGlsIHRoZSBlbmQgb2YgdGhlIG5leHQgZ3JvdXAuXG4qL1xuY29uc3QgZGVsZXRlR3JvdXBGb3J3YXJkID0gdGFyZ2V0ID0+IGRlbGV0ZUJ5R3JvdXAodGFyZ2V0LCB0cnVlKTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24sIG9yLCBpZiBpdCBpcyBhIGN1cnNvciBzZWxlY3Rpb24sIGRlbGV0ZSB0b1xudGhlIGVuZCBvZiB0aGUgbGluZS4gSWYgdGhlIGN1cnNvciBpcyBkaXJlY3RseSBhdCB0aGUgZW5kIG9mIHRoZVxubGluZSwgZGVsZXRlIHRoZSBsaW5lIGJyZWFrIGFmdGVyIGl0LlxuKi9cbmNvbnN0IGRlbGV0ZVRvTGluZUVuZCA9IHZpZXcgPT4gZGVsZXRlQnkodmlldywgcmFuZ2UgPT4ge1xuICAgIGxldCBsaW5lRW5kID0gdmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKS50bztcbiAgICByZXR1cm4gcmFuZ2UuaGVhZCA8IGxpbmVFbmQgPyBsaW5lRW5kIDogTWF0aC5taW4odmlldy5zdGF0ZS5kb2MubGVuZ3RoLCByYW5nZS5oZWFkICsgMSk7XG59KTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24sIG9yLCBpZiBpdCBpcyBhIGN1cnNvciBzZWxlY3Rpb24sIGRlbGV0ZSB0b1xudGhlIHN0YXJ0IG9mIHRoZSBsaW5lLiBJZiB0aGUgY3Vyc29yIGlzIGRpcmVjdGx5IGF0IHRoZSBzdGFydCBvZiB0aGVcbmxpbmUsIGRlbGV0ZSB0aGUgbGluZSBicmVhayBiZWZvcmUgaXQuXG4qL1xuY29uc3QgZGVsZXRlVG9MaW5lU3RhcnQgPSB2aWV3ID0+IGRlbGV0ZUJ5KHZpZXcsIHJhbmdlID0+IHtcbiAgICBsZXQgbGluZVN0YXJ0ID0gdmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKS5mcm9tO1xuICAgIHJldHVybiByYW5nZS5oZWFkID4gbGluZVN0YXJ0ID8gbGluZVN0YXJ0IDogTWF0aC5tYXgoMCwgcmFuZ2UuaGVhZCAtIDEpO1xufSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBvciwgaWYgaXQgaXMgYSBjdXJzb3Igc2VsZWN0aW9uLCBkZWxldGUgdG9cbnRoZSBzdGFydCBvZiB0aGUgbGluZSBvciB0aGUgbmV4dCBsaW5lIHdyYXAgYmVmb3JlIHRoZSBjdXJzb3IuXG4qL1xuY29uc3QgZGVsZXRlTGluZUJvdW5kYXJ5QmFja3dhcmQgPSB2aWV3ID0+IGRlbGV0ZUJ5KHZpZXcsIHJhbmdlID0+IHtcbiAgICBsZXQgbGluZVN0YXJ0ID0gdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkocmFuZ2UsIGZhbHNlKS5oZWFkO1xuICAgIHJldHVybiByYW5nZS5oZWFkID4gbGluZVN0YXJ0ID8gbGluZVN0YXJ0IDogTWF0aC5tYXgoMCwgcmFuZ2UuaGVhZCAtIDEpO1xufSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBvciwgaWYgaXQgaXMgYSBjdXJzb3Igc2VsZWN0aW9uLCBkZWxldGUgdG9cbnRoZSBlbmQgb2YgdGhlIGxpbmUgb3IgdGhlIG5leHQgbGluZSB3cmFwIGFmdGVyIHRoZSBjdXJzb3IuXG4qL1xuY29uc3QgZGVsZXRlTGluZUJvdW5kYXJ5Rm9yd2FyZCA9IHZpZXcgPT4gZGVsZXRlQnkodmlldywgcmFuZ2UgPT4ge1xuICAgIGxldCBsaW5lU3RhcnQgPSB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShyYW5nZSwgdHJ1ZSkuaGVhZDtcbiAgICByZXR1cm4gcmFuZ2UuaGVhZCA8IGxpbmVTdGFydCA/IGxpbmVTdGFydCA6IE1hdGgubWluKHZpZXcuc3RhdGUuZG9jLmxlbmd0aCwgcmFuZ2UuaGVhZCArIDEpO1xufSk7XG4vKipcbkRlbGV0ZSBhbGwgd2hpdGVzcGFjZSBkaXJlY3RseSBiZWZvcmUgYSBsaW5lIGVuZCBmcm9tIHRoZVxuZG9jdW1lbnQuXG4qL1xuY29uc3QgZGVsZXRlVHJhaWxpbmdXaGl0ZXNwYWNlID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IHBvcyA9IDAsIHByZXYgPSBcIlwiLCBpdGVyID0gc3RhdGUuZG9jLml0ZXIoKTs7KSB7XG4gICAgICAgIGl0ZXIubmV4dCgpO1xuICAgICAgICBpZiAoaXRlci5saW5lQnJlYWsgfHwgaXRlci5kb25lKSB7XG4gICAgICAgICAgICBsZXQgdHJhaWxpbmcgPSBwcmV2LnNlYXJjaCgvXFxzKyQvKTtcbiAgICAgICAgICAgIGlmICh0cmFpbGluZyA+IC0xKVxuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IHBvcyAtIChwcmV2Lmxlbmd0aCAtIHRyYWlsaW5nKSwgdG86IHBvcyB9KTtcbiAgICAgICAgICAgIGlmIChpdGVyLmRvbmUpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwcmV2ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByZXYgPSBpdGVyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBpdGVyLnZhbHVlLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKCFjaGFuZ2VzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IGNoYW5nZXMsIHVzZXJFdmVudDogXCJkZWxldGVcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5SZXBsYWNlIGVhY2ggc2VsZWN0aW9uIHJhbmdlIHdpdGggYSBsaW5lIGJyZWFrLCBsZWF2aW5nIHRoZSBjdXJzb3Jcbm9uIHRoZSBsaW5lIGJlZm9yZSB0aGUgYnJlYWsuXG4qL1xuY29uc3Qgc3BsaXRMaW5lID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmZyb20sIHRvOiByYW5nZS50bywgaW5zZXJ0OiBUZXh0Lm9mKFtcIlwiLCBcIlwiXSkgfSxcbiAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20pIH07XG4gICAgfSk7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJpbnB1dFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkZsaXAgdGhlIGNoYXJhY3RlcnMgYmVmb3JlIGFuZCBhZnRlciB0aGUgY3Vyc29yKHMpLlxuKi9cbmNvbnN0IHRyYW5zcG9zZUNoYXJzID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5IHx8IHJhbmdlLmZyb20gPT0gMCB8fCByYW5nZS5mcm9tID09IHN0YXRlLmRvYy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4geyByYW5nZSB9O1xuICAgICAgICBsZXQgcG9zID0gcmFuZ2UuZnJvbSwgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgbGV0IGZyb20gPSBwb3MgPT0gbGluZS5mcm9tID8gcG9zIC0gMSA6IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBwb3MgLSBsaW5lLmZyb20sIGZhbHNlKSArIGxpbmUuZnJvbTtcbiAgICAgICAgbGV0IHRvID0gcG9zID09IGxpbmUudG8gPyBwb3MgKyAxIDogZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHBvcyAtIGxpbmUuZnJvbSwgdHJ1ZSkgKyBsaW5lLmZyb207XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbSwgdG8sIGluc2VydDogc3RhdGUuZG9jLnNsaWNlKHBvcywgdG8pLmFwcGVuZChzdGF0ZS5kb2Muc2xpY2UoZnJvbSwgcG9zKSkgfSxcbiAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHRvKSB9O1xuICAgIH0pO1xuICAgIGlmIChjaGFuZ2VzLmNoYW5nZXMuZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcIm1vdmUuY2hhcmFjdGVyXCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIHNlbGVjdGVkTGluZUJsb2NrcyhzdGF0ZSkge1xuICAgIGxldCBibG9ja3MgPSBbXSwgdXB0byA9IC0xO1xuICAgIGZvciAobGV0IHJhbmdlIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgbGV0IHN0YXJ0TGluZSA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UuZnJvbSksIGVuZExpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHJhbmdlLnRvKTtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSAmJiByYW5nZS50byA9PSBlbmRMaW5lLmZyb20pXG4gICAgICAgICAgICBlbmRMaW5lID0gc3RhdGUuZG9jLmxpbmVBdChyYW5nZS50byAtIDEpO1xuICAgICAgICBpZiAodXB0byA+PSBzdGFydExpbmUubnVtYmVyKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IGJsb2Nrc1tibG9ja3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBwcmV2LnRvID0gZW5kTGluZS50bztcbiAgICAgICAgICAgIHByZXYucmFuZ2VzLnB1c2gocmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmxvY2tzLnB1c2goeyBmcm9tOiBzdGFydExpbmUuZnJvbSwgdG86IGVuZExpbmUudG8sIHJhbmdlczogW3JhbmdlXSB9KTtcbiAgICAgICAgfVxuICAgICAgICB1cHRvID0gZW5kTGluZS5udW1iZXIgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gYmxvY2tzO1xufVxuZnVuY3Rpb24gbW92ZUxpbmUoc3RhdGUsIGRpc3BhdGNoLCBmb3J3YXJkKSB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBbXSwgcmFuZ2VzID0gW107XG4gICAgZm9yIChsZXQgYmxvY2sgb2Ygc2VsZWN0ZWRMaW5lQmxvY2tzKHN0YXRlKSkge1xuICAgICAgICBpZiAoZm9yd2FyZCA/IGJsb2NrLnRvID09IHN0YXRlLmRvYy5sZW5ndGggOiBibG9jay5mcm9tID09IDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IG5leHRMaW5lID0gc3RhdGUuZG9jLmxpbmVBdChmb3J3YXJkID8gYmxvY2sudG8gKyAxIDogYmxvY2suZnJvbSAtIDEpO1xuICAgICAgICBsZXQgc2l6ZSA9IG5leHRMaW5lLmxlbmd0aCArIDE7XG4gICAgICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBibG9jay50bywgdG86IG5leHRMaW5lLnRvIH0sIHsgZnJvbTogYmxvY2suZnJvbSwgaW5zZXJ0OiBuZXh0TGluZS50ZXh0ICsgc3RhdGUubGluZUJyZWFrIH0pO1xuICAgICAgICAgICAgZm9yIChsZXQgciBvZiBibG9jay5yYW5nZXMpXG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLnJhbmdlKE1hdGgubWluKHN0YXRlLmRvYy5sZW5ndGgsIHIuYW5jaG9yICsgc2l6ZSksIE1hdGgubWluKHN0YXRlLmRvYy5sZW5ndGgsIHIuaGVhZCArIHNpemUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBuZXh0TGluZS5mcm9tLCB0bzogYmxvY2suZnJvbSB9LCB7IGZyb206IGJsb2NrLnRvLCBpbnNlcnQ6IHN0YXRlLmxpbmVCcmVhayArIG5leHRMaW5lLnRleHQgfSk7XG4gICAgICAgICAgICBmb3IgKGxldCByIG9mIGJsb2NrLnJhbmdlcylcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChFZGl0b3JTZWxlY3Rpb24ucmFuZ2Uoci5hbmNob3IgLSBzaXplLCByLmhlYWQgLSBzaXplKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjaGFuZ2VzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgIGNoYW5nZXMsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLCBzdGF0ZS5zZWxlY3Rpb24ubWFpbkluZGV4KSxcbiAgICAgICAgdXNlckV2ZW50OiBcIm1vdmUubGluZVwiXG4gICAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3RlZCBsaW5lcyB1cCBvbmUgbGluZS5cbiovXG5jb25zdCBtb3ZlTGluZVVwID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IG1vdmVMaW5lKHN0YXRlLCBkaXNwYXRjaCwgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3RlZCBsaW5lcyBkb3duIG9uZSBsaW5lLlxuKi9cbmNvbnN0IG1vdmVMaW5lRG93biA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiBtb3ZlTGluZShzdGF0ZSwgZGlzcGF0Y2gsIHRydWUpO1xuZnVuY3Rpb24gY29weUxpbmUoc3RhdGUsIGRpc3BhdGNoLCBmb3J3YXJkKSB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCBibG9jayBvZiBzZWxlY3RlZExpbmVCbG9ja3Moc3RhdGUpKSB7XG4gICAgICAgIGlmIChmb3J3YXJkKVxuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogYmxvY2suZnJvbSwgaW5zZXJ0OiBzdGF0ZS5kb2Muc2xpY2UoYmxvY2suZnJvbSwgYmxvY2sudG8pICsgc3RhdGUubGluZUJyZWFrIH0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBibG9jay50bywgaW5zZXJ0OiBzdGF0ZS5saW5lQnJlYWsgKyBzdGF0ZS5kb2Muc2xpY2UoYmxvY2suZnJvbSwgYmxvY2sudG8pIH0pO1xuICAgIH1cbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBjaGFuZ2VzLCBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0LmNvcHlsaW5lXCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5DcmVhdGUgYSBjb3B5IG9mIHRoZSBzZWxlY3RlZCBsaW5lcy4gS2VlcCB0aGUgc2VsZWN0aW9uIGluIHRoZSB0b3AgY29weS5cbiovXG5jb25zdCBjb3B5TGluZVVwID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IGNvcHlMaW5lKHN0YXRlLCBkaXNwYXRjaCwgZmFsc2UpO1xuLyoqXG5DcmVhdGUgYSBjb3B5IG9mIHRoZSBzZWxlY3RlZCBsaW5lcy4gS2VlcCB0aGUgc2VsZWN0aW9uIGluIHRoZSBib3R0b20gY29weS5cbiovXG5jb25zdCBjb3B5TGluZURvd24gPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4gY29weUxpbmUoc3RhdGUsIGRpc3BhdGNoLCB0cnVlKTtcbi8qKlxuRGVsZXRlIHNlbGVjdGVkIGxpbmVzLlxuKi9cbmNvbnN0IGRlbGV0ZUxpbmUgPSB2aWV3ID0+IHtcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlcyhzZWxlY3RlZExpbmVCbG9ja3Moc3RhdGUpLm1hcCgoeyBmcm9tLCB0byB9KSA9PiB7XG4gICAgICAgIGlmIChmcm9tID4gMClcbiAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgZWxzZSBpZiAodG8gPCBzdGF0ZS5kb2MubGVuZ3RoKVxuICAgICAgICAgICAgdG8rKztcbiAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8gfTtcbiAgICB9KSk7XG4gICAgbGV0IHNlbGVjdGlvbiA9IHVwZGF0ZVNlbChzdGF0ZS5zZWxlY3Rpb24sIHJhbmdlID0+IHZpZXcubW92ZVZlcnRpY2FsbHkocmFuZ2UsIHRydWUpKS5tYXAoY2hhbmdlcyk7XG4gICAgdmlldy5kaXNwYXRjaCh7IGNoYW5nZXMsIHNlbGVjdGlvbiwgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJkZWxldGUubGluZVwiIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuUmVwbGFjZSB0aGUgc2VsZWN0aW9uIHdpdGggYSBuZXdsaW5lLlxuKi9cbmNvbnN0IGluc2VydE5ld2xpbmUgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShzdGF0ZS5yZXBsYWNlU2VsZWN0aW9uKHN0YXRlLmxpbmVCcmVhayksIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJpbnB1dFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBpc0JldHdlZW5CcmFja2V0cyhzdGF0ZSwgcG9zKSB7XG4gICAgaWYgKC9cXChcXCl8XFxbXFxdfFxce1xcfS8udGVzdChzdGF0ZS5zbGljZURvYyhwb3MgLSAxLCBwb3MgKyAxKSkpXG4gICAgICAgIHJldHVybiB7IGZyb206IHBvcywgdG86IHBvcyB9O1xuICAgIGxldCBjb250ZXh0ID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHBvcyk7XG4gICAgbGV0IGJlZm9yZSA9IGNvbnRleHQuY2hpbGRCZWZvcmUocG9zKSwgYWZ0ZXIgPSBjb250ZXh0LmNoaWxkQWZ0ZXIocG9zKSwgY2xvc2VkQnk7XG4gICAgaWYgKGJlZm9yZSAmJiBhZnRlciAmJiBiZWZvcmUudG8gPD0gcG9zICYmIGFmdGVyLmZyb20gPj0gcG9zICYmXG4gICAgICAgIChjbG9zZWRCeSA9IGJlZm9yZS50eXBlLnByb3AoTm9kZVByb3AuY2xvc2VkQnkpKSAmJiBjbG9zZWRCeS5pbmRleE9mKGFmdGVyLm5hbWUpID4gLTEgJiZcbiAgICAgICAgc3RhdGUuZG9jLmxpbmVBdChiZWZvcmUudG8pLmZyb20gPT0gc3RhdGUuZG9jLmxpbmVBdChhZnRlci5mcm9tKS5mcm9tICYmXG4gICAgICAgICEvXFxTLy50ZXN0KHN0YXRlLnNsaWNlRG9jKGJlZm9yZS50bywgYWZ0ZXIuZnJvbSkpKVxuICAgICAgICByZXR1cm4geyBmcm9tOiBiZWZvcmUudG8sIHRvOiBhZnRlci5mcm9tIH07XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcblJlcGxhY2UgdGhlIHNlbGVjdGlvbiB3aXRoIGEgbmV3bGluZSBhbmQgaW5kZW50IHRoZSBuZXdseSBjcmVhdGVkXG5saW5lKHMpLiBJZiB0aGUgY3VycmVudCBsaW5lIGNvbnNpc3RzIG9ubHkgb2Ygd2hpdGVzcGFjZSwgdGhpc1xud2lsbCBhbHNvIGRlbGV0ZSB0aGF0IHdoaXRlc3BhY2UuIFdoZW4gdGhlIGN1cnNvciBpcyBiZXR3ZWVuXG5tYXRjaGluZyBicmFja2V0cywgYW4gYWRkaXRpb25hbCBuZXdsaW5lIHdpbGwgYmUgaW5zZXJ0ZWQgYWZ0ZXJcbnRoZSBjdXJzb3IuXG4qL1xuY29uc3QgaW5zZXJ0TmV3bGluZUFuZEluZGVudCA9IC8qQF9fUFVSRV9fKi9uZXdsaW5lQW5kSW5kZW50KGZhbHNlKTtcbi8qKlxuQ3JlYXRlIGEgYmxhbmssIGluZGVudGVkIGxpbmUgYmVsb3cgdGhlIGN1cnJlbnQgbGluZS5cbiovXG5jb25zdCBpbnNlcnRCbGFua0xpbmUgPSAvKkBfX1BVUkVfXyovbmV3bGluZUFuZEluZGVudCh0cnVlKTtcbmZ1bmN0aW9uIG5ld2xpbmVBbmRJbmRlbnQoYXRFb2YpIHtcbiAgICByZXR1cm4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHJhbmdlLCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChmcm9tKTtcbiAgICAgICAgICAgIGxldCBleHBsb2RlID0gIWF0RW9mICYmIGZyb20gPT0gdG8gJiYgaXNCZXR3ZWVuQnJhY2tldHMoc3RhdGUsIGZyb20pO1xuICAgICAgICAgICAgaWYgKGF0RW9mKVxuICAgICAgICAgICAgICAgIGZyb20gPSB0byA9ICh0byA8PSBsaW5lLnRvID8gbGluZSA6IHN0YXRlLmRvYy5saW5lQXQodG8pKS50bztcbiAgICAgICAgICAgIGxldCBjeCA9IG5ldyBJbmRlbnRDb250ZXh0KHN0YXRlLCB7IHNpbXVsYXRlQnJlYWs6IGZyb20sIHNpbXVsYXRlRG91YmxlQnJlYWs6ICEhZXhwbG9kZSB9KTtcbiAgICAgICAgICAgIGxldCBpbmRlbnQgPSBnZXRJbmRlbnRhdGlvbihjeCwgZnJvbSk7XG4gICAgICAgICAgICBpZiAoaW5kZW50ID09IG51bGwpXG4gICAgICAgICAgICAgICAgaW5kZW50ID0gY291bnRDb2x1bW4oL15cXHMqLy5leGVjKHN0YXRlLmRvYy5saW5lQXQoZnJvbSkudGV4dClbMF0sIHN0YXRlLnRhYlNpemUpO1xuICAgICAgICAgICAgd2hpbGUgKHRvIDwgbGluZS50byAmJiAvXFxzLy50ZXN0KGxpbmUudGV4dFt0byAtIGxpbmUuZnJvbV0pKVxuICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICBpZiAoZXhwbG9kZSlcbiAgICAgICAgICAgICAgICAoeyBmcm9tLCB0byB9ID0gZXhwbG9kZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmcm9tID4gbGluZS5mcm9tICYmIGZyb20gPCBsaW5lLmZyb20gKyAxMDAgJiYgIS9cXFMvLnRlc3QobGluZS50ZXh0LnNsaWNlKDAsIGZyb20pKSlcbiAgICAgICAgICAgICAgICBmcm9tID0gbGluZS5mcm9tO1xuICAgICAgICAgICAgbGV0IGluc2VydCA9IFtcIlwiLCBpbmRlbnRTdHJpbmcoc3RhdGUsIGluZGVudCldO1xuICAgICAgICAgICAgaWYgKGV4cGxvZGUpXG4gICAgICAgICAgICAgICAgaW5zZXJ0LnB1c2goaW5kZW50U3RyaW5nKHN0YXRlLCBjeC5saW5lSW5kZW50KGxpbmUuZnJvbSwgLTEpKSk7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb20sIHRvLCBpbnNlcnQ6IFRleHQub2YoaW5zZXJ0KSB9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZyb20gKyAxICsgaW5zZXJ0WzFdLmxlbmd0aCkgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXRcIiB9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5mdW5jdGlvbiBjaGFuZ2VCeVNlbGVjdGVkTGluZShzdGF0ZSwgZikge1xuICAgIGxldCBhdExpbmUgPSAtMTtcbiAgICByZXR1cm4gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHJhbmdlLmZyb207IHBvcyA8PSByYW5nZS50bzspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKGxpbmUubnVtYmVyID4gYXRMaW5lICYmIChyYW5nZS5lbXB0eSB8fCByYW5nZS50byA+IGxpbmUuZnJvbSkpIHtcbiAgICAgICAgICAgICAgICBmKGxpbmUsIGNoYW5nZXMsIHJhbmdlKTtcbiAgICAgICAgICAgICAgICBhdExpbmUgPSBsaW5lLm51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGxpbmUudG8gKyAxO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaGFuZ2VTZXQgPSBzdGF0ZS5jaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzLFxuICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5yYW5nZShjaGFuZ2VTZXQubWFwUG9zKHJhbmdlLmFuY2hvciwgMSksIGNoYW5nZVNldC5tYXBQb3MocmFuZ2UuaGVhZCwgMSkpIH07XG4gICAgfSk7XG59XG4vKipcbkF1dG8taW5kZW50IHRoZSBzZWxlY3RlZCBsaW5lcy4gVGhpcyB1c2VzIHRoZSBbaW5kZW50YXRpb24gc2VydmljZVxuZmFjZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50U2VydmljZSkgYXMgc291cmNlIGZvciBhdXRvLWluZGVudFxuaW5mb3JtYXRpb24uXG4qL1xuY29uc3QgaW5kZW50U2VsZWN0aW9uID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgdXBkYXRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGNvbnRleHQgPSBuZXcgSW5kZW50Q29udGV4dChzdGF0ZSwgeyBvdmVycmlkZUluZGVudGF0aW9uOiBzdGFydCA9PiB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSB1cGRhdGVkW3N0YXJ0XTtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZCA9PSBudWxsID8gLTEgOiBmb3VuZDtcbiAgICAgICAgfSB9KTtcbiAgICBsZXQgY2hhbmdlcyA9IGNoYW5nZUJ5U2VsZWN0ZWRMaW5lKHN0YXRlLCAobGluZSwgY2hhbmdlcywgcmFuZ2UpID0+IHtcbiAgICAgICAgbGV0IGluZGVudCA9IGdldEluZGVudGF0aW9uKGNvbnRleHQsIGxpbmUuZnJvbSk7XG4gICAgICAgIGlmIChpbmRlbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCEvXFxTLy50ZXN0KGxpbmUudGV4dCkpXG4gICAgICAgICAgICBpbmRlbnQgPSAwO1xuICAgICAgICBsZXQgY3VyID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF07XG4gICAgICAgIGxldCBub3JtID0gaW5kZW50U3RyaW5nKHN0YXRlLCBpbmRlbnQpO1xuICAgICAgICBpZiAoY3VyICE9IG5vcm0gfHwgcmFuZ2UuZnJvbSA8IGxpbmUuZnJvbSArIGN1ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHVwZGF0ZWRbbGluZS5mcm9tXSA9IGluZGVudDtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSwgdG86IGxpbmUuZnJvbSArIGN1ci5sZW5ndGgsIGluc2VydDogbm9ybSB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghY2hhbmdlcy5jaGFuZ2VzLmVtcHR5KVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyB1c2VyRXZlbnQ6IFwiaW5kZW50XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQWRkIGEgW3VuaXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdCkgb2YgaW5kZW50YXRpb24gdG8gYWxsIHNlbGVjdGVkXG5saW5lcy5cbiovXG5jb25zdCBpbmRlbnRNb3JlID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlQnlTZWxlY3RlZExpbmUoc3RhdGUsIChsaW5lLCBjaGFuZ2VzKSA9PiB7XG4gICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSwgaW5zZXJ0OiBzdGF0ZS5mYWNldChpbmRlbnRVbml0KSB9KTtcbiAgICB9KSwgeyB1c2VyRXZlbnQ6IFwiaW5wdXQuaW5kZW50XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuUmVtb3ZlIGEgW3VuaXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdCkgb2YgaW5kZW50YXRpb24gZnJvbSBhbGxcbnNlbGVjdGVkIGxpbmVzLlxuKi9cbmNvbnN0IGluZGVudExlc3MgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VCeVNlbGVjdGVkTGluZShzdGF0ZSwgKGxpbmUsIGNoYW5nZXMpID0+IHtcbiAgICAgICAgbGV0IHNwYWNlID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF07XG4gICAgICAgIGlmICghc3BhY2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBjb2wgPSBjb3VudENvbHVtbihzcGFjZSwgc3RhdGUudGFiU2l6ZSksIGtlZXAgPSAwO1xuICAgICAgICBsZXQgaW5zZXJ0ID0gaW5kZW50U3RyaW5nKHN0YXRlLCBNYXRoLm1heCgwLCBjb2wgLSBnZXRJbmRlbnRVbml0KHN0YXRlKSkpO1xuICAgICAgICB3aGlsZSAoa2VlcCA8IHNwYWNlLmxlbmd0aCAmJiBrZWVwIDwgaW5zZXJ0Lmxlbmd0aCAmJiBzcGFjZS5jaGFyQ29kZUF0KGtlZXApID09IGluc2VydC5jaGFyQ29kZUF0KGtlZXApKVxuICAgICAgICAgICAga2VlcCsrO1xuICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20gKyBrZWVwLCB0bzogbGluZS5mcm9tICsgc3BhY2UubGVuZ3RoLCBpbnNlcnQ6IGluc2VydC5zbGljZShrZWVwKSB9KTtcbiAgICB9KSwgeyB1c2VyRXZlbnQ6IFwiZGVsZXRlLmRlZGVudFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkluc2VydCBhIHRhYiBjaGFyYWN0ZXIgYXQgdGhlIGN1cnNvciBvciwgaWYgc29tZXRoaW5nIGlzIHNlbGVjdGVkLFxudXNlIFtgaW5kZW50TW9yZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50TW9yZSkgdG8gaW5kZW50IHRoZSBlbnRpcmVcbnNlbGVjdGlvbi5cbiovXG5jb25zdCBpbnNlcnRUYWIgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLnNvbWUociA9PiAhci5lbXB0eSkpXG4gICAgICAgIHJldHVybiBpbmRlbnRNb3JlKHsgc3RhdGUsIGRpc3BhdGNoIH0pO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShzdGF0ZS5yZXBsYWNlU2VsZWN0aW9uKFwiXFx0XCIpLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5BcnJheSBvZiBrZXkgYmluZGluZ3MgY29udGFpbmluZyB0aGUgRW1hY3Mtc3R5bGUgYmluZGluZ3MgdGhhdCBhcmVcbmF2YWlsYWJsZSBvbiBtYWNPUyBieSBkZWZhdWx0LlxuXG4gLSBDdHJsLWI6IFtgY3Vyc29yQ2hhckxlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckNoYXJMZWZ0KSAoW2BzZWxlY3RDaGFyTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhckxlZnQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLWY6IFtgY3Vyc29yQ2hhclJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JDaGFyUmlnaHQpIChbYHNlbGVjdENoYXJSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhclJpZ2h0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1wOiBbYGN1cnNvckxpbmVVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZVVwKSAoW2BzZWxlY3RMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVVcCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtbjogW2BjdXJzb3JMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZURvd24pIChbYHNlbGVjdExpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lRG93bikgd2l0aCBTaGlmdClcbiAtIEN0cmwtYTogW2BjdXJzb3JMaW5lU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVTdGFydCkgKFtgc2VsZWN0TGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lU3RhcnQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLWU6IFtgY3Vyc29yTGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZUVuZCkgKFtgc2VsZWN0TGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZUVuZCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtZDogW2BkZWxldGVDaGFyRm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlQ2hhckZvcndhcmQpXG4gLSBDdHJsLWg6IFtgZGVsZXRlQ2hhckJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVDaGFyQmFja3dhcmQpXG4gLSBDdHJsLWs6IFtgZGVsZXRlVG9MaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVUb0xpbmVFbmQpXG4gLSBDdHJsLUFsdC1oOiBbYGRlbGV0ZUdyb3VwQmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUdyb3VwQmFja3dhcmQpXG4gLSBDdHJsLW86IFtgc3BsaXRMaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zcGxpdExpbmUpXG4gLSBDdHJsLXQ6IFtgdHJhbnNwb3NlQ2hhcnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnRyYW5zcG9zZUNoYXJzKVxuIC0gQ3RybC12OiBbYGN1cnNvclBhZ2VEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlRG93bilcbiAtIEFsdC12OiBbYGN1cnNvclBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZVVwKVxuKi9cbmNvbnN0IGVtYWNzU3R5bGVLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiQ3RybC1iXCIsIHJ1bjogY3Vyc29yQ2hhckxlZnQsIHNoaWZ0OiBzZWxlY3RDaGFyTGVmdCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJDdHJsLWZcIiwgcnVuOiBjdXJzb3JDaGFyUmlnaHQsIHNoaWZ0OiBzZWxlY3RDaGFyUmlnaHQgfSxcbiAgICB7IGtleTogXCJDdHJsLXBcIiwgcnVuOiBjdXJzb3JMaW5lVXAsIHNoaWZ0OiBzZWxlY3RMaW5lVXAgfSxcbiAgICB7IGtleTogXCJDdHJsLW5cIiwgcnVuOiBjdXJzb3JMaW5lRG93biwgc2hpZnQ6IHNlbGVjdExpbmVEb3duIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1hXCIsIHJ1bjogY3Vyc29yTGluZVN0YXJ0LCBzaGlmdDogc2VsZWN0TGluZVN0YXJ0IH0sXG4gICAgeyBrZXk6IFwiQ3RybC1lXCIsIHJ1bjogY3Vyc29yTGluZUVuZCwgc2hpZnQ6IHNlbGVjdExpbmVFbmQgfSxcbiAgICB7IGtleTogXCJDdHJsLWRcIiwgcnVuOiBkZWxldGVDaGFyRm9yd2FyZCB9LFxuICAgIHsga2V5OiBcIkN0cmwtaFwiLCBydW46IGRlbGV0ZUNoYXJCYWNrd2FyZCB9LFxuICAgIHsga2V5OiBcIkN0cmwta1wiLCBydW46IGRlbGV0ZVRvTGluZUVuZCB9LFxuICAgIHsga2V5OiBcIkN0cmwtQWx0LWhcIiwgcnVuOiBkZWxldGVHcm91cEJhY2t3YXJkIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1vXCIsIHJ1bjogc3BsaXRMaW5lIH0sXG4gICAgeyBrZXk6IFwiQ3RybC10XCIsIHJ1bjogdHJhbnNwb3NlQ2hhcnMgfSxcbiAgICB7IGtleTogXCJDdHJsLXZcIiwgcnVuOiBjdXJzb3JQYWdlRG93biB9LFxuXTtcbi8qKlxuQW4gYXJyYXkgb2Yga2V5IGJpbmRpbmdzIGNsb3NlbHkgc3RpY2tpbmcgdG8gcGxhdGZvcm0tc3RhbmRhcmQgb3JcbndpZGVseSB1c2VkIGJpbmRpbmdzLiAoVGhpcyBpbmNsdWRlcyB0aGUgYmluZGluZ3MgZnJvbVxuW2BlbWFjc1N0eWxlS2V5bWFwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5lbWFjc1N0eWxlS2V5bWFwKSwgd2l0aCB0aGVpciBga2V5YFxucHJvcGVydHkgY2hhbmdlZCB0byBgbWFjYC4pXG5cbiAtIEFycm93TGVmdDogW2BjdXJzb3JDaGFyTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yQ2hhckxlZnQpIChbYHNlbGVjdENoYXJMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RDaGFyTGVmdCkgd2l0aCBTaGlmdClcbiAtIEFycm93UmlnaHQ6IFtgY3Vyc29yQ2hhclJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JDaGFyUmlnaHQpIChbYHNlbGVjdENoYXJSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhclJpZ2h0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1BcnJvd0xlZnQgKEFsdC1BcnJvd0xlZnQgb24gbWFjT1MpOiBbYGN1cnNvckdyb3VwTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yR3JvdXBMZWZ0KSAoW2BzZWxlY3RHcm91cExlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdEdyb3VwTGVmdCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtQXJyb3dSaWdodCAoQWx0LUFycm93UmlnaHQgb24gbWFjT1MpOiBbYGN1cnNvckdyb3VwUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckdyb3VwUmlnaHQpIChbYHNlbGVjdEdyb3VwUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdEdyb3VwUmlnaHQpIHdpdGggU2hpZnQpXG4gLSBDbWQtQXJyb3dMZWZ0IChvbiBtYWNPUyk6IFtgY3Vyc29yTGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lU3RhcnQpIChbYHNlbGVjdExpbmVTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZVN0YXJ0KSB3aXRoIFNoaWZ0KVxuIC0gQ21kLUFycm93UmlnaHQgKG9uIG1hY09TKTogW2BjdXJzb3JMaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lRW5kKSAoW2BzZWxlY3RMaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lRW5kKSB3aXRoIFNoaWZ0KVxuIC0gQXJyb3dVcDogW2BjdXJzb3JMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVVcCkgKFtgc2VsZWN0TGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lVXApIHdpdGggU2hpZnQpXG4gLSBBcnJvd0Rvd246IFtgY3Vyc29yTGluZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVEb3duKSAoW2BzZWxlY3RMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZURvd24pIHdpdGggU2hpZnQpXG4gLSBDbWQtQXJyb3dVcCAob24gbWFjT1MpOiBbYGN1cnNvckRvY1N0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JEb2NTdGFydCkgKFtgc2VsZWN0RG9jU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdERvY1N0YXJ0KSB3aXRoIFNoaWZ0KVxuIC0gQ21kLUFycm93RG93biAob24gbWFjT1MpOiBbYGN1cnNvckRvY0VuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yRG9jRW5kKSAoW2BzZWxlY3REb2NFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdERvY0VuZCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtQXJyb3dVcCAob24gbWFjT1MpOiBbYGN1cnNvclBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZVVwKSAoW2BzZWxlY3RQYWdlVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFBhZ2VVcCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtQXJyb3dEb3duIChvbiBtYWNPUyk6IFtgY3Vyc29yUGFnZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VEb3duKSAoW2BzZWxlY3RQYWdlRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFnZURvd24pIHdpdGggU2hpZnQpXG4gLSBQYWdlVXA6IFtgY3Vyc29yUGFnZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlVXApIChbYHNlbGVjdFBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFnZVVwKSB3aXRoIFNoaWZ0KVxuIC0gUGFnZURvd246IFtgY3Vyc29yUGFnZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VEb3duKSAoW2BzZWxlY3RQYWdlRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFnZURvd24pIHdpdGggU2hpZnQpXG4gLSBIb21lOiBbYGN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCkgKFtgc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkKSB3aXRoIFNoaWZ0KVxuIC0gRW5kOiBbYGN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmQpIChbYHNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLUhvbWUgKENtZC1Ib21lIG9uIG1hY09TKTogW2BjdXJzb3JEb2NTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yRG9jU3RhcnQpIChbYHNlbGVjdERvY1N0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3REb2NTdGFydCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtRW5kIChDbWQtSG9tZSBvbiBtYWNPUyk6IFtgY3Vyc29yRG9jRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JEb2NFbmQpIChbYHNlbGVjdERvY0VuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0RG9jRW5kKSB3aXRoIFNoaWZ0KVxuIC0gRW50ZXI6IFtgaW5zZXJ0TmV3bGluZUFuZEluZGVudGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5zZXJ0TmV3bGluZUFuZEluZGVudClcbiAtIEN0cmwtYSAoQ21kLWEgb24gbWFjT1MpOiBbYHNlbGVjdEFsbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0QWxsKVxuIC0gQmFja3NwYWNlOiBbYGRlbGV0ZUNoYXJCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlQ2hhckJhY2t3YXJkKVxuIC0gRGVsZXRlOiBbYGRlbGV0ZUNoYXJGb3J3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVDaGFyRm9yd2FyZClcbiAtIEN0cmwtQmFja3NwYWNlIChBbHQtQmFja3NwYWNlIG9uIG1hY09TKTogW2BkZWxldGVHcm91cEJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVHcm91cEJhY2t3YXJkKVxuIC0gQ3RybC1EZWxldGUgKEFsdC1EZWxldGUgb24gbWFjT1MpOiBbYGRlbGV0ZUdyb3VwRm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlR3JvdXBGb3J3YXJkKVxuIC0gQ21kLUJhY2tzcGFjZSAobWFjT1MpOiBbYGRlbGV0ZUxpbmVCb3VuZGFyeUJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVMaW5lQm91bmRhcnlCYWNrd2FyZCkuXG4gLSBDbWQtRGVsZXRlIChtYWNPUyk6IFtgZGVsZXRlTGluZUJvdW5kYXJ5Rm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlTGluZUJvdW5kYXJ5Rm9yd2FyZCkuXG4qL1xuY29uc3Qgc3RhbmRhcmRLZXltYXAgPSAvKkBfX1BVUkVfXyovW1xuICAgIHsga2V5OiBcIkFycm93TGVmdFwiLCBydW46IGN1cnNvckNoYXJMZWZ0LCBzaGlmdDogc2VsZWN0Q2hhckxlZnQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLUFycm93TGVmdFwiLCBtYWM6IFwiQWx0LUFycm93TGVmdFwiLCBydW46IGN1cnNvckdyb3VwTGVmdCwgc2hpZnQ6IHNlbGVjdEdyb3VwTGVmdCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IG1hYzogXCJDbWQtQXJyb3dMZWZ0XCIsIHJ1bjogY3Vyc29yTGluZUJvdW5kYXJ5TGVmdCwgc2hpZnQ6IHNlbGVjdExpbmVCb3VuZGFyeUxlZnQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiQXJyb3dSaWdodFwiLCBydW46IGN1cnNvckNoYXJSaWdodCwgc2hpZnQ6IHNlbGVjdENoYXJSaWdodCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtQXJyb3dSaWdodFwiLCBtYWM6IFwiQWx0LUFycm93UmlnaHRcIiwgcnVuOiBjdXJzb3JHcm91cFJpZ2h0LCBzaGlmdDogc2VsZWN0R3JvdXBSaWdodCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IG1hYzogXCJDbWQtQXJyb3dSaWdodFwiLCBydW46IGN1cnNvckxpbmVCb3VuZGFyeVJpZ2h0LCBzaGlmdDogc2VsZWN0TGluZUJvdW5kYXJ5UmlnaHQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiQXJyb3dVcFwiLCBydW46IGN1cnNvckxpbmVVcCwgc2hpZnQ6IHNlbGVjdExpbmVVcCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IG1hYzogXCJDbWQtQXJyb3dVcFwiLCBydW46IGN1cnNvckRvY1N0YXJ0LCBzaGlmdDogc2VsZWN0RG9jU3RhcnQgfSxcbiAgICB7IG1hYzogXCJDdHJsLUFycm93VXBcIiwgcnVuOiBjdXJzb3JQYWdlVXAsIHNoaWZ0OiBzZWxlY3RQYWdlVXAgfSxcbiAgICB7IGtleTogXCJBcnJvd0Rvd25cIiwgcnVuOiBjdXJzb3JMaW5lRG93biwgc2hpZnQ6IHNlbGVjdExpbmVEb3duLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsgbWFjOiBcIkNtZC1BcnJvd0Rvd25cIiwgcnVuOiBjdXJzb3JEb2NFbmQsIHNoaWZ0OiBzZWxlY3REb2NFbmQgfSxcbiAgICB7IG1hYzogXCJDdHJsLUFycm93RG93blwiLCBydW46IGN1cnNvclBhZ2VEb3duLCBzaGlmdDogc2VsZWN0UGFnZURvd24gfSxcbiAgICB7IGtleTogXCJQYWdlVXBcIiwgcnVuOiBjdXJzb3JQYWdlVXAsIHNoaWZ0OiBzZWxlY3RQYWdlVXAgfSxcbiAgICB7IGtleTogXCJQYWdlRG93blwiLCBydW46IGN1cnNvclBhZ2VEb3duLCBzaGlmdDogc2VsZWN0UGFnZURvd24gfSxcbiAgICB7IGtleTogXCJIb21lXCIsIHJ1bjogY3Vyc29yTGluZUJvdW5kYXJ5QmFja3dhcmQsIHNoaWZ0OiBzZWxlY3RMaW5lQm91bmRhcnlCYWNrd2FyZCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtSG9tZVwiLCBydW46IGN1cnNvckRvY1N0YXJ0LCBzaGlmdDogc2VsZWN0RG9jU3RhcnQgfSxcbiAgICB7IGtleTogXCJFbmRcIiwgcnVuOiBjdXJzb3JMaW5lQm91bmRhcnlGb3J3YXJkLCBzaGlmdDogc2VsZWN0TGluZUJvdW5kYXJ5Rm9yd2FyZCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtRW5kXCIsIHJ1bjogY3Vyc29yRG9jRW5kLCBzaGlmdDogc2VsZWN0RG9jRW5kIH0sXG4gICAgeyBrZXk6IFwiRW50ZXJcIiwgcnVuOiBpbnNlcnROZXdsaW5lQW5kSW5kZW50IH0sXG4gICAgeyBrZXk6IFwiTW9kLWFcIiwgcnVuOiBzZWxlY3RBbGwgfSxcbiAgICB7IGtleTogXCJCYWNrc3BhY2VcIiwgcnVuOiBkZWxldGVDaGFyQmFja3dhcmQsIHNoaWZ0OiBkZWxldGVDaGFyQmFja3dhcmQgfSxcbiAgICB7IGtleTogXCJEZWxldGVcIiwgcnVuOiBkZWxldGVDaGFyRm9yd2FyZCB9LFxuICAgIHsga2V5OiBcIk1vZC1CYWNrc3BhY2VcIiwgbWFjOiBcIkFsdC1CYWNrc3BhY2VcIiwgcnVuOiBkZWxldGVHcm91cEJhY2t3YXJkIH0sXG4gICAgeyBrZXk6IFwiTW9kLURlbGV0ZVwiLCBtYWM6IFwiQWx0LURlbGV0ZVwiLCBydW46IGRlbGV0ZUdyb3VwRm9yd2FyZCB9LFxuICAgIHsgbWFjOiBcIk1vZC1CYWNrc3BhY2VcIiwgcnVuOiBkZWxldGVMaW5lQm91bmRhcnlCYWNrd2FyZCB9LFxuICAgIHsgbWFjOiBcIk1vZC1EZWxldGVcIiwgcnVuOiBkZWxldGVMaW5lQm91bmRhcnlGb3J3YXJkIH1cbl0uY29uY2F0KC8qQF9fUFVSRV9fKi9lbWFjc1N0eWxlS2V5bWFwLm1hcChiID0+ICh7IG1hYzogYi5rZXksIHJ1bjogYi5ydW4sIHNoaWZ0OiBiLnNoaWZ0IH0pKSk7XG4vKipcblRoZSBkZWZhdWx0IGtleW1hcC4gSW5jbHVkZXMgYWxsIGJpbmRpbmdzIGZyb21cbltgc3RhbmRhcmRLZXltYXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnN0YW5kYXJkS2V5bWFwKSBwbHVzIHRoZSBmb2xsb3dpbmc6XG5cbi0gQWx0LUFycm93TGVmdCAoQ3RybC1BcnJvd0xlZnQgb24gbWFjT1MpOiBbYGN1cnNvclN5bnRheExlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclN5bnRheExlZnQpIChbYHNlbGVjdFN5bnRheExlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFN5bnRheExlZnQpIHdpdGggU2hpZnQpXG4tIEFsdC1BcnJvd1JpZ2h0IChDdHJsLUFycm93UmlnaHQgb24gbWFjT1MpOiBbYGN1cnNvclN5bnRheFJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JTeW50YXhSaWdodCkgKFtgc2VsZWN0U3ludGF4UmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFN5bnRheFJpZ2h0KSB3aXRoIFNoaWZ0KVxuLSBBbHQtQXJyb3dVcDogW2Btb3ZlTGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5tb3ZlTGluZVVwKVxuLSBBbHQtQXJyb3dEb3duOiBbYG1vdmVMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMubW92ZUxpbmVEb3duKVxuLSBTaGlmdC1BbHQtQXJyb3dVcDogW2Bjb3B5TGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jb3B5TGluZVVwKVxuLSBTaGlmdC1BbHQtQXJyb3dEb3duOiBbYGNvcHlMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY29weUxpbmVEb3duKVxuLSBFc2NhcGU6IFtgc2ltcGxpZnlTZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNpbXBsaWZ5U2VsZWN0aW9uKVxuLSBDdHJsLUVudGVyIChDbWQtRW50ZXIgb24gbWFjT1MpOiBbYGluc2VydEJsYW5rTGluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5zZXJ0QmxhbmtMaW5lKVxuLSBBbHQtbCAoQ3RybC1sIG9uIG1hY09TKTogW2BzZWxlY3RMaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lKVxuLSBDdHJsLWkgKENtZC1pIG9uIG1hY09TKTogW2BzZWxlY3RQYXJlbnRTeW50YXhgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFBhcmVudFN5bnRheClcbi0gQ3RybC1bIChDbWQtWyBvbiBtYWNPUyk6IFtgaW5kZW50TGVzc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50TGVzcylcbi0gQ3RybC1dIChDbWQtXSBvbiBtYWNPUyk6IFtgaW5kZW50TW9yZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50TW9yZSlcbi0gQ3RybC1BbHQtXFxcXCAoQ21kLUFsdC1cXFxcIG9uIG1hY09TKTogW2BpbmRlbnRTZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudFNlbGVjdGlvbilcbi0gU2hpZnQtQ3RybC1rIChTaGlmdC1DbWQtayBvbiBtYWNPUyk6IFtgZGVsZXRlTGluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlTGluZSlcbi0gU2hpZnQtQ3RybC1cXFxcIChTaGlmdC1DbWQtXFxcXCBvbiBtYWNPUyk6IFtgY3Vyc29yTWF0Y2hpbmdCcmFja2V0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JNYXRjaGluZ0JyYWNrZXQpXG4tIEN0cmwtLyAoQ21kLS8gb24gbWFjT1MpOiBbYHRvZ2dsZUNvbW1lbnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnRvZ2dsZUNvbW1lbnQpLlxuLSBTaGlmdC1BbHQtYTogW2B0b2dnbGVCbG9ja0NvbW1lbnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnRvZ2dsZUJsb2NrQ29tbWVudCkuXG4qL1xuY29uc3QgZGVmYXVsdEtleW1hcCA9IC8qQF9fUFVSRV9fKi9bXG4gICAgeyBrZXk6IFwiQWx0LUFycm93TGVmdFwiLCBtYWM6IFwiQ3RybC1BcnJvd0xlZnRcIiwgcnVuOiBjdXJzb3JTeW50YXhMZWZ0LCBzaGlmdDogc2VsZWN0U3ludGF4TGVmdCB9LFxuICAgIHsga2V5OiBcIkFsdC1BcnJvd1JpZ2h0XCIsIG1hYzogXCJDdHJsLUFycm93UmlnaHRcIiwgcnVuOiBjdXJzb3JTeW50YXhSaWdodCwgc2hpZnQ6IHNlbGVjdFN5bnRheFJpZ2h0IH0sXG4gICAgeyBrZXk6IFwiQWx0LUFycm93VXBcIiwgcnVuOiBtb3ZlTGluZVVwIH0sXG4gICAgeyBrZXk6IFwiU2hpZnQtQWx0LUFycm93VXBcIiwgcnVuOiBjb3B5TGluZVVwIH0sXG4gICAgeyBrZXk6IFwiQWx0LUFycm93RG93blwiLCBydW46IG1vdmVMaW5lRG93biB9LFxuICAgIHsga2V5OiBcIlNoaWZ0LUFsdC1BcnJvd0Rvd25cIiwgcnVuOiBjb3B5TGluZURvd24gfSxcbiAgICB7IGtleTogXCJFc2NhcGVcIiwgcnVuOiBzaW1wbGlmeVNlbGVjdGlvbiB9LFxuICAgIHsga2V5OiBcIk1vZC1FbnRlclwiLCBydW46IGluc2VydEJsYW5rTGluZSB9LFxuICAgIHsga2V5OiBcIkFsdC1sXCIsIG1hYzogXCJDdHJsLWxcIiwgcnVuOiBzZWxlY3RMaW5lIH0sXG4gICAgeyBrZXk6IFwiTW9kLWlcIiwgcnVuOiBzZWxlY3RQYXJlbnRTeW50YXgsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLVtcIiwgcnVuOiBpbmRlbnRMZXNzIH0sXG4gICAgeyBrZXk6IFwiTW9kLV1cIiwgcnVuOiBpbmRlbnRNb3JlIH0sXG4gICAgeyBrZXk6IFwiTW9kLUFsdC1cXFxcXCIsIHJ1bjogaW5kZW50U2VsZWN0aW9uIH0sXG4gICAgeyBrZXk6IFwiU2hpZnQtTW9kLWtcIiwgcnVuOiBkZWxldGVMaW5lIH0sXG4gICAgeyBrZXk6IFwiU2hpZnQtTW9kLVxcXFxcIiwgcnVuOiBjdXJzb3JNYXRjaGluZ0JyYWNrZXQgfSxcbiAgICB7IGtleTogXCJNb2QtL1wiLCBydW46IHRvZ2dsZUNvbW1lbnQgfSxcbiAgICB7IGtleTogXCJBbHQtQVwiLCBydW46IHRvZ2dsZUJsb2NrQ29tbWVudCB9XG5dLmNvbmNhdChzdGFuZGFyZEtleW1hcCk7XG4vKipcbkEgYmluZGluZyB0aGF0IGJpbmRzIFRhYiB0byBbYGluZGVudE1vcmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudE1vcmUpIGFuZFxuU2hpZnQtVGFiIHRvIFtgaW5kZW50TGVzc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50TGVzcykuXG5QbGVhc2Ugc2VlIHRoZSBbVGFiIGV4YW1wbGVdKC4uLy4uL2V4YW1wbGVzL3RhYi8pIGJlZm9yZSB1c2luZ1xudGhpcy5cbiovXG5jb25zdCBpbmRlbnRXaXRoVGFiID0geyBrZXk6IFwiVGFiXCIsIHJ1bjogaW5kZW50TW9yZSwgc2hpZnQ6IGluZGVudExlc3MgfTtcblxuZXhwb3J0IHsgYmxvY2tDb21tZW50LCBibG9ja1VuY29tbWVudCwgY29weUxpbmVEb3duLCBjb3B5TGluZVVwLCBjdXJzb3JDaGFyQmFja3dhcmQsIGN1cnNvckNoYXJGb3J3YXJkLCBjdXJzb3JDaGFyTGVmdCwgY3Vyc29yQ2hhclJpZ2h0LCBjdXJzb3JEb2NFbmQsIGN1cnNvckRvY1N0YXJ0LCBjdXJzb3JHcm91cEJhY2t3YXJkLCBjdXJzb3JHcm91cEZvcndhcmQsIGN1cnNvckdyb3VwTGVmdCwgY3Vyc29yR3JvdXBSaWdodCwgY3Vyc29yTGluZUJvdW5kYXJ5QmFja3dhcmQsIGN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmQsIGN1cnNvckxpbmVCb3VuZGFyeUxlZnQsIGN1cnNvckxpbmVCb3VuZGFyeVJpZ2h0LCBjdXJzb3JMaW5lRG93biwgY3Vyc29yTGluZUVuZCwgY3Vyc29yTGluZVN0YXJ0LCBjdXJzb3JMaW5lVXAsIGN1cnNvck1hdGNoaW5nQnJhY2tldCwgY3Vyc29yUGFnZURvd24sIGN1cnNvclBhZ2VVcCwgY3Vyc29yU3Vid29yZEJhY2t3YXJkLCBjdXJzb3JTdWJ3b3JkRm9yd2FyZCwgY3Vyc29yU3ludGF4TGVmdCwgY3Vyc29yU3ludGF4UmlnaHQsIGRlZmF1bHRLZXltYXAsIGRlbGV0ZUNoYXJCYWNrd2FyZCwgZGVsZXRlQ2hhckZvcndhcmQsIGRlbGV0ZUdyb3VwQmFja3dhcmQsIGRlbGV0ZUdyb3VwRm9yd2FyZCwgZGVsZXRlTGluZSwgZGVsZXRlTGluZUJvdW5kYXJ5QmFja3dhcmQsIGRlbGV0ZUxpbmVCb3VuZGFyeUZvcndhcmQsIGRlbGV0ZVRvTGluZUVuZCwgZGVsZXRlVG9MaW5lU3RhcnQsIGRlbGV0ZVRyYWlsaW5nV2hpdGVzcGFjZSwgZW1hY3NTdHlsZUtleW1hcCwgaGlzdG9yeSwgaGlzdG9yeUZpZWxkLCBoaXN0b3J5S2V5bWFwLCBpbmRlbnRMZXNzLCBpbmRlbnRNb3JlLCBpbmRlbnRTZWxlY3Rpb24sIGluZGVudFdpdGhUYWIsIGluc2VydEJsYW5rTGluZSwgaW5zZXJ0TmV3bGluZSwgaW5zZXJ0TmV3bGluZUFuZEluZGVudCwgaW5zZXJ0VGFiLCBpbnZlcnRlZEVmZmVjdHMsIGlzb2xhdGVIaXN0b3J5LCBsaW5lQ29tbWVudCwgbGluZVVuY29tbWVudCwgbW92ZUxpbmVEb3duLCBtb3ZlTGluZVVwLCByZWRvLCByZWRvRGVwdGgsIHJlZG9TZWxlY3Rpb24sIHNlbGVjdEFsbCwgc2VsZWN0Q2hhckJhY2t3YXJkLCBzZWxlY3RDaGFyRm9yd2FyZCwgc2VsZWN0Q2hhckxlZnQsIHNlbGVjdENoYXJSaWdodCwgc2VsZWN0RG9jRW5kLCBzZWxlY3REb2NTdGFydCwgc2VsZWN0R3JvdXBCYWNrd2FyZCwgc2VsZWN0R3JvdXBGb3J3YXJkLCBzZWxlY3RHcm91cExlZnQsIHNlbGVjdEdyb3VwUmlnaHQsIHNlbGVjdExpbmUsIHNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkLCBzZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkLCBzZWxlY3RMaW5lQm91bmRhcnlMZWZ0LCBzZWxlY3RMaW5lQm91bmRhcnlSaWdodCwgc2VsZWN0TGluZURvd24sIHNlbGVjdExpbmVFbmQsIHNlbGVjdExpbmVTdGFydCwgc2VsZWN0TGluZVVwLCBzZWxlY3RNYXRjaGluZ0JyYWNrZXQsIHNlbGVjdFBhZ2VEb3duLCBzZWxlY3RQYWdlVXAsIHNlbGVjdFBhcmVudFN5bnRheCwgc2VsZWN0U3Vid29yZEJhY2t3YXJkLCBzZWxlY3RTdWJ3b3JkRm9yd2FyZCwgc2VsZWN0U3ludGF4TGVmdCwgc2VsZWN0U3ludGF4UmlnaHQsIHNpbXBsaWZ5U2VsZWN0aW9uLCBzcGxpdExpbmUsIHN0YW5kYXJkS2V5bWFwLCB0b2dnbGVCbG9ja0NvbW1lbnQsIHRvZ2dsZUJsb2NrQ29tbWVudEJ5TGluZSwgdG9nZ2xlQ29tbWVudCwgdG9nZ2xlTGluZUNvbW1lbnQsIHRyYW5zcG9zZUNoYXJzLCB1bmRvLCB1bmRvRGVwdGgsIHVuZG9TZWxlY3Rpb24gfTtcbiJdLCJuYW1lcyI6WyJBbm5vdGF0aW9uIiwiRmFjZXQiLCJjb21iaW5lQ29uZmlnIiwiU3RhdGVGaWVsZCIsIlRyYW5zYWN0aW9uIiwiQ2hhbmdlU2V0IiwiQ2hhbmdlRGVzYyIsIkVkaXRvclNlbGVjdGlvbiIsIlN0YXRlRWZmZWN0IiwiVGV4dCIsImZpbmRDbHVzdGVyQnJlYWsiLCJjb3VudENvbHVtbiIsIkNoYXJDYXRlZ29yeSIsIkVkaXRvclZpZXciLCJEaXJlY3Rpb24iLCJJbmRlbnRDb250ZXh0IiwiZ2V0SW5kZW50YXRpb24iLCJpbmRlbnRTdHJpbmciLCJtYXRjaEJyYWNrZXRzIiwic3ludGF4VHJlZSIsImdldEluZGVudFVuaXQiLCJpbmRlbnRVbml0IiwiTm9kZVByb3AiLCJ0b2dnbGVDb21tZW50IiwidGFyZ2V0Iiwic3RhdGUiLCJsaW5lIiwiZG9jIiwibGluZUF0Iiwic2VsZWN0aW9uIiwibWFpbiIsImZyb20iLCJjb25maWciLCJnZXRDb25maWciLCJ0b2dnbGVMaW5lQ29tbWVudCIsImJsb2NrIiwidG9nZ2xlQmxvY2tDb21tZW50QnlMaW5lIiwiY29tbWFuZCIsImYiLCJvcHRpb24iLCJkaXNwYXRjaCIsInJlYWRPbmx5IiwidHIiLCJ1cGRhdGUiLCJjaGFuZ2VMaW5lQ29tbWVudCIsImxpbmVDb21tZW50IiwibGluZVVuY29tbWVudCIsInRvZ2dsZUJsb2NrQ29tbWVudCIsImNoYW5nZUJsb2NrQ29tbWVudCIsImJsb2NrQ29tbWVudCIsImJsb2NrVW5jb21tZW50IiwibyIsInMiLCJzZWxlY3RlZExpbmVSYW5nZXMiLCJwb3MiLCJkYXRhIiwibGFuZ3VhZ2VEYXRhQXQiLCJsZW5ndGgiLCJTZWFyY2hNYXJnaW4iLCJmaW5kQmxvY2tDb21tZW50Iiwib3BlbiIsImNsb3NlIiwidG8iLCJ0ZXh0QmVmb3JlIiwic2xpY2VEb2MiLCJ0ZXh0QWZ0ZXIiLCJzcGFjZUJlZm9yZSIsImV4ZWMiLCJzcGFjZUFmdGVyIiwiYmVmb3JlT2ZmIiwic2xpY2UiLCJtYXJnaW4iLCJzdGFydFRleHQiLCJlbmRUZXh0Iiwic3RhcnRTcGFjZSIsImVuZFNwYWNlIiwiZW5kT2ZmIiwidGVzdCIsImNoYXJBdCIsInJhbmdlcyIsInIiLCJmcm9tTGluZSIsInRvTGluZSIsImxhc3QiLCJwdXNoIiwidGV4dCIsInRva2VucyIsIm1hcCIsImV2ZXJ5IiwiYyIsImNvbW1lbnRzIiwiaSIsImNoYW5nZXMiLCJyYW5nZSIsImluc2VydCIsInNvbWUiLCJjb21tZW50IiwidG9rZW4iLCJsaW5lcyIsInByZXZMaW5lIiwic3RhcnRJIiwibWluSW5kZW50IiwiaW5kZW50IiwiZW1wdHkiLCJzaW5nbGUiLCJsIiwiY2hhbmdlU2V0IiwiZnJvbUhpc3RvcnkiLCJkZWZpbmUiLCJpc29sYXRlSGlzdG9yeSIsImludmVydGVkRWZmZWN0cyIsImhpc3RvcnlDb25maWciLCJjb21iaW5lIiwiY29uZmlncyIsIm1pbkRlcHRoIiwibmV3R3JvdXBEZWxheSIsImpvaW5Ub0V2ZW50IiwiX3QiLCJpc0FkamFjZW50IiwiTWF0aCIsIm1heCIsIm1pbiIsImEiLCJiIiwiYWRqIiwiaGlzdG9yeUZpZWxkXyIsImNyZWF0ZSIsIkhpc3RvcnlTdGF0ZSIsImZhY2V0IiwiZnJvbUhpc3QiLCJhbm5vdGF0aW9uIiwiaXRlbSIsIkhpc3RFdmVudCIsImZyb21UcmFuc2FjdGlvbiIsInNpZGUiLCJvdGhlciIsInVuZG9uZSIsImRvbmUiLCJ1cGRhdGVCcmFuY2giLCJhZGRTZWxlY3Rpb24iLCJzdGFydFN0YXRlIiwicmVzdCIsImlzb2xhdGUiLCJhZGRUb0hpc3RvcnkiLCJhZGRNYXBwaW5nIiwiZGVzYyIsImV2ZW50IiwidGltZSIsInVzZXJFdmVudCIsImFkZENoYW5nZXMiLCJ0b0pTT04iLCJ2YWx1ZSIsImUiLCJmcm9tSlNPTiIsImpzb24iLCJoaXN0b3J5Iiwib2YiLCJkb21FdmVudEhhbmRsZXJzIiwiYmVmb3JlaW5wdXQiLCJ2aWV3IiwiaW5wdXRUeXBlIiwidW5kbyIsInJlZG8iLCJwcmV2ZW50RGVmYXVsdCIsImhpc3RvcnlGaWVsZCIsImNtZCIsImhpc3RvcnlTdGF0ZSIsImZpZWxkIiwicG9wIiwidW5kb1NlbGVjdGlvbiIsInJlZG9TZWxlY3Rpb24iLCJkZXB0aCIsImhpc3RTdGF0ZSIsImJyYW5jaCIsInVuZG9EZXB0aCIsInJlZG9EZXB0aCIsImNvbnN0cnVjdG9yIiwiZWZmZWN0cyIsIm1hcHBlZCIsInN0YXJ0U2VsZWN0aW9uIiwic2VsZWN0aW9uc0FmdGVyIiwic2V0U2VsQWZ0ZXIiLCJhZnRlciIsIl9hIiwiX2IiLCJfYyIsIm5vbmUiLCJpbnZlcnQiLCJyZXN1bHQiLCJjb25jYXQiLCJ1bmRlZmluZWQiLCJzZWxlY3Rpb25zIiwibWF4TGVuIiwibmV3RXZlbnQiLCJzdGFydCIsIm5ld0JyYW5jaCIsIml0ZXJDaGFuZ2VkUmFuZ2VzIiwidCIsIl9mIiwiZXFTZWxlY3Rpb25TaGFwZSIsImZpbHRlciIsImNvbmMiLCJNYXhTZWxlY3Rpb25zUGVyRXZlbnQiLCJsYXN0RXZlbnQiLCJzZWxzIiwiZXEiLCJwb3BTZWxlY3Rpb24iLCJhZGRNYXBwaW5nVG9CcmFuY2giLCJtYXBwaW5nIiwibWFwRXZlbnQiLCJleHRyYVNlbGVjdGlvbnMiLCJtYXBwZWRDaGFuZ2VzIiwiYmVmb3JlIiwibWFwRGVzYyIsImZ1bGxNYXBwaW5nIiwiY29tcG9zZURlc2MiLCJtYXBFZmZlY3RzIiwiam9pbmFibGVVc2VyRXZlbnQiLCJwcmV2VGltZSIsInByZXZVc2VyRXZlbnQiLCJjb21wb3NlIiwib25seVNlbGVjdGlvbiIsImFubm90YXRpb25zIiwic2Nyb2xsSW50b1ZpZXciLCJoaXN0b3J5S2V5bWFwIiwia2V5IiwicnVuIiwibWFjIiwibGludXgiLCJ1cGRhdGVTZWwiLCJzZWwiLCJieSIsIm1haW5JbmRleCIsInNldFNlbCIsIm1vdmVTZWwiLCJob3ciLCJyYW5nZUVuZCIsImZvcndhcmQiLCJjdXJzb3IiLCJjdXJzb3JCeUNoYXIiLCJtb3ZlQnlDaGFyIiwibHRyQXRDdXJzb3IiLCJ0ZXh0RGlyZWN0aW9uQXQiLCJoZWFkIiwiTFRSIiwiY3Vyc29yQ2hhckxlZnQiLCJjdXJzb3JDaGFyUmlnaHQiLCJjdXJzb3JDaGFyRm9yd2FyZCIsImN1cnNvckNoYXJCYWNrd2FyZCIsImN1cnNvckJ5R3JvdXAiLCJtb3ZlQnlHcm91cCIsImN1cnNvckdyb3VwTGVmdCIsImN1cnNvckdyb3VwUmlnaHQiLCJjdXJzb3JHcm91cEZvcndhcmQiLCJjdXJzb3JHcm91cEJhY2t3YXJkIiwic2VnbWVudGVyIiwiSW50bCIsIlNlZ21lbnRlciIsImdyYW51bGFyaXR5IiwibW92ZUJ5U3Vid29yZCIsImNhdGVnb3JpemUiLCJjaGFyQ2F0ZWdvcml6ZXIiLCJjYXQiLCJTcGFjZSIsInN0ZXBzIiwic2F3VXBwZXIiLCJzYXdMb3dlciIsInN0ZXAiLCJuZXh0IiwibmV4dENhdCIsImFoZWFkIiwiV29yZCIsImNoYXJDb2RlQXQiLCJ0b0xvd2VyQ2FzZSIsImVuZCIsInNraXBwZWQiLCJzZWdtZW50cyIsIkFycmF5Iiwic2VnbWVudCIsImluZGV4IiwiY3Vyc29yQnlTdWJ3b3JkIiwiY3Vyc29yU3Vid29yZEZvcndhcmQiLCJjdXJzb3JTdWJ3b3JkQmFja3dhcmQiLCJpbnRlcmVzdGluZ05vZGUiLCJub2RlIiwiYnJhY2tldFByb3AiLCJ0eXBlIiwicHJvcCIsImxlbiIsImZpcnN0Q2hpbGQiLCJtb3ZlQnlTeW50YXgiLCJyZXNvbHZlSW5uZXIiLCJjbG9zZWRCeSIsIm9wZW5lZEJ5IiwiYXQiLCJjaGlsZEFmdGVyIiwiY2hpbGRCZWZvcmUiLCJicmFja2V0IiwibWF0Y2giLCJuZXdQb3MiLCJtYXRjaGVkIiwiY3Vyc29yU3ludGF4TGVmdCIsImN1cnNvclN5bnRheFJpZ2h0IiwiY3Vyc29yQnlMaW5lIiwibW92ZWQiLCJtb3ZlVmVydGljYWxseSIsIm1vdmVUb0xpbmVCb3VuZGFyeSIsImN1cnNvckxpbmVVcCIsImN1cnNvckxpbmVEb3duIiwicGFnZUluZm8iLCJzZWxmU2Nyb2xsIiwic2Nyb2xsRE9NIiwiY2xpZW50SGVpZ2h0Iiwic2Nyb2xsSGVpZ2h0IiwibWFyZ2luVG9wIiwibWFyZ2luQm90dG9tIiwiaGVpZ2h0Iiwic291cmNlIiwic2Nyb2xsTWFyZ2lucyIsIm1hcmdpbnMiLCJ0b3AiLCJib3R0b20iLCJkb20iLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJ3aW5kb3ciLCJpbm5lckhlaWdodCIsImRlZmF1bHRMaW5lSGVpZ2h0IiwiY3Vyc29yQnlQYWdlIiwicGFnZSIsImVmZmVjdCIsInN0YXJ0UG9zIiwiY29vcmRzQXRQb3MiLCJzY3JvbGxSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwic2Nyb2xsVG9wIiwic2Nyb2xsQm90dG9tIiwieSIsInlNYXJnaW4iLCJjdXJzb3JQYWdlVXAiLCJjdXJzb3JQYWdlRG93biIsIm1vdmVCeUxpbmVCb3VuZGFyeSIsImxpbmVCbG9ja0F0Iiwic3BhY2UiLCJjdXJzb3JMaW5lQm91bmRhcnlGb3J3YXJkIiwiY3Vyc29yTGluZUJvdW5kYXJ5QmFja3dhcmQiLCJjdXJzb3JMaW5lQm91bmRhcnlMZWZ0IiwiY3Vyc29yTGluZUJvdW5kYXJ5UmlnaHQiLCJjdXJzb3JMaW5lU3RhcnQiLCJjdXJzb3JMaW5lRW5kIiwidG9NYXRjaGluZ0JyYWNrZXQiLCJleHRlbmQiLCJmb3VuZCIsIm1hdGNoaW5nIiwiYW5jaG9yIiwiY3Vyc29yTWF0Y2hpbmdCcmFja2V0Iiwic2VsZWN0TWF0Y2hpbmdCcmFja2V0IiwiZXh0ZW5kU2VsIiwiZ29hbENvbHVtbiIsImJpZGlMZXZlbCIsInNlbGVjdEJ5Q2hhciIsInNlbGVjdENoYXJMZWZ0Iiwic2VsZWN0Q2hhclJpZ2h0Iiwic2VsZWN0Q2hhckZvcndhcmQiLCJzZWxlY3RDaGFyQmFja3dhcmQiLCJzZWxlY3RCeUdyb3VwIiwic2VsZWN0R3JvdXBMZWZ0Iiwic2VsZWN0R3JvdXBSaWdodCIsInNlbGVjdEdyb3VwRm9yd2FyZCIsInNlbGVjdEdyb3VwQmFja3dhcmQiLCJzZWxlY3RCeVN1YndvcmQiLCJzZWxlY3RTdWJ3b3JkRm9yd2FyZCIsInNlbGVjdFN1YndvcmRCYWNrd2FyZCIsInNlbGVjdFN5bnRheExlZnQiLCJzZWxlY3RTeW50YXhSaWdodCIsInNlbGVjdEJ5TGluZSIsInNlbGVjdExpbmVVcCIsInNlbGVjdExpbmVEb3duIiwic2VsZWN0QnlQYWdlIiwic2VsZWN0UGFnZVVwIiwic2VsZWN0UGFnZURvd24iLCJzZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkIiwic2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmQiLCJzZWxlY3RMaW5lQm91bmRhcnlMZWZ0Iiwic2VsZWN0TGluZUJvdW5kYXJ5UmlnaHQiLCJzZWxlY3RMaW5lU3RhcnQiLCJzZWxlY3RMaW5lRW5kIiwiY3Vyc29yRG9jU3RhcnQiLCJjdXJzb3JEb2NFbmQiLCJzZWxlY3REb2NTdGFydCIsInNlbGVjdERvY0VuZCIsInNlbGVjdEFsbCIsInNlbGVjdExpbmUiLCJzZWxlY3RlZExpbmVCbG9ja3MiLCJzZWxlY3RQYXJlbnRTeW50YXgiLCJzdGFjayIsInJlc29sdmVTdGFjayIsImN1ciIsInBhcmVudCIsInNpbXBsaWZ5U2VsZWN0aW9uIiwiZGVsZXRlQnkiLCJjaGFuZ2VCeVJhbmdlIiwidG93YXJkcyIsInNraXBBdG9taWMiLCJhbm5vdW5jZSIsInBocmFzZSIsImF0b21pY1JhbmdlcyIsImJldHdlZW4iLCJkZWxldGVCeUNoYXIiLCJ0YXJnZXRQb3MiLCJjb2wiLCJ0YWJTaXplIiwiZHJvcCIsIm51bWJlciIsImRlbGV0ZUNoYXJCYWNrd2FyZCIsImRlbGV0ZUNoYXJGb3J3YXJkIiwiZGVsZXRlQnlHcm91cCIsIm5leHRDaGFyIiwiZGVsZXRlR3JvdXBCYWNrd2FyZCIsImRlbGV0ZUdyb3VwRm9yd2FyZCIsImRlbGV0ZVRvTGluZUVuZCIsImxpbmVFbmQiLCJkZWxldGVUb0xpbmVTdGFydCIsImxpbmVTdGFydCIsImRlbGV0ZUxpbmVCb3VuZGFyeUJhY2t3YXJkIiwiZGVsZXRlTGluZUJvdW5kYXJ5Rm9yd2FyZCIsImRlbGV0ZVRyYWlsaW5nV2hpdGVzcGFjZSIsInByZXYiLCJpdGVyIiwibGluZUJyZWFrIiwidHJhaWxpbmciLCJzZWFyY2giLCJzcGxpdExpbmUiLCJ0cmFuc3Bvc2VDaGFycyIsImFwcGVuZCIsImJsb2NrcyIsInVwdG8iLCJzdGFydExpbmUiLCJlbmRMaW5lIiwibW92ZUxpbmUiLCJuZXh0TGluZSIsInNpemUiLCJtb3ZlTGluZVVwIiwibW92ZUxpbmVEb3duIiwiY29weUxpbmUiLCJjb3B5TGluZVVwIiwiY29weUxpbmVEb3duIiwiZGVsZXRlTGluZSIsImluc2VydE5ld2xpbmUiLCJyZXBsYWNlU2VsZWN0aW9uIiwiaXNCZXR3ZWVuQnJhY2tldHMiLCJjb250ZXh0IiwiaW5kZXhPZiIsIm5hbWUiLCJpbnNlcnROZXdsaW5lQW5kSW5kZW50IiwibmV3bGluZUFuZEluZGVudCIsImluc2VydEJsYW5rTGluZSIsImF0RW9mIiwiZXhwbG9kZSIsImN4Iiwic2ltdWxhdGVCcmVhayIsInNpbXVsYXRlRG91YmxlQnJlYWsiLCJsaW5lSW5kZW50IiwiY2hhbmdlQnlTZWxlY3RlZExpbmUiLCJhdExpbmUiLCJtYXBQb3MiLCJpbmRlbnRTZWxlY3Rpb24iLCJ1cGRhdGVkIiwiT2JqZWN0Iiwib3ZlcnJpZGVJbmRlbnRhdGlvbiIsIm5vcm0iLCJpbmRlbnRNb3JlIiwiaW5kZW50TGVzcyIsImtlZXAiLCJpbnNlcnRUYWIiLCJlbWFjc1N0eWxlS2V5bWFwIiwic2hpZnQiLCJzdGFuZGFyZEtleW1hcCIsImRlZmF1bHRLZXltYXAiLCJpbmRlbnRXaXRoVGFiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/commands/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/lang-javascript/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@codemirror/lang-javascript/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoCloseTags: () => (/* binding */ autoCloseTags),\n/* harmony export */   completionPath: () => (/* binding */ completionPath),\n/* harmony export */   esLint: () => (/* binding */ esLint),\n/* harmony export */   javascript: () => (/* binding */ javascript),\n/* harmony export */   javascriptLanguage: () => (/* binding */ javascriptLanguage),\n/* harmony export */   jsxLanguage: () => (/* binding */ jsxLanguage),\n/* harmony export */   localCompletionSource: () => (/* binding */ localCompletionSource),\n/* harmony export */   scopeCompletionSource: () => (/* binding */ scopeCompletionSource),\n/* harmony export */   snippets: () => (/* binding */ snippets),\n/* harmony export */   tsxLanguage: () => (/* binding */ tsxLanguage),\n/* harmony export */   typescriptLanguage: () => (/* binding */ typescriptLanguage),\n/* harmony export */   typescriptSnippets: () => (/* binding */ typescriptSnippets)\n/* harmony export */ });\n/* harmony import */ var _lezer_javascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/javascript */ \"(ssr)/./node_modules/@lezer/javascript/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/language */ \"(ssr)/./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/autocomplete */ \"(ssr)/./node_modules/@codemirror/autocomplete/dist/index.js\");\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n\n\n\n\n\n\n/**\nA collection of JavaScript-related\n[snippets](https://codemirror.net/6/docs/ref/#autocomplete.snippet).\n*/ const snippets = [\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"function ${name}(${params}) {\\n\t${}\\n}\", {\n        label: \"function\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\\n\t${}\\n}\", {\n        label: \"for\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"for (let ${name} of ${collection}) {\\n\t${}\\n}\", {\n        label: \"for\",\n        detail: \"of loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"do {\\n\t${}\\n} while (${})\", {\n        label: \"do\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"while (${}) {\\n\t${}\\n}\", {\n        label: \"while\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"try {\\n\t${}\\n} catch (${error}) {\\n\t${}\\n}\", {\n        label: \"try\",\n        detail: \"/ catch block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"if (${}) {\\n\t${}\\n}\", {\n        label: \"if\",\n        detail: \"block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"if (${}) {\\n\t${}\\n} else {\\n\t${}\\n}\", {\n        label: \"if\",\n        detail: \"/ else block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"class ${name} {\\n\tconstructor(${params}) {\\n\t\t${}\\n\t}\\n}\", {\n        label: \"class\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)('import {${names}} from \"${module}\"\\n${}', {\n        label: \"import\",\n        detail: \"named\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)('import ${name} from \"${module}\"\\n${}', {\n        label: \"import\",\n        detail: \"default\",\n        type: \"keyword\"\n    })\n];\n/**\nA collection of snippet completions for TypeScript. Includes the\nJavaScript [snippets](https://codemirror.net/6/docs/ref/#lang-javascript.snippets).\n*/ const typescriptSnippets = /*@__PURE__*/ snippets.concat([\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"interface ${name} {\\n\t${}\\n}\", {\n        label: \"interface\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"type ${name} = ${type}\", {\n        label: \"type\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"enum ${name} {\\n\t${}\\n}\", {\n        label: \"enum\",\n        detail: \"definition\",\n        type: \"keyword\"\n    })\n]);\nconst cache = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_1__.NodeWeakMap();\nconst ScopeNodes = /*@__PURE__*/ new Set([\n    \"Script\",\n    \"Block\",\n    \"FunctionExpression\",\n    \"FunctionDeclaration\",\n    \"ArrowFunction\",\n    \"MethodDeclaration\",\n    \"ForStatement\"\n]);\nfunction defID(type) {\n    return (node, def)=>{\n        let id = node.node.getChild(\"VariableDefinition\");\n        if (id) def(id, type);\n        return true;\n    };\n}\nconst functionContext = [\n    \"FunctionDeclaration\"\n];\nconst gatherCompletions = {\n    FunctionDeclaration: /*@__PURE__*/ defID(\"function\"),\n    ClassDeclaration: /*@__PURE__*/ defID(\"class\"),\n    ClassExpression: ()=>true,\n    EnumDeclaration: /*@__PURE__*/ defID(\"constant\"),\n    TypeAliasDeclaration: /*@__PURE__*/ defID(\"type\"),\n    NamespaceDeclaration: /*@__PURE__*/ defID(\"namespace\"),\n    VariableDefinition (node, def) {\n        if (!node.matchContext(functionContext)) def(node, \"variable\");\n    },\n    TypeDefinition (node, def) {\n        def(node, \"type\");\n    },\n    __proto__: null\n};\nfunction getScope(doc, node) {\n    let cached = cache.get(node);\n    if (cached) return cached;\n    let completions = [], top = true;\n    function def(node, type) {\n        let name = doc.sliceString(node.from, node.to);\n        completions.push({\n            label: name,\n            type\n        });\n    }\n    node.cursor(_lezer_common__WEBPACK_IMPORTED_MODULE_1__.IterMode.IncludeAnonymous).iterate((node)=>{\n        if (top) {\n            top = false;\n        } else if (node.name) {\n            let gather = gatherCompletions[node.name];\n            if (gather && gather(node, def) || ScopeNodes.has(node.name)) return false;\n        } else if (node.to - node.from > 8192) {\n            // Allow caching for bigger internal nodes\n            for (let c of getScope(doc, node.node))completions.push(c);\n            return false;\n        }\n    });\n    cache.set(node, completions);\n    return completions;\n}\nconst Identifier = /^[\\w$\\xa1-\\uffff][\\w$\\d\\xa1-\\uffff]*$/;\nconst dontComplete = [\n    \"TemplateString\",\n    \"String\",\n    \"RegExp\",\n    \"LineComment\",\n    \"BlockComment\",\n    \"VariableDefinition\",\n    \"TypeDefinition\",\n    \"Label\",\n    \"PropertyDefinition\",\n    \"PropertyName\",\n    \"PrivatePropertyDefinition\",\n    \"PrivatePropertyName\",\n    \".\",\n    \"?.\"\n];\n/**\nCompletion source that looks up locally defined names in\nJavaScript code.\n*/ function localCompletionSource(context) {\n    let inner = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(context.state).resolveInner(context.pos, -1);\n    if (dontComplete.indexOf(inner.name) > -1) return null;\n    let isWord = inner.name == \"VariableName\" || inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));\n    if (!isWord && !context.explicit) return null;\n    let options = [];\n    for(let pos = inner; pos; pos = pos.parent){\n        if (ScopeNodes.has(pos.name)) options = options.concat(getScope(context.state.doc, pos));\n    }\n    return {\n        options,\n        from: isWord ? inner.from : context.pos,\n        validFor: Identifier\n    };\n}\nfunction pathFor(read, member, name) {\n    var _a;\n    let path = [];\n    for(;;){\n        let obj = member.firstChild, prop;\n        if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"VariableName\") {\n            path.push(read(obj));\n            return {\n                path: path.reverse(),\n                name\n            };\n        } else if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"MemberExpression\" && ((_a = prop = obj.lastChild) === null || _a === void 0 ? void 0 : _a.name) == \"PropertyName\") {\n            path.push(read(prop));\n            member = obj;\n        } else {\n            return null;\n        }\n    }\n}\n/**\nHelper function for defining JavaScript completion sources. It\nreturns the completable name and object path for a completion\ncontext, or null if no name/property completion should happen at\nthat position. For example, when completing after `a.b.c` it will\nreturn `{path: [\"a\", \"b\"], name: \"c\"}`. When completing after `x`\nit will return `{path: [], name: \"x\"}`. When not in a property or\nname, it will return null if `context.explicit` is false, and\n`{path: [], name: \"\"}` otherwise.\n*/ function completionPath(context) {\n    let read = (node)=>context.state.doc.sliceString(node.from, node.to);\n    let inner = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(context.state).resolveInner(context.pos, -1);\n    if (inner.name == \"PropertyName\") {\n        return pathFor(read, inner.parent, read(inner));\n    } else if ((inner.name == \".\" || inner.name == \"?.\") && inner.parent.name == \"MemberExpression\") {\n        return pathFor(read, inner.parent, \"\");\n    } else if (dontComplete.indexOf(inner.name) > -1) {\n        return null;\n    } else if (inner.name == \"VariableName\" || inner.to - inner.from < 20 && Identifier.test(read(inner))) {\n        return {\n            path: [],\n            name: read(inner)\n        };\n    } else if (inner.name == \"MemberExpression\") {\n        return pathFor(read, inner, \"\");\n    } else {\n        return context.explicit ? {\n            path: [],\n            name: \"\"\n        } : null;\n    }\n}\nfunction enumeratePropertyCompletions(obj, top) {\n    let options = [], seen = new Set;\n    for(let depth = 0;; depth++){\n        for (let name of (Object.getOwnPropertyNames || Object.keys)(obj)){\n            if (!/^[a-zA-Z_$\\xaa-\\uffdc][\\w$\\xaa-\\uffdc]*$/.test(name) || seen.has(name)) continue;\n            seen.add(name);\n            let value;\n            try {\n                value = obj[name];\n            } catch (_) {\n                continue;\n            }\n            options.push({\n                label: name,\n                type: typeof value == \"function\" ? /^[A-Z]/.test(name) ? \"class\" : top ? \"function\" : \"method\" : top ? \"variable\" : \"property\",\n                boost: -depth\n            });\n        }\n        let next = Object.getPrototypeOf(obj);\n        if (!next) return options;\n        obj = next;\n    }\n}\n/**\nDefines a [completion source](https://codemirror.net/6/docs/ref/#autocomplete.CompletionSource) that\ncompletes from the given scope object (for example `globalThis`).\nWill enter properties of the object when completing properties on\na directly-named path.\n*/ function scopeCompletionSource(scope) {\n    let cache = new Map;\n    return (context)=>{\n        let path = completionPath(context);\n        if (!path) return null;\n        let target = scope;\n        for (let step of path.path){\n            target = target[step];\n            if (!target) return null;\n        }\n        let options = cache.get(target);\n        if (!options) cache.set(target, options = enumeratePropertyCompletions(target, !path.path.length));\n        return {\n            from: context.pos - path.name.length,\n            options,\n            validFor: Identifier\n        };\n    };\n}\n/**\nA language provider based on the [Lezer JavaScript\nparser](https://github.com/lezer-parser/javascript), extended with\nhighlighting and indentation information.\n*/ const javascriptLanguage = /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.LRLanguage.define({\n    name: \"javascript\",\n    parser: /*@__PURE__*/ _lezer_javascript__WEBPACK_IMPORTED_MODULE_0__.parser.configure({\n        props: [\n            /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentNodeProp.add({\n                IfStatement: /*@__PURE__*/ (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.continuedIndent)({\n                    except: /^\\s*({|else\\b)/\n                }),\n                TryStatement: /*@__PURE__*/ (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.continuedIndent)({\n                    except: /^\\s*({|catch\\b|finally\\b)/\n                }),\n                LabeledStatement: _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.flatIndent,\n                SwitchBody: (context)=>{\n                    let after = context.textAfter, closed = /^\\s*\\}/.test(after), isCase = /^\\s*(case|default)\\b/.test(after);\n                    return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;\n                },\n                Block: /*@__PURE__*/ (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.delimitedIndent)({\n                    closing: \"}\"\n                }),\n                ArrowFunction: (cx)=>cx.baseIndent + cx.unit,\n                \"TemplateString BlockComment\": ()=>null,\n                \"Statement Property\": /*@__PURE__*/ (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.continuedIndent)({\n                    except: /^{/\n                }),\n                JSXElement (context) {\n                    let closed = /^\\s*<\\//.test(context.textAfter);\n                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n                },\n                JSXEscape (context) {\n                    let closed = /\\s*\\}/.test(context.textAfter);\n                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n                },\n                \"JSXOpenTag JSXSelfClosingTag\" (context) {\n                    return context.column(context.node.from) + context.unit;\n                }\n            }),\n            /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.foldNodeProp.add({\n                \"Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType\": _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.foldInside,\n                BlockComment (tree) {\n                    return {\n                        from: tree.from + 2,\n                        to: tree.to - 2\n                    };\n                }\n            })\n        ]\n    }),\n    languageData: {\n        closeBrackets: {\n            brackets: [\n                \"(\",\n                \"[\",\n                \"{\",\n                \"'\",\n                '\"',\n                \"`\"\n            ]\n        },\n        commentTokens: {\n            line: \"//\",\n            block: {\n                open: \"/*\",\n                close: \"*/\"\n            }\n        },\n        indentOnInput: /^\\s*(?:case |default:|\\{|\\}|<\\/)$/,\n        wordChars: \"$\"\n    }\n});\nconst jsxSublanguage = {\n    test: (node)=>/^JSX/.test(node.name),\n    facet: /*@__PURE__*/ (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.defineLanguageFacet)({\n        commentTokens: {\n            block: {\n                open: \"{/*\",\n                close: \"*/}\"\n            }\n        }\n    })\n};\n/**\nA language provider for TypeScript.\n*/ const typescriptLanguage = /*@__PURE__*/ javascriptLanguage.configure({\n    dialect: \"ts\"\n}, \"typescript\");\n/**\nLanguage provider for JSX.\n*/ const jsxLanguage = /*@__PURE__*/ javascriptLanguage.configure({\n    dialect: \"jsx\",\n    props: [\n        /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.sublanguageProp.add((n)=>n.isTop ? [\n                jsxSublanguage\n            ] : undefined)\n    ]\n});\n/**\nLanguage provider for JSX + TypeScript.\n*/ const tsxLanguage = /*@__PURE__*/ javascriptLanguage.configure({\n    dialect: \"jsx ts\",\n    props: [\n        /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.sublanguageProp.add((n)=>n.isTop ? [\n                jsxSublanguage\n            ] : undefined)\n    ]\n}, \"typescript\");\nlet kwCompletion = (name)=>({\n        label: name,\n        type: \"keyword\"\n    });\nconst keywords = /*@__PURE__*/ \"break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield\".split(\" \").map(kwCompletion);\nconst typescriptKeywords = /*@__PURE__*/ keywords.concat(/*@__PURE__*/ [\n    \"declare\",\n    \"implements\",\n    \"private\",\n    \"protected\",\n    \"public\"\n].map(kwCompletion));\n/**\nJavaScript support. Includes [snippet](https://codemirror.net/6/docs/ref/#lang-javascript.snippets)\ncompletion.\n*/ function javascript(config = {}) {\n    let lang = config.jsx ? config.typescript ? tsxLanguage : jsxLanguage : config.typescript ? typescriptLanguage : javascriptLanguage;\n    let completions = config.typescript ? typescriptSnippets.concat(typescriptKeywords) : snippets.concat(keywords);\n    return new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.LanguageSupport(lang, [\n        javascriptLanguage.data.of({\n            autocomplete: (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.ifNotIn)(dontComplete, (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.completeFromList)(completions))\n        }),\n        javascriptLanguage.data.of({\n            autocomplete: localCompletionSource\n        }),\n        config.jsx ? autoCloseTags : []\n    ]);\n}\nfunction findOpenTag(node) {\n    for(;;){\n        if (node.name == \"JSXOpenTag\" || node.name == \"JSXSelfClosingTag\" || node.name == \"JSXFragmentTag\") return node;\n        if (node.name == \"JSXEscape\" || !node.parent) return null;\n        node = node.parent;\n    }\n}\nfunction elementName(doc, tree, max = doc.length) {\n    for(let ch = tree === null || tree === void 0 ? void 0 : tree.firstChild; ch; ch = ch.nextSibling){\n        if (ch.name == \"JSXIdentifier\" || ch.name == \"JSXBuiltin\" || ch.name == \"JSXNamespacedName\" || ch.name == \"JSXMemberExpression\") return doc.sliceString(ch.from, Math.min(ch.to, max));\n    }\n    return \"\";\n}\nconst android = typeof navigator == \"object\" && /*@__PURE__*/ /Android\\b/.test(navigator.userAgent);\n/**\nExtension that will automatically insert JSX close tags when a `>` or\n`/` is typed.\n*/ const autoCloseTags = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.inputHandler.of((view, from, to, text, defaultInsert)=>{\n    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly || from != to || text != \">\" && text != \"/\" || !javascriptLanguage.isActiveAt(view.state, from, -1)) return false;\n    let base = defaultInsert(), { state } = base;\n    let closeTags = state.changeByRange((range)=>{\n        var _a;\n        let { head } = range, around = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(head - 1, -1), name;\n        if (around.name == \"JSXStartTag\") around = around.parent;\n        if (state.doc.sliceString(head - 1, head) != text || around.name == \"JSXAttributeValue\" && around.to > head) ;\n        else if (text == \">\" && around.name == \"JSXFragmentTag\") {\n            return {\n                range,\n                changes: {\n                    from: head,\n                    insert: `</>`\n                }\n            };\n        } else if (text == \"/\" && around.name == \"JSXStartCloseTag\") {\n            let empty = around.parent, base = empty.parent;\n            if (base && empty.from == head - 2 && ((name = elementName(state.doc, base.firstChild, head)) || ((_a = base.firstChild) === null || _a === void 0 ? void 0 : _a.name) == \"JSXFragmentTag\")) {\n                let insert = `${name}>`;\n                return {\n                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_5__.EditorSelection.cursor(head + insert.length, -1),\n                    changes: {\n                        from: head,\n                        insert\n                    }\n                };\n            }\n        } else if (text == \">\") {\n            let openTag = findOpenTag(around);\n            if (openTag && !/^\\/?>|^<\\//.test(state.doc.sliceString(head, head + 2)) && (name = elementName(state.doc, openTag, head))) return {\n                range,\n                changes: {\n                    from: head,\n                    insert: `</${name}>`\n                }\n            };\n        }\n        return {\n            range\n        };\n    });\n    if (closeTags.changes.empty) return false;\n    view.dispatch([\n        base,\n        state.update(closeTags, {\n            userEvent: \"input.complete\",\n            scrollIntoView: true\n        })\n    ]);\n    return true;\n});\n/**\nConnects an [ESLint](https://eslint.org/) linter to CodeMirror's\n[lint](https://codemirror.net/6/docs/ref/#lint) integration. `eslint` should be an instance of the\n[`Linter`](https://eslint.org/docs/developer-guide/nodejs-api#linter)\nclass, and `config` an optional ESLint configuration. The return\nvalue of this function can be passed to [`linter`](https://codemirror.net/6/docs/ref/#lint.linter)\nto create a JavaScript linting extension.\n\nNote that ESLint targets node, and is tricky to run in the\nbrowser. The\n[eslint-linter-browserify](https://github.com/UziTech/eslint-linter-browserify)\npackage may help with that (see\n[example](https://github.com/UziTech/eslint-linter-browserify/blob/master/example/script.js)).\n*/ function esLint(eslint, config) {\n    if (!config) {\n        config = {\n            parserOptions: {\n                ecmaVersion: 2019,\n                sourceType: \"module\"\n            },\n            env: {\n                browser: true,\n                node: true,\n                es6: true,\n                es2015: true,\n                es2017: true,\n                es2020: true\n            },\n            rules: {}\n        };\n        eslint.getRules().forEach((desc, name)=>{\n            if (desc.meta.docs.recommended) config.rules[name] = 2;\n        });\n    }\n    return (view)=>{\n        let { state } = view, found = [];\n        for (let { from, to } of javascriptLanguage.findRegions(state)){\n            let fromLine = state.doc.lineAt(from), offset = {\n                line: fromLine.number - 1,\n                col: from - fromLine.from,\n                pos: from\n            };\n            for (let d of eslint.verify(state.sliceDoc(from, to), config))found.push(translateDiagnostic(d, state.doc, offset));\n        }\n        return found;\n    };\n}\nfunction mapPos(line, col, doc, offset) {\n    return doc.line(line + offset.line).from + col + (line == 1 ? offset.col - 1 : -1);\n}\nfunction translateDiagnostic(input, doc, offset) {\n    let start = mapPos(input.line, input.column, doc, offset);\n    let result = {\n        from: start,\n        to: input.endLine != null && input.endColumn != 1 ? mapPos(input.endLine, input.endColumn, doc, offset) : start,\n        message: input.message,\n        source: input.ruleId ? \"eslint:\" + input.ruleId : \"eslint\",\n        severity: input.severity == 1 ? \"warning\" : \"error\"\n    };\n    if (input.fix) {\n        let { range, text } = input.fix, from = range[0] + offset.pos - start, to = range[1] + offset.pos - start;\n        result.actions = [\n            {\n                name: \"fix\",\n                apply (view, start) {\n                    view.dispatch({\n                        changes: {\n                            from: start + from,\n                            to: start + to,\n                            insert: text\n                        },\n                        scrollIntoView: true\n                    });\n                }\n            }\n        ];\n    }\n    return result;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGFuZy1qYXZhc2NyaXB0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTJDO0FBQ2tLO0FBQ3pKO0FBQ047QUFDMEM7QUFDbEM7QUFFdEQ7OztBQUdBLEdBQ0EsTUFBTW1CLFdBQVc7SUFDYixXQUFXLEdBQUVMLDJFQUFpQkEsQ0FBQywwQ0FBMkM7UUFDdEVNLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxNQUFNO0lBQ1Y7SUFDQSxXQUFXLEdBQUVSLDJFQUFpQkEsQ0FBQyxzRUFBdUU7UUFDbEdNLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxNQUFNO0lBQ1Y7SUFDQSxXQUFXLEdBQUVSLDJFQUFpQkEsQ0FBQyxpREFBa0Q7UUFDN0VNLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxNQUFNO0lBQ1Y7SUFDQSxXQUFXLEdBQUVSLDJFQUFpQkEsQ0FBQyw2QkFBOEI7UUFDekRNLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxNQUFNO0lBQ1Y7SUFDQSxXQUFXLEdBQUVSLDJFQUFpQkEsQ0FBQywwQkFBMkI7UUFDdERNLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxNQUFNO0lBQ1Y7SUFDQSxXQUFXLEdBQUVSLDJFQUFpQkEsQ0FBQyw4Q0FBZ0Q7UUFDM0VNLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxNQUFNO0lBQ1Y7SUFDQSxXQUFXLEdBQUVSLDJFQUFpQkEsQ0FBQyx1QkFBd0I7UUFDbkRNLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxNQUFNO0lBQ1Y7SUFDQSxXQUFXLEdBQUVSLDJFQUFpQkEsQ0FBQyx1Q0FBeUM7UUFDcEVNLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxNQUFNO0lBQ1Y7SUFDQSxXQUFXLEdBQUVSLDJFQUFpQkEsQ0FBQyw0REFBZ0U7UUFDM0ZNLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxNQUFNO0lBQ1Y7SUFDQSxXQUFXLEdBQUVSLDJFQUFpQkEsQ0FBQywyQ0FBNkM7UUFDeEVN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TU8sTUFBTSxHQUFHLFlBQVlQLE1BQU1PLE1BQU0sR0FBRztRQUNsREMsVUFBVVIsTUFBTVEsUUFBUSxJQUFJLElBQUksWUFBWTtJQUNoRDtJQUNBLElBQUlSLE1BQU1TLEdBQUcsRUFBRTtRQUNYLElBQUksRUFBRWpELEtBQUssRUFBRVQsSUFBSSxFQUFFLEdBQUdpRCxNQUFNUyxHQUFHLEVBQUV2TCxPQUFPc0ksS0FBSyxDQUFDLEVBQUUsR0FBR2lDLE9BQU90SixHQUFHLEdBQUc4SixPQUFPOUssS0FBS3FJLEtBQUssQ0FBQyxFQUFFLEdBQUdpQyxPQUFPdEosR0FBRyxHQUFHOEo7UUFDcEdDLE9BQU9RLE9BQU8sR0FBRztZQUFDO2dCQUNWMUwsTUFBTTtnQkFDTjJMLE9BQU03RCxJQUFJLEVBQUVtRCxLQUFLO29CQUNibkQsS0FBS2lCLFFBQVEsQ0FBQzt3QkFBRUosU0FBUzs0QkFBRXpJLE1BQU0rSyxRQUFRL0s7NEJBQU1DLElBQUk4SyxRQUFROUs7NEJBQUl5SSxRQUFRYjt3QkFBSzt3QkFBR21CLGdCQUFnQjtvQkFBSztnQkFDeEc7WUFDSjtTQUFFO0lBQ1Y7SUFDQSxPQUFPZ0M7QUFDWDtBQUUyTSIsInNvdXJjZXMiOlsid2VicGFjazovL21iYy8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sYW5nLWphdmFzY3JpcHQvZGlzdC9pbmRleC5qcz9mOThkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhcnNlciB9IGZyb20gJ0BsZXplci9qYXZhc2NyaXB0JztcbmltcG9ydCB7IHN5bnRheFRyZWUsIExSTGFuZ3VhZ2UsIGluZGVudE5vZGVQcm9wLCBjb250aW51ZWRJbmRlbnQsIGZsYXRJbmRlbnQsIGRlbGltaXRlZEluZGVudCwgZm9sZE5vZGVQcm9wLCBmb2xkSW5zaWRlLCBkZWZpbmVMYW5ndWFnZUZhY2V0LCBzdWJsYW5ndWFnZVByb3AsIExhbmd1YWdlU3VwcG9ydCB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJztcbmltcG9ydCB7IEVkaXRvclNlbGVjdGlvbiB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IEVkaXRvclZpZXcgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IHNuaXBwZXRDb21wbGV0aW9uLCBpZk5vdEluLCBjb21wbGV0ZUZyb21MaXN0IH0gZnJvbSAnQGNvZGVtaXJyb3IvYXV0b2NvbXBsZXRlJztcbmltcG9ydCB7IE5vZGVXZWFrTWFwLCBJdGVyTW9kZSB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuXG4vKipcbkEgY29sbGVjdGlvbiBvZiBKYXZhU2NyaXB0LXJlbGF0ZWRcbltzbmlwcGV0c10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuc25pcHBldCkuXG4qL1xuY29uc3Qgc25pcHBldHMgPSBbXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiZnVuY3Rpb24gJHtuYW1lfSgke3BhcmFtc30pIHtcXG5cXHQke31cXG59XCIsIHtcbiAgICAgICAgbGFiZWw6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgZGV0YWlsOiBcImRlZmluaXRpb25cIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJmb3IgKGxldCAke2luZGV4fSA9IDA7ICR7aW5kZXh9IDwgJHtib3VuZH07ICR7aW5kZXh9KyspIHtcXG5cXHQke31cXG59XCIsIHtcbiAgICAgICAgbGFiZWw6IFwiZm9yXCIsXG4gICAgICAgIGRldGFpbDogXCJsb29wXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiZm9yIChsZXQgJHtuYW1lfSBvZiAke2NvbGxlY3Rpb259KSB7XFxuXFx0JHt9XFxufVwiLCB7XG4gICAgICAgIGxhYmVsOiBcImZvclwiLFxuICAgICAgICBkZXRhaWw6IFwib2YgbG9vcFwiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcImRvIHtcXG5cXHQke31cXG59IHdoaWxlICgke30pXCIsIHtcbiAgICAgICAgbGFiZWw6IFwiZG9cIixcbiAgICAgICAgZGV0YWlsOiBcImxvb3BcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJ3aGlsZSAoJHt9KSB7XFxuXFx0JHt9XFxufVwiLCB7XG4gICAgICAgIGxhYmVsOiBcIndoaWxlXCIsXG4gICAgICAgIGRldGFpbDogXCJsb29wXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwidHJ5IHtcXG5cXHQke31cXG59IGNhdGNoICgke2Vycm9yfSkge1xcblxcdCR7fVxcbn1cIiwge1xuICAgICAgICBsYWJlbDogXCJ0cnlcIixcbiAgICAgICAgZGV0YWlsOiBcIi8gY2F0Y2ggYmxvY2tcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJpZiAoJHt9KSB7XFxuXFx0JHt9XFxufVwiLCB7XG4gICAgICAgIGxhYmVsOiBcImlmXCIsXG4gICAgICAgIGRldGFpbDogXCJibG9ja1wiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcImlmICgke30pIHtcXG5cXHQke31cXG59IGVsc2Uge1xcblxcdCR7fVxcbn1cIiwge1xuICAgICAgICBsYWJlbDogXCJpZlwiLFxuICAgICAgICBkZXRhaWw6IFwiLyBlbHNlIGJsb2NrXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiY2xhc3MgJHtuYW1lfSB7XFxuXFx0Y29uc3RydWN0b3IoJHtwYXJhbXN9KSB7XFxuXFx0XFx0JHt9XFxuXFx0fVxcbn1cIiwge1xuICAgICAgICBsYWJlbDogXCJjbGFzc1wiLFxuICAgICAgICBkZXRhaWw6IFwiZGVmaW5pdGlvblwiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcImltcG9ydCB7JHtuYW1lc319IGZyb20gXFxcIiR7bW9kdWxlfVxcXCJcXG4ke31cIiwge1xuICAgICAgICBsYWJlbDogXCJpbXBvcnRcIixcbiAgICAgICAgZGV0YWlsOiBcIm5hbWVkXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiaW1wb3J0ICR7bmFtZX0gZnJvbSBcXFwiJHttb2R1bGV9XFxcIlxcbiR7fVwiLCB7XG4gICAgICAgIGxhYmVsOiBcImltcG9ydFwiLFxuICAgICAgICBkZXRhaWw6IFwiZGVmYXVsdFwiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pXG5dO1xuLyoqXG5BIGNvbGxlY3Rpb24gb2Ygc25pcHBldCBjb21wbGV0aW9ucyBmb3IgVHlwZVNjcmlwdC4gSW5jbHVkZXMgdGhlXG5KYXZhU2NyaXB0IFtzbmlwcGV0c10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5nLWphdmFzY3JpcHQuc25pcHBldHMpLlxuKi9cbmNvbnN0IHR5cGVzY3JpcHRTbmlwcGV0cyA9IC8qQF9fUFVSRV9fKi9zbmlwcGV0cy5jb25jYXQoW1xuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcImludGVyZmFjZSAke25hbWV9IHtcXG5cXHQke31cXG59XCIsIHtcbiAgICAgICAgbGFiZWw6IFwiaW50ZXJmYWNlXCIsXG4gICAgICAgIGRldGFpbDogXCJkZWZpbml0aW9uXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwidHlwZSAke25hbWV9ID0gJHt0eXBlfVwiLCB7XG4gICAgICAgIGxhYmVsOiBcInR5cGVcIixcbiAgICAgICAgZGV0YWlsOiBcImRlZmluaXRpb25cIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJlbnVtICR7bmFtZX0ge1xcblxcdCR7fVxcbn1cIiwge1xuICAgICAgICBsYWJlbDogXCJlbnVtXCIsXG4gICAgICAgIGRldGFpbDogXCJkZWZpbml0aW9uXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSlcbl0pO1xuXG5jb25zdCBjYWNoZSA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVdlYWtNYXAoKTtcbmNvbnN0IFNjb3BlTm9kZXMgPSAvKkBfX1BVUkVfXyovbmV3IFNldChbXG4gICAgXCJTY3JpcHRcIiwgXCJCbG9ja1wiLFxuICAgIFwiRnVuY3Rpb25FeHByZXNzaW9uXCIsIFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiLCBcIkFycm93RnVuY3Rpb25cIiwgXCJNZXRob2REZWNsYXJhdGlvblwiLFxuICAgIFwiRm9yU3RhdGVtZW50XCJcbl0pO1xuZnVuY3Rpb24gZGVmSUQodHlwZSkge1xuICAgIHJldHVybiAobm9kZSwgZGVmKSA9PiB7XG4gICAgICAgIGxldCBpZCA9IG5vZGUubm9kZS5nZXRDaGlsZChcIlZhcmlhYmxlRGVmaW5pdGlvblwiKTtcbiAgICAgICAgaWYgKGlkKVxuICAgICAgICAgICAgZGVmKGlkLCB0eXBlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbmNvbnN0IGZ1bmN0aW9uQ29udGV4dCA9IFtcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIl07XG5jb25zdCBnYXRoZXJDb21wbGV0aW9ucyA9IHtcbiAgICBGdW5jdGlvbkRlY2xhcmF0aW9uOiAvKkBfX1BVUkVfXyovZGVmSUQoXCJmdW5jdGlvblwiKSxcbiAgICBDbGFzc0RlY2xhcmF0aW9uOiAvKkBfX1BVUkVfXyovZGVmSUQoXCJjbGFzc1wiKSxcbiAgICBDbGFzc0V4cHJlc3Npb246ICgpID0+IHRydWUsXG4gICAgRW51bURlY2xhcmF0aW9uOiAvKkBfX1BVUkVfXyovZGVmSUQoXCJjb25zdGFudFwiKSxcbiAgICBUeXBlQWxpYXNEZWNsYXJhdGlvbjogLypAX19QVVJFX18qL2RlZklEKFwidHlwZVwiKSxcbiAgICBOYW1lc3BhY2VEZWNsYXJhdGlvbjogLypAX19QVVJFX18qL2RlZklEKFwibmFtZXNwYWNlXCIpLFxuICAgIFZhcmlhYmxlRGVmaW5pdGlvbihub2RlLCBkZWYpIHsgaWYgKCFub2RlLm1hdGNoQ29udGV4dChmdW5jdGlvbkNvbnRleHQpKVxuICAgICAgICBkZWYobm9kZSwgXCJ2YXJpYWJsZVwiKTsgfSxcbiAgICBUeXBlRGVmaW5pdGlvbihub2RlLCBkZWYpIHsgZGVmKG5vZGUsIFwidHlwZVwiKTsgfSxcbiAgICBfX3Byb3RvX186IG51bGxcbn07XG5mdW5jdGlvbiBnZXRTY29wZShkb2MsIG5vZGUpIHtcbiAgICBsZXQgY2FjaGVkID0gY2FjaGUuZ2V0KG5vZGUpO1xuICAgIGlmIChjYWNoZWQpXG4gICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgbGV0IGNvbXBsZXRpb25zID0gW10sIHRvcCA9IHRydWU7XG4gICAgZnVuY3Rpb24gZGVmKG5vZGUsIHR5cGUpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBkb2Muc2xpY2VTdHJpbmcobm9kZS5mcm9tLCBub2RlLnRvKTtcbiAgICAgICAgY29tcGxldGlvbnMucHVzaCh7IGxhYmVsOiBuYW1lLCB0eXBlIH0pO1xuICAgIH1cbiAgICBub2RlLmN1cnNvcihJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKS5pdGVyYXRlKG5vZGUgPT4ge1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgICB0b3AgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5hbWUpIHtcbiAgICAgICAgICAgIGxldCBnYXRoZXIgPSBnYXRoZXJDb21wbGV0aW9uc1tub2RlLm5hbWVdO1xuICAgICAgICAgICAgaWYgKGdhdGhlciAmJiBnYXRoZXIobm9kZSwgZGVmKSB8fCBTY29wZU5vZGVzLmhhcyhub2RlLm5hbWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLnRvIC0gbm9kZS5mcm9tID4gODE5Mikge1xuICAgICAgICAgICAgLy8gQWxsb3cgY2FjaGluZyBmb3IgYmlnZ2VyIGludGVybmFsIG5vZGVzXG4gICAgICAgICAgICBmb3IgKGxldCBjIG9mIGdldFNjb3BlKGRvYywgbm9kZS5ub2RlKSlcbiAgICAgICAgICAgICAgICBjb21wbGV0aW9ucy5wdXNoKGMpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY2FjaGUuc2V0KG5vZGUsIGNvbXBsZXRpb25zKTtcbiAgICByZXR1cm4gY29tcGxldGlvbnM7XG59XG5jb25zdCBJZGVudGlmaWVyID0gL15bXFx3JFxceGExLVxcdWZmZmZdW1xcdyRcXGRcXHhhMS1cXHVmZmZmXSokLztcbmNvbnN0IGRvbnRDb21wbGV0ZSA9IFtcbiAgICBcIlRlbXBsYXRlU3RyaW5nXCIsIFwiU3RyaW5nXCIsIFwiUmVnRXhwXCIsXG4gICAgXCJMaW5lQ29tbWVudFwiLCBcIkJsb2NrQ29tbWVudFwiLFxuICAgIFwiVmFyaWFibGVEZWZpbml0aW9uXCIsIFwiVHlwZURlZmluaXRpb25cIiwgXCJMYWJlbFwiLFxuICAgIFwiUHJvcGVydHlEZWZpbml0aW9uXCIsIFwiUHJvcGVydHlOYW1lXCIsXG4gICAgXCJQcml2YXRlUHJvcGVydHlEZWZpbml0aW9uXCIsIFwiUHJpdmF0ZVByb3BlcnR5TmFtZVwiLFxuICAgIFwiLlwiLCBcIj8uXCJcbl07XG4vKipcbkNvbXBsZXRpb24gc291cmNlIHRoYXQgbG9va3MgdXAgbG9jYWxseSBkZWZpbmVkIG5hbWVzIGluXG5KYXZhU2NyaXB0IGNvZGUuXG4qL1xuZnVuY3Rpb24gbG9jYWxDb21wbGV0aW9uU291cmNlKGNvbnRleHQpIHtcbiAgICBsZXQgaW5uZXIgPSBzeW50YXhUcmVlKGNvbnRleHQuc3RhdGUpLnJlc29sdmVJbm5lcihjb250ZXh0LnBvcywgLTEpO1xuICAgIGlmIChkb250Q29tcGxldGUuaW5kZXhPZihpbm5lci5uYW1lKSA+IC0xKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgaXNXb3JkID0gaW5uZXIubmFtZSA9PSBcIlZhcmlhYmxlTmFtZVwiIHx8XG4gICAgICAgIGlubmVyLnRvIC0gaW5uZXIuZnJvbSA8IDIwICYmIElkZW50aWZpZXIudGVzdChjb250ZXh0LnN0YXRlLnNsaWNlRG9jKGlubmVyLmZyb20sIGlubmVyLnRvKSk7XG4gICAgaWYgKCFpc1dvcmQgJiYgIWNvbnRleHQuZXhwbGljaXQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBvcHRpb25zID0gW107XG4gICAgZm9yIChsZXQgcG9zID0gaW5uZXI7IHBvczsgcG9zID0gcG9zLnBhcmVudCkge1xuICAgICAgICBpZiAoU2NvcGVOb2Rlcy5oYXMocG9zLm5hbWUpKVxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMuY29uY2F0KGdldFNjb3BlKGNvbnRleHQuc3RhdGUuZG9jLCBwb3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgZnJvbTogaXNXb3JkID8gaW5uZXIuZnJvbSA6IGNvbnRleHQucG9zLFxuICAgICAgICB2YWxpZEZvcjogSWRlbnRpZmllclxuICAgIH07XG59XG5mdW5jdGlvbiBwYXRoRm9yKHJlYWQsIG1lbWJlciwgbmFtZSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgcGF0aCA9IFtdO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IG9iaiA9IG1lbWJlci5maXJzdENoaWxkLCBwcm9wO1xuICAgICAgICBpZiAoKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iai5uYW1lKSA9PSBcIlZhcmlhYmxlTmFtZVwiKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2gocmVhZChvYmopKTtcbiAgICAgICAgICAgIHJldHVybiB7IHBhdGg6IHBhdGgucmV2ZXJzZSgpLCBuYW1lIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iai5uYW1lKSA9PSBcIk1lbWJlckV4cHJlc3Npb25cIiAmJiAoKF9hID0gKHByb3AgPSBvYmoubGFzdENoaWxkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpID09IFwiUHJvcGVydHlOYW1lXCIpIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChyZWFkKHByb3ApKTtcbiAgICAgICAgICAgIG1lbWJlciA9IG9iajtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG5IZWxwZXIgZnVuY3Rpb24gZm9yIGRlZmluaW5nIEphdmFTY3JpcHQgY29tcGxldGlvbiBzb3VyY2VzLiBJdFxucmV0dXJucyB0aGUgY29tcGxldGFibGUgbmFtZSBhbmQgb2JqZWN0IHBhdGggZm9yIGEgY29tcGxldGlvblxuY29udGV4dCwgb3IgbnVsbCBpZiBubyBuYW1lL3Byb3BlcnR5IGNvbXBsZXRpb24gc2hvdWxkIGhhcHBlbiBhdFxudGhhdCBwb3NpdGlvbi4gRm9yIGV4YW1wbGUsIHdoZW4gY29tcGxldGluZyBhZnRlciBgYS5iLmNgIGl0IHdpbGxcbnJldHVybiBge3BhdGg6IFtcImFcIiwgXCJiXCJdLCBuYW1lOiBcImNcIn1gLiBXaGVuIGNvbXBsZXRpbmcgYWZ0ZXIgYHhgXG5pdCB3aWxsIHJldHVybiBge3BhdGg6IFtdLCBuYW1lOiBcInhcIn1gLiBXaGVuIG5vdCBpbiBhIHByb3BlcnR5IG9yXG5uYW1lLCBpdCB3aWxsIHJldHVybiBudWxsIGlmIGBjb250ZXh0LmV4cGxpY2l0YCBpcyBmYWxzZSwgYW5kXG5ge3BhdGg6IFtdLCBuYW1lOiBcIlwifWAgb3RoZXJ3aXNlLlxuKi9cbmZ1bmN0aW9uIGNvbXBsZXRpb25QYXRoKGNvbnRleHQpIHtcbiAgICBsZXQgcmVhZCA9IChub2RlKSA9PiBjb250ZXh0LnN0YXRlLmRvYy5zbGljZVN0cmluZyhub2RlLmZyb20sIG5vZGUudG8pO1xuICAgIGxldCBpbm5lciA9IHN5bnRheFRyZWUoY29udGV4dC5zdGF0ZSkucmVzb2x2ZUlubmVyKGNvbnRleHQucG9zLCAtMSk7XG4gICAgaWYgKGlubmVyLm5hbWUgPT0gXCJQcm9wZXJ0eU5hbWVcIikge1xuICAgICAgICByZXR1cm4gcGF0aEZvcihyZWFkLCBpbm5lci5wYXJlbnQsIHJlYWQoaW5uZXIpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKGlubmVyLm5hbWUgPT0gXCIuXCIgfHwgaW5uZXIubmFtZSA9PSBcIj8uXCIpICYmIGlubmVyLnBhcmVudC5uYW1lID09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIHJldHVybiBwYXRoRm9yKHJlYWQsIGlubmVyLnBhcmVudCwgXCJcIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRvbnRDb21wbGV0ZS5pbmRleE9mKGlubmVyLm5hbWUpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlubmVyLm5hbWUgPT0gXCJWYXJpYWJsZU5hbWVcIiB8fCBpbm5lci50byAtIGlubmVyLmZyb20gPCAyMCAmJiBJZGVudGlmaWVyLnRlc3QocmVhZChpbm5lcikpKSB7XG4gICAgICAgIHJldHVybiB7IHBhdGg6IFtdLCBuYW1lOiByZWFkKGlubmVyKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChpbm5lci5uYW1lID09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIHJldHVybiBwYXRoRm9yKHJlYWQsIGlubmVyLCBcIlwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmV4cGxpY2l0ID8geyBwYXRoOiBbXSwgbmFtZTogXCJcIiB9IDogbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBlbnVtZXJhdGVQcm9wZXJ0eUNvbXBsZXRpb25zKG9iaiwgdG9wKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBbXSwgc2VlbiA9IG5ldyBTZXQ7XG4gICAgZm9yIChsZXQgZGVwdGggPSAwOzsgZGVwdGgrKykge1xuICAgICAgICBmb3IgKGxldCBuYW1lIG9mIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBPYmplY3Qua2V5cykob2JqKSkge1xuICAgICAgICAgICAgaWYgKCEvXlthLXpBLVpfJFxceGFhLVxcdWZmZGNdW1xcdyRcXHhhYS1cXHVmZmRjXSokLy50ZXN0KG5hbWUpIHx8IHNlZW4uaGFzKG5hbWUpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgc2Vlbi5hZGQobmFtZSk7XG4gICAgICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbGFiZWw6IG5hbWUsXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZW9mIHZhbHVlID09IFwiZnVuY3Rpb25cIiA/ICgvXltBLVpdLy50ZXN0KG5hbWUpID8gXCJjbGFzc1wiIDogdG9wID8gXCJmdW5jdGlvblwiIDogXCJtZXRob2RcIilcbiAgICAgICAgICAgICAgICAgICAgOiB0b3AgPyBcInZhcmlhYmxlXCIgOiBcInByb3BlcnR5XCIsXG4gICAgICAgICAgICAgICAgYm9vc3Q6IC1kZXB0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgICAgICAgaWYgKCFuZXh0KVxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICAgIG9iaiA9IG5leHQ7XG4gICAgfVxufVxuLyoqXG5EZWZpbmVzIGEgW2NvbXBsZXRpb24gc291cmNlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5Db21wbGV0aW9uU291cmNlKSB0aGF0XG5jb21wbGV0ZXMgZnJvbSB0aGUgZ2l2ZW4gc2NvcGUgb2JqZWN0IChmb3IgZXhhbXBsZSBgZ2xvYmFsVGhpc2ApLlxuV2lsbCBlbnRlciBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3Qgd2hlbiBjb21wbGV0aW5nIHByb3BlcnRpZXMgb25cbmEgZGlyZWN0bHktbmFtZWQgcGF0aC5cbiovXG5mdW5jdGlvbiBzY29wZUNvbXBsZXRpb25Tb3VyY2Uoc2NvcGUpIHtcbiAgICBsZXQgY2FjaGUgPSBuZXcgTWFwO1xuICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBsZXQgcGF0aCA9IGNvbXBsZXRpb25QYXRoKGNvbnRleHQpO1xuICAgICAgICBpZiAoIXBhdGgpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHRhcmdldCA9IHNjb3BlO1xuICAgICAgICBmb3IgKGxldCBzdGVwIG9mIHBhdGgucGF0aCkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0W3N0ZXBdO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9wdGlvbnMgPSBjYWNoZS5nZXQodGFyZ2V0KTtcbiAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgY2FjaGUuc2V0KHRhcmdldCwgb3B0aW9ucyA9IGVudW1lcmF0ZVByb3BlcnR5Q29tcGxldGlvbnModGFyZ2V0LCAhcGF0aC5wYXRoLmxlbmd0aCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvbTogY29udGV4dC5wb3MgLSBwYXRoLm5hbWUubGVuZ3RoLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIHZhbGlkRm9yOiBJZGVudGlmaWVyXG4gICAgICAgIH07XG4gICAgfTtcbn1cblxuLyoqXG5BIGxhbmd1YWdlIHByb3ZpZGVyIGJhc2VkIG9uIHRoZSBbTGV6ZXIgSmF2YVNjcmlwdFxucGFyc2VyXShodHRwczovL2dpdGh1Yi5jb20vbGV6ZXItcGFyc2VyL2phdmFzY3JpcHQpLCBleHRlbmRlZCB3aXRoXG5oaWdobGlnaHRpbmcgYW5kIGluZGVudGF0aW9uIGluZm9ybWF0aW9uLlxuKi9cbmNvbnN0IGphdmFzY3JpcHRMYW5ndWFnZSA9IC8qQF9fUFVSRV9fKi9MUkxhbmd1YWdlLmRlZmluZSh7XG4gICAgbmFtZTogXCJqYXZhc2NyaXB0XCIsXG4gICAgcGFyc2VyOiAvKkBfX1BVUkVfXyovcGFyc2VyLmNvbmZpZ3VyZSh7XG4gICAgICAgIHByb3BzOiBbXG4gICAgICAgICAgICAvKkBfX1BVUkVfXyovaW5kZW50Tm9kZVByb3AuYWRkKHtcbiAgICAgICAgICAgICAgICBJZlN0YXRlbWVudDogLypAX19QVVJFX18qL2NvbnRpbnVlZEluZGVudCh7IGV4Y2VwdDogL15cXHMqKHt8ZWxzZVxcYikvIH0pLFxuICAgICAgICAgICAgICAgIFRyeVN0YXRlbWVudDogLypAX19QVVJFX18qL2NvbnRpbnVlZEluZGVudCh7IGV4Y2VwdDogL15cXHMqKHt8Y2F0Y2hcXGJ8ZmluYWxseVxcYikvIH0pLFxuICAgICAgICAgICAgICAgIExhYmVsZWRTdGF0ZW1lbnQ6IGZsYXRJbmRlbnQsXG4gICAgICAgICAgICAgICAgU3dpdGNoQm9keTogY29udGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhZnRlciA9IGNvbnRleHQudGV4dEFmdGVyLCBjbG9zZWQgPSAvXlxccypcXH0vLnRlc3QoYWZ0ZXIpLCBpc0Nhc2UgPSAvXlxccyooY2FzZXxkZWZhdWx0KVxcYi8udGVzdChhZnRlcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmJhc2VJbmRlbnQgKyAoY2xvc2VkID8gMCA6IGlzQ2FzZSA/IDEgOiAyKSAqIGNvbnRleHQudW5pdDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIEJsb2NrOiAvKkBfX1BVUkVfXyovZGVsaW1pdGVkSW5kZW50KHsgY2xvc2luZzogXCJ9XCIgfSksXG4gICAgICAgICAgICAgICAgQXJyb3dGdW5jdGlvbjogY3ggPT4gY3guYmFzZUluZGVudCArIGN4LnVuaXQsXG4gICAgICAgICAgICAgICAgXCJUZW1wbGF0ZVN0cmluZyBCbG9ja0NvbW1lbnRcIjogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgICAgICBcIlN0YXRlbWVudCBQcm9wZXJ0eVwiOiAvKkBfX1BVUkVfXyovY29udGludWVkSW5kZW50KHsgZXhjZXB0OiAvXnsvIH0pLFxuICAgICAgICAgICAgICAgIEpTWEVsZW1lbnQoY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2xvc2VkID0gL15cXHMqPFxcLy8udGVzdChjb250ZXh0LnRleHRBZnRlcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmxpbmVJbmRlbnQoY29udGV4dC5ub2RlLmZyb20pICsgKGNsb3NlZCA/IDAgOiBjb250ZXh0LnVuaXQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgSlNYRXNjYXBlKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNsb3NlZCA9IC9cXHMqXFx9Ly50ZXN0KGNvbnRleHQudGV4dEFmdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQubGluZUluZGVudChjb250ZXh0Lm5vZGUuZnJvbSkgKyAoY2xvc2VkID8gMCA6IGNvbnRleHQudW5pdCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIkpTWE9wZW5UYWcgSlNYU2VsZkNsb3NpbmdUYWdcIihjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbHVtbihjb250ZXh0Lm5vZGUuZnJvbSkgKyBjb250ZXh0LnVuaXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAvKkBfX1BVUkVfXyovZm9sZE5vZGVQcm9wLmFkZCh7XG4gICAgICAgICAgICAgICAgXCJCbG9jayBDbGFzc0JvZHkgU3dpdGNoQm9keSBFbnVtQm9keSBPYmplY3RFeHByZXNzaW9uIEFycmF5RXhwcmVzc2lvbiBPYmplY3RUeXBlXCI6IGZvbGRJbnNpZGUsXG4gICAgICAgICAgICAgICAgQmxvY2tDb21tZW50KHRyZWUpIHsgcmV0dXJuIHsgZnJvbTogdHJlZS5mcm9tICsgMiwgdG86IHRyZWUudG8gLSAyIH07IH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIF1cbiAgICB9KSxcbiAgICBsYW5ndWFnZURhdGE6IHtcbiAgICAgICAgY2xvc2VCcmFja2V0czogeyBicmFja2V0czogW1wiKFwiLCBcIltcIiwgXCJ7XCIsIFwiJ1wiLCAnXCInLCBcImBcIl0gfSxcbiAgICAgICAgY29tbWVudFRva2VuczogeyBsaW5lOiBcIi8vXCIsIGJsb2NrOiB7IG9wZW46IFwiLypcIiwgY2xvc2U6IFwiKi9cIiB9IH0sXG4gICAgICAgIGluZGVudE9uSW5wdXQ6IC9eXFxzKig/OmNhc2UgfGRlZmF1bHQ6fFxce3xcXH18PFxcLykkLyxcbiAgICAgICAgd29yZENoYXJzOiBcIiRcIlxuICAgIH1cbn0pO1xuY29uc3QganN4U3VibGFuZ3VhZ2UgPSB7XG4gICAgdGVzdDogbm9kZSA9PiAvXkpTWC8udGVzdChub2RlLm5hbWUpLFxuICAgIGZhY2V0OiAvKkBfX1BVUkVfXyovZGVmaW5lTGFuZ3VhZ2VGYWNldCh7IGNvbW1lbnRUb2tlbnM6IHsgYmxvY2s6IHsgb3BlbjogXCJ7LypcIiwgY2xvc2U6IFwiKi99XCIgfSB9IH0pXG59O1xuLyoqXG5BIGxhbmd1YWdlIHByb3ZpZGVyIGZvciBUeXBlU2NyaXB0LlxuKi9cbmNvbnN0IHR5cGVzY3JpcHRMYW5ndWFnZSA9IC8qQF9fUFVSRV9fKi9qYXZhc2NyaXB0TGFuZ3VhZ2UuY29uZmlndXJlKHsgZGlhbGVjdDogXCJ0c1wiIH0sIFwidHlwZXNjcmlwdFwiKTtcbi8qKlxuTGFuZ3VhZ2UgcHJvdmlkZXIgZm9yIEpTWC5cbiovXG5jb25zdCBqc3hMYW5ndWFnZSA9IC8qQF9fUFVSRV9fKi9qYXZhc2NyaXB0TGFuZ3VhZ2UuY29uZmlndXJlKHtcbiAgICBkaWFsZWN0OiBcImpzeFwiLFxuICAgIHByb3BzOiBbLypAX19QVVJFX18qL3N1Ymxhbmd1YWdlUHJvcC5hZGQobiA9PiBuLmlzVG9wID8gW2pzeFN1Ymxhbmd1YWdlXSA6IHVuZGVmaW5lZCldXG59KTtcbi8qKlxuTGFuZ3VhZ2UgcHJvdmlkZXIgZm9yIEpTWCArIFR5cGVTY3JpcHQuXG4qL1xuY29uc3QgdHN4TGFuZ3VhZ2UgPSAvKkBfX1BVUkVfXyovamF2YXNjcmlwdExhbmd1YWdlLmNvbmZpZ3VyZSh7XG4gICAgZGlhbGVjdDogXCJqc3ggdHNcIixcbiAgICBwcm9wczogWy8qQF9fUFVSRV9fKi9zdWJsYW5ndWFnZVByb3AuYWRkKG4gPT4gbi5pc1RvcCA/IFtqc3hTdWJsYW5ndWFnZV0gOiB1bmRlZmluZWQpXVxufSwgXCJ0eXBlc2NyaXB0XCIpO1xubGV0IGt3Q29tcGxldGlvbiA9IChuYW1lKSA9PiAoeyBsYWJlbDogbmFtZSwgdHlwZTogXCJrZXl3b3JkXCIgfSk7XG5jb25zdCBrZXl3b3JkcyA9IC8qQF9fUFVSRV9fKi9cImJyZWFrIGNhc2UgY29uc3QgY29udGludWUgZGVmYXVsdCBkZWxldGUgZXhwb3J0IGV4dGVuZHMgZmFsc2UgZmluYWxseSBpbiBpbnN0YW5jZW9mIGxldCBuZXcgcmV0dXJuIHN0YXRpYyBzdXBlciBzd2l0Y2ggdGhpcyB0aHJvdyB0cnVlIHR5cGVvZiB2YXIgeWllbGRcIi5zcGxpdChcIiBcIikubWFwKGt3Q29tcGxldGlvbik7XG5jb25zdCB0eXBlc2NyaXB0S2V5d29yZHMgPSAvKkBfX1BVUkVfXyova2V5d29yZHMuY29uY2F0KC8qQF9fUFVSRV9fKi9bXCJkZWNsYXJlXCIsIFwiaW1wbGVtZW50c1wiLCBcInByaXZhdGVcIiwgXCJwcm90ZWN0ZWRcIiwgXCJwdWJsaWNcIl0ubWFwKGt3Q29tcGxldGlvbikpO1xuLyoqXG5KYXZhU2NyaXB0IHN1cHBvcnQuIEluY2x1ZGVzIFtzbmlwcGV0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmctamF2YXNjcmlwdC5zbmlwcGV0cylcbmNvbXBsZXRpb24uXG4qL1xuZnVuY3Rpb24gamF2YXNjcmlwdChjb25maWcgPSB7fSkge1xuICAgIGxldCBsYW5nID0gY29uZmlnLmpzeCA/IChjb25maWcudHlwZXNjcmlwdCA/IHRzeExhbmd1YWdlIDoganN4TGFuZ3VhZ2UpXG4gICAgICAgIDogY29uZmlnLnR5cGVzY3JpcHQgPyB0eXBlc2NyaXB0TGFuZ3VhZ2UgOiBqYXZhc2NyaXB0TGFuZ3VhZ2U7XG4gICAgbGV0IGNvbXBsZXRpb25zID0gY29uZmlnLnR5cGVzY3JpcHQgPyB0eXBlc2NyaXB0U25pcHBldHMuY29uY2F0KHR5cGVzY3JpcHRLZXl3b3JkcykgOiBzbmlwcGV0cy5jb25jYXQoa2V5d29yZHMpO1xuICAgIHJldHVybiBuZXcgTGFuZ3VhZ2VTdXBwb3J0KGxhbmcsIFtcbiAgICAgICAgamF2YXNjcmlwdExhbmd1YWdlLmRhdGEub2Yoe1xuICAgICAgICAgICAgYXV0b2NvbXBsZXRlOiBpZk5vdEluKGRvbnRDb21wbGV0ZSwgY29tcGxldGVGcm9tTGlzdChjb21wbGV0aW9ucykpXG4gICAgICAgIH0pLFxuICAgICAgICBqYXZhc2NyaXB0TGFuZ3VhZ2UuZGF0YS5vZih7XG4gICAgICAgICAgICBhdXRvY29tcGxldGU6IGxvY2FsQ29tcGxldGlvblNvdXJjZVxuICAgICAgICB9KSxcbiAgICAgICAgY29uZmlnLmpzeCA/IGF1dG9DbG9zZVRhZ3MgOiBbXSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIGZpbmRPcGVuVGFnKG5vZGUpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChub2RlLm5hbWUgPT0gXCJKU1hPcGVuVGFnXCIgfHwgbm9kZS5uYW1lID09IFwiSlNYU2VsZkNsb3NpbmdUYWdcIiB8fCBub2RlLm5hbWUgPT0gXCJKU1hGcmFnbWVudFRhZ1wiKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIGlmIChub2RlLm5hbWUgPT0gXCJKU1hFc2NhcGVcIiB8fCAhbm9kZS5wYXJlbnQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVsZW1lbnROYW1lKGRvYywgdHJlZSwgbWF4ID0gZG9jLmxlbmd0aCkge1xuICAgIGZvciAobGV0IGNoID0gdHJlZSA9PT0gbnVsbCB8fCB0cmVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmVlLmZpcnN0Q2hpbGQ7IGNoOyBjaCA9IGNoLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIGlmIChjaC5uYW1lID09IFwiSlNYSWRlbnRpZmllclwiIHx8IGNoLm5hbWUgPT0gXCJKU1hCdWlsdGluXCIgfHwgY2gubmFtZSA9PSBcIkpTWE5hbWVzcGFjZWROYW1lXCIgfHxcbiAgICAgICAgICAgIGNoLm5hbWUgPT0gXCJKU1hNZW1iZXJFeHByZXNzaW9uXCIpXG4gICAgICAgICAgICByZXR1cm4gZG9jLnNsaWNlU3RyaW5nKGNoLmZyb20sIE1hdGgubWluKGNoLnRvLCBtYXgpKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCI7XG59XG5jb25zdCBhbmRyb2lkID0gdHlwZW9mIG5hdmlnYXRvciA9PSBcIm9iamVjdFwiICYmIC8qQF9fUFVSRV9fKi8vQW5kcm9pZFxcYi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbi8qKlxuRXh0ZW5zaW9uIHRoYXQgd2lsbCBhdXRvbWF0aWNhbGx5IGluc2VydCBKU1ggY2xvc2UgdGFncyB3aGVuIGEgYD5gIG9yXG5gL2AgaXMgdHlwZWQuXG4qL1xuY29uc3QgYXV0b0Nsb3NlVGFncyA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmlucHV0SGFuZGxlci5vZigodmlldywgZnJvbSwgdG8sIHRleHQsIGRlZmF1bHRJbnNlcnQpID0+IHtcbiAgICBpZiAoKGFuZHJvaWQgPyB2aWV3LmNvbXBvc2luZyA6IHZpZXcuY29tcG9zaXRpb25TdGFydGVkKSB8fCB2aWV3LnN0YXRlLnJlYWRPbmx5IHx8XG4gICAgICAgIGZyb20gIT0gdG8gfHwgKHRleHQgIT0gXCI+XCIgJiYgdGV4dCAhPSBcIi9cIikgfHxcbiAgICAgICAgIWphdmFzY3JpcHRMYW5ndWFnZS5pc0FjdGl2ZUF0KHZpZXcuc3RhdGUsIGZyb20sIC0xKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBiYXNlID0gZGVmYXVsdEluc2VydCgpLCB7IHN0YXRlIH0gPSBiYXNlO1xuICAgIGxldCBjbG9zZVRhZ3MgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgeyBoZWFkIH0gPSByYW5nZSwgYXJvdW5kID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKGhlYWQgLSAxLCAtMSksIG5hbWU7XG4gICAgICAgIGlmIChhcm91bmQubmFtZSA9PSBcIkpTWFN0YXJ0VGFnXCIpXG4gICAgICAgICAgICBhcm91bmQgPSBhcm91bmQucGFyZW50O1xuICAgICAgICBpZiAoc3RhdGUuZG9jLnNsaWNlU3RyaW5nKGhlYWQgLSAxLCBoZWFkKSAhPSB0ZXh0IHx8IGFyb3VuZC5uYW1lID09IFwiSlNYQXR0cmlidXRlVmFsdWVcIiAmJiBhcm91bmQudG8gPiBoZWFkKSA7XG4gICAgICAgIGVsc2UgaWYgKHRleHQgPT0gXCI+XCIgJiYgYXJvdW5kLm5hbWUgPT0gXCJKU1hGcmFnbWVudFRhZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4geyByYW5nZSwgY2hhbmdlczogeyBmcm9tOiBoZWFkLCBpbnNlcnQ6IGA8Lz5gIH0gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0ZXh0ID09IFwiL1wiICYmIGFyb3VuZC5uYW1lID09IFwiSlNYU3RhcnRDbG9zZVRhZ1wiKSB7XG4gICAgICAgICAgICBsZXQgZW1wdHkgPSBhcm91bmQucGFyZW50LCBiYXNlID0gZW1wdHkucGFyZW50O1xuICAgICAgICAgICAgaWYgKGJhc2UgJiYgZW1wdHkuZnJvbSA9PSBoZWFkIC0gMiAmJlxuICAgICAgICAgICAgICAgICgobmFtZSA9IGVsZW1lbnROYW1lKHN0YXRlLmRvYywgYmFzZS5maXJzdENoaWxkLCBoZWFkKSkgfHwgKChfYSA9IGJhc2UuZmlyc3RDaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpID09IFwiSlNYRnJhZ21lbnRUYWdcIikpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5zZXJ0ID0gYCR7bmFtZX0+YDtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihoZWFkICsgaW5zZXJ0Lmxlbmd0aCwgLTEpLCBjaGFuZ2VzOiB7IGZyb206IGhlYWQsIGluc2VydCB9IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGV4dCA9PSBcIj5cIikge1xuICAgICAgICAgICAgbGV0IG9wZW5UYWcgPSBmaW5kT3BlblRhZyhhcm91bmQpO1xuICAgICAgICAgICAgaWYgKG9wZW5UYWcgJiZcbiAgICAgICAgICAgICAgICAhL15cXC8/PnxePFxcLy8udGVzdChzdGF0ZS5kb2Muc2xpY2VTdHJpbmcoaGVhZCwgaGVhZCArIDIpKSAmJlxuICAgICAgICAgICAgICAgIChuYW1lID0gZWxlbWVudE5hbWUoc3RhdGUuZG9jLCBvcGVuVGFnLCBoZWFkKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UsIGNoYW5nZXM6IHsgZnJvbTogaGVhZCwgaW5zZXJ0OiBgPC8ke25hbWV9PmAgfSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJhbmdlIH07XG4gICAgfSk7XG4gICAgaWYgKGNsb3NlVGFncy5jaGFuZ2VzLmVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaChbXG4gICAgICAgIGJhc2UsXG4gICAgICAgIHN0YXRlLnVwZGF0ZShjbG9zZVRhZ3MsIHsgdXNlckV2ZW50OiBcImlucHV0LmNvbXBsZXRlXCIsIHNjcm9sbEludG9WaWV3OiB0cnVlIH0pXG4gICAgXSk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcblxuLyoqXG5Db25uZWN0cyBhbiBbRVNMaW50XShodHRwczovL2VzbGludC5vcmcvKSBsaW50ZXIgdG8gQ29kZU1pcnJvcidzXG5bbGludF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsaW50KSBpbnRlZ3JhdGlvbi4gYGVzbGludGAgc2hvdWxkIGJlIGFuIGluc3RhbmNlIG9mIHRoZVxuW2BMaW50ZXJgXShodHRwczovL2VzbGludC5vcmcvZG9jcy9kZXZlbG9wZXItZ3VpZGUvbm9kZWpzLWFwaSNsaW50ZXIpXG5jbGFzcywgYW5kIGBjb25maWdgIGFuIG9wdGlvbmFsIEVTTGludCBjb25maWd1cmF0aW9uLiBUaGUgcmV0dXJuXG52YWx1ZSBvZiB0aGlzIGZ1bmN0aW9uIGNhbiBiZSBwYXNzZWQgdG8gW2BsaW50ZXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xpbnQubGludGVyKVxudG8gY3JlYXRlIGEgSmF2YVNjcmlwdCBsaW50aW5nIGV4dGVuc2lvbi5cblxuTm90ZSB0aGF0IEVTTGludCB0YXJnZXRzIG5vZGUsIGFuZCBpcyB0cmlja3kgdG8gcnVuIGluIHRoZVxuYnJvd3Nlci4gVGhlXG5bZXNsaW50LWxpbnRlci1icm93c2VyaWZ5XShodHRwczovL2dpdGh1Yi5jb20vVXppVGVjaC9lc2xpbnQtbGludGVyLWJyb3dzZXJpZnkpXG5wYWNrYWdlIG1heSBoZWxwIHdpdGggdGhhdCAoc2VlXG5bZXhhbXBsZV0oaHR0cHM6Ly9naXRodWIuY29tL1V6aVRlY2gvZXNsaW50LWxpbnRlci1icm93c2VyaWZ5L2Jsb2IvbWFzdGVyL2V4YW1wbGUvc2NyaXB0LmpzKSkuXG4qL1xuZnVuY3Rpb24gZXNMaW50KGVzbGludCwgY29uZmlnKSB7XG4gICAgaWYgKCFjb25maWcpIHtcbiAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgICAgcGFyc2VyT3B0aW9uczogeyBlY21hVmVyc2lvbjogMjAxOSwgc291cmNlVHlwZTogXCJtb2R1bGVcIiB9LFxuICAgICAgICAgICAgZW52OiB7IGJyb3dzZXI6IHRydWUsIG5vZGU6IHRydWUsIGVzNjogdHJ1ZSwgZXMyMDE1OiB0cnVlLCBlczIwMTc6IHRydWUsIGVzMjAyMDogdHJ1ZSB9LFxuICAgICAgICAgICAgcnVsZXM6IHt9XG4gICAgICAgIH07XG4gICAgICAgIGVzbGludC5nZXRSdWxlcygpLmZvckVhY2goKGRlc2MsIG5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmIChkZXNjLm1ldGEuZG9jcy5yZWNvbW1lbmRlZClcbiAgICAgICAgICAgICAgICBjb25maWcucnVsZXNbbmFtZV0gPSAyO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICh2aWV3KSA9PiB7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBmb3VuZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgamF2YXNjcmlwdExhbmd1YWdlLmZpbmRSZWdpb25zKHN0YXRlKSkge1xuICAgICAgICAgICAgbGV0IGZyb21MaW5lID0gc3RhdGUuZG9jLmxpbmVBdChmcm9tKSwgb2Zmc2V0ID0geyBsaW5lOiBmcm9tTGluZS5udW1iZXIgLSAxLCBjb2w6IGZyb20gLSBmcm9tTGluZS5mcm9tLCBwb3M6IGZyb20gfTtcbiAgICAgICAgICAgIGZvciAobGV0IGQgb2YgZXNsaW50LnZlcmlmeShzdGF0ZS5zbGljZURvYyhmcm9tLCB0byksIGNvbmZpZykpXG4gICAgICAgICAgICAgICAgZm91bmQucHVzaCh0cmFuc2xhdGVEaWFnbm9zdGljKGQsIHN0YXRlLmRvYywgb2Zmc2V0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH07XG59XG5mdW5jdGlvbiBtYXBQb3MobGluZSwgY29sLCBkb2MsIG9mZnNldCkge1xuICAgIHJldHVybiBkb2MubGluZShsaW5lICsgb2Zmc2V0LmxpbmUpLmZyb20gKyBjb2wgKyAobGluZSA9PSAxID8gb2Zmc2V0LmNvbCAtIDEgOiAtMSk7XG59XG5mdW5jdGlvbiB0cmFuc2xhdGVEaWFnbm9zdGljKGlucHV0LCBkb2MsIG9mZnNldCkge1xuICAgIGxldCBzdGFydCA9IG1hcFBvcyhpbnB1dC5saW5lLCBpbnB1dC5jb2x1bW4sIGRvYywgb2Zmc2V0KTtcbiAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICBmcm9tOiBzdGFydCxcbiAgICAgICAgdG86IGlucHV0LmVuZExpbmUgIT0gbnVsbCAmJiBpbnB1dC5lbmRDb2x1bW4gIT0gMSA/IG1hcFBvcyhpbnB1dC5lbmRMaW5lLCBpbnB1dC5lbmRDb2x1bW4sIGRvYywgb2Zmc2V0KSA6IHN0YXJ0LFxuICAgICAgICBtZXNzYWdlOiBpbnB1dC5tZXNzYWdlLFxuICAgICAgICBzb3VyY2U6IGlucHV0LnJ1bGVJZCA/IFwiZXNsaW50OlwiICsgaW5wdXQucnVsZUlkIDogXCJlc2xpbnRcIixcbiAgICAgICAgc2V2ZXJpdHk6IGlucHV0LnNldmVyaXR5ID09IDEgPyBcIndhcm5pbmdcIiA6IFwiZXJyb3JcIixcbiAgICB9O1xuICAgIGlmIChpbnB1dC5maXgpIHtcbiAgICAgICAgbGV0IHsgcmFuZ2UsIHRleHQgfSA9IGlucHV0LmZpeCwgZnJvbSA9IHJhbmdlWzBdICsgb2Zmc2V0LnBvcyAtIHN0YXJ0LCB0byA9IHJhbmdlWzFdICsgb2Zmc2V0LnBvcyAtIHN0YXJ0O1xuICAgICAgICByZXN1bHQuYWN0aW9ucyA9IFt7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJmaXhcIixcbiAgICAgICAgICAgICAgICBhcHBseSh2aWV3LCBzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgY2hhbmdlczogeyBmcm9tOiBzdGFydCArIGZyb20sIHRvOiBzdGFydCArIHRvLCBpbnNlcnQ6IHRleHQgfSwgc2Nyb2xsSW50b1ZpZXc6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCB7IGF1dG9DbG9zZVRhZ3MsIGNvbXBsZXRpb25QYXRoLCBlc0xpbnQsIGphdmFzY3JpcHQsIGphdmFzY3JpcHRMYW5ndWFnZSwganN4TGFuZ3VhZ2UsIGxvY2FsQ29tcGxldGlvblNvdXJjZSwgc2NvcGVDb21wbGV0aW9uU291cmNlLCBzbmlwcGV0cywgdHN4TGFuZ3VhZ2UsIHR5cGVzY3JpcHRMYW5ndWFnZSwgdHlwZXNjcmlwdFNuaXBwZXRzIH07XG4iXSwibmFtZXMiOlsicGFyc2VyIiwic3ludGF4VHJlZSIsIkxSTGFuZ3VhZ2UiLCJpbmRlbnROb2RlUHJvcCIsImNvbnRpbnVlZEluZGVudCIsImZsYXRJbmRlbnQiLCJkZWxpbWl0ZWRJbmRlbnQiLCJmb2xkTm9kZVByb3AiLCJmb2xkSW5zaWRlIiwiZGVmaW5lTGFuZ3VhZ2VGYWNldCIsInN1Ymxhbmd1YWdlUHJvcCIsIkxhbmd1YWdlU3VwcG9ydCIsIkVkaXRvclNlbGVjdGlvbiIsIkVkaXRvclZpZXciLCJzbmlwcGV0Q29tcGxldGlvbiIsImlmTm90SW4iLCJjb21wbGV0ZUZyb21MaXN0IiwiTm9kZVdlYWtNYXAiLCJJdGVyTW9kZSIsInNuaXBwZXRzIiwibGFiZWwiLCJkZXRhaWwiLCJ0eXBlIiwidHlwZXNjcmlwdFNuaXBwZXRzIiwiY29uY2F0IiwiY2FjaGUiLCJTY29wZU5vZGVzIiwiU2V0IiwiZGVmSUQiLCJub2RlIiwiZGVmIiwiaWQiLCJnZXRDaGlsZCIsImZ1bmN0aW9uQ29udGV4dCIsImdhdGhlckNvbXBsZXRpb25zIiwiRnVuY3Rpb25EZWNsYXJhdGlvbiIsIkNsYXNzRGVjbGFyYXRpb24iLCJDbGFzc0V4cHJlc3Npb24iLCJFbnVtRGVjbGFyYXRpb24iLCJUeXBlQWxpYXNEZWNsYXJhdGlvbiIsIk5hbWVzcGFjZURlY2xhcmF0aW9uIiwiVmFyaWFibGVEZWZpbml0aW9uIiwibWF0Y2hDb250ZXh0IiwiVHlwZURlZmluaXRpb24iLCJfX3Byb3RvX18iLCJnZXRTY29wZSIsImRvYyIsImNhY2hlZCIsImdldCIsImNvbXBsZXRpb25zIiwidG9wIiwibmFtZSIsInNsaWNlU3RyaW5nIiwiZnJvbSIsInRvIiwicHVzaCIsImN1cnNvciIsIkluY2x1ZGVBbm9ueW1vdXMiLCJpdGVyYXRlIiwiZ2F0aGVyIiwiaGFzIiwiYyIsInNldCIsIklkZW50aWZpZXIiLCJkb250Q29tcGxldGUiLCJsb2NhbENvbXBsZXRpb25Tb3VyY2UiLCJjb250ZXh0IiwiaW5uZXIiLCJzdGF0ZSIsInJlc29sdmVJbm5lciIsInBvcyIsImluZGV4T2YiLCJpc1dvcmQiLCJ0ZXN0Iiwic2xpY2VEb2MiLCJleHBsaWNpdCIsIm9wdGlvbnMiLCJwYXJlbnQiLCJ2YWxpZEZvciIsInBhdGhGb3IiLCJyZWFkIiwibWVtYmVyIiwiX2EiLCJwYXRoIiwib2JqIiwiZmlyc3RDaGlsZCIsInByb3AiLCJyZXZlcnNlIiwibGFzdENoaWxkIiwiY29tcGxldGlvblBhdGgiLCJlbnVtZXJhdGVQcm9wZXJ0eUNvbXBsZXRpb25zIiwic2VlbiIsImRlcHRoIiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImtleXMiLCJhZGQiLCJ2YWx1ZSIsIl8iLCJib29zdCIsIm5leHQiLCJnZXRQcm90b3R5cGVPZiIsInNjb3BlQ29tcGxldGlvblNvdXJjZSIsInNjb3BlIiwiTWFwIiwidGFyZ2V0Iiwic3RlcCIsImxlbmd0aCIsImphdmFzY3JpcHRMYW5ndWFnZSIsImRlZmluZSIsImNvbmZpZ3VyZSIsInByb3BzIiwiSWZTdGF0ZW1lbnQiLCJleGNlcHQiLCJUcnlTdGF0ZW1lbnQiLCJMYWJlbGVkU3RhdGVtZW50IiwiU3dpdGNoQm9keSIsImFmdGVyIiwidGV4dEFmdGVyIiwiY2xvc2VkIiwiaXNDYXNlIiwiYmFzZUluZGVudCIsInVuaXQiLCJCbG9jayIsImNsb3NpbmciLCJBcnJvd0Z1bmN0aW9uIiwiY3giLCJKU1hFbGVtZW50IiwibGluZUluZGVudCIsIkpTWEVzY2FwZSIsImNvbHVtbiIsIkJsb2NrQ29tbWVudCIsInRyZWUiLCJsYW5ndWFnZURhdGEiLCJjbG9zZUJyYWNrZXRzIiwiYnJhY2tldHMiLCJjb21tZW50VG9rZW5zIiwibGluZSIsImJsb2NrIiwib3BlbiIsImNsb3NlIiwiaW5kZW50T25JbnB1dCIsIndvcmRDaGFycyIsImpzeFN1Ymxhbmd1YWdlIiwiZmFjZXQiLCJ0eXBlc2NyaXB0TGFuZ3VhZ2UiLCJkaWFsZWN0IiwianN4TGFuZ3VhZ2UiLCJuIiwiaXNUb3AiLCJ1bmRlZmluZWQiLCJ0c3hMYW5ndWFnZSIsImt3Q29tcGxldGlvbiIsImtleXdvcmRzIiwic3BsaXQiLCJtYXAiLCJ0eXBlc2NyaXB0S2V5d29yZHMiLCJqYXZhc2NyaXB0IiwiY29uZmlnIiwibGFuZyIsImpzeCIsInR5cGVzY3JpcHQiLCJkYXRhIiwib2YiLCJhdXRvY29tcGxldGUiLCJhdXRvQ2xvc2VUYWdzIiwiZmluZE9wZW5UYWciLCJlbGVtZW50TmFtZSIsIm1heCIsImNoIiwibmV4dFNpYmxpbmciLCJNYXRoIiwibWluIiwiYW5kcm9pZCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImlucHV0SGFuZGxlciIsInZpZXciLCJ0ZXh0IiwiZGVmYXVsdEluc2VydCIsImNvbXBvc2luZyIsImNvbXBvc2l0aW9uU3RhcnRlZCIsInJlYWRPbmx5IiwiaXNBY3RpdmVBdCIsImJhc2UiLCJjbG9zZVRhZ3MiLCJjaGFuZ2VCeVJhbmdlIiwicmFuZ2UiLCJoZWFkIiwiYXJvdW5kIiwiY2hhbmdlcyIsImluc2VydCIsImVtcHR5Iiwib3BlblRhZyIsImRpc3BhdGNoIiwidXBkYXRlIiwidXNlckV2ZW50Iiwic2Nyb2xsSW50b1ZpZXciLCJlc0xpbnQiLCJlc2xpbnQiLCJwYXJzZXJPcHRpb25zIiwiZWNtYVZlcnNpb24iLCJzb3VyY2VUeXBlIiwiZW52IiwiYnJvd3NlciIsImVzNiIsImVzMjAxNSIsImVzMjAxNyIsImVzMjAyMCIsInJ1bGVzIiwiZ2V0UnVsZXMiLCJmb3JFYWNoIiwiZGVzYyIsIm1ldGEiLCJkb2NzIiwicmVjb21tZW5kZWQiLCJmb3VuZCIsImZpbmRSZWdpb25zIiwiZnJvbUxpbmUiLCJsaW5lQXQiLCJvZmZzZXQiLCJudW1iZXIiLCJjb2wiLCJkIiwidmVyaWZ5IiwidHJhbnNsYXRlRGlhZ25vc3RpYyIsIm1hcFBvcyIsImlucHV0Iiwic3RhcnQiLCJyZXN1bHQiLCJlbmRMaW5lIiwiZW5kQ29sdW1uIiwibWVzc2FnZSIsInNvdXJjZSIsInJ1bGVJZCIsInNldmVyaXR5IiwiZml4IiwiYWN0aW9ucyIsImFwcGx5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/lang-javascript/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/language/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@codemirror/language/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DocInput: () => (/* binding */ DocInput),\n/* harmony export */   HighlightStyle: () => (/* binding */ HighlightStyle),\n/* harmony export */   IndentContext: () => (/* binding */ IndentContext),\n/* harmony export */   LRLanguage: () => (/* binding */ LRLanguage),\n/* harmony export */   Language: () => (/* binding */ Language),\n/* harmony export */   LanguageDescription: () => (/* binding */ LanguageDescription),\n/* harmony export */   LanguageSupport: () => (/* binding */ LanguageSupport),\n/* harmony export */   ParseContext: () => (/* binding */ ParseContext),\n/* harmony export */   StreamLanguage: () => (/* binding */ StreamLanguage),\n/* harmony export */   StringStream: () => (/* binding */ StringStream),\n/* harmony export */   TreeIndentContext: () => (/* binding */ TreeIndentContext),\n/* harmony export */   bidiIsolates: () => (/* binding */ bidiIsolates),\n/* harmony export */   bracketMatching: () => (/* binding */ bracketMatching),\n/* harmony export */   bracketMatchingHandle: () => (/* binding */ bracketMatchingHandle),\n/* harmony export */   codeFolding: () => (/* binding */ codeFolding),\n/* harmony export */   continuedIndent: () => (/* binding */ continuedIndent),\n/* harmony export */   defaultHighlightStyle: () => (/* binding */ defaultHighlightStyle),\n/* harmony export */   defineLanguageFacet: () => (/* binding */ defineLanguageFacet),\n/* harmony export */   delimitedIndent: () => (/* binding */ delimitedIndent),\n/* harmony export */   ensureSyntaxTree: () => (/* binding */ ensureSyntaxTree),\n/* harmony export */   flatIndent: () => (/* binding */ flatIndent),\n/* harmony export */   foldAll: () => (/* binding */ foldAll),\n/* harmony export */   foldCode: () => (/* binding */ foldCode),\n/* harmony export */   foldEffect: () => (/* binding */ foldEffect),\n/* harmony export */   foldGutter: () => (/* binding */ foldGutter),\n/* harmony export */   foldInside: () => (/* binding */ foldInside),\n/* harmony export */   foldKeymap: () => (/* binding */ foldKeymap),\n/* harmony export */   foldNodeProp: () => (/* binding */ foldNodeProp),\n/* harmony export */   foldService: () => (/* binding */ foldService),\n/* harmony export */   foldState: () => (/* binding */ foldState),\n/* harmony export */   foldable: () => (/* binding */ foldable),\n/* harmony export */   foldedRanges: () => (/* binding */ foldedRanges),\n/* harmony export */   forceParsing: () => (/* binding */ forceParsing),\n/* harmony export */   getIndentUnit: () => (/* binding */ getIndentUnit),\n/* harmony export */   getIndentation: () => (/* binding */ getIndentation),\n/* harmony export */   highlightingFor: () => (/* binding */ highlightingFor),\n/* harmony export */   indentNodeProp: () => (/* binding */ indentNodeProp),\n/* harmony export */   indentOnInput: () => (/* binding */ indentOnInput),\n/* harmony export */   indentRange: () => (/* binding */ indentRange),\n/* harmony export */   indentService: () => (/* binding */ indentService),\n/* harmony export */   indentString: () => (/* binding */ indentString),\n/* harmony export */   indentUnit: () => (/* binding */ indentUnit),\n/* harmony export */   language: () => (/* binding */ language),\n/* harmony export */   languageDataProp: () => (/* binding */ languageDataProp),\n/* harmony export */   matchBrackets: () => (/* binding */ matchBrackets),\n/* harmony export */   sublanguageProp: () => (/* binding */ sublanguageProp),\n/* harmony export */   syntaxHighlighting: () => (/* binding */ syntaxHighlighting),\n/* harmony export */   syntaxParserRunning: () => (/* binding */ syntaxParserRunning),\n/* harmony export */   syntaxTree: () => (/* binding */ syntaxTree),\n/* harmony export */   syntaxTreeAvailable: () => (/* binding */ syntaxTreeAvailable),\n/* harmony export */   toggleFold: () => (/* binding */ toggleFold),\n/* harmony export */   unfoldAll: () => (/* binding */ unfoldAll),\n/* harmony export */   unfoldCode: () => (/* binding */ unfoldCode),\n/* harmony export */   unfoldEffect: () => (/* binding */ unfoldEffect)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/highlight */ \"(ssr)/./node_modules/@lezer/highlight/dist/index.js\");\n/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! style-mod */ \"(ssr)/./node_modules/style-mod/src/style-mod.js\");\n\n\n\n\n\nvar _a;\n/**\nNode prop stored in a parser's top syntax node to provide the\nfacet that stores language-specific data for that language.\n*/ const languageDataProp = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\nHelper function to define a facet (to be added to the top syntax\nnode(s) for a language via\n[`languageDataProp`](https://codemirror.net/6/docs/ref/#language.languageDataProp)), that will be\nused to associate language data with the language. You\nprobably only need this when subclassing\n[`Language`](https://codemirror.net/6/docs/ref/#language.Language).\n*/ function defineLanguageFacet(baseData) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n        combine: baseData ? (values)=>values.concat(baseData) : undefined\n    });\n}\n/**\nSyntax node prop used to register sublanguages. Should be added to\nthe top level node type for the language.\n*/ const sublanguageProp = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\nA language object manages parsing and per-language\n[metadata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt). Parse data is\nmanaged as a [Lezer](https://lezer.codemirror.net) tree. The class\ncan be used directly, via the [`LRLanguage`](https://codemirror.net/6/docs/ref/#language.LRLanguage)\nsubclass for [Lezer](https://lezer.codemirror.net/) LR parsers, or\nvia the [`StreamLanguage`](https://codemirror.net/6/docs/ref/#language.StreamLanguage) subclass\nfor stream parsers.\n*/ class Language {\n    /**\n    Construct a language object. If you need to invoke this\n    directly, first define a data facet with\n    [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then\n    configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it\n    to the language's outer syntax node.\n    */ constructor(/**\n    The [language data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) facet\n    used for this language.\n    */ data, parser, extraExtensions = [], /**\n    A language name.\n    */ name = \"\"){\n        this.data = data;\n        this.name = name;\n        // Kludge to define EditorState.tree as a debugging helper,\n        // without the EditorState package actually knowing about\n        // languages and lezer trees.\n        if (!_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.prototype.hasOwnProperty(\"tree\")) Object.defineProperty(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.prototype, \"tree\", {\n            get () {\n                return syntaxTree(this);\n            }\n        });\n        this.parser = parser;\n        this.extension = [\n            language.of(this),\n            _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.languageData.of((state, pos, side)=>{\n                let top = topNodeAt(state, pos, side), data = top.type.prop(languageDataProp);\n                if (!data) return [];\n                let base = state.facet(data), sub = top.type.prop(sublanguageProp);\n                if (sub) {\n                    let innerNode = top.resolve(pos - top.from, side);\n                    for (let sublang of sub)if (sublang.test(innerNode, state)) {\n                        let data = state.facet(sublang.facet);\n                        return sublang.type == \"replace\" ? data : data.concat(base);\n                    }\n                }\n                return base;\n            })\n        ].concat(extraExtensions);\n    }\n    /**\n    Query whether this language is active at the given position.\n    */ isActiveAt(state, pos, side = -1) {\n        return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;\n    }\n    /**\n    Find the document regions that were parsed using this language.\n    The returned regions will _include_ any nested languages rooted\n    in this language, when those exist.\n    */ findRegions(state) {\n        let lang = state.facet(language);\n        if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data) return [\n            {\n                from: 0,\n                to: state.doc.length\n            }\n        ];\n        if (!lang || !lang.allowsNesting) return [];\n        let result = [];\n        let explore = (tree, from)=>{\n            if (tree.prop(languageDataProp) == this.data) {\n                result.push({\n                    from,\n                    to: from + tree.length\n                });\n                return;\n            }\n            let mount = tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);\n            if (mount) {\n                if (mount.tree.prop(languageDataProp) == this.data) {\n                    if (mount.overlay) for (let r of mount.overlay)result.push({\n                        from: r.from + from,\n                        to: r.to + from\n                    });\n                    else result.push({\n                        from: from,\n                        to: from + tree.length\n                    });\n                    return;\n                } else if (mount.overlay) {\n                    let size = result.length;\n                    explore(mount.tree, mount.overlay[0].from + from);\n                    if (result.length > size) return;\n                }\n            }\n            for(let i = 0; i < tree.children.length; i++){\n                let ch = tree.children[i];\n                if (ch instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) explore(ch, tree.positions[i] + from);\n            }\n        };\n        explore(syntaxTree(state), 0);\n        return result;\n    }\n    /**\n    Indicates whether this language allows nested languages. The\n    default implementation returns true.\n    */ get allowsNesting() {\n        return true;\n    }\n}\n/**\n@internal\n*/ Language.setState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define();\nfunction topNodeAt(state, pos, side) {\n    let topLang = state.facet(language), tree = syntaxTree(state).topNode;\n    if (!topLang || topLang.allowsNesting) {\n        for(let node = tree; node; node = node.enter(pos, side, _lezer_common__WEBPACK_IMPORTED_MODULE_0__.IterMode.ExcludeBuffers))if (node.type.isTop) tree = node;\n    }\n    return tree;\n}\n/**\nA subclass of [`Language`](https://codemirror.net/6/docs/ref/#language.Language) for use with Lezer\n[LR parsers](https://lezer.codemirror.net/docs/ref#lr.LRParser)\nparsers.\n*/ class LRLanguage extends Language {\n    constructor(data, parser, name){\n        super(data, parser, [], name);\n        this.parser = parser;\n    }\n    /**\n    Define a language from a parser.\n    */ static define(spec) {\n        let data = defineLanguageFacet(spec.languageData);\n        return new LRLanguage(data, spec.parser.configure({\n            props: [\n                languageDataProp.add((type)=>type.isTop ? data : undefined)\n            ]\n        }), spec.name);\n    }\n    /**\n    Create a new instance of this language with a reconfigured\n    version of its parser and optionally a new name.\n    */ configure(options, name) {\n        return new LRLanguage(this.data, this.parser.configure(options), name || this.name);\n    }\n    get allowsNesting() {\n        return this.parser.hasWrappers();\n    }\n}\n/**\nGet the syntax tree for a state, which is the current (possibly\nincomplete) parse tree of the active\n[language](https://codemirror.net/6/docs/ref/#language.Language), or the empty tree if there is no\nlanguage available.\n*/ function syntaxTree(state) {\n    let field = state.field(Language.state, false);\n    return field ? field.tree : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty;\n}\n/**\nTry to get a parse tree that spans at least up to `upto`. The\nmethod will do at most `timeout` milliseconds of work to parse\nup to that point if the tree isn't already available.\n*/ function ensureSyntaxTree(state, upto, timeout = 50) {\n    var _a;\n    let parse = (_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context;\n    if (!parse) return null;\n    let oldVieport = parse.viewport;\n    parse.updateViewport({\n        from: 0,\n        to: upto\n    });\n    let result = parse.isDone(upto) || parse.work(timeout, upto) ? parse.tree : null;\n    parse.updateViewport(oldVieport);\n    return result;\n}\n/**\nQueries whether there is a full syntax tree available up to the\ngiven document position. If there isn't, the background parse\nprocess _might_ still be working and update the tree further, but\nthere is no guarantee of that—the parser will [stop\nworking](https://codemirror.net/6/docs/ref/#language.syntaxParserRunning) when it has spent a\ncertain amount of time or has moved beyond the visible viewport.\nAlways returns false if no language has been enabled.\n*/ function syntaxTreeAvailable(state, upto = state.doc.length) {\n    var _a;\n    return ((_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context.isDone(upto)) || false;\n}\n/**\nMove parsing forward, and update the editor state afterwards to\nreflect the new tree. Will work for at most `timeout`\nmilliseconds. Returns true if the parser managed get to the given\nposition in that time.\n*/ function forceParsing(view, upto = view.viewport.to, timeout = 100) {\n    let success = ensureSyntaxTree(view.state, upto, timeout);\n    if (success != syntaxTree(view.state)) view.dispatch({});\n    return !!success;\n}\n/**\nTells you whether the language parser is planning to do more\nparsing work (in a `requestIdleCallback` pseudo-thread) or has\nstopped running, either because it parsed the entire document,\nbecause it spent too much time and was cut off, or because there\nis no language parser enabled.\n*/ function syntaxParserRunning(view) {\n    var _a;\n    return ((_a = view.plugin(parseWorker)) === null || _a === void 0 ? void 0 : _a.isWorking()) || false;\n}\n/**\nLezer-style\n[`Input`](https://lezer.codemirror.net/docs/ref#common.Input)\nobject for a [`Text`](https://codemirror.net/6/docs/ref/#state.Text) object.\n*/ class DocInput {\n    /**\n    Create an input object for the given document.\n    */ constructor(doc){\n        this.doc = doc;\n        this.cursorPos = 0;\n        this.string = \"\";\n        this.cursor = doc.iter();\n    }\n    get length() {\n        return this.doc.length;\n    }\n    syncTo(pos) {\n        this.string = this.cursor.next(pos - this.cursorPos).value;\n        this.cursorPos = pos + this.string.length;\n        return this.cursorPos - this.string.length;\n    }\n    chunk(pos) {\n        this.syncTo(pos);\n        return this.string;\n    }\n    get lineChunks() {\n        return true;\n    }\n    read(from, to) {\n        let stringStart = this.cursorPos - this.string.length;\n        if (from < stringStart || to >= this.cursorPos) return this.doc.sliceString(from, to);\n        else return this.string.slice(from - stringStart, to - stringStart);\n    }\n}\nlet currentContext = null;\n/**\nA parse context provided to parsers working on the editor content.\n*/ class ParseContext {\n    constructor(parser, /**\n    The current editor state.\n    */ state, /**\n    Tree fragments that can be reused by incremental re-parses.\n    */ fragments = [], /**\n    @internal\n    */ tree, /**\n    @internal\n    */ treeLen, /**\n    The current editor viewport (or some overapproximation\n    thereof). Intended to be used for opportunistically avoiding\n    work (in which case\n    [`skipUntilInView`](https://codemirror.net/6/docs/ref/#language.ParseContext.skipUntilInView)\n    should be called to make sure the parser is restarted when the\n    skipped region becomes visible).\n    */ viewport, /**\n    @internal\n    */ skipped, /**\n    This is where skipping parsers can register a promise that,\n    when resolved, will schedule a new parse. It is cleared when\n    the parse worker picks up the promise. @internal\n    */ scheduleOn){\n        this.parser = parser;\n        this.state = state;\n        this.fragments = fragments;\n        this.tree = tree;\n        this.treeLen = treeLen;\n        this.viewport = viewport;\n        this.skipped = skipped;\n        this.scheduleOn = scheduleOn;\n        this.parse = null;\n        /**\n        @internal\n        */ this.tempSkipped = [];\n    }\n    /**\n    @internal\n    */ static create(parser, state, viewport) {\n        return new ParseContext(parser, state, [], _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty, 0, viewport, [], null);\n    }\n    startParse() {\n        return this.parser.startParse(new DocInput(this.state.doc), this.fragments);\n    }\n    /**\n    @internal\n    */ work(until, upto) {\n        if (upto != null && upto >= this.state.doc.length) upto = undefined;\n        if (this.tree != _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {\n            this.takeTree();\n            return true;\n        }\n        return this.withContext(()=>{\n            var _a;\n            if (typeof until == \"number\") {\n                let endTime = Date.now() + until;\n                until = ()=>Date.now() > endTime;\n            }\n            if (!this.parse) this.parse = this.startParse();\n            if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length) this.parse.stopAt(upto);\n            for(;;){\n                let done = this.parse.advance();\n                if (done) {\n                    this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));\n                    this.treeLen = (_a = this.parse.stoppedAt) !== null && _a !== void 0 ? _a : this.state.doc.length;\n                    this.tree = done;\n                    this.parse = null;\n                    if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length)) this.parse = this.startParse();\n                    else return true;\n                }\n                if (until()) return false;\n            }\n        });\n    }\n    /**\n    @internal\n    */ takeTree() {\n        let pos, tree;\n        if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {\n            if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos) this.parse.stopAt(pos);\n            this.withContext(()=>{\n                while(!(tree = this.parse.advance())){}\n            });\n            this.treeLen = pos;\n            this.tree = tree;\n            this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.addTree(this.tree, this.fragments, true));\n            this.parse = null;\n        }\n    }\n    withContext(f) {\n        let prev = currentContext;\n        currentContext = this;\n        try {\n            return f();\n        } finally{\n            currentContext = prev;\n        }\n    }\n    withoutTempSkipped(fragments) {\n        for(let r; r = this.tempSkipped.pop();)fragments = cutFragments(fragments, r.from, r.to);\n        return fragments;\n    }\n    /**\n    @internal\n    */ changes(changes, newState) {\n        let { fragments, tree, treeLen, viewport, skipped } = this;\n        this.takeTree();\n        if (!changes.empty) {\n            let ranges = [];\n            changes.iterChangedRanges((fromA, toA, fromB, toB)=>ranges.push({\n                    fromA,\n                    toA,\n                    fromB,\n                    toB\n                }));\n            fragments = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.applyChanges(fragments, ranges);\n            tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty;\n            treeLen = 0;\n            viewport = {\n                from: changes.mapPos(viewport.from, -1),\n                to: changes.mapPos(viewport.to, 1)\n            };\n            if (this.skipped.length) {\n                skipped = [];\n                for (let r of this.skipped){\n                    let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);\n                    if (from < to) skipped.push({\n                        from,\n                        to\n                    });\n                }\n            }\n        }\n        return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);\n    }\n    /**\n    @internal\n    */ updateViewport(viewport) {\n        if (this.viewport.from == viewport.from && this.viewport.to == viewport.to) return false;\n        this.viewport = viewport;\n        let startLen = this.skipped.length;\n        for(let i = 0; i < this.skipped.length; i++){\n            let { from, to } = this.skipped[i];\n            if (from < viewport.to && to > viewport.from) {\n                this.fragments = cutFragments(this.fragments, from, to);\n                this.skipped.splice(i--, 1);\n            }\n        }\n        if (this.skipped.length >= startLen) return false;\n        this.reset();\n        return true;\n    }\n    /**\n    @internal\n    */ reset() {\n        if (this.parse) {\n            this.takeTree();\n            this.parse = null;\n        }\n    }\n    /**\n    Notify the parse scheduler that the given region was skipped\n    because it wasn't in view, and the parse should be restarted\n    when it comes into view.\n    */ skipUntilInView(from, to) {\n        this.skipped.push({\n            from,\n            to\n        });\n    }\n    /**\n    Returns a parser intended to be used as placeholder when\n    asynchronously loading a nested parser. It'll skip its input and\n    mark it as not-really-parsed, so that the next update will parse\n    it again.\n    \n    When `until` is given, a reparse will be scheduled when that\n    promise resolves.\n    */ static getSkippingParser(until) {\n        return new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n            createParse(input, fragments, ranges) {\n                let from = ranges[0].from, to = ranges[ranges.length - 1].to;\n                let parser = {\n                    parsedPos: from,\n                    advance () {\n                        let cx = currentContext;\n                        if (cx) {\n                            for (let r of ranges)cx.tempSkipped.push(r);\n                            if (until) cx.scheduleOn = cx.scheduleOn ? Promise.all([\n                                cx.scheduleOn,\n                                until\n                            ]) : until;\n                        }\n                        this.parsedPos = to;\n                        return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none, [], [], to - from);\n                    },\n                    stoppedAt: null,\n                    stopAt () {}\n                };\n                return parser;\n            }\n        };\n    }\n    /**\n    @internal\n    */ isDone(upto) {\n        upto = Math.min(upto, this.state.doc.length);\n        let frags = this.fragments;\n        return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;\n    }\n    /**\n    Get the context for the current parse, or `null` if no editor\n    parse is in progress.\n    */ static get() {\n        return currentContext;\n    }\n}\nfunction cutFragments(fragments, from, to) {\n    return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.applyChanges(fragments, [\n        {\n            fromA: from,\n            toA: to,\n            fromB: from,\n            toB: to\n        }\n    ]);\n}\nclass LanguageState {\n    constructor(// A mutable parse state that is used to preserve work done during\n    // the lifetime of a state when moving to the next state.\n    context){\n        this.context = context;\n        this.tree = context.tree;\n    }\n    apply(tr) {\n        if (!tr.docChanged && this.tree == this.context.tree) return this;\n        let newCx = this.context.changes(tr.changes, tr.state);\n        // If the previous parse wasn't done, go forward only up to its\n        // end position or the end of the viewport, to avoid slowing down\n        // state updates with parse work beyond the viewport.\n        let upto = this.context.treeLen == tr.startState.doc.length ? undefined : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);\n        if (!newCx.work(20 /* Work.Apply */ , upto)) newCx.takeTree();\n        return new LanguageState(newCx);\n    }\n    static init(state) {\n        let vpTo = Math.min(3000 /* Work.InitViewport */ , state.doc.length);\n        let parseState = ParseContext.create(state.facet(language).parser, state, {\n            from: 0,\n            to: vpTo\n        });\n        if (!parseState.work(20 /* Work.Apply */ , vpTo)) parseState.takeTree();\n        return new LanguageState(parseState);\n    }\n}\nLanguage.state = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n    create: LanguageState.init,\n    update (value, tr) {\n        for (let e of tr.effects)if (e.is(Language.setState)) return e.value;\n        if (tr.startState.facet(language) != tr.state.facet(language)) return LanguageState.init(tr.state);\n        return value.apply(tr);\n    }\n});\nlet requestIdle = (callback)=>{\n    let timeout = setTimeout(()=>callback(), 500 /* Work.MaxPause */ );\n    return ()=>clearTimeout(timeout);\n};\nif (typeof requestIdleCallback != \"undefined\") requestIdle = (callback)=>{\n    let idle = -1, timeout = setTimeout(()=>{\n        idle = requestIdleCallback(callback, {\n            timeout: 500 /* Work.MaxPause */  - 100 /* Work.MinPause */ \n        });\n    }, 100 /* Work.MinPause */ );\n    return ()=>idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);\n};\nconst isInputPending = typeof navigator != \"undefined\" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? ()=>navigator.scheduling.isInputPending() : null;\nconst parseWorker = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class ParseWorker {\n    constructor(view){\n        this.view = view;\n        this.working = null;\n        this.workScheduled = 0;\n        // End of the current time chunk\n        this.chunkEnd = -1;\n        // Milliseconds of budget left for this chunk\n        this.chunkBudget = -1;\n        this.work = this.work.bind(this);\n        this.scheduleWork();\n    }\n    update(update) {\n        let cx = this.view.state.field(Language.state).context;\n        if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen) this.scheduleWork();\n        if (update.docChanged || update.selectionSet) {\n            if (this.view.hasFocus) this.chunkBudget += 50 /* Work.ChangeBonus */ ;\n            this.scheduleWork();\n        }\n        this.checkAsyncSchedule(cx);\n    }\n    scheduleWork() {\n        if (this.working) return;\n        let { state } = this.view, field = state.field(Language.state);\n        if (field.tree != field.context.tree || !field.context.isDone(state.doc.length)) this.working = requestIdle(this.work);\n    }\n    work(deadline) {\n        this.working = null;\n        let now = Date.now();\n        if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {\n            this.chunkEnd = now + 30000 /* Work.ChunkTime */ ;\n            this.chunkBudget = 3000 /* Work.ChunkBudget */ ;\n        }\n        if (this.chunkBudget <= 0) return; // No more budget\n        let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);\n        if (field.tree == field.context.tree && field.context.isDone(vpTo + 100000 /* Work.MaxParseAhead */ )) return;\n        let endTime = Date.now() + Math.min(this.chunkBudget, 100 /* Work.Slice */ , deadline && !isInputPending ? Math.max(25 /* Work.MinSlice */ , deadline.timeRemaining() - 5) : 1e9);\n        let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1000;\n        let done = field.context.work(()=>{\n            return isInputPending && isInputPending() || Date.now() > endTime;\n        }, vpTo + (viewportFirst ? 0 : 100000 /* Work.MaxParseAhead */ ));\n        this.chunkBudget -= Date.now() - now;\n        if (done || this.chunkBudget <= 0) {\n            field.context.takeTree();\n            this.view.dispatch({\n                effects: Language.setState.of(new LanguageState(field.context))\n            });\n        }\n        if (this.chunkBudget > 0 && !(done && !viewportFirst)) this.scheduleWork();\n        this.checkAsyncSchedule(field.context);\n    }\n    checkAsyncSchedule(cx) {\n        if (cx.scheduleOn) {\n            this.workScheduled++;\n            cx.scheduleOn.then(()=>this.scheduleWork()).catch((err)=>(0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.logException)(this.view.state, err)).then(()=>this.workScheduled--);\n            cx.scheduleOn = null;\n        }\n    }\n    destroy() {\n        if (this.working) this.working();\n    }\n    isWorking() {\n        return !!(this.working || this.workScheduled > 0);\n    }\n}, {\n    eventHandlers: {\n        focus () {\n            this.scheduleWork();\n        }\n    }\n});\n/**\nThe facet used to associate a language with an editor state. Used\nby `Language` object's `extension` property (so you don't need to\nmanually wrap your languages in this). Can be used to access the\ncurrent language on a state.\n*/ const language = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (languages) {\n        return languages.length ? languages[0] : null;\n    },\n    enables: (language)=>[\n            Language.state,\n            parseWorker,\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.contentAttributes.compute([\n                language\n            ], (state)=>{\n                let lang = state.facet(language);\n                return lang && lang.name ? {\n                    \"data-language\": lang.name\n                } : {};\n            })\n        ]\n});\n/**\nThis class bundles a [language](https://codemirror.net/6/docs/ref/#language.Language) with an\noptional set of supporting extensions. Language packages are\nencouraged to export a function that optionally takes a\nconfiguration object and returns a `LanguageSupport` instance, as\nthe main way for client code to use the package.\n*/ class LanguageSupport {\n    /**\n    Create a language support object.\n    */ constructor(/**\n    The language object.\n    */ language, /**\n    An optional set of supporting extensions. When nesting a\n    language in another language, the outer language is encouraged\n    to include the supporting extensions for its inner languages\n    in its own set of support extensions.\n    */ support = []){\n        this.language = language;\n        this.support = support;\n        this.extension = [\n            language,\n            support\n        ];\n    }\n}\n/**\nLanguage descriptions are used to store metadata about languages\nand to dynamically load them. Their main role is finding the\nappropriate language for a filename or dynamically loading nested\nparsers.\n*/ class LanguageDescription {\n    constructor(/**\n    The name of this language.\n    */ name, /**\n    Alternative names for the mode (lowercased, includes `this.name`).\n    */ alias, /**\n    File extensions associated with this language.\n    */ extensions, /**\n    Optional filename pattern that should be associated with this\n    language.\n    */ filename, loadFunc, /**\n    If the language has been loaded, this will hold its value.\n    */ support = undefined){\n        this.name = name;\n        this.alias = alias;\n        this.extensions = extensions;\n        this.filename = filename;\n        this.loadFunc = loadFunc;\n        this.support = support;\n        this.loading = null;\n    }\n    /**\n    Start loading the the language. Will return a promise that\n    resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)\n    object when the language successfully loads.\n    */ load() {\n        return this.loading || (this.loading = this.loadFunc().then((support)=>this.support = support, (err)=>{\n            this.loading = null;\n            throw err;\n        }));\n    }\n    /**\n    Create a language description.\n    */ static of(spec) {\n        let { load, support } = spec;\n        if (!load) {\n            if (!support) throw new RangeError(\"Must pass either 'load' or 'support' to LanguageDescription.of\");\n            load = ()=>Promise.resolve(support);\n        }\n        return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map((s)=>s.toLowerCase()), spec.extensions || [], spec.filename, load, support);\n    }\n    /**\n    Look for a language in the given array of descriptions that\n    matches the filename. Will first match\n    [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,\n    and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),\n    and return the first language that matches.\n    */ static matchFilename(descs, filename) {\n        for (let d of descs)if (d.filename && d.filename.test(filename)) return d;\n        let ext = /\\.([^.]+)$/.exec(filename);\n        if (ext) {\n            for (let d of descs)if (d.extensions.indexOf(ext[1]) > -1) return d;\n        }\n        return null;\n    }\n    /**\n    Look for a language whose name or alias matches the the given\n    name (case-insensitively). If `fuzzy` is true, and no direct\n    matchs is found, this'll also search for a language whose name\n    or alias occurs in the string (for names shorter than three\n    characters, only when surrounded by non-word characters).\n    */ static matchLanguageName(descs, name, fuzzy = true) {\n        name = name.toLowerCase();\n        for (let d of descs)if (d.alias.some((a)=>a == name)) return d;\n        if (fuzzy) for (let d of descs)for (let a of d.alias){\n            let found = name.indexOf(a);\n            if (found > -1 && (a.length > 2 || !/\\w/.test(name[found - 1]) && !/\\w/.test(name[found + a.length]))) return d;\n        }\n        return null;\n    }\n}\n/**\nFacet that defines a way to provide a function that computes the\nappropriate indentation depth, as a column number (see\n[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)), at the start of a given\nline. A return value of `null` indicates no indentation can be\ndetermined, and the line should inherit the indentation of the one\nabove it. A return value of `undefined` defers to the next indent\nservice.\n*/ const indentService = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\n/**\nFacet for overriding the unit by which indentation happens. Should\nbe a string consisting either entirely of the same whitespace\ncharacter. When not set, this defaults to 2 spaces.\n*/ const indentUnit = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: (values)=>{\n        if (!values.length) return \"  \";\n        let unit = values[0];\n        if (!unit || /\\S/.test(unit) || Array.from(unit).some((e)=>e != unit[0])) throw new Error(\"Invalid indent unit: \" + JSON.stringify(values[0]));\n        return unit;\n    }\n});\n/**\nReturn the _column width_ of an indent unit in the state.\nDetermined by the [`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit)\nfacet, and [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) when that\ncontains tabs.\n*/ function getIndentUnit(state) {\n    let unit = state.facet(indentUnit);\n    return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;\n}\n/**\nCreate an indentation string that covers columns 0 to `cols`.\nWill use tabs for as much of the columns as possible when the\n[`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit) facet contains\ntabs.\n*/ function indentString(state, cols) {\n    let result = \"\", ts = state.tabSize, ch = state.facet(indentUnit)[0];\n    if (ch == \"\t\") {\n        while(cols >= ts){\n            result += \"\t\";\n            cols -= ts;\n        }\n        ch = \" \";\n    }\n    for(let i = 0; i < cols; i++)result += ch;\n    return result;\n}\n/**\nGet the indentation, as a column number, at the given position.\nWill first consult any [indent services](https://codemirror.net/6/docs/ref/#language.indentService)\nthat are registered, and if none of those return an indentation,\nthis will check the syntax tree for the [indent node\nprop](https://codemirror.net/6/docs/ref/#language.indentNodeProp) and use that if found. Returns a\nnumber when an indentation could be determined, and null\notherwise.\n*/ function getIndentation(context, pos) {\n    if (context instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState) context = new IndentContext(context);\n    for (let service of context.state.facet(indentService)){\n        let result = service(context, pos);\n        if (result !== undefined) return result;\n    }\n    let tree = syntaxTree(context.state);\n    return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null;\n}\n/**\nCreate a change set that auto-indents all lines touched by the\ngiven document range.\n*/ function indentRange(state, from, to) {\n    let updated = Object.create(null);\n    let context = new IndentContext(state, {\n        overrideIndentation: (start)=>{\n            var _a;\n            return (_a = updated[start]) !== null && _a !== void 0 ? _a : -1;\n        }\n    });\n    let changes = [];\n    for(let pos = from; pos <= to;){\n        let line = state.doc.lineAt(pos);\n        pos = line.to + 1;\n        let indent = getIndentation(context, line.from);\n        if (indent == null) continue;\n        if (!/\\S/.test(line.text)) indent = 0;\n        let cur = /^\\s*/.exec(line.text)[0];\n        let norm = indentString(state, indent);\n        if (cur != norm) {\n            updated[line.from] = indent;\n            changes.push({\n                from: line.from,\n                to: line.from + cur.length,\n                insert: norm\n            });\n        }\n    }\n    return state.changes(changes);\n}\n/**\nIndentation contexts are used when calling [indentation\nservices](https://codemirror.net/6/docs/ref/#language.indentService). They provide helper utilities\nuseful in indentation logic, and can selectively override the\nindentation reported for some lines.\n*/ class IndentContext {\n    /**\n    Create an indent context.\n    */ constructor(/**\n    The editor state.\n    */ state, /**\n    @internal\n    */ options = {}){\n        this.state = state;\n        this.options = options;\n        this.unit = getIndentUnit(state);\n    }\n    /**\n    Get a description of the line at the given position, taking\n    [simulated line\n    breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)\n    into account. If there is such a break at `pos`, the `bias`\n    argument determines whether the part of the line line before or\n    after the break is used.\n    */ lineAt(pos, bias = 1) {\n        let line = this.state.doc.lineAt(pos);\n        let { simulateBreak, simulateDoubleBreak } = this.options;\n        if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {\n            if (simulateDoubleBreak && simulateBreak == pos) return {\n                text: \"\",\n                from: pos\n            };\n            else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos) return {\n                text: line.text.slice(simulateBreak - line.from),\n                from: simulateBreak\n            };\n            else return {\n                text: line.text.slice(0, simulateBreak - line.from),\n                from: line.from\n            };\n        }\n        return line;\n    }\n    /**\n    Get the text directly after `pos`, either the entire line\n    or the next 100 characters, whichever is shorter.\n    */ textAfterPos(pos, bias = 1) {\n        if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak) return \"\";\n        let { text, from } = this.lineAt(pos, bias);\n        return text.slice(pos - from, Math.min(text.length, pos + 100 - from));\n    }\n    /**\n    Find the column for the given position.\n    */ column(pos, bias = 1) {\n        let { text, from } = this.lineAt(pos, bias);\n        let result = this.countColumn(text, pos - from);\n        let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;\n        if (override > -1) result += override - this.countColumn(text, text.search(/\\S|$/));\n        return result;\n    }\n    /**\n    Find the column position (taking tabs into account) of the given\n    position in the given string.\n    */ countColumn(line, pos = line.length) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.countColumn)(line, this.state.tabSize, pos);\n    }\n    /**\n    Find the indentation column of the line at the given point.\n    */ lineIndent(pos, bias = 1) {\n        let { text, from } = this.lineAt(pos, bias);\n        let override = this.options.overrideIndentation;\n        if (override) {\n            let overriden = override(from);\n            if (overriden > -1) return overriden;\n        }\n        return this.countColumn(text, text.search(/\\S|$/));\n    }\n    /**\n    Returns the [simulated line\n    break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)\n    for this context, if any.\n    */ get simulatedBreak() {\n        return this.options.simulateBreak || null;\n    }\n}\n/**\nA syntax tree node prop used to associate indentation strategies\nwith node types. Such a strategy is a function from an indentation\ncontext to a column number (see also\n[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)) or null, where null\nindicates that no definitive indentation can be determined.\n*/ const indentNodeProp = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n// Compute the indentation for a given position from the syntax tree.\nfunction syntaxIndentation(cx, ast, pos) {\n    let stack = ast.resolveStack(pos);\n    let inner = stack.node.enterUnfinishedNodesBefore(pos);\n    if (inner != stack.node) {\n        let add = [];\n        for(let cur = inner; cur != stack.node; cur = cur.parent)add.push(cur);\n        for(let i = add.length - 1; i >= 0; i--)stack = {\n            node: add[i],\n            next: stack\n        };\n    }\n    return indentFor(stack, cx, pos);\n}\nfunction indentFor(stack, cx, pos) {\n    for(let cur = stack; cur; cur = cur.next){\n        let strategy = indentStrategy(cur.node);\n        if (strategy) return strategy(TreeIndentContext.create(cx, pos, cur));\n    }\n    return 0;\n}\nfunction ignoreClosed(cx) {\n    return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;\n}\nfunction indentStrategy(tree) {\n    let strategy = tree.type.prop(indentNodeProp);\n    if (strategy) return strategy;\n    let first = tree.firstChild, close;\n    if (first && (close = first.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy))) {\n        let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;\n        return (cx)=>delimitedStrategy(cx, true, 1, undefined, closed && !ignoreClosed(cx) ? last.from : undefined);\n    }\n    return tree.parent == null ? topIndent : null;\n}\nfunction topIndent() {\n    return 0;\n}\n/**\nObjects of this type provide context information and helper\nmethods to indentation functions registered on syntax nodes.\n*/ class TreeIndentContext extends IndentContext {\n    constructor(base, /**\n    The position at which indentation is being computed.\n    */ pos, /**\n    @internal\n    */ context){\n        super(base.state, base.options);\n        this.base = base;\n        this.pos = pos;\n        this.context = context;\n    }\n    /**\n    The syntax tree node to which the indentation strategy\n    applies.\n    */ get node() {\n        return this.context.node;\n    }\n    /**\n    @internal\n    */ static create(base, pos, context) {\n        return new TreeIndentContext(base, pos, context);\n    }\n    /**\n    Get the text directly after `this.pos`, either the entire line\n    or the next 100 characters, whichever is shorter.\n    */ get textAfter() {\n        return this.textAfterPos(this.pos);\n    }\n    /**\n    Get the indentation at the reference line for `this.node`, which\n    is the line on which it starts, unless there is a node that is\n    _not_ a parent of this node covering the start of that line. If\n    so, the line at the start of that node is tried, again skipping\n    on if it is covered by another such node.\n    */ get baseIndent() {\n        return this.baseIndentFor(this.node);\n    }\n    /**\n    Get the indentation for the reference line of the given node\n    (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).\n    */ baseIndentFor(node) {\n        let line = this.state.doc.lineAt(node.from);\n        // Skip line starts that are covered by a sibling (or cousin, etc)\n        for(;;){\n            let atBreak = node.resolve(line.from);\n            while(atBreak.parent && atBreak.parent.from == atBreak.from)atBreak = atBreak.parent;\n            if (isParent(atBreak, node)) break;\n            line = this.state.doc.lineAt(atBreak.from);\n        }\n        return this.lineIndent(line.from);\n    }\n    /**\n    Continue looking for indentations in the node's parent nodes,\n    and return the result of that.\n    */ continue() {\n        return indentFor(this.context.next, this.base, this.pos);\n    }\n}\nfunction isParent(parent, of) {\n    for(let cur = of; cur; cur = cur.parent)if (parent == cur) return true;\n    return false;\n}\n// Check whether a delimited node is aligned (meaning there are\n// non-skipped nodes on the same line as the opening delimiter). And\n// if so, return the opening token.\nfunction bracketedAligned(context) {\n    let tree = context.node;\n    let openToken = tree.childAfter(tree.from), last = tree.lastChild;\n    if (!openToken) return null;\n    let sim = context.options.simulateBreak;\n    let openLine = context.state.doc.lineAt(openToken.from);\n    let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);\n    for(let pos = openToken.to;;){\n        let next = tree.childAfter(pos);\n        if (!next || next == last) return null;\n        if (!next.type.isSkipped) return next.from < lineEnd ? openToken : null;\n        pos = next.to;\n    }\n}\n/**\nAn indentation strategy for delimited (usually bracketed) nodes.\nWill, by default, indent one unit more than the parent's base\nindent unless the line starts with a closing token. When `align`\nis true and there are non-skipped nodes on the node's opening\nline, the content of the node will be aligned with the end of the\nopening node, like this:\n\n    foo(bar,\n        baz)\n*/ function delimitedIndent({ closing, align = true, units = 1 }) {\n    return (context)=>delimitedStrategy(context, align, units, closing);\n}\nfunction delimitedStrategy(context, align, units, closing, closedAt) {\n    let after = context.textAfter, space = after.match(/^\\s*/)[0].length;\n    let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;\n    let aligned = align ? bracketedAligned(context) : null;\n    if (aligned) return closed ? context.column(aligned.from) : context.column(aligned.to);\n    return context.baseIndent + (closed ? 0 : context.unit * units);\n}\n/**\nAn indentation strategy that aligns a node's content to its base\nindentation.\n*/ const flatIndent = (context)=>context.baseIndent;\n/**\nCreates an indentation strategy that, by default, indents\ncontinued lines one unit more than the node's base indentation.\nYou can provide `except` to prevent indentation of lines that\nmatch a pattern (for example `/^else\\b/` in `if`/`else`\nconstructs), and you can change the amount of units used with the\n`units` option.\n*/ function continuedIndent({ except, units = 1 } = {}) {\n    return (context)=>{\n        let matchExcept = except && except.test(context.textAfter);\n        return context.baseIndent + (matchExcept ? 0 : units * context.unit);\n    };\n}\nconst DontIndentBeyond = 200;\n/**\nEnables reindentation on input. When a language defines an\n`indentOnInput` field in its [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt), which must hold a regular\nexpression, the line at the cursor will be reindented whenever new\ntext is typed and the input from the start of the line up to the\ncursor matches that regexp.\n\nTo avoid unneccesary reindents, it is recommended to start the\nregexp with `^` (usually followed by `\\s*`), and end it with `$`.\nFor example, `/^\\s*\\}$/` will reindent when a closing brace is\nadded at the start of a line.\n*/ function indentOnInput() {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.transactionFilter.of((tr)=>{\n        if (!tr.docChanged || !tr.isUserEvent(\"input.type\") && !tr.isUserEvent(\"input.complete\")) return tr;\n        let rules = tr.startState.languageDataAt(\"indentOnInput\", tr.startState.selection.main.head);\n        if (!rules.length) return tr;\n        let doc = tr.newDoc, { head } = tr.newSelection.main, line = doc.lineAt(head);\n        if (head > line.from + DontIndentBeyond) return tr;\n        let lineStart = doc.sliceString(line.from, head);\n        if (!rules.some((r)=>r.test(lineStart))) return tr;\n        let { state } = tr, last = -1, changes = [];\n        for (let { head } of state.selection.ranges){\n            let line = state.doc.lineAt(head);\n            if (line.from == last) continue;\n            last = line.from;\n            let indent = getIndentation(state, line.from);\n            if (indent == null) continue;\n            let cur = /^\\s*/.exec(line.text)[0];\n            let norm = indentString(state, indent);\n            if (cur != norm) changes.push({\n                from: line.from,\n                to: line.from + cur.length,\n                insert: norm\n            });\n        }\n        return changes.length ? [\n            tr,\n            {\n                changes,\n                sequential: true\n            }\n        ] : tr;\n    });\n}\n/**\nA facet that registers a code folding service. When called with\nthe extent of a line, such a function should return a foldable\nrange that starts on that line (but continues beyond it), if one\ncan be found.\n*/ const foldService = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\n/**\nThis node prop is used to associate folding information with\nsyntax node types. Given a syntax node, it should check whether\nthat tree is foldable and return the range that can be collapsed\nwhen it is.\n*/ const foldNodeProp = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\n[Fold](https://codemirror.net/6/docs/ref/#language.foldNodeProp) function that folds everything but\nthe first and the last child of a syntax node. Useful for nodes\nthat start and end with delimiters.\n*/ function foldInside(node) {\n    let first = node.firstChild, last = node.lastChild;\n    return first && first.to < last.from ? {\n        from: first.to,\n        to: last.type.isError ? node.to : last.from\n    } : null;\n}\nfunction syntaxFolding(state, start, end) {\n    let tree = syntaxTree(state);\n    if (tree.length < end) return null;\n    let stack = tree.resolveStack(end, 1);\n    let found = null;\n    for(let iter = stack; iter; iter = iter.next){\n        let cur = iter.node;\n        if (cur.to <= end || cur.from > end) continue;\n        if (found && cur.from < start) break;\n        let prop = cur.type.prop(foldNodeProp);\n        if (prop && (cur.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur))) {\n            let value = prop(cur, state);\n            if (value && value.from <= end && value.from >= start && value.to > end) found = value;\n        }\n    }\n    return found;\n}\nfunction isUnfinished(node) {\n    let ch = node.lastChild;\n    return ch && ch.to == node.to && ch.type.isError;\n}\n/**\nCheck whether the given line is foldable. First asks any fold\nservices registered through\n[`foldService`](https://codemirror.net/6/docs/ref/#language.foldService), and if none of them return\na result, tries to query the [fold node\nprop](https://codemirror.net/6/docs/ref/#language.foldNodeProp) of syntax nodes that cover the end\nof the line.\n*/ function foldable(state, lineStart, lineEnd) {\n    for (let service of state.facet(foldService)){\n        let result = service(state, lineStart, lineEnd);\n        if (result) return result;\n    }\n    return syntaxFolding(state, lineStart, lineEnd);\n}\nfunction mapRange(range, mapping) {\n    let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);\n    return from >= to ? undefined : {\n        from,\n        to\n    };\n}\n/**\nState effect that can be attached to a transaction to fold the\ngiven range. (You probably only need this in exceptional\ncircumstances—usually you'll just want to let\n[`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode) and the [fold\ngutter](https://codemirror.net/6/docs/ref/#language.foldGutter) create the transactions.)\n*/ const foldEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define({\n    map: mapRange\n});\n/**\nState effect that unfolds the given range (if it was folded).\n*/ const unfoldEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define({\n    map: mapRange\n});\nfunction selectedLines(view) {\n    let lines = [];\n    for (let { head } of view.state.selection.ranges){\n        if (lines.some((l)=>l.from <= head && l.to >= head)) continue;\n        lines.push(view.lineBlockAt(head));\n    }\n    return lines;\n}\n/**\nThe state field that stores the folded ranges (as a [decoration\nset](https://codemirror.net/6/docs/ref/#view.DecorationSet)). Can be passed to\n[`EditorState.toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) and\n[`fromJSON`](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) to serialize the fold\nstate.\n*/ const foldState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n    create () {\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n    },\n    update (folded, tr) {\n        folded = folded.map(tr.changes);\n        for (let e of tr.effects){\n            if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to)) {\n                let { preparePlaceholder } = tr.state.facet(foldConfig);\n                let widget = !preparePlaceholder ? foldWidget : _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.replace({\n                    widget: new PreparedFoldWidget(preparePlaceholder(tr.state, e.value))\n                });\n                folded = folded.update({\n                    add: [\n                        widget.range(e.value.from, e.value.to)\n                    ]\n                });\n            } else if (e.is(unfoldEffect)) {\n                folded = folded.update({\n                    filter: (from, to)=>e.value.from != from || e.value.to != to,\n                    filterFrom: e.value.from,\n                    filterTo: e.value.to\n                });\n            }\n        }\n        // Clear folded ranges that cover the selection head\n        if (tr.selection) {\n            let onSelection = false, { head } = tr.selection.main;\n            folded.between(head, head, (a, b)=>{\n                if (a < head && b > head) onSelection = true;\n            });\n            if (onSelection) folded = folded.update({\n                filterFrom: head,\n                filterTo: head,\n                filter: (a, b)=>b <= head || a >= head\n            });\n        }\n        return folded;\n    },\n    provide: (f)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.decorations.from(f),\n    toJSON (folded, state) {\n        let ranges = [];\n        folded.between(0, state.doc.length, (from, to)=>{\n            ranges.push(from, to);\n        });\n        return ranges;\n    },\n    fromJSON (value) {\n        if (!Array.isArray(value) || value.length % 2) throw new RangeError(\"Invalid JSON for fold state\");\n        let ranges = [];\n        for(let i = 0; i < value.length;){\n            let from = value[i++], to = value[i++];\n            if (typeof from != \"number\" || typeof to != \"number\") throw new RangeError(\"Invalid JSON for fold state\");\n            ranges.push(foldWidget.range(from, to));\n        }\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.set(ranges, true);\n    }\n});\n/**\nGet a [range set](https://codemirror.net/6/docs/ref/#state.RangeSet) containing the folded ranges\nin the given state.\n*/ function foldedRanges(state) {\n    return state.field(foldState, false) || _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.empty;\n}\nfunction findFold(state, from, to) {\n    var _a;\n    let found = null;\n    (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to)=>{\n        if (!found || found.from > from) found = {\n            from,\n            to\n        };\n    });\n    return found;\n}\nfunction foldExists(folded, from, to) {\n    let found = false;\n    folded.between(from, from, (a, b)=>{\n        if (a == from && b == to) found = true;\n    });\n    return found;\n}\nfunction maybeEnable(state, other) {\n    return state.field(foldState, false) ? other : other.concat(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.appendConfig.of(codeFolding()));\n}\n/**\nFold the lines that are selected, if possible.\n*/ const foldCode = (view)=>{\n    for (let line of selectedLines(view)){\n        let range = foldable(view.state, line.from, line.to);\n        if (range) {\n            view.dispatch({\n                effects: maybeEnable(view.state, [\n                    foldEffect.of(range),\n                    announceFold(view, range)\n                ])\n            });\n            return true;\n        }\n    }\n    return false;\n};\n/**\nUnfold folded ranges on selected lines.\n*/ const unfoldCode = (view)=>{\n    if (!view.state.field(foldState, false)) return false;\n    let effects = [];\n    for (let line of selectedLines(view)){\n        let folded = findFold(view.state, line.from, line.to);\n        if (folded) effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));\n    }\n    if (effects.length) view.dispatch({\n        effects\n    });\n    return effects.length > 0;\n};\nfunction announceFold(view, range, fold = true) {\n    let lineFrom = view.state.doc.lineAt(range.from).number, lineTo = view.state.doc.lineAt(range.to).number;\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.announce.of(`${view.state.phrase(fold ? \"Folded lines\" : \"Unfolded lines\")} ${lineFrom} ${view.state.phrase(\"to\")} ${lineTo}.`);\n}\n/**\nFold all top-level foldable ranges. Note that, in most cases,\nfolding information will depend on the [syntax\ntree](https://codemirror.net/6/docs/ref/#language.syntaxTree), and folding everything may not work\nreliably when the document hasn't been fully parsed (either\nbecause the editor state was only just initialized, or because the\ndocument is so big that the parser decided not to parse it\nentirely).\n*/ const foldAll = (view)=>{\n    let { state } = view, effects = [];\n    for(let pos = 0; pos < state.doc.length;){\n        let line = view.lineBlockAt(pos), range = foldable(state, line.from, line.to);\n        if (range) effects.push(foldEffect.of(range));\n        pos = (range ? view.lineBlockAt(range.to) : line).to + 1;\n    }\n    if (effects.length) view.dispatch({\n        effects: maybeEnable(view.state, effects)\n    });\n    return !!effects.length;\n};\n/**\nUnfold all folded code.\n*/ const unfoldAll = (view)=>{\n    let field = view.state.field(foldState, false);\n    if (!field || !field.size) return false;\n    let effects = [];\n    field.between(0, view.state.doc.length, (from, to)=>{\n        effects.push(unfoldEffect.of({\n            from,\n            to\n        }));\n    });\n    view.dispatch({\n        effects\n    });\n    return true;\n};\n// Find the foldable region containing the given line, if one exists\nfunction foldableContainer(view, lineBlock) {\n    // Look backwards through line blocks until we find a foldable region that\n    // intersects with the line\n    for(let line = lineBlock;;){\n        let foldableRegion = foldable(view.state, line.from, line.to);\n        if (foldableRegion && foldableRegion.to > lineBlock.from) return foldableRegion;\n        if (!line.from) return null;\n        line = view.lineBlockAt(line.from - 1);\n    }\n}\n/**\nToggle folding at cursors. Unfolds if there is an existing fold\nstarting in that line, tries to find a foldable range around it\notherwise.\n*/ const toggleFold = (view)=>{\n    let effects = [];\n    for (let line of selectedLines(view)){\n        let folded = findFold(view.state, line.from, line.to);\n        if (folded) {\n            effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));\n        } else {\n            let foldRange = foldableContainer(view, line);\n            if (foldRange) effects.push(foldEffect.of(foldRange), announceFold(view, foldRange));\n        }\n    }\n    if (effects.length > 0) view.dispatch({\n        effects: maybeEnable(view.state, effects)\n    });\n    return !!effects.length;\n};\n/**\nDefault fold-related key bindings.\n\n - Ctrl-Shift-[ (Cmd-Alt-[ on macOS): [`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode).\n - Ctrl-Shift-] (Cmd-Alt-] on macOS): [`unfoldCode`](https://codemirror.net/6/docs/ref/#language.unfoldCode).\n - Ctrl-Alt-[: [`foldAll`](https://codemirror.net/6/docs/ref/#language.foldAll).\n - Ctrl-Alt-]: [`unfoldAll`](https://codemirror.net/6/docs/ref/#language.unfoldAll).\n*/ const foldKeymap = [\n    {\n        key: \"Ctrl-Shift-[\",\n        mac: \"Cmd-Alt-[\",\n        run: foldCode\n    },\n    {\n        key: \"Ctrl-Shift-]\",\n        mac: \"Cmd-Alt-]\",\n        run: unfoldCode\n    },\n    {\n        key: \"Ctrl-Alt-[\",\n        run: foldAll\n    },\n    {\n        key: \"Ctrl-Alt-]\",\n        run: unfoldAll\n    }\n];\nconst defaultConfig = {\n    placeholderDOM: null,\n    preparePlaceholder: null,\n    placeholderText: \"…\"\n};\nconst foldConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (values) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(values, defaultConfig);\n    }\n});\n/**\nCreate an extension that configures code folding.\n*/ function codeFolding(config) {\n    let result = [\n        foldState,\n        baseTheme$1\n    ];\n    if (config) result.push(foldConfig.of(config));\n    return result;\n}\nfunction widgetToDOM(view, prepared) {\n    let { state } = view, conf = state.facet(foldConfig);\n    let onclick = (event)=>{\n        let line = view.lineBlockAt(view.posAtDOM(event.target));\n        let folded = findFold(view.state, line.from, line.to);\n        if (folded) view.dispatch({\n            effects: unfoldEffect.of(folded)\n        });\n        event.preventDefault();\n    };\n    if (conf.placeholderDOM) return conf.placeholderDOM(view, onclick, prepared);\n    let element = document.createElement(\"span\");\n    element.textContent = conf.placeholderText;\n    element.setAttribute(\"aria-label\", state.phrase(\"folded code\"));\n    element.title = state.phrase(\"unfold\");\n    element.className = \"cm-foldPlaceholder\";\n    element.onclick = onclick;\n    return element;\n}\nconst foldWidget = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.replace({\n    widget: /*@__PURE__*/ new class extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.WidgetType {\n        toDOM(view) {\n            return widgetToDOM(view, null);\n        }\n    }\n});\nclass PreparedFoldWidget extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.WidgetType {\n    constructor(value){\n        super();\n        this.value = value;\n    }\n    eq(other) {\n        return this.value == other.value;\n    }\n    toDOM(view) {\n        return widgetToDOM(view, this.value);\n    }\n}\nconst foldGutterDefaults = {\n    openText: \"⌄\",\n    closedText: \"›\",\n    markerDOM: null,\n    domEventHandlers: {},\n    foldingChanged: ()=>false\n};\nclass FoldMarker extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.GutterMarker {\n    constructor(config, open){\n        super();\n        this.config = config;\n        this.open = open;\n    }\n    eq(other) {\n        return this.config == other.config && this.open == other.open;\n    }\n    toDOM(view) {\n        if (this.config.markerDOM) return this.config.markerDOM(this.open);\n        let span = document.createElement(\"span\");\n        span.textContent = this.open ? this.config.openText : this.config.closedText;\n        span.title = view.state.phrase(this.open ? \"Fold line\" : \"Unfold line\");\n        return span;\n    }\n}\n/**\nCreate an extension that registers a fold gutter, which shows a\nfold status indicator before foldable lines (which can be clicked\nto fold or unfold the line).\n*/ function foldGutter(config = {}) {\n    let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config);\n    let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);\n    let markers = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class {\n        constructor(view){\n            this.from = view.viewport.from;\n            this.markers = this.buildMarkers(view);\n        }\n        update(update) {\n            if (update.docChanged || update.viewportChanged || update.startState.facet(language) != update.state.facet(language) || update.startState.field(foldState, false) != update.state.field(foldState, false) || syntaxTree(update.startState) != syntaxTree(update.state) || fullConfig.foldingChanged(update)) this.markers = this.buildMarkers(update.view);\n        }\n        buildMarkers(view) {\n            let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();\n            for (let line of view.viewportLineBlocks){\n                let mark = findFold(view.state, line.from, line.to) ? canUnfold : foldable(view.state, line.from, line.to) ? canFold : null;\n                if (mark) builder.add(line.from, line.from, mark);\n            }\n            return builder.finish();\n        }\n    });\n    let { domEventHandlers } = fullConfig;\n    return [\n        markers,\n        (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.gutter)({\n            class: \"cm-foldGutter\",\n            markers (view) {\n                var _a;\n                return ((_a = view.plugin(markers)) === null || _a === void 0 ? void 0 : _a.markers) || _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.empty;\n            },\n            initialSpacer () {\n                return new FoldMarker(fullConfig, false);\n            },\n            domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), {\n                click: (view, line, event)=>{\n                    if (domEventHandlers.click && domEventHandlers.click(view, line, event)) return true;\n                    let folded = findFold(view.state, line.from, line.to);\n                    if (folded) {\n                        view.dispatch({\n                            effects: unfoldEffect.of(folded)\n                        });\n                        return true;\n                    }\n                    let range = foldable(view.state, line.from, line.to);\n                    if (range) {\n                        view.dispatch({\n                            effects: foldEffect.of(range)\n                        });\n                        return true;\n                    }\n                    return false;\n                }\n            })\n        }),\n        codeFolding()\n    ];\n}\nconst baseTheme$1 = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.baseTheme({\n    \".cm-foldPlaceholder\": {\n        backgroundColor: \"#eee\",\n        border: \"1px solid #ddd\",\n        color: \"#888\",\n        borderRadius: \".2em\",\n        margin: \"0 1px\",\n        padding: \"0 1px\",\n        cursor: \"pointer\"\n    },\n    \".cm-foldGutter span\": {\n        padding: \"0 1px\",\n        cursor: \"pointer\"\n    }\n});\n/**\nA highlight style associates CSS styles with higlighting\n[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag).\n*/ class HighlightStyle {\n    constructor(/**\n    The tag styles used to create this highlight style.\n    */ specs, options){\n        this.specs = specs;\n        let modSpec;\n        function def(spec) {\n            let cls = style_mod__WEBPACK_IMPORTED_MODULE_2__.StyleModule.newName();\n            (modSpec || (modSpec = Object.create(null)))[\".\" + cls] = spec;\n            return cls;\n        }\n        const all = typeof options.all == \"string\" ? options.all : options.all ? def(options.all) : undefined;\n        const scopeOpt = options.scope;\n        this.scope = scopeOpt instanceof Language ? (type)=>type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type)=>type == scopeOpt : undefined;\n        this.style = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tagHighlighter)(specs.map((style)=>({\n                tag: style.tag,\n                class: style.class || def(Object.assign({}, style, {\n                    tag: null\n                }))\n            })), {\n            all\n        }).style;\n        this.module = modSpec ? new style_mod__WEBPACK_IMPORTED_MODULE_2__.StyleModule(modSpec) : null;\n        this.themeType = options.themeType;\n    }\n    /**\n    Create a highlighter style that associates the given styles to\n    the given tags. The specs must be objects that hold a style tag\n    or array of tags in their `tag` property, and either a single\n    `class` property providing a static CSS class (for highlighter\n    that rely on external styling), or a\n    [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style\n    set of CSS properties (which define the styling for those tags).\n    \n    The CSS rules created for a highlighter will be emitted in the\n    order of the spec's properties. That means that for elements that\n    have multiple tags associated with them, styles defined further\n    down in the list will have a higher CSS precedence than styles\n    defined earlier.\n    */ static define(specs, options) {\n        return new HighlightStyle(specs, options || {});\n    }\n}\nconst highlighterFacet = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst fallbackHighlighter = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (values) {\n        return values.length ? [\n            values[0]\n        ] : null;\n    }\n});\nfunction getHighlighters(state) {\n    let main = state.facet(highlighterFacet);\n    return main.length ? main : state.facet(fallbackHighlighter);\n}\n/**\nWrap a highlighter in an editor extension that uses it to apply\nsyntax highlighting to the editor content.\n\nWhen multiple (non-fallback) styles are provided, the styling\napplied is the union of the classes they emit.\n*/ function syntaxHighlighting(highlighter, options) {\n    let ext = [\n        treeHighlighter\n    ], themeType;\n    if (highlighter instanceof HighlightStyle) {\n        if (highlighter.module) ext.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.styleModule.of(highlighter.module));\n        themeType = highlighter.themeType;\n    }\n    if (options === null || options === void 0 ? void 0 : options.fallback) ext.push(fallbackHighlighter.of(highlighter));\n    else if (themeType) ext.push(highlighterFacet.computeN([\n        _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.darkTheme\n    ], (state)=>{\n        return state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.darkTheme) == (themeType == \"dark\") ? [\n            highlighter\n        ] : [];\n    }));\n    else ext.push(highlighterFacet.of(highlighter));\n    return ext;\n}\n/**\nReturns the CSS classes (if any) that the highlighters active in\nthe state would assign to the given style\n[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag) and\n(optional) language\n[scope](https://codemirror.net/6/docs/ref/#language.HighlightStyle^define^options.scope).\n*/ function highlightingFor(state, tags, scope) {\n    let highlighters = getHighlighters(state);\n    let result = null;\n    if (highlighters) for (let highlighter of highlighters){\n        if (!highlighter.scope || scope && highlighter.scope(scope)) {\n            let cls = highlighter.style(tags);\n            if (cls) result = result ? result + \" \" + cls : cls;\n        }\n    }\n    return result;\n}\nclass TreeHighlighter {\n    constructor(view){\n        this.markCache = Object.create(null);\n        this.tree = syntaxTree(view.state);\n        this.decorations = this.buildDeco(view, getHighlighters(view.state));\n        this.decoratedTo = view.viewport.to;\n    }\n    update(update) {\n        let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);\n        let styleChange = highlighters != getHighlighters(update.startState);\n        let { viewport } = update.view, decoratedToMapped = update.changes.mapPos(this.decoratedTo, 1);\n        if (tree.length < viewport.to && !styleChange && tree.type == this.tree.type && decoratedToMapped >= viewport.to) {\n            this.decorations = this.decorations.map(update.changes);\n            this.decoratedTo = decoratedToMapped;\n        } else if (tree != this.tree || update.viewportChanged || styleChange) {\n            this.tree = tree;\n            this.decorations = this.buildDeco(update.view, highlighters);\n            this.decoratedTo = viewport.to;\n        }\n    }\n    buildDeco(view, highlighters) {\n        if (!highlighters || !this.tree.length) return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n        let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();\n        for (let { from, to } of view.visibleRanges){\n            (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.highlightTree)(this.tree, highlighters, (from, to, style)=>{\n                builder.add(from, to, this.markCache[style] || (this.markCache[style] = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n                    class: style\n                })));\n            }, from, to);\n        }\n        return builder.finish();\n    }\n}\nconst treeHighlighter = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Prec.high(/*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(TreeHighlighter, {\n    decorations: (v)=>v.decorations\n}));\n/**\nA default highlight style (works well with light themes).\n*/ const defaultHighlightStyle = /*@__PURE__*/ HighlightStyle.define([\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.meta,\n        color: \"#404740\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.link,\n        textDecoration: \"underline\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.heading,\n        textDecoration: \"underline\",\n        fontWeight: \"bold\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.emphasis,\n        fontStyle: \"italic\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.strong,\n        fontWeight: \"bold\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.strikethrough,\n        textDecoration: \"line-through\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.keyword,\n        color: \"#708\"\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.atom,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.bool,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.url,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.contentSeparator,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.labelName\n        ],\n        color: \"#219\"\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.literal,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.inserted\n        ],\n        color: \"#164\"\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.deleted\n        ],\n        color: \"#a11\"\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.regexp,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.escape,\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string)\n        ],\n        color: \"#e40\"\n    },\n    {\n        tag: /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n        color: \"#00f\"\n    },\n    {\n        tag: /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.local(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n        color: \"#30a\"\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.typeName,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.namespace\n        ],\n        color: \"#085\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.className,\n        color: \"#167\"\n    },\n    {\n        tag: [\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.macroName\n        ],\n        color: \"#256\"\n    },\n    {\n        tag: /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n        color: \"#00c\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.comment,\n        color: \"#940\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.invalid,\n        color: \"#f00\"\n    }\n]);\nconst baseTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.baseTheme({\n    \"&.cm-focused .cm-matchingBracket\": {\n        backgroundColor: \"#328c8252\"\n    },\n    \"&.cm-focused .cm-nonmatchingBracket\": {\n        backgroundColor: \"#bb555544\"\n    }\n});\nconst DefaultScanDist = 10000, DefaultBrackets = \"()[]{}\";\nconst bracketMatchingConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(configs, {\n            afterCursor: true,\n            brackets: DefaultBrackets,\n            maxScanDistance: DefaultScanDist,\n            renderMatch: defaultRenderMatch\n        });\n    }\n});\nconst matchingMark = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n    class: \"cm-matchingBracket\"\n}), nonmatchingMark = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n    class: \"cm-nonmatchingBracket\"\n});\nfunction defaultRenderMatch(match) {\n    let decorations = [];\n    let mark = match.matched ? matchingMark : nonmatchingMark;\n    decorations.push(mark.range(match.start.from, match.start.to));\n    if (match.end) decorations.push(mark.range(match.end.from, match.end.to));\n    return decorations;\n}\nconst bracketMatchingState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n    create () {\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n    },\n    update (deco, tr) {\n        if (!tr.docChanged && !tr.selection) return deco;\n        let decorations = [];\n        let config = tr.state.facet(bracketMatchingConfig);\n        for (let range of tr.state.selection.ranges){\n            if (!range.empty) continue;\n            let match = matchBrackets(tr.state, range.head, -1, config) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config) || config.afterCursor && (matchBrackets(tr.state, range.head, 1, config) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config));\n            if (match) decorations = decorations.concat(config.renderMatch(match, tr.state));\n        }\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.set(decorations, true);\n    },\n    provide: (f)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.decorations.from(f)\n});\nconst bracketMatchingUnique = [\n    bracketMatchingState,\n    baseTheme\n];\n/**\nCreate an extension that enables bracket matching. Whenever the\ncursor is next to a bracket, that bracket and the one it matches\nare highlighted. Or, when no matching bracket is found, another\nhighlighting style is used to indicate this.\n*/ function bracketMatching(config = {}) {\n    return [\n        bracketMatchingConfig.of(config),\n        bracketMatchingUnique\n    ];\n}\n/**\nWhen larger syntax nodes, such as HTML tags, are marked as\nopening/closing, it can be a bit messy to treat the whole node as\na matchable bracket. This node prop allows you to define, for such\na node, a ‘handle’—the part of the node that is highlighted, and\nthat the cursor must be on to activate highlighting in the first\nplace.\n*/ const bracketMatchingHandle = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\nfunction matchingNodes(node, dir, brackets) {\n    let byProp = node.prop(dir < 0 ? _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.openedBy : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy);\n    if (byProp) return byProp;\n    if (node.name.length == 1) {\n        let index = brackets.indexOf(node.name);\n        if (index > -1 && index % 2 == (dir < 0 ? 1 : 0)) return [\n            brackets[index + dir]\n        ];\n    }\n    return null;\n}\nfunction findHandle(node) {\n    let hasHandle = node.type.prop(bracketMatchingHandle);\n    return hasHandle ? hasHandle(node.node) : node;\n}\n/**\nFind the matching bracket for the token at `pos`, scanning\ndirection `dir`. Only the `brackets` and `maxScanDistance`\nproperties are used from `config`, if given. Returns null if no\nbracket was found at `pos`, or a match result otherwise.\n*/ function matchBrackets(state, pos, dir, config = {}) {\n    let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;\n    let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);\n    for(let cur = node; cur; cur = cur.parent){\n        let matches = matchingNodes(cur.type, dir, brackets);\n        if (matches && cur.from < cur.to) {\n            let handle = findHandle(cur);\n            if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to)) return matchMarkedBrackets(state, pos, dir, cur, handle, matches, brackets);\n        }\n    }\n    return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);\n}\nfunction matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {\n    let parent = token.parent, firstToken = {\n        from: handle.from,\n        to: handle.to\n    };\n    let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();\n    if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to))) do {\n        if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {\n            if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {\n                let endHandle = findHandle(cursor);\n                return {\n                    start: firstToken,\n                    end: endHandle ? {\n                        from: endHandle.from,\n                        to: endHandle.to\n                    } : undefined,\n                    matched: true\n                };\n            } else if (matchingNodes(cursor.type, dir, brackets)) {\n                depth++;\n            } else if (matchingNodes(cursor.type, -dir, brackets)) {\n                if (depth == 0) {\n                    let endHandle = findHandle(cursor);\n                    return {\n                        start: firstToken,\n                        end: endHandle && endHandle.from < endHandle.to ? {\n                            from: endHandle.from,\n                            to: endHandle.to\n                        } : undefined,\n                        matched: false\n                    };\n                }\n                depth--;\n            }\n        }\n    }while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());\n    return {\n        start: firstToken,\n        matched: false\n    };\n}\nfunction matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {\n    let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);\n    let bracket = brackets.indexOf(startCh);\n    if (bracket < 0 || bracket % 2 == 0 != dir > 0) return null;\n    let startToken = {\n        from: dir < 0 ? pos - 1 : pos,\n        to: dir > 0 ? pos + 1 : pos\n    };\n    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;\n    for(let distance = 0; !iter.next().done && distance <= maxScanDistance;){\n        let text = iter.value;\n        if (dir < 0) distance += text.length;\n        let basePos = pos + distance * dir;\n        for(let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir){\n            let found = brackets.indexOf(text[pos]);\n            if (found < 0 || tree.resolveInner(basePos + pos, 1).type != tokenType) continue;\n            if (found % 2 == 0 == dir > 0) {\n                depth++;\n            } else if (depth == 1) {\n                return {\n                    start: startToken,\n                    end: {\n                        from: basePos + pos,\n                        to: basePos + pos + 1\n                    },\n                    matched: found >> 1 == bracket >> 1\n                };\n            } else {\n                depth--;\n            }\n        }\n        if (dir > 0) distance += text.length;\n    }\n    return iter.done ? {\n        start: startToken,\n        matched: false\n    } : null;\n}\n// Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\nfunction countCol(string, end, tabSize, startIndex = 0, startValue = 0) {\n    if (end == null) {\n        end = string.search(/[^\\s\\u00a0]/);\n        if (end == -1) end = string.length;\n    }\n    let n = startValue;\n    for(let i = startIndex; i < end; i++){\n        if (string.charCodeAt(i) == 9) n += tabSize - n % tabSize;\n        else n++;\n    }\n    return n;\n}\n/**\nEncapsulates a single line of input. Given to stream syntax code,\nwhich uses it to tokenize the content.\n*/ class StringStream {\n    /**\n    Create a stream.\n    */ constructor(/**\n    The line.\n    */ string, tabSize, /**\n    The current indent unit size.\n    */ indentUnit, overrideIndent){\n        this.string = string;\n        this.tabSize = tabSize;\n        this.indentUnit = indentUnit;\n        this.overrideIndent = overrideIndent;\n        /**\n        The current position on the line.\n        */ this.pos = 0;\n        /**\n        The start position of the current token.\n        */ this.start = 0;\n        this.lastColumnPos = 0;\n        this.lastColumnValue = 0;\n    }\n    /**\n    True if we are at the end of the line.\n    */ eol() {\n        return this.pos >= this.string.length;\n    }\n    /**\n    True if we are at the start of the line.\n    */ sol() {\n        return this.pos == 0;\n    }\n    /**\n    Get the next code unit after the current position, or undefined\n    if we're at the end of the line.\n    */ peek() {\n        return this.string.charAt(this.pos) || undefined;\n    }\n    /**\n    Read the next code unit and advance `this.pos`.\n    */ next() {\n        if (this.pos < this.string.length) return this.string.charAt(this.pos++);\n    }\n    /**\n    Match the next character against the given string, regular\n    expression, or predicate. Consume and return it if it matches.\n    */ eat(match) {\n        let ch = this.string.charAt(this.pos);\n        let ok;\n        if (typeof match == \"string\") ok = ch == match;\n        else ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch));\n        if (ok) {\n            ++this.pos;\n            return ch;\n        }\n    }\n    /**\n    Continue matching characters that match the given string,\n    regular expression, or predicate function. Return true if any\n    characters were consumed.\n    */ eatWhile(match) {\n        let start = this.pos;\n        while(this.eat(match)){}\n        return this.pos > start;\n    }\n    /**\n    Consume whitespace ahead of `this.pos`. Return true if any was\n    found.\n    */ eatSpace() {\n        let start = this.pos;\n        while(/[\\s\\u00a0]/.test(this.string.charAt(this.pos)))++this.pos;\n        return this.pos > start;\n    }\n    /**\n    Move to the end of the line.\n    */ skipToEnd() {\n        this.pos = this.string.length;\n    }\n    /**\n    Move to directly before the given character, if found on the\n    current line.\n    */ skipTo(ch) {\n        let found = this.string.indexOf(ch, this.pos);\n        if (found > -1) {\n            this.pos = found;\n            return true;\n        }\n    }\n    /**\n    Move back `n` characters.\n    */ backUp(n) {\n        this.pos -= n;\n    }\n    /**\n    Get the column position at `this.pos`.\n    */ column() {\n        if (this.lastColumnPos < this.start) {\n            this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n            this.lastColumnPos = this.start;\n        }\n        return this.lastColumnValue;\n    }\n    /**\n    Get the indentation column of the current line.\n    */ indentation() {\n        var _a;\n        return (_a = this.overrideIndent) !== null && _a !== void 0 ? _a : countCol(this.string, null, this.tabSize);\n    }\n    /**\n    Match the input against the given string or regular expression\n    (which should start with a `^`). Return true or the regexp match\n    if it matches.\n    \n    Unless `consume` is set to `false`, this will move `this.pos`\n    past the matched text.\n    \n    When matching a string `caseInsensitive` can be set to true to\n    make the match case-insensitive.\n    */ match(pattern, consume, caseInsensitive) {\n        if (typeof pattern == \"string\") {\n            let cased = (str)=>caseInsensitive ? str.toLowerCase() : str;\n            let substr = this.string.substr(this.pos, pattern.length);\n            if (cased(substr) == cased(pattern)) {\n                if (consume !== false) this.pos += pattern.length;\n                return true;\n            } else return null;\n        } else {\n            let match = this.string.slice(this.pos).match(pattern);\n            if (match && match.index > 0) return null;\n            if (match && consume !== false) this.pos += match[0].length;\n            return match;\n        }\n    }\n    /**\n    Get the current token.\n    */ current() {\n        return this.string.slice(this.start, this.pos);\n    }\n}\nfunction fullParser(spec) {\n    return {\n        name: spec.name || \"\",\n        token: spec.token,\n        blankLine: spec.blankLine || (()=>{}),\n        startState: spec.startState || (()=>true),\n        copyState: spec.copyState || defaultCopyState,\n        indent: spec.indent || (()=>null),\n        languageData: spec.languageData || {},\n        tokenTable: spec.tokenTable || noTokens\n    };\n}\nfunction defaultCopyState(state) {\n    if (typeof state != \"object\") return state;\n    let newState = {};\n    for(let prop in state){\n        let val = state[prop];\n        newState[prop] = val instanceof Array ? val.slice() : val;\n    }\n    return newState;\n}\nconst IndentedFrom = /*@__PURE__*/ new WeakMap();\n/**\nA [language](https://codemirror.net/6/docs/ref/#language.Language) class based on a CodeMirror\n5-style [streaming parser](https://codemirror.net/6/docs/ref/#language.StreamParser).\n*/ class StreamLanguage extends Language {\n    constructor(parser){\n        let data = defineLanguageFacet(parser.languageData);\n        let p = fullParser(parser), self;\n        let impl = new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n            createParse(input, fragments, ranges) {\n                return new Parse(self, input, fragments, ranges);\n            }\n        };\n        super(data, impl, [\n            indentService.of((cx, pos)=>this.getIndent(cx, pos))\n        ], parser.name);\n        this.topNode = docID(data);\n        self = this;\n        this.streamParser = p;\n        this.stateAfter = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp({\n            perNode: true\n        });\n        this.tokenTable = parser.tokenTable ? new TokenTable(p.tokenTable) : defaultTokenTable;\n    }\n    /**\n    Define a stream language.\n    */ static define(spec) {\n        return new StreamLanguage(spec);\n    }\n    getIndent(cx, pos) {\n        let tree = syntaxTree(cx.state), at = tree.resolve(pos);\n        while(at && at.type != this.topNode)at = at.parent;\n        if (!at) return null;\n        let from = undefined;\n        let { overrideIndentation } = cx.options;\n        if (overrideIndentation) {\n            from = IndentedFrom.get(cx.state);\n            if (from != null && from < pos - 1e4) from = undefined;\n        }\n        let start = findState(this, tree, 0, at.from, from !== null && from !== void 0 ? from : pos), statePos, state;\n        if (start) {\n            state = start.state;\n            statePos = start.pos + 1;\n        } else {\n            state = this.streamParser.startState(cx.unit);\n            statePos = 0;\n        }\n        if (pos - statePos > 10000 /* C.MaxIndentScanDist */ ) return null;\n        while(statePos < pos){\n            let line = cx.state.doc.lineAt(statePos), end = Math.min(pos, line.to);\n            if (line.length) {\n                let indentation = overrideIndentation ? overrideIndentation(line.from) : -1;\n                let stream = new StringStream(line.text, cx.state.tabSize, cx.unit, indentation < 0 ? undefined : indentation);\n                while(stream.pos < end - line.from)readToken(this.streamParser.token, stream, state);\n            } else {\n                this.streamParser.blankLine(state, cx.unit);\n            }\n            if (end == pos) break;\n            statePos = line.to + 1;\n        }\n        let line = cx.lineAt(pos);\n        if (overrideIndentation && from == null) IndentedFrom.set(cx.state, line.from);\n        return this.streamParser.indent(state, /^\\s*(.*)/.exec(line.text)[1], cx);\n    }\n    get allowsNesting() {\n        return false;\n    }\n}\nfunction findState(lang, tree, off, startPos, before) {\n    let state = off >= startPos && off + tree.length <= before && tree.prop(lang.stateAfter);\n    if (state) return {\n        state: lang.streamParser.copyState(state),\n        pos: off + tree.length\n    };\n    for(let i = tree.children.length - 1; i >= 0; i--){\n        let child = tree.children[i], pos = off + tree.positions[i];\n        let found = child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree && pos < before && findState(lang, child, pos, startPos, before);\n        if (found) return found;\n    }\n    return null;\n}\nfunction cutTree(lang, tree, from, to, inside) {\n    if (inside && from <= 0 && to >= tree.length) return tree;\n    if (!inside && tree.type == lang.topNode) inside = true;\n    for(let i = tree.children.length - 1; i >= 0; i--){\n        let pos = tree.positions[i], child = tree.children[i], inner;\n        if (pos < to && child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) {\n            if (!(inner = cutTree(lang, child, from - pos, to - pos, inside))) break;\n            return !inside ? inner : new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(tree.type, tree.children.slice(0, i).concat(inner), tree.positions.slice(0, i + 1), pos + inner.length);\n        }\n    }\n    return null;\n}\nfunction findStartInFragments(lang, fragments, startPos, editorState) {\n    for (let f of fragments){\n        let from = f.from + (f.openStart ? 25 : 0), to = f.to - (f.openEnd ? 25 : 0);\n        let found = from <= startPos && to > startPos && findState(lang, f.tree, 0 - f.offset, startPos, to), tree;\n        if (found && (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false))) return {\n            state: found.state,\n            tree\n        };\n    }\n    return {\n        state: lang.streamParser.startState(editorState ? getIndentUnit(editorState) : 4),\n        tree: _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty\n    };\n}\nclass Parse {\n    constructor(lang, input, fragments, ranges){\n        this.lang = lang;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.stoppedAt = null;\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunk = [];\n        this.chunkReused = undefined;\n        this.rangeIndex = 0;\n        this.to = ranges[ranges.length - 1].to;\n        let context = ParseContext.get(), from = ranges[0].from;\n        let { state, tree } = findStartInFragments(lang, fragments, from, context === null || context === void 0 ? void 0 : context.state);\n        this.state = state;\n        this.parsedPos = this.chunkStart = from + tree.length;\n        for(let i = 0; i < tree.children.length; i++){\n            this.chunks.push(tree.children[i]);\n            this.chunkPos.push(tree.positions[i]);\n        }\n        if (context && this.parsedPos < context.viewport.from - 100000 /* C.MaxDistanceBeforeViewport */ ) {\n            this.state = this.lang.streamParser.startState(getIndentUnit(context.state));\n            context.skipUntilInView(this.parsedPos, context.viewport.from);\n            this.parsedPos = context.viewport.from;\n        }\n        this.moveRangeIndex();\n    }\n    advance() {\n        let context = ParseContext.get();\n        let parseEnd = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt);\n        let end = Math.min(parseEnd, this.chunkStart + 2048 /* C.ChunkSize */ );\n        if (context) end = Math.min(end, context.viewport.to);\n        while(this.parsedPos < end)this.parseLine(context);\n        if (this.chunkStart < this.parsedPos) this.finishChunk();\n        if (this.parsedPos >= parseEnd) return this.finish();\n        if (context && this.parsedPos >= context.viewport.to) {\n            context.skipUntilInView(this.parsedPos, parseEnd);\n            return this.finish();\n        }\n        return null;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n    }\n    lineAfter(pos) {\n        let chunk = this.input.chunk(pos);\n        if (!this.input.lineChunks) {\n            let eol = chunk.indexOf(\"\\n\");\n            if (eol > -1) chunk = chunk.slice(0, eol);\n        } else if (chunk == \"\\n\") {\n            chunk = \"\";\n        }\n        return pos + chunk.length <= this.to ? chunk : chunk.slice(0, this.to - pos);\n    }\n    nextLine() {\n        let from = this.parsedPos, line = this.lineAfter(from), end = from + line.length;\n        for(let index = this.rangeIndex;;){\n            let rangeEnd = this.ranges[index].to;\n            if (rangeEnd >= end) break;\n            line = line.slice(0, rangeEnd - (end - line.length));\n            index++;\n            if (index == this.ranges.length) break;\n            let rangeStart = this.ranges[index].from;\n            let after = this.lineAfter(rangeStart);\n            line += after;\n            end = rangeStart + after.length;\n        }\n        return {\n            line,\n            end\n        };\n    }\n    skipGapsTo(pos, offset, side) {\n        for(;;){\n            let end = this.ranges[this.rangeIndex].to, offPos = pos + offset;\n            if (side > 0 ? end > offPos : end >= offPos) break;\n            let start = this.ranges[++this.rangeIndex].from;\n            offset += start - end;\n        }\n        return offset;\n    }\n    moveRangeIndex() {\n        while(this.ranges[this.rangeIndex].to < this.parsedPos)this.rangeIndex++;\n    }\n    emitToken(id, from, to, size, offset) {\n        if (this.ranges.length > 1) {\n            offset = this.skipGapsTo(from, offset, 1);\n            from += offset;\n            let len0 = this.chunk.length;\n            offset = this.skipGapsTo(to, offset, -1);\n            to += offset;\n            size += this.chunk.length - len0;\n        }\n        this.chunk.push(id, from, to, size);\n        return offset;\n    }\n    parseLine(context) {\n        let { line, end } = this.nextLine(), offset = 0, { streamParser } = this.lang;\n        let stream = new StringStream(line, context ? context.state.tabSize : 4, context ? getIndentUnit(context.state) : 2);\n        if (stream.eol()) {\n            streamParser.blankLine(this.state, stream.indentUnit);\n        } else {\n            while(!stream.eol()){\n                let token = readToken(streamParser.token, stream, this.state);\n                if (token) offset = this.emitToken(this.lang.tokenTable.resolve(token), this.parsedPos + stream.start, this.parsedPos + stream.pos, 4, offset);\n                if (stream.start > 10000 /* C.MaxLineLength */ ) break;\n            }\n        }\n        this.parsedPos = end;\n        this.moveRangeIndex();\n        if (this.parsedPos < this.to) this.parsedPos++;\n    }\n    finishChunk() {\n        let tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({\n            buffer: this.chunk,\n            start: this.chunkStart,\n            length: this.parsedPos - this.chunkStart,\n            nodeSet,\n            topID: 0,\n            maxBufferLength: 2048 /* C.ChunkSize */ ,\n            reused: this.chunkReused\n        });\n        tree = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(tree.type, tree.children, tree.positions, tree.length, [\n            [\n                this.lang.stateAfter,\n                this.lang.streamParser.copyState(this.state)\n            ]\n        ]);\n        this.chunks.push(tree);\n        this.chunkPos.push(this.chunkStart - this.ranges[0].from);\n        this.chunk = [];\n        this.chunkReused = undefined;\n        this.chunkStart = this.parsedPos;\n    }\n    finish() {\n        return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();\n    }\n}\nfunction readToken(token, stream, state) {\n    stream.start = stream.pos;\n    for(let i = 0; i < 10; i++){\n        let result = token(stream, state);\n        if (stream.pos > stream.start) return result;\n    }\n    throw new Error(\"Stream parser failed to advance stream.\");\n}\nconst noTokens = /*@__PURE__*/ Object.create(null);\nconst typeArray = [\n    _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none\n];\nconst nodeSet = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(typeArray);\nconst warned = [];\n// Cache of node types by name and tags\nconst byTag = /*@__PURE__*/ Object.create(null);\nconst defaultTable = /*@__PURE__*/ Object.create(null);\nfor (let [legacyName, name] of [\n    [\n        \"variable\",\n        \"variableName\"\n    ],\n    [\n        \"variable-2\",\n        \"variableName.special\"\n    ],\n    [\n        \"string-2\",\n        \"string.special\"\n    ],\n    [\n        \"def\",\n        \"variableName.definition\"\n    ],\n    [\n        \"tag\",\n        \"tagName\"\n    ],\n    [\n        \"attribute\",\n        \"attributeName\"\n    ],\n    [\n        \"type\",\n        \"typeName\"\n    ],\n    [\n        \"builtin\",\n        \"variableName.standard\"\n    ],\n    [\n        \"qualifier\",\n        \"modifier\"\n    ],\n    [\n        \"error\",\n        \"invalid\"\n    ],\n    [\n        \"header\",\n        \"heading\"\n    ],\n    [\n        \"property\",\n        \"propertyName\"\n    ]\n])defaultTable[legacyName] = /*@__PURE__*/ createTokenType(noTokens, name);\nclass TokenTable {\n    constructor(extra){\n        this.extra = extra;\n        this.table = Object.assign(Object.create(null), defaultTable);\n    }\n    resolve(tag) {\n        return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag));\n    }\n}\nconst defaultTokenTable = /*@__PURE__*/ new TokenTable(noTokens);\nfunction warnForPart(part, msg) {\n    if (warned.indexOf(part) > -1) return;\n    warned.push(part);\n    console.warn(msg);\n}\nfunction createTokenType(extra, tagStr) {\n    let tags$1 = [];\n    for (let name of tagStr.split(\" \")){\n        let found = [];\n        for (let part of name.split(\".\")){\n            let value = extra[part] || _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags[part];\n            if (!value) {\n                warnForPart(part, `Unknown highlighting tag ${part}`);\n            } else if (typeof value == \"function\") {\n                if (!found.length) warnForPart(part, `Modifier ${part} used at start of tag`);\n                else found = found.map(value);\n            } else {\n                if (found.length) warnForPart(part, `Tag ${part} used as modifier`);\n                else found = Array.isArray(value) ? value : [\n                    value\n                ];\n            }\n        }\n        for (let tag of found)tags$1.push(tag);\n    }\n    if (!tags$1.length) return 0;\n    let name = tagStr.replace(/ /g, \"_\"), key = name + \" \" + tags$1.map((t)=>t.id);\n    let known = byTag[key];\n    if (known) return known.id;\n    let type = byTag[key] = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n        id: typeArray.length,\n        name,\n        props: [\n            (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)({\n                [name]: tags$1\n            })\n        ]\n    });\n    typeArray.push(type);\n    return type.id;\n}\nfunction docID(data) {\n    let type = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n        id: typeArray.length,\n        name: \"Document\",\n        props: [\n            languageDataProp.add(()=>data)\n        ],\n        top: true\n    });\n    typeArray.push(type);\n    return type;\n}\nfunction buildForLine(line) {\n    return line.length <= 4096 && /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac\\ufb50-\\ufdff]/.test(line);\n}\nfunction textHasRTL(text) {\n    for(let i = text.iter(); !i.next().done;)if (buildForLine(i.value)) return true;\n    return false;\n}\nfunction changeAddsRTL(change) {\n    let added = false;\n    change.iterChanges((fA, tA, fB, tB, ins)=>{\n        if (!added && textHasRTL(ins)) added = true;\n    });\n    return added;\n}\nconst alwaysIsolate = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: (values)=>values.some((x)=>x)\n});\n/**\nMake sure nodes\n[marked](https://lezer.codemirror.net/docs/ref/#common.NodeProp^isolate)\nas isolating for bidirectional text are rendered in a way that\nisolates them from the surrounding text.\n*/ function bidiIsolates(options = {}) {\n    let extensions = [\n        isolateMarks\n    ];\n    if (options.alwaysIsolate) extensions.push(alwaysIsolate.of(true));\n    return extensions;\n}\nconst isolateMarks = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class {\n    constructor(view){\n        this.always = view.state.facet(alwaysIsolate) || view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.LTR || view.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.perLineTextDirection);\n        this.hasRTL = !this.always && textHasRTL(view.state.doc);\n        this.tree = syntaxTree(view.state);\n        this.decorations = this.always || this.hasRTL ? buildDeco(view, this.tree, this.always) : _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n    }\n    update(update) {\n        let always = update.state.facet(alwaysIsolate) || update.view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.LTR || update.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.perLineTextDirection);\n        if (!always && !this.hasRTL && changeAddsRTL(update.changes)) this.hasRTL = true;\n        if (!always && !this.hasRTL) return;\n        let tree = syntaxTree(update.state);\n        if (always != this.always || tree != this.tree || update.docChanged || update.viewportChanged) {\n            this.tree = tree;\n            this.always = always;\n            this.decorations = buildDeco(update.view, tree, always);\n        }\n    }\n}, {\n    provide: (plugin)=>{\n        function access(view) {\n            var _a, _b;\n            return (_b = (_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.decorations) !== null && _b !== void 0 ? _b : _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n        }\n        return [\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.outerDecorations.of(access),\n            _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Prec.lowest(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.bidiIsolatedRanges.of(access))\n        ];\n    }\n});\nfunction buildDeco(view, tree, always) {\n    let deco = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();\n    let ranges = view.visibleRanges;\n    if (!always) ranges = clipRTLLines(ranges, view.state.doc);\n    for (let { from, to } of ranges){\n        tree.iterate({\n            enter: (node)=>{\n                let iso = node.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.isolate);\n                if (iso) deco.add(node.from, node.to, marks[iso]);\n            },\n            from,\n            to\n        });\n    }\n    return deco.finish();\n}\nfunction clipRTLLines(ranges, doc) {\n    let cur = doc.iter(), pos = 0, result = [], last = null;\n    for (let { from, to } of ranges){\n        if (from != pos) {\n            if (pos < from) cur.next(from - pos);\n            pos = from;\n        }\n        for(;;){\n            let start = pos, end = pos + cur.value.length;\n            if (!cur.lineBreak && buildForLine(cur.value)) {\n                if (last && last.to > start - 10) last.to = Math.min(to, end);\n                else result.push(last = {\n                    from: start,\n                    to: Math.min(to, end)\n                });\n            }\n            if (pos >= to) break;\n            pos = end;\n            cur.next();\n        }\n    }\n    return result;\n}\nconst marks = {\n    rtl: /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n        class: \"cm-iso\",\n        inclusive: true,\n        attributes: {\n            dir: \"rtl\"\n        },\n        bidiIsolate: _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.RTL\n    }),\n    ltr: /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n        class: \"cm-iso\",\n        inclusive: true,\n        attributes: {\n            dir: \"ltr\"\n        },\n        bidiIsolate: _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.LTR\n    }),\n    auto: /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n        class: \"cm-iso\",\n        inclusive: true,\n        attributes: {\n            dir: \"auto\"\n        },\n        bidiIsolate: null\n    })\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGFuZ3VhZ2UvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrRztBQUMyQztBQUNaO0FBQy9DO0FBQzFDO0FBRXhDLElBQUk2QjtBQUNKOzs7QUFHQSxHQUNBLE1BQU1DLG1CQUFtQixXQUFXLEdBQUUsSUFBSTlCLG1EQUFRQTtBQUNsRDs7Ozs7OztBQU9BLEdBQ0EsU0FBUytCLG9CQUFvQkMsUUFBUTtJQUNqQyxPQUFPdkIsb0RBQUtBLENBQUN3QixNQUFNLENBQUM7UUFDaEJDLFNBQVNGLFdBQVdHLENBQUFBLFNBQVVBLE9BQU9DLE1BQU0sQ0FBQ0osWUFBWUs7SUFDNUQ7QUFDSjtBQUNBOzs7QUFHQSxHQUNBLE1BQU1DLGtCQUFrQixXQUFXLEdBQUUsSUFBSXRDLG1EQUFRQTtBQUNqRDs7Ozs7Ozs7QUFRQSxHQUNBLE1BQU11QztJQUNGOzs7Ozs7SUFNQSxHQUNBQyxZQUNBOzs7SUFHQSxHQUNBQyxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsa0JBQWtCLEVBQUUsRUFDbEM7O0lBRUEsR0FDQUMsT0FBTyxFQUFFLENBQUU7UUFDUCxJQUFJLENBQUNILElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNHLElBQUksR0FBR0E7UUFDWiwyREFBMkQ7UUFDM0QseURBQXlEO1FBQ3pELDZCQUE2QjtRQUM3QixJQUFJLENBQUNsQywwREFBV0EsQ0FBQ21DLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDLFNBQ3RDQyxPQUFPQyxjQUFjLENBQUN0QywwREFBV0EsQ0FBQ21DLFNBQVMsRUFBRSxRQUFRO1lBQUVJO2dCQUFRLE9BQU9DLFdBQVcsSUFBSTtZQUFHO1FBQUU7UUFDOUYsSUFBSSxDQUFDUixNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDUyxTQUFTLEdBQUc7WUFDYkMsU0FBU0MsRUFBRSxDQUFDLElBQUk7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UUFBTTtRQUFHMkssYUFBYW5zQix1REFBU0EsQ0FBQ29zQixHQUFHO0lBQUM7SUFDN0hDLEtBQUssV0FBVyxHQUFFenNCLHdEQUFVQSxDQUFDNmIsSUFBSSxDQUFDO1FBQUVFLE9BQU87UUFBVXNRLFdBQVc7UUFBTUMsWUFBWTtZQUFFMUssS0FBSztRQUFNO1FBQUcySyxhQUFhbnNCLHVEQUFTQSxDQUFDa3JCLEdBQUc7SUFBQztJQUM3SG9CLE1BQU0sV0FBVyxHQUFFMXNCLHdEQUFVQSxDQUFDNmIsSUFBSSxDQUFDO1FBQUVFLE9BQU87UUFBVXNRLFdBQVc7UUFBTUMsWUFBWTtZQUFFMUssS0FBSztRQUFPO1FBQUcySyxhQUFhO0lBQUs7QUFDMUg7QUFFd3lCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWJjLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xhbmd1YWdlL2Rpc3QvaW5kZXguanM/ZDczZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOb2RlUHJvcCwgSXRlck1vZGUsIFRyZWUsIFRyZWVGcmFnbWVudCwgUGFyc2VyLCBOb2RlVHlwZSwgTm9kZVNldCB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuaW1wb3J0IHsgU3RhdGVFZmZlY3QsIFN0YXRlRmllbGQsIEZhY2V0LCBFZGl0b3JTdGF0ZSwgY291bnRDb2x1bW4sIGNvbWJpbmVDb25maWcsIFJhbmdlU2V0LCBSYW5nZVNldEJ1aWxkZXIsIFByZWMgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgeyBWaWV3UGx1Z2luLCBsb2dFeGNlcHRpb24sIEVkaXRvclZpZXcsIERlY29yYXRpb24sIFdpZGdldFR5cGUsIGd1dHRlciwgR3V0dGVyTWFya2VyLCBEaXJlY3Rpb24gfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IHRhZ3MsIHRhZ0hpZ2hsaWdodGVyLCBoaWdobGlnaHRUcmVlLCBzdHlsZVRhZ3MgfSBmcm9tICdAbGV6ZXIvaGlnaGxpZ2h0JztcbmltcG9ydCB7IFN0eWxlTW9kdWxlIH0gZnJvbSAnc3R5bGUtbW9kJztcblxudmFyIF9hO1xuLyoqXG5Ob2RlIHByb3Agc3RvcmVkIGluIGEgcGFyc2VyJ3MgdG9wIHN5bnRheCBub2RlIHRvIHByb3ZpZGUgdGhlXG5mYWNldCB0aGF0IHN0b3JlcyBsYW5ndWFnZS1zcGVjaWZpYyBkYXRhIGZvciB0aGF0IGxhbmd1YWdlLlxuKi9cbmNvbnN0IGxhbmd1YWdlRGF0YVByb3AgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVQcm9wKCk7XG4vKipcbkhlbHBlciBmdW5jdGlvbiB0byBkZWZpbmUgYSBmYWNldCAodG8gYmUgYWRkZWQgdG8gdGhlIHRvcCBzeW50YXhcbm5vZGUocykgZm9yIGEgbGFuZ3VhZ2UgdmlhXG5bYGxhbmd1YWdlRGF0YVByb3BgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmxhbmd1YWdlRGF0YVByb3ApKSwgdGhhdCB3aWxsIGJlXG51c2VkIHRvIGFzc29jaWF0ZSBsYW5ndWFnZSBkYXRhIHdpdGggdGhlIGxhbmd1YWdlLiBZb3VcbnByb2JhYmx5IG9ubHkgbmVlZCB0aGlzIHdoZW4gc3ViY2xhc3NpbmdcbltgTGFuZ3VhZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlKS5cbiovXG5mdW5jdGlvbiBkZWZpbmVMYW5ndWFnZUZhY2V0KGJhc2VEYXRhKSB7XG4gICAgcmV0dXJuIEZhY2V0LmRlZmluZSh7XG4gICAgICAgIGNvbWJpbmU6IGJhc2VEYXRhID8gdmFsdWVzID0+IHZhbHVlcy5jb25jYXQoYmFzZURhdGEpIDogdW5kZWZpbmVkXG4gICAgfSk7XG59XG4vKipcblN5bnRheCBub2RlIHByb3AgdXNlZCB0byByZWdpc3RlciBzdWJsYW5ndWFnZXMuIFNob3VsZCBiZSBhZGRlZCB0b1xudGhlIHRvcCBsZXZlbCBub2RlIHR5cGUgZm9yIHRoZSBsYW5ndWFnZS5cbiovXG5jb25zdCBzdWJsYW5ndWFnZVByb3AgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVQcm9wKCk7XG4vKipcbkEgbGFuZ3VhZ2Ugb2JqZWN0IG1hbmFnZXMgcGFyc2luZyBhbmQgcGVyLWxhbmd1YWdlXG5bbWV0YWRhdGFdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpLiBQYXJzZSBkYXRhIGlzXG5tYW5hZ2VkIGFzIGEgW0xlemVyXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0KSB0cmVlLiBUaGUgY2xhc3NcbmNhbiBiZSB1c2VkIGRpcmVjdGx5LCB2aWEgdGhlIFtgTFJMYW5ndWFnZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTFJMYW5ndWFnZSlcbnN1YmNsYXNzIGZvciBbTGV6ZXJdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQvKSBMUiBwYXJzZXJzLCBvclxudmlhIHRoZSBbYFN0cmVhbUxhbmd1YWdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5TdHJlYW1MYW5ndWFnZSkgc3ViY2xhc3NcbmZvciBzdHJlYW0gcGFyc2Vycy5cbiovXG5jbGFzcyBMYW5ndWFnZSB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgbGFuZ3VhZ2Ugb2JqZWN0LiBJZiB5b3UgbmVlZCB0byBpbnZva2UgdGhpc1xuICAgIGRpcmVjdGx5LCBmaXJzdCBkZWZpbmUgYSBkYXRhIGZhY2V0IHdpdGhcbiAgICBbYGRlZmluZUxhbmd1YWdlRmFjZXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmRlZmluZUxhbmd1YWdlRmFjZXQpLCBhbmQgdGhlblxuICAgIGNvbmZpZ3VyZSB5b3VyIHBhcnNlciB0byBbYXR0YWNoXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmxhbmd1YWdlRGF0YVByb3ApIGl0XG4gICAgdG8gdGhlIGxhbmd1YWdlJ3Mgb3V0ZXIgc3ludGF4IG5vZGUuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgW2xhbmd1YWdlIGRhdGFdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpIGZhY2V0XG4gICAgdXNlZCBmb3IgdGhpcyBsYW5ndWFnZS5cbiAgICAqL1xuICAgIGRhdGEsIHBhcnNlciwgZXh0cmFFeHRlbnNpb25zID0gW10sIFxuICAgIC8qKlxuICAgIEEgbGFuZ3VhZ2UgbmFtZS5cbiAgICAqL1xuICAgIG5hbWUgPSBcIlwiKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIC8vIEtsdWRnZSB0byBkZWZpbmUgRWRpdG9yU3RhdGUudHJlZSBhcyBhIGRlYnVnZ2luZyBoZWxwZXIsXG4gICAgICAgIC8vIHdpdGhvdXQgdGhlIEVkaXRvclN0YXRlIHBhY2thZ2UgYWN0dWFsbHkga25vd2luZyBhYm91dFxuICAgICAgICAvLyBsYW5ndWFnZXMgYW5kIGxlemVyIHRyZWVzLlxuICAgICAgICBpZiAoIUVkaXRvclN0YXRlLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShcInRyZWVcIikpXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRWRpdG9yU3RhdGUucHJvdG90eXBlLCBcInRyZWVcIiwgeyBnZXQoKSB7IHJldHVybiBzeW50YXhUcmVlKHRoaXMpOyB9IH0pO1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5leHRlbnNpb24gPSBbXG4gICAgICAgICAgICBsYW5ndWFnZS5vZih0aGlzKSxcbiAgICAgICAgICAgIEVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YS5vZigoc3RhdGUsIHBvcywgc2lkZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB0b3AgPSB0b3BOb2RlQXQoc3RhdGUsIHBvcywgc2lkZSksIGRhdGEgPSB0b3AudHlwZS5wcm9wKGxhbmd1YWdlRGF0YVByb3ApO1xuICAgICAgICAgICAgICAgIGlmICghZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIGxldCBiYXNlID0gc3RhdGUuZmFjZXQoZGF0YSksIHN1YiA9IHRvcC50eXBlLnByb3Aoc3VibGFuZ3VhZ2VQcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAoc3ViKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbm5lck5vZGUgPSB0b3AucmVzb2x2ZShwb3MgLSB0b3AuZnJvbSwgc2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHN1Ymxhbmcgb2Ygc3ViKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YmxhbmcudGVzdChpbm5lck5vZGUsIHN0YXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXRhID0gc3RhdGUuZmFjZXQoc3VibGFuZy5mYWNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YmxhbmcudHlwZSA9PSBcInJlcGxhY2VcIiA/IGRhdGEgOiBkYXRhLmNvbmNhdChiYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgICAgICB9KVxuICAgICAgICBdLmNvbmNhdChleHRyYUV4dGVuc2lvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBRdWVyeSB3aGV0aGVyIHRoaXMgbGFuZ3VhZ2UgaXMgYWN0aXZlIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGlzQWN0aXZlQXQoc3RhdGUsIHBvcywgc2lkZSA9IC0xKSB7XG4gICAgICAgIHJldHVybiB0b3BOb2RlQXQoc3RhdGUsIHBvcywgc2lkZSkudHlwZS5wcm9wKGxhbmd1YWdlRGF0YVByb3ApID09IHRoaXMuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgZG9jdW1lbnQgcmVnaW9ucyB0aGF0IHdlcmUgcGFyc2VkIHVzaW5nIHRoaXMgbGFuZ3VhZ2UuXG4gICAgVGhlIHJldHVybmVkIHJlZ2lvbnMgd2lsbCBfaW5jbHVkZV8gYW55IG5lc3RlZCBsYW5ndWFnZXMgcm9vdGVkXG4gICAgaW4gdGhpcyBsYW5ndWFnZSwgd2hlbiB0aG9zZSBleGlzdC5cbiAgICAqL1xuICAgIGZpbmRSZWdpb25zKHN0YXRlKSB7XG4gICAgICAgIGxldCBsYW5nID0gc3RhdGUuZmFjZXQobGFuZ3VhZ2UpO1xuICAgICAgICBpZiAoKGxhbmcgPT09IG51bGwgfHwgbGFuZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFuZy5kYXRhKSA9PSB0aGlzLmRhdGEpXG4gICAgICAgICAgICByZXR1cm4gW3sgZnJvbTogMCwgdG86IHN0YXRlLmRvYy5sZW5ndGggfV07XG4gICAgICAgIGlmICghbGFuZyB8fCAhbGFuZy5hbGxvd3NOZXN0aW5nKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBleHBsb3JlID0gKHRyZWUsIGZyb20pID0+IHtcbiAgICAgICAgICAgIGlmICh0cmVlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCkgPT0gdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBmcm9tLCB0bzogZnJvbSArIHRyZWUubGVuZ3RoIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtb3VudCA9IHRyZWUucHJvcChOb2RlUHJvcC5tb3VudGVkKTtcbiAgICAgICAgICAgIGlmIChtb3VudCkge1xuICAgICAgICAgICAgICAgIGlmIChtb3VudC50cmVlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCkgPT0gdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3VudC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiBtb3VudC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgZnJvbTogci5mcm9tICsgZnJvbSwgdG86IHIudG8gKyBmcm9tIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IGZyb206IGZyb20sIHRvOiBmcm9tICsgdHJlZS5sZW5ndGggfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobW91bnQub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGV4cGxvcmUobW91bnQudHJlZSwgbW91bnQub3ZlcmxheVswXS5mcm9tICsgZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gc2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyZWUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY2ggPSB0cmVlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjaCBpbnN0YW5jZW9mIFRyZWUpXG4gICAgICAgICAgICAgICAgICAgIGV4cGxvcmUoY2gsIHRyZWUucG9zaXRpb25zW2ldICsgZnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGV4cGxvcmUoc3ludGF4VHJlZShzdGF0ZSksIDApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGxhbmd1YWdlIGFsbG93cyBuZXN0ZWQgbGFuZ3VhZ2VzLiBUaGVcbiAgICBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnMgdHJ1ZS5cbiAgICAqL1xuICAgIGdldCBhbGxvd3NOZXN0aW5nKCkgeyByZXR1cm4gdHJ1ZTsgfVxufVxuLyoqXG5AaW50ZXJuYWxcbiovXG5MYW5ndWFnZS5zZXRTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmZ1bmN0aW9uIHRvcE5vZGVBdChzdGF0ZSwgcG9zLCBzaWRlKSB7XG4gICAgbGV0IHRvcExhbmcgPSBzdGF0ZS5mYWNldChsYW5ndWFnZSksIHRyZWUgPSBzeW50YXhUcmVlKHN0YXRlKS50b3BOb2RlO1xuICAgIGlmICghdG9wTGFuZyB8fCB0b3BMYW5nLmFsbG93c05lc3RpbmcpIHtcbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IHRyZWU7IG5vZGU7IG5vZGUgPSBub2RlLmVudGVyKHBvcywgc2lkZSwgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpKVxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZS5pc1RvcClcbiAgICAgICAgICAgICAgICB0cmVlID0gbm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIHRyZWU7XG59XG4vKipcbkEgc3ViY2xhc3Mgb2YgW2BMYW5ndWFnZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpIGZvciB1c2Ugd2l0aCBMZXplclxuW0xSIHBhcnNlcnNdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQvZG9jcy9yZWYjbHIuTFJQYXJzZXIpXG5wYXJzZXJzLlxuKi9cbmNsYXNzIExSTGFuZ3VhZ2UgZXh0ZW5kcyBMYW5ndWFnZSB7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgcGFyc2VyLCBuYW1lKSB7XG4gICAgICAgIHN1cGVyKGRhdGEsIHBhcnNlciwgW10sIG5hbWUpO1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgbGFuZ3VhZ2UgZnJvbSBhIHBhcnNlci5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoc3BlYykge1xuICAgICAgICBsZXQgZGF0YSA9IGRlZmluZUxhbmd1YWdlRmFjZXQoc3BlYy5sYW5ndWFnZURhdGEpO1xuICAgICAgICByZXR1cm4gbmV3IExSTGFuZ3VhZ2UoZGF0YSwgc3BlYy5wYXJzZXIuY29uZmlndXJlKHtcbiAgICAgICAgICAgIHByb3BzOiBbbGFuZ3VhZ2VEYXRhUHJvcC5hZGQodHlwZSA9PiB0eXBlLmlzVG9wID8gZGF0YSA6IHVuZGVmaW5lZCldXG4gICAgICAgIH0pLCBzcGVjLm5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgdGhpcyBsYW5ndWFnZSB3aXRoIGEgcmVjb25maWd1cmVkXG4gICAgdmVyc2lvbiBvZiBpdHMgcGFyc2VyIGFuZCBvcHRpb25hbGx5IGEgbmV3IG5hbWUuXG4gICAgKi9cbiAgICBjb25maWd1cmUob3B0aW9ucywgbmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IExSTGFuZ3VhZ2UodGhpcy5kYXRhLCB0aGlzLnBhcnNlci5jb25maWd1cmUob3B0aW9ucyksIG5hbWUgfHwgdGhpcy5uYW1lKTtcbiAgICB9XG4gICAgZ2V0IGFsbG93c05lc3RpbmcoKSB7IHJldHVybiB0aGlzLnBhcnNlci5oYXNXcmFwcGVycygpOyB9XG59XG4vKipcbkdldCB0aGUgc3ludGF4IHRyZWUgZm9yIGEgc3RhdGUsIHdoaWNoIGlzIHRoZSBjdXJyZW50IChwb3NzaWJseVxuaW5jb21wbGV0ZSkgcGFyc2UgdHJlZSBvZiB0aGUgYWN0aXZlXG5bbGFuZ3VhZ2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpLCBvciB0aGUgZW1wdHkgdHJlZSBpZiB0aGVyZSBpcyBub1xubGFuZ3VhZ2UgYXZhaWxhYmxlLlxuKi9cbmZ1bmN0aW9uIHN5bnRheFRyZWUoc3RhdGUpIHtcbiAgICBsZXQgZmllbGQgPSBzdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSwgZmFsc2UpO1xuICAgIHJldHVybiBmaWVsZCA/IGZpZWxkLnRyZWUgOiBUcmVlLmVtcHR5O1xufVxuLyoqXG5UcnkgdG8gZ2V0IGEgcGFyc2UgdHJlZSB0aGF0IHNwYW5zIGF0IGxlYXN0IHVwIHRvIGB1cHRvYC4gVGhlXG5tZXRob2Qgd2lsbCBkbyBhdCBtb3N0IGB0aW1lb3V0YCBtaWxsaXNlY29uZHMgb2Ygd29yayB0byBwYXJzZVxudXAgdG8gdGhhdCBwb2ludCBpZiB0aGUgdHJlZSBpc24ndCBhbHJlYWR5IGF2YWlsYWJsZS5cbiovXG5mdW5jdGlvbiBlbnN1cmVTeW50YXhUcmVlKHN0YXRlLCB1cHRvLCB0aW1lb3V0ID0gNTApIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHBhcnNlID0gKF9hID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRleHQ7XG4gICAgaWYgKCFwYXJzZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IG9sZFZpZXBvcnQgPSBwYXJzZS52aWV3cG9ydDtcbiAgICBwYXJzZS51cGRhdGVWaWV3cG9ydCh7IGZyb206IDAsIHRvOiB1cHRvIH0pO1xuICAgIGxldCByZXN1bHQgPSBwYXJzZS5pc0RvbmUodXB0bykgfHwgcGFyc2Uud29yayh0aW1lb3V0LCB1cHRvKSA/IHBhcnNlLnRyZWUgOiBudWxsO1xuICAgIHBhcnNlLnVwZGF0ZVZpZXdwb3J0KG9sZFZpZXBvcnQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcblF1ZXJpZXMgd2hldGhlciB0aGVyZSBpcyBhIGZ1bGwgc3ludGF4IHRyZWUgYXZhaWxhYmxlIHVwIHRvIHRoZVxuZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uIElmIHRoZXJlIGlzbid0LCB0aGUgYmFja2dyb3VuZCBwYXJzZVxucHJvY2VzcyBfbWlnaHRfIHN0aWxsIGJlIHdvcmtpbmcgYW5kIHVwZGF0ZSB0aGUgdHJlZSBmdXJ0aGVyLCBidXRcbnRoZXJlIGlzIG5vIGd1YXJhbnRlZSBvZiB0aGF04oCUdGhlIHBhcnNlciB3aWxsIFtzdG9wXG53b3JraW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLnN5bnRheFBhcnNlclJ1bm5pbmcpIHdoZW4gaXQgaGFzIHNwZW50IGFcbmNlcnRhaW4gYW1vdW50IG9mIHRpbWUgb3IgaGFzIG1vdmVkIGJleW9uZCB0aGUgdmlzaWJsZSB2aWV3cG9ydC5cbkFsd2F5cyByZXR1cm5zIGZhbHNlIGlmIG5vIGxhbmd1YWdlIGhhcyBiZWVuIGVuYWJsZWQuXG4qL1xuZnVuY3Rpb24gc3ludGF4VHJlZUF2YWlsYWJsZShzdGF0ZSwgdXB0byA9IHN0YXRlLmRvYy5sZW5ndGgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSBzdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGV4dC5pc0RvbmUodXB0bykpIHx8IGZhbHNlO1xufVxuLyoqXG5Nb3ZlIHBhcnNpbmcgZm9yd2FyZCwgYW5kIHVwZGF0ZSB0aGUgZWRpdG9yIHN0YXRlIGFmdGVyd2FyZHMgdG9cbnJlZmxlY3QgdGhlIG5ldyB0cmVlLiBXaWxsIHdvcmsgZm9yIGF0IG1vc3QgYHRpbWVvdXRgXG5taWxsaXNlY29uZHMuIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFyc2VyIG1hbmFnZWQgZ2V0IHRvIHRoZSBnaXZlblxucG9zaXRpb24gaW4gdGhhdCB0aW1lLlxuKi9cbmZ1bmN0aW9uIGZvcmNlUGFyc2luZyh2aWV3LCB1cHRvID0gdmlldy52aWV3cG9ydC50bywgdGltZW91dCA9IDEwMCkge1xuICAgIGxldCBzdWNjZXNzID0gZW5zdXJlU3ludGF4VHJlZSh2aWV3LnN0YXRlLCB1cHRvLCB0aW1lb3V0KTtcbiAgICBpZiAoc3VjY2VzcyAhPSBzeW50YXhUcmVlKHZpZXcuc3RhdGUpKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHt9KTtcbiAgICByZXR1cm4gISFzdWNjZXNzO1xufVxuLyoqXG5UZWxscyB5b3Ugd2hldGhlciB0aGUgbGFuZ3VhZ2UgcGFyc2VyIGlzIHBsYW5uaW5nIHRvIGRvIG1vcmVcbnBhcnNpbmcgd29yayAoaW4gYSBgcmVxdWVzdElkbGVDYWxsYmFja2AgcHNldWRvLXRocmVhZCkgb3IgaGFzXG5zdG9wcGVkIHJ1bm5pbmcsIGVpdGhlciBiZWNhdXNlIGl0IHBhcnNlZCB0aGUgZW50aXJlIGRvY3VtZW50LFxuYmVjYXVzZSBpdCBzcGVudCB0b28gbXVjaCB0aW1lIGFuZCB3YXMgY3V0IG9mZiwgb3IgYmVjYXVzZSB0aGVyZVxuaXMgbm8gbGFuZ3VhZ2UgcGFyc2VyIGVuYWJsZWQuXG4qL1xuZnVuY3Rpb24gc3ludGF4UGFyc2VyUnVubmluZyh2aWV3KSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gdmlldy5wbHVnaW4ocGFyc2VXb3JrZXIpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNXb3JraW5nKCkpIHx8IGZhbHNlO1xufVxuLyoqXG5MZXplci1zdHlsZVxuW2BJbnB1dGBdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQvZG9jcy9yZWYjY29tbW9uLklucHV0KVxub2JqZWN0IGZvciBhIFtgVGV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVGV4dCkgb2JqZWN0LlxuKi9cbmNsYXNzIERvY0lucHV0IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW5wdXQgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gZG9jdW1lbnQuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihkb2MpIHtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgIHRoaXMuY3Vyc29yUG9zID0gMDtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBcIlwiO1xuICAgICAgICB0aGlzLmN1cnNvciA9IGRvYy5pdGVyKCk7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLmRvYy5sZW5ndGg7IH1cbiAgICBzeW5jVG8ocG9zKSB7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gdGhpcy5jdXJzb3IubmV4dChwb3MgLSB0aGlzLmN1cnNvclBvcykudmFsdWU7XG4gICAgICAgIHRoaXMuY3Vyc29yUG9zID0gcG9zICsgdGhpcy5zdHJpbmcubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJzb3JQb3MgLSB0aGlzLnN0cmluZy5sZW5ndGg7XG4gICAgfVxuICAgIGNodW5rKHBvcykge1xuICAgICAgICB0aGlzLnN5bmNUbyhwb3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmc7XG4gICAgfVxuICAgIGdldCBsaW5lQ2h1bmtzKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIHJlYWQoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IHN0cmluZ1N0YXJ0ID0gdGhpcy5jdXJzb3JQb3MgLSB0aGlzLnN0cmluZy5sZW5ndGg7XG4gICAgICAgIGlmIChmcm9tIDwgc3RyaW5nU3RhcnQgfHwgdG8gPj0gdGhpcy5jdXJzb3JQb3MpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb2Muc2xpY2VTdHJpbmcoZnJvbSwgdG8pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UoZnJvbSAtIHN0cmluZ1N0YXJ0LCB0byAtIHN0cmluZ1N0YXJ0KTtcbiAgICB9XG59XG5sZXQgY3VycmVudENvbnRleHQgPSBudWxsO1xuLyoqXG5BIHBhcnNlIGNvbnRleHQgcHJvdmlkZWQgdG8gcGFyc2VycyB3b3JraW5nIG9uIHRoZSBlZGl0b3IgY29udGVudC5cbiovXG5jbGFzcyBQYXJzZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgc3RhdGUsIFxuICAgIC8qKlxuICAgIFRyZWUgZnJhZ21lbnRzIHRoYXQgY2FuIGJlIHJldXNlZCBieSBpbmNyZW1lbnRhbCByZS1wYXJzZXMuXG4gICAgKi9cbiAgICBmcmFnbWVudHMgPSBbXSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0cmVlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRyZWVMZW4sIFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGVkaXRvciB2aWV3cG9ydCAob3Igc29tZSBvdmVyYXBwcm94aW1hdGlvblxuICAgIHRoZXJlb2YpLiBJbnRlbmRlZCB0byBiZSB1c2VkIGZvciBvcHBvcnR1bmlzdGljYWxseSBhdm9pZGluZ1xuICAgIHdvcmsgKGluIHdoaWNoIGNhc2VcbiAgICBbYHNraXBVbnRpbEluVmlld2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuUGFyc2VDb250ZXh0LnNraXBVbnRpbEluVmlldylcbiAgICBzaG91bGQgYmUgY2FsbGVkIHRvIG1ha2Ugc3VyZSB0aGUgcGFyc2VyIGlzIHJlc3RhcnRlZCB3aGVuIHRoZVxuICAgIHNraXBwZWQgcmVnaW9uIGJlY29tZXMgdmlzaWJsZSkuXG4gICAgKi9cbiAgICB2aWV3cG9ydCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBza2lwcGVkLCBcbiAgICAvKipcbiAgICBUaGlzIGlzIHdoZXJlIHNraXBwaW5nIHBhcnNlcnMgY2FuIHJlZ2lzdGVyIGEgcHJvbWlzZSB0aGF0LFxuICAgIHdoZW4gcmVzb2x2ZWQsIHdpbGwgc2NoZWR1bGUgYSBuZXcgcGFyc2UuIEl0IGlzIGNsZWFyZWQgd2hlblxuICAgIHRoZSBwYXJzZSB3b3JrZXIgcGlja3MgdXAgdGhlIHByb21pc2UuIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2NoZWR1bGVPbikge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy50cmVlTGVuID0gdHJlZUxlbjtcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICB0aGlzLnNraXBwZWQgPSBza2lwcGVkO1xuICAgICAgICB0aGlzLnNjaGVkdWxlT24gPSBzY2hlZHVsZU9uO1xuICAgICAgICB0aGlzLnBhcnNlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnRlbXBTa2lwcGVkID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShwYXJzZXIsIHN0YXRlLCB2aWV3cG9ydCkge1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlQ29udGV4dChwYXJzZXIsIHN0YXRlLCBbXSwgVHJlZS5lbXB0eSwgMCwgdmlld3BvcnQsIFtdLCBudWxsKTtcbiAgICB9XG4gICAgc3RhcnRQYXJzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VyLnN0YXJ0UGFyc2UobmV3IERvY0lucHV0KHRoaXMuc3RhdGUuZG9jKSwgdGhpcy5mcmFnbWVudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHdvcmsodW50aWwsIHVwdG8pIHtcbiAgICAgICAgaWYgKHVwdG8gIT0gbnVsbCAmJiB1cHRvID49IHRoaXMuc3RhdGUuZG9jLmxlbmd0aClcbiAgICAgICAgICAgIHVwdG8gPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLnRyZWUgIT0gVHJlZS5lbXB0eSAmJiB0aGlzLmlzRG9uZSh1cHRvICE9PSBudWxsICYmIHVwdG8gIT09IHZvaWQgMCA/IHVwdG8gOiB0aGlzLnN0YXRlLmRvYy5sZW5ndGgpKSB7XG4gICAgICAgICAgICB0aGlzLnRha2VUcmVlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy53aXRoQ29udGV4dCgoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVudGlsID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kVGltZSA9IERhdGUubm93KCkgKyB1bnRpbDtcbiAgICAgICAgICAgICAgICB1bnRpbCA9ICgpID0+IERhdGUubm93KCkgPiBlbmRUaW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcnNlKVxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2UgPSB0aGlzLnN0YXJ0UGFyc2UoKTtcbiAgICAgICAgICAgIGlmICh1cHRvICE9IG51bGwgJiYgKHRoaXMucGFyc2Uuc3RvcHBlZEF0ID09IG51bGwgfHwgdGhpcy5wYXJzZS5zdG9wcGVkQXQgPiB1cHRvKSAmJlxuICAgICAgICAgICAgICAgIHVwdG8gPCB0aGlzLnN0YXRlLmRvYy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZS5zdG9wQXQodXB0byk7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgbGV0IGRvbmUgPSB0aGlzLnBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50cyA9IHRoaXMud2l0aG91dFRlbXBTa2lwcGVkKFRyZWVGcmFnbWVudC5hZGRUcmVlKGRvbmUsIHRoaXMuZnJhZ21lbnRzLCB0aGlzLnBhcnNlLnN0b3BwZWRBdCAhPSBudWxsKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZUxlbiA9IChfYSA9IHRoaXMucGFyc2Uuc3RvcHBlZEF0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnN0YXRlLmRvYy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZSA9IGRvbmU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmVlTGVuIDwgKHVwdG8gIT09IG51bGwgJiYgdXB0byAhPT0gdm9pZCAwID8gdXB0byA6IHRoaXMuc3RhdGUuZG9jLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlID0gdGhpcy5zdGFydFBhcnNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodW50aWwoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0YWtlVHJlZSgpIHtcbiAgICAgICAgbGV0IHBvcywgdHJlZTtcbiAgICAgICAgaWYgKHRoaXMucGFyc2UgJiYgKHBvcyA9IHRoaXMucGFyc2UucGFyc2VkUG9zKSA+PSB0aGlzLnRyZWVMZW4pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlLnN0b3BwZWRBdCA9PSBudWxsIHx8IHRoaXMucGFyc2Uuc3RvcHBlZEF0ID4gcG9zKVxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2Uuc3RvcEF0KHBvcyk7XG4gICAgICAgICAgICB0aGlzLndpdGhDb250ZXh0KCgpID0+IHsgd2hpbGUgKCEodHJlZSA9IHRoaXMucGFyc2UuYWR2YW5jZSgpKSkgeyB9IH0pO1xuICAgICAgICAgICAgdGhpcy50cmVlTGVuID0gcG9zO1xuICAgICAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRzID0gdGhpcy53aXRob3V0VGVtcFNraXBwZWQoVHJlZUZyYWdtZW50LmFkZFRyZWUodGhpcy50cmVlLCB0aGlzLmZyYWdtZW50cywgdHJ1ZSkpO1xuICAgICAgICAgICAgdGhpcy5wYXJzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2l0aENvbnRleHQoZikge1xuICAgICAgICBsZXQgcHJldiA9IGN1cnJlbnRDb250ZXh0O1xuICAgICAgICBjdXJyZW50Q29udGV4dCA9IHRoaXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZigpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBwcmV2O1xuICAgICAgICB9XG4gICAgfVxuICAgIHdpdGhvdXRUZW1wU2tpcHBlZChmcmFnbWVudHMpIHtcbiAgICAgICAgZm9yIChsZXQgcjsgciA9IHRoaXMudGVtcFNraXBwZWQucG9wKCk7KVxuICAgICAgICAgICAgZnJhZ21lbnRzID0gY3V0RnJhZ21lbnRzKGZyYWdtZW50cywgci5mcm9tLCByLnRvKTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50cztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaGFuZ2VzKGNoYW5nZXMsIG5ld1N0YXRlKSB7XG4gICAgICAgIGxldCB7IGZyYWdtZW50cywgdHJlZSwgdHJlZUxlbiwgdmlld3BvcnQsIHNraXBwZWQgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMudGFrZVRyZWUoKTtcbiAgICAgICAgaWYgKCFjaGFuZ2VzLmVtcHR5KSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgICAgICBjaGFuZ2VzLml0ZXJDaGFuZ2VkUmFuZ2VzKChmcm9tQSwgdG9BLCBmcm9tQiwgdG9CKSA9PiByYW5nZXMucHVzaCh7IGZyb21BLCB0b0EsIGZyb21CLCB0b0IgfSkpO1xuICAgICAgICAgICAgZnJhZ21lbnRzID0gVHJlZUZyYWdtZW50LmFwcGx5Q2hhbmdlcyhmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgICAgICB0cmVlID0gVHJlZS5lbXB0eTtcbiAgICAgICAgICAgIHRyZWVMZW4gPSAwO1xuICAgICAgICAgICAgdmlld3BvcnQgPSB7IGZyb206IGNoYW5nZXMubWFwUG9zKHZpZXdwb3J0LmZyb20sIC0xKSwgdG86IGNoYW5nZXMubWFwUG9zKHZpZXdwb3J0LnRvLCAxKSB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuc2tpcHBlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiB0aGlzLnNraXBwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZyb20gPSBjaGFuZ2VzLm1hcFBvcyhyLmZyb20sIDEpLCB0byA9IGNoYW5nZXMubWFwUG9zKHIudG8sIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gPCB0bylcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBwZWQucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlQ29udGV4dCh0aGlzLnBhcnNlciwgbmV3U3RhdGUsIGZyYWdtZW50cywgdHJlZSwgdHJlZUxlbiwgdmlld3BvcnQsIHNraXBwZWQsIHRoaXMuc2NoZWR1bGVPbik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdXBkYXRlVmlld3BvcnQodmlld3BvcnQpIHtcbiAgICAgICAgaWYgKHRoaXMudmlld3BvcnQuZnJvbSA9PSB2aWV3cG9ydC5mcm9tICYmIHRoaXMudmlld3BvcnQudG8gPT0gdmlld3BvcnQudG8pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAgICAgbGV0IHN0YXJ0TGVuID0gdGhpcy5za2lwcGVkLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNraXBwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSB0aGlzLnNraXBwZWRbaV07XG4gICAgICAgICAgICBpZiAoZnJvbSA8IHZpZXdwb3J0LnRvICYmIHRvID4gdmlld3BvcnQuZnJvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRzID0gY3V0RnJhZ21lbnRzKHRoaXMuZnJhZ21lbnRzLCBmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwcGVkLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNraXBwZWQubGVuZ3RoID49IHN0YXJ0TGVuKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5wYXJzZSkge1xuICAgICAgICAgICAgdGhpcy50YWtlVHJlZSgpO1xuICAgICAgICAgICAgdGhpcy5wYXJzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgTm90aWZ5IHRoZSBwYXJzZSBzY2hlZHVsZXIgdGhhdCB0aGUgZ2l2ZW4gcmVnaW9uIHdhcyBza2lwcGVkXG4gICAgYmVjYXVzZSBpdCB3YXNuJ3QgaW4gdmlldywgYW5kIHRoZSBwYXJzZSBzaG91bGQgYmUgcmVzdGFydGVkXG4gICAgd2hlbiBpdCBjb21lcyBpbnRvIHZpZXcuXG4gICAgKi9cbiAgICBza2lwVW50aWxJblZpZXcoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5za2lwcGVkLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhIHBhcnNlciBpbnRlbmRlZCB0byBiZSB1c2VkIGFzIHBsYWNlaG9sZGVyIHdoZW5cbiAgICBhc3luY2hyb25vdXNseSBsb2FkaW5nIGEgbmVzdGVkIHBhcnNlci4gSXQnbGwgc2tpcCBpdHMgaW5wdXQgYW5kXG4gICAgbWFyayBpdCBhcyBub3QtcmVhbGx5LXBhcnNlZCwgc28gdGhhdCB0aGUgbmV4dCB1cGRhdGUgd2lsbCBwYXJzZVxuICAgIGl0IGFnYWluLlxuICAgIFxuICAgIFdoZW4gYHVudGlsYCBpcyBnaXZlbiwgYSByZXBhcnNlIHdpbGwgYmUgc2NoZWR1bGVkIHdoZW4gdGhhdFxuICAgIHByb21pc2UgcmVzb2x2ZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgZ2V0U2tpcHBpbmdQYXJzZXIodW50aWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjbGFzcyBleHRlbmRzIFBhcnNlciB7XG4gICAgICAgICAgICBjcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHJhbmdlc1swXS5mcm9tLCB0byA9IHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0udG87XG4gICAgICAgICAgICAgICAgbGV0IHBhcnNlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkUG9zOiBmcm9tLFxuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGN4ID0gY3VycmVudENvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIHJhbmdlcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3gudGVtcFNraXBwZWQucHVzaChyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW50aWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4LnNjaGVkdWxlT24gPSBjeC5zY2hlZHVsZU9uID8gUHJvbWlzZS5hbGwoW2N4LnNjaGVkdWxlT24sIHVudGlsXSkgOiB1bnRpbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VkUG9zID0gdG87XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWUoTm9kZVR5cGUubm9uZSwgW10sIFtdLCB0byAtIGZyb20pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkQXQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHN0b3BBdCgpIHsgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpc0RvbmUodXB0bykge1xuICAgICAgICB1cHRvID0gTWF0aC5taW4odXB0bywgdGhpcy5zdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgbGV0IGZyYWdzID0gdGhpcy5mcmFnbWVudHM7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWVMZW4gPj0gdXB0byAmJiBmcmFncy5sZW5ndGggJiYgZnJhZ3NbMF0uZnJvbSA9PSAwICYmIGZyYWdzWzBdLnRvID49IHVwdG87XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY29udGV4dCBmb3IgdGhlIGN1cnJlbnQgcGFyc2UsIG9yIGBudWxsYCBpZiBubyBlZGl0b3JcbiAgICBwYXJzZSBpcyBpbiBwcm9ncmVzcy5cbiAgICAqL1xuICAgIHN0YXRpYyBnZXQoKSB7IHJldHVybiBjdXJyZW50Q29udGV4dDsgfVxufVxuZnVuY3Rpb24gY3V0RnJhZ21lbnRzKGZyYWdtZW50cywgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gVHJlZUZyYWdtZW50LmFwcGx5Q2hhbmdlcyhmcmFnbWVudHMsIFt7IGZyb21BOiBmcm9tLCB0b0E6IHRvLCBmcm9tQjogZnJvbSwgdG9COiB0byB9XSk7XG59XG5jbGFzcyBMYW5ndWFnZVN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBBIG11dGFibGUgcGFyc2Ugc3RhdGUgdGhhdCBpcyB1c2VkIHRvIHByZXNlcnZlIHdvcmsgZG9uZSBkdXJpbmdcbiAgICAvLyB0aGUgbGlmZXRpbWUgb2YgYSBzdGF0ZSB3aGVuIG1vdmluZyB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMudHJlZSA9IGNvbnRleHQudHJlZTtcbiAgICB9XG4gICAgYXBwbHkodHIpIHtcbiAgICAgICAgaWYgKCF0ci5kb2NDaGFuZ2VkICYmIHRoaXMudHJlZSA9PSB0aGlzLmNvbnRleHQudHJlZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgbmV3Q3ggPSB0aGlzLmNvbnRleHQuY2hhbmdlcyh0ci5jaGFuZ2VzLCB0ci5zdGF0ZSk7XG4gICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyBwYXJzZSB3YXNuJ3QgZG9uZSwgZ28gZm9yd2FyZCBvbmx5IHVwIHRvIGl0c1xuICAgICAgICAvLyBlbmQgcG9zaXRpb24gb3IgdGhlIGVuZCBvZiB0aGUgdmlld3BvcnQsIHRvIGF2b2lkIHNsb3dpbmcgZG93blxuICAgICAgICAvLyBzdGF0ZSB1cGRhdGVzIHdpdGggcGFyc2Ugd29yayBiZXlvbmQgdGhlIHZpZXdwb3J0LlxuICAgICAgICBsZXQgdXB0byA9IHRoaXMuY29udGV4dC50cmVlTGVuID09IHRyLnN0YXJ0U3RhdGUuZG9jLmxlbmd0aCA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiBNYXRoLm1heCh0ci5jaGFuZ2VzLm1hcFBvcyh0aGlzLmNvbnRleHQudHJlZUxlbiksIG5ld0N4LnZpZXdwb3J0LnRvKTtcbiAgICAgICAgaWYgKCFuZXdDeC53b3JrKDIwIC8qIFdvcmsuQXBwbHkgKi8sIHVwdG8pKVxuICAgICAgICAgICAgbmV3Q3gudGFrZVRyZWUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMYW5ndWFnZVN0YXRlKG5ld0N4KTtcbiAgICB9XG4gICAgc3RhdGljIGluaXQoc3RhdGUpIHtcbiAgICAgICAgbGV0IHZwVG8gPSBNYXRoLm1pbigzMDAwIC8qIFdvcmsuSW5pdFZpZXdwb3J0ICovLCBzdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgbGV0IHBhcnNlU3RhdGUgPSBQYXJzZUNvbnRleHQuY3JlYXRlKHN0YXRlLmZhY2V0KGxhbmd1YWdlKS5wYXJzZXIsIHN0YXRlLCB7IGZyb206IDAsIHRvOiB2cFRvIH0pO1xuICAgICAgICBpZiAoIXBhcnNlU3RhdGUud29yaygyMCAvKiBXb3JrLkFwcGx5ICovLCB2cFRvKSlcbiAgICAgICAgICAgIHBhcnNlU3RhdGUudGFrZVRyZWUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMYW5ndWFnZVN0YXRlKHBhcnNlU3RhdGUpO1xuICAgIH1cbn1cbkxhbmd1YWdlLnN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGU6IExhbmd1YWdlU3RhdGUuaW5pdCxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGZvciAobGV0IGUgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgIGlmIChlLmlzKExhbmd1YWdlLnNldFN0YXRlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZS52YWx1ZTtcbiAgICAgICAgaWYgKHRyLnN0YXJ0U3RhdGUuZmFjZXQobGFuZ3VhZ2UpICE9IHRyLnN0YXRlLmZhY2V0KGxhbmd1YWdlKSlcbiAgICAgICAgICAgIHJldHVybiBMYW5ndWFnZVN0YXRlLmluaXQodHIuc3RhdGUpO1xuICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkodHIpO1xuICAgIH1cbn0pO1xubGV0IHJlcXVlc3RJZGxlID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgbGV0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IGNhbGxiYWNrKCksIDUwMCAvKiBXb3JrLk1heFBhdXNlICovKTtcbiAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufTtcbmlmICh0eXBlb2YgcmVxdWVzdElkbGVDYWxsYmFjayAhPSBcInVuZGVmaW5lZFwiKVxuICAgIHJlcXVlc3RJZGxlID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGxldCBpZGxlID0gLTEsIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlkbGUgPSByZXF1ZXN0SWRsZUNhbGxiYWNrKGNhbGxiYWNrLCB7IHRpbWVvdXQ6IDUwMCAvKiBXb3JrLk1heFBhdXNlICovIC0gMTAwIC8qIFdvcmsuTWluUGF1c2UgKi8gfSk7XG4gICAgICAgIH0sIDEwMCAvKiBXb3JrLk1pblBhdXNlICovKTtcbiAgICAgICAgcmV0dXJuICgpID0+IGlkbGUgPCAwID8gY2xlYXJUaW1lb3V0KHRpbWVvdXQpIDogY2FuY2VsSWRsZUNhbGxiYWNrKGlkbGUpO1xuICAgIH07XG5jb25zdCBpc0lucHV0UGVuZGluZyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAoKF9hID0gbmF2aWdhdG9yLnNjaGVkdWxpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0lucHV0UGVuZGluZylcbiAgICA/ICgpID0+IG5hdmlnYXRvci5zY2hlZHVsaW5nLmlzSW5wdXRQZW5kaW5nKCkgOiBudWxsO1xuY29uc3QgcGFyc2VXb3JrZXIgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3MgUGFyc2VXb3JrZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy53b3JraW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy53b3JrU2NoZWR1bGVkID0gMDtcbiAgICAgICAgLy8gRW5kIG9mIHRoZSBjdXJyZW50IHRpbWUgY2h1bmtcbiAgICAgICAgdGhpcy5jaHVua0VuZCA9IC0xO1xuICAgICAgICAvLyBNaWxsaXNlY29uZHMgb2YgYnVkZ2V0IGxlZnQgZm9yIHRoaXMgY2h1bmtcbiAgICAgICAgdGhpcy5jaHVua0J1ZGdldCA9IC0xO1xuICAgICAgICB0aGlzLndvcmsgPSB0aGlzLndvcmsuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVdvcmsoKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgY3ggPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUpLmNvbnRleHQ7XG4gICAgICAgIGlmIChjeC51cGRhdGVWaWV3cG9ydCh1cGRhdGUudmlldy52aWV3cG9ydCkgfHwgdGhpcy52aWV3LnZpZXdwb3J0LnRvID4gY3gudHJlZUxlbilcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVXb3JrKCk7XG4gICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuc2VsZWN0aW9uU2V0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy52aWV3Lmhhc0ZvY3VzKVxuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtCdWRnZXQgKz0gNTAgLyogV29yay5DaGFuZ2VCb251cyAqLztcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVXb3JrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja0FzeW5jU2NoZWR1bGUoY3gpO1xuICAgIH1cbiAgICBzY2hlZHVsZVdvcmsoKSB7XG4gICAgICAgIGlmICh0aGlzLndvcmtpbmcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0aGlzLnZpZXcsIGZpZWxkID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUpO1xuICAgICAgICBpZiAoZmllbGQudHJlZSAhPSBmaWVsZC5jb250ZXh0LnRyZWUgfHwgIWZpZWxkLmNvbnRleHQuaXNEb25lKHN0YXRlLmRvYy5sZW5ndGgpKVxuICAgICAgICAgICAgdGhpcy53b3JraW5nID0gcmVxdWVzdElkbGUodGhpcy53b3JrKTtcbiAgICB9XG4gICAgd29yayhkZWFkbGluZSkge1xuICAgICAgICB0aGlzLndvcmtpbmcgPSBudWxsO1xuICAgICAgICBsZXQgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtFbmQgPCBub3cgJiYgKHRoaXMuY2h1bmtFbmQgPCAwIHx8IHRoaXMudmlldy5oYXNGb2N1cykpIHsgLy8gU3RhcnQgYSBuZXcgY2h1bmtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtFbmQgPSBub3cgKyAzMDAwMCAvKiBXb3JrLkNodW5rVGltZSAqLztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtCdWRnZXQgPSAzMDAwIC8qIFdvcmsuQ2h1bmtCdWRnZXQgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2h1bmtCdWRnZXQgPD0gMClcbiAgICAgICAgICAgIHJldHVybjsgLy8gTm8gbW9yZSBidWRnZXRcbiAgICAgICAgbGV0IHsgc3RhdGUsIHZpZXdwb3J0OiB7IHRvOiB2cFRvIH0gfSA9IHRoaXMudmlldywgZmllbGQgPSBzdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSk7XG4gICAgICAgIGlmIChmaWVsZC50cmVlID09IGZpZWxkLmNvbnRleHQudHJlZSAmJiBmaWVsZC5jb250ZXh0LmlzRG9uZSh2cFRvICsgMTAwMDAwIC8qIFdvcmsuTWF4UGFyc2VBaGVhZCAqLykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBlbmRUaW1lID0gRGF0ZS5ub3coKSArIE1hdGgubWluKHRoaXMuY2h1bmtCdWRnZXQsIDEwMCAvKiBXb3JrLlNsaWNlICovLCBkZWFkbGluZSAmJiAhaXNJbnB1dFBlbmRpbmcgPyBNYXRoLm1heCgyNSAvKiBXb3JrLk1pblNsaWNlICovLCBkZWFkbGluZS50aW1lUmVtYWluaW5nKCkgLSA1KSA6IDFlOSk7XG4gICAgICAgIGxldCB2aWV3cG9ydEZpcnN0ID0gZmllbGQuY29udGV4dC50cmVlTGVuIDwgdnBUbyAmJiBzdGF0ZS5kb2MubGVuZ3RoID4gdnBUbyArIDEwMDA7XG4gICAgICAgIGxldCBkb25lID0gZmllbGQuY29udGV4dC53b3JrKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpc0lucHV0UGVuZGluZyAmJiBpc0lucHV0UGVuZGluZygpIHx8IERhdGUubm93KCkgPiBlbmRUaW1lO1xuICAgICAgICB9LCB2cFRvICsgKHZpZXdwb3J0Rmlyc3QgPyAwIDogMTAwMDAwIC8qIFdvcmsuTWF4UGFyc2VBaGVhZCAqLykpO1xuICAgICAgICB0aGlzLmNodW5rQnVkZ2V0IC09IERhdGUubm93KCkgLSBub3c7XG4gICAgICAgIGlmIChkb25lIHx8IHRoaXMuY2h1bmtCdWRnZXQgPD0gMCkge1xuICAgICAgICAgICAgZmllbGQuY29udGV4dC50YWtlVHJlZSgpO1xuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogTGFuZ3VhZ2Uuc2V0U3RhdGUub2YobmV3IExhbmd1YWdlU3RhdGUoZmllbGQuY29udGV4dCkpIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNodW5rQnVkZ2V0ID4gMCAmJiAhKGRvbmUgJiYgIXZpZXdwb3J0Rmlyc3QpKVxuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVdvcmsoKTtcbiAgICAgICAgdGhpcy5jaGVja0FzeW5jU2NoZWR1bGUoZmllbGQuY29udGV4dCk7XG4gICAgfVxuICAgIGNoZWNrQXN5bmNTY2hlZHVsZShjeCkge1xuICAgICAgICBpZiAoY3guc2NoZWR1bGVPbikge1xuICAgICAgICAgICAgdGhpcy53b3JrU2NoZWR1bGVkKys7XG4gICAgICAgICAgICBjeC5zY2hlZHVsZU9uXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5zY2hlZHVsZVdvcmsoKSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IGxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGVycikpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy53b3JrU2NoZWR1bGVkLS0pO1xuICAgICAgICAgICAgY3guc2NoZWR1bGVPbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMud29ya2luZylcbiAgICAgICAgICAgIHRoaXMud29ya2luZygpO1xuICAgIH1cbiAgICBpc1dvcmtpbmcoKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLndvcmtpbmcgfHwgdGhpcy53b3JrU2NoZWR1bGVkID4gMCk7XG4gICAgfVxufSwge1xuICAgIGV2ZW50SGFuZGxlcnM6IHsgZm9jdXMoKSB7IHRoaXMuc2NoZWR1bGVXb3JrKCk7IH0gfVxufSk7XG4vKipcblRoZSBmYWNldCB1c2VkIHRvIGFzc29jaWF0ZSBhIGxhbmd1YWdlIHdpdGggYW4gZWRpdG9yIHN0YXRlLiBVc2VkXG5ieSBgTGFuZ3VhZ2VgIG9iamVjdCdzIGBleHRlbnNpb25gIHByb3BlcnR5IChzbyB5b3UgZG9uJ3QgbmVlZCB0b1xubWFudWFsbHkgd3JhcCB5b3VyIGxhbmd1YWdlcyBpbiB0aGlzKS4gQ2FuIGJlIHVzZWQgdG8gYWNjZXNzIHRoZVxuY3VycmVudCBsYW5ndWFnZSBvbiBhIHN0YXRlLlxuKi9cbmNvbnN0IGxhbmd1YWdlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShsYW5ndWFnZXMpIHsgcmV0dXJuIGxhbmd1YWdlcy5sZW5ndGggPyBsYW5ndWFnZXNbMF0gOiBudWxsOyB9LFxuICAgIGVuYWJsZXM6IGxhbmd1YWdlID0+IFtcbiAgICAgICAgTGFuZ3VhZ2Uuc3RhdGUsXG4gICAgICAgIHBhcnNlV29ya2VyLFxuICAgICAgICBFZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzLmNvbXB1dGUoW2xhbmd1YWdlXSwgc3RhdGUgPT4ge1xuICAgICAgICAgICAgbGV0IGxhbmcgPSBzdGF0ZS5mYWNldChsYW5ndWFnZSk7XG4gICAgICAgICAgICByZXR1cm4gbGFuZyAmJiBsYW5nLm5hbWUgPyB7IFwiZGF0YS1sYW5ndWFnZVwiOiBsYW5nLm5hbWUgfSA6IHt9O1xuICAgICAgICB9KVxuICAgIF1cbn0pO1xuLyoqXG5UaGlzIGNsYXNzIGJ1bmRsZXMgYSBbbGFuZ3VhZ2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpIHdpdGggYW5cbm9wdGlvbmFsIHNldCBvZiBzdXBwb3J0aW5nIGV4dGVuc2lvbnMuIExhbmd1YWdlIHBhY2thZ2VzIGFyZVxuZW5jb3VyYWdlZCB0byBleHBvcnQgYSBmdW5jdGlvbiB0aGF0IG9wdGlvbmFsbHkgdGFrZXMgYVxuY29uZmlndXJhdGlvbiBvYmplY3QgYW5kIHJldHVybnMgYSBgTGFuZ3VhZ2VTdXBwb3J0YCBpbnN0YW5jZSwgYXNcbnRoZSBtYWluIHdheSBmb3IgY2xpZW50IGNvZGUgdG8gdXNlIHRoZSBwYWNrYWdlLlxuKi9cbmNsYXNzIExhbmd1YWdlU3VwcG9ydCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbGFuZ3VhZ2Ugc3VwcG9ydCBvYmplY3QuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbGFuZ3VhZ2Ugb2JqZWN0LlxuICAgICovXG4gICAgbGFuZ3VhZ2UsIFxuICAgIC8qKlxuICAgIEFuIG9wdGlvbmFsIHNldCBvZiBzdXBwb3J0aW5nIGV4dGVuc2lvbnMuIFdoZW4gbmVzdGluZyBhXG4gICAgbGFuZ3VhZ2UgaW4gYW5vdGhlciBsYW5ndWFnZSwgdGhlIG91dGVyIGxhbmd1YWdlIGlzIGVuY291cmFnZWRcbiAgICB0byBpbmNsdWRlIHRoZSBzdXBwb3J0aW5nIGV4dGVuc2lvbnMgZm9yIGl0cyBpbm5lciBsYW5ndWFnZXNcbiAgICBpbiBpdHMgb3duIHNldCBvZiBzdXBwb3J0IGV4dGVuc2lvbnMuXG4gICAgKi9cbiAgICBzdXBwb3J0ID0gW10pIHtcbiAgICAgICAgdGhpcy5sYW5ndWFnZSA9IGxhbmd1YWdlO1xuICAgICAgICB0aGlzLnN1cHBvcnQgPSBzdXBwb3J0O1xuICAgICAgICB0aGlzLmV4dGVuc2lvbiA9IFtsYW5ndWFnZSwgc3VwcG9ydF07XG4gICAgfVxufVxuLyoqXG5MYW5ndWFnZSBkZXNjcmlwdGlvbnMgYXJlIHVzZWQgdG8gc3RvcmUgbWV0YWRhdGEgYWJvdXQgbGFuZ3VhZ2VzXG5hbmQgdG8gZHluYW1pY2FsbHkgbG9hZCB0aGVtLiBUaGVpciBtYWluIHJvbGUgaXMgZmluZGluZyB0aGVcbmFwcHJvcHJpYXRlIGxhbmd1YWdlIGZvciBhIGZpbGVuYW1lIG9yIGR5bmFtaWNhbGx5IGxvYWRpbmcgbmVzdGVkXG5wYXJzZXJzLlxuKi9cbmNsYXNzIExhbmd1YWdlRGVzY3JpcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBuYW1lIG9mIHRoaXMgbGFuZ3VhZ2UuXG4gICAgKi9cbiAgICBuYW1lLCBcbiAgICAvKipcbiAgICBBbHRlcm5hdGl2ZSBuYW1lcyBmb3IgdGhlIG1vZGUgKGxvd2VyY2FzZWQsIGluY2x1ZGVzIGB0aGlzLm5hbWVgKS5cbiAgICAqL1xuICAgIGFsaWFzLCBcbiAgICAvKipcbiAgICBGaWxlIGV4dGVuc2lvbnMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbGFuZ3VhZ2UuXG4gICAgKi9cbiAgICBleHRlbnNpb25zLCBcbiAgICAvKipcbiAgICBPcHRpb25hbCBmaWxlbmFtZSBwYXR0ZXJuIHRoYXQgc2hvdWxkIGJlIGFzc29jaWF0ZWQgd2l0aCB0aGlzXG4gICAgbGFuZ3VhZ2UuXG4gICAgKi9cbiAgICBmaWxlbmFtZSwgbG9hZEZ1bmMsIFxuICAgIC8qKlxuICAgIElmIHRoZSBsYW5ndWFnZSBoYXMgYmVlbiBsb2FkZWQsIHRoaXMgd2lsbCBob2xkIGl0cyB2YWx1ZS5cbiAgICAqL1xuICAgIHN1cHBvcnQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hbGlhcyA9IGFsaWFzO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gZmlsZW5hbWU7XG4gICAgICAgIHRoaXMubG9hZEZ1bmMgPSBsb2FkRnVuYztcbiAgICAgICAgdGhpcy5zdXBwb3J0ID0gc3VwcG9ydDtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgU3RhcnQgbG9hZGluZyB0aGUgdGhlIGxhbmd1YWdlLiBXaWxsIHJldHVybiBhIHByb21pc2UgdGhhdFxuICAgIHJlc29sdmVzIHRvIGEgW2BMYW5ndWFnZVN1cHBvcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlU3VwcG9ydClcbiAgICBvYmplY3Qgd2hlbiB0aGUgbGFuZ3VhZ2Ugc3VjY2Vzc2Z1bGx5IGxvYWRzLlxuICAgICovXG4gICAgbG9hZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGluZyB8fCAodGhpcy5sb2FkaW5nID0gdGhpcy5sb2FkRnVuYygpLnRoZW4oc3VwcG9ydCA9PiB0aGlzLnN1cHBvcnQgPSBzdXBwb3J0LCBlcnIgPT4geyB0aGlzLmxvYWRpbmcgPSBudWxsOyB0aHJvdyBlcnI7IH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbGFuZ3VhZ2UgZGVzY3JpcHRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgb2Yoc3BlYykge1xuICAgICAgICBsZXQgeyBsb2FkLCBzdXBwb3J0IH0gPSBzcGVjO1xuICAgICAgICBpZiAoIWxvYWQpIHtcbiAgICAgICAgICAgIGlmICghc3VwcG9ydClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk11c3QgcGFzcyBlaXRoZXIgJ2xvYWQnIG9yICdzdXBwb3J0JyB0byBMYW5ndWFnZURlc2NyaXB0aW9uLm9mXCIpO1xuICAgICAgICAgICAgbG9hZCA9ICgpID0+IFByb21pc2UucmVzb2x2ZShzdXBwb3J0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExhbmd1YWdlRGVzY3JpcHRpb24oc3BlYy5uYW1lLCAoc3BlYy5hbGlhcyB8fCBbXSkuY29uY2F0KHNwZWMubmFtZSkubWFwKHMgPT4gcy50b0xvd2VyQ2FzZSgpKSwgc3BlYy5leHRlbnNpb25zIHx8IFtdLCBzcGVjLmZpbGVuYW1lLCBsb2FkLCBzdXBwb3J0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgTG9vayBmb3IgYSBsYW5ndWFnZSBpbiB0aGUgZ2l2ZW4gYXJyYXkgb2YgZGVzY3JpcHRpb25zIHRoYXRcbiAgICBtYXRjaGVzIHRoZSBmaWxlbmFtZS4gV2lsbCBmaXJzdCBtYXRjaFxuICAgIFtgZmlsZW5hbWVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlRGVzY3JpcHRpb24uZmlsZW5hbWUpIHBhdHRlcm5zLFxuICAgIGFuZCB0aGVuIFtleHRlbnNpb25zXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlRGVzY3JpcHRpb24uZXh0ZW5zaW9ucyksXG4gICAgYW5kIHJldHVybiB0aGUgZmlyc3QgbGFuZ3VhZ2UgdGhhdCBtYXRjaGVzLlxuICAgICovXG4gICAgc3RhdGljIG1hdGNoRmlsZW5hbWUoZGVzY3MsIGZpbGVuYW1lKSB7XG4gICAgICAgIGZvciAobGV0IGQgb2YgZGVzY3MpXG4gICAgICAgICAgICBpZiAoZC5maWxlbmFtZSAmJiBkLmZpbGVuYW1lLnRlc3QoZmlsZW5hbWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICBsZXQgZXh0ID0gL1xcLihbXi5dKykkLy5leGVjKGZpbGVuYW1lKTtcbiAgICAgICAgaWYgKGV4dClcbiAgICAgICAgICAgIGZvciAobGV0IGQgb2YgZGVzY3MpXG4gICAgICAgICAgICAgICAgaWYgKGQuZXh0ZW5zaW9ucy5pbmRleE9mKGV4dFsxXSkgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBMb29rIGZvciBhIGxhbmd1YWdlIHdob3NlIG5hbWUgb3IgYWxpYXMgbWF0Y2hlcyB0aGUgdGhlIGdpdmVuXG4gICAgbmFtZSAoY2FzZS1pbnNlbnNpdGl2ZWx5KS4gSWYgYGZ1enp5YCBpcyB0cnVlLCBhbmQgbm8gZGlyZWN0XG4gICAgbWF0Y2hzIGlzIGZvdW5kLCB0aGlzJ2xsIGFsc28gc2VhcmNoIGZvciBhIGxhbmd1YWdlIHdob3NlIG5hbWVcbiAgICBvciBhbGlhcyBvY2N1cnMgaW4gdGhlIHN0cmluZyAoZm9yIG5hbWVzIHNob3J0ZXIgdGhhbiB0aHJlZVxuICAgIGNoYXJhY3RlcnMsIG9ubHkgd2hlbiBzdXJyb3VuZGVkIGJ5IG5vbi13b3JkIGNoYXJhY3RlcnMpLlxuICAgICovXG4gICAgc3RhdGljIG1hdGNoTGFuZ3VhZ2VOYW1lKGRlc2NzLCBuYW1lLCBmdXp6eSA9IHRydWUpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgZm9yIChsZXQgZCBvZiBkZXNjcylcbiAgICAgICAgICAgIGlmIChkLmFsaWFzLnNvbWUoYSA9PiBhID09IG5hbWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICBpZiAoZnV6enkpXG4gICAgICAgICAgICBmb3IgKGxldCBkIG9mIGRlc2NzKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGEgb2YgZC5hbGlhcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBuYW1lLmluZGV4T2YoYSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZCA+IC0xICYmIChhLmxlbmd0aCA+IDIgfHwgIS9cXHcvLnRlc3QobmFtZVtmb3VuZCAtIDFdKSAmJiAhL1xcdy8udGVzdChuYW1lW2ZvdW5kICsgYS5sZW5ndGhdKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuLyoqXG5GYWNldCB0aGF0IGRlZmluZXMgYSB3YXkgdG8gcHJvdmlkZSBhIGZ1bmN0aW9uIHRoYXQgY29tcHV0ZXMgdGhlXG5hcHByb3ByaWF0ZSBpbmRlbnRhdGlvbiBkZXB0aCwgYXMgYSBjb2x1bW4gbnVtYmVyIChzZWVcbltgaW5kZW50U3RyaW5nYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRTdHJpbmcpKSwgYXQgdGhlIHN0YXJ0IG9mIGEgZ2l2ZW5cbmxpbmUuIEEgcmV0dXJuIHZhbHVlIG9mIGBudWxsYCBpbmRpY2F0ZXMgbm8gaW5kZW50YXRpb24gY2FuIGJlXG5kZXRlcm1pbmVkLCBhbmQgdGhlIGxpbmUgc2hvdWxkIGluaGVyaXQgdGhlIGluZGVudGF0aW9uIG9mIHRoZSBvbmVcbmFib3ZlIGl0LiBBIHJldHVybiB2YWx1ZSBvZiBgdW5kZWZpbmVkYCBkZWZlcnMgdG8gdGhlIG5leHQgaW5kZW50XG5zZXJ2aWNlLlxuKi9cbmNvbnN0IGluZGVudFNlcnZpY2UgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcbkZhY2V0IGZvciBvdmVycmlkaW5nIHRoZSB1bml0IGJ5IHdoaWNoIGluZGVudGF0aW9uIGhhcHBlbnMuIFNob3VsZFxuYmUgYSBzdHJpbmcgY29uc2lzdGluZyBlaXRoZXIgZW50aXJlbHkgb2YgdGhlIHNhbWUgd2hpdGVzcGFjZVxuY2hhcmFjdGVyLiBXaGVuIG5vdCBzZXQsIHRoaXMgZGVmYXVsdHMgdG8gMiBzcGFjZXMuXG4qL1xuY29uc3QgaW5kZW50VW5pdCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB7XG4gICAgICAgIGlmICghdmFsdWVzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBcIiAgXCI7XG4gICAgICAgIGxldCB1bml0ID0gdmFsdWVzWzBdO1xuICAgICAgICBpZiAoIXVuaXQgfHwgL1xcUy8udGVzdCh1bml0KSB8fCBBcnJheS5mcm9tKHVuaXQpLnNvbWUoZSA9PiBlICE9IHVuaXRbMF0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbmRlbnQgdW5pdDogXCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZXNbMF0pKTtcbiAgICAgICAgcmV0dXJuIHVuaXQ7XG4gICAgfVxufSk7XG4vKipcblJldHVybiB0aGUgX2NvbHVtbiB3aWR0aF8gb2YgYW4gaW5kZW50IHVuaXQgaW4gdGhlIHN0YXRlLlxuRGV0ZXJtaW5lZCBieSB0aGUgW2BpbmRlbnRVbml0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRVbml0KVxuZmFjZXQsIGFuZCBbYHRhYlNpemVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRhYlNpemUpIHdoZW4gdGhhdFxuY29udGFpbnMgdGFicy5cbiovXG5mdW5jdGlvbiBnZXRJbmRlbnRVbml0KHN0YXRlKSB7XG4gICAgbGV0IHVuaXQgPSBzdGF0ZS5mYWNldChpbmRlbnRVbml0KTtcbiAgICByZXR1cm4gdW5pdC5jaGFyQ29kZUF0KDApID09IDkgPyBzdGF0ZS50YWJTaXplICogdW5pdC5sZW5ndGggOiB1bml0Lmxlbmd0aDtcbn1cbi8qKlxuQ3JlYXRlIGFuIGluZGVudGF0aW9uIHN0cmluZyB0aGF0IGNvdmVycyBjb2x1bW5zIDAgdG8gYGNvbHNgLlxuV2lsbCB1c2UgdGFicyBmb3IgYXMgbXVjaCBvZiB0aGUgY29sdW1ucyBhcyBwb3NzaWJsZSB3aGVuIHRoZVxuW2BpbmRlbnRVbml0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRVbml0KSBmYWNldCBjb250YWluc1xudGFicy5cbiovXG5mdW5jdGlvbiBpbmRlbnRTdHJpbmcoc3RhdGUsIGNvbHMpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIiwgdHMgPSBzdGF0ZS50YWJTaXplLCBjaCA9IHN0YXRlLmZhY2V0KGluZGVudFVuaXQpWzBdO1xuICAgIGlmIChjaCA9PSBcIlxcdFwiKSB7XG4gICAgICAgIHdoaWxlIChjb2xzID49IHRzKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJcXHRcIjtcbiAgICAgICAgICAgIGNvbHMgLT0gdHM7XG4gICAgICAgIH1cbiAgICAgICAgY2ggPSBcIiBcIjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xzOyBpKyspXG4gICAgICAgIHJlc3VsdCArPSBjaDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5HZXQgdGhlIGluZGVudGF0aW9uLCBhcyBhIGNvbHVtbiBudW1iZXIsIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbldpbGwgZmlyc3QgY29uc3VsdCBhbnkgW2luZGVudCBzZXJ2aWNlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRTZXJ2aWNlKVxudGhhdCBhcmUgcmVnaXN0ZXJlZCwgYW5kIGlmIG5vbmUgb2YgdGhvc2UgcmV0dXJuIGFuIGluZGVudGF0aW9uLFxudGhpcyB3aWxsIGNoZWNrIHRoZSBzeW50YXggdHJlZSBmb3IgdGhlIFtpbmRlbnQgbm9kZVxucHJvcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnROb2RlUHJvcCkgYW5kIHVzZSB0aGF0IGlmIGZvdW5kLiBSZXR1cm5zIGFcbm51bWJlciB3aGVuIGFuIGluZGVudGF0aW9uIGNvdWxkIGJlIGRldGVybWluZWQsIGFuZCBudWxsXG5vdGhlcndpc2UuXG4qL1xuZnVuY3Rpb24gZ2V0SW5kZW50YXRpb24oY29udGV4dCwgcG9zKSB7XG4gICAgaWYgKGNvbnRleHQgaW5zdGFuY2VvZiBFZGl0b3JTdGF0ZSlcbiAgICAgICAgY29udGV4dCA9IG5ldyBJbmRlbnRDb250ZXh0KGNvbnRleHQpO1xuICAgIGZvciAobGV0IHNlcnZpY2Ugb2YgY29udGV4dC5zdGF0ZS5mYWNldChpbmRlbnRTZXJ2aWNlKSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gc2VydmljZShjb250ZXh0LCBwb3MpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoY29udGV4dC5zdGF0ZSk7XG4gICAgcmV0dXJuIHRyZWUubGVuZ3RoID49IHBvcyA/IHN5bnRheEluZGVudGF0aW9uKGNvbnRleHQsIHRyZWUsIHBvcykgOiBudWxsO1xufVxuLyoqXG5DcmVhdGUgYSBjaGFuZ2Ugc2V0IHRoYXQgYXV0by1pbmRlbnRzIGFsbCBsaW5lcyB0b3VjaGVkIGJ5IHRoZVxuZ2l2ZW4gZG9jdW1lbnQgcmFuZ2UuXG4qL1xuZnVuY3Rpb24gaW5kZW50UmFuZ2Uoc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgbGV0IHVwZGF0ZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBjb250ZXh0ID0gbmV3IEluZGVudENvbnRleHQoc3RhdGUsIHsgb3ZlcnJpZGVJbmRlbnRhdGlvbjogc3RhcnQgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSB1cGRhdGVkW3N0YXJ0XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogLTE7IH0gfSk7XG4gICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCBwb3MgPSBmcm9tOyBwb3MgPD0gdG87KSB7XG4gICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICBwb3MgPSBsaW5lLnRvICsgMTtcbiAgICAgICAgbGV0IGluZGVudCA9IGdldEluZGVudGF0aW9uKGNvbnRleHQsIGxpbmUuZnJvbSk7XG4gICAgICAgIGlmIChpbmRlbnQgPT0gbnVsbClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIS9cXFMvLnRlc3QobGluZS50ZXh0KSlcbiAgICAgICAgICAgIGluZGVudCA9IDA7XG4gICAgICAgIGxldCBjdXIgPSAvXlxccyovLmV4ZWMobGluZS50ZXh0KVswXTtcbiAgICAgICAgbGV0IG5vcm0gPSBpbmRlbnRTdHJpbmcoc3RhdGUsIGluZGVudCk7XG4gICAgICAgIGlmIChjdXIgIT0gbm9ybSkge1xuICAgICAgICAgICAgdXBkYXRlZFtsaW5lLmZyb21dID0gaW5kZW50O1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tLCB0bzogbGluZS5mcm9tICsgY3VyLmxlbmd0aCwgaW5zZXJ0OiBub3JtIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5jaGFuZ2VzKGNoYW5nZXMpO1xufVxuLyoqXG5JbmRlbnRhdGlvbiBjb250ZXh0cyBhcmUgdXNlZCB3aGVuIGNhbGxpbmcgW2luZGVudGF0aW9uXG5zZXJ2aWNlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRTZXJ2aWNlKS4gVGhleSBwcm92aWRlIGhlbHBlciB1dGlsaXRpZXNcbnVzZWZ1bCBpbiBpbmRlbnRhdGlvbiBsb2dpYywgYW5kIGNhbiBzZWxlY3RpdmVseSBvdmVycmlkZSB0aGVcbmluZGVudGF0aW9uIHJlcG9ydGVkIGZvciBzb21lIGxpbmVzLlxuKi9cbmNsYXNzIEluZGVudENvbnRleHQge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbmRlbnQgY29udGV4dC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBlZGl0b3Igc3RhdGUuXG4gICAgKi9cbiAgICBzdGF0ZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnVuaXQgPSBnZXRJbmRlbnRVbml0KHN0YXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgZGVzY3JpcHRpb24gb2YgdGhlIGxpbmUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLCB0YWtpbmdcbiAgICBbc2ltdWxhdGVkIGxpbmVcbiAgICBicmVha3NdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuSW5kZW50Q29udGV4dC5jb25zdHJ1Y3Rvcl5vcHRpb25zLnNpbXVsYXRlQnJlYWspXG4gICAgaW50byBhY2NvdW50LiBJZiB0aGVyZSBpcyBzdWNoIGEgYnJlYWsgYXQgYHBvc2AsIHRoZSBgYmlhc2BcbiAgICBhcmd1bWVudCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBhcnQgb2YgdGhlIGxpbmUgbGluZSBiZWZvcmUgb3JcbiAgICBhZnRlciB0aGUgYnJlYWsgaXMgdXNlZC5cbiAgICAqL1xuICAgIGxpbmVBdChwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5zdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgIGxldCB7IHNpbXVsYXRlQnJlYWssIHNpbXVsYXRlRG91YmxlQnJlYWsgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKHNpbXVsYXRlQnJlYWsgIT0gbnVsbCAmJiBzaW11bGF0ZUJyZWFrID49IGxpbmUuZnJvbSAmJiBzaW11bGF0ZUJyZWFrIDw9IGxpbmUudG8pIHtcbiAgICAgICAgICAgIGlmIChzaW11bGF0ZURvdWJsZUJyZWFrICYmIHNpbXVsYXRlQnJlYWsgPT0gcG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHRleHQ6IFwiXCIsIGZyb206IHBvcyB9O1xuICAgICAgICAgICAgZWxzZSBpZiAoYmlhcyA8IDAgPyBzaW11bGF0ZUJyZWFrIDwgcG9zIDogc2ltdWxhdGVCcmVhayA8PSBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdGV4dDogbGluZS50ZXh0LnNsaWNlKHNpbXVsYXRlQnJlYWsgLSBsaW5lLmZyb20pLCBmcm9tOiBzaW11bGF0ZUJyZWFrIH07XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdGV4dDogbGluZS50ZXh0LnNsaWNlKDAsIHNpbXVsYXRlQnJlYWsgLSBsaW5lLmZyb20pLCBmcm9tOiBsaW5lLmZyb20gfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB0ZXh0IGRpcmVjdGx5IGFmdGVyIGBwb3NgLCBlaXRoZXIgdGhlIGVudGlyZSBsaW5lXG4gICAgb3IgdGhlIG5leHQgMTAwIGNoYXJhY3RlcnMsIHdoaWNoZXZlciBpcyBzaG9ydGVyLlxuICAgICovXG4gICAgdGV4dEFmdGVyUG9zKHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaW11bGF0ZURvdWJsZUJyZWFrICYmIHBvcyA9PSB0aGlzLm9wdGlvbnMuc2ltdWxhdGVCcmVhaylcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICBsZXQgeyB0ZXh0LCBmcm9tIH0gPSB0aGlzLmxpbmVBdChwb3MsIGJpYXMpO1xuICAgICAgICByZXR1cm4gdGV4dC5zbGljZShwb3MgLSBmcm9tLCBNYXRoLm1pbih0ZXh0Lmxlbmd0aCwgcG9zICsgMTAwIC0gZnJvbSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBjb2x1bW4gZm9yIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGNvbHVtbihwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIGxldCB7IHRleHQsIGZyb20gfSA9IHRoaXMubGluZUF0KHBvcywgYmlhcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmNvdW50Q29sdW1uKHRleHQsIHBvcyAtIGZyb20pO1xuICAgICAgICBsZXQgb3ZlcnJpZGUgPSB0aGlzLm9wdGlvbnMub3ZlcnJpZGVJbmRlbnRhdGlvbiA/IHRoaXMub3B0aW9ucy5vdmVycmlkZUluZGVudGF0aW9uKGZyb20pIDogLTE7XG4gICAgICAgIGlmIChvdmVycmlkZSA+IC0xKVxuICAgICAgICAgICAgcmVzdWx0ICs9IG92ZXJyaWRlIC0gdGhpcy5jb3VudENvbHVtbih0ZXh0LCB0ZXh0LnNlYXJjaCgvXFxTfCQvKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGNvbHVtbiBwb3NpdGlvbiAodGFraW5nIHRhYnMgaW50byBhY2NvdW50KSBvZiB0aGUgZ2l2ZW5cbiAgICBwb3NpdGlvbiBpbiB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgICovXG4gICAgY291bnRDb2x1bW4obGluZSwgcG9zID0gbGluZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNvdW50Q29sdW1uKGxpbmUsIHRoaXMuc3RhdGUudGFiU2l6ZSwgcG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgaW5kZW50YXRpb24gY29sdW1uIG9mIHRoZSBsaW5lIGF0IHRoZSBnaXZlbiBwb2ludC5cbiAgICAqL1xuICAgIGxpbmVJbmRlbnQocG9zLCBiaWFzID0gMSkge1xuICAgICAgICBsZXQgeyB0ZXh0LCBmcm9tIH0gPSB0aGlzLmxpbmVBdChwb3MsIGJpYXMpO1xuICAgICAgICBsZXQgb3ZlcnJpZGUgPSB0aGlzLm9wdGlvbnMub3ZlcnJpZGVJbmRlbnRhdGlvbjtcbiAgICAgICAgaWYgKG92ZXJyaWRlKSB7XG4gICAgICAgICAgICBsZXQgb3ZlcnJpZGVuID0gb3ZlcnJpZGUoZnJvbSk7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGVuID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG92ZXJyaWRlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb3VudENvbHVtbih0ZXh0LCB0ZXh0LnNlYXJjaCgvXFxTfCQvKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdGhlIFtzaW11bGF0ZWQgbGluZVxuICAgIGJyZWFrXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkluZGVudENvbnRleHQuY29uc3RydWN0b3Jeb3B0aW9ucy5zaW11bGF0ZUJyZWFrKVxuICAgIGZvciB0aGlzIGNvbnRleHQsIGlmIGFueS5cbiAgICAqL1xuICAgIGdldCBzaW11bGF0ZWRCcmVhaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zaW11bGF0ZUJyZWFrIHx8IG51bGw7XG4gICAgfVxufVxuLyoqXG5BIHN5bnRheCB0cmVlIG5vZGUgcHJvcCB1c2VkIHRvIGFzc29jaWF0ZSBpbmRlbnRhdGlvbiBzdHJhdGVnaWVzXG53aXRoIG5vZGUgdHlwZXMuIFN1Y2ggYSBzdHJhdGVneSBpcyBhIGZ1bmN0aW9uIGZyb20gYW4gaW5kZW50YXRpb25cbmNvbnRleHQgdG8gYSBjb2x1bW4gbnVtYmVyIChzZWUgYWxzb1xuW2BpbmRlbnRTdHJpbmdgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFN0cmluZykpIG9yIG51bGwsIHdoZXJlIG51bGxcbmluZGljYXRlcyB0aGF0IG5vIGRlZmluaXRpdmUgaW5kZW50YXRpb24gY2FuIGJlIGRldGVybWluZWQuXG4qL1xuY29uc3QgaW5kZW50Tm9kZVByb3AgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVQcm9wKCk7XG4vLyBDb21wdXRlIHRoZSBpbmRlbnRhdGlvbiBmb3IgYSBnaXZlbiBwb3NpdGlvbiBmcm9tIHRoZSBzeW50YXggdHJlZS5cbmZ1bmN0aW9uIHN5bnRheEluZGVudGF0aW9uKGN4LCBhc3QsIHBvcykge1xuICAgIGxldCBzdGFjayA9IGFzdC5yZXNvbHZlU3RhY2socG9zKTtcbiAgICBsZXQgaW5uZXIgPSBzdGFjay5ub2RlLmVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlKHBvcyk7XG4gICAgaWYgKGlubmVyICE9IHN0YWNrLm5vZGUpIHtcbiAgICAgICAgbGV0IGFkZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBjdXIgPSBpbm5lcjsgY3VyICE9IHN0YWNrLm5vZGU7IGN1ciA9IGN1ci5wYXJlbnQpXG4gICAgICAgICAgICBhZGQucHVzaChjdXIpO1xuICAgICAgICBmb3IgKGxldCBpID0gYWRkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgc3RhY2sgPSB7IG5vZGU6IGFkZFtpXSwgbmV4dDogc3RhY2sgfTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGVudEZvcihzdGFjaywgY3gsIHBvcyk7XG59XG5mdW5jdGlvbiBpbmRlbnRGb3Ioc3RhY2ssIGN4LCBwb3MpIHtcbiAgICBmb3IgKGxldCBjdXIgPSBzdGFjazsgY3VyOyBjdXIgPSBjdXIubmV4dCkge1xuICAgICAgICBsZXQgc3RyYXRlZ3kgPSBpbmRlbnRTdHJhdGVneShjdXIubm9kZSk7XG4gICAgICAgIGlmIChzdHJhdGVneSlcbiAgICAgICAgICAgIHJldHVybiBzdHJhdGVneShUcmVlSW5kZW50Q29udGV4dC5jcmVhdGUoY3gsIHBvcywgY3VyKSk7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gaWdub3JlQ2xvc2VkKGN4KSB7XG4gICAgcmV0dXJuIGN4LnBvcyA9PSBjeC5vcHRpb25zLnNpbXVsYXRlQnJlYWsgJiYgY3gub3B0aW9ucy5zaW11bGF0ZURvdWJsZUJyZWFrO1xufVxuZnVuY3Rpb24gaW5kZW50U3RyYXRlZ3kodHJlZSkge1xuICAgIGxldCBzdHJhdGVneSA9IHRyZWUudHlwZS5wcm9wKGluZGVudE5vZGVQcm9wKTtcbiAgICBpZiAoc3RyYXRlZ3kpXG4gICAgICAgIHJldHVybiBzdHJhdGVneTtcbiAgICBsZXQgZmlyc3QgPSB0cmVlLmZpcnN0Q2hpbGQsIGNsb3NlO1xuICAgIGlmIChmaXJzdCAmJiAoY2xvc2UgPSBmaXJzdC50eXBlLnByb3AoTm9kZVByb3AuY2xvc2VkQnkpKSkge1xuICAgICAgICBsZXQgbGFzdCA9IHRyZWUubGFzdENoaWxkLCBjbG9zZWQgPSBsYXN0ICYmIGNsb3NlLmluZGV4T2YobGFzdC5uYW1lKSA+IC0xO1xuICAgICAgICByZXR1cm4gY3ggPT4gZGVsaW1pdGVkU3RyYXRlZ3koY3gsIHRydWUsIDEsIHVuZGVmaW5lZCwgY2xvc2VkICYmICFpZ25vcmVDbG9zZWQoY3gpID8gbGFzdC5mcm9tIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyZWUucGFyZW50ID09IG51bGwgPyB0b3BJbmRlbnQgOiBudWxsO1xufVxuZnVuY3Rpb24gdG9wSW5kZW50KCkgeyByZXR1cm4gMDsgfVxuLyoqXG5PYmplY3RzIG9mIHRoaXMgdHlwZSBwcm92aWRlIGNvbnRleHQgaW5mb3JtYXRpb24gYW5kIGhlbHBlclxubWV0aG9kcyB0byBpbmRlbnRhdGlvbiBmdW5jdGlvbnMgcmVnaXN0ZXJlZCBvbiBzeW50YXggbm9kZXMuXG4qL1xuY2xhc3MgVHJlZUluZGVudENvbnRleHQgZXh0ZW5kcyBJbmRlbnRDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlLCBcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gYXQgd2hpY2ggaW5kZW50YXRpb24gaXMgYmVpbmcgY29tcHV0ZWQuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29udGV4dCkge1xuICAgICAgICBzdXBlcihiYXNlLnN0YXRlLCBiYXNlLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHN5bnRheCB0cmVlIG5vZGUgdG8gd2hpY2ggdGhlIGluZGVudGF0aW9uIHN0cmF0ZWd5XG4gICAgYXBwbGllcy5cbiAgICAqL1xuICAgIGdldCBub2RlKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0Lm5vZGU7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoYmFzZSwgcG9zLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUluZGVudENvbnRleHQoYmFzZSwgcG9zLCBjb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB0ZXh0IGRpcmVjdGx5IGFmdGVyIGB0aGlzLnBvc2AsIGVpdGhlciB0aGUgZW50aXJlIGxpbmVcbiAgICBvciB0aGUgbmV4dCAxMDAgY2hhcmFjdGVycywgd2hpY2hldmVyIGlzIHNob3J0ZXIuXG4gICAgKi9cbiAgICBnZXQgdGV4dEFmdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0QWZ0ZXJQb3ModGhpcy5wb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGluZGVudGF0aW9uIGF0IHRoZSByZWZlcmVuY2UgbGluZSBmb3IgYHRoaXMubm9kZWAsIHdoaWNoXG4gICAgaXMgdGhlIGxpbmUgb24gd2hpY2ggaXQgc3RhcnRzLCB1bmxlc3MgdGhlcmUgaXMgYSBub2RlIHRoYXQgaXNcbiAgICBfbm90XyBhIHBhcmVudCBvZiB0aGlzIG5vZGUgY292ZXJpbmcgdGhlIHN0YXJ0IG9mIHRoYXQgbGluZS4gSWZcbiAgICBzbywgdGhlIGxpbmUgYXQgdGhlIHN0YXJ0IG9mIHRoYXQgbm9kZSBpcyB0cmllZCwgYWdhaW4gc2tpcHBpbmdcbiAgICBvbiBpZiBpdCBpcyBjb3ZlcmVkIGJ5IGFub3RoZXIgc3VjaCBub2RlLlxuICAgICovXG4gICAgZ2V0IGJhc2VJbmRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VJbmRlbnRGb3IodGhpcy5ub2RlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBpbmRlbnRhdGlvbiBmb3IgdGhlIHJlZmVyZW5jZSBsaW5lIG9mIHRoZSBnaXZlbiBub2RlXG4gICAgKHNlZSBbYGJhc2VJbmRlbnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLlRyZWVJbmRlbnRDb250ZXh0LmJhc2VJbmRlbnQpKS5cbiAgICAqL1xuICAgIGJhc2VJbmRlbnRGb3Iobm9kZSkge1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdChub2RlLmZyb20pO1xuICAgICAgICAvLyBTa2lwIGxpbmUgc3RhcnRzIHRoYXQgYXJlIGNvdmVyZWQgYnkgYSBzaWJsaW5nIChvciBjb3VzaW4sIGV0YylcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGF0QnJlYWsgPSBub2RlLnJlc29sdmUobGluZS5mcm9tKTtcbiAgICAgICAgICAgIHdoaWxlIChhdEJyZWFrLnBhcmVudCAmJiBhdEJyZWFrLnBhcmVudC5mcm9tID09IGF0QnJlYWsuZnJvbSlcbiAgICAgICAgICAgICAgICBhdEJyZWFrID0gYXRCcmVhay5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoaXNQYXJlbnQoYXRCcmVhaywgbm9kZSkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsaW5lID0gdGhpcy5zdGF0ZS5kb2MubGluZUF0KGF0QnJlYWsuZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUluZGVudChsaW5lLmZyb20pO1xuICAgIH1cbiAgICAvKipcbiAgICBDb250aW51ZSBsb29raW5nIGZvciBpbmRlbnRhdGlvbnMgaW4gdGhlIG5vZGUncyBwYXJlbnQgbm9kZXMsXG4gICAgYW5kIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoYXQuXG4gICAgKi9cbiAgICBjb250aW51ZSgpIHtcbiAgICAgICAgcmV0dXJuIGluZGVudEZvcih0aGlzLmNvbnRleHQubmV4dCwgdGhpcy5iYXNlLCB0aGlzLnBvcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNQYXJlbnQocGFyZW50LCBvZikge1xuICAgIGZvciAobGV0IGN1ciA9IG9mOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnQpXG4gICAgICAgIGlmIChwYXJlbnQgPT0gY3VyKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gQ2hlY2sgd2hldGhlciBhIGRlbGltaXRlZCBub2RlIGlzIGFsaWduZWQgKG1lYW5pbmcgdGhlcmUgYXJlXG4vLyBub24tc2tpcHBlZCBub2RlcyBvbiB0aGUgc2FtZSBsaW5lIGFzIHRoZSBvcGVuaW5nIGRlbGltaXRlcikuIEFuZFxuLy8gaWYgc28sIHJldHVybiB0aGUgb3BlbmluZyB0b2tlbi5cbmZ1bmN0aW9uIGJyYWNrZXRlZEFsaWduZWQoY29udGV4dCkge1xuICAgIGxldCB0cmVlID0gY29udGV4dC5ub2RlO1xuICAgIGxldCBvcGVuVG9rZW4gPSB0cmVlLmNoaWxkQWZ0ZXIodHJlZS5mcm9tKSwgbGFzdCA9IHRyZWUubGFzdENoaWxkO1xuICAgIGlmICghb3BlblRva2VuKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgc2ltID0gY29udGV4dC5vcHRpb25zLnNpbXVsYXRlQnJlYWs7XG4gICAgbGV0IG9wZW5MaW5lID0gY29udGV4dC5zdGF0ZS5kb2MubGluZUF0KG9wZW5Ub2tlbi5mcm9tKTtcbiAgICBsZXQgbGluZUVuZCA9IHNpbSA9PSBudWxsIHx8IHNpbSA8PSBvcGVuTGluZS5mcm9tID8gb3BlbkxpbmUudG8gOiBNYXRoLm1pbihvcGVuTGluZS50bywgc2ltKTtcbiAgICBmb3IgKGxldCBwb3MgPSBvcGVuVG9rZW4udG87Oykge1xuICAgICAgICBsZXQgbmV4dCA9IHRyZWUuY2hpbGRBZnRlcihwb3MpO1xuICAgICAgICBpZiAoIW5leHQgfHwgbmV4dCA9PSBsYXN0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghbmV4dC50eXBlLmlzU2tpcHBlZClcbiAgICAgICAgICAgIHJldHVybiBuZXh0LmZyb20gPCBsaW5lRW5kID8gb3BlblRva2VuIDogbnVsbDtcbiAgICAgICAgcG9zID0gbmV4dC50bztcbiAgICB9XG59XG4vKipcbkFuIGluZGVudGF0aW9uIHN0cmF0ZWd5IGZvciBkZWxpbWl0ZWQgKHVzdWFsbHkgYnJhY2tldGVkKSBub2Rlcy5cbldpbGwsIGJ5IGRlZmF1bHQsIGluZGVudCBvbmUgdW5pdCBtb3JlIHRoYW4gdGhlIHBhcmVudCdzIGJhc2VcbmluZGVudCB1bmxlc3MgdGhlIGxpbmUgc3RhcnRzIHdpdGggYSBjbG9zaW5nIHRva2VuLiBXaGVuIGBhbGlnbmBcbmlzIHRydWUgYW5kIHRoZXJlIGFyZSBub24tc2tpcHBlZCBub2RlcyBvbiB0aGUgbm9kZSdzIG9wZW5pbmdcbmxpbmUsIHRoZSBjb250ZW50IG9mIHRoZSBub2RlIHdpbGwgYmUgYWxpZ25lZCB3aXRoIHRoZSBlbmQgb2YgdGhlXG5vcGVuaW5nIG5vZGUsIGxpa2UgdGhpczpcblxuICAgIGZvbyhiYXIsXG4gICAgICAgIGJheilcbiovXG5mdW5jdGlvbiBkZWxpbWl0ZWRJbmRlbnQoeyBjbG9zaW5nLCBhbGlnbiA9IHRydWUsIHVuaXRzID0gMSB9KSB7XG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiBkZWxpbWl0ZWRTdHJhdGVneShjb250ZXh0LCBhbGlnbiwgdW5pdHMsIGNsb3NpbmcpO1xufVxuZnVuY3Rpb24gZGVsaW1pdGVkU3RyYXRlZ3koY29udGV4dCwgYWxpZ24sIHVuaXRzLCBjbG9zaW5nLCBjbG9zZWRBdCkge1xuICAgIGxldCBhZnRlciA9IGNvbnRleHQudGV4dEFmdGVyLCBzcGFjZSA9IGFmdGVyLm1hdGNoKC9eXFxzKi8pWzBdLmxlbmd0aDtcbiAgICBsZXQgY2xvc2VkID0gY2xvc2luZyAmJiBhZnRlci5zbGljZShzcGFjZSwgc3BhY2UgKyBjbG9zaW5nLmxlbmd0aCkgPT0gY2xvc2luZyB8fCBjbG9zZWRBdCA9PSBjb250ZXh0LnBvcyArIHNwYWNlO1xuICAgIGxldCBhbGlnbmVkID0gYWxpZ24gPyBicmFja2V0ZWRBbGlnbmVkKGNvbnRleHQpIDogbnVsbDtcbiAgICBpZiAoYWxpZ25lZClcbiAgICAgICAgcmV0dXJuIGNsb3NlZCA/IGNvbnRleHQuY29sdW1uKGFsaWduZWQuZnJvbSkgOiBjb250ZXh0LmNvbHVtbihhbGlnbmVkLnRvKTtcbiAgICByZXR1cm4gY29udGV4dC5iYXNlSW5kZW50ICsgKGNsb3NlZCA/IDAgOiBjb250ZXh0LnVuaXQgKiB1bml0cyk7XG59XG4vKipcbkFuIGluZGVudGF0aW9uIHN0cmF0ZWd5IHRoYXQgYWxpZ25zIGEgbm9kZSdzIGNvbnRlbnQgdG8gaXRzIGJhc2VcbmluZGVudGF0aW9uLlxuKi9cbmNvbnN0IGZsYXRJbmRlbnQgPSAoY29udGV4dCkgPT4gY29udGV4dC5iYXNlSW5kZW50O1xuLyoqXG5DcmVhdGVzIGFuIGluZGVudGF0aW9uIHN0cmF0ZWd5IHRoYXQsIGJ5IGRlZmF1bHQsIGluZGVudHNcbmNvbnRpbnVlZCBsaW5lcyBvbmUgdW5pdCBtb3JlIHRoYW4gdGhlIG5vZGUncyBiYXNlIGluZGVudGF0aW9uLlxuWW91IGNhbiBwcm92aWRlIGBleGNlcHRgIHRvIHByZXZlbnQgaW5kZW50YXRpb24gb2YgbGluZXMgdGhhdFxubWF0Y2ggYSBwYXR0ZXJuIChmb3IgZXhhbXBsZSBgL15lbHNlXFxiL2AgaW4gYGlmYC9gZWxzZWBcbmNvbnN0cnVjdHMpLCBhbmQgeW91IGNhbiBjaGFuZ2UgdGhlIGFtb3VudCBvZiB1bml0cyB1c2VkIHdpdGggdGhlXG5gdW5pdHNgIG9wdGlvbi5cbiovXG5mdW5jdGlvbiBjb250aW51ZWRJbmRlbnQoeyBleGNlcHQsIHVuaXRzID0gMSB9ID0ge30pIHtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgbGV0IG1hdGNoRXhjZXB0ID0gZXhjZXB0ICYmIGV4Y2VwdC50ZXN0KGNvbnRleHQudGV4dEFmdGVyKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuYmFzZUluZGVudCArIChtYXRjaEV4Y2VwdCA/IDAgOiB1bml0cyAqIGNvbnRleHQudW5pdCk7XG4gICAgfTtcbn1cbmNvbnN0IERvbnRJbmRlbnRCZXlvbmQgPSAyMDA7XG4vKipcbkVuYWJsZXMgcmVpbmRlbnRhdGlvbiBvbiBpbnB1dC4gV2hlbiBhIGxhbmd1YWdlIGRlZmluZXMgYW5cbmBpbmRlbnRPbklucHV0YCBmaWVsZCBpbiBpdHMgW2xhbmd1YWdlXG5kYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KSwgd2hpY2ggbXVzdCBob2xkIGEgcmVndWxhclxuZXhwcmVzc2lvbiwgdGhlIGxpbmUgYXQgdGhlIGN1cnNvciB3aWxsIGJlIHJlaW5kZW50ZWQgd2hlbmV2ZXIgbmV3XG50ZXh0IGlzIHR5cGVkIGFuZCB0aGUgaW5wdXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGxpbmUgdXAgdG8gdGhlXG5jdXJzb3IgbWF0Y2hlcyB0aGF0IHJlZ2V4cC5cblxuVG8gYXZvaWQgdW5uZWNjZXNhcnkgcmVpbmRlbnRzLCBpdCBpcyByZWNvbW1lbmRlZCB0byBzdGFydCB0aGVcbnJlZ2V4cCB3aXRoIGBeYCAodXN1YWxseSBmb2xsb3dlZCBieSBgXFxzKmApLCBhbmQgZW5kIGl0IHdpdGggYCRgLlxuRm9yIGV4YW1wbGUsIGAvXlxccypcXH0kL2Agd2lsbCByZWluZGVudCB3aGVuIGEgY2xvc2luZyBicmFjZSBpc1xuYWRkZWQgYXQgdGhlIHN0YXJ0IG9mIGEgbGluZS5cbiovXG5mdW5jdGlvbiBpbmRlbnRPbklucHV0KCkge1xuICAgIHJldHVybiBFZGl0b3JTdGF0ZS50cmFuc2FjdGlvbkZpbHRlci5vZih0ciA9PiB7XG4gICAgICAgIGlmICghdHIuZG9jQ2hhbmdlZCB8fCAhdHIuaXNVc2VyRXZlbnQoXCJpbnB1dC50eXBlXCIpICYmICF0ci5pc1VzZXJFdmVudChcImlucHV0LmNvbXBsZXRlXCIpKVxuICAgICAgICAgICAgcmV0dXJuIHRyO1xuICAgICAgICBsZXQgcnVsZXMgPSB0ci5zdGFydFN0YXRlLmxhbmd1YWdlRGF0YUF0KFwiaW5kZW50T25JbnB1dFwiLCB0ci5zdGFydFN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgICAgICBpZiAoIXJ1bGVzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgbGV0IGRvYyA9IHRyLm5ld0RvYywgeyBoZWFkIH0gPSB0ci5uZXdTZWxlY3Rpb24ubWFpbiwgbGluZSA9IGRvYy5saW5lQXQoaGVhZCk7XG4gICAgICAgIGlmIChoZWFkID4gbGluZS5mcm9tICsgRG9udEluZGVudEJleW9uZClcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgbGV0IGxpbmVTdGFydCA9IGRvYy5zbGljZVN0cmluZyhsaW5lLmZyb20sIGhlYWQpO1xuICAgICAgICBpZiAoIXJ1bGVzLnNvbWUociA9PiByLnRlc3QobGluZVN0YXJ0KSkpXG4gICAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0ciwgbGFzdCA9IC0xLCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHsgaGVhZCB9IG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChoZWFkKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmZyb20gPT0gbGFzdClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxhc3QgPSBsaW5lLmZyb207XG4gICAgICAgICAgICBsZXQgaW5kZW50ID0gZ2V0SW5kZW50YXRpb24oc3RhdGUsIGxpbmUuZnJvbSk7XG4gICAgICAgICAgICBpZiAoaW5kZW50ID09IG51bGwpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgY3VyID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF07XG4gICAgICAgICAgICBsZXQgbm9ybSA9IGluZGVudFN0cmluZyhzdGF0ZSwgaW5kZW50KTtcbiAgICAgICAgICAgIGlmIChjdXIgIT0gbm9ybSlcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIHRvOiBsaW5lLmZyb20gKyBjdXIubGVuZ3RoLCBpbnNlcnQ6IG5vcm0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZXMubGVuZ3RoID8gW3RyLCB7IGNoYW5nZXMsIHNlcXVlbnRpYWw6IHRydWUgfV0gOiB0cjtcbiAgICB9KTtcbn1cblxuLyoqXG5BIGZhY2V0IHRoYXQgcmVnaXN0ZXJzIGEgY29kZSBmb2xkaW5nIHNlcnZpY2UuIFdoZW4gY2FsbGVkIHdpdGhcbnRoZSBleHRlbnQgb2YgYSBsaW5lLCBzdWNoIGEgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGZvbGRhYmxlXG5yYW5nZSB0aGF0IHN0YXJ0cyBvbiB0aGF0IGxpbmUgKGJ1dCBjb250aW51ZXMgYmV5b25kIGl0KSwgaWYgb25lXG5jYW4gYmUgZm91bmQuXG4qL1xuY29uc3QgZm9sZFNlcnZpY2UgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcblRoaXMgbm9kZSBwcm9wIGlzIHVzZWQgdG8gYXNzb2NpYXRlIGZvbGRpbmcgaW5mb3JtYXRpb24gd2l0aFxuc3ludGF4IG5vZGUgdHlwZXMuIEdpdmVuIGEgc3ludGF4IG5vZGUsIGl0IHNob3VsZCBjaGVjayB3aGV0aGVyXG50aGF0IHRyZWUgaXMgZm9sZGFibGUgYW5kIHJldHVybiB0aGUgcmFuZ2UgdGhhdCBjYW4gYmUgY29sbGFwc2VkXG53aGVuIGl0IGlzLlxuKi9cbmNvbnN0IGZvbGROb2RlUHJvcCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbi8qKlxuW0ZvbGRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZE5vZGVQcm9wKSBmdW5jdGlvbiB0aGF0IGZvbGRzIGV2ZXJ5dGhpbmcgYnV0XG50aGUgZmlyc3QgYW5kIHRoZSBsYXN0IGNoaWxkIG9mIGEgc3ludGF4IG5vZGUuIFVzZWZ1bCBmb3Igbm9kZXNcbnRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIGRlbGltaXRlcnMuXG4qL1xuZnVuY3Rpb24gZm9sZEluc2lkZShub2RlKSB7XG4gICAgbGV0IGZpcnN0ID0gbm9kZS5maXJzdENoaWxkLCBsYXN0ID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgcmV0dXJuIGZpcnN0ICYmIGZpcnN0LnRvIDwgbGFzdC5mcm9tID8geyBmcm9tOiBmaXJzdC50bywgdG86IGxhc3QudHlwZS5pc0Vycm9yID8gbm9kZS50byA6IGxhc3QuZnJvbSB9IDogbnVsbDtcbn1cbmZ1bmN0aW9uIHN5bnRheEZvbGRpbmcoc3RhdGUsIHN0YXJ0LCBlbmQpIHtcbiAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpO1xuICAgIGlmICh0cmVlLmxlbmd0aCA8IGVuZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHN0YWNrID0gdHJlZS5yZXNvbHZlU3RhY2soZW5kLCAxKTtcbiAgICBsZXQgZm91bmQgPSBudWxsO1xuICAgIGZvciAobGV0IGl0ZXIgPSBzdGFjazsgaXRlcjsgaXRlciA9IGl0ZXIubmV4dCkge1xuICAgICAgICBsZXQgY3VyID0gaXRlci5ub2RlO1xuICAgICAgICBpZiAoY3VyLnRvIDw9IGVuZCB8fCBjdXIuZnJvbSA+IGVuZClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoZm91bmQgJiYgY3VyLmZyb20gPCBzdGFydClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgcHJvcCA9IGN1ci50eXBlLnByb3AoZm9sZE5vZGVQcm9wKTtcbiAgICAgICAgaWYgKHByb3AgJiYgKGN1ci50byA8IHRyZWUubGVuZ3RoIC0gNTAgfHwgdHJlZS5sZW5ndGggPT0gc3RhdGUuZG9jLmxlbmd0aCB8fCAhaXNVbmZpbmlzaGVkKGN1cikpKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBwcm9wKGN1ciwgc3RhdGUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmZyb20gPD0gZW5kICYmIHZhbHVlLmZyb20gPj0gc3RhcnQgJiYgdmFsdWUudG8gPiBlbmQpXG4gICAgICAgICAgICAgICAgZm91bmQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBpc1VuZmluaXNoZWQobm9kZSkge1xuICAgIGxldCBjaCA9IG5vZGUubGFzdENoaWxkO1xuICAgIHJldHVybiBjaCAmJiBjaC50byA9PSBub2RlLnRvICYmIGNoLnR5cGUuaXNFcnJvcjtcbn1cbi8qKlxuQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gbGluZSBpcyBmb2xkYWJsZS4gRmlyc3QgYXNrcyBhbnkgZm9sZFxuc2VydmljZXMgcmVnaXN0ZXJlZCB0aHJvdWdoXG5bYGZvbGRTZXJ2aWNlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkU2VydmljZSksIGFuZCBpZiBub25lIG9mIHRoZW0gcmV0dXJuXG5hIHJlc3VsdCwgdHJpZXMgdG8gcXVlcnkgdGhlIFtmb2xkIG5vZGVcbnByb3BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZE5vZGVQcm9wKSBvZiBzeW50YXggbm9kZXMgdGhhdCBjb3ZlciB0aGUgZW5kXG5vZiB0aGUgbGluZS5cbiovXG5mdW5jdGlvbiBmb2xkYWJsZShzdGF0ZSwgbGluZVN0YXJ0LCBsaW5lRW5kKSB7XG4gICAgZm9yIChsZXQgc2VydmljZSBvZiBzdGF0ZS5mYWNldChmb2xkU2VydmljZSkpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHNlcnZpY2Uoc3RhdGUsIGxpbmVTdGFydCwgbGluZUVuZCk7XG4gICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gc3ludGF4Rm9sZGluZyhzdGF0ZSwgbGluZVN0YXJ0LCBsaW5lRW5kKTtcbn1cbmZ1bmN0aW9uIG1hcFJhbmdlKHJhbmdlLCBtYXBwaW5nKSB7XG4gICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcFBvcyhyYW5nZS5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFBvcyhyYW5nZS50bywgLTEpO1xuICAgIHJldHVybiBmcm9tID49IHRvID8gdW5kZWZpbmVkIDogeyBmcm9tLCB0byB9O1xufVxuLyoqXG5TdGF0ZSBlZmZlY3QgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYSB0cmFuc2FjdGlvbiB0byBmb2xkIHRoZVxuZ2l2ZW4gcmFuZ2UuIChZb3UgcHJvYmFibHkgb25seSBuZWVkIHRoaXMgaW4gZXhjZXB0aW9uYWxcbmNpcmN1bXN0YW5jZXPigJR1c3VhbGx5IHlvdSdsbCBqdXN0IHdhbnQgdG8gbGV0XG5bYGZvbGRDb2RlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkQ29kZSkgYW5kIHRoZSBbZm9sZFxuZ3V0dGVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGRHdXR0ZXIpIGNyZWF0ZSB0aGUgdHJhbnNhY3Rpb25zLilcbiovXG5jb25zdCBmb2xkRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7IG1hcDogbWFwUmFuZ2UgfSk7XG4vKipcblN0YXRlIGVmZmVjdCB0aGF0IHVuZm9sZHMgdGhlIGdpdmVuIHJhbmdlIChpZiBpdCB3YXMgZm9sZGVkKS5cbiovXG5jb25zdCB1bmZvbGRFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHsgbWFwOiBtYXBSYW5nZSB9KTtcbmZ1bmN0aW9uIHNlbGVjdGVkTGluZXModmlldykge1xuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGZvciAobGV0IHsgaGVhZCB9IG9mIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICBpZiAobGluZXMuc29tZShsID0+IGwuZnJvbSA8PSBoZWFkICYmIGwudG8gPj0gaGVhZCkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGluZXMucHVzaCh2aWV3LmxpbmVCbG9ja0F0KGhlYWQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzO1xufVxuLyoqXG5UaGUgc3RhdGUgZmllbGQgdGhhdCBzdG9yZXMgdGhlIGZvbGRlZCByYW5nZXMgKGFzIGEgW2RlY29yYXRpb25cbnNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25TZXQpKS4gQ2FuIGJlIHBhc3NlZCB0b1xuW2BFZGl0b3JTdGF0ZS50b0pTT05gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnRvSlNPTikgYW5kXG5bYGZyb21KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5mcm9tSlNPTikgdG8gc2VyaWFsaXplIHRoZSBmb2xkXG5zdGF0ZS5cbiovXG5jb25zdCBmb2xkU3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICB9LFxuICAgIHVwZGF0ZShmb2xkZWQsIHRyKSB7XG4gICAgICAgIGZvbGRlZCA9IGZvbGRlZC5tYXAodHIuY2hhbmdlcyk7XG4gICAgICAgIGZvciAobGV0IGUgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGUuaXMoZm9sZEVmZmVjdCkgJiYgIWZvbGRFeGlzdHMoZm9sZGVkLCBlLnZhbHVlLmZyb20sIGUudmFsdWUudG8pKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgcHJlcGFyZVBsYWNlaG9sZGVyIH0gPSB0ci5zdGF0ZS5mYWNldChmb2xkQ29uZmlnKTtcbiAgICAgICAgICAgICAgICBsZXQgd2lkZ2V0ID0gIXByZXBhcmVQbGFjZWhvbGRlciA/IGZvbGRXaWRnZXQgOlxuICAgICAgICAgICAgICAgICAgICBEZWNvcmF0aW9uLnJlcGxhY2UoeyB3aWRnZXQ6IG5ldyBQcmVwYXJlZEZvbGRXaWRnZXQocHJlcGFyZVBsYWNlaG9sZGVyKHRyLnN0YXRlLCBlLnZhbHVlKSkgfSk7XG4gICAgICAgICAgICAgICAgZm9sZGVkID0gZm9sZGVkLnVwZGF0ZSh7IGFkZDogW3dpZGdldC5yYW5nZShlLnZhbHVlLmZyb20sIGUudmFsdWUudG8pXSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGUuaXModW5mb2xkRWZmZWN0KSkge1xuICAgICAgICAgICAgICAgIGZvbGRlZCA9IGZvbGRlZC51cGRhdGUoeyBmaWx0ZXI6IChmcm9tLCB0bykgPT4gZS52YWx1ZS5mcm9tICE9IGZyb20gfHwgZS52YWx1ZS50byAhPSB0byxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyRnJvbTogZS52YWx1ZS5mcm9tLCBmaWx0ZXJUbzogZS52YWx1ZS50byB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhciBmb2xkZWQgcmFuZ2VzIHRoYXQgY292ZXIgdGhlIHNlbGVjdGlvbiBoZWFkXG4gICAgICAgIGlmICh0ci5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGxldCBvblNlbGVjdGlvbiA9IGZhbHNlLCB7IGhlYWQgfSA9IHRyLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICAgICAgZm9sZGVkLmJldHdlZW4oaGVhZCwgaGVhZCwgKGEsIGIpID0+IHsgaWYgKGEgPCBoZWFkICYmIGIgPiBoZWFkKVxuICAgICAgICAgICAgICAgIG9uU2VsZWN0aW9uID0gdHJ1ZTsgfSk7XG4gICAgICAgICAgICBpZiAob25TZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgZm9sZGVkID0gZm9sZGVkLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlckZyb206IGhlYWQsXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclRvOiBoZWFkLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IChhLCBiKSA9PiBiIDw9IGhlYWQgfHwgYSA+PSBoZWFkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvbGRlZDtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gRWRpdG9yVmlldy5kZWNvcmF0aW9ucy5mcm9tKGYpLFxuICAgIHRvSlNPTihmb2xkZWQsIHN0YXRlKSB7XG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgZm9sZGVkLmJldHdlZW4oMCwgc3RhdGUuZG9jLmxlbmd0aCwgKGZyb20sIHRvKSA9PiB7IHJhbmdlcy5wdXNoKGZyb20sIHRvKTsgfSk7XG4gICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgfSxcbiAgICBmcm9tSlNPTih2YWx1ZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlLmxlbmd0aCAlIDIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiBmb3IgZm9sZCBzdGF0ZVwiKTtcbiAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gdmFsdWVbaSsrXSwgdG8gPSB2YWx1ZVtpKytdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIHRvICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gZm9yIGZvbGQgc3RhdGVcIik7XG4gICAgICAgICAgICByYW5nZXMucHVzaChmb2xkV2lkZ2V0LnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24uc2V0KHJhbmdlcywgdHJ1ZSk7XG4gICAgfVxufSk7XG4vKipcbkdldCBhIFtyYW5nZSBzZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2VTZXQpIGNvbnRhaW5pbmcgdGhlIGZvbGRlZCByYW5nZXNcbmluIHRoZSBnaXZlbiBzdGF0ZS5cbiovXG5mdW5jdGlvbiBmb2xkZWRSYW5nZXMoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkgfHwgUmFuZ2VTZXQuZW1wdHk7XG59XG5mdW5jdGlvbiBmaW5kRm9sZChzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICAoX2EgPSBzdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJldHdlZW4oZnJvbSwgdG8sIChmcm9tLCB0bykgPT4ge1xuICAgICAgICBpZiAoIWZvdW5kIHx8IGZvdW5kLmZyb20gPiBmcm9tKVxuICAgICAgICAgICAgZm91bmQgPSB7IGZyb20sIHRvIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gZm9sZEV4aXN0cyhmb2xkZWQsIGZyb20sIHRvKSB7XG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgZm9sZGVkLmJldHdlZW4oZnJvbSwgZnJvbSwgKGEsIGIpID0+IHsgaWYgKGEgPT0gZnJvbSAmJiBiID09IHRvKVxuICAgICAgICBmb3VuZCA9IHRydWU7IH0pO1xuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIG1heWJlRW5hYmxlKHN0YXRlLCBvdGhlcikge1xuICAgIHJldHVybiBzdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSA/IG90aGVyIDogb3RoZXIuY29uY2F0KFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihjb2RlRm9sZGluZygpKSk7XG59XG4vKipcbkZvbGQgdGhlIGxpbmVzIHRoYXQgYXJlIHNlbGVjdGVkLCBpZiBwb3NzaWJsZS5cbiovXG5jb25zdCBmb2xkQ29kZSA9IHZpZXcgPT4ge1xuICAgIGZvciAobGV0IGxpbmUgb2Ygc2VsZWN0ZWRMaW5lcyh2aWV3KSkge1xuICAgICAgICBsZXQgcmFuZ2UgPSBmb2xkYWJsZSh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBtYXliZUVuYWJsZSh2aWV3LnN0YXRlLCBbZm9sZEVmZmVjdC5vZihyYW5nZSksIGFubm91bmNlRm9sZCh2aWV3LCByYW5nZSldKSB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vKipcblVuZm9sZCBmb2xkZWQgcmFuZ2VzIG9uIHNlbGVjdGVkIGxpbmVzLlxuKi9cbmNvbnN0IHVuZm9sZENvZGUgPSB2aWV3ID0+IHtcbiAgICBpZiAoIXZpZXcuc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZWZmZWN0cyA9IFtdO1xuICAgIGZvciAobGV0IGxpbmUgb2Ygc2VsZWN0ZWRMaW5lcyh2aWV3KSkge1xuICAgICAgICBsZXQgZm9sZGVkID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKGZvbGRlZClcbiAgICAgICAgICAgIGVmZmVjdHMucHVzaCh1bmZvbGRFZmZlY3Qub2YoZm9sZGVkKSwgYW5ub3VuY2VGb2xkKHZpZXcsIGZvbGRlZCwgZmFsc2UpKTtcbiAgICB9XG4gICAgaWYgKGVmZmVjdHMubGVuZ3RoKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0cyB9KTtcbiAgICByZXR1cm4gZWZmZWN0cy5sZW5ndGggPiAwO1xufTtcbmZ1bmN0aW9uIGFubm91bmNlRm9sZCh2aWV3LCByYW5nZSwgZm9sZCA9IHRydWUpIHtcbiAgICBsZXQgbGluZUZyb20gPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQocmFuZ2UuZnJvbSkubnVtYmVyLCBsaW5lVG8gPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQocmFuZ2UudG8pLm51bWJlcjtcbiAgICByZXR1cm4gRWRpdG9yVmlldy5hbm5vdW5jZS5vZihgJHt2aWV3LnN0YXRlLnBocmFzZShmb2xkID8gXCJGb2xkZWQgbGluZXNcIiA6IFwiVW5mb2xkZWQgbGluZXNcIil9ICR7bGluZUZyb219ICR7dmlldy5zdGF0ZS5waHJhc2UoXCJ0b1wiKX0gJHtsaW5lVG99LmApO1xufVxuLyoqXG5Gb2xkIGFsbCB0b3AtbGV2ZWwgZm9sZGFibGUgcmFuZ2VzLiBOb3RlIHRoYXQsIGluIG1vc3QgY2FzZXMsXG5mb2xkaW5nIGluZm9ybWF0aW9uIHdpbGwgZGVwZW5kIG9uIHRoZSBbc3ludGF4XG50cmVlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLnN5bnRheFRyZWUpLCBhbmQgZm9sZGluZyBldmVyeXRoaW5nIG1heSBub3Qgd29ya1xucmVsaWFibHkgd2hlbiB0aGUgZG9jdW1lbnQgaGFzbid0IGJlZW4gZnVsbHkgcGFyc2VkIChlaXRoZXJcbmJlY2F1c2UgdGhlIGVkaXRvciBzdGF0ZSB3YXMgb25seSBqdXN0IGluaXRpYWxpemVkLCBvciBiZWNhdXNlIHRoZVxuZG9jdW1lbnQgaXMgc28gYmlnIHRoYXQgdGhlIHBhcnNlciBkZWNpZGVkIG5vdCB0byBwYXJzZSBpdFxuZW50aXJlbHkpLlxuKi9cbmNvbnN0IGZvbGRBbGwgPSB2aWV3ID0+IHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgZWZmZWN0cyA9IFtdO1xuICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IHN0YXRlLmRvYy5sZW5ndGg7KSB7XG4gICAgICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdChwb3MpLCByYW5nZSA9IGZvbGRhYmxlKHN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBpZiAocmFuZ2UpXG4gICAgICAgICAgICBlZmZlY3RzLnB1c2goZm9sZEVmZmVjdC5vZihyYW5nZSkpO1xuICAgICAgICBwb3MgPSAocmFuZ2UgPyB2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLnRvKSA6IGxpbmUpLnRvICsgMTtcbiAgICB9XG4gICAgaWYgKGVmZmVjdHMubGVuZ3RoKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogbWF5YmVFbmFibGUodmlldy5zdGF0ZSwgZWZmZWN0cykgfSk7XG4gICAgcmV0dXJuICEhZWZmZWN0cy5sZW5ndGg7XG59O1xuLyoqXG5VbmZvbGQgYWxsIGZvbGRlZCBjb2RlLlxuKi9cbmNvbnN0IHVuZm9sZEFsbCA9IHZpZXcgPT4ge1xuICAgIGxldCBmaWVsZCA9IHZpZXcuc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFmaWVsZCB8fCAhZmllbGQuc2l6ZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBlZmZlY3RzID0gW107XG4gICAgZmllbGQuYmV0d2VlbigwLCB2aWV3LnN0YXRlLmRvYy5sZW5ndGgsIChmcm9tLCB0bykgPT4geyBlZmZlY3RzLnB1c2godW5mb2xkRWZmZWN0Lm9mKHsgZnJvbSwgdG8gfSkpOyB9KTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0cyB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vLyBGaW5kIHRoZSBmb2xkYWJsZSByZWdpb24gY29udGFpbmluZyB0aGUgZ2l2ZW4gbGluZSwgaWYgb25lIGV4aXN0c1xuZnVuY3Rpb24gZm9sZGFibGVDb250YWluZXIodmlldywgbGluZUJsb2NrKSB7XG4gICAgLy8gTG9vayBiYWNrd2FyZHMgdGhyb3VnaCBsaW5lIGJsb2NrcyB1bnRpbCB3ZSBmaW5kIGEgZm9sZGFibGUgcmVnaW9uIHRoYXRcbiAgICAvLyBpbnRlcnNlY3RzIHdpdGggdGhlIGxpbmVcbiAgICBmb3IgKGxldCBsaW5lID0gbGluZUJsb2NrOzspIHtcbiAgICAgICAgbGV0IGZvbGRhYmxlUmVnaW9uID0gZm9sZGFibGUodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKGZvbGRhYmxlUmVnaW9uICYmIGZvbGRhYmxlUmVnaW9uLnRvID4gbGluZUJsb2NrLmZyb20pXG4gICAgICAgICAgICByZXR1cm4gZm9sZGFibGVSZWdpb247XG4gICAgICAgIGlmICghbGluZS5mcm9tKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KGxpbmUuZnJvbSAtIDEpO1xuICAgIH1cbn1cbi8qKlxuVG9nZ2xlIGZvbGRpbmcgYXQgY3Vyc29ycy4gVW5mb2xkcyBpZiB0aGVyZSBpcyBhbiBleGlzdGluZyBmb2xkXG5zdGFydGluZyBpbiB0aGF0IGxpbmUsIHRyaWVzIHRvIGZpbmQgYSBmb2xkYWJsZSByYW5nZSBhcm91bmQgaXRcbm90aGVyd2lzZS5cbiovXG5jb25zdCB0b2dnbGVGb2xkID0gKHZpZXcpID0+IHtcbiAgICBsZXQgZWZmZWN0cyA9IFtdO1xuICAgIGZvciAobGV0IGxpbmUgb2Ygc2VsZWN0ZWRMaW5lcyh2aWV3KSkge1xuICAgICAgICBsZXQgZm9sZGVkID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKGZvbGRlZCkge1xuICAgICAgICAgICAgZWZmZWN0cy5wdXNoKHVuZm9sZEVmZmVjdC5vZihmb2xkZWQpLCBhbm5vdW5jZUZvbGQodmlldywgZm9sZGVkLCBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZvbGRSYW5nZSA9IGZvbGRhYmxlQ29udGFpbmVyKHZpZXcsIGxpbmUpO1xuICAgICAgICAgICAgaWYgKGZvbGRSYW5nZSlcbiAgICAgICAgICAgICAgICBlZmZlY3RzLnB1c2goZm9sZEVmZmVjdC5vZihmb2xkUmFuZ2UpLCBhbm5vdW5jZUZvbGQodmlldywgZm9sZFJhbmdlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVmZmVjdHMubGVuZ3RoID4gMClcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IG1heWJlRW5hYmxlKHZpZXcuc3RhdGUsIGVmZmVjdHMpIH0pO1xuICAgIHJldHVybiAhIWVmZmVjdHMubGVuZ3RoO1xufTtcbi8qKlxuRGVmYXVsdCBmb2xkLXJlbGF0ZWQga2V5IGJpbmRpbmdzLlxuXG4gLSBDdHJsLVNoaWZ0LVsgKENtZC1BbHQtWyBvbiBtYWNPUyk6IFtgZm9sZENvZGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGRDb2RlKS5cbiAtIEN0cmwtU2hpZnQtXSAoQ21kLUFsdC1dIG9uIG1hY09TKTogW2B1bmZvbGRDb2RlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS51bmZvbGRDb2RlKS5cbiAtIEN0cmwtQWx0LVs6IFtgZm9sZEFsbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZEFsbCkuXG4gLSBDdHJsLUFsdC1dOiBbYHVuZm9sZEFsbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UudW5mb2xkQWxsKS5cbiovXG5jb25zdCBmb2xkS2V5bWFwID0gW1xuICAgIHsga2V5OiBcIkN0cmwtU2hpZnQtW1wiLCBtYWM6IFwiQ21kLUFsdC1bXCIsIHJ1bjogZm9sZENvZGUgfSxcbiAgICB7IGtleTogXCJDdHJsLVNoaWZ0LV1cIiwgbWFjOiBcIkNtZC1BbHQtXVwiLCBydW46IHVuZm9sZENvZGUgfSxcbiAgICB7IGtleTogXCJDdHJsLUFsdC1bXCIsIHJ1bjogZm9sZEFsbCB9LFxuICAgIHsga2V5OiBcIkN0cmwtQWx0LV1cIiwgcnVuOiB1bmZvbGRBbGwgfVxuXTtcbmNvbnN0IGRlZmF1bHRDb25maWcgPSB7XG4gICAgcGxhY2Vob2xkZXJET006IG51bGwsXG4gICAgcHJlcGFyZVBsYWNlaG9sZGVyOiBudWxsLFxuICAgIHBsYWNlaG9sZGVyVGV4dDogXCLigKZcIlxufTtcbmNvbnN0IGZvbGRDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKHZhbHVlcykgeyByZXR1cm4gY29tYmluZUNvbmZpZyh2YWx1ZXMsIGRlZmF1bHRDb25maWcpOyB9XG59KTtcbi8qKlxuQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGNvbmZpZ3VyZXMgY29kZSBmb2xkaW5nLlxuKi9cbmZ1bmN0aW9uIGNvZGVGb2xkaW5nKGNvbmZpZykge1xuICAgIGxldCByZXN1bHQgPSBbZm9sZFN0YXRlLCBiYXNlVGhlbWUkMV07XG4gICAgaWYgKGNvbmZpZylcbiAgICAgICAgcmVzdWx0LnB1c2goZm9sZENvbmZpZy5vZihjb25maWcpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gd2lkZ2V0VG9ET00odmlldywgcHJlcGFyZWQpIHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgY29uZiA9IHN0YXRlLmZhY2V0KGZvbGRDb25maWcpO1xuICAgIGxldCBvbmNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdCh2aWV3LnBvc0F0RE9NKGV2ZW50LnRhcmdldCkpO1xuICAgICAgICBsZXQgZm9sZGVkID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKGZvbGRlZClcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB1bmZvbGRFZmZlY3Qub2YoZm9sZGVkKSB9KTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuICAgIGlmIChjb25mLnBsYWNlaG9sZGVyRE9NKVxuICAgICAgICByZXR1cm4gY29uZi5wbGFjZWhvbGRlckRPTSh2aWV3LCBvbmNsaWNrLCBwcmVwYXJlZCk7XG4gICAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBlbGVtZW50LnRleHRDb250ZW50ID0gY29uZi5wbGFjZWhvbGRlclRleHQ7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHN0YXRlLnBocmFzZShcImZvbGRlZCBjb2RlXCIpKTtcbiAgICBlbGVtZW50LnRpdGxlID0gc3RhdGUucGhyYXNlKFwidW5mb2xkXCIpO1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gXCJjbS1mb2xkUGxhY2Vob2xkZXJcIjtcbiAgICBlbGVtZW50Lm9uY2xpY2sgPSBvbmNsaWNrO1xuICAgIHJldHVybiBlbGVtZW50O1xufVxuY29uc3QgZm9sZFdpZGdldCA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLnJlcGxhY2UoeyB3aWRnZXQ6IC8qQF9fUFVSRV9fKi9uZXcgY2xhc3MgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICAgICAgdG9ET00odmlldykgeyByZXR1cm4gd2lkZ2V0VG9ET00odmlldywgbnVsbCk7IH1cbiAgICB9IH0pO1xuY2xhc3MgUHJlcGFyZWRGb2xkV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gdGhpcy52YWx1ZSA9PSBvdGhlci52YWx1ZTsgfVxuICAgIHRvRE9NKHZpZXcpIHsgcmV0dXJuIHdpZGdldFRvRE9NKHZpZXcsIHRoaXMudmFsdWUpOyB9XG59XG5jb25zdCBmb2xkR3V0dGVyRGVmYXVsdHMgPSB7XG4gICAgb3BlblRleHQ6IFwi4oyEXCIsXG4gICAgY2xvc2VkVGV4dDogXCLigLpcIixcbiAgICBtYXJrZXJET006IG51bGwsXG4gICAgZG9tRXZlbnRIYW5kbGVyczoge30sXG4gICAgZm9sZGluZ0NoYW5nZWQ6ICgpID0+IGZhbHNlXG59O1xuY2xhc3MgRm9sZE1hcmtlciBleHRlbmRzIEd1dHRlck1hcmtlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBvcGVuKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLm9wZW4gPSBvcGVuO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gdGhpcy5jb25maWcgPT0gb3RoZXIuY29uZmlnICYmIHRoaXMub3BlbiA9PSBvdGhlci5vcGVuOyB9XG4gICAgdG9ET00odmlldykge1xuICAgICAgICBpZiAodGhpcy5jb25maWcubWFya2VyRE9NKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLm1hcmtlckRPTSh0aGlzLm9wZW4pO1xuICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gdGhpcy5vcGVuID8gdGhpcy5jb25maWcub3BlblRleHQgOiB0aGlzLmNvbmZpZy5jbG9zZWRUZXh0O1xuICAgICAgICBzcGFuLnRpdGxlID0gdmlldy5zdGF0ZS5waHJhc2UodGhpcy5vcGVuID8gXCJGb2xkIGxpbmVcIiA6IFwiVW5mb2xkIGxpbmVcIik7XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbn1cbi8qKlxuQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IHJlZ2lzdGVycyBhIGZvbGQgZ3V0dGVyLCB3aGljaCBzaG93cyBhXG5mb2xkIHN0YXR1cyBpbmRpY2F0b3IgYmVmb3JlIGZvbGRhYmxlIGxpbmVzICh3aGljaCBjYW4gYmUgY2xpY2tlZFxudG8gZm9sZCBvciB1bmZvbGQgdGhlIGxpbmUpLlxuKi9cbmZ1bmN0aW9uIGZvbGRHdXR0ZXIoY29uZmlnID0ge30pIHtcbiAgICBsZXQgZnVsbENvbmZpZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZm9sZEd1dHRlckRlZmF1bHRzKSwgY29uZmlnKTtcbiAgICBsZXQgY2FuRm9sZCA9IG5ldyBGb2xkTWFya2VyKGZ1bGxDb25maWcsIHRydWUpLCBjYW5VbmZvbGQgPSBuZXcgRm9sZE1hcmtlcihmdWxsQ29uZmlnLCBmYWxzZSk7XG4gICAgbGV0IG1hcmtlcnMgPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbSA9IHZpZXcudmlld3BvcnQuZnJvbTtcbiAgICAgICAgICAgIHRoaXMubWFya2VycyA9IHRoaXMuYnVpbGRNYXJrZXJzKHZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8XG4gICAgICAgICAgICAgICAgdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQobGFuZ3VhZ2UpICE9IHVwZGF0ZS5zdGF0ZS5mYWNldChsYW5ndWFnZSkgfHxcbiAgICAgICAgICAgICAgICB1cGRhdGUuc3RhcnRTdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSAhPSB1cGRhdGUuc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkgfHxcbiAgICAgICAgICAgICAgICBzeW50YXhUcmVlKHVwZGF0ZS5zdGFydFN0YXRlKSAhPSBzeW50YXhUcmVlKHVwZGF0ZS5zdGF0ZSkgfHxcbiAgICAgICAgICAgICAgICBmdWxsQ29uZmlnLmZvbGRpbmdDaGFuZ2VkKHVwZGF0ZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrZXJzID0gdGhpcy5idWlsZE1hcmtlcnModXBkYXRlLnZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIGJ1aWxkTWFya2Vycyh2aWV3KSB7XG4gICAgICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGxpbmUgb2Ygdmlldy52aWV3cG9ydExpbmVCbG9ja3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFyayA9IGZpbmRGb2xkKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50bykgPyBjYW5VbmZvbGRcbiAgICAgICAgICAgICAgICAgICAgOiBmb2xkYWJsZSh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pID8gY2FuRm9sZCA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmspXG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkKGxpbmUuZnJvbSwgbGluZS5mcm9tLCBtYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaCgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbGV0IHsgZG9tRXZlbnRIYW5kbGVycyB9ID0gZnVsbENvbmZpZztcbiAgICByZXR1cm4gW1xuICAgICAgICBtYXJrZXJzLFxuICAgICAgICBndXR0ZXIoe1xuICAgICAgICAgICAgY2xhc3M6IFwiY20tZm9sZEd1dHRlclwiLFxuICAgICAgICAgICAgbWFya2Vycyh2aWV3KSB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSB2aWV3LnBsdWdpbihtYXJrZXJzKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcmtlcnMpIHx8IFJhbmdlU2V0LmVtcHR5OyB9LFxuICAgICAgICAgICAgaW5pdGlhbFNwYWNlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZvbGRNYXJrZXIoZnVsbENvbmZpZywgZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvbUV2ZW50SGFuZGxlcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZG9tRXZlbnRIYW5kbGVycyksIHsgY2xpY2s6ICh2aWV3LCBsaW5lLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tRXZlbnRIYW5kbGVycy5jbGljayAmJiBkb21FdmVudEhhbmRsZXJzLmNsaWNrKHZpZXcsIGxpbmUsIGV2ZW50KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm9sZGVkID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvbGRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHVuZm9sZEVmZmVjdC5vZihmb2xkZWQpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gZm9sZGFibGUodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogZm9sZEVmZmVjdC5vZihyYW5nZSkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSB9KVxuICAgICAgICB9KSxcbiAgICAgICAgY29kZUZvbGRpbmcoKVxuICAgIF07XG59XG5jb25zdCBiYXNlVGhlbWUkMSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tZm9sZFBsYWNlaG9sZGVyXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNlZWVcIixcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjZGRkXCIsXG4gICAgICAgIGNvbG9yOiBcIiM4ODhcIixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBcIi4yZW1cIixcbiAgICAgICAgbWFyZ2luOiBcIjAgMXB4XCIsXG4gICAgICAgIHBhZGRpbmc6IFwiMCAxcHhcIixcbiAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIlxuICAgIH0sXG4gICAgXCIuY20tZm9sZEd1dHRlciBzcGFuXCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIwIDFweFwiLFxuICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiXG4gICAgfVxufSk7XG5cbi8qKlxuQSBoaWdobGlnaHQgc3R5bGUgYXNzb2NpYXRlcyBDU1Mgc3R5bGVzIHdpdGggaGlnbGlnaHRpbmdcblt0YWdzXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmI2hpZ2hsaWdodC5UYWcpLlxuKi9cbmNsYXNzIEhpZ2hsaWdodFN0eWxlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgdGFnIHN0eWxlcyB1c2VkIHRvIGNyZWF0ZSB0aGlzIGhpZ2hsaWdodCBzdHlsZS5cbiAgICAqL1xuICAgIHNwZWNzLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc3BlY3MgPSBzcGVjcztcbiAgICAgICAgbGV0IG1vZFNwZWM7XG4gICAgICAgIGZ1bmN0aW9uIGRlZihzcGVjKSB7XG4gICAgICAgICAgICBsZXQgY2xzID0gU3R5bGVNb2R1bGUubmV3TmFtZSgpO1xuICAgICAgICAgICAgKG1vZFNwZWMgfHwgKG1vZFNwZWMgPSBPYmplY3QuY3JlYXRlKG51bGwpKSlbXCIuXCIgKyBjbHNdID0gc3BlYztcbiAgICAgICAgICAgIHJldHVybiBjbHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsID0gdHlwZW9mIG9wdGlvbnMuYWxsID09IFwic3RyaW5nXCIgPyBvcHRpb25zLmFsbCA6IG9wdGlvbnMuYWxsID8gZGVmKG9wdGlvbnMuYWxsKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc2NvcGVPcHQgPSBvcHRpb25zLnNjb3BlO1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGVPcHQgaW5zdGFuY2VvZiBMYW5ndWFnZSA/ICh0eXBlKSA9PiB0eXBlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCkgPT0gc2NvcGVPcHQuZGF0YVxuICAgICAgICAgICAgOiBzY29wZU9wdCA/ICh0eXBlKSA9PiB0eXBlID09IHNjb3BlT3B0IDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnN0eWxlID0gdGFnSGlnaGxpZ2h0ZXIoc3BlY3MubWFwKHN0eWxlID0+ICh7XG4gICAgICAgICAgICB0YWc6IHN0eWxlLnRhZyxcbiAgICAgICAgICAgIGNsYXNzOiBzdHlsZS5jbGFzcyB8fCBkZWYoT2JqZWN0LmFzc2lnbih7fSwgc3R5bGUsIHsgdGFnOiBudWxsIH0pKVxuICAgICAgICB9KSksIHtcbiAgICAgICAgICAgIGFsbCxcbiAgICAgICAgfSkuc3R5bGU7XG4gICAgICAgIHRoaXMubW9kdWxlID0gbW9kU3BlYyA/IG5ldyBTdHlsZU1vZHVsZShtb2RTcGVjKSA6IG51bGw7XG4gICAgICAgIHRoaXMudGhlbWVUeXBlID0gb3B0aW9ucy50aGVtZVR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGhpZ2hsaWdodGVyIHN0eWxlIHRoYXQgYXNzb2NpYXRlcyB0aGUgZ2l2ZW4gc3R5bGVzIHRvXG4gICAgdGhlIGdpdmVuIHRhZ3MuIFRoZSBzcGVjcyBtdXN0IGJlIG9iamVjdHMgdGhhdCBob2xkIGEgc3R5bGUgdGFnXG4gICAgb3IgYXJyYXkgb2YgdGFncyBpbiB0aGVpciBgdGFnYCBwcm9wZXJ0eSwgYW5kIGVpdGhlciBhIHNpbmdsZVxuICAgIGBjbGFzc2AgcHJvcGVydHkgcHJvdmlkaW5nIGEgc3RhdGljIENTUyBjbGFzcyAoZm9yIGhpZ2hsaWdodGVyXG4gICAgdGhhdCByZWx5IG9uIGV4dGVybmFsIHN0eWxpbmcpLCBvciBhXG4gICAgW2BzdHlsZS1tb2RgXShodHRwczovL2dpdGh1Yi5jb20vbWFyaWpuaC9zdHlsZS1tb2QjZG9jdW1lbnRhdGlvbiktc3R5bGVcbiAgICBzZXQgb2YgQ1NTIHByb3BlcnRpZXMgKHdoaWNoIGRlZmluZSB0aGUgc3R5bGluZyBmb3IgdGhvc2UgdGFncykuXG4gICAgXG4gICAgVGhlIENTUyBydWxlcyBjcmVhdGVkIGZvciBhIGhpZ2hsaWdodGVyIHdpbGwgYmUgZW1pdHRlZCBpbiB0aGVcbiAgICBvcmRlciBvZiB0aGUgc3BlYydzIHByb3BlcnRpZXMuIFRoYXQgbWVhbnMgdGhhdCBmb3IgZWxlbWVudHMgdGhhdFxuICAgIGhhdmUgbXVsdGlwbGUgdGFncyBhc3NvY2lhdGVkIHdpdGggdGhlbSwgc3R5bGVzIGRlZmluZWQgZnVydGhlclxuICAgIGRvd24gaW4gdGhlIGxpc3Qgd2lsbCBoYXZlIGEgaGlnaGVyIENTUyBwcmVjZWRlbmNlIHRoYW4gc3R5bGVzXG4gICAgZGVmaW5lZCBlYXJsaWVyLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShzcGVjcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEhpZ2hsaWdodFN0eWxlKHNwZWNzLCBvcHRpb25zIHx8IHt9KTtcbiAgICB9XG59XG5jb25zdCBoaWdobGlnaHRlckZhY2V0ID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgZmFsbGJhY2tIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUodmFsdWVzKSB7IHJldHVybiB2YWx1ZXMubGVuZ3RoID8gW3ZhbHVlc1swXV0gOiBudWxsOyB9XG59KTtcbmZ1bmN0aW9uIGdldEhpZ2hsaWdodGVycyhzdGF0ZSkge1xuICAgIGxldCBtYWluID0gc3RhdGUuZmFjZXQoaGlnaGxpZ2h0ZXJGYWNldCk7XG4gICAgcmV0dXJuIG1haW4ubGVuZ3RoID8gbWFpbiA6IHN0YXRlLmZhY2V0KGZhbGxiYWNrSGlnaGxpZ2h0ZXIpO1xufVxuLyoqXG5XcmFwIGEgaGlnaGxpZ2h0ZXIgaW4gYW4gZWRpdG9yIGV4dGVuc2lvbiB0aGF0IHVzZXMgaXQgdG8gYXBwbHlcbnN5bnRheCBoaWdobGlnaHRpbmcgdG8gdGhlIGVkaXRvciBjb250ZW50LlxuXG5XaGVuIG11bHRpcGxlIChub24tZmFsbGJhY2spIHN0eWxlcyBhcmUgcHJvdmlkZWQsIHRoZSBzdHlsaW5nXG5hcHBsaWVkIGlzIHRoZSB1bmlvbiBvZiB0aGUgY2xhc3NlcyB0aGV5IGVtaXQuXG4qL1xuZnVuY3Rpb24gc3ludGF4SGlnaGxpZ2h0aW5nKGhpZ2hsaWdodGVyLCBvcHRpb25zKSB7XG4gICAgbGV0IGV4dCA9IFt0cmVlSGlnaGxpZ2h0ZXJdLCB0aGVtZVR5cGU7XG4gICAgaWYgKGhpZ2hsaWdodGVyIGluc3RhbmNlb2YgSGlnaGxpZ2h0U3R5bGUpIHtcbiAgICAgICAgaWYgKGhpZ2hsaWdodGVyLm1vZHVsZSlcbiAgICAgICAgICAgIGV4dC5wdXNoKEVkaXRvclZpZXcuc3R5bGVNb2R1bGUub2YoaGlnaGxpZ2h0ZXIubW9kdWxlKSk7XG4gICAgICAgIHRoZW1lVHlwZSA9IGhpZ2hsaWdodGVyLnRoZW1lVHlwZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mYWxsYmFjaylcbiAgICAgICAgZXh0LnB1c2goZmFsbGJhY2tIaWdobGlnaHRlci5vZihoaWdobGlnaHRlcikpO1xuICAgIGVsc2UgaWYgKHRoZW1lVHlwZSlcbiAgICAgICAgZXh0LnB1c2goaGlnaGxpZ2h0ZXJGYWNldC5jb21wdXRlTihbRWRpdG9yVmlldy5kYXJrVGhlbWVdLCBzdGF0ZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUuZmFjZXQoRWRpdG9yVmlldy5kYXJrVGhlbWUpID09ICh0aGVtZVR5cGUgPT0gXCJkYXJrXCIpID8gW2hpZ2hsaWdodGVyXSA6IFtdO1xuICAgICAgICB9KSk7XG4gICAgZWxzZVxuICAgICAgICBleHQucHVzaChoaWdobGlnaHRlckZhY2V0Lm9mKGhpZ2hsaWdodGVyKSk7XG4gICAgcmV0dXJuIGV4dDtcbn1cbi8qKlxuUmV0dXJucyB0aGUgQ1NTIGNsYXNzZXMgKGlmIGFueSkgdGhhdCB0aGUgaGlnaGxpZ2h0ZXJzIGFjdGl2ZSBpblxudGhlIHN0YXRlIHdvdWxkIGFzc2lnbiB0byB0aGUgZ2l2ZW4gc3R5bGVcblt0YWdzXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmI2hpZ2hsaWdodC5UYWcpIGFuZFxuKG9wdGlvbmFsKSBsYW5ndWFnZVxuW3Njb3BlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkhpZ2hsaWdodFN0eWxlXmRlZmluZV5vcHRpb25zLnNjb3BlKS5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRpbmdGb3Ioc3RhdGUsIHRhZ3MsIHNjb3BlKSB7XG4gICAgbGV0IGhpZ2hsaWdodGVycyA9IGdldEhpZ2hsaWdodGVycyhzdGF0ZSk7XG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgaWYgKGhpZ2hsaWdodGVycylcbiAgICAgICAgZm9yIChsZXQgaGlnaGxpZ2h0ZXIgb2YgaGlnaGxpZ2h0ZXJzKSB7XG4gICAgICAgICAgICBpZiAoIWhpZ2hsaWdodGVyLnNjb3BlIHx8IHNjb3BlICYmIGhpZ2hsaWdodGVyLnNjb3BlKHNjb3BlKSkge1xuICAgICAgICAgICAgICAgIGxldCBjbHMgPSBoaWdobGlnaHRlci5zdHlsZSh0YWdzKTtcbiAgICAgICAgICAgICAgICBpZiAoY2xzKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgPyByZXN1bHQgKyBcIiBcIiArIGNscyA6IGNscztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jbGFzcyBUcmVlSGlnaGxpZ2h0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5tYXJrQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLnRyZWUgPSBzeW50YXhUcmVlKHZpZXcuc3RhdGUpO1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5idWlsZERlY28odmlldywgZ2V0SGlnaGxpZ2h0ZXJzKHZpZXcuc3RhdGUpKTtcbiAgICAgICAgdGhpcy5kZWNvcmF0ZWRUbyA9IHZpZXcudmlld3BvcnQudG87XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKHVwZGF0ZS5zdGF0ZSksIGhpZ2hsaWdodGVycyA9IGdldEhpZ2hsaWdodGVycyh1cGRhdGUuc3RhdGUpO1xuICAgICAgICBsZXQgc3R5bGVDaGFuZ2UgPSBoaWdobGlnaHRlcnMgIT0gZ2V0SGlnaGxpZ2h0ZXJzKHVwZGF0ZS5zdGFydFN0YXRlKTtcbiAgICAgICAgbGV0IHsgdmlld3BvcnQgfSA9IHVwZGF0ZS52aWV3LCBkZWNvcmF0ZWRUb01hcHBlZCA9IHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyh0aGlzLmRlY29yYXRlZFRvLCAxKTtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoIDwgdmlld3BvcnQudG8gJiYgIXN0eWxlQ2hhbmdlICYmIHRyZWUudHlwZSA9PSB0aGlzLnRyZWUudHlwZSAmJiBkZWNvcmF0ZWRUb01hcHBlZCA+PSB2aWV3cG9ydC50bykge1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdGlvbnMubWFwKHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGVkVG8gPSBkZWNvcmF0ZWRUb01hcHBlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0cmVlICE9IHRoaXMudHJlZSB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8IHN0eWxlQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuYnVpbGREZWNvKHVwZGF0ZS52aWV3LCBoaWdobGlnaHRlcnMpO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0ZWRUbyA9IHZpZXdwb3J0LnRvO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJ1aWxkRGVjbyh2aWV3LCBoaWdobGlnaHRlcnMpIHtcbiAgICAgICAgaWYgKCFoaWdobGlnaHRlcnMgfHwgIXRoaXMudHJlZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKTtcbiAgICAgICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIHZpZXcudmlzaWJsZVJhbmdlcykge1xuICAgICAgICAgICAgaGlnaGxpZ2h0VHJlZSh0aGlzLnRyZWUsIGhpZ2hsaWdodGVycywgKGZyb20sIHRvLCBzdHlsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkKGZyb20sIHRvLCB0aGlzLm1hcmtDYWNoZVtzdHlsZV0gfHwgKHRoaXMubWFya0NhY2hlW3N0eWxlXSA9IERlY29yYXRpb24ubWFyayh7IGNsYXNzOiBzdHlsZSB9KSkpO1xuICAgICAgICAgICAgfSwgZnJvbSwgdG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaCgpO1xuICAgIH1cbn1cbmNvbnN0IHRyZWVIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9QcmVjLmhpZ2goLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKFRyZWVIaWdobGlnaHRlciwge1xuICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbn0pKTtcbi8qKlxuQSBkZWZhdWx0IGhpZ2hsaWdodCBzdHlsZSAod29ya3Mgd2VsbCB3aXRoIGxpZ2h0IHRoZW1lcykuXG4qL1xuY29uc3QgZGVmYXVsdEhpZ2hsaWdodFN0eWxlID0gLypAX19QVVJFX18qL0hpZ2hsaWdodFN0eWxlLmRlZmluZShbXG4gICAgeyB0YWc6IHRhZ3MubWV0YSxcbiAgICAgICAgY29sb3I6IFwiIzQwNDc0MFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubGluayxcbiAgICAgICAgdGV4dERlY29yYXRpb246IFwidW5kZXJsaW5lXCIgfSxcbiAgICB7IHRhZzogdGFncy5oZWFkaW5nLFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIixcbiAgICAgICAgZm9udFdlaWdodDogXCJib2xkXCIgfSxcbiAgICB7IHRhZzogdGFncy5lbXBoYXNpcyxcbiAgICAgICAgZm9udFN0eWxlOiBcIml0YWxpY1wiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3Ryb25nLFxuICAgICAgICBmb250V2VpZ2h0OiBcImJvbGRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cmlrZXRocm91Z2gsXG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcImxpbmUtdGhyb3VnaFwiIH0sXG4gICAgeyB0YWc6IHRhZ3Mua2V5d29yZCxcbiAgICAgICAgY29sb3I6IFwiIzcwOFwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLmF0b20sIHRhZ3MuYm9vbCwgdGFncy51cmwsIHRhZ3MuY29udGVudFNlcGFyYXRvciwgdGFncy5sYWJlbE5hbWVdLFxuICAgICAgICBjb2xvcjogXCIjMjE5XCIgfSxcbiAgICB7IHRhZzogW3RhZ3MubGl0ZXJhbCwgdGFncy5pbnNlcnRlZF0sXG4gICAgICAgIGNvbG9yOiBcIiMxNjRcIiB9LFxuICAgIHsgdGFnOiBbdGFncy5zdHJpbmcsIHRhZ3MuZGVsZXRlZF0sXG4gICAgICAgIGNvbG9yOiBcIiNhMTFcIiB9LFxuICAgIHsgdGFnOiBbdGFncy5yZWdleHAsIHRhZ3MuZXNjYXBlLCAvKkBfX1BVUkVfXyovdGFncy5zcGVjaWFsKHRhZ3Muc3RyaW5nKV0sXG4gICAgICAgIGNvbG9yOiBcIiNlNDBcIiB9LFxuICAgIHsgdGFnOiAvKkBfX1BVUkVfXyovdGFncy5kZWZpbml0aW9uKHRhZ3MudmFyaWFibGVOYW1lKSxcbiAgICAgICAgY29sb3I6IFwiIzAwZlwiIH0sXG4gICAgeyB0YWc6IC8qQF9fUFVSRV9fKi90YWdzLmxvY2FsKHRhZ3MudmFyaWFibGVOYW1lKSxcbiAgICAgICAgY29sb3I6IFwiIzMwYVwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLnR5cGVOYW1lLCB0YWdzLm5hbWVzcGFjZV0sXG4gICAgICAgIGNvbG9yOiBcIiMwODVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmNsYXNzTmFtZSxcbiAgICAgICAgY29sb3I6IFwiIzE2N1wiIH0sXG4gICAgeyB0YWc6IFsvKkBfX1BVUkVfXyovdGFncy5zcGVjaWFsKHRhZ3MudmFyaWFibGVOYW1lKSwgdGFncy5tYWNyb05hbWVdLFxuICAgICAgICBjb2xvcjogXCIjMjU2XCIgfSxcbiAgICB7IHRhZzogLypAX19QVVJFX18qL3RhZ3MuZGVmaW5pdGlvbih0YWdzLnByb3BlcnR5TmFtZSksXG4gICAgICAgIGNvbG9yOiBcIiMwMGNcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmNvbW1lbnQsXG4gICAgICAgIGNvbG9yOiBcIiM5NDBcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmludmFsaWQsXG4gICAgICAgIGNvbG9yOiBcIiNmMDBcIiB9XG5dKTtcblxuY29uc3QgYmFzZVRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIiYuY20tZm9jdXNlZCAuY20tbWF0Y2hpbmdCcmFja2V0XCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiMzMjhjODI1MlwiIH0sXG4gICAgXCImLmNtLWZvY3VzZWQgLmNtLW5vbm1hdGNoaW5nQnJhY2tldFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjYmI1NTU1NDRcIiB9XG59KTtcbmNvbnN0IERlZmF1bHRTY2FuRGlzdCA9IDEwMDAwLCBEZWZhdWx0QnJhY2tldHMgPSBcIigpW117fVwiO1xuY29uc3QgYnJhY2tldE1hdGNoaW5nQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIGFmdGVyQ3Vyc29yOiB0cnVlLFxuICAgICAgICAgICAgYnJhY2tldHM6IERlZmF1bHRCcmFja2V0cyxcbiAgICAgICAgICAgIG1heFNjYW5EaXN0YW5jZTogRGVmYXVsdFNjYW5EaXN0LFxuICAgICAgICAgICAgcmVuZGVyTWF0Y2g6IGRlZmF1bHRSZW5kZXJNYXRjaFxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbmNvbnN0IG1hdGNoaW5nTWFyayA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1tYXRjaGluZ0JyYWNrZXRcIiB9KSwgbm9ubWF0Y2hpbmdNYXJrID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLW5vbm1hdGNoaW5nQnJhY2tldFwiIH0pO1xuZnVuY3Rpb24gZGVmYXVsdFJlbmRlck1hdGNoKG1hdGNoKSB7XG4gICAgbGV0IGRlY29yYXRpb25zID0gW107XG4gICAgbGV0IG1hcmsgPSBtYXRjaC5tYXRjaGVkID8gbWF0Y2hpbmdNYXJrIDogbm9ubWF0Y2hpbmdNYXJrO1xuICAgIGRlY29yYXRpb25zLnB1c2gobWFyay5yYW5nZShtYXRjaC5zdGFydC5mcm9tLCBtYXRjaC5zdGFydC50bykpO1xuICAgIGlmIChtYXRjaC5lbmQpXG4gICAgICAgIGRlY29yYXRpb25zLnB1c2gobWFyay5yYW5nZShtYXRjaC5lbmQuZnJvbSwgbWF0Y2guZW5kLnRvKSk7XG4gICAgcmV0dXJuIGRlY29yYXRpb25zO1xufVxuY29uc3QgYnJhY2tldE1hdGNoaW5nU3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIERlY29yYXRpb24ubm9uZTsgfSxcbiAgICB1cGRhdGUoZGVjbywgdHIpIHtcbiAgICAgICAgaWYgKCF0ci5kb2NDaGFuZ2VkICYmICF0ci5zZWxlY3Rpb24pXG4gICAgICAgICAgICByZXR1cm4gZGVjbztcbiAgICAgICAgbGV0IGRlY29yYXRpb25zID0gW107XG4gICAgICAgIGxldCBjb25maWcgPSB0ci5zdGF0ZS5mYWNldChicmFja2V0TWF0Y2hpbmdDb25maWcpO1xuICAgICAgICBmb3IgKGxldCByYW5nZSBvZiB0ci5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAoIXJhbmdlLmVtcHR5KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gbWF0Y2hCcmFja2V0cyh0ci5zdGF0ZSwgcmFuZ2UuaGVhZCwgLTEsIGNvbmZpZylcbiAgICAgICAgICAgICAgICB8fCAocmFuZ2UuaGVhZCA+IDAgJiYgbWF0Y2hCcmFja2V0cyh0ci5zdGF0ZSwgcmFuZ2UuaGVhZCAtIDEsIDEsIGNvbmZpZykpXG4gICAgICAgICAgICAgICAgfHwgKGNvbmZpZy5hZnRlckN1cnNvciAmJlxuICAgICAgICAgICAgICAgICAgICAobWF0Y2hCcmFja2V0cyh0ci5zdGF0ZSwgcmFuZ2UuaGVhZCwgMSwgY29uZmlnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHJhbmdlLmhlYWQgPCB0ci5zdGF0ZS5kb2MubGVuZ3RoICYmIG1hdGNoQnJhY2tldHModHIuc3RhdGUsIHJhbmdlLmhlYWQgKyAxLCAtMSwgY29uZmlnKSkpKTtcbiAgICAgICAgICAgIGlmIChtYXRjaClcbiAgICAgICAgICAgICAgICBkZWNvcmF0aW9ucyA9IGRlY29yYXRpb25zLmNvbmNhdChjb25maWcucmVuZGVyTWF0Y2gobWF0Y2gsIHRyLnN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24uc2V0KGRlY29yYXRpb25zLCB0cnVlKTtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gRWRpdG9yVmlldy5kZWNvcmF0aW9ucy5mcm9tKGYpXG59KTtcbmNvbnN0IGJyYWNrZXRNYXRjaGluZ1VuaXF1ZSA9IFtcbiAgICBicmFja2V0TWF0Y2hpbmdTdGF0ZSxcbiAgICBiYXNlVGhlbWVcbl07XG4vKipcbkNyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBlbmFibGVzIGJyYWNrZXQgbWF0Y2hpbmcuIFdoZW5ldmVyIHRoZVxuY3Vyc29yIGlzIG5leHQgdG8gYSBicmFja2V0LCB0aGF0IGJyYWNrZXQgYW5kIHRoZSBvbmUgaXQgbWF0Y2hlc1xuYXJlIGhpZ2hsaWdodGVkLiBPciwgd2hlbiBubyBtYXRjaGluZyBicmFja2V0IGlzIGZvdW5kLCBhbm90aGVyXG5oaWdobGlnaHRpbmcgc3R5bGUgaXMgdXNlZCB0byBpbmRpY2F0ZSB0aGlzLlxuKi9cbmZ1bmN0aW9uIGJyYWNrZXRNYXRjaGluZyhjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbYnJhY2tldE1hdGNoaW5nQ29uZmlnLm9mKGNvbmZpZyksIGJyYWNrZXRNYXRjaGluZ1VuaXF1ZV07XG59XG4vKipcbldoZW4gbGFyZ2VyIHN5bnRheCBub2Rlcywgc3VjaCBhcyBIVE1MIHRhZ3MsIGFyZSBtYXJrZWQgYXNcbm9wZW5pbmcvY2xvc2luZywgaXQgY2FuIGJlIGEgYml0IG1lc3N5IHRvIHRyZWF0IHRoZSB3aG9sZSBub2RlIGFzXG5hIG1hdGNoYWJsZSBicmFja2V0LiBUaGlzIG5vZGUgcHJvcCBhbGxvd3MgeW91IHRvIGRlZmluZSwgZm9yIHN1Y2hcbmEgbm9kZSwgYSDigJhoYW5kbGXigJnigJR0aGUgcGFydCBvZiB0aGUgbm9kZSB0aGF0IGlzIGhpZ2hsaWdodGVkLCBhbmRcbnRoYXQgdGhlIGN1cnNvciBtdXN0IGJlIG9uIHRvIGFjdGl2YXRlIGhpZ2hsaWdodGluZyBpbiB0aGUgZmlyc3RcbnBsYWNlLlxuKi9cbmNvbnN0IGJyYWNrZXRNYXRjaGluZ0hhbmRsZSA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbmZ1bmN0aW9uIG1hdGNoaW5nTm9kZXMobm9kZSwgZGlyLCBicmFja2V0cykge1xuICAgIGxldCBieVByb3AgPSBub2RlLnByb3AoZGlyIDwgMCA/IE5vZGVQcm9wLm9wZW5lZEJ5IDogTm9kZVByb3AuY2xvc2VkQnkpO1xuICAgIGlmIChieVByb3ApXG4gICAgICAgIHJldHVybiBieVByb3A7XG4gICAgaWYgKG5vZGUubmFtZS5sZW5ndGggPT0gMSkge1xuICAgICAgICBsZXQgaW5kZXggPSBicmFja2V0cy5pbmRleE9mKG5vZGUubmFtZSk7XG4gICAgICAgIGlmIChpbmRleCA+IC0xICYmIGluZGV4ICUgMiA9PSAoZGlyIDwgMCA/IDEgOiAwKSlcbiAgICAgICAgICAgIHJldHVybiBbYnJhY2tldHNbaW5kZXggKyBkaXJdXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmaW5kSGFuZGxlKG5vZGUpIHtcbiAgICBsZXQgaGFzSGFuZGxlID0gbm9kZS50eXBlLnByb3AoYnJhY2tldE1hdGNoaW5nSGFuZGxlKTtcbiAgICByZXR1cm4gaGFzSGFuZGxlID8gaGFzSGFuZGxlKG5vZGUubm9kZSkgOiBub2RlO1xufVxuLyoqXG5GaW5kIHRoZSBtYXRjaGluZyBicmFja2V0IGZvciB0aGUgdG9rZW4gYXQgYHBvc2AsIHNjYW5uaW5nXG5kaXJlY3Rpb24gYGRpcmAuIE9ubHkgdGhlIGBicmFja2V0c2AgYW5kIGBtYXhTY2FuRGlzdGFuY2VgXG5wcm9wZXJ0aWVzIGFyZSB1c2VkIGZyb20gYGNvbmZpZ2AsIGlmIGdpdmVuLiBSZXR1cm5zIG51bGwgaWYgbm9cbmJyYWNrZXQgd2FzIGZvdW5kIGF0IGBwb3NgLCBvciBhIG1hdGNoIHJlc3VsdCBvdGhlcndpc2UuXG4qL1xuZnVuY3Rpb24gbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcG9zLCBkaXIsIGNvbmZpZyA9IHt9KSB7XG4gICAgbGV0IG1heFNjYW5EaXN0YW5jZSA9IGNvbmZpZy5tYXhTY2FuRGlzdGFuY2UgfHwgRGVmYXVsdFNjYW5EaXN0LCBicmFja2V0cyA9IGNvbmZpZy5icmFja2V0cyB8fCBEZWZhdWx0QnJhY2tldHM7XG4gICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKHN0YXRlKSwgbm9kZSA9IHRyZWUucmVzb2x2ZUlubmVyKHBvcywgZGlyKTtcbiAgICBmb3IgKGxldCBjdXIgPSBub2RlOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnQpIHtcbiAgICAgICAgbGV0IG1hdGNoZXMgPSBtYXRjaGluZ05vZGVzKGN1ci50eXBlLCBkaXIsIGJyYWNrZXRzKTtcbiAgICAgICAgaWYgKG1hdGNoZXMgJiYgY3VyLmZyb20gPCBjdXIudG8pIHtcbiAgICAgICAgICAgIGxldCBoYW5kbGUgPSBmaW5kSGFuZGxlKGN1cik7XG4gICAgICAgICAgICBpZiAoaGFuZGxlICYmIChkaXIgPiAwID8gcG9zID49IGhhbmRsZS5mcm9tICYmIHBvcyA8IGhhbmRsZS50byA6IHBvcyA+IGhhbmRsZS5mcm9tICYmIHBvcyA8PSBoYW5kbGUudG8pKVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaE1hcmtlZEJyYWNrZXRzKHN0YXRlLCBwb3MsIGRpciwgY3VyLCBoYW5kbGUsIG1hdGNoZXMsIGJyYWNrZXRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hQbGFpbkJyYWNrZXRzKHN0YXRlLCBwb3MsIGRpciwgdHJlZSwgbm9kZS50eXBlLCBtYXhTY2FuRGlzdGFuY2UsIGJyYWNrZXRzKTtcbn1cbmZ1bmN0aW9uIG1hdGNoTWFya2VkQnJhY2tldHMoX3N0YXRlLCBfcG9zLCBkaXIsIHRva2VuLCBoYW5kbGUsIG1hdGNoaW5nLCBicmFja2V0cykge1xuICAgIGxldCBwYXJlbnQgPSB0b2tlbi5wYXJlbnQsIGZpcnN0VG9rZW4gPSB7IGZyb206IGhhbmRsZS5mcm9tLCB0bzogaGFuZGxlLnRvIH07XG4gICAgbGV0IGRlcHRoID0gMCwgY3Vyc29yID0gcGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmN1cnNvcigpO1xuICAgIGlmIChjdXJzb3IgJiYgKGRpciA8IDAgPyBjdXJzb3IuY2hpbGRCZWZvcmUodG9rZW4uZnJvbSkgOiBjdXJzb3IuY2hpbGRBZnRlcih0b2tlbi50bykpKVxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoZGlyIDwgMCA/IGN1cnNvci50byA8PSB0b2tlbi5mcm9tIDogY3Vyc29yLmZyb20gPj0gdG9rZW4udG8pIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVwdGggPT0gMCAmJiBtYXRjaGluZy5pbmRleE9mKGN1cnNvci50eXBlLm5hbWUpID4gLTEgJiYgY3Vyc29yLmZyb20gPCBjdXJzb3IudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVuZEhhbmRsZSA9IGZpbmRIYW5kbGUoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IGZpcnN0VG9rZW4sIGVuZDogZW5kSGFuZGxlID8geyBmcm9tOiBlbmRIYW5kbGUuZnJvbSwgdG86IGVuZEhhbmRsZS50byB9IDogdW5kZWZpbmVkLCBtYXRjaGVkOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoaW5nTm9kZXMoY3Vyc29yLnR5cGUsIGRpciwgYnJhY2tldHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoaW5nTm9kZXMoY3Vyc29yLnR5cGUsIC1kaXIsIGJyYWNrZXRzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVuZEhhbmRsZSA9IGZpbmRIYW5kbGUoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGZpcnN0VG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBlbmRIYW5kbGUgJiYgZW5kSGFuZGxlLmZyb20gPCBlbmRIYW5kbGUudG8gPyB7IGZyb206IGVuZEhhbmRsZS5mcm9tLCB0bzogZW5kSGFuZGxlLnRvIH0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGRpciA8IDAgPyBjdXJzb3IucHJldlNpYmxpbmcoKSA6IGN1cnNvci5uZXh0U2libGluZygpKTtcbiAgICByZXR1cm4geyBzdGFydDogZmlyc3RUb2tlbiwgbWF0Y2hlZDogZmFsc2UgfTtcbn1cbmZ1bmN0aW9uIG1hdGNoUGxhaW5CcmFja2V0cyhzdGF0ZSwgcG9zLCBkaXIsIHRyZWUsIHRva2VuVHlwZSwgbWF4U2NhbkRpc3RhbmNlLCBicmFja2V0cykge1xuICAgIGxldCBzdGFydENoID0gZGlyIDwgMCA/IHN0YXRlLnNsaWNlRG9jKHBvcyAtIDEsIHBvcykgOiBzdGF0ZS5zbGljZURvYyhwb3MsIHBvcyArIDEpO1xuICAgIGxldCBicmFja2V0ID0gYnJhY2tldHMuaW5kZXhPZihzdGFydENoKTtcbiAgICBpZiAoYnJhY2tldCA8IDAgfHwgKGJyYWNrZXQgJSAyID09IDApICE9IChkaXIgPiAwKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHN0YXJ0VG9rZW4gPSB7IGZyb206IGRpciA8IDAgPyBwb3MgLSAxIDogcG9zLCB0bzogZGlyID4gMCA/IHBvcyArIDEgOiBwb3MgfTtcbiAgICBsZXQgaXRlciA9IHN0YXRlLmRvYy5pdGVyUmFuZ2UocG9zLCBkaXIgPiAwID8gc3RhdGUuZG9jLmxlbmd0aCA6IDApLCBkZXB0aCA9IDA7XG4gICAgZm9yIChsZXQgZGlzdGFuY2UgPSAwOyAhKGl0ZXIubmV4dCgpKS5kb25lICYmIGRpc3RhbmNlIDw9IG1heFNjYW5EaXN0YW5jZTspIHtcbiAgICAgICAgbGV0IHRleHQgPSBpdGVyLnZhbHVlO1xuICAgICAgICBpZiAoZGlyIDwgMClcbiAgICAgICAgICAgIGRpc3RhbmNlICs9IHRleHQubGVuZ3RoO1xuICAgICAgICBsZXQgYmFzZVBvcyA9IHBvcyArIGRpc3RhbmNlICogZGlyO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSBkaXIgPiAwID8gMCA6IHRleHQubGVuZ3RoIC0gMSwgZW5kID0gZGlyID4gMCA/IHRleHQubGVuZ3RoIDogLTE7IHBvcyAhPSBlbmQ7IHBvcyArPSBkaXIpIHtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGJyYWNrZXRzLmluZGV4T2YodGV4dFtwb3NdKTtcbiAgICAgICAgICAgIGlmIChmb3VuZCA8IDAgfHwgdHJlZS5yZXNvbHZlSW5uZXIoYmFzZVBvcyArIHBvcywgMSkudHlwZSAhPSB0b2tlblR5cGUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoKGZvdW5kICUgMiA9PSAwKSA9PSAoZGlyID4gMCkpIHtcbiAgICAgICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGVwdGggPT0gMSkgeyAvLyBDbG9zaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0VG9rZW4sIGVuZDogeyBmcm9tOiBiYXNlUG9zICsgcG9zLCB0bzogYmFzZVBvcyArIHBvcyArIDEgfSwgbWF0Y2hlZDogKGZvdW5kID4+IDEpID09IChicmFja2V0ID4+IDEpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkaXIgPiAwKVxuICAgICAgICAgICAgZGlzdGFuY2UgKz0gdGV4dC5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBpdGVyLmRvbmUgPyB7IHN0YXJ0OiBzdGFydFRva2VuLCBtYXRjaGVkOiBmYWxzZSB9IDogbnVsbDtcbn1cblxuLy8gQ291bnRzIHRoZSBjb2x1bW4gb2Zmc2V0IGluIGEgc3RyaW5nLCB0YWtpbmcgdGFicyBpbnRvIGFjY291bnQuXG4vLyBVc2VkIG1vc3RseSB0byBmaW5kIGluZGVudGF0aW9uLlxuZnVuY3Rpb24gY291bnRDb2woc3RyaW5nLCBlbmQsIHRhYlNpemUsIHN0YXJ0SW5kZXggPSAwLCBzdGFydFZhbHVlID0gMCkge1xuICAgIGlmIChlbmQgPT0gbnVsbCkge1xuICAgICAgICBlbmQgPSBzdHJpbmcuc2VhcmNoKC9bXlxcc1xcdTAwYTBdLyk7XG4gICAgICAgIGlmIChlbmQgPT0gLTEpXG4gICAgICAgICAgICBlbmQgPSBzdHJpbmcubGVuZ3RoO1xuICAgIH1cbiAgICBsZXQgbiA9IHN0YXJ0VmFsdWU7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoaSkgPT0gOSlcbiAgICAgICAgICAgIG4gKz0gdGFiU2l6ZSAtIChuICUgdGFiU2l6ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG4rKztcbiAgICB9XG4gICAgcmV0dXJuIG47XG59XG4vKipcbkVuY2Fwc3VsYXRlcyBhIHNpbmdsZSBsaW5lIG9mIGlucHV0LiBHaXZlbiB0byBzdHJlYW0gc3ludGF4IGNvZGUsXG53aGljaCB1c2VzIGl0IHRvIHRva2VuaXplIHRoZSBjb250ZW50LlxuKi9cbmNsYXNzIFN0cmluZ1N0cmVhbSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc3RyZWFtLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGxpbmUuXG4gICAgKi9cbiAgICBzdHJpbmcsIHRhYlNpemUsIFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGluZGVudCB1bml0IHNpemUuXG4gICAgKi9cbiAgICBpbmRlbnRVbml0LCBvdmVycmlkZUluZGVudCkge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICAgICAgdGhpcy50YWJTaXplID0gdGFiU2l6ZTtcbiAgICAgICAgdGhpcy5pbmRlbnRVbml0ID0gaW5kZW50VW5pdDtcbiAgICAgICAgdGhpcy5vdmVycmlkZUluZGVudCA9IG92ZXJyaWRlSW5kZW50O1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIGN1cnJlbnQgcG9zaXRpb24gb24gdGhlIGxpbmUuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCB0b2tlbi5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFydCA9IDA7XG4gICAgICAgIHRoaXMubGFzdENvbHVtblBvcyA9IDA7XG4gICAgICAgIHRoaXMubGFzdENvbHVtblZhbHVlID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ1ZSBpZiB3ZSBhcmUgYXQgdGhlIGVuZCBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIGVvbCgpIHsgcmV0dXJuIHRoaXMucG9zID49IHRoaXMuc3RyaW5nLmxlbmd0aDsgfVxuICAgIC8qKlxuICAgIFRydWUgaWYgd2UgYXJlIGF0IHRoZSBzdGFydCBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIHNvbCgpIHsgcmV0dXJuIHRoaXMucG9zID09IDA7IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIG5leHQgY29kZSB1bml0IGFmdGVyIHRoZSBjdXJyZW50IHBvc2l0aW9uLCBvciB1bmRlZmluZWRcbiAgICBpZiB3ZSdyZSBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lLlxuICAgICovXG4gICAgcGVlaygpIHsgcmV0dXJuIHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcykgfHwgdW5kZWZpbmVkOyB9XG4gICAgLyoqXG4gICAgUmVhZCB0aGUgbmV4dCBjb2RlIHVuaXQgYW5kIGFkdmFuY2UgYHRoaXMucG9zYC5cbiAgICAqL1xuICAgIG5leHQoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcyA8IHRoaXMuc3RyaW5nLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MrKyk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hdGNoIHRoZSBuZXh0IGNoYXJhY3RlciBhZ2FpbnN0IHRoZSBnaXZlbiBzdHJpbmcsIHJlZ3VsYXJcbiAgICBleHByZXNzaW9uLCBvciBwcmVkaWNhdGUuIENvbnN1bWUgYW5kIHJldHVybiBpdCBpZiBpdCBtYXRjaGVzLlxuICAgICovXG4gICAgZWF0KG1hdGNoKSB7XG4gICAgICAgIGxldCBjaCA9IHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcyk7XG4gICAgICAgIGxldCBvaztcbiAgICAgICAgaWYgKHR5cGVvZiBtYXRjaCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgb2sgPSBjaCA9PSBtYXRjaDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgb2sgPSBjaCAmJiAobWF0Y2ggaW5zdGFuY2VvZiBSZWdFeHAgPyBtYXRjaC50ZXN0KGNoKSA6IG1hdGNoKGNoKSk7XG4gICAgICAgIGlmIChvaykge1xuICAgICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgICAgIHJldHVybiBjaDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDb250aW51ZSBtYXRjaGluZyBjaGFyYWN0ZXJzIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIHN0cmluZyxcbiAgICByZWd1bGFyIGV4cHJlc3Npb24sIG9yIHByZWRpY2F0ZSBmdW5jdGlvbi4gUmV0dXJuIHRydWUgaWYgYW55XG4gICAgY2hhcmFjdGVycyB3ZXJlIGNvbnN1bWVkLlxuICAgICovXG4gICAgZWF0V2hpbGUobWF0Y2gpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIHdoaWxlICh0aGlzLmVhdChtYXRjaCkpIHsgfVxuICAgICAgICByZXR1cm4gdGhpcy5wb3MgPiBzdGFydDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29uc3VtZSB3aGl0ZXNwYWNlIGFoZWFkIG9mIGB0aGlzLnBvc2AuIFJldHVybiB0cnVlIGlmIGFueSB3YXNcbiAgICBmb3VuZC5cbiAgICAqL1xuICAgIGVhdFNwYWNlKCkge1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgd2hpbGUgKC9bXFxzXFx1MDBhMF0vLnRlc3QodGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKSkpXG4gICAgICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICByZXR1cm4gdGhpcy5wb3MgPiBzdGFydDtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgZW5kIG9mIHRoZSBsaW5lLlxuICAgICovXG4gICAgc2tpcFRvRW5kKCkgeyB0aGlzLnBvcyA9IHRoaXMuc3RyaW5nLmxlbmd0aDsgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gZGlyZWN0bHkgYmVmb3JlIHRoZSBnaXZlbiBjaGFyYWN0ZXIsIGlmIGZvdW5kIG9uIHRoZVxuICAgIGN1cnJlbnQgbGluZS5cbiAgICAqL1xuICAgIHNraXBUbyhjaCkge1xuICAgICAgICBsZXQgZm91bmQgPSB0aGlzLnN0cmluZy5pbmRleE9mKGNoLCB0aGlzLnBvcyk7XG4gICAgICAgIGlmIChmb3VuZCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IGZvdW5kO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSBiYWNrIGBuYCBjaGFyYWN0ZXJzLlxuICAgICovXG4gICAgYmFja1VwKG4pIHsgdGhpcy5wb3MgLT0gbjsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY29sdW1uIHBvc2l0aW9uIGF0IGB0aGlzLnBvc2AuXG4gICAgKi9cbiAgICBjb2x1bW4oKSB7XG4gICAgICAgIGlmICh0aGlzLmxhc3RDb2x1bW5Qb3MgPCB0aGlzLnN0YXJ0KSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb2x1bW5WYWx1ZSA9IGNvdW50Q29sKHRoaXMuc3RyaW5nLCB0aGlzLnN0YXJ0LCB0aGlzLnRhYlNpemUsIHRoaXMubGFzdENvbHVtblBvcywgdGhpcy5sYXN0Q29sdW1uVmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5sYXN0Q29sdW1uUG9zID0gdGhpcy5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sYXN0Q29sdW1uVmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgaW5kZW50YXRpb24gY29sdW1uIG9mIHRoZSBjdXJyZW50IGxpbmUuXG4gICAgKi9cbiAgICBpbmRlbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5vdmVycmlkZUluZGVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY291bnRDb2wodGhpcy5zdHJpbmcsIG51bGwsIHRoaXMudGFiU2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hdGNoIHRoZSBpbnB1dCBhZ2FpbnN0IHRoZSBnaXZlbiBzdHJpbmcgb3IgcmVndWxhciBleHByZXNzaW9uXG4gICAgKHdoaWNoIHNob3VsZCBzdGFydCB3aXRoIGEgYF5gKS4gUmV0dXJuIHRydWUgb3IgdGhlIHJlZ2V4cCBtYXRjaFxuICAgIGlmIGl0IG1hdGNoZXMuXG4gICAgXG4gICAgVW5sZXNzIGBjb25zdW1lYCBpcyBzZXQgdG8gYGZhbHNlYCwgdGhpcyB3aWxsIG1vdmUgYHRoaXMucG9zYFxuICAgIHBhc3QgdGhlIG1hdGNoZWQgdGV4dC5cbiAgICBcbiAgICBXaGVuIG1hdGNoaW5nIGEgc3RyaW5nIGBjYXNlSW5zZW5zaXRpdmVgIGNhbiBiZSBzZXQgdG8gdHJ1ZSB0b1xuICAgIG1ha2UgdGhlIG1hdGNoIGNhc2UtaW5zZW5zaXRpdmUuXG4gICAgKi9cbiAgICBtYXRjaChwYXR0ZXJuLCBjb25zdW1lLCBjYXNlSW5zZW5zaXRpdmUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGxldCBjYXNlZCA9IChzdHIpID0+IGNhc2VJbnNlbnNpdGl2ZSA/IHN0ci50b0xvd2VyQ2FzZSgpIDogc3RyO1xuICAgICAgICAgICAgbGV0IHN1YnN0ciA9IHRoaXMuc3RyaW5nLnN1YnN0cih0aGlzLnBvcywgcGF0dGVybi5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKGNhc2VkKHN1YnN0cikgPT0gY2FzZWQocGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uc3VtZSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IHBhdHRlcm4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5zdHJpbmcuc2xpY2UodGhpcy5wb3MpLm1hdGNoKHBhdHRlcm4pO1xuICAgICAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmluZGV4ID4gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChtYXRjaCAmJiBjb25zdW1lICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjdXJyZW50IHRva2VuLlxuICAgICovXG4gICAgY3VycmVudCgpIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMucG9zKTsgfVxufVxuXG5mdW5jdGlvbiBmdWxsUGFyc2VyKHNwZWMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBzcGVjLm5hbWUgfHwgXCJcIixcbiAgICAgICAgdG9rZW46IHNwZWMudG9rZW4sXG4gICAgICAgIGJsYW5rTGluZTogc3BlYy5ibGFua0xpbmUgfHwgKCgpID0+IHsgfSksXG4gICAgICAgIHN0YXJ0U3RhdGU6IHNwZWMuc3RhcnRTdGF0ZSB8fCAoKCkgPT4gdHJ1ZSksXG4gICAgICAgIGNvcHlTdGF0ZTogc3BlYy5jb3B5U3RhdGUgfHwgZGVmYXVsdENvcHlTdGF0ZSxcbiAgICAgICAgaW5kZW50OiBzcGVjLmluZGVudCB8fCAoKCkgPT4gbnVsbCksXG4gICAgICAgIGxhbmd1YWdlRGF0YTogc3BlYy5sYW5ndWFnZURhdGEgfHwge30sXG4gICAgICAgIHRva2VuVGFibGU6IHNwZWMudG9rZW5UYWJsZSB8fCBub1Rva2Vuc1xuICAgIH07XG59XG5mdW5jdGlvbiBkZWZhdWx0Q29weVN0YXRlKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSAhPSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgbGV0IG5ld1N0YXRlID0ge307XG4gICAgZm9yIChsZXQgcHJvcCBpbiBzdGF0ZSkge1xuICAgICAgICBsZXQgdmFsID0gc3RhdGVbcHJvcF07XG4gICAgICAgIG5ld1N0YXRlW3Byb3BdID0gKHZhbCBpbnN0YW5jZW9mIEFycmF5ID8gdmFsLnNsaWNlKCkgOiB2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3U3RhdGU7XG59XG5jb25zdCBJbmRlbnRlZEZyb20gPSAvKkBfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbi8qKlxuQSBbbGFuZ3VhZ2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpIGNsYXNzIGJhc2VkIG9uIGEgQ29kZU1pcnJvclxuNS1zdHlsZSBbc3RyZWFtaW5nIHBhcnNlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5TdHJlYW1QYXJzZXIpLlxuKi9cbmNsYXNzIFN0cmVhbUxhbmd1YWdlIGV4dGVuZHMgTGFuZ3VhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgICAgICBsZXQgZGF0YSA9IGRlZmluZUxhbmd1YWdlRmFjZXQocGFyc2VyLmxhbmd1YWdlRGF0YSk7XG4gICAgICAgIGxldCBwID0gZnVsbFBhcnNlcihwYXJzZXIpLCBzZWxmO1xuICAgICAgICBsZXQgaW1wbCA9IG5ldyBjbGFzcyBleHRlbmRzIFBhcnNlciB7XG4gICAgICAgICAgICBjcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBhcnNlKHNlbGYsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyKGRhdGEsIGltcGwsIFtpbmRlbnRTZXJ2aWNlLm9mKChjeCwgcG9zKSA9PiB0aGlzLmdldEluZGVudChjeCwgcG9zKSldLCBwYXJzZXIubmFtZSk7XG4gICAgICAgIHRoaXMudG9wTm9kZSA9IGRvY0lEKGRhdGEpO1xuICAgICAgICBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5zdHJlYW1QYXJzZXIgPSBwO1xuICAgICAgICB0aGlzLnN0YXRlQWZ0ZXIgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLnRva2VuVGFibGUgPSBwYXJzZXIudG9rZW5UYWJsZSA/IG5ldyBUb2tlblRhYmxlKHAudG9rZW5UYWJsZSkgOiBkZWZhdWx0VG9rZW5UYWJsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgc3RyZWFtIGxhbmd1YWdlLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7IHJldHVybiBuZXcgU3RyZWFtTGFuZ3VhZ2Uoc3BlYyk7IH1cbiAgICBnZXRJbmRlbnQoY3gsIHBvcykge1xuICAgICAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoY3guc3RhdGUpLCBhdCA9IHRyZWUucmVzb2x2ZShwb3MpO1xuICAgICAgICB3aGlsZSAoYXQgJiYgYXQudHlwZSAhPSB0aGlzLnRvcE5vZGUpXG4gICAgICAgICAgICBhdCA9IGF0LnBhcmVudDtcbiAgICAgICAgaWYgKCFhdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgZnJvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHsgb3ZlcnJpZGVJbmRlbnRhdGlvbiB9ID0gY3gub3B0aW9ucztcbiAgICAgICAgaWYgKG92ZXJyaWRlSW5kZW50YXRpb24pIHtcbiAgICAgICAgICAgIGZyb20gPSBJbmRlbnRlZEZyb20uZ2V0KGN4LnN0YXRlKTtcbiAgICAgICAgICAgIGlmIChmcm9tICE9IG51bGwgJiYgZnJvbSA8IHBvcyAtIDFlNClcbiAgICAgICAgICAgICAgICBmcm9tID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydCA9IGZpbmRTdGF0ZSh0aGlzLCB0cmVlLCAwLCBhdC5mcm9tLCBmcm9tICE9PSBudWxsICYmIGZyb20gIT09IHZvaWQgMCA/IGZyb20gOiBwb3MpLCBzdGF0ZVBvcywgc3RhdGU7XG4gICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBzdGFydC5zdGF0ZTtcbiAgICAgICAgICAgIHN0YXRlUG9zID0gc3RhcnQucG9zICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gdGhpcy5zdHJlYW1QYXJzZXIuc3RhcnRTdGF0ZShjeC51bml0KTtcbiAgICAgICAgICAgIHN0YXRlUG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zIC0gc3RhdGVQb3MgPiAxMDAwMCAvKiBDLk1heEluZGVudFNjYW5EaXN0ICovKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHdoaWxlIChzdGF0ZVBvcyA8IHBvcykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBjeC5zdGF0ZS5kb2MubGluZUF0KHN0YXRlUG9zKSwgZW5kID0gTWF0aC5taW4ocG9zLCBsaW5lLnRvKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBpbmRlbnRhdGlvbiA9IG92ZXJyaWRlSW5kZW50YXRpb24gPyBvdmVycmlkZUluZGVudGF0aW9uKGxpbmUuZnJvbSkgOiAtMTtcbiAgICAgICAgICAgICAgICBsZXQgc3RyZWFtID0gbmV3IFN0cmluZ1N0cmVhbShsaW5lLnRleHQsIGN4LnN0YXRlLnRhYlNpemUsIGN4LnVuaXQsIGluZGVudGF0aW9uIDwgMCA/IHVuZGVmaW5lZCA6IGluZGVudGF0aW9uKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyZWFtLnBvcyA8IGVuZCAtIGxpbmUuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgcmVhZFRva2VuKHRoaXMuc3RyZWFtUGFyc2VyLnRva2VuLCBzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtUGFyc2VyLmJsYW5rTGluZShzdGF0ZSwgY3gudW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kID09IHBvcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN0YXRlUG9zID0gbGluZS50byArIDE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxpbmUgPSBjeC5saW5lQXQocG9zKTtcbiAgICAgICAgaWYgKG92ZXJyaWRlSW5kZW50YXRpb24gJiYgZnJvbSA9PSBudWxsKVxuICAgICAgICAgICAgSW5kZW50ZWRGcm9tLnNldChjeC5zdGF0ZSwgbGluZS5mcm9tKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtUGFyc2VyLmluZGVudChzdGF0ZSwgL15cXHMqKC4qKS8uZXhlYyhsaW5lLnRleHQpWzFdLCBjeCk7XG4gICAgfVxuICAgIGdldCBhbGxvd3NOZXN0aW5nKCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbmZ1bmN0aW9uIGZpbmRTdGF0ZShsYW5nLCB0cmVlLCBvZmYsIHN0YXJ0UG9zLCBiZWZvcmUpIHtcbiAgICBsZXQgc3RhdGUgPSBvZmYgPj0gc3RhcnRQb3MgJiYgb2ZmICsgdHJlZS5sZW5ndGggPD0gYmVmb3JlICYmIHRyZWUucHJvcChsYW5nLnN0YXRlQWZ0ZXIpO1xuICAgIGlmIChzdGF0ZSlcbiAgICAgICAgcmV0dXJuIHsgc3RhdGU6IGxhbmcuc3RyZWFtUGFyc2VyLmNvcHlTdGF0ZShzdGF0ZSksIHBvczogb2ZmICsgdHJlZS5sZW5ndGggfTtcbiAgICBmb3IgKGxldCBpID0gdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgY2hpbGQgPSB0cmVlLmNoaWxkcmVuW2ldLCBwb3MgPSBvZmYgKyB0cmVlLnBvc2l0aW9uc1tpXTtcbiAgICAgICAgbGV0IGZvdW5kID0gY2hpbGQgaW5zdGFuY2VvZiBUcmVlICYmIHBvcyA8IGJlZm9yZSAmJiBmaW5kU3RhdGUobGFuZywgY2hpbGQsIHBvcywgc3RhcnRQb3MsIGJlZm9yZSk7XG4gICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjdXRUcmVlKGxhbmcsIHRyZWUsIGZyb20sIHRvLCBpbnNpZGUpIHtcbiAgICBpZiAoaW5zaWRlICYmIGZyb20gPD0gMCAmJiB0byA+PSB0cmVlLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgaWYgKCFpbnNpZGUgJiYgdHJlZS50eXBlID09IGxhbmcudG9wTm9kZSlcbiAgICAgICAgaW5zaWRlID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgcG9zID0gdHJlZS5wb3NpdGlvbnNbaV0sIGNoaWxkID0gdHJlZS5jaGlsZHJlbltpXSwgaW5uZXI7XG4gICAgICAgIGlmIChwb3MgPCB0byAmJiBjaGlsZCBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgIGlmICghKGlubmVyID0gY3V0VHJlZShsYW5nLCBjaGlsZCwgZnJvbSAtIHBvcywgdG8gLSBwb3MsIGluc2lkZSkpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcmV0dXJuICFpbnNpZGUgPyBpbm5lclxuICAgICAgICAgICAgICAgIDogbmV3IFRyZWUodHJlZS50eXBlLCB0cmVlLmNoaWxkcmVuLnNsaWNlKDAsIGkpLmNvbmNhdChpbm5lciksIHRyZWUucG9zaXRpb25zLnNsaWNlKDAsIGkgKyAxKSwgcG9zICsgaW5uZXIubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRTdGFydEluRnJhZ21lbnRzKGxhbmcsIGZyYWdtZW50cywgc3RhcnRQb3MsIGVkaXRvclN0YXRlKSB7XG4gICAgZm9yIChsZXQgZiBvZiBmcmFnbWVudHMpIHtcbiAgICAgICAgbGV0IGZyb20gPSBmLmZyb20gKyAoZi5vcGVuU3RhcnQgPyAyNSA6IDApLCB0byA9IGYudG8gLSAoZi5vcGVuRW5kID8gMjUgOiAwKTtcbiAgICAgICAgbGV0IGZvdW5kID0gZnJvbSA8PSBzdGFydFBvcyAmJiB0byA+IHN0YXJ0UG9zICYmIGZpbmRTdGF0ZShsYW5nLCBmLnRyZWUsIDAgLSBmLm9mZnNldCwgc3RhcnRQb3MsIHRvKSwgdHJlZTtcbiAgICAgICAgaWYgKGZvdW5kICYmICh0cmVlID0gY3V0VHJlZShsYW5nLCBmLnRyZWUsIHN0YXJ0UG9zICsgZi5vZmZzZXQsIGZvdW5kLnBvcyArIGYub2Zmc2V0LCBmYWxzZSkpKVxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdGU6IGZvdW5kLnN0YXRlLCB0cmVlIH07XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXRlOiBsYW5nLnN0cmVhbVBhcnNlci5zdGFydFN0YXRlKGVkaXRvclN0YXRlID8gZ2V0SW5kZW50VW5pdChlZGl0b3JTdGF0ZSkgOiA0KSwgdHJlZTogVHJlZS5lbXB0eSB9O1xufVxuY2xhc3MgUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKGxhbmcsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICB0aGlzLmxhbmcgPSBsYW5nO1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBudWxsO1xuICAgICAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rUG9zID0gW107XG4gICAgICAgIHRoaXMuY2h1bmsgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua1JldXNlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy50byA9IHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0udG87XG4gICAgICAgIGxldCBjb250ZXh0ID0gUGFyc2VDb250ZXh0LmdldCgpLCBmcm9tID0gcmFuZ2VzWzBdLmZyb207XG4gICAgICAgIGxldCB7IHN0YXRlLCB0cmVlIH0gPSBmaW5kU3RhcnRJbkZyYWdtZW50cyhsYW5nLCBmcmFnbWVudHMsIGZyb20sIGNvbnRleHQgPT09IG51bGwgfHwgY29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGV4dC5zdGF0ZSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5wYXJzZWRQb3MgPSB0aGlzLmNodW5rU3RhcnQgPSBmcm9tICsgdHJlZS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJlZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jaHVua3MucHVzaCh0cmVlLmNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtQb3MucHVzaCh0cmVlLnBvc2l0aW9uc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRleHQgJiYgdGhpcy5wYXJzZWRQb3MgPCBjb250ZXh0LnZpZXdwb3J0LmZyb20gLSAxMDAwMDAgLyogQy5NYXhEaXN0YW5jZUJlZm9yZVZpZXdwb3J0ICovKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5sYW5nLnN0cmVhbVBhcnNlci5zdGFydFN0YXRlKGdldEluZGVudFVuaXQoY29udGV4dC5zdGF0ZSkpO1xuICAgICAgICAgICAgY29udGV4dC5za2lwVW50aWxJblZpZXcodGhpcy5wYXJzZWRQb3MsIGNvbnRleHQudmlld3BvcnQuZnJvbSk7XG4gICAgICAgICAgICB0aGlzLnBhcnNlZFBvcyA9IGNvbnRleHQudmlld3BvcnQuZnJvbTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdmVSYW5nZUluZGV4KCk7XG4gICAgfVxuICAgIGFkdmFuY2UoKSB7XG4gICAgICAgIGxldCBjb250ZXh0ID0gUGFyc2VDb250ZXh0LmdldCgpO1xuICAgICAgICBsZXQgcGFyc2VFbmQgPSB0aGlzLnN0b3BwZWRBdCA9PSBudWxsID8gdGhpcy50byA6IE1hdGgubWluKHRoaXMudG8sIHRoaXMuc3RvcHBlZEF0KTtcbiAgICAgICAgbGV0IGVuZCA9IE1hdGgubWluKHBhcnNlRW5kLCB0aGlzLmNodW5rU3RhcnQgKyAyMDQ4IC8qIEMuQ2h1bmtTaXplICovKTtcbiAgICAgICAgaWYgKGNvbnRleHQpXG4gICAgICAgICAgICBlbmQgPSBNYXRoLm1pbihlbmQsIGNvbnRleHQudmlld3BvcnQudG8pO1xuICAgICAgICB3aGlsZSAodGhpcy5wYXJzZWRQb3MgPCBlbmQpXG4gICAgICAgICAgICB0aGlzLnBhcnNlTGluZShjb250ZXh0KTtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtTdGFydCA8IHRoaXMucGFyc2VkUG9zKVxuICAgICAgICAgICAgdGhpcy5maW5pc2hDaHVuaygpO1xuICAgICAgICBpZiAodGhpcy5wYXJzZWRQb3MgPj0gcGFyc2VFbmQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2goKTtcbiAgICAgICAgaWYgKGNvbnRleHQgJiYgdGhpcy5wYXJzZWRQb3MgPj0gY29udGV4dC52aWV3cG9ydC50bykge1xuICAgICAgICAgICAgY29udGV4dC5za2lwVW50aWxJblZpZXcodGhpcy5wYXJzZWRQb3MsIHBhcnNlRW5kKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdG9wQXQocG9zKSB7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gcG9zO1xuICAgIH1cbiAgICBsaW5lQWZ0ZXIocG9zKSB7XG4gICAgICAgIGxldCBjaHVuayA9IHRoaXMuaW5wdXQuY2h1bmsocG9zKTtcbiAgICAgICAgaWYgKCF0aGlzLmlucHV0LmxpbmVDaHVua3MpIHtcbiAgICAgICAgICAgIGxldCBlb2wgPSBjaHVuay5pbmRleE9mKFwiXFxuXCIpO1xuICAgICAgICAgICAgaWYgKGVvbCA+IC0xKVxuICAgICAgICAgICAgICAgIGNodW5rID0gY2h1bmsuc2xpY2UoMCwgZW9sKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaHVuayA9PSBcIlxcblwiKSB7XG4gICAgICAgICAgICBjaHVuayA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcyArIGNodW5rLmxlbmd0aCA8PSB0aGlzLnRvID8gY2h1bmsgOiBjaHVuay5zbGljZSgwLCB0aGlzLnRvIC0gcG9zKTtcbiAgICB9XG4gICAgbmV4dExpbmUoKSB7XG4gICAgICAgIGxldCBmcm9tID0gdGhpcy5wYXJzZWRQb3MsIGxpbmUgPSB0aGlzLmxpbmVBZnRlcihmcm9tKSwgZW5kID0gZnJvbSArIGxpbmUubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IHRoaXMucmFuZ2VJbmRleDs7KSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2VFbmQgPSB0aGlzLnJhbmdlc1tpbmRleF0udG87XG4gICAgICAgICAgICBpZiAocmFuZ2VFbmQgPj0gZW5kKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UoMCwgcmFuZ2VFbmQgLSAoZW5kIC0gbGluZS5sZW5ndGgpKTtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5yYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IHJhbmdlU3RhcnQgPSB0aGlzLnJhbmdlc1tpbmRleF0uZnJvbTtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IHRoaXMubGluZUFmdGVyKHJhbmdlU3RhcnQpO1xuICAgICAgICAgICAgbGluZSArPSBhZnRlcjtcbiAgICAgICAgICAgIGVuZCA9IHJhbmdlU3RhcnQgKyBhZnRlci5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbGluZSwgZW5kIH07XG4gICAgfVxuICAgIHNraXBHYXBzVG8ocG9zLCBvZmZzZXQsIHNpZGUpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGVuZCA9IHRoaXMucmFuZ2VzW3RoaXMucmFuZ2VJbmRleF0udG8sIG9mZlBvcyA9IHBvcyArIG9mZnNldDtcbiAgICAgICAgICAgIGlmIChzaWRlID4gMCA/IGVuZCA+IG9mZlBvcyA6IGVuZCA+PSBvZmZQb3MpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnJhbmdlc1srK3RoaXMucmFuZ2VJbmRleF0uZnJvbTtcbiAgICAgICAgICAgIG9mZnNldCArPSBzdGFydCAtIGVuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgICBtb3ZlUmFuZ2VJbmRleCgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMucmFuZ2VzW3RoaXMucmFuZ2VJbmRleF0udG8gPCB0aGlzLnBhcnNlZFBvcylcbiAgICAgICAgICAgIHRoaXMucmFuZ2VJbmRleCsrO1xuICAgIH1cbiAgICBlbWl0VG9rZW4oaWQsIGZyb20sIHRvLCBzaXplLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuc2tpcEdhcHNUbyhmcm9tLCBvZmZzZXQsIDEpO1xuICAgICAgICAgICAgZnJvbSArPSBvZmZzZXQ7XG4gICAgICAgICAgICBsZXQgbGVuMCA9IHRoaXMuY2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5za2lwR2Fwc1RvKHRvLCBvZmZzZXQsIC0xKTtcbiAgICAgICAgICAgIHRvICs9IG9mZnNldDtcbiAgICAgICAgICAgIHNpemUgKz0gdGhpcy5jaHVuay5sZW5ndGggLSBsZW4wO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2h1bmsucHVzaChpZCwgZnJvbSwgdG8sIHNpemUpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgICBwYXJzZUxpbmUoY29udGV4dCkge1xuICAgICAgICBsZXQgeyBsaW5lLCBlbmQgfSA9IHRoaXMubmV4dExpbmUoKSwgb2Zmc2V0ID0gMCwgeyBzdHJlYW1QYXJzZXIgfSA9IHRoaXMubGFuZztcbiAgICAgICAgbGV0IHN0cmVhbSA9IG5ldyBTdHJpbmdTdHJlYW0obGluZSwgY29udGV4dCA/IGNvbnRleHQuc3RhdGUudGFiU2l6ZSA6IDQsIGNvbnRleHQgPyBnZXRJbmRlbnRVbml0KGNvbnRleHQuc3RhdGUpIDogMik7XG4gICAgICAgIGlmIChzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgICAgIHN0cmVhbVBhcnNlci5ibGFua0xpbmUodGhpcy5zdGF0ZSwgc3RyZWFtLmluZGVudFVuaXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgdG9rZW4gPSByZWFkVG9rZW4oc3RyZWFtUGFyc2VyLnRva2VuLCBzdHJlYW0sIHRoaXMuc3RhdGUpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbilcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5lbWl0VG9rZW4odGhpcy5sYW5nLnRva2VuVGFibGUucmVzb2x2ZSh0b2tlbiksIHRoaXMucGFyc2VkUG9zICsgc3RyZWFtLnN0YXJ0LCB0aGlzLnBhcnNlZFBvcyArIHN0cmVhbS5wb3MsIDQsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5zdGFydCA+IDEwMDAwIC8qIEMuTWF4TGluZUxlbmd0aCAqLylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJzZWRQb3MgPSBlbmQ7XG4gICAgICAgIHRoaXMubW92ZVJhbmdlSW5kZXgoKTtcbiAgICAgICAgaWYgKHRoaXMucGFyc2VkUG9zIDwgdGhpcy50bylcbiAgICAgICAgICAgIHRoaXMucGFyc2VkUG9zKys7XG4gICAgfVxuICAgIGZpbmlzaENodW5rKCkge1xuICAgICAgICBsZXQgdHJlZSA9IFRyZWUuYnVpbGQoe1xuICAgICAgICAgICAgYnVmZmVyOiB0aGlzLmNodW5rLFxuICAgICAgICAgICAgc3RhcnQ6IHRoaXMuY2h1bmtTdGFydCxcbiAgICAgICAgICAgIGxlbmd0aDogdGhpcy5wYXJzZWRQb3MgLSB0aGlzLmNodW5rU3RhcnQsXG4gICAgICAgICAgICBub2RlU2V0LFxuICAgICAgICAgICAgdG9wSUQ6IDAsXG4gICAgICAgICAgICBtYXhCdWZmZXJMZW5ndGg6IDIwNDggLyogQy5DaHVua1NpemUgKi8sXG4gICAgICAgICAgICByZXVzZWQ6IHRoaXMuY2h1bmtSZXVzZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHRyZWUgPSBuZXcgVHJlZSh0cmVlLnR5cGUsIHRyZWUuY2hpbGRyZW4sIHRyZWUucG9zaXRpb25zLCB0cmVlLmxlbmd0aCwgW1t0aGlzLmxhbmcuc3RhdGVBZnRlciwgdGhpcy5sYW5nLnN0cmVhbVBhcnNlci5jb3B5U3RhdGUodGhpcy5zdGF0ZSldXSk7XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2godHJlZSk7XG4gICAgICAgIHRoaXMuY2h1bmtQb3MucHVzaCh0aGlzLmNodW5rU3RhcnQgLSB0aGlzLnJhbmdlc1swXS5mcm9tKTtcbiAgICAgICAgdGhpcy5jaHVuayA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rUmV1c2VkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNodW5rU3RhcnQgPSB0aGlzLnBhcnNlZFBvcztcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWUodGhpcy5sYW5nLnRvcE5vZGUsIHRoaXMuY2h1bmtzLCB0aGlzLmNodW5rUG9zLCB0aGlzLnBhcnNlZFBvcyAtIHRoaXMucmFuZ2VzWzBdLmZyb20pLmJhbGFuY2UoKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZWFkVG9rZW4odG9rZW4sIHN0cmVhbSwgc3RhdGUpIHtcbiAgICBzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdG9rZW4oc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIGlmIChzdHJlYW0ucG9zID4gc3RyZWFtLnN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyZWFtIHBhcnNlciBmYWlsZWQgdG8gYWR2YW5jZSBzdHJlYW0uXCIpO1xufVxuY29uc3Qgbm9Ub2tlbnMgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbmNvbnN0IHR5cGVBcnJheSA9IFtOb2RlVHlwZS5ub25lXTtcbmNvbnN0IG5vZGVTZXQgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVTZXQodHlwZUFycmF5KTtcbmNvbnN0IHdhcm5lZCA9IFtdO1xuLy8gQ2FjaGUgb2Ygbm9kZSB0eXBlcyBieSBuYW1lIGFuZCB0YWdzXG5jb25zdCBieVRhZyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuY29uc3QgZGVmYXVsdFRhYmxlID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG5mb3IgKGxldCBbbGVnYWN5TmFtZSwgbmFtZV0gb2YgW1xuICAgIFtcInZhcmlhYmxlXCIsIFwidmFyaWFibGVOYW1lXCJdLFxuICAgIFtcInZhcmlhYmxlLTJcIiwgXCJ2YXJpYWJsZU5hbWUuc3BlY2lhbFwiXSxcbiAgICBbXCJzdHJpbmctMlwiLCBcInN0cmluZy5zcGVjaWFsXCJdLFxuICAgIFtcImRlZlwiLCBcInZhcmlhYmxlTmFtZS5kZWZpbml0aW9uXCJdLFxuICAgIFtcInRhZ1wiLCBcInRhZ05hbWVcIl0sXG4gICAgW1wiYXR0cmlidXRlXCIsIFwiYXR0cmlidXRlTmFtZVwiXSxcbiAgICBbXCJ0eXBlXCIsIFwidHlwZU5hbWVcIl0sXG4gICAgW1wiYnVpbHRpblwiLCBcInZhcmlhYmxlTmFtZS5zdGFuZGFyZFwiXSxcbiAgICBbXCJxdWFsaWZpZXJcIiwgXCJtb2RpZmllclwiXSxcbiAgICBbXCJlcnJvclwiLCBcImludmFsaWRcIl0sXG4gICAgW1wiaGVhZGVyXCIsIFwiaGVhZGluZ1wiXSxcbiAgICBbXCJwcm9wZXJ0eVwiLCBcInByb3BlcnR5TmFtZVwiXVxuXSlcbiAgICBkZWZhdWx0VGFibGVbbGVnYWN5TmFtZV0gPSAvKkBfX1BVUkVfXyovY3JlYXRlVG9rZW5UeXBlKG5vVG9rZW5zLCBuYW1lKTtcbmNsYXNzIFRva2VuVGFibGUge1xuICAgIGNvbnN0cnVjdG9yKGV4dHJhKSB7XG4gICAgICAgIHRoaXMuZXh0cmEgPSBleHRyYTtcbiAgICAgICAgdGhpcy50YWJsZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgZGVmYXVsdFRhYmxlKTtcbiAgICB9XG4gICAgcmVzb2x2ZSh0YWcpIHtcbiAgICAgICAgcmV0dXJuICF0YWcgPyAwIDogdGhpcy50YWJsZVt0YWddIHx8ICh0aGlzLnRhYmxlW3RhZ10gPSBjcmVhdGVUb2tlblR5cGUodGhpcy5leHRyYSwgdGFnKSk7XG4gICAgfVxufVxuY29uc3QgZGVmYXVsdFRva2VuVGFibGUgPSAvKkBfX1BVUkVfXyovbmV3IFRva2VuVGFibGUobm9Ub2tlbnMpO1xuZnVuY3Rpb24gd2FybkZvclBhcnQocGFydCwgbXNnKSB7XG4gICAgaWYgKHdhcm5lZC5pbmRleE9mKHBhcnQpID4gLTEpXG4gICAgICAgIHJldHVybjtcbiAgICB3YXJuZWQucHVzaChwYXJ0KTtcbiAgICBjb25zb2xlLndhcm4obXNnKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRva2VuVHlwZShleHRyYSwgdGFnU3RyKSB7XG4gICAgbGV0IHRhZ3MkMSA9IFtdO1xuICAgIGZvciAobGV0IG5hbWUgb2YgdGFnU3RyLnNwbGl0KFwiIFwiKSkge1xuICAgICAgICBsZXQgZm91bmQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcGFydCBvZiBuYW1lLnNwbGl0KFwiLlwiKSkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gKGV4dHJhW3BhcnRdIHx8IHRhZ3NbcGFydF0pO1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHdhcm5Gb3JQYXJ0KHBhcnQsIGBVbmtub3duIGhpZ2hsaWdodGluZyB0YWcgJHtwYXJ0fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGlmICghZm91bmQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB3YXJuRm9yUGFydChwYXJ0LCBgTW9kaWZpZXIgJHtwYXJ0fSB1c2VkIGF0IHN0YXJ0IG9mIHRhZ2ApO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBmb3VuZC5tYXAodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgd2FybkZvclBhcnQocGFydCwgYFRhZyAke3BhcnR9IHVzZWQgYXMgbW9kaWZpZXJgKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgdGFnIG9mIGZvdW5kKVxuICAgICAgICAgICAgdGFncyQxLnB1c2godGFnKTtcbiAgICB9XG4gICAgaWYgKCF0YWdzJDEubGVuZ3RoKVxuICAgICAgICByZXR1cm4gMDtcbiAgICBsZXQgbmFtZSA9IHRhZ1N0ci5yZXBsYWNlKC8gL2csIFwiX1wiKSwga2V5ID0gbmFtZSArIFwiIFwiICsgdGFncyQxLm1hcCh0ID0+IHQuaWQpO1xuICAgIGxldCBrbm93biA9IGJ5VGFnW2tleV07XG4gICAgaWYgKGtub3duKVxuICAgICAgICByZXR1cm4ga25vd24uaWQ7XG4gICAgbGV0IHR5cGUgPSBieVRhZ1trZXldID0gTm9kZVR5cGUuZGVmaW5lKHtcbiAgICAgICAgaWQ6IHR5cGVBcnJheS5sZW5ndGgsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHByb3BzOiBbc3R5bGVUYWdzKHsgW25hbWVdOiB0YWdzJDEgfSldXG4gICAgfSk7XG4gICAgdHlwZUFycmF5LnB1c2godHlwZSk7XG4gICAgcmV0dXJuIHR5cGUuaWQ7XG59XG5mdW5jdGlvbiBkb2NJRChkYXRhKSB7XG4gICAgbGV0IHR5cGUgPSBOb2RlVHlwZS5kZWZpbmUoeyBpZDogdHlwZUFycmF5Lmxlbmd0aCwgbmFtZTogXCJEb2N1bWVudFwiLCBwcm9wczogW2xhbmd1YWdlRGF0YVByb3AuYWRkKCgpID0+IGRhdGEpXSwgdG9wOiB0cnVlIH0pO1xuICAgIHR5cGVBcnJheS5wdXNoKHR5cGUpO1xuICAgIHJldHVybiB0eXBlO1xufVxuXG5mdW5jdGlvbiBidWlsZEZvckxpbmUobGluZSkge1xuICAgIHJldHVybiBsaW5lLmxlbmd0aCA8PSA0MDk2ICYmIC9bXFx1MDU5MC1cXHUwNWY0XFx1MDYwMC1cXHUwNmZmXFx1MDcwMC1cXHUwOGFjXFx1ZmI1MC1cXHVmZGZmXS8udGVzdChsaW5lKTtcbn1cbmZ1bmN0aW9uIHRleHRIYXNSVEwodGV4dCkge1xuICAgIGZvciAobGV0IGkgPSB0ZXh0Lml0ZXIoKTsgIWkubmV4dCgpLmRvbmU7KVxuICAgICAgICBpZiAoYnVpbGRGb3JMaW5lKGkudmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY2hhbmdlQWRkc1JUTChjaGFuZ2UpIHtcbiAgICBsZXQgYWRkZWQgPSBmYWxzZTtcbiAgICBjaGFuZ2UuaXRlckNoYW5nZXMoKGZBLCB0QSwgZkIsIHRCLCBpbnMpID0+IHtcbiAgICAgICAgaWYgKCFhZGRlZCAmJiB0ZXh0SGFzUlRMKGlucykpXG4gICAgICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFkZGVkO1xufVxuY29uc3QgYWx3YXlzSXNvbGF0ZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnNvbWUoeCA9PiB4KSB9KTtcbi8qKlxuTWFrZSBzdXJlIG5vZGVzXG5bbWFya2VkXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tb24uTm9kZVByb3BeaXNvbGF0ZSlcbmFzIGlzb2xhdGluZyBmb3IgYmlkaXJlY3Rpb25hbCB0ZXh0IGFyZSByZW5kZXJlZCBpbiBhIHdheSB0aGF0XG5pc29sYXRlcyB0aGVtIGZyb20gdGhlIHN1cnJvdW5kaW5nIHRleHQuXG4qL1xuZnVuY3Rpb24gYmlkaUlzb2xhdGVzKG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBleHRlbnNpb25zID0gW2lzb2xhdGVNYXJrc107XG4gICAgaWYgKG9wdGlvbnMuYWx3YXlzSXNvbGF0ZSlcbiAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKGFsd2F5c0lzb2xhdGUub2YodHJ1ZSkpO1xuICAgIHJldHVybiBleHRlbnNpb25zO1xufVxuY29uc3QgaXNvbGF0ZU1hcmtzID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMuYWx3YXlzID0gdmlldy5zdGF0ZS5mYWNldChhbHdheXNJc29sYXRlKSB8fFxuICAgICAgICAgICAgdmlldy50ZXh0RGlyZWN0aW9uICE9IERpcmVjdGlvbi5MVFIgfHxcbiAgICAgICAgICAgIHZpZXcuc3RhdGUuZmFjZXQoRWRpdG9yVmlldy5wZXJMaW5lVGV4dERpcmVjdGlvbik7XG4gICAgICAgIHRoaXMuaGFzUlRMID0gIXRoaXMuYWx3YXlzICYmIHRleHRIYXNSVEwodmlldy5zdGF0ZS5kb2MpO1xuICAgICAgICB0aGlzLnRyZWUgPSBzeW50YXhUcmVlKHZpZXcuc3RhdGUpO1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5hbHdheXMgfHwgdGhpcy5oYXNSVEwgPyBidWlsZERlY28odmlldywgdGhpcy50cmVlLCB0aGlzLmFsd2F5cykgOiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IGFsd2F5cyA9IHVwZGF0ZS5zdGF0ZS5mYWNldChhbHdheXNJc29sYXRlKSB8fFxuICAgICAgICAgICAgdXBkYXRlLnZpZXcudGV4dERpcmVjdGlvbiAhPSBEaXJlY3Rpb24uTFRSIHx8XG4gICAgICAgICAgICB1cGRhdGUuc3RhdGUuZmFjZXQoRWRpdG9yVmlldy5wZXJMaW5lVGV4dERpcmVjdGlvbik7XG4gICAgICAgIGlmICghYWx3YXlzICYmICF0aGlzLmhhc1JUTCAmJiBjaGFuZ2VBZGRzUlRMKHVwZGF0ZS5jaGFuZ2VzKSlcbiAgICAgICAgICAgIHRoaXMuaGFzUlRMID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFhbHdheXMgJiYgIXRoaXMuaGFzUlRMKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUodXBkYXRlLnN0YXRlKTtcbiAgICAgICAgaWYgKGFsd2F5cyAhPSB0aGlzLmFsd2F5cyB8fCB0cmVlICE9IHRoaXMudHJlZSB8fCB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICAgICAgdGhpcy5hbHdheXMgPSBhbHdheXM7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gYnVpbGREZWNvKHVwZGF0ZS52aWV3LCB0cmVlLCBhbHdheXMpO1xuICAgICAgICB9XG4gICAgfVxufSwge1xuICAgIHByb3ZpZGU6IHBsdWdpbiA9PiB7XG4gICAgICAgIGZ1bmN0aW9uIGFjY2Vzcyh2aWV3KSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHZpZXcucGx1Z2luKHBsdWdpbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWNvcmF0aW9ucykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbRWRpdG9yVmlldy5vdXRlckRlY29yYXRpb25zLm9mKGFjY2VzcyksXG4gICAgICAgICAgICBQcmVjLmxvd2VzdChFZGl0b3JWaWV3LmJpZGlJc29sYXRlZFJhbmdlcy5vZihhY2Nlc3MpKV07XG4gICAgfVxufSk7XG5mdW5jdGlvbiBidWlsZERlY28odmlldywgdHJlZSwgYWx3YXlzKSB7XG4gICAgbGV0IGRlY28gPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgbGV0IHJhbmdlcyA9IHZpZXcudmlzaWJsZVJhbmdlcztcbiAgICBpZiAoIWFsd2F5cylcbiAgICAgICAgcmFuZ2VzID0gY2xpcFJUTExpbmVzKHJhbmdlcywgdmlldy5zdGF0ZS5kb2MpO1xuICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiByYW5nZXMpIHtcbiAgICAgICAgdHJlZS5pdGVyYXRlKHtcbiAgICAgICAgICAgIGVudGVyOiBub2RlID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgaXNvID0gbm9kZS50eXBlLnByb3AoTm9kZVByb3AuaXNvbGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzbylcbiAgICAgICAgICAgICAgICAgICAgZGVjby5hZGQobm9kZS5mcm9tLCBub2RlLnRvLCBtYXJrc1tpc29dKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tLCB0b1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY28uZmluaXNoKCk7XG59XG5mdW5jdGlvbiBjbGlwUlRMTGluZXMocmFuZ2VzLCBkb2MpIHtcbiAgICBsZXQgY3VyID0gZG9jLml0ZXIoKSwgcG9zID0gMCwgcmVzdWx0ID0gW10sIGxhc3QgPSBudWxsO1xuICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiByYW5nZXMpIHtcbiAgICAgICAgaWYgKGZyb20gIT0gcG9zKSB7XG4gICAgICAgICAgICBpZiAocG9zIDwgZnJvbSlcbiAgICAgICAgICAgICAgICBjdXIubmV4dChmcm9tIC0gcG9zKTtcbiAgICAgICAgICAgIHBvcyA9IGZyb207XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gcG9zLCBlbmQgPSBwb3MgKyBjdXIudmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKCFjdXIubGluZUJyZWFrICYmIGJ1aWxkRm9yTGluZShjdXIudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC50byA+IHN0YXJ0IC0gMTApXG4gICAgICAgICAgICAgICAgICAgIGxhc3QudG8gPSBNYXRoLm1pbih0bywgZW5kKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxhc3QgPSB7IGZyb206IHN0YXJ0LCB0bzogTWF0aC5taW4odG8sIGVuZCkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zID49IHRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcG9zID0gZW5kO1xuICAgICAgICAgICAgY3VyLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgbWFya3MgPSB7XG4gICAgcnRsOiAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20taXNvXCIsIGluY2x1c2l2ZTogdHJ1ZSwgYXR0cmlidXRlczogeyBkaXI6IFwicnRsXCIgfSwgYmlkaUlzb2xhdGU6IERpcmVjdGlvbi5SVEwgfSksXG4gICAgbHRyOiAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20taXNvXCIsIGluY2x1c2l2ZTogdHJ1ZSwgYXR0cmlidXRlczogeyBkaXI6IFwibHRyXCIgfSwgYmlkaUlzb2xhdGU6IERpcmVjdGlvbi5MVFIgfSksXG4gICAgYXV0bzogLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLWlzb1wiLCBpbmNsdXNpdmU6IHRydWUsIGF0dHJpYnV0ZXM6IHsgZGlyOiBcImF1dG9cIiB9LCBiaWRpSXNvbGF0ZTogbnVsbCB9KVxufTtcblxuZXhwb3J0IHsgRG9jSW5wdXQsIEhpZ2hsaWdodFN0eWxlLCBJbmRlbnRDb250ZXh0LCBMUkxhbmd1YWdlLCBMYW5ndWFnZSwgTGFuZ3VhZ2VEZXNjcmlwdGlvbiwgTGFuZ3VhZ2VTdXBwb3J0LCBQYXJzZUNvbnRleHQsIFN0cmVhbUxhbmd1YWdlLCBTdHJpbmdTdHJlYW0sIFRyZWVJbmRlbnRDb250ZXh0LCBiaWRpSXNvbGF0ZXMsIGJyYWNrZXRNYXRjaGluZywgYnJhY2tldE1hdGNoaW5nSGFuZGxlLCBjb2RlRm9sZGluZywgY29udGludWVkSW5kZW50LCBkZWZhdWx0SGlnaGxpZ2h0U3R5bGUsIGRlZmluZUxhbmd1YWdlRmFjZXQsIGRlbGltaXRlZEluZGVudCwgZW5zdXJlU3ludGF4VHJlZSwgZmxhdEluZGVudCwgZm9sZEFsbCwgZm9sZENvZGUsIGZvbGRFZmZlY3QsIGZvbGRHdXR0ZXIsIGZvbGRJbnNpZGUsIGZvbGRLZXltYXAsIGZvbGROb2RlUHJvcCwgZm9sZFNlcnZpY2UsIGZvbGRTdGF0ZSwgZm9sZGFibGUsIGZvbGRlZFJhbmdlcywgZm9yY2VQYXJzaW5nLCBnZXRJbmRlbnRVbml0LCBnZXRJbmRlbnRhdGlvbiwgaGlnaGxpZ2h0aW5nRm9yLCBpbmRlbnROb2RlUHJvcCwgaW5kZW50T25JbnB1dCwgaW5kZW50UmFuZ2UsIGluZGVudFNlcnZpY2UsIGluZGVudFN0cmluZywgaW5kZW50VW5pdCwgbGFuZ3VhZ2UsIGxhbmd1YWdlRGF0YVByb3AsIG1hdGNoQnJhY2tldHMsIHN1Ymxhbmd1YWdlUHJvcCwgc3ludGF4SGlnaGxpZ2h0aW5nLCBzeW50YXhQYXJzZXJSdW5uaW5nLCBzeW50YXhUcmVlLCBzeW50YXhUcmVlQXZhaWxhYmxlLCB0b2dnbGVGb2xkLCB1bmZvbGRBbGwsIHVuZm9sZENvZGUsIHVuZm9sZEVmZmVjdCB9O1xuIl0sIm5hbWVzIjpbIk5vZGVQcm9wIiwiSXRlck1vZGUiLCJUcmVlIiwiVHJlZUZyYWdtZW50IiwiUGFyc2VyIiwiTm9kZVR5cGUiLCJOb2RlU2V0IiwiU3RhdGVFZmZlY3QiLCJTdGF0ZUZpZWxkIiwiRmFjZXQiLCJFZGl0b3JTdGF0ZSIsImNvdW50Q29sdW1uIiwiY29tYmluZUNvbmZpZyIsIlJhbmdlU2V0IiwiUmFuZ2VTZXRCdWlsZGVyIiwiUHJlYyIsIlZpZXdQbHVnaW4iLCJsb2dFeGNlcHRpb24iLCJFZGl0b3JWaWV3IiwiRGVjb3JhdGlvbiIsIldpZGdldFR5cGUiLCJndXR0ZXIiLCJHdXR0ZXJNYXJrZXIiLCJEaXJlY3Rpb24iLCJ0YWdzIiwidGFnSGlnaGxpZ2h0ZXIiLCJoaWdobGlnaHRUcmVlIiwic3R5bGVUYWdzIiwiU3R5bGVNb2R1bGUiLCJfYSIsImxhbmd1YWdlRGF0YVByb3AiLCJkZWZpbmVMYW5ndWFnZUZhY2V0IiwiYmFzZURhdGEiLCJkZWZpbmUiLCJjb21iaW5lIiwidmFsdWVzIiwiY29uY2F0IiwidW5kZWZpbmVkIiwic3VibGFuZ3VhZ2VQcm9wIiwiTGFuZ3VhZ2UiLCJjb25zdHJ1Y3RvciIsImRhdGEiLCJwYXJzZXIiLCJleHRyYUV4dGVuc2lvbnMiLCJuYW1lIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsInN5bnRheFRyZWUiLCJleHRlbnNpb24iLCJsYW5ndWFnZSIsIm9mIiwibGFuZ3VhZ2VEYXRhIiwic3RhdGUiLCJwb3MiLCJzaWRlIiwidG9wIiwidG9wTm9kZUF0IiwidHlwZSIsInByb3AiLCJiYXNlIiwiZmFjZXQiLCJzdWIiLCJpbm5lck5vZGUiLCJyZXNvbHZlIiwiZnJvbSIsInN1YmxhbmciLCJ0ZXN0IiwiaXNBY3RpdmVBdCIsImZpbmRSZWdpb25zIiwibGFuZyIsInRvIiwiZG9jIiwibGVuZ3RoIiwiYWxsb3dzTmVzdGluZyIsInJlc3VsdCIsImV4cGxvcmUiLCJ0cmVlIiwicHVzaCIsIm1vdW50IiwibW91bnRlZCIsIm92ZXJsYXkiLCJyIiwic2l6ZSIsImkiLCJjaGlsZHJlbiIsImNoIiwicG9zaXRpb25zIiwic2V0U3RhdGUiLCJ0b3BMYW5nIiwidG9wTm9kZSIsIm5vZGUiLCJlbnRlciIsIkV4Y2x1ZGVCdWZmZXJzIiwiaXNUb3AiLCJMUkxhbmd1YWdlIiwic3BlYyIsImNvbmZpZ3VyZSIsInByb3BzIiwiYWRkIiwib3B0aW9ucyIsImhhc1dyYXBwZXJzIiwiZmllbGQiLCJlbXB0eSIsImVuc3VyZVN5bnRheFRyZWUiLCJ1cHRvIiwidGltZW91dCIsInBhcnNlIiwiY29udGV4dCIsIm9sZFZpZXBvcnQiLCJ2aWV3cG9ydCIsInVwZGF0ZVZpZXdwb3J0IiwiaXNEb25lIiwid29yayIsInN5bnRheFRyZWVBdmFpbGFibGUiLCJmb3JjZVBhcnNpbmciLCJ2aWV3Iiwic3VjY2VzcyIsImRpc3BhdGNoIiwic3ludGF4UGFyc2VyUnVubmluZyIsInBsdWdpbiIsInBhcnNlV29ya2VyIiwiaXNXb3JraW5nIiwiRG9jSW5wdXQiLCJjdXJzb3JQb3MiLCJzdHJpbmciLCJjdXJzb3IiLCJpdGVyIiwic3luY1RvIiwibmV4dCIsInZhbHVlIiwiY2h1bmsiLCJsaW5lQ2h1bmtzIiwicmVhZCIsInN0cmluZ1N0YXJ0Iiwic2xpY2VTdHJpbmciLCJzbGljZSIsImN1cnJlbnRDb250ZXh0IiwiUGFyc2VDb250ZXh0IiwiZnJhZ21lbnRzIiwidHJlZUxlbiIsInNraXBwZWQiLCJzY2hlZHVsZU9uIiwidGVtcFNraXBwZWQiLCJjcmVhdGUiLCJzdGFydFBhcnNlIiwidW50aWwiLCJ0YWtlVHJlZSIsIndpdGhDb250ZXh0IiwiZW5kVGltZSIsIkRhdGUiLCJub3ciLCJzdG9wcGVkQXQiLCJzdG9wQXQiLCJkb25lIiwiYWR2YW5jZSIsIndpdGhvdXRUZW1wU2tpcHBlZCIsImFkZFRyZWUiLCJwYXJzZWRQb3MiLCJmIiwicHJldiIsInBvcCIsImN1dEZyYWdtZW50cyIsImNoYW5nZXMiLCJuZXdTdGF0ZSIsInJhbmdlcyIsIml0ZXJDaGFuZ2VkUmFuZ2VzIiwiZnJvbUEiLCJ0b0EiLCJmcm9tQiIsInRvQiIsImFwcGx5Q2hhbmdlcyIsIm1hcFBvcyIsInN0YXJ0TGVuIiwic3BsaWNlIiwicmVzZXQiLCJza2lwVW50aWxJblZpZXciLCJnZXRTa2lwcGluZ1BhcnNlciIsImNyZWF0ZVBhcnNlIiwiaW5wdXQiLCJjeCIsIlByb21pc2UiLCJhbGwiLCJub25lIiwiTWF0aCIsIm1pbiIsImZyYWdzIiwiTGFuZ3VhZ2VTdGF0ZSIsImFwcGx5IiwidHIiLCJkb2NDaGFuZ2VkIiwibmV3Q3giLCJzdGFydFN0YXRlIiwibWF4IiwiaW5pdCIsInZwVG8iLCJwYXJzZVN0YXRlIiwidXBkYXRlIiwiZSIsImVmZmVjdHMiLCJpcyIsInJlcXVlc3RJZGxlIiwiY2FsbGJhY2siLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwicmVxdWVzdElkbGVDYWxsYmFjayIsImlkbGUiLCJjYW5jZWxJZGxlQ2FsbGJhY2siLCJpc0lucHV0UGVuZGluZyIsIm5hdmlnYXRvciIsInNjaGVkdWxpbmciLCJmcm9tQ2xhc3MiLCJQYXJzZVdvcmtlciIsIndvcmtpbmciLCJ3b3JrU2NoZWR1bGVkIiwiY2h1bmtFbmQiLCJjaHVua0J1ZGdldCIsImJpbmQiLCJzY2hlZHVsZVdvcmsiLCJzZWxlY3Rpb25TZXQiLCJoYXNGb2N1cyIsImNoZWNrQXN5bmNTY2hlZHVsZSIsImRlYWRsaW5lIiwidGltZVJlbWFpbmluZyIsInZpZXdwb3J0Rmlyc3QiLCJ0aGVuIiwiY2F0Y2giLCJlcnIiLCJkZXN0cm95IiwiZXZlbnRIYW5kbGVycyIsImZvY3VzIiwibGFuZ3VhZ2VzIiwiZW5hYmxlcyIsImNvbnRlbnRBdHRyaWJ1dGVzIiwiY29tcHV0ZSIsIkxhbmd1YWdlU3VwcG9ydCIsInN1cHBvcnQiLCJMYW5ndWFnZURlc2NyaXB0aW9uIiwiYWxpYXMiLCJleHRlbnNpb25zIiwiZmlsZW5hbWUiLCJsb2FkRnVuYyIsImxvYWRpbmciLCJsb2FkIiwiUmFuZ2VFcnJvciIsIm1hcCIsInMiLCJ0b0xvd2VyQ2FzZSIsIm1hdGNoRmlsZW5hbWUiLCJkZXNjcyIsImQiLCJleHQiLCJleGVjIiwiaW5kZXhPZiIsIm1hdGNoTGFuZ3VhZ2VOYW1lIiwiZnV6enkiLCJzb21lIiwiYSIsImZvdW5kIiwiaW5kZW50U2VydmljZSIsImluZGVudFVuaXQiLCJ1bml0IiwiQXJyYXkiLCJFcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJnZXRJbmRlbnRVbml0IiwiY2hhckNvZGVBdCIsInRhYlNpemUiLCJpbmRlbnRTdHJpbmciLCJjb2xzIiwidHMiLCJnZXRJbmRlbnRhdGlvbiIsIkluZGVudENvbnRleHQiLCJzZXJ2aWNlIiwic3ludGF4SW5kZW50YXRpb24iLCJpbmRlbnRSYW5nZSIsInVwZGF0ZWQiLCJvdmVycmlkZUluZGVudGF0aW9uIiwic3RhcnQiLCJsaW5lIiwibGluZUF0IiwiaW5kZW50IiwidGV4dCIsImN1ciIsIm5vcm0iLCJpbnNlcnQiLCJiaWFzIiwic2ltdWxhdGVCcmVhayIsInNpbXVsYXRlRG91YmxlQnJlYWsiLCJ0ZXh0QWZ0ZXJQb3MiLCJjb2x1bW4iLCJvdmVycmlkZSIsInNlYXJjaCIsImxpbmVJbmRlbnQiLCJvdmVycmlkZW4iLCJzaW11bGF0ZWRCcmVhayIsImluZGVudE5vZGVQcm9wIiwiYXN0Iiwic3RhY2siLCJyZXNvbHZlU3RhY2siLCJpbm5lciIsImVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlIiwicGFyZW50IiwiaW5kZW50Rm9yIiwic3RyYXRlZ3kiLCJpbmRlbnRTdHJhdGVneSIsIlRyZWVJbmRlbnRDb250ZXh0IiwiaWdub3JlQ2xvc2VkIiwiZmlyc3QiLCJmaXJzdENoaWxkIiwiY2xvc2UiLCJjbG9zZWRCeSIsImxhc3QiLCJsYXN0Q2hpbGQiLCJjbG9zZWQiLCJkZWxpbWl0ZWRTdHJhdGVneSIsInRvcEluZGVudCIsInRleHRBZnRlciIsImJhc2VJbmRlbnQiLCJiYXNlSW5kZW50Rm9yIiwiYXRCcmVhayIsImlzUGFyZW50IiwiY29udGludWUiLCJicmFja2V0ZWRBbGlnbmVkIiwib3BlblRva2VuIiwiY2hpbGRBZnRlciIsInNpbSIsIm9wZW5MaW5lIiwibGluZUVuZCIsImlzU2tpcHBlZCIsImRlbGltaXRlZEluZGVudCIsImNsb3NpbmciLCJhbGlnbiIsInVuaXRzIiwiY2xvc2VkQXQiLCJhZnRlciIsInNwYWNlIiwibWF0Y2giLCJhbGlnbmVkIiwiZmxhdEluZGVudCIsImNvbnRpbnVlZEluZGVudCIsImV4Y2VwdCIsIm1hdGNoRXhjZXB0IiwiRG9udEluZGVudEJleW9uZCIsImluZGVudE9uSW5wdXQiLCJ0cmFuc2FjdGlvbkZpbHRlciIsImlzVXNlckV2ZW50IiwicnVsZXMiLCJsYW5ndWFnZURhdGFBdCIsInNlbGVjdGlvbiIsIm1haW4iLCJoZWFkIiwibmV3RG9jIiwibmV3U2VsZWN0aW9uIiwibGluZVN0YXJ0Iiwic2VxdWVudGlhbCIsImZvbGRTZXJ2aWNlIiwiZm9sZE5vZGVQcm9wIiwiZm9sZEluc2lkZSIsImlzRXJyb3IiLCJzeW50YXhGb2xkaW5nIiwiZW5kIiwiaXNVbmZpbmlzaGVkIiwiZm9sZGFibGUiLCJtYXBSYW5nZSIsInJhbmdlIiwibWFwcGluZyIsImZvbGRFZmZlY3QiLCJ1bmZvbGRFZmZlY3QiLCJzZWxlY3RlZExpbmVzIiwibGluZXMiLCJsIiwibGluZUJsb2NrQXQiLCJmb2xkU3RhdGUiLCJmb2xkZWQiLCJmb2xkRXhpc3RzIiwicHJlcGFyZVBsYWNlaG9sZGVyIiwiZm9sZENvbmZpZyIsIndpZGdldCIsImZvbGRXaWRnZXQiLCJyZXBsYWNlIiwiUHJlcGFyZWRGb2xkV2lkZ2V0IiwiZmlsdGVyIiwiZmlsdGVyRnJvbSIsImZpbHRlclRvIiwib25TZWxlY3Rpb24iLCJiZXR3ZWVuIiwiYiIsInByb3ZpZGUiLCJkZWNvcmF0aW9ucyIsInRvSlNPTiIsImZyb21KU09OIiwiaXNBcnJheSIsInNldCIsImZvbGRlZFJhbmdlcyIsImZpbmRGb2xkIiwibWF5YmVFbmFibGUiLCJvdGhlciIsImFwcGVuZENvbmZpZyIsImNvZGVGb2xkaW5nIiwiZm9sZENvZGUiLCJhbm5vdW5jZUZvbGQiLCJ1bmZvbGRDb2RlIiwiZm9sZCIsImxpbmVGcm9tIiwibnVtYmVyIiwibGluZVRvIiwiYW5ub3VuY2UiLCJwaHJhc2UiLCJmb2xkQWxsIiwidW5mb2xkQWxsIiwiZm9sZGFibGVDb250YWluZXIiLCJsaW5lQmxvY2siLCJmb2xkYWJsZVJlZ2lvbiIsInRvZ2dsZUZvbGQiLCJmb2xkUmFuZ2UiLCJmb2xkS2V5bWFwIiwia2V5IiwibWFjIiwicnVuIiwiZGVmYXVsdENvbmZpZyIsInBsYWNlaG9sZGVyRE9NIiwicGxhY2Vob2xkZXJUZXh0IiwiY29uZmlnIiwiYmFzZVRoZW1lJDEiLCJ3aWRnZXRUb0RPTSIsInByZXBhcmVkIiwiY29uZiIsIm9uY2xpY2siLCJldmVudCIsInBvc0F0RE9NIiwidGFyZ2V0IiwicHJldmVudERlZmF1bHQiLCJlbGVtZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwidGV4dENvbnRlbnQiLCJzZXRBdHRyaWJ1dGUiLCJ0aXRsZSIsImNsYXNzTmFtZSIsInRvRE9NIiwiZXEiLCJmb2xkR3V0dGVyRGVmYXVsdHMiLCJvcGVuVGV4dCIsImNsb3NlZFRleHQiLCJtYXJrZXJET00iLCJkb21FdmVudEhhbmRsZXJzIiwiZm9sZGluZ0NoYW5nZWQiLCJGb2xkTWFya2VyIiwib3BlbiIsInNwYW4iLCJmb2xkR3V0dGVyIiwiZnVsbENvbmZpZyIsImFzc2lnbiIsImNhbkZvbGQiLCJjYW5VbmZvbGQiLCJtYXJrZXJzIiwiYnVpbGRNYXJrZXJzIiwidmlld3BvcnRDaGFuZ2VkIiwiYnVpbGRlciIsInZpZXdwb3J0TGluZUJsb2NrcyIsIm1hcmsiLCJmaW5pc2giLCJjbGFzcyIsImluaXRpYWxTcGFjZXIiLCJjbGljayIsImJhc2VUaGVtZSIsImJhY2tncm91bmRDb2xvciIsImJvcmRlciIsImNvbG9yIiwiYm9yZGVyUmFkaXVzIiwibWFyZ2luIiwicGFkZGluZyIsIkhpZ2hsaWdodFN0eWxlIiwic3BlY3MiLCJtb2RTcGVjIiwiZGVmIiwiY2xzIiwibmV3TmFtZSIsInNjb3BlT3B0Iiwic2NvcGUiLCJzdHlsZSIsInRhZyIsIm1vZHVsZSIsInRoZW1lVHlwZSIsImhpZ2hsaWdodGVyRmFjZXQiLCJmYWxsYmFja0hpZ2hsaWdodGVyIiwiZ2V0SGlnaGxpZ2h0ZXJzIiwic3ludGF4SGlnaGxpZ2h0aW5nIiwiaGlnaGxpZ2h0ZXIiLCJ0cmVlSGlnaGxpZ2h0ZXIiLCJzdHlsZU1vZHVsZSIsImZhbGxiYWNrIiwiY29tcHV0ZU4iLCJkYXJrVGhlbWUiLCJoaWdobGlnaHRpbmdGb3IiLCJoaWdobGlnaHRlcnMiLCJUcmVlSGlnaGxpZ2h0ZXIiLCJtYXJrQ2FjaGUiLCJidWlsZERlY28iLCJkZWNvcmF0ZWRUbyIsInN0eWxlQ2hhbmdlIiwiZGVjb3JhdGVkVG9NYXBwZWQiLCJ2aXNpYmxlUmFuZ2VzIiwiaGlnaCIsInYiLCJkZWZhdWx0SGlnaGxpZ2h0U3R5bGUiLCJtZXRhIiwibGluayIsInRleHREZWNvcmF0aW9uIiwiaGVhZGluZyIsImZvbnRXZWlnaHQiLCJlbXBoYXNpcyIsImZvbnRTdHlsZSIsInN0cm9uZyIsInN0cmlrZXRocm91Z2giLCJrZXl3b3JkIiwiYXRvbSIsImJvb2wiLCJ1cmwiLCJjb250ZW50U2VwYXJhdG9yIiwibGFiZWxOYW1lIiwibGl0ZXJhbCIsImluc2VydGVkIiwiZGVsZXRlZCIsInJlZ2V4cCIsImVzY2FwZSIsInNwZWNpYWwiLCJkZWZpbml0aW9uIiwidmFyaWFibGVOYW1lIiwibG9jYWwiLCJ0eXBlTmFtZSIsIm5hbWVzcGFjZSIsIm1hY3JvTmFtZSIsInByb3BlcnR5TmFtZSIsImNvbW1lbnQiLCJpbnZhbGlkIiwiRGVmYXVsdFNjYW5EaXN0IiwiRGVmYXVsdEJyYWNrZXRzIiwiYnJhY2tldE1hdGNoaW5nQ29uZmlnIiwiY29uZmlncyIsImFmdGVyQ3Vyc29yIiwiYnJhY2tldHMiLCJtYXhTY2FuRGlzdGFuY2UiLCJyZW5kZXJNYXRjaCIsImRlZmF1bHRSZW5kZXJNYXRjaCIsIm1hdGNoaW5nTWFyayIsIm5vbm1hdGNoaW5nTWFyayIsIm1hdGNoZWQiLCJicmFja2V0TWF0Y2hpbmdTdGF0ZSIsImRlY28iLCJtYXRjaEJyYWNrZXRzIiwiYnJhY2tldE1hdGNoaW5nVW5pcXVlIiwiYnJhY2tldE1hdGNoaW5nIiwiYnJhY2tldE1hdGNoaW5nSGFuZGxlIiwibWF0Y2hpbmdOb2RlcyIsImRpciIsImJ5UHJvcCIsIm9wZW5lZEJ5IiwiaW5kZXgiLCJmaW5kSGFuZGxlIiwiaGFzSGFuZGxlIiwicmVzb2x2ZUlubmVyIiwibWF0Y2hlcyIsImhhbmRsZSIsIm1hdGNoTWFya2VkQnJhY2tldHMiLCJtYXRjaFBsYWluQnJhY2tldHMiLCJfc3RhdGUiLCJfcG9zIiwidG9rZW4iLCJtYXRjaGluZyIsImZpcnN0VG9rZW4iLCJkZXB0aCIsImNoaWxkQmVmb3JlIiwiZW5kSGFuZGxlIiwicHJldlNpYmxpbmciLCJuZXh0U2libGluZyIsInRva2VuVHlwZSIsInN0YXJ0Q2giLCJzbGljZURvYyIsImJyYWNrZXQiLCJzdGFydFRva2VuIiwiaXRlclJhbmdlIiwiZGlzdGFuY2UiLCJiYXNlUG9zIiwiY291bnRDb2wiLCJzdGFydEluZGV4Iiwic3RhcnRWYWx1ZSIsIm4iLCJTdHJpbmdTdHJlYW0iLCJvdmVycmlkZUluZGVudCIsImxhc3RDb2x1bW5Qb3MiLCJsYXN0Q29sdW1uVmFsdWUiLCJlb2wiLCJzb2wiLCJwZWVrIiwiY2hhckF0IiwiZWF0Iiwib2siLCJSZWdFeHAiLCJlYXRXaGlsZSIsImVhdFNwYWNlIiwic2tpcFRvRW5kIiwic2tpcFRvIiwiYmFja1VwIiwiaW5kZW50YXRpb24iLCJwYXR0ZXJuIiwiY29uc3VtZSIsImNhc2VJbnNlbnNpdGl2ZSIsImNhc2VkIiwic3RyIiwic3Vic3RyIiwiY3VycmVudCIsImZ1bGxQYXJzZXIiLCJibGFua0xpbmUiLCJjb3B5U3RhdGUiLCJkZWZhdWx0Q29weVN0YXRlIiwidG9rZW5UYWJsZSIsIm5vVG9rZW5zIiwidmFsIiwiSW5kZW50ZWRGcm9tIiwiV2Vha01hcCIsIlN0cmVhbUxhbmd1YWdlIiwicCIsInNlbGYiLCJpbXBsIiwiUGFyc2UiLCJnZXRJbmRlbnQiLCJkb2NJRCIsInN0cmVhbVBhcnNlciIsInN0YXRlQWZ0ZXIiLCJwZXJOb2RlIiwiVG9rZW5UYWJsZSIsImRlZmF1bHRUb2tlblRhYmxlIiwiYXQiLCJmaW5kU3RhdGUiLCJzdGF0ZVBvcyIsInN0cmVhbSIsInJlYWRUb2tlbiIsIm9mZiIsInN0YXJ0UG9zIiwiYmVmb3JlIiwiY2hpbGQiLCJjdXRUcmVlIiwiaW5zaWRlIiwiZmluZFN0YXJ0SW5GcmFnbWVudHMiLCJlZGl0b3JTdGF0ZSIsIm9wZW5TdGFydCIsIm9wZW5FbmQiLCJvZmZzZXQiLCJjaHVua3MiLCJjaHVua1BvcyIsImNodW5rUmV1c2VkIiwicmFuZ2VJbmRleCIsImNodW5rU3RhcnQiLCJtb3ZlUmFuZ2VJbmRleCIsInBhcnNlRW5kIiwicGFyc2VMaW5lIiwiZmluaXNoQ2h1bmsiLCJsaW5lQWZ0ZXIiLCJuZXh0TGluZSIsInJhbmdlRW5kIiwicmFuZ2VTdGFydCIsInNraXBHYXBzVG8iLCJvZmZQb3MiLCJlbWl0VG9rZW4iLCJpZCIsImxlbjAiLCJidWlsZCIsImJ1ZmZlciIsIm5vZGVTZXQiLCJ0b3BJRCIsIm1heEJ1ZmZlckxlbmd0aCIsInJldXNlZCIsImJhbGFuY2UiLCJ0eXBlQXJyYXkiLCJ3YXJuZWQiLCJieVRhZyIsImRlZmF1bHRUYWJsZSIsImxlZ2FjeU5hbWUiLCJjcmVhdGVUb2tlblR5cGUiLCJleHRyYSIsInRhYmxlIiwid2FybkZvclBhcnQiLCJwYXJ0IiwibXNnIiwiY29uc29sZSIsIndhcm4iLCJ0YWdTdHIiLCJ0YWdzJDEiLCJzcGxpdCIsInQiLCJrbm93biIsImJ1aWxkRm9yTGluZSIsInRleHRIYXNSVEwiLCJjaGFuZ2VBZGRzUlRMIiwiY2hhbmdlIiwiYWRkZWQiLCJpdGVyQ2hhbmdlcyIsImZBIiwidEEiLCJmQiIsInRCIiwiaW5zIiwiYWx3YXlzSXNvbGF0ZSIsIngiLCJiaWRpSXNvbGF0ZXMiLCJpc29sYXRlTWFya3MiLCJhbHdheXMiLCJ0ZXh0RGlyZWN0aW9uIiwiTFRSIiwicGVyTGluZVRleHREaXJlY3Rpb24iLCJoYXNSVEwiLCJhY2Nlc3MiLCJfYiIsIm91dGVyRGVjb3JhdGlvbnMiLCJsb3dlc3QiLCJiaWRpSXNvbGF0ZWRSYW5nZXMiLCJjbGlwUlRMTGluZXMiLCJpdGVyYXRlIiwiaXNvIiwiaXNvbGF0ZSIsIm1hcmtzIiwibGluZUJyZWFrIiwicnRsIiwiaW5jbHVzaXZlIiwiYXR0cmlidXRlcyIsImJpZGlJc29sYXRlIiwiUlRMIiwibHRyIiwiYXV0byJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/language/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/lint/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@codemirror/lint/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closeLintPanel: () => (/* binding */ closeLintPanel),\n/* harmony export */   diagnosticCount: () => (/* binding */ diagnosticCount),\n/* harmony export */   forEachDiagnostic: () => (/* binding */ forEachDiagnostic),\n/* harmony export */   forceLinting: () => (/* binding */ forceLinting),\n/* harmony export */   lintGutter: () => (/* binding */ lintGutter),\n/* harmony export */   lintKeymap: () => (/* binding */ lintKeymap),\n/* harmony export */   linter: () => (/* binding */ linter),\n/* harmony export */   nextDiagnostic: () => (/* binding */ nextDiagnostic),\n/* harmony export */   openLintPanel: () => (/* binding */ openLintPanel),\n/* harmony export */   previousDiagnostic: () => (/* binding */ previousDiagnostic),\n/* harmony export */   setDiagnostics: () => (/* binding */ setDiagnostics),\n/* harmony export */   setDiagnosticsEffect: () => (/* binding */ setDiagnosticsEffect)\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var crelt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crelt */ \"(ssr)/./node_modules/crelt/index.js\");\n\n\n\nclass SelectedDiagnostic {\n    constructor(from, to, diagnostic){\n        this.from = from;\n        this.to = to;\n        this.diagnostic = diagnostic;\n    }\n}\nclass LintState {\n    constructor(diagnostics, panel, selected){\n        this.diagnostics = diagnostics;\n        this.panel = panel;\n        this.selected = selected;\n    }\n    static init(diagnostics, panel, state) {\n        // Filter the list of diagnostics for which to create markers\n        let markedDiagnostics = diagnostics;\n        let diagnosticFilter = state.facet(lintConfig).markerFilter;\n        if (diagnosticFilter) markedDiagnostics = diagnosticFilter(markedDiagnostics, state);\n        let ranges = _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.set(markedDiagnostics.map((d)=>{\n            // For zero-length ranges or ranges covering only a line break, create a widget\n            return d.from == d.to || d.from == d.to - 1 && state.doc.lineAt(d.from).to == d.from ? _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.widget({\n                widget: new DiagnosticWidget(d),\n                diagnostic: d\n            }).range(d.from) : _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.mark({\n                attributes: {\n                    class: \"cm-lintRange cm-lintRange-\" + d.severity + (d.markClass ? \" \" + d.markClass : \"\")\n                },\n                diagnostic: d,\n                inclusive: true\n            }).range(d.from, d.to);\n        }), true);\n        return new LintState(ranges, panel, findDiagnostic(ranges));\n    }\n}\nfunction findDiagnostic(diagnostics, diagnostic = null, after = 0) {\n    let found = null;\n    diagnostics.between(after, 1e9, (from, to, { spec })=>{\n        if (diagnostic && spec.diagnostic != diagnostic) return;\n        found = new SelectedDiagnostic(from, to, spec.diagnostic);\n        return false;\n    });\n    return found;\n}\nfunction hideTooltip(tr, tooltip) {\n    let line = tr.startState.doc.lineAt(tooltip.pos);\n    return !!(tr.effects.some((e)=>e.is(setDiagnosticsEffect)) || tr.changes.touchesRange(line.from, line.to));\n}\nfunction maybeEnableLint(state, effects) {\n    return state.field(lintState, false) ? effects : effects.concat(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.appendConfig.of(lintExtensions));\n}\n/**\nReturns a transaction spec which updates the current set of\ndiagnostics, and enables the lint extension if if wasn't already\nactive.\n*/ function setDiagnostics(state, diagnostics) {\n    return {\n        effects: maybeEnableLint(state, [\n            setDiagnosticsEffect.of(diagnostics)\n        ])\n    };\n}\n/**\nThe state effect that updates the set of active diagnostics. Can\nbe useful when writing an extension that needs to track these.\n*/ const setDiagnosticsEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\nconst togglePanel = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\nconst movePanelSelection = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\nconst lintState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n    create () {\n        return new LintState(_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.none, null, null);\n    },\n    update (value, tr) {\n        if (tr.docChanged) {\n            let mapped = value.diagnostics.map(tr.changes), selected = null;\n            if (value.selected) {\n                let selPos = tr.changes.mapPos(value.selected.from, 1);\n                selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);\n            }\n            value = new LintState(mapped, value.panel, selected);\n        }\n        for (let effect of tr.effects){\n            if (effect.is(setDiagnosticsEffect)) {\n                value = LintState.init(effect.value, value.panel, tr.state);\n            } else if (effect.is(togglePanel)) {\n                value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);\n            } else if (effect.is(movePanelSelection)) {\n                value = new LintState(value.diagnostics, value.panel, effect.value);\n            }\n        }\n        return value;\n    },\n    provide: (f)=>[\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.showPanel.from(f, (val)=>val.panel),\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.decorations.from(f, (s)=>s.diagnostics)\n        ]\n});\n/**\nReturns the number of active lint diagnostics in the given state.\n*/ function diagnosticCount(state) {\n    let lint = state.field(lintState, false);\n    return lint ? lint.diagnostics.size : 0;\n}\nconst activeMark = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.mark({\n    class: \"cm-lintRange cm-lintRange-active\",\n    inclusive: true\n});\nfunction lintTooltip(view, pos, side) {\n    let { diagnostics } = view.state.field(lintState);\n    let found = [], stackStart = 2e8, stackEnd = 0;\n    diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, { spec })=>{\n        if (pos >= from && pos <= to && (from == to || (pos > from || side > 0) && (pos < to || side < 0))) {\n            found.push(spec.diagnostic);\n            stackStart = Math.min(from, stackStart);\n            stackEnd = Math.max(to, stackEnd);\n        }\n    });\n    let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;\n    if (diagnosticFilter) found = diagnosticFilter(found, view.state);\n    if (!found.length) return null;\n    return {\n        pos: stackStart,\n        end: stackEnd,\n        above: view.state.doc.lineAt(stackStart).to < stackEnd,\n        create () {\n            return {\n                dom: diagnosticsTooltip(view, found)\n            };\n        }\n    };\n}\nfunction diagnosticsTooltip(view, diagnostics) {\n    return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"ul\", {\n        class: \"cm-tooltip-lint\"\n    }, diagnostics.map((d)=>renderDiagnostic(view, d, false)));\n}\n/**\nCommand to open and focus the lint panel.\n*/ const openLintPanel = (view)=>{\n    let field = view.state.field(lintState, false);\n    if (!field || !field.panel) view.dispatch({\n        effects: maybeEnableLint(view.state, [\n            togglePanel.of(true)\n        ])\n    });\n    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.getPanel)(view, LintPanel.open);\n    if (panel) panel.dom.querySelector(\".cm-panel-lint ul\").focus();\n    return true;\n};\n/**\nCommand to close the lint panel, when open.\n*/ const closeLintPanel = (view)=>{\n    let field = view.state.field(lintState, false);\n    if (!field || !field.panel) return false;\n    view.dispatch({\n        effects: togglePanel.of(false)\n    });\n    return true;\n};\n/**\nMove the selection to the next diagnostic.\n*/ const nextDiagnostic = (view)=>{\n    let field = view.state.field(lintState, false);\n    if (!field) return false;\n    let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);\n    if (!next.value) {\n        next = field.diagnostics.iter(0);\n        if (!next.value || next.from == sel.from && next.to == sel.to) return false;\n    }\n    view.dispatch({\n        selection: {\n            anchor: next.from,\n            head: next.to\n        },\n        scrollIntoView: true\n    });\n    return true;\n};\n/**\nMove the selection to the previous diagnostic.\n*/ const previousDiagnostic = (view)=>{\n    let { state } = view, field = state.field(lintState, false);\n    if (!field) return false;\n    let sel = state.selection.main;\n    let prevFrom, prevTo, lastFrom, lastTo;\n    field.diagnostics.between(0, state.doc.length, (from, to)=>{\n        if (to < sel.to && (prevFrom == null || prevFrom < from)) {\n            prevFrom = from;\n            prevTo = to;\n        }\n        if (lastFrom == null || from > lastFrom) {\n            lastFrom = from;\n            lastTo = to;\n        }\n    });\n    if (lastFrom == null || prevFrom == null && lastFrom == sel.from) return false;\n    view.dispatch({\n        selection: {\n            anchor: prevFrom !== null && prevFrom !== void 0 ? prevFrom : lastFrom,\n            head: prevTo !== null && prevTo !== void 0 ? prevTo : lastTo\n        },\n        scrollIntoView: true\n    });\n    return true;\n};\n/**\nA set of default key bindings for the lint functionality.\n\n- Ctrl-Shift-m (Cmd-Shift-m on macOS): [`openLintPanel`](https://codemirror.net/6/docs/ref/#lint.openLintPanel)\n- F8: [`nextDiagnostic`](https://codemirror.net/6/docs/ref/#lint.nextDiagnostic)\n*/ const lintKeymap = [\n    {\n        key: \"Mod-Shift-m\",\n        run: openLintPanel,\n        preventDefault: true\n    },\n    {\n        key: \"F8\",\n        run: nextDiagnostic\n    }\n];\nconst lintPlugin = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.timeout = -1;\n        this.set = true;\n        let { delay } = view.state.facet(lintConfig);\n        this.lintTime = Date.now() + delay;\n        this.run = this.run.bind(this);\n        this.timeout = setTimeout(this.run, delay);\n    }\n    run() {\n        let now = Date.now();\n        if (now < this.lintTime - 10) {\n            this.timeout = setTimeout(this.run, this.lintTime - now);\n        } else {\n            this.set = false;\n            let { state } = this.view, { sources } = state.facet(lintConfig);\n            if (sources.length) Promise.all(sources.map((source)=>Promise.resolve(source(this.view)))).then((annotations)=>{\n                let all = annotations.reduce((a, b)=>a.concat(b));\n                if (this.view.state.doc == state.doc) this.view.dispatch(setDiagnostics(this.view.state, all));\n            }, (error)=>{\n                (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.logException)(this.view.state, error);\n            });\n        }\n    }\n    update(update) {\n        let config = update.state.facet(lintConfig);\n        if (update.docChanged || config != update.startState.facet(lintConfig) || config.needsRefresh && config.needsRefresh(update)) {\n            this.lintTime = Date.now() + config.delay;\n            if (!this.set) {\n                this.set = true;\n                this.timeout = setTimeout(this.run, config.delay);\n            }\n        }\n    }\n    force() {\n        if (this.set) {\n            this.lintTime = Date.now();\n            this.run();\n        }\n    }\n    destroy() {\n        clearTimeout(this.timeout);\n    }\n});\nconst lintConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine (input) {\n        return Object.assign({\n            sources: input.map((i)=>i.source).filter((x)=>x != null)\n        }, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(input.map((i)=>i.config), {\n            delay: 750,\n            markerFilter: null,\n            tooltipFilter: null,\n            needsRefresh: null\n        }, {\n            needsRefresh: (a, b)=>!a ? b : !b ? a : (u)=>a(u) || b(u)\n        }));\n    }\n});\n/**\nGiven a diagnostic source, this function returns an extension that\nenables linting with that source. It will be called whenever the\neditor is idle (after its content changed). If `null` is given as\nsource, this only configures the lint extension.\n*/ function linter(source, config = {}) {\n    return [\n        lintConfig.of({\n            source,\n            config\n        }),\n        lintPlugin,\n        lintExtensions\n    ];\n}\n/**\nForces any linters [configured](https://codemirror.net/6/docs/ref/#lint.linter) to run when the\neditor is idle to run right away.\n*/ function forceLinting(view) {\n    let plugin = view.plugin(lintPlugin);\n    if (plugin) plugin.force();\n}\nfunction assignKeys(actions) {\n    let assigned = [];\n    if (actions) actions: for (let { name } of actions){\n        for(let i = 0; i < name.length; i++){\n            let ch = name[i];\n            if (/[a-zA-Z]/.test(ch) && !assigned.some((c)=>c.toLowerCase() == ch.toLowerCase())) {\n                assigned.push(ch);\n                continue actions;\n            }\n        }\n        assigned.push(\"\");\n    }\n    return assigned;\n}\nfunction renderDiagnostic(view, diagnostic, inPanel) {\n    var _a;\n    let keys = inPanel ? assignKeys(diagnostic.actions) : [];\n    return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"li\", {\n        class: \"cm-diagnostic cm-diagnostic-\" + diagnostic.severity\n    }, (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"span\", {\n        class: \"cm-diagnosticText\"\n    }, diagnostic.renderMessage ? diagnostic.renderMessage() : diagnostic.message), (_a = diagnostic.actions) === null || _a === void 0 ? void 0 : _a.map((action, i)=>{\n        let fired = false, click = (e)=>{\n            e.preventDefault();\n            if (fired) return;\n            fired = true;\n            let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);\n            if (found) action.apply(view, found.from, found.to);\n        };\n        let { name } = action, keyIndex = keys[i] ? name.indexOf(keys[i]) : -1;\n        let nameElt = keyIndex < 0 ? name : [\n            name.slice(0, keyIndex),\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"u\", name.slice(keyIndex, keyIndex + 1)),\n            name.slice(keyIndex + 1)\n        ];\n        return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n            type: \"button\",\n            class: \"cm-diagnosticAction\",\n            onclick: click,\n            onmousedown: click,\n            \"aria-label\": ` Action: ${name}${keyIndex < 0 ? \"\" : ` (access key \"${keys[i]})\"`}.`\n        }, nameElt);\n    }), diagnostic.source && (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"div\", {\n        class: \"cm-diagnosticSource\"\n    }, diagnostic.source));\n}\nclass DiagnosticWidget extends _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.WidgetType {\n    constructor(diagnostic){\n        super();\n        this.diagnostic = diagnostic;\n    }\n    eq(other) {\n        return other.diagnostic == this.diagnostic;\n    }\n    toDOM() {\n        return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"span\", {\n            class: \"cm-lintPoint cm-lintPoint-\" + this.diagnostic.severity\n        });\n    }\n}\nclass PanelItem {\n    constructor(view, diagnostic){\n        this.diagnostic = diagnostic;\n        this.id = \"item_\" + Math.floor(Math.random() * 0xffffffff).toString(16);\n        this.dom = renderDiagnostic(view, diagnostic, true);\n        this.dom.id = this.id;\n        this.dom.setAttribute(\"role\", \"option\");\n    }\n}\nclass LintPanel {\n    constructor(view){\n        this.view = view;\n        this.items = [];\n        let onkeydown = (event)=>{\n            if (event.keyCode == 27) {\n                closeLintPanel(this.view);\n                this.view.focus();\n            } else if (event.keyCode == 38 || event.keyCode == 33) {\n                this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);\n            } else if (event.keyCode == 40 || event.keyCode == 34) {\n                this.moveSelection((this.selectedIndex + 1) % this.items.length);\n            } else if (event.keyCode == 36) {\n                this.moveSelection(0);\n            } else if (event.keyCode == 35) {\n                this.moveSelection(this.items.length - 1);\n            } else if (event.keyCode == 13) {\n                this.view.focus();\n            } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {\n                let { diagnostic } = this.items[this.selectedIndex], keys = assignKeys(diagnostic.actions);\n                for(let i = 0; i < keys.length; i++)if (keys[i].toUpperCase().charCodeAt(0) == event.keyCode) {\n                    let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);\n                    if (found) diagnostic.actions[i].apply(view, found.from, found.to);\n                }\n            } else {\n                return;\n            }\n            event.preventDefault();\n        };\n        let onclick = (event)=>{\n            for(let i = 0; i < this.items.length; i++){\n                if (this.items[i].dom.contains(event.target)) this.moveSelection(i);\n            }\n        };\n        this.list = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"ul\", {\n            tabIndex: 0,\n            role: \"listbox\",\n            \"aria-label\": this.view.state.phrase(\"Diagnostics\"),\n            onkeydown,\n            onclick\n        });\n        this.dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"div\", {\n            class: \"cm-panel-lint\"\n        }, this.list, (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n            type: \"button\",\n            name: \"close\",\n            \"aria-label\": this.view.state.phrase(\"close\"),\n            onclick: ()=>closeLintPanel(this.view)\n        }, \"\\xd7\"));\n        this.update();\n    }\n    get selectedIndex() {\n        let selected = this.view.state.field(lintState).selected;\n        if (!selected) return -1;\n        for(let i = 0; i < this.items.length; i++)if (this.items[i].diagnostic == selected.diagnostic) return i;\n        return -1;\n    }\n    update() {\n        let { diagnostics, selected } = this.view.state.field(lintState);\n        let i = 0, needsSync = false, newSelectedItem = null;\n        diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec })=>{\n            let found = -1, item;\n            for(let j = i; j < this.items.length; j++)if (this.items[j].diagnostic == spec.diagnostic) {\n                found = j;\n                break;\n            }\n            if (found < 0) {\n                item = new PanelItem(this.view, spec.diagnostic);\n                this.items.splice(i, 0, item);\n                needsSync = true;\n            } else {\n                item = this.items[found];\n                if (found > i) {\n                    this.items.splice(i, found - i);\n                    needsSync = true;\n                }\n            }\n            if (selected && item.diagnostic == selected.diagnostic) {\n                if (!item.dom.hasAttribute(\"aria-selected\")) {\n                    item.dom.setAttribute(\"aria-selected\", \"true\");\n                    newSelectedItem = item;\n                }\n            } else if (item.dom.hasAttribute(\"aria-selected\")) {\n                item.dom.removeAttribute(\"aria-selected\");\n            }\n            i++;\n        });\n        while(i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)){\n            needsSync = true;\n            this.items.pop();\n        }\n        if (this.items.length == 0) {\n            this.items.push(new PanelItem(this.view, {\n                from: -1,\n                to: -1,\n                severity: \"info\",\n                message: this.view.state.phrase(\"No diagnostics\")\n            }));\n            needsSync = true;\n        }\n        if (newSelectedItem) {\n            this.list.setAttribute(\"aria-activedescendant\", newSelectedItem.id);\n            this.view.requestMeasure({\n                key: this,\n                read: ()=>({\n                        sel: newSelectedItem.dom.getBoundingClientRect(),\n                        panel: this.list.getBoundingClientRect()\n                    }),\n                write: ({ sel, panel })=>{\n                    let scaleY = panel.height / this.list.offsetHeight;\n                    if (sel.top < panel.top) this.list.scrollTop -= (panel.top - sel.top) / scaleY;\n                    else if (sel.bottom > panel.bottom) this.list.scrollTop += (sel.bottom - panel.bottom) / scaleY;\n                }\n            });\n        } else if (this.selectedIndex < 0) {\n            this.list.removeAttribute(\"aria-activedescendant\");\n        }\n        if (needsSync) this.sync();\n    }\n    sync() {\n        let domPos = this.list.firstChild;\n        function rm() {\n            let prev = domPos;\n            domPos = prev.nextSibling;\n            prev.remove();\n        }\n        for (let item of this.items){\n            if (item.dom.parentNode == this.list) {\n                while(domPos != item.dom)rm();\n                domPos = item.dom.nextSibling;\n            } else {\n                this.list.insertBefore(item.dom, domPos);\n            }\n        }\n        while(domPos)rm();\n    }\n    moveSelection(selectedIndex) {\n        if (this.selectedIndex < 0) return;\n        let field = this.view.state.field(lintState);\n        let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);\n        if (!selection) return;\n        this.view.dispatch({\n            selection: {\n                anchor: selection.from,\n                head: selection.to\n            },\n            scrollIntoView: true,\n            effects: movePanelSelection.of(selection)\n        });\n    }\n    static open(view) {\n        return new LintPanel(view);\n    }\n}\nfunction svg(content, attrs = `viewBox=\"0 0 40 40\"`) {\n    return `url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" ${attrs}>${encodeURIComponent(content)}</svg>')`;\n}\nfunction underline(color) {\n    return svg(`<path d=\"m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0\" stroke=\"${color}\" fill=\"none\" stroke-width=\".7\"/>`, `width=\"6\" height=\"3\"`);\n}\nconst baseTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.baseTheme({\n    \".cm-diagnostic\": {\n        padding: \"3px 6px 3px 8px\",\n        marginLeft: \"-1px\",\n        display: \"block\",\n        whiteSpace: \"pre-wrap\"\n    },\n    \".cm-diagnostic-error\": {\n        borderLeft: \"5px solid #d11\"\n    },\n    \".cm-diagnostic-warning\": {\n        borderLeft: \"5px solid orange\"\n    },\n    \".cm-diagnostic-info\": {\n        borderLeft: \"5px solid #999\"\n    },\n    \".cm-diagnostic-hint\": {\n        borderLeft: \"5px solid #66d\"\n    },\n    \".cm-diagnosticAction\": {\n        font: \"inherit\",\n        border: \"none\",\n        padding: \"2px 4px\",\n        backgroundColor: \"#444\",\n        color: \"white\",\n        borderRadius: \"3px\",\n        marginLeft: \"8px\",\n        cursor: \"pointer\"\n    },\n    \".cm-diagnosticSource\": {\n        fontSize: \"70%\",\n        opacity: .7\n    },\n    \".cm-lintRange\": {\n        backgroundPosition: \"left bottom\",\n        backgroundRepeat: \"repeat-x\",\n        paddingBottom: \"0.7px\"\n    },\n    \".cm-lintRange-error\": {\n        backgroundImage: /*@__PURE__*/ underline(\"#d11\")\n    },\n    \".cm-lintRange-warning\": {\n        backgroundImage: /*@__PURE__*/ underline(\"orange\")\n    },\n    \".cm-lintRange-info\": {\n        backgroundImage: /*@__PURE__*/ underline(\"#999\")\n    },\n    \".cm-lintRange-hint\": {\n        backgroundImage: /*@__PURE__*/ underline(\"#66d\")\n    },\n    \".cm-lintRange-active\": {\n        backgroundColor: \"#ffdd9980\"\n    },\n    \".cm-tooltip-lint\": {\n        padding: 0,\n        margin: 0\n    },\n    \".cm-lintPoint\": {\n        position: \"relative\",\n        \"&:after\": {\n            content: '\"\"',\n            position: \"absolute\",\n            bottom: 0,\n            left: \"-2px\",\n            borderLeft: \"3px solid transparent\",\n            borderRight: \"3px solid transparent\",\n            borderBottom: \"4px solid #d11\"\n        }\n    },\n    \".cm-lintPoint-warning\": {\n        \"&:after\": {\n            borderBottomColor: \"orange\"\n        }\n    },\n    \".cm-lintPoint-info\": {\n        \"&:after\": {\n            borderBottomColor: \"#999\"\n        }\n    },\n    \".cm-lintPoint-hint\": {\n        \"&:after\": {\n            borderBottomColor: \"#66d\"\n        }\n    },\n    \".cm-panel.cm-panel-lint\": {\n        position: \"relative\",\n        \"& ul\": {\n            maxHeight: \"100px\",\n            overflowY: \"auto\",\n            \"& [aria-selected]\": {\n                backgroundColor: \"#ddd\",\n                \"& u\": {\n                    textDecoration: \"underline\"\n                }\n            },\n            \"&:focus [aria-selected]\": {\n                background_fallback: \"#bdf\",\n                backgroundColor: \"Highlight\",\n                color_fallback: \"white\",\n                color: \"HighlightText\"\n            },\n            \"& u\": {\n                textDecoration: \"none\"\n            },\n            padding: 0,\n            margin: 0\n        },\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"2px\",\n            background: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        }\n    }\n});\nfunction severityWeight(sev) {\n    return sev == \"error\" ? 4 : sev == \"warning\" ? 3 : sev == \"info\" ? 2 : 1;\n}\nclass LintGutterMarker extends _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.GutterMarker {\n    constructor(diagnostics){\n        super();\n        this.diagnostics = diagnostics;\n        this.severity = diagnostics.reduce((max, d)=>severityWeight(max) < severityWeight(d.severity) ? d.severity : max, \"hint\");\n    }\n    toDOM(view) {\n        let elt = document.createElement(\"div\");\n        elt.className = \"cm-lint-marker cm-lint-marker-\" + this.severity;\n        let diagnostics = this.diagnostics;\n        let diagnosticsFilter = view.state.facet(lintGutterConfig).tooltipFilter;\n        if (diagnosticsFilter) diagnostics = diagnosticsFilter(diagnostics, view.state);\n        if (diagnostics.length) elt.onmouseover = ()=>gutterMarkerMouseOver(view, elt, diagnostics);\n        return elt;\n    }\n}\nfunction trackHoverOn(view, marker) {\n    let mousemove = (event)=>{\n        let rect = marker.getBoundingClientRect();\n        if (event.clientX > rect.left - 10 /* Hover.Margin */  && event.clientX < rect.right + 10 /* Hover.Margin */  && event.clientY > rect.top - 10 /* Hover.Margin */  && event.clientY < rect.bottom + 10 /* Hover.Margin */ ) return;\n        for(let target = event.target; target; target = target.parentNode){\n            if (target.nodeType == 1 && target.classList.contains(\"cm-tooltip-lint\")) return;\n        }\n        window.removeEventListener(\"mousemove\", mousemove);\n        if (view.state.field(lintGutterTooltip)) view.dispatch({\n            effects: setLintGutterTooltip.of(null)\n        });\n    };\n    window.addEventListener(\"mousemove\", mousemove);\n}\nfunction gutterMarkerMouseOver(view, marker, diagnostics) {\n    function hovered() {\n        let line = view.elementAtHeight(marker.getBoundingClientRect().top + 5 - view.documentTop);\n        const linePos = view.coordsAtPos(line.from);\n        if (linePos) {\n            view.dispatch({\n                effects: setLintGutterTooltip.of({\n                    pos: line.from,\n                    above: false,\n                    create () {\n                        return {\n                            dom: diagnosticsTooltip(view, diagnostics),\n                            getCoords: ()=>marker.getBoundingClientRect()\n                        };\n                    }\n                })\n            });\n        }\n        marker.onmouseout = marker.onmousemove = null;\n        trackHoverOn(view, marker);\n    }\n    let { hoverTime } = view.state.facet(lintGutterConfig);\n    let hoverTimeout = setTimeout(hovered, hoverTime);\n    marker.onmouseout = ()=>{\n        clearTimeout(hoverTimeout);\n        marker.onmouseout = marker.onmousemove = null;\n    };\n    marker.onmousemove = ()=>{\n        clearTimeout(hoverTimeout);\n        hoverTimeout = setTimeout(hovered, hoverTime);\n    };\n}\nfunction markersForDiagnostics(doc, diagnostics) {\n    let byLine = Object.create(null);\n    for (let diagnostic of diagnostics){\n        let line = doc.lineAt(diagnostic.from);\n        (byLine[line.from] || (byLine[line.from] = [])).push(diagnostic);\n    }\n    let markers = [];\n    for(let line in byLine){\n        markers.push(new LintGutterMarker(byLine[line]).range(+line));\n    }\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.of(markers, true);\n}\nconst lintGutterExtension = /*@__PURE__*/ (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.gutter)({\n    class: \"cm-gutter-lint\",\n    markers: (view)=>view.state.field(lintGutterMarkers)\n});\nconst lintGutterMarkers = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n    create () {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.empty;\n    },\n    update (markers, tr) {\n        markers = markers.map(tr.changes);\n        let diagnosticFilter = tr.state.facet(lintGutterConfig).markerFilter;\n        for (let effect of tr.effects){\n            if (effect.is(setDiagnosticsEffect)) {\n                let diagnostics = effect.value;\n                if (diagnosticFilter) diagnostics = diagnosticFilter(diagnostics || [], tr.state);\n                markers = markersForDiagnostics(tr.state.doc, diagnostics.slice(0));\n            }\n        }\n        return markers;\n    }\n});\nconst setLintGutterTooltip = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\nconst lintGutterTooltip = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n    create () {\n        return null;\n    },\n    update (tooltip, tr) {\n        if (tooltip && tr.docChanged) tooltip = hideTooltip(tr, tooltip) ? null : Object.assign(Object.assign({}, tooltip), {\n            pos: tr.changes.mapPos(tooltip.pos)\n        });\n        return tr.effects.reduce((t, e)=>e.is(setLintGutterTooltip) ? e.value : t, tooltip);\n    },\n    provide: (field)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.showTooltip.from(field)\n});\nconst lintGutterTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.baseTheme({\n    \".cm-gutter-lint\": {\n        width: \"1.4em\",\n        \"& .cm-gutterElement\": {\n            padding: \".2em\"\n        }\n    },\n    \".cm-lint-marker\": {\n        width: \"1em\",\n        height: \"1em\"\n    },\n    \".cm-lint-marker-info\": {\n        content: /*@__PURE__*/ svg(`<path fill=\"#aaf\" stroke=\"#77e\" stroke-width=\"6\" stroke-linejoin=\"round\" d=\"M5 5L35 5L35 35L5 35Z\"/>`)\n    },\n    \".cm-lint-marker-warning\": {\n        content: /*@__PURE__*/ svg(`<path fill=\"#fe8\" stroke=\"#fd7\" stroke-width=\"6\" stroke-linejoin=\"round\" d=\"M20 6L37 35L3 35Z\"/>`)\n    },\n    \".cm-lint-marker-error\": {\n        content: /*@__PURE__*/ svg(`<circle cx=\"20\" cy=\"20\" r=\"15\" fill=\"#f87\" stroke=\"#f43\" stroke-width=\"6\"/>`)\n    }\n});\nconst lintExtensions = [\n    lintState,\n    /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.decorations.compute([\n        lintState\n    ], (state)=>{\n        let { selected, panel } = state.field(lintState);\n        return !selected || !panel || selected.from == selected.to ? _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.none : _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.set([\n            activeMark.range(selected.from, selected.to)\n        ]);\n    }),\n    /*@__PURE__*/ (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.hoverTooltip)(lintTooltip, {\n        hideOn: hideTooltip\n    }),\n    baseTheme\n];\nconst lintGutterConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(configs, {\n            hoverTime: 300 /* Hover.Time */ ,\n            markerFilter: null,\n            tooltipFilter: null\n        });\n    }\n});\n/**\nReturns an extension that installs a gutter showing markers for\neach line that has diagnostics, which can be hovered over to see\nthe diagnostics.\n*/ function lintGutter(config = {}) {\n    return [\n        lintGutterConfig.of(config),\n        lintGutterMarkers,\n        lintGutterExtension,\n        lintGutterTheme,\n        lintGutterTooltip\n    ];\n}\n/**\nIterate over the marked diagnostics for the given editor state,\ncalling `f` for each of them. Note that, if the document changed\nsince the diagnostics were created, the `Diagnostic` object will\nhold the original outdated position, whereas the `to` and `from`\narguments hold the diagnostic's current position.\n*/ function forEachDiagnostic(state, f) {\n    let lState = state.field(lintState, false);\n    if (lState && lState.diagnostics.size) for(let iter = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.iter([\n        lState.diagnostics\n    ]); iter.value; iter.next())f(iter.value.spec.diagnostic, iter.from, iter.to);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGludC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzSztBQUMxRTtBQUNwRTtBQUV4QixNQUFNaUI7SUFDRkMsWUFBWUMsSUFBSSxFQUFFQyxFQUFFLEVBQUVDLFVBQVUsQ0FBRTtRQUM5QixJQUFJLENBQUNGLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLEVBQUUsR0FBR0E7UUFDVixJQUFJLENBQUNDLFVBQVUsR0FBR0E7SUFDdEI7QUFDSjtBQUNBLE1BQU1DO0lBQ0ZKLFlBQVlLLFdBQVcsRUFBRUMsS0FBSyxFQUFFQyxRQUFRLENBQUU7UUFDdEMsSUFBSSxDQUFDRixXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQ0MsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsUUFBUSxHQUFHQTtJQUNwQjtJQUNBLE9BQU9DLEtBQUtILFdBQVcsRUFBRUMsS0FBSyxFQUFFRyxLQUFLLEVBQUU7UUFDbkMsNkRBQTZEO1FBQzdELElBQUlDLG9CQUFvQkw7UUFDeEIsSUFBSU0sbUJBQW1CRixNQUFNRyxLQUFLLENBQUNDLFlBQVlDLFlBQVk7UUFDM0QsSUFBSUgsa0JBQ0FELG9CQUFvQkMsaUJBQWlCRCxtQkFBbUJEO1FBQzVELElBQUlNLFNBQVNqQyx3REFBVUEsQ0FBQ2tDLEdBQUcsQ0FBQ04sa0JBQWtCTyxHQUFHLENBQUMsQ0FBQ0M7WUFDL0MsK0VBQStFO1lBQy9FLE9BQU9BLEVBQUVqQixJQUFJLElBQUlpQixFQUFFaEIsRUFBRSxJQUFLZ0IsRUFBRWpCLElBQUksSUFBSWlCLEVBQUVoQixFQUFFLEdBQUcsS0FBS08sTUFBTVUsR0FBRyxDQUFDQyxNQUFNLENBQUNGLEVBQUVqQixJQUFJLEVBQUVDLEVBQUUsSUFBSWdCLEVBQUVqQixJQUFJLEdBQy9FbkIsd0RBQVVBLENBQUN1QyxNQUFNLENBQUM7Z0JBQ2hCQSxRQUFRLElBQUlDLGlCQUFpQko7Z0JBQzdCZixZ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QUFFc08sUUFBUWxSO0lBQVk7SUFDN0R5TTtDQUNIO0FBQ0QsTUFBTXFDLG1CQUFtQixXQUFXLEdBQUV0UixvREFBS0EsQ0FBQzZELE1BQU0sQ0FBQztJQUMvQ3VGLFNBQVF1SyxPQUFPO1FBQ1gsT0FBTzFULGdFQUFhQSxDQUFDMFQsU0FBUztZQUMxQmIsV0FBVyxJQUFJLGNBQWM7WUFDN0IzUixjQUFjO1lBQ2QwRSxlQUFlO1FBQ25CO0lBQ0o7QUFDSjtBQUNBOzs7O0FBSUEsR0FDQSxTQUFTK04sV0FBVzdLLFNBQVMsQ0FBQyxDQUFDO0lBQzNCLE9BQU87UUFBQ3VJLGlCQUFpQjVOLEVBQUUsQ0FBQ3FGO1FBQVNxSztRQUFtQkQ7UUFBcUJJO1FBQWlCcEI7S0FBa0I7QUFDcEg7QUFDQTs7Ozs7O0FBTUEsR0FDQSxTQUFTMEIsa0JBQWtCL1MsS0FBSyxFQUFFOEQsQ0FBQztJQUMvQixJQUFJa1AsU0FBU2hULE1BQU13QyxLQUFLLENBQUNDLFdBQVc7SUFDcEMsSUFBSXVRLFVBQVVBLE9BQU9wVCxXQUFXLENBQUN3RSxJQUFJLEVBQ2pDLElBQUssSUFBSTRCLE9BQU81Ryx1REFBUUEsQ0FBQzRHLElBQUksQ0FBQztRQUFDZ04sT0FBT3BULFdBQVc7S0FBQyxHQUFHb0csS0FBSzNDLEtBQUssRUFBRTJDLEtBQUtELElBQUksR0FDdEVqQyxFQUFFa0MsS0FBSzNDLEtBQUssQ0FBQzVCLElBQUksQ0FBQy9CLFVBQVUsRUFBRXNHLEtBQUt4RyxJQUFJLEVBQUV3RyxLQUFLdkcsRUFBRTtBQUM1RDtBQUVxTSIsInNvdXJjZXMiOlsid2VicGFjazovL21iYy8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9saW50L2Rpc3QvaW5kZXguanM/ZjlkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEZWNvcmF0aW9uLCBzaG93UGFuZWwsIEVkaXRvclZpZXcsIFZpZXdQbHVnaW4sIGxvZ0V4Y2VwdGlvbiwgZ3V0dGVyLCBzaG93VG9vbHRpcCwgaG92ZXJUb29sdGlwLCBnZXRQYW5lbCwgV2lkZ2V0VHlwZSwgR3V0dGVyTWFya2VyIH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQgeyBTdGF0ZUVmZmVjdCwgU3RhdGVGaWVsZCwgRmFjZXQsIGNvbWJpbmVDb25maWcsIFJhbmdlU2V0IH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IGVsdCBmcm9tICdjcmVsdCc7XG5cbmNsYXNzIFNlbGVjdGVkRGlhZ25vc3RpYyB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIGRpYWdub3N0aWMpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmRpYWdub3N0aWMgPSBkaWFnbm9zdGljO1xuICAgIH1cbn1cbmNsYXNzIExpbnRTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoZGlhZ25vc3RpY3MsIHBhbmVsLCBzZWxlY3RlZCkge1xuICAgICAgICB0aGlzLmRpYWdub3N0aWNzID0gZGlhZ25vc3RpY3M7XG4gICAgICAgIHRoaXMucGFuZWwgPSBwYW5lbDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgIH1cbiAgICBzdGF0aWMgaW5pdChkaWFnbm9zdGljcywgcGFuZWwsIHN0YXRlKSB7XG4gICAgICAgIC8vIEZpbHRlciB0aGUgbGlzdCBvZiBkaWFnbm9zdGljcyBmb3Igd2hpY2ggdG8gY3JlYXRlIG1hcmtlcnNcbiAgICAgICAgbGV0IG1hcmtlZERpYWdub3N0aWNzID0gZGlhZ25vc3RpY3M7XG4gICAgICAgIGxldCBkaWFnbm9zdGljRmlsdGVyID0gc3RhdGUuZmFjZXQobGludENvbmZpZykubWFya2VyRmlsdGVyO1xuICAgICAgICBpZiAoZGlhZ25vc3RpY0ZpbHRlcilcbiAgICAgICAgICAgIG1hcmtlZERpYWdub3N0aWNzID0gZGlhZ25vc3RpY0ZpbHRlcihtYXJrZWREaWFnbm9zdGljcywgc3RhdGUpO1xuICAgICAgICBsZXQgcmFuZ2VzID0gRGVjb3JhdGlvbi5zZXQobWFya2VkRGlhZ25vc3RpY3MubWFwKChkKSA9PiB7XG4gICAgICAgICAgICAvLyBGb3IgemVyby1sZW5ndGggcmFuZ2VzIG9yIHJhbmdlcyBjb3ZlcmluZyBvbmx5IGEgbGluZSBicmVhaywgY3JlYXRlIGEgd2lkZ2V0XG4gICAgICAgICAgICByZXR1cm4gZC5mcm9tID09IGQudG8gfHwgKGQuZnJvbSA9PSBkLnRvIC0gMSAmJiBzdGF0ZS5kb2MubGluZUF0KGQuZnJvbSkudG8gPT0gZC5mcm9tKVxuICAgICAgICAgICAgICAgID8gRGVjb3JhdGlvbi53aWRnZXQoe1xuICAgICAgICAgICAgICAgICAgICB3aWRnZXQ6IG5ldyBEaWFnbm9zdGljV2lkZ2V0KGQpLFxuICAgICAgICAgICAgICAgICAgICBkaWFnbm9zdGljOiBkXG4gICAgICAgICAgICAgICAgfSkucmFuZ2UoZC5mcm9tKVxuICAgICAgICAgICAgICAgIDogRGVjb3JhdGlvbi5tYXJrKHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogeyBjbGFzczogXCJjbS1saW50UmFuZ2UgY20tbGludFJhbmdlLVwiICsgZC5zZXZlcml0eSArIChkLm1hcmtDbGFzcyA/IFwiIFwiICsgZC5tYXJrQ2xhc3MgOiBcIlwiKSB9LFxuICAgICAgICAgICAgICAgICAgICBkaWFnbm9zdGljOiBkLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWVcbiAgICAgICAgICAgICAgICB9KS5yYW5nZShkLmZyb20sIGQudG8pO1xuICAgICAgICB9KSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgTGludFN0YXRlKHJhbmdlcywgcGFuZWwsIGZpbmREaWFnbm9zdGljKHJhbmdlcykpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmREaWFnbm9zdGljKGRpYWdub3N0aWNzLCBkaWFnbm9zdGljID0gbnVsbCwgYWZ0ZXIgPSAwKSB7XG4gICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICBkaWFnbm9zdGljcy5iZXR3ZWVuKGFmdGVyLCAxZTksIChmcm9tLCB0bywgeyBzcGVjIH0pID0+IHtcbiAgICAgICAgaWYgKGRpYWdub3N0aWMgJiYgc3BlYy5kaWFnbm9zdGljICE9IGRpYWdub3N0aWMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvdW5kID0gbmV3IFNlbGVjdGVkRGlhZ25vc3RpYyhmcm9tLCB0bywgc3BlYy5kaWFnbm9zdGljKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIGhpZGVUb29sdGlwKHRyLCB0b29sdGlwKSB7XG4gICAgbGV0IGxpbmUgPSB0ci5zdGFydFN0YXRlLmRvYy5saW5lQXQodG9vbHRpcC5wb3MpO1xuICAgIHJldHVybiAhISh0ci5lZmZlY3RzLnNvbWUoZSA9PiBlLmlzKHNldERpYWdub3N0aWNzRWZmZWN0KSkgfHwgdHIuY2hhbmdlcy50b3VjaGVzUmFuZ2UobGluZS5mcm9tLCBsaW5lLnRvKSk7XG59XG5mdW5jdGlvbiBtYXliZUVuYWJsZUxpbnQoc3RhdGUsIGVmZmVjdHMpIHtcbiAgICByZXR1cm4gc3RhdGUuZmllbGQobGludFN0YXRlLCBmYWxzZSkgPyBlZmZlY3RzIDogZWZmZWN0cy5jb25jYXQoU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnLm9mKGxpbnRFeHRlbnNpb25zKSk7XG59XG4vKipcblJldHVybnMgYSB0cmFuc2FjdGlvbiBzcGVjIHdoaWNoIHVwZGF0ZXMgdGhlIGN1cnJlbnQgc2V0IG9mXG5kaWFnbm9zdGljcywgYW5kIGVuYWJsZXMgdGhlIGxpbnQgZXh0ZW5zaW9uIGlmIGlmIHdhc24ndCBhbHJlYWR5XG5hY3RpdmUuXG4qL1xuZnVuY3Rpb24gc2V0RGlhZ25vc3RpY3Moc3RhdGUsIGRpYWdub3N0aWNzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZWZmZWN0czogbWF5YmVFbmFibGVMaW50KHN0YXRlLCBbc2V0RGlhZ25vc3RpY3NFZmZlY3Qub2YoZGlhZ25vc3RpY3MpXSlcbiAgICB9O1xufVxuLyoqXG5UaGUgc3RhdGUgZWZmZWN0IHRoYXQgdXBkYXRlcyB0aGUgc2V0IG9mIGFjdGl2ZSBkaWFnbm9zdGljcy4gQ2FuXG5iZSB1c2VmdWwgd2hlbiB3cml0aW5nIGFuIGV4dGVuc2lvbiB0aGF0IG5lZWRzIHRvIHRyYWNrIHRoZXNlLlxuKi9cbmNvbnN0IHNldERpYWdub3N0aWNzRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgdG9nZ2xlUGFuZWwgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBtb3ZlUGFuZWxTZWxlY3Rpb24gPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBsaW50U3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW50U3RhdGUoRGVjb3JhdGlvbi5ub25lLCBudWxsLCBudWxsKTtcbiAgICB9LFxuICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHtcbiAgICAgICAgaWYgKHRyLmRvY0NoYW5nZWQpIHtcbiAgICAgICAgICAgIGxldCBtYXBwZWQgPSB2YWx1ZS5kaWFnbm9zdGljcy5tYXAodHIuY2hhbmdlcyksIHNlbGVjdGVkID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIGxldCBzZWxQb3MgPSB0ci5jaGFuZ2VzLm1hcFBvcyh2YWx1ZS5zZWxlY3RlZC5mcm9tLCAxKTtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IGZpbmREaWFnbm9zdGljKG1hcHBlZCwgdmFsdWUuc2VsZWN0ZWQuZGlhZ25vc3RpYywgc2VsUG9zKSB8fCBmaW5kRGlhZ25vc3RpYyhtYXBwZWQsIG51bGwsIHNlbFBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBMaW50U3RhdGUobWFwcGVkLCB2YWx1ZS5wYW5lbCwgc2VsZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldERpYWdub3N0aWNzRWZmZWN0KSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gTGludFN0YXRlLmluaXQoZWZmZWN0LnZhbHVlLCB2YWx1ZS5wYW5lbCwgdHIuc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKHRvZ2dsZVBhbmVsKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IExpbnRTdGF0ZSh2YWx1ZS5kaWFnbm9zdGljcywgZWZmZWN0LnZhbHVlID8gTGludFBhbmVsLm9wZW4gOiBudWxsLCB2YWx1ZS5zZWxlY3RlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXMobW92ZVBhbmVsU2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IExpbnRTdGF0ZSh2YWx1ZS5kaWFnbm9zdGljcywgdmFsdWUucGFuZWwsIGVmZmVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBbc2hvd1BhbmVsLmZyb20oZiwgdmFsID0+IHZhbC5wYW5lbCksXG4gICAgICAgIEVkaXRvclZpZXcuZGVjb3JhdGlvbnMuZnJvbShmLCBzID0+IHMuZGlhZ25vc3RpY3MpXVxufSk7XG4vKipcblJldHVybnMgdGhlIG51bWJlciBvZiBhY3RpdmUgbGludCBkaWFnbm9zdGljcyBpbiB0aGUgZ2l2ZW4gc3RhdGUuXG4qL1xuZnVuY3Rpb24gZGlhZ25vc3RpY0NvdW50KHN0YXRlKSB7XG4gICAgbGV0IGxpbnQgPSBzdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKTtcbiAgICByZXR1cm4gbGludCA/IGxpbnQuZGlhZ25vc3RpY3Muc2l6ZSA6IDA7XG59XG5jb25zdCBhY3RpdmVNYXJrID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLWxpbnRSYW5nZSBjbS1saW50UmFuZ2UtYWN0aXZlXCIsIGluY2x1c2l2ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGxpbnRUb29sdGlwKHZpZXcsIHBvcywgc2lkZSkge1xuICAgIGxldCB7IGRpYWdub3N0aWNzIH0gPSB2aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSk7XG4gICAgbGV0IGZvdW5kID0gW10sIHN0YWNrU3RhcnQgPSAyZTgsIHN0YWNrRW5kID0gMDtcbiAgICBkaWFnbm9zdGljcy5iZXR3ZWVuKHBvcyAtIChzaWRlIDwgMCA/IDEgOiAwKSwgcG9zICsgKHNpZGUgPiAwID8gMSA6IDApLCAoZnJvbSwgdG8sIHsgc3BlYyB9KSA9PiB7XG4gICAgICAgIGlmIChwb3MgPj0gZnJvbSAmJiBwb3MgPD0gdG8gJiZcbiAgICAgICAgICAgIChmcm9tID09IHRvIHx8ICgocG9zID4gZnJvbSB8fCBzaWRlID4gMCkgJiYgKHBvcyA8IHRvIHx8IHNpZGUgPCAwKSkpKSB7XG4gICAgICAgICAgICBmb3VuZC5wdXNoKHNwZWMuZGlhZ25vc3RpYyk7XG4gICAgICAgICAgICBzdGFja1N0YXJ0ID0gTWF0aC5taW4oZnJvbSwgc3RhY2tTdGFydCk7XG4gICAgICAgICAgICBzdGFja0VuZCA9IE1hdGgubWF4KHRvLCBzdGFja0VuZCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgZGlhZ25vc3RpY0ZpbHRlciA9IHZpZXcuc3RhdGUuZmFjZXQobGludENvbmZpZykudG9vbHRpcEZpbHRlcjtcbiAgICBpZiAoZGlhZ25vc3RpY0ZpbHRlcilcbiAgICAgICAgZm91bmQgPSBkaWFnbm9zdGljRmlsdGVyKGZvdW5kLCB2aWV3LnN0YXRlKTtcbiAgICBpZiAoIWZvdW5kLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9zOiBzdGFja1N0YXJ0LFxuICAgICAgICBlbmQ6IHN0YWNrRW5kLFxuICAgICAgICBhYm92ZTogdmlldy5zdGF0ZS5kb2MubGluZUF0KHN0YWNrU3RhcnQpLnRvIDwgc3RhY2tFbmQsXG4gICAgICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRvbTogZGlhZ25vc3RpY3NUb29sdGlwKHZpZXcsIGZvdW5kKSB9O1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRpYWdub3N0aWNzVG9vbHRpcCh2aWV3LCBkaWFnbm9zdGljcykge1xuICAgIHJldHVybiBlbHQoXCJ1bFwiLCB7IGNsYXNzOiBcImNtLXRvb2x0aXAtbGludFwiIH0sIGRpYWdub3N0aWNzLm1hcChkID0+IHJlbmRlckRpYWdub3N0aWModmlldywgZCwgZmFsc2UpKSk7XG59XG4vKipcbkNvbW1hbmQgdG8gb3BlbiBhbmQgZm9jdXMgdGhlIGxpbnQgcGFuZWwuXG4qL1xuY29uc3Qgb3BlbkxpbnRQYW5lbCA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGZpZWxkID0gdmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWZpZWxkIHx8ICFmaWVsZC5wYW5lbClcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IG1heWJlRW5hYmxlTGludCh2aWV3LnN0YXRlLCBbdG9nZ2xlUGFuZWwub2YodHJ1ZSldKSB9KTtcbiAgICBsZXQgcGFuZWwgPSBnZXRQYW5lbCh2aWV3LCBMaW50UGFuZWwub3Blbik7XG4gICAgaWYgKHBhbmVsKVxuICAgICAgICBwYW5lbC5kb20ucXVlcnlTZWxlY3RvcihcIi5jbS1wYW5lbC1saW50IHVsXCIpLmZvY3VzKCk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Db21tYW5kIHRvIGNsb3NlIHRoZSBsaW50IHBhbmVsLCB3aGVuIG9wZW4uXG4qL1xuY29uc3QgY2xvc2VMaW50UGFuZWwgPSAodmlldykgPT4ge1xuICAgIGxldCBmaWVsZCA9IHZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFmaWVsZCB8fCAhZmllbGQucGFuZWwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdG9nZ2xlUGFuZWwub2YoZmFsc2UpIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBuZXh0IGRpYWdub3N0aWMuXG4qL1xuY29uc3QgbmV4dERpYWdub3N0aWMgPSAodmlldykgPT4ge1xuICAgIGxldCBmaWVsZCA9IHZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFmaWVsZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLCBuZXh0ID0gZmllbGQuZGlhZ25vc3RpY3MuaXRlcihzZWwudG8gKyAxKTtcbiAgICBpZiAoIW5leHQudmFsdWUpIHtcbiAgICAgICAgbmV4dCA9IGZpZWxkLmRpYWdub3N0aWNzLml0ZXIoMCk7XG4gICAgICAgIGlmICghbmV4dC52YWx1ZSB8fCBuZXh0LmZyb20gPT0gc2VsLmZyb20gJiYgbmV4dC50byA9PSBzZWwudG8pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZpZXcuZGlzcGF0Y2goeyBzZWxlY3Rpb246IHsgYW5jaG9yOiBuZXh0LmZyb20sIGhlYWQ6IG5leHQudG8gfSwgc2Nyb2xsSW50b1ZpZXc6IHRydWUgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIHByZXZpb3VzIGRpYWdub3N0aWMuXG4qL1xuY29uc3QgcHJldmlvdXNEaWFnbm9zdGljID0gKHZpZXcpID0+IHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgZmllbGQgPSBzdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWZpZWxkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGxldCBwcmV2RnJvbSwgcHJldlRvLCBsYXN0RnJvbSwgbGFzdFRvO1xuICAgIGZpZWxkLmRpYWdub3N0aWNzLmJldHdlZW4oMCwgc3RhdGUuZG9jLmxlbmd0aCwgKGZyb20sIHRvKSA9PiB7XG4gICAgICAgIGlmICh0byA8IHNlbC50byAmJiAocHJldkZyb20gPT0gbnVsbCB8fCBwcmV2RnJvbSA8IGZyb20pKSB7XG4gICAgICAgICAgICBwcmV2RnJvbSA9IGZyb207XG4gICAgICAgICAgICBwcmV2VG8gPSB0bztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdEZyb20gPT0gbnVsbCB8fCBmcm9tID4gbGFzdEZyb20pIHtcbiAgICAgICAgICAgIGxhc3RGcm9tID0gZnJvbTtcbiAgICAgICAgICAgIGxhc3RUbyA9IHRvO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGxhc3RGcm9tID09IG51bGwgfHwgcHJldkZyb20gPT0gbnVsbCAmJiBsYXN0RnJvbSA9PSBzZWwuZnJvbSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBzZWxlY3Rpb246IHsgYW5jaG9yOiBwcmV2RnJvbSAhPT0gbnVsbCAmJiBwcmV2RnJvbSAhPT0gdm9pZCAwID8gcHJldkZyb20gOiBsYXN0RnJvbSwgaGVhZDogcHJldlRvICE9PSBudWxsICYmIHByZXZUbyAhPT0gdm9pZCAwID8gcHJldlRvIDogbGFzdFRvIH0sIHNjcm9sbEludG9WaWV3OiB0cnVlIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQSBzZXQgb2YgZGVmYXVsdCBrZXkgYmluZGluZ3MgZm9yIHRoZSBsaW50IGZ1bmN0aW9uYWxpdHkuXG5cbi0gQ3RybC1TaGlmdC1tIChDbWQtU2hpZnQtbSBvbiBtYWNPUyk6IFtgb3BlbkxpbnRQYW5lbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGludC5vcGVuTGludFBhbmVsKVxuLSBGODogW2BuZXh0RGlhZ25vc3RpY2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGludC5uZXh0RGlhZ25vc3RpYylcbiovXG5jb25zdCBsaW50S2V5bWFwID0gW1xuICAgIHsga2V5OiBcIk1vZC1TaGlmdC1tXCIsIHJ1bjogb3BlbkxpbnRQYW5lbCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJGOFwiLCBydW46IG5leHREaWFnbm9zdGljIH1cbl07XG5jb25zdCBsaW50UGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMudGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLnNldCA9IHRydWU7XG4gICAgICAgIGxldCB7IGRlbGF5IH0gPSB2aWV3LnN0YXRlLmZhY2V0KGxpbnRDb25maWcpO1xuICAgICAgICB0aGlzLmxpbnRUaW1lID0gRGF0ZS5ub3coKSArIGRlbGF5O1xuICAgICAgICB0aGlzLnJ1biA9IHRoaXMucnVuLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5ydW4sIGRlbGF5KTtcbiAgICB9XG4gICAgcnVuKCkge1xuICAgICAgICBsZXQgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKG5vdyA8IHRoaXMubGludFRpbWUgLSAxMCkge1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLnJ1biwgdGhpcy5saW50VGltZSAtIG5vdyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHRoaXMudmlldywgeyBzb3VyY2VzIH0gPSBzdGF0ZS5mYWNldChsaW50Q29uZmlnKTtcbiAgICAgICAgICAgIGlmIChzb3VyY2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChzb3VyY2VzLm1hcChzb3VyY2UgPT4gUHJvbWlzZS5yZXNvbHZlKHNvdXJjZSh0aGlzLnZpZXcpKSkpLnRoZW4oYW5ub3RhdGlvbnMgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWxsID0gYW5ub3RhdGlvbnMucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUuZG9jID09IHN0YXRlLmRvYylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaChzZXREaWFnbm9zdGljcyh0aGlzLnZpZXcuc3RhdGUsIGFsbCkpO1xuICAgICAgICAgICAgICAgIH0sIGVycm9yID0+IHsgbG9nRXhjZXB0aW9uKHRoaXMudmlldy5zdGF0ZSwgZXJyb3IpOyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBjb25maWcgPSB1cGRhdGUuc3RhdGUuZmFjZXQobGludENvbmZpZyk7XG4gICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCB8fCBjb25maWcgIT0gdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQobGludENvbmZpZykgfHxcbiAgICAgICAgICAgIGNvbmZpZy5uZWVkc1JlZnJlc2ggJiYgY29uZmlnLm5lZWRzUmVmcmVzaCh1cGRhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLmxpbnRUaW1lID0gRGF0ZS5ub3coKSArIGNvbmZpZy5kZWxheTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLnJ1biwgY29uZmlnLmRlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3JjZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0KSB7XG4gICAgICAgICAgICB0aGlzLmxpbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHRoaXMucnVuKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgfVxufSk7XG5jb25zdCBsaW50Q29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHNvdXJjZXM6IGlucHV0Lm1hcChpID0+IGkuc291cmNlKS5maWx0ZXIoeCA9PiB4ICE9IG51bGwpIH0sIGNvbWJpbmVDb25maWcoaW5wdXQubWFwKGkgPT4gaS5jb25maWcpLCB7XG4gICAgICAgICAgICBkZWxheTogNzUwLFxuICAgICAgICAgICAgbWFya2VyRmlsdGVyOiBudWxsLFxuICAgICAgICAgICAgdG9vbHRpcEZpbHRlcjogbnVsbCxcbiAgICAgICAgICAgIG5lZWRzUmVmcmVzaDogbnVsbFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuZWVkc1JlZnJlc2g6IChhLCBiKSA9PiAhYSA/IGIgOiAhYiA/IGEgOiB1ID0+IGEodSkgfHwgYih1KVxuICAgICAgICB9KSk7XG4gICAgfVxufSk7XG4vKipcbkdpdmVuIGEgZGlhZ25vc3RpYyBzb3VyY2UsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBleHRlbnNpb24gdGhhdFxuZW5hYmxlcyBsaW50aW5nIHdpdGggdGhhdCBzb3VyY2UuIEl0IHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIHRoZVxuZWRpdG9yIGlzIGlkbGUgKGFmdGVyIGl0cyBjb250ZW50IGNoYW5nZWQpLiBJZiBgbnVsbGAgaXMgZ2l2ZW4gYXNcbnNvdXJjZSwgdGhpcyBvbmx5IGNvbmZpZ3VyZXMgdGhlIGxpbnQgZXh0ZW5zaW9uLlxuKi9cbmZ1bmN0aW9uIGxpbnRlcihzb3VyY2UsIGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbGludENvbmZpZy5vZih7IHNvdXJjZSwgY29uZmlnIH0pLFxuICAgICAgICBsaW50UGx1Z2luLFxuICAgICAgICBsaW50RXh0ZW5zaW9uc1xuICAgIF07XG59XG4vKipcbkZvcmNlcyBhbnkgbGludGVycyBbY29uZmlndXJlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsaW50LmxpbnRlcikgdG8gcnVuIHdoZW4gdGhlXG5lZGl0b3IgaXMgaWRsZSB0byBydW4gcmlnaHQgYXdheS5cbiovXG5mdW5jdGlvbiBmb3JjZUxpbnRpbmcodmlldykge1xuICAgIGxldCBwbHVnaW4gPSB2aWV3LnBsdWdpbihsaW50UGx1Z2luKTtcbiAgICBpZiAocGx1Z2luKVxuICAgICAgICBwbHVnaW4uZm9yY2UoKTtcbn1cbmZ1bmN0aW9uIGFzc2lnbktleXMoYWN0aW9ucykge1xuICAgIGxldCBhc3NpZ25lZCA9IFtdO1xuICAgIGlmIChhY3Rpb25zKVxuICAgICAgICBhY3Rpb25zOiBmb3IgKGxldCB7IG5hbWUgfSBvZiBhY3Rpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY2ggPSBuYW1lW2ldO1xuICAgICAgICAgICAgICAgIGlmICgvW2EtekEtWl0vLnRlc3QoY2gpICYmICFhc3NpZ25lZC5zb21lKGMgPT4gYy50b0xvd2VyQ2FzZSgpID09IGNoLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbmVkLnB1c2goY2gpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBhY3Rpb25zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2lnbmVkLnB1c2goXCJcIik7XG4gICAgICAgIH1cbiAgICByZXR1cm4gYXNzaWduZWQ7XG59XG5mdW5jdGlvbiByZW5kZXJEaWFnbm9zdGljKHZpZXcsIGRpYWdub3N0aWMsIGluUGFuZWwpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IGtleXMgPSBpblBhbmVsID8gYXNzaWduS2V5cyhkaWFnbm9zdGljLmFjdGlvbnMpIDogW107XG4gICAgcmV0dXJuIGVsdChcImxpXCIsIHsgY2xhc3M6IFwiY20tZGlhZ25vc3RpYyBjbS1kaWFnbm9zdGljLVwiICsgZGlhZ25vc3RpYy5zZXZlcml0eSB9LCBlbHQoXCJzcGFuXCIsIHsgY2xhc3M6IFwiY20tZGlhZ25vc3RpY1RleHRcIiB9LCBkaWFnbm9zdGljLnJlbmRlck1lc3NhZ2UgPyBkaWFnbm9zdGljLnJlbmRlck1lc3NhZ2UoKSA6IGRpYWdub3N0aWMubWVzc2FnZSksIChfYSA9IGRpYWdub3N0aWMuYWN0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoYWN0aW9uLCBpKSA9PiB7XG4gICAgICAgIGxldCBmaXJlZCA9IGZhbHNlLCBjbGljayA9IChlKSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAoZmlyZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gZmluZERpYWdub3N0aWModmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUpLmRpYWdub3N0aWNzLCBkaWFnbm9zdGljKTtcbiAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICBhY3Rpb24uYXBwbHkodmlldywgZm91bmQuZnJvbSwgZm91bmQudG8pO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgeyBuYW1lIH0gPSBhY3Rpb24sIGtleUluZGV4ID0ga2V5c1tpXSA/IG5hbWUuaW5kZXhPZihrZXlzW2ldKSA6IC0xO1xuICAgICAgICBsZXQgbmFtZUVsdCA9IGtleUluZGV4IDwgMCA/IG5hbWUgOiBbbmFtZS5zbGljZSgwLCBrZXlJbmRleCksXG4gICAgICAgICAgICBlbHQoXCJ1XCIsIG5hbWUuc2xpY2Uoa2V5SW5kZXgsIGtleUluZGV4ICsgMSkpLFxuICAgICAgICAgICAgbmFtZS5zbGljZShrZXlJbmRleCArIDEpXTtcbiAgICAgICAgcmV0dXJuIGVsdChcImJ1dHRvblwiLCB7XG4gICAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICAgICAgY2xhc3M6IFwiY20tZGlhZ25vc3RpY0FjdGlvblwiLFxuICAgICAgICAgICAgb25jbGljazogY2xpY2ssXG4gICAgICAgICAgICBvbm1vdXNlZG93bjogY2xpY2ssXG4gICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogYCBBY3Rpb246ICR7bmFtZX0ke2tleUluZGV4IDwgMCA/IFwiXCIgOiBgIChhY2Nlc3Mga2V5IFwiJHtrZXlzW2ldfSlcImB9LmBcbiAgICAgICAgfSwgbmFtZUVsdCk7XG4gICAgfSksIGRpYWdub3N0aWMuc291cmNlICYmIGVsdChcImRpdlwiLCB7IGNsYXNzOiBcImNtLWRpYWdub3N0aWNTb3VyY2VcIiB9LCBkaWFnbm9zdGljLnNvdXJjZSkpO1xufVxuY2xhc3MgRGlhZ25vc3RpY1dpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGRpYWdub3N0aWMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5kaWFnbm9zdGljID0gZGlhZ25vc3RpYztcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLmRpYWdub3N0aWMgPT0gdGhpcy5kaWFnbm9zdGljOyB9XG4gICAgdG9ET00oKSB7XG4gICAgICAgIHJldHVybiBlbHQoXCJzcGFuXCIsIHsgY2xhc3M6IFwiY20tbGludFBvaW50IGNtLWxpbnRQb2ludC1cIiArIHRoaXMuZGlhZ25vc3RpYy5zZXZlcml0eSB9KTtcbiAgICB9XG59XG5jbGFzcyBQYW5lbEl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIGRpYWdub3N0aWMpIHtcbiAgICAgICAgdGhpcy5kaWFnbm9zdGljID0gZGlhZ25vc3RpYztcbiAgICAgICAgdGhpcy5pZCA9IFwiaXRlbV9cIiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgdGhpcy5kb20gPSByZW5kZXJEaWFnbm9zdGljKHZpZXcsIGRpYWdub3N0aWMsIHRydWUpO1xuICAgICAgICB0aGlzLmRvbS5pZCA9IHRoaXMuaWQ7XG4gICAgICAgIHRoaXMuZG9tLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJvcHRpb25cIik7XG4gICAgfVxufVxuY2xhc3MgTGludFBhbmVsIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICAgICAgbGV0IG9ua2V5ZG93biA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMjcpIHsgLy8gRXNjYXBlXG4gICAgICAgICAgICAgICAgY2xvc2VMaW50UGFuZWwodGhpcy52aWV3KTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMzggfHwgZXZlbnQua2V5Q29kZSA9PSAzMykgeyAvLyBBcnJvd1VwLCBQYWdlVXBcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVTZWxlY3Rpb24oKHRoaXMuc2VsZWN0ZWRJbmRleCAtIDEgKyB0aGlzLml0ZW1zLmxlbmd0aCkgJSB0aGlzLml0ZW1zLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IDQwIHx8IGV2ZW50LmtleUNvZGUgPT0gMzQpIHsgLy8gQXJyb3dEb3duLCBQYWdlRG93blxuICAgICAgICAgICAgICAgIHRoaXMubW92ZVNlbGVjdGlvbigodGhpcy5zZWxlY3RlZEluZGV4ICsgMSkgJSB0aGlzLml0ZW1zLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IDM2KSB7IC8vIEhvbWVcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVTZWxlY3Rpb24oMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IDM1KSB7IC8vIEVuZFxuICAgICAgICAgICAgICAgIHRoaXMubW92ZVNlbGVjdGlvbih0aGlzLml0ZW1zLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSAxMykgeyAvLyBFbnRlclxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA+PSA2NSAmJiBldmVudC5rZXlDb2RlIDw9IDkwICYmIHRoaXMuc2VsZWN0ZWRJbmRleCA+PSAwKSB7IC8vIEEtWlxuICAgICAgICAgICAgICAgIGxldCB7IGRpYWdub3N0aWMgfSA9IHRoaXMuaXRlbXNbdGhpcy5zZWxlY3RlZEluZGV4XSwga2V5cyA9IGFzc2lnbktleXMoZGlhZ25vc3RpYy5hY3Rpb25zKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlzW2ldLnRvVXBwZXJDYXNlKCkuY2hhckNvZGVBdCgwKSA9PSBldmVudC5rZXlDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBmaW5kRGlhZ25vc3RpYyh0aGlzLnZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlKS5kaWFnbm9zdGljcywgZGlhZ25vc3RpYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlhZ25vc3RpYy5hY3Rpb25zW2ldLmFwcGx5KHZpZXcsIGZvdW5kLmZyb20sIGZvdW5kLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IG9uY2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLml0ZW1zW2ldLmRvbS5jb250YWlucyhldmVudC50YXJnZXQpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVTZWxlY3Rpb24oaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGlzdCA9IGVsdChcInVsXCIsIHtcbiAgICAgICAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgICAgICAgcm9sZTogXCJsaXN0Ym94XCIsXG4gICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogdGhpcy52aWV3LnN0YXRlLnBocmFzZShcIkRpYWdub3N0aWNzXCIpLFxuICAgICAgICAgICAgb25rZXlkb3duLFxuICAgICAgICAgICAgb25jbGlja1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kb20gPSBlbHQoXCJkaXZcIiwgeyBjbGFzczogXCJjbS1wYW5lbC1saW50XCIgfSwgdGhpcy5saXN0LCBlbHQoXCJidXR0b25cIiwge1xuICAgICAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgICAgIG5hbWU6IFwiY2xvc2VcIixcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiB0aGlzLnZpZXcuc3RhdGUucGhyYXNlKFwiY2xvc2VcIiksXG4gICAgICAgICAgICBvbmNsaWNrOiAoKSA9PiBjbG9zZUxpbnRQYW5lbCh0aGlzLnZpZXcpXG4gICAgICAgIH0sIFwiw5dcIikpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgICBnZXQgc2VsZWN0ZWRJbmRleCgpIHtcbiAgICAgICAgbGV0IHNlbGVjdGVkID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSkuc2VsZWN0ZWQ7XG4gICAgICAgIGlmICghc2VsZWN0ZWQpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pdGVtcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0aGlzLml0ZW1zW2ldLmRpYWdub3N0aWMgPT0gc2VsZWN0ZWQuZGlhZ25vc3RpYylcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGxldCB7IGRpYWdub3N0aWNzLCBzZWxlY3RlZCB9ID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSk7XG4gICAgICAgIGxldCBpID0gMCwgbmVlZHNTeW5jID0gZmFsc2UsIG5ld1NlbGVjdGVkSXRlbSA9IG51bGw7XG4gICAgICAgIGRpYWdub3N0aWNzLmJldHdlZW4oMCwgdGhpcy52aWV3LnN0YXRlLmRvYy5sZW5ndGgsIChfc3RhcnQsIF9lbmQsIHsgc3BlYyB9KSA9PiB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSAtMSwgaXRlbTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpOyBqIDwgdGhpcy5pdGVtcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pdGVtc1tqXS5kaWFnbm9zdGljID09IHNwZWMuZGlhZ25vc3RpYykge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGo7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3VuZCA8IDApIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gbmV3IFBhbmVsSXRlbSh0aGlzLnZpZXcsIHNwZWMuZGlhZ25vc3RpYyk7XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtcy5zcGxpY2UoaSwgMCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgbmVlZHNTeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSB0aGlzLml0ZW1zW2ZvdW5kXTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgPiBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKGksIGZvdW5kIC0gaSk7XG4gICAgICAgICAgICAgICAgICAgIG5lZWRzU3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkICYmIGl0ZW0uZGlhZ25vc3RpYyA9PSBzZWxlY3RlZC5kaWFnbm9zdGljKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtLmRvbS5oYXNBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZG9tLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgXCJ0cnVlXCIpO1xuICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3RlZEl0ZW0gPSBpdGVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0uZG9tLmhhc0F0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIikpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmRvbS5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9KTtcbiAgICAgICAgd2hpbGUgKGkgPCB0aGlzLml0ZW1zLmxlbmd0aCAmJiAhKHRoaXMuaXRlbXMubGVuZ3RoID09IDEgJiYgdGhpcy5pdGVtc1swXS5kaWFnbm9zdGljLmZyb20gPCAwKSkge1xuICAgICAgICAgICAgbmVlZHNTeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXRlbXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChuZXcgUGFuZWxJdGVtKHRoaXMudmlldywge1xuICAgICAgICAgICAgICAgIGZyb206IC0xLCB0bzogLTEsXG4gICAgICAgICAgICAgICAgc2V2ZXJpdHk6IFwiaW5mb1wiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMudmlldy5zdGF0ZS5waHJhc2UoXCJObyBkaWFnbm9zdGljc1wiKVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgbmVlZHNTeW5jID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3U2VsZWN0ZWRJdGVtKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3Quc2V0QXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIsIG5ld1NlbGVjdGVkSXRlbS5pZCk7XG4gICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUoe1xuICAgICAgICAgICAgICAgIGtleTogdGhpcyxcbiAgICAgICAgICAgICAgICByZWFkOiAoKSA9PiAoeyBzZWw6IG5ld1NlbGVjdGVkSXRlbS5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHBhbmVsOiB0aGlzLmxpc3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgfSksXG4gICAgICAgICAgICAgICAgd3JpdGU6ICh7IHNlbCwgcGFuZWwgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2NhbGVZID0gcGFuZWwuaGVpZ2h0IC8gdGhpcy5saXN0Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbC50b3AgPCBwYW5lbC50b3ApXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3Quc2Nyb2xsVG9wIC09IChwYW5lbC50b3AgLSBzZWwudG9wKSAvIHNjYWxlWTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VsLmJvdHRvbSA+IHBhbmVsLmJvdHRvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdC5zY3JvbGxUb3AgKz0gKHNlbC5ib3R0b20gLSBwYW5lbC5ib3R0b20pIC8gc2NhbGVZO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0ZWRJbmRleCA8IDApIHtcbiAgICAgICAgICAgIHRoaXMubGlzdC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZWRzU3luYylcbiAgICAgICAgICAgIHRoaXMuc3luYygpO1xuICAgIH1cbiAgICBzeW5jKCkge1xuICAgICAgICBsZXQgZG9tUG9zID0gdGhpcy5saXN0LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGZ1bmN0aW9uIHJtKCkge1xuICAgICAgICAgICAgbGV0IHByZXYgPSBkb21Qb3M7XG4gICAgICAgICAgICBkb21Qb3MgPSBwcmV2Lm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgcHJldi5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIHRoaXMuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLmRvbS5wYXJlbnROb2RlID09IHRoaXMubGlzdCkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChkb21Qb3MgIT0gaXRlbS5kb20pXG4gICAgICAgICAgICAgICAgICAgIHJtKCk7XG4gICAgICAgICAgICAgICAgZG9tUG9zID0gaXRlbS5kb20ubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3QuaW5zZXJ0QmVmb3JlKGl0ZW0uZG9tLCBkb21Qb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChkb21Qb3MpXG4gICAgICAgICAgICBybSgpO1xuICAgIH1cbiAgICBtb3ZlU2VsZWN0aW9uKHNlbGVjdGVkSW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJbmRleCA8IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBmaWVsZCA9IHRoaXMudmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUpO1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gZmluZERpYWdub3N0aWMoZmllbGQuZGlhZ25vc3RpY3MsIHRoaXMuaXRlbXNbc2VsZWN0ZWRJbmRleF0uZGlhZ25vc3RpYyk7XG4gICAgICAgIGlmICghc2VsZWN0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgc2VsZWN0aW9uOiB7IGFuY2hvcjogc2VsZWN0aW9uLmZyb20sIGhlYWQ6IHNlbGVjdGlvbi50byB9LFxuICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgICAgICBlZmZlY3RzOiBtb3ZlUGFuZWxTZWxlY3Rpb24ub2Yoc2VsZWN0aW9uKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIG9wZW4odmlldykgeyByZXR1cm4gbmV3IExpbnRQYW5lbCh2aWV3KTsgfVxufVxuZnVuY3Rpb24gc3ZnKGNvbnRlbnQsIGF0dHJzID0gYHZpZXdCb3g9XCIwIDAgNDAgNDBcImApIHtcbiAgICByZXR1cm4gYHVybCgnZGF0YTppbWFnZS9zdmcreG1sLDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiICR7YXR0cnN9PiR7ZW5jb2RlVVJJQ29tcG9uZW50KGNvbnRlbnQpfTwvc3ZnPicpYDtcbn1cbmZ1bmN0aW9uIHVuZGVybGluZShjb2xvcikge1xuICAgIHJldHVybiBzdmcoYDxwYXRoIGQ9XCJtMCAyLjUgbDIgLTEuNSBsMSAwIGwyIDEuNSBsMSAwXCIgc3Ryb2tlPVwiJHtjb2xvcn1cIiBmaWxsPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIi43XCIvPmAsIGB3aWR0aD1cIjZcIiBoZWlnaHQ9XCIzXCJgKTtcbn1cbmNvbnN0IGJhc2VUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tZGlhZ25vc3RpY1wiOiB7XG4gICAgICAgIHBhZGRpbmc6IFwiM3B4IDZweCAzcHggOHB4XCIsXG4gICAgICAgIG1hcmdpbkxlZnQ6IFwiLTFweFwiLFxuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICAgIHdoaXRlU3BhY2U6IFwicHJlLXdyYXBcIlxuICAgIH0sXG4gICAgXCIuY20tZGlhZ25vc3RpYy1lcnJvclwiOiB7IGJvcmRlckxlZnQ6IFwiNXB4IHNvbGlkICNkMTFcIiB9LFxuICAgIFwiLmNtLWRpYWdub3N0aWMtd2FybmluZ1wiOiB7IGJvcmRlckxlZnQ6IFwiNXB4IHNvbGlkIG9yYW5nZVwiIH0sXG4gICAgXCIuY20tZGlhZ25vc3RpYy1pbmZvXCI6IHsgYm9yZGVyTGVmdDogXCI1cHggc29saWQgIzk5OVwiIH0sXG4gICAgXCIuY20tZGlhZ25vc3RpYy1oaW50XCI6IHsgYm9yZGVyTGVmdDogXCI1cHggc29saWQgIzY2ZFwiIH0sXG4gICAgXCIuY20tZGlhZ25vc3RpY0FjdGlvblwiOiB7XG4gICAgICAgIGZvbnQ6IFwiaW5oZXJpdFwiLFxuICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgICAgICBwYWRkaW5nOiBcIjJweCA0cHhcIixcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiM0NDRcIixcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBcIjNweFwiLFxuICAgICAgICBtYXJnaW5MZWZ0OiBcIjhweFwiLFxuICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiXG4gICAgfSxcbiAgICBcIi5jbS1kaWFnbm9zdGljU291cmNlXCI6IHtcbiAgICAgICAgZm9udFNpemU6IFwiNzAlXCIsXG4gICAgICAgIG9wYWNpdHk6IC43XG4gICAgfSxcbiAgICBcIi5jbS1saW50UmFuZ2VcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb246IFwibGVmdCBib3R0b21cIixcbiAgICAgICAgYmFja2dyb3VuZFJlcGVhdDogXCJyZXBlYXQteFwiLFxuICAgICAgICBwYWRkaW5nQm90dG9tOiBcIjAuN3B4XCIsXG4gICAgfSxcbiAgICBcIi5jbS1saW50UmFuZ2UtZXJyb3JcIjogeyBiYWNrZ3JvdW5kSW1hZ2U6IC8qQF9fUFVSRV9fKi91bmRlcmxpbmUoXCIjZDExXCIpIH0sXG4gICAgXCIuY20tbGludFJhbmdlLXdhcm5pbmdcIjogeyBiYWNrZ3JvdW5kSW1hZ2U6IC8qQF9fUFVSRV9fKi91bmRlcmxpbmUoXCJvcmFuZ2VcIikgfSxcbiAgICBcIi5jbS1saW50UmFuZ2UtaW5mb1wiOiB7IGJhY2tncm91bmRJbWFnZTogLypAX19QVVJFX18qL3VuZGVybGluZShcIiM5OTlcIikgfSxcbiAgICBcIi5jbS1saW50UmFuZ2UtaGludFwiOiB7IGJhY2tncm91bmRJbWFnZTogLypAX19QVVJFX18qL3VuZGVybGluZShcIiM2NmRcIikgfSxcbiAgICBcIi5jbS1saW50UmFuZ2UtYWN0aXZlXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNmZmRkOTk4MFwiIH0sXG4gICAgXCIuY20tdG9vbHRpcC1saW50XCI6IHtcbiAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgbWFyZ2luOiAwXG4gICAgfSxcbiAgICBcIi5jbS1saW50UG9pbnRcIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICBcIiY6YWZ0ZXJcIjoge1xuICAgICAgICAgICAgY29udGVudDogJ1wiXCInLFxuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICAgIGxlZnQ6IFwiLTJweFwiLFxuICAgICAgICAgICAgYm9yZGVyTGVmdDogXCIzcHggc29saWQgdHJhbnNwYXJlbnRcIixcbiAgICAgICAgICAgIGJvcmRlclJpZ2h0OiBcIjNweCBzb2xpZCB0cmFuc3BhcmVudFwiLFxuICAgICAgICAgICAgYm9yZGVyQm90dG9tOiBcIjRweCBzb2xpZCAjZDExXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCIuY20tbGludFBvaW50LXdhcm5pbmdcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBib3JkZXJCb3R0b21Db2xvcjogXCJvcmFuZ2VcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1saW50UG9pbnQtaW5mb1wiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGJvcmRlckJvdHRvbUNvbG9yOiBcIiM5OTlcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1saW50UG9pbnQtaGludFwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGJvcmRlckJvdHRvbUNvbG9yOiBcIiM2NmRcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1wYW5lbC5jbS1wYW5lbC1saW50XCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgXCImIHVsXCI6IHtcbiAgICAgICAgICAgIG1heEhlaWdodDogXCIxMDBweFwiLFxuICAgICAgICAgICAgb3ZlcmZsb3dZOiBcImF1dG9cIixcbiAgICAgICAgICAgIFwiJiBbYXJpYS1zZWxlY3RlZF1cIjoge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZGRkXCIsXG4gICAgICAgICAgICAgICAgXCImIHVcIjogeyB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIiB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCImOmZvY3VzIFthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZF9mYWxsYmFjazogXCIjYmRmXCIsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIkhpZ2hsaWdodFwiLFxuICAgICAgICAgICAgICAgIGNvbG9yX2ZhbGxiYWNrOiBcIndoaXRlXCIsXG4gICAgICAgICAgICAgICAgY29sb3I6IFwiSGlnaGxpZ2h0VGV4dFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCImIHVcIjogeyB0ZXh0RGVjb3JhdGlvbjogXCJub25lXCIgfSxcbiAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICBtYXJnaW46IDBcbiAgICAgICAgfSxcbiAgICAgICAgXCImIFtuYW1lPWNsb3NlXVwiOiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgdG9wOiBcIjBcIixcbiAgICAgICAgICAgIHJpZ2h0OiBcIjJweFwiLFxuICAgICAgICAgICAgYmFja2dyb3VuZDogXCJpbmhlcml0XCIsXG4gICAgICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgICAgICAgICAgZm9udDogXCJpbmhlcml0XCIsXG4gICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgbWFyZ2luOiAwXG4gICAgICAgIH1cbiAgICB9XG59KTtcbmZ1bmN0aW9uIHNldmVyaXR5V2VpZ2h0KHNldikge1xuICAgIHJldHVybiBzZXYgPT0gXCJlcnJvclwiID8gNCA6IHNldiA9PSBcIndhcm5pbmdcIiA/IDMgOiBzZXYgPT0gXCJpbmZvXCIgPyAyIDogMTtcbn1cbmNsYXNzIExpbnRHdXR0ZXJNYXJrZXIgZXh0ZW5kcyBHdXR0ZXJNYXJrZXIge1xuICAgIGNvbnN0cnVjdG9yKGRpYWdub3N0aWNzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZGlhZ25vc3RpY3MgPSBkaWFnbm9zdGljcztcbiAgICAgICAgdGhpcy5zZXZlcml0eSA9IGRpYWdub3N0aWNzLnJlZHVjZSgobWF4LCBkKSA9PiBzZXZlcml0eVdlaWdodChtYXgpIDwgc2V2ZXJpdHlXZWlnaHQoZC5zZXZlcml0eSkgPyBkLnNldmVyaXR5IDogbWF4LCBcImhpbnRcIik7XG4gICAgfVxuICAgIHRvRE9NKHZpZXcpIHtcbiAgICAgICAgbGV0IGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGVsdC5jbGFzc05hbWUgPSBcImNtLWxpbnQtbWFya2VyIGNtLWxpbnQtbWFya2VyLVwiICsgdGhpcy5zZXZlcml0eTtcbiAgICAgICAgbGV0IGRpYWdub3N0aWNzID0gdGhpcy5kaWFnbm9zdGljcztcbiAgICAgICAgbGV0IGRpYWdub3N0aWNzRmlsdGVyID0gdmlldy5zdGF0ZS5mYWNldChsaW50R3V0dGVyQ29uZmlnKS50b29sdGlwRmlsdGVyO1xuICAgICAgICBpZiAoZGlhZ25vc3RpY3NGaWx0ZXIpXG4gICAgICAgICAgICBkaWFnbm9zdGljcyA9IGRpYWdub3N0aWNzRmlsdGVyKGRpYWdub3N0aWNzLCB2aWV3LnN0YXRlKTtcbiAgICAgICAgaWYgKGRpYWdub3N0aWNzLmxlbmd0aClcbiAgICAgICAgICAgIGVsdC5vbm1vdXNlb3ZlciA9ICgpID0+IGd1dHRlck1hcmtlck1vdXNlT3Zlcih2aWV3LCBlbHQsIGRpYWdub3N0aWNzKTtcbiAgICAgICAgcmV0dXJuIGVsdDtcbiAgICB9XG59XG5mdW5jdGlvbiB0cmFja0hvdmVyT24odmlldywgbWFya2VyKSB7XG4gICAgbGV0IG1vdXNlbW92ZSA9IChldmVudCkgPT4ge1xuICAgICAgICBsZXQgcmVjdCA9IG1hcmtlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKGV2ZW50LmNsaWVudFggPiByZWN0LmxlZnQgLSAxMCAvKiBIb3Zlci5NYXJnaW4gKi8gJiYgZXZlbnQuY2xpZW50WCA8IHJlY3QucmlnaHQgKyAxMCAvKiBIb3Zlci5NYXJnaW4gKi8gJiZcbiAgICAgICAgICAgIGV2ZW50LmNsaWVudFkgPiByZWN0LnRvcCAtIDEwIC8qIEhvdmVyLk1hcmdpbiAqLyAmJiBldmVudC5jbGllbnRZIDwgcmVjdC5ib3R0b20gKyAxMCAvKiBIb3Zlci5NYXJnaW4gKi8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAobGV0IHRhcmdldCA9IGV2ZW50LnRhcmdldDsgdGFyZ2V0OyB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgaWYgKHRhcmdldC5ub2RlVHlwZSA9PSAxICYmIHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoXCJjbS10b29sdGlwLWxpbnRcIikpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG1vdXNlbW92ZSk7XG4gICAgICAgIGlmICh2aWV3LnN0YXRlLmZpZWxkKGxpbnRHdXR0ZXJUb29sdGlwKSlcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXRMaW50R3V0dGVyVG9vbHRpcC5vZihudWxsKSB9KTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG1vdXNlbW92ZSk7XG59XG5mdW5jdGlvbiBndXR0ZXJNYXJrZXJNb3VzZU92ZXIodmlldywgbWFya2VyLCBkaWFnbm9zdGljcykge1xuICAgIGZ1bmN0aW9uIGhvdmVyZWQoKSB7XG4gICAgICAgIGxldCBsaW5lID0gdmlldy5lbGVtZW50QXRIZWlnaHQobWFya2VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIDUgLSB2aWV3LmRvY3VtZW50VG9wKTtcbiAgICAgICAgY29uc3QgbGluZVBvcyA9IHZpZXcuY29vcmRzQXRQb3MobGluZS5mcm9tKTtcbiAgICAgICAgaWYgKGxpbmVQb3MpIHtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXRMaW50R3V0dGVyVG9vbHRpcC5vZih7XG4gICAgICAgICAgICAgICAgICAgIHBvczogbGluZS5mcm9tLFxuICAgICAgICAgICAgICAgICAgICBhYm92ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tOiBkaWFnbm9zdGljc1Rvb2x0aXAodmlldywgZGlhZ25vc3RpY3MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldENvb3JkczogKCkgPT4gbWFya2VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbWFya2VyLm9ubW91c2VvdXQgPSBtYXJrZXIub25tb3VzZW1vdmUgPSBudWxsO1xuICAgICAgICB0cmFja0hvdmVyT24odmlldywgbWFya2VyKTtcbiAgICB9XG4gICAgbGV0IHsgaG92ZXJUaW1lIH0gPSB2aWV3LnN0YXRlLmZhY2V0KGxpbnRHdXR0ZXJDb25maWcpO1xuICAgIGxldCBob3ZlclRpbWVvdXQgPSBzZXRUaW1lb3V0KGhvdmVyZWQsIGhvdmVyVGltZSk7XG4gICAgbWFya2VyLm9ubW91c2VvdXQgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dChob3ZlclRpbWVvdXQpO1xuICAgICAgICBtYXJrZXIub25tb3VzZW91dCA9IG1hcmtlci5vbm1vdXNlbW92ZSA9IG51bGw7XG4gICAgfTtcbiAgICBtYXJrZXIub25tb3VzZW1vdmUgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dChob3ZlclRpbWVvdXQpO1xuICAgICAgICBob3ZlclRpbWVvdXQgPSBzZXRUaW1lb3V0KGhvdmVyZWQsIGhvdmVyVGltZSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1hcmtlcnNGb3JEaWFnbm9zdGljcyhkb2MsIGRpYWdub3N0aWNzKSB7XG4gICAgbGV0IGJ5TGluZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgZGlhZ25vc3RpYyBvZiBkaWFnbm9zdGljcykge1xuICAgICAgICBsZXQgbGluZSA9IGRvYy5saW5lQXQoZGlhZ25vc3RpYy5mcm9tKTtcbiAgICAgICAgKGJ5TGluZVtsaW5lLmZyb21dIHx8IChieUxpbmVbbGluZS5mcm9tXSA9IFtdKSkucHVzaChkaWFnbm9zdGljKTtcbiAgICB9XG4gICAgbGV0IG1hcmtlcnMgPSBbXTtcbiAgICBmb3IgKGxldCBsaW5lIGluIGJ5TGluZSkge1xuICAgICAgICBtYXJrZXJzLnB1c2gobmV3IExpbnRHdXR0ZXJNYXJrZXIoYnlMaW5lW2xpbmVdKS5yYW5nZSgrbGluZSkpO1xuICAgIH1cbiAgICByZXR1cm4gUmFuZ2VTZXQub2YobWFya2VycywgdHJ1ZSk7XG59XG5jb25zdCBsaW50R3V0dGVyRXh0ZW5zaW9uID0gLypAX19QVVJFX18qL2d1dHRlcih7XG4gICAgY2xhc3M6IFwiY20tZ3V0dGVyLWxpbnRcIixcbiAgICBtYXJrZXJzOiB2aWV3ID0+IHZpZXcuc3RhdGUuZmllbGQobGludEd1dHRlck1hcmtlcnMpLFxufSk7XG5jb25zdCBsaW50R3V0dGVyTWFya2VycyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gUmFuZ2VTZXQuZW1wdHk7XG4gICAgfSxcbiAgICB1cGRhdGUobWFya2VycywgdHIpIHtcbiAgICAgICAgbWFya2VycyA9IG1hcmtlcnMubWFwKHRyLmNoYW5nZXMpO1xuICAgICAgICBsZXQgZGlhZ25vc3RpY0ZpbHRlciA9IHRyLnN0YXRlLmZhY2V0KGxpbnRHdXR0ZXJDb25maWcpLm1hcmtlckZpbHRlcjtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0RGlhZ25vc3RpY3NFZmZlY3QpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRpYWdub3N0aWNzID0gZWZmZWN0LnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChkaWFnbm9zdGljRmlsdGVyKVxuICAgICAgICAgICAgICAgICAgICBkaWFnbm9zdGljcyA9IGRpYWdub3N0aWNGaWx0ZXIoZGlhZ25vc3RpY3MgfHwgW10sIHRyLnN0YXRlKTtcbiAgICAgICAgICAgICAgICBtYXJrZXJzID0gbWFya2Vyc0ZvckRpYWdub3N0aWNzKHRyLnN0YXRlLmRvYywgZGlhZ25vc3RpY3Muc2xpY2UoMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXJrZXJzO1xuICAgIH1cbn0pO1xuY29uc3Qgc2V0TGludEd1dHRlclRvb2x0aXAgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBsaW50R3V0dGVyVG9vbHRpcCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICB1cGRhdGUodG9vbHRpcCwgdHIpIHtcbiAgICAgICAgaWYgKHRvb2x0aXAgJiYgdHIuZG9jQ2hhbmdlZClcbiAgICAgICAgICAgIHRvb2x0aXAgPSBoaWRlVG9vbHRpcCh0ciwgdG9vbHRpcCkgPyBudWxsIDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0b29sdGlwKSwgeyBwb3M6IHRyLmNoYW5nZXMubWFwUG9zKHRvb2x0aXAucG9zKSB9KTtcbiAgICAgICAgcmV0dXJuIHRyLmVmZmVjdHMucmVkdWNlKCh0LCBlKSA9PiBlLmlzKHNldExpbnRHdXR0ZXJUb29sdGlwKSA/IGUudmFsdWUgOiB0LCB0b29sdGlwKTtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGZpZWxkID0+IHNob3dUb29sdGlwLmZyb20oZmllbGQpXG59KTtcbmNvbnN0IGxpbnRHdXR0ZXJUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tZ3V0dGVyLWxpbnRcIjoge1xuICAgICAgICB3aWR0aDogXCIxLjRlbVwiLFxuICAgICAgICBcIiYgLmNtLWd1dHRlckVsZW1lbnRcIjoge1xuICAgICAgICAgICAgcGFkZGluZzogXCIuMmVtXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCIuY20tbGludC1tYXJrZXJcIjoge1xuICAgICAgICB3aWR0aDogXCIxZW1cIixcbiAgICAgICAgaGVpZ2h0OiBcIjFlbVwiXG4gICAgfSxcbiAgICBcIi5jbS1saW50LW1hcmtlci1pbmZvXCI6IHtcbiAgICAgICAgY29udGVudDogLypAX19QVVJFX18qL3N2ZyhgPHBhdGggZmlsbD1cIiNhYWZcIiBzdHJva2U9XCIjNzdlXCIgc3Ryb2tlLXdpZHRoPVwiNlwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk01IDVMMzUgNUwzNSAzNUw1IDM1WlwiLz5gKVxuICAgIH0sXG4gICAgXCIuY20tbGludC1tYXJrZXItd2FybmluZ1wiOiB7XG4gICAgICAgIGNvbnRlbnQ6IC8qQF9fUFVSRV9fKi9zdmcoYDxwYXRoIGZpbGw9XCIjZmU4XCIgc3Ryb2tlPVwiI2ZkN1wiIHN0cm9rZS13aWR0aD1cIjZcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMjAgNkwzNyAzNUwzIDM1WlwiLz5gKSxcbiAgICB9LFxuICAgIFwiLmNtLWxpbnQtbWFya2VyLWVycm9yXCI6IHtcbiAgICAgICAgY29udGVudDogLypAX19QVVJFX18qL3N2ZyhgPGNpcmNsZSBjeD1cIjIwXCIgY3k9XCIyMFwiIHI9XCIxNVwiIGZpbGw9XCIjZjg3XCIgc3Ryb2tlPVwiI2Y0M1wiIHN0cm9rZS13aWR0aD1cIjZcIi8+YClcbiAgICB9LFxufSk7XG5jb25zdCBsaW50RXh0ZW5zaW9ucyA9IFtcbiAgICBsaW50U3RhdGUsXG4gICAgLypAX19QVVJFX18qL0VkaXRvclZpZXcuZGVjb3JhdGlvbnMuY29tcHV0ZShbbGludFN0YXRlXSwgc3RhdGUgPT4ge1xuICAgICAgICBsZXQgeyBzZWxlY3RlZCwgcGFuZWwgfSA9IHN0YXRlLmZpZWxkKGxpbnRTdGF0ZSk7XG4gICAgICAgIHJldHVybiAhc2VsZWN0ZWQgfHwgIXBhbmVsIHx8IHNlbGVjdGVkLmZyb20gPT0gc2VsZWN0ZWQudG8gPyBEZWNvcmF0aW9uLm5vbmUgOiBEZWNvcmF0aW9uLnNldChbXG4gICAgICAgICAgICBhY3RpdmVNYXJrLnJhbmdlKHNlbGVjdGVkLmZyb20sIHNlbGVjdGVkLnRvKVxuICAgICAgICBdKTtcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovaG92ZXJUb29sdGlwKGxpbnRUb29sdGlwLCB7IGhpZGVPbjogaGlkZVRvb2x0aXAgfSksXG4gICAgYmFzZVRoZW1lXG5dO1xuY29uc3QgbGludEd1dHRlckNvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICBob3ZlclRpbWU6IDMwMCAvKiBIb3Zlci5UaW1lICovLFxuICAgICAgICAgICAgbWFya2VyRmlsdGVyOiBudWxsLFxuICAgICAgICAgICAgdG9vbHRpcEZpbHRlcjogbnVsbFxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBpbnN0YWxscyBhIGd1dHRlciBzaG93aW5nIG1hcmtlcnMgZm9yXG5lYWNoIGxpbmUgdGhhdCBoYXMgZGlhZ25vc3RpY3MsIHdoaWNoIGNhbiBiZSBob3ZlcmVkIG92ZXIgdG8gc2VlXG50aGUgZGlhZ25vc3RpY3MuXG4qL1xuZnVuY3Rpb24gbGludEd1dHRlcihjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbbGludEd1dHRlckNvbmZpZy5vZihjb25maWcpLCBsaW50R3V0dGVyTWFya2VycywgbGludEd1dHRlckV4dGVuc2lvbiwgbGludEd1dHRlclRoZW1lLCBsaW50R3V0dGVyVG9vbHRpcF07XG59XG4vKipcbkl0ZXJhdGUgb3ZlciB0aGUgbWFya2VkIGRpYWdub3N0aWNzIGZvciB0aGUgZ2l2ZW4gZWRpdG9yIHN0YXRlLFxuY2FsbGluZyBgZmAgZm9yIGVhY2ggb2YgdGhlbS4gTm90ZSB0aGF0LCBpZiB0aGUgZG9jdW1lbnQgY2hhbmdlZFxuc2luY2UgdGhlIGRpYWdub3N0aWNzIHdlcmUgY3JlYXRlZCwgdGhlIGBEaWFnbm9zdGljYCBvYmplY3Qgd2lsbFxuaG9sZCB0aGUgb3JpZ2luYWwgb3V0ZGF0ZWQgcG9zaXRpb24sIHdoZXJlYXMgdGhlIGB0b2AgYW5kIGBmcm9tYFxuYXJndW1lbnRzIGhvbGQgdGhlIGRpYWdub3N0aWMncyBjdXJyZW50IHBvc2l0aW9uLlxuKi9cbmZ1bmN0aW9uIGZvckVhY2hEaWFnbm9zdGljKHN0YXRlLCBmKSB7XG4gICAgbGV0IGxTdGF0ZSA9IHN0YXRlLmZpZWxkKGxpbnRTdGF0ZSwgZmFsc2UpO1xuICAgIGlmIChsU3RhdGUgJiYgbFN0YXRlLmRpYWdub3N0aWNzLnNpemUpXG4gICAgICAgIGZvciAobGV0IGl0ZXIgPSBSYW5nZVNldC5pdGVyKFtsU3RhdGUuZGlhZ25vc3RpY3NdKTsgaXRlci52YWx1ZTsgaXRlci5uZXh0KCkpXG4gICAgICAgICAgICBmKGl0ZXIudmFsdWUuc3BlYy5kaWFnbm9zdGljLCBpdGVyLmZyb20sIGl0ZXIudG8pO1xufVxuXG5leHBvcnQgeyBjbG9zZUxpbnRQYW5lbCwgZGlhZ25vc3RpY0NvdW50LCBmb3JFYWNoRGlhZ25vc3RpYywgZm9yY2VMaW50aW5nLCBsaW50R3V0dGVyLCBsaW50S2V5bWFwLCBsaW50ZXIsIG5leHREaWFnbm9zdGljLCBvcGVuTGludFBhbmVsLCBwcmV2aW91c0RpYWdub3N0aWMsIHNldERpYWdub3N0aWNzLCBzZXREaWFnbm9zdGljc0VmZmVjdCB9O1xuIl0sIm5hbWVzIjpbIkRlY29yYXRpb24iLCJzaG93UGFuZWwiLCJFZGl0b3JWaWV3IiwiVmlld1BsdWdpbiIsImxvZ0V4Y2VwdGlvbiIsImd1dHRlciIsInNob3dUb29sdGlwIiwiaG92ZXJUb29sdGlwIiwiZ2V0UGFuZWwiLCJXaWRnZXRUeXBlIiwiR3V0dGVyTWFya2VyIiwiU3RhdGVFZmZlY3QiLCJTdGF0ZUZpZWxkIiwiRmFjZXQiLCJjb21iaW5lQ29uZmlnIiwiUmFuZ2VTZXQiLCJlbHQiLCJTZWxlY3RlZERpYWdub3N0aWMiLCJjb25zdHJ1Y3RvciIsImZyb20iLCJ0byIsImRpYWdub3N0aWMiLCJMaW50U3RhdGUiLCJkaWFnbm9zdGljcyIsInBhbmVsIiwic2VsZWN0ZWQiLCJpbml0Iiwic3RhdGUiLCJtYXJrZWREaWFnbm9zdGljcyIsImRpYWdub3N0aWNGaWx0ZXIiLCJmYWNldCIsImxpbnRDb25maWciLCJtYXJrZXJGaWx0ZXIiLCJyYW5nZXMiLCJzZXQiLCJtYXAiLCJkIiwiZG9jIiwibGluZUF0Iiwid2lkZ2V0IiwiRGlhZ25vc3RpY1dpZGdldCIsInJhbmdlIiwibWFyayIsImF0dHJpYnV0ZXMiLCJjbGFzcyIsInNldmVyaXR5IiwibWFya0NsYXNzIiwiaW5jbHVzaXZlIiwiZmluZERpYWdub3N0aWMiLCJhZnRlciIsImZvdW5kIiwiYmV0d2VlbiIsInNwZWMiLCJoaWRlVG9vbHRpcCIsInRyIiwidG9vbHRpcCIsImxpbmUiLCJzdGFydFN0YXRlIiwicG9zIiwiZWZmZWN0cyIsInNvbWUiLCJlIiwiaXMiLCJzZXREaWFnbm9zdGljc0VmZmVjdCIsImNoYW5nZXMiLCJ0b3VjaGVzUmFuZ2UiLCJtYXliZUVuYWJsZUxpbnQiLCJmaWVsZCIsImxpbnRTdGF0ZSIsImNvbmNhdCIsImFwcGVuZENvbmZpZyIsIm9mIiwibGludEV4dGVuc2lvbnMiLCJzZXREaWFnbm9zdGljcyIsImRlZmluZSIsInRvZ2dsZVBhbmVsIiwibW92ZVBhbmVsU2VsZWN0aW9uIiwiY3JlYXRlIiwibm9uZSIsInVwZGF0ZSIsInZhbHVlIiwiZG9jQ2hhbmdlZCIsIm1hcHBlZCIsInNlbFBvcyIsIm1hcFBvcyIsImVmZmVjdCIsIkxpbnRQYW5lbCIsIm9wZW4iLCJwcm92aWRlIiwiZiIsInZhbCIsImRlY29yYXRpb25zIiwicyIsImRpYWdub3N0aWNDb3VudCIsImxpbnQiLCJzaXplIiwiYWN0aXZlTWFyayIsImxpbnRUb29sdGlwIiwidmlldyIsInNpZGUiLCJzdGFja1N0YXJ0Iiwic3RhY2tFbmQiLCJwdXNoIiwiTWF0aCIsIm1pbiIsIm1heCIsInRvb2x0aXBGaWx0ZXIiLCJsZW5ndGgiLCJlbmQiLCJhYm92ZSIsImRvbSIsImRpYWdub3N0aWNzVG9vbHRpcCIsInJlbmRlckRpYWdub3N0aWMiLCJvcGVuTGludFBhbmVsIiwiZGlzcGF0Y2giLCJxdWVyeVNlbGVjdG9yIiwiZm9jdXMiLCJjbG9zZUxpbnRQYW5lbCIsIm5leHREaWFnbm9zdGljIiwic2VsIiwic2VsZWN0aW9uIiwibWFpbiIsIm5leHQiLCJpdGVyIiwiYW5jaG9yIiwiaGVhZCIsInNjcm9sbEludG9WaWV3IiwicHJldmlvdXNEaWFnbm9zdGljIiwicHJldkZyb20iLCJwcmV2VG8iLCJsYXN0RnJvbSIsImxhc3RUbyIsImxpbnRLZXltYXAiLCJrZXkiLCJydW4iLCJwcmV2ZW50RGVmYXVsdCIsImxpbnRQbHVnaW4iLCJmcm9tQ2xhc3MiLCJ0aW1lb3V0IiwiZGVsYXkiLCJsaW50VGltZSIsIkRhdGUiLCJub3ciLCJiaW5kIiwic2V0VGltZW91dCIsInNvdXJjZXMiLCJQcm9taXNlIiwiYWxsIiwic291cmNlIiwicmVzb2x2ZSIsInRoZW4iLCJhbm5vdGF0aW9ucyIsInJlZHVjZSIsImEiLCJiIiwiZXJyb3IiLCJjb25maWciLCJuZWVkc1JlZnJlc2giLCJmb3JjZSIsImRlc3Ryb3kiLCJjbGVhclRpbWVvdXQiLCJjb21iaW5lIiwiaW5wdXQiLCJPYmplY3QiLCJhc3NpZ24iLCJpIiwiZmlsdGVyIiwieCIsInUiLCJsaW50ZXIiLCJmb3JjZUxpbnRpbmciLCJwbHVnaW4iLCJhc3NpZ25LZXlzIiwiYWN0aW9ucyIsImFzc2lnbmVkIiwibmFtZSIsImNoIiwidGVzdCIsImMiLCJ0b0xvd2VyQ2FzZSIsImluUGFuZWwiLCJfYSIsImtleXMiLCJyZW5kZXJNZXNzYWdlIiwibWVzc2FnZSIsImFjdGlvbiIsImZpcmVkIiwiY2xpY2siLCJhcHBseSIsImtleUluZGV4IiwiaW5kZXhPZiIsIm5hbWVFbHQiLCJzbGljZSIsInR5cGUiLCJvbmNsaWNrIiwib25tb3VzZWRvd24iLCJlcSIsIm90aGVyIiwidG9ET00iLCJQYW5lbEl0ZW0iLCJpZCIsImZsb29yIiwicmFuZG9tIiwidG9TdHJpbmciLCJzZXRBdHRyaWJ1dGUiLCJpdGVtcyIsIm9ua2V5ZG93biIsImV2ZW50Iiwia2V5Q29kZSIsIm1vdmVTZWxlY3Rpb24iLCJzZWxlY3RlZEluZGV4IiwidG9VcHBlckNhc2UiLCJjaGFyQ29kZUF0IiwiY29udGFpbnMiLCJ0YXJnZXQiLCJsaXN0IiwidGFiSW5kZXgiLCJyb2xlIiwicGhyYXNlIiwibmVlZHNTeW5jIiwibmV3U2VsZWN0ZWRJdGVtIiwiX3N0YXJ0IiwiX2VuZCIsIml0ZW0iLCJqIiwic3BsaWNlIiwiaGFzQXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwicG9wIiwicmVxdWVzdE1lYXN1cmUiLCJyZWFkIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwid3JpdGUiLCJzY2FsZVkiLCJoZWlnaHQiLCJvZmZzZXRIZWlnaHQiLCJ0b3AiLCJzY3JvbGxUb3AiLCJib3R0b20iLCJzeW5jIiwiZG9tUG9zIiwiZmlyc3RDaGlsZCIsInJtIiwicHJldiIsIm5leHRTaWJsaW5nIiwicmVtb3ZlIiwicGFyZW50Tm9kZSIsImluc2VydEJlZm9yZSIsInN2ZyIsImNvbnRlbnQiLCJhdHRycyIsImVuY29kZVVSSUNvbXBvbmVudCIsInVuZGVybGluZSIsImNvbG9yIiwiYmFzZVRoZW1lIiwicGFkZGluZyIsIm1hcmdpbkxlZnQiLCJkaXNwbGF5Iiwid2hpdGVTcGFjZSIsImJvcmRlckxlZnQiLCJmb250IiwiYm9yZGVyIiwiYmFja2dyb3VuZENvbG9yIiwiYm9yZGVyUmFkaXVzIiwiY3Vyc29yIiwiZm9udFNpemUiLCJvcGFjaXR5IiwiYmFja2dyb3VuZFBvc2l0aW9uIiwiYmFja2dyb3VuZFJlcGVhdCIsInBhZGRpbmdCb3R0b20iLCJiYWNrZ3JvdW5kSW1hZ2UiLCJtYXJnaW4iLCJwb3NpdGlvbiIsImxlZnQiLCJib3JkZXJSaWdodCIsImJvcmRlckJvdHRvbSIsImJvcmRlckJvdHRvbUNvbG9yIiwibWF4SGVpZ2h0Iiwib3ZlcmZsb3dZIiwidGV4dERlY29yYXRpb24iLCJiYWNrZ3JvdW5kX2ZhbGxiYWNrIiwiY29sb3JfZmFsbGJhY2siLCJyaWdodCIsImJhY2tncm91bmQiLCJzZXZlcml0eVdlaWdodCIsInNldiIsIkxpbnRHdXR0ZXJNYXJrZXIiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJkaWFnbm9zdGljc0ZpbHRlciIsImxpbnRHdXR0ZXJDb25maWciLCJvbm1vdXNlb3ZlciIsImd1dHRlck1hcmtlck1vdXNlT3ZlciIsInRyYWNrSG92ZXJPbiIsIm1hcmtlciIsIm1vdXNlbW92ZSIsInJlY3QiLCJjbGllbnRYIiwiY2xpZW50WSIsIm5vZGVUeXBlIiwiY2xhc3NMaXN0Iiwid2luZG93IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImxpbnRHdXR0ZXJUb29sdGlwIiwic2V0TGludEd1dHRlclRvb2x0aXAiLCJhZGRFdmVudExpc3RlbmVyIiwiaG92ZXJlZCIsImVsZW1lbnRBdEhlaWdodCIsImRvY3VtZW50VG9wIiwibGluZVBvcyIsImNvb3Jkc0F0UG9zIiwiZ2V0Q29vcmRzIiwib25tb3VzZW91dCIsIm9ubW91c2Vtb3ZlIiwiaG92ZXJUaW1lIiwiaG92ZXJUaW1lb3V0IiwibWFya2Vyc0ZvckRpYWdub3N0aWNzIiwiYnlMaW5lIiwibWFya2VycyIsImxpbnRHdXR0ZXJFeHRlbnNpb24iLCJsaW50R3V0dGVyTWFya2VycyIsImVtcHR5IiwidCIsImxpbnRHdXR0ZXJUaGVtZSIsIndpZHRoIiwiY29tcHV0ZSIsImhpZGVPbiIsImNvbmZpZ3MiLCJsaW50R3V0dGVyIiwiZm9yRWFjaERpYWdub3N0aWMiLCJsU3RhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/lint/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/search/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@codemirror/search/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RegExpCursor: () => (/* binding */ RegExpCursor),\n/* harmony export */   SearchCursor: () => (/* binding */ SearchCursor),\n/* harmony export */   SearchQuery: () => (/* binding */ SearchQuery),\n/* harmony export */   closeSearchPanel: () => (/* binding */ closeSearchPanel),\n/* harmony export */   findNext: () => (/* binding */ findNext),\n/* harmony export */   findPrevious: () => (/* binding */ findPrevious),\n/* harmony export */   getSearchQuery: () => (/* binding */ getSearchQuery),\n/* harmony export */   gotoLine: () => (/* binding */ gotoLine),\n/* harmony export */   highlightSelectionMatches: () => (/* binding */ highlightSelectionMatches),\n/* harmony export */   openSearchPanel: () => (/* binding */ openSearchPanel),\n/* harmony export */   replaceAll: () => (/* binding */ replaceAll),\n/* harmony export */   replaceNext: () => (/* binding */ replaceNext),\n/* harmony export */   search: () => (/* binding */ search),\n/* harmony export */   searchKeymap: () => (/* binding */ searchKeymap),\n/* harmony export */   searchPanelOpen: () => (/* binding */ searchPanelOpen),\n/* harmony export */   selectMatches: () => (/* binding */ selectMatches),\n/* harmony export */   selectNextOccurrence: () => (/* binding */ selectNextOccurrence),\n/* harmony export */   selectSelectionMatches: () => (/* binding */ selectSelectionMatches),\n/* harmony export */   setSearchQuery: () => (/* binding */ setSearchQuery)\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var crelt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crelt */ \"(ssr)/./node_modules/crelt/index.js\");\n\n\n\nconst basicNormalize = typeof String.prototype.normalize == \"function\" ? (x)=>x.normalize(\"NFKD\") : (x)=>x;\n/**\nA search cursor provides an iterator over text matches in a\ndocument.\n*/ class SearchCursor {\n    /**\n    Create a text cursor. The query is the search string, `from` to\n    `to` provides the region to search.\n    \n    When `normalize` is given, it will be called, on both the query\n    string and the content it is matched against, before comparing.\n    You can, for example, create a case-insensitive search by\n    passing `s => s.toLowerCase()`.\n    \n    Text is always normalized with\n    [`.normalize(\"NFKD\")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)\n    (when supported).\n    */ constructor(text, query, from = 0, to = text.length, normalize, test){\n        this.test = test;\n        /**\n        The current match (only holds a meaningful value after\n        [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when\n        `done` is false).\n        */ this.value = {\n            from: 0,\n            to: 0\n        };\n        /**\n        Whether the end of the iterated region has been reached.\n        */ this.done = false;\n        this.matches = [];\n        this.buffer = \"\";\n        this.bufferPos = 0;\n        this.iter = text.iterRange(from, to);\n        this.bufferStart = from;\n        this.normalize = normalize ? (x)=>normalize(basicNormalize(x)) : basicNormalize;\n        this.query = this.normalize(query);\n    }\n    peek() {\n        if (this.bufferPos == this.buffer.length) {\n            this.bufferStart += this.buffer.length;\n            this.iter.next();\n            if (this.iter.done) return -1;\n            this.bufferPos = 0;\n            this.buffer = this.iter.value;\n        }\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(this.buffer, this.bufferPos);\n    }\n    /**\n    Look for the next match. Updates the iterator's\n    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and\n    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called\n    at least once before using the cursor.\n    */ next() {\n        while(this.matches.length)this.matches.pop();\n        return this.nextOverlapping();\n    }\n    /**\n    The `next` method will ignore matches that partially overlap a\n    previous match. This method behaves like `next`, but includes\n    such matches.\n    */ nextOverlapping() {\n        for(;;){\n            let next = this.peek();\n            if (next < 0) {\n                this.done = true;\n                return this;\n            }\n            let str = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(next), start = this.bufferStart + this.bufferPos;\n            this.bufferPos += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\n            let norm = this.normalize(str);\n            for(let i = 0, pos = start;; i++){\n                let code = norm.charCodeAt(i);\n                let match = this.match(code, pos);\n                if (i == norm.length - 1) {\n                    if (match) {\n                        this.value = match;\n                        return this;\n                    }\n                    break;\n                }\n                if (pos == start && i < str.length && str.charCodeAt(i) == code) pos++;\n            }\n        }\n    }\n    match(code, pos) {\n        let match = null;\n        for(let i = 0; i < this.matches.length; i += 2){\n            let index = this.matches[i], keep = false;\n            if (this.query.charCodeAt(index) == code) {\n                if (index == this.query.length - 1) {\n                    match = {\n                        from: this.matches[i + 1],\n                        to: pos + 1\n                    };\n                } else {\n                    this.matches[i]++;\n                    keep = true;\n                }\n            }\n            if (!keep) {\n                this.matches.splice(i, 2);\n                i -= 2;\n            }\n        }\n        if (this.query.charCodeAt(0) == code) {\n            if (this.query.length == 1) match = {\n                from: pos,\n                to: pos + 1\n            };\n            else this.matches.push(1, pos);\n        }\n        if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferStart)) match = null;\n        return match;\n    }\n}\nif (typeof Symbol != \"undefined\") SearchCursor.prototype[Symbol.iterator] = function() {\n    return this;\n};\nconst empty = {\n    from: -1,\n    to: -1,\n    match: /*@__PURE__*/ /.*/.exec(\"\")\n};\nconst baseFlags = \"gm\" + (/x/.unicode == null ? \"\" : \"u\");\n/**\nThis class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)\nbut searches for a regular expression pattern instead of a plain\nstring.\n*/ class RegExpCursor {\n    /**\n    Create a cursor that will search the given range in the given\n    document. `query` should be the raw pattern (as you'd pass it to\n    `new RegExp`).\n    */ constructor(text, query, options, from = 0, to = text.length){\n        this.text = text;\n        this.to = to;\n        this.curLine = \"\";\n        /**\n        Set to `true` when the cursor has reached the end of the search\n        range.\n        */ this.done = false;\n        /**\n        Will contain an object with the extent of the match and the\n        match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)\n        sucessfully finds a match.\n        */ this.value = empty;\n        if (/\\\\[sWDnr]|\\n|\\r|\\[\\^/.test(query)) return new MultilineRegExpCursor(text, query, options, from, to);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.test = options === null || options === void 0 ? void 0 : options.test;\n        this.iter = text.iter();\n        let startLine = text.lineAt(from);\n        this.curLineStart = startLine.from;\n        this.matchPos = toCharEnd(text, from);\n        this.getLine(this.curLineStart);\n    }\n    getLine(skip) {\n        this.iter.next(skip);\n        if (this.iter.lineBreak) {\n            this.curLine = \"\";\n        } else {\n            this.curLine = this.iter.value;\n            if (this.curLineStart + this.curLine.length > this.to) this.curLine = this.curLine.slice(0, this.to - this.curLineStart);\n            this.iter.next();\n        }\n    }\n    nextLine() {\n        this.curLineStart = this.curLineStart + this.curLine.length + 1;\n        if (this.curLineStart > this.to) this.curLine = \"\";\n        else this.getLine(0);\n    }\n    /**\n    Move to the next match, if there is one.\n    */ next() {\n        for(let off = this.matchPos - this.curLineStart;;){\n            this.re.lastIndex = off;\n            let match = this.matchPos <= this.to && this.re.exec(this.curLine);\n            if (match) {\n                let from = this.curLineStart + match.index, to = from + match[0].length;\n                this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                if (from == this.curLineStart + this.curLine.length) this.nextLine();\n                if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {\n                    this.value = {\n                        from,\n                        to,\n                        match\n                    };\n                    return this;\n                }\n                off = this.matchPos - this.curLineStart;\n            } else if (this.curLineStart + this.curLine.length < this.to) {\n                this.nextLine();\n                off = 0;\n            } else {\n                this.done = true;\n                return this;\n            }\n        }\n    }\n}\nconst flattened = /*@__PURE__*/ new WeakMap();\n// Reusable (partially) flattened document strings\nclass FlattenedDoc {\n    constructor(from, text){\n        this.from = from;\n        this.text = text;\n    }\n    get to() {\n        return this.from + this.text.length;\n    }\n    static get(doc, from, to) {\n        let cached = flattened.get(doc);\n        if (!cached || cached.from >= to || cached.to <= from) {\n            let flat = new FlattenedDoc(from, doc.sliceString(from, to));\n            flattened.set(doc, flat);\n            return flat;\n        }\n        if (cached.from == from && cached.to == to) return cached;\n        let { text, from: cachedFrom } = cached;\n        if (cachedFrom > from) {\n            text = doc.sliceString(from, cachedFrom) + text;\n            cachedFrom = from;\n        }\n        if (cached.to < to) text += doc.sliceString(cached.to, to);\n        flattened.set(doc, new FlattenedDoc(cachedFrom, text));\n        return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));\n    }\n}\nclass MultilineRegExpCursor {\n    constructor(text, query, options, from, to){\n        this.text = text;\n        this.to = to;\n        this.done = false;\n        this.value = empty;\n        this.matchPos = toCharEnd(text, from);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.test = options === null || options === void 0 ? void 0 : options.test;\n        this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000 /* Chunk.Base */ ));\n    }\n    chunkEnd(pos) {\n        return pos >= this.to ? this.to : this.text.lineAt(pos).to;\n    }\n    next() {\n        for(;;){\n            let off = this.re.lastIndex = this.matchPos - this.flat.from;\n            let match = this.re.exec(this.flat.text);\n            // Skip empty matches directly after the last match\n            if (match && !match[0] && match.index == off) {\n                this.re.lastIndex = off + 1;\n                match = this.re.exec(this.flat.text);\n            }\n            if (match) {\n                let from = this.flat.from + match.index, to = from + match[0].length;\n                // If a match goes almost to the end of a noncomplete chunk, try\n                // again, since it'll likely be able to match more\n                if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from, to, match))) {\n                    this.value = {\n                        from,\n                        to,\n                        match\n                    };\n                    this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                    return this;\n                }\n            }\n            if (this.flat.to == this.to) {\n                this.done = true;\n                return this;\n            }\n            // Grow the flattened doc\n            this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));\n        }\n    }\n}\nif (typeof Symbol != \"undefined\") {\n    RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {\n        return this;\n    };\n}\nfunction validRegExp(source) {\n    try {\n        new RegExp(source, baseFlags);\n        return true;\n    } catch (_a) {\n        return false;\n    }\n}\nfunction toCharEnd(text, pos) {\n    if (pos >= text.length) return pos;\n    let line = text.lineAt(pos), next;\n    while(pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 0xDC00 && next < 0xE000)pos++;\n    return pos;\n}\nfunction createLineDialog(view) {\n    let line = String(view.state.doc.lineAt(view.state.selection.main.head).number);\n    let input = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n        class: \"cm-textfield\",\n        name: \"line\",\n        value: line\n    });\n    let dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"form\", {\n        class: \"cm-gotoLine\",\n        onkeydown: (event)=>{\n            if (event.keyCode == 27) {\n                event.preventDefault();\n                view.dispatch({\n                    effects: dialogEffect.of(false)\n                });\n                view.focus();\n            } else if (event.keyCode == 13) {\n                event.preventDefault();\n                go();\n            }\n        },\n        onsubmit: (event)=>{\n            event.preventDefault();\n            go();\n        }\n    }, (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", view.state.phrase(\"Go to line\"), \": \", input), \" \", (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n        class: \"cm-button\",\n        type: \"submit\"\n    }, view.state.phrase(\"go\")));\n    function go() {\n        let match = /^([+-])?(\\d+)?(:\\d+)?(%)?$/.exec(input.value);\n        if (!match) return;\n        let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);\n        let [, sign, ln, cl, percent] = match;\n        let col = cl ? +cl.slice(1) : 0;\n        let line = ln ? +ln : startLine.number;\n        if (ln && percent) {\n            let pc = line / 100;\n            if (sign) pc = pc * (sign == \"-\" ? -1 : 1) + startLine.number / state.doc.lines;\n            line = Math.round(state.doc.lines * pc);\n        } else if (ln && sign) {\n            line = line * (sign == \"-\" ? -1 : 1) + startLine.number;\n        }\n        let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));\n        let selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));\n        view.dispatch({\n            effects: [\n                dialogEffect.of(false),\n                _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(selection.from, {\n                    y: \"center\"\n                })\n            ],\n            selection\n        });\n        view.focus();\n    }\n    return {\n        dom\n    };\n}\nconst dialogEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst dialogField = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return true;\n    },\n    update (value, tr) {\n        for (let e of tr.effects)if (e.is(dialogEffect)) value = e.value;\n        return value;\n    },\n    provide: (f)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showPanel.from(f, (val)=>val ? createLineDialog : null)\n});\n/**\nCommand that shows a dialog asking the user for a line number, and\nwhen a valid position is provided, moves the cursor to that line.\n\nSupports line numbers, relative line offsets prefixed with `+` or\n`-`, document percentages suffixed with `%`, and an optional\ncolumn position by adding `:` and a second number after the line\nnumber.\n*/ const gotoLine = (view)=>{\n    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createLineDialog);\n    if (!panel) {\n        let effects = [\n            dialogEffect.of(true)\n        ];\n        if (view.state.field(dialogField, false) == null) effects.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of([\n            dialogField,\n            baseTheme$1\n        ]));\n        view.dispatch({\n            effects\n        });\n        panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createLineDialog);\n    }\n    if (panel) panel.dom.querySelector(\"input\").select();\n    return true;\n};\nconst baseTheme$1 = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-panel.cm-gotoLine\": {\n        padding: \"2px 6px 4px\",\n        \"& label\": {\n            fontSize: \"80%\"\n        }\n    }\n});\nconst defaultHighlightOptions = {\n    highlightWordAroundCursor: false,\n    minSelectionLength: 1,\n    maxMatches: 100,\n    wholeWords: false\n};\nconst highlightConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (options) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(options, defaultHighlightOptions, {\n            highlightWordAroundCursor: (a, b)=>a || b,\n            minSelectionLength: Math.min,\n            maxMatches: Math.min\n        });\n    }\n});\n/**\nThis extension highlights text that matches the selection. It uses\nthe `\"cm-selectionMatch\"` class for the highlighting. When\n`highlightWordAroundCursor` is enabled, the word at the cursor\nitself will be highlighted with `\"cm-selectionMatch-main\"`.\n*/ function highlightSelectionMatches(options) {\n    let ext = [\n        defaultTheme,\n        matchHighlighter\n    ];\n    if (options) ext.push(highlightConfig.of(options));\n    return ext;\n}\nconst matchDeco = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-selectionMatch\"\n});\nconst mainMatchDeco = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-selectionMatch cm-selectionMatch-main\"\n});\n// Whether the characters directly outside the given positions are non-word characters\nfunction insideWordBoundaries(check, state, from, to) {\n    return (from == 0 || check(state.sliceDoc(from - 1, from)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) && (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);\n}\n// Whether the characters directly at the given positions are word characters\nfunction insideWord(check, state, from, to) {\n    return check(state.sliceDoc(from, from + 1)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && check(state.sliceDoc(to - 1, to)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word;\n}\nconst matchHighlighter = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {\n    constructor(view){\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.selectionSet || update.docChanged || update.viewportChanged) this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let conf = view.state.facet(highlightConfig);\n        let { state } = view, sel = state.selection;\n        if (sel.ranges.length > 1) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n        let range = sel.main, query, check = null;\n        if (range.empty) {\n            if (!conf.highlightWordAroundCursor) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            let word = state.wordAt(range.head);\n            if (!word) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            check = state.charCategorizer(range.head);\n            query = state.sliceDoc(word.from, word.to);\n        } else {\n            let len = range.to - range.from;\n            if (len < conf.minSelectionLength || len > 200) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            if (conf.wholeWords) {\n                query = state.sliceDoc(range.from, range.to); // TODO: allow and include leading/trailing space?\n                check = state.charCategorizer(range.head);\n                if (!(insideWordBoundaries(check, state, range.from, range.to) && insideWord(check, state, range.from, range.to))) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            } else {\n                query = state.sliceDoc(range.from, range.to).trim();\n                if (!query) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            }\n        }\n        let deco = [];\n        for (let part of view.visibleRanges){\n            let cursor = new SearchCursor(state.doc, query, part.from, part.to);\n            while(!cursor.next().done){\n                let { from, to } = cursor.value;\n                if (!check || insideWordBoundaries(check, state, from, to)) {\n                    if (range.empty && from <= range.from && to >= range.to) deco.push(mainMatchDeco.range(from, to));\n                    else if (from >= range.to || to <= range.from) deco.push(matchDeco.range(from, to));\n                    if (deco.length > conf.maxMatches) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n                }\n            }\n        }\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.set(deco);\n    }\n}, {\n    decorations: (v)=>v.decorations\n});\nconst defaultTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-selectionMatch\": {\n        backgroundColor: \"#99ff7780\"\n    },\n    \".cm-searchMatch .cm-selectionMatch\": {\n        backgroundColor: \"transparent\"\n    }\n});\n// Select the words around the cursors.\nconst selectWord = ({ state, dispatch })=>{\n    let { selection } = state;\n    let newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(selection.ranges.map((range)=>state.wordAt(range.head) || _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head)), selection.mainIndex);\n    if (newSel.eq(selection)) return false;\n    dispatch(state.update({\n        selection: newSel\n    }));\n    return true;\n};\n// Find next occurrence of query relative to last cursor. Wrap around\n// the document if there are no more matches.\nfunction findNextOccurrence(state, query) {\n    let { main, ranges } = state.selection;\n    let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;\n    for(let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;){\n        cursor.next();\n        if (cursor.done) {\n            if (cycled) return null;\n            cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));\n            cycled = true;\n        } else {\n            if (cycled && ranges.some((r)=>r.from == cursor.value.from)) continue;\n            if (fullWord) {\n                let word = state.wordAt(cursor.value.from);\n                if (!word || word.from != cursor.value.from || word.to != cursor.value.to) continue;\n            }\n            return cursor.value;\n        }\n    }\n}\n/**\nSelect next occurrence of the current selection. Expand selection\nto the surrounding word when the selection is empty.\n*/ const selectNextOccurrence = ({ state, dispatch })=>{\n    let { ranges } = state.selection;\n    if (ranges.some((sel)=>sel.from === sel.to)) return selectWord({\n        state,\n        dispatch\n    });\n    let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);\n    if (state.selection.ranges.some((r)=>state.sliceDoc(r.from, r.to) != searchedText)) return false;\n    let range = findNextOccurrence(state, searchedText);\n    if (!range) return false;\n    dispatch(state.update({\n        selection: state.selection.addRange(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.from, range.to), false),\n        effects: _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(range.to)\n    }));\n    return true;\n};\nconst searchConfigFacet = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\n            top: false,\n            caseSensitive: false,\n            literal: false,\n            regexp: false,\n            wholeWord: false,\n            createPanel: (view)=>new SearchPanel(view),\n            scrollToMatch: (range)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(range)\n        });\n    }\n});\n/**\nAdd search state to the editor configuration, and optionally\nconfigure the search extension.\n([`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) will automatically\nenable this if it isn't already on).\n*/ function search(config) {\n    return config ? [\n        searchConfigFacet.of(config),\n        searchExtensions\n    ] : searchExtensions;\n}\n/**\nA search query. Part of the editor's search state.\n*/ class SearchQuery {\n    /**\n    Create a query object.\n    */ constructor(config){\n        this.search = config.search;\n        this.caseSensitive = !!config.caseSensitive;\n        this.literal = !!config.literal;\n        this.regexp = !!config.regexp;\n        this.replace = config.replace || \"\";\n        this.valid = !!this.search && (!this.regexp || validRegExp(this.search));\n        this.unquoted = this.unquote(this.search);\n        this.wholeWord = !!config.wholeWord;\n    }\n    /**\n    @internal\n    */ unquote(text) {\n        return this.literal ? text : text.replace(/\\\\([nrt\\\\])/g, (_, ch)=>ch == \"n\" ? \"\\n\" : ch == \"r\" ? \"\\r\" : ch == \"t\" ? \"\t\" : \"\\\\\");\n    }\n    /**\n    Compare this query to another query.\n    */ eq(other) {\n        return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;\n    }\n    /**\n    @internal\n    */ create() {\n        return this.regexp ? new RegExpQuery(this) : new StringQuery(this);\n    }\n    /**\n    Get a search cursor for this query, searching through the given\n    range in the given state.\n    */ getCursor(state, from = 0, to) {\n        let st = state.doc ? state : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorState.create({\n            doc: state\n        });\n        if (to == null) to = st.doc.length;\n        return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);\n    }\n}\nclass QueryType {\n    constructor(spec){\n        this.spec = spec;\n    }\n}\nfunction stringCursor(spec, state, from, to) {\n    return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? undefined : (x)=>x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : undefined);\n}\nfunction stringWordTest(doc, categorizer) {\n    return (from, to, buf, bufPos)=>{\n        if (bufPos > from || bufPos + buf.length < to) {\n            bufPos = Math.max(0, from - 2);\n            buf = doc.sliceString(bufPos, Math.min(doc.length, to + 2));\n        }\n        return (categorizer(charBefore(buf, from - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word || categorizer(charAfter(buf, from - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) && (categorizer(charAfter(buf, to - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word || categorizer(charBefore(buf, to - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);\n    };\n}\nclass StringQuery extends QueryType {\n    constructor(spec){\n        super(spec);\n    }\n    nextMatch(state, curFrom, curTo) {\n        let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();\n        if (cursor.done) cursor = stringCursor(this.spec, state, 0, curFrom).nextOverlapping();\n        return cursor.done ? null : cursor.value;\n    }\n    // Searching in reverse is, rather than implementing an inverted search\n    // cursor, done by scanning chunk after chunk forward.\n    prevMatchInRange(state, from, to) {\n        for(let pos = to;;){\n            let start = Math.max(from, pos - 10000 /* FindPrev.ChunkSize */  - this.spec.unquoted.length);\n            let cursor = stringCursor(this.spec, state, start, pos), range = null;\n            while(!cursor.nextOverlapping().done)range = cursor.value;\n            if (range) return range;\n            if (start == from) return null;\n            pos -= 10000 /* FindPrev.ChunkSize */ ;\n        }\n    }\n    prevMatch(state, curFrom, curTo) {\n        return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);\n    }\n    getReplacement(_result) {\n        return this.spec.unquote(this.spec.replace);\n    }\n    matchAll(state, limit) {\n        let cursor = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];\n        while(!cursor.next().done){\n            if (ranges.length >= limit) return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(state, from, to, add) {\n        let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));\n        while(!cursor.next().done)add(cursor.value.from, cursor.value.to);\n    }\n}\nfunction regexpCursor(spec, state, from, to) {\n    return new RegExpCursor(state.doc, spec.search, {\n        ignoreCase: !spec.caseSensitive,\n        test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : undefined\n    }, from, to);\n}\nfunction charBefore(str, index) {\n    return str.slice((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(str, index, false), index);\n}\nfunction charAfter(str, index) {\n    return str.slice(index, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(str, index));\n}\nfunction regexpWordTest(categorizer) {\n    return (_from, _to, match)=>!match[0].length || (categorizer(charBefore(match.input, match.index)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word || categorizer(charAfter(match.input, match.index)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) && (categorizer(charAfter(match.input, match.index + match[0].length)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word || categorizer(charBefore(match.input, match.index + match[0].length)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);\n}\nclass RegExpQuery extends QueryType {\n    nextMatch(state, curFrom, curTo) {\n        let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();\n        if (cursor.done) cursor = regexpCursor(this.spec, state, 0, curFrom).next();\n        return cursor.done ? null : cursor.value;\n    }\n    prevMatchInRange(state, from, to) {\n        for(let size = 1;; size++){\n            let start = Math.max(from, to - size * 10000 /* FindPrev.ChunkSize */ );\n            let cursor = regexpCursor(this.spec, state, start, to), range = null;\n            while(!cursor.next().done)range = cursor.value;\n            if (range && (start == from || range.from > start + 10)) return range;\n            if (start == from) return null;\n        }\n    }\n    prevMatch(state, curFrom, curTo) {\n        return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);\n    }\n    getReplacement(result) {\n        return this.spec.unquote(this.spec.replace).replace(/\\$([$&\\d+])/g, (m, i)=>i == \"$\" ? \"$\" : i == \"&\" ? result.match[0] : i != \"0\" && +i < result.match.length ? result.match[i] : m);\n    }\n    matchAll(state, limit) {\n        let cursor = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];\n        while(!cursor.next().done){\n            if (ranges.length >= limit) return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(state, from, to, add) {\n        let cursor = regexpCursor(this.spec, state, Math.max(0, from - 250 /* RegExp.HighlightMargin */ ), Math.min(to + 250 /* RegExp.HighlightMargin */ , state.doc.length));\n        while(!cursor.next().done)add(cursor.value.from, cursor.value.to);\n    }\n}\n/**\nA state effect that updates the current search query. Note that\nthis only has an effect if the search state has been initialized\n(by including [`search`](https://codemirror.net/6/docs/ref/#search.search) in your configuration or\nby running [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) at least\nonce).\n*/ const setSearchQuery = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst togglePanel = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst searchState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create (state) {\n        return new SearchState(defaultQuery(state).create(), null);\n    },\n    update (value, tr) {\n        for (let effect of tr.effects){\n            if (effect.is(setSearchQuery)) value = new SearchState(effect.value.create(), value.panel);\n            else if (effect.is(togglePanel)) value = new SearchState(value.query, effect.value ? createSearchPanel : null);\n        }\n        return value;\n    },\n    provide: (f)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showPanel.from(f, (val)=>val.panel)\n});\n/**\nGet the current search query from an editor state.\n*/ function getSearchQuery(state) {\n    let curState = state.field(searchState, false);\n    return curState ? curState.query.spec : defaultQuery(state);\n}\n/**\nQuery whether the search panel is open in the given editor state.\n*/ function searchPanelOpen(state) {\n    var _a;\n    return ((_a = state.field(searchState, false)) === null || _a === void 0 ? void 0 : _a.panel) != null;\n}\nclass SearchState {\n    constructor(query, panel){\n        this.query = query;\n        this.panel = panel;\n    }\n}\nconst matchMark = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-searchMatch\"\n}), selectedMatchMark = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-searchMatch cm-searchMatch-selected\"\n});\nconst searchHighlighter = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.decorations = this.highlight(view.state.field(searchState));\n    }\n    update(update) {\n        let state = update.state.field(searchState);\n        if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged) this.decorations = this.highlight(state);\n    }\n    highlight({ query, panel }) {\n        if (!panel || !query.spec.valid) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n        let { view } = this;\n        let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSetBuilder();\n        for(let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++){\n            let { from, to } = ranges[i];\n            while(i < l - 1 && to > ranges[i + 1].from - 2 * 250 /* RegExp.HighlightMargin */ )to = ranges[++i].to;\n            query.highlight(view.state, from, to, (from, to)=>{\n                let selected = view.state.selection.ranges.some((r)=>r.from == from && r.to == to);\n                builder.add(from, to, selected ? selectedMatchMark : matchMark);\n            });\n        }\n        return builder.finish();\n    }\n}, {\n    decorations: (v)=>v.decorations\n});\nfunction searchCommand(f) {\n    return (view)=>{\n        let state = view.state.field(searchState, false);\n        return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);\n    };\n}\n/**\nOpen the search panel if it isn't already open, and move the\nselection to the first match after the current main selection.\nWill wrap around to the start of the document when it reaches the\nend.\n*/ const findNext = /*@__PURE__*/ searchCommand((view, { query })=>{\n    let { to } = view.state.selection.main;\n    let next = query.nextMatch(view.state, to, to);\n    if (!next) return false;\n    let selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.single(next.from, next.to);\n    let config = view.state.facet(searchConfigFacet);\n    view.dispatch({\n        selection,\n        effects: [\n            announceMatch(view, next),\n            config.scrollToMatch(selection.main, view)\n        ],\n        userEvent: \"select.search\"\n    });\n    selectSearchInput(view);\n    return true;\n});\n/**\nMove the selection to the previous instance of the search query,\nbefore the current main selection. Will wrap past the start\nof the document to start searching at the end again.\n*/ const findPrevious = /*@__PURE__*/ searchCommand((view, { query })=>{\n    let { state } = view, { from } = state.selection.main;\n    let prev = query.prevMatch(state, from, from);\n    if (!prev) return false;\n    let selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.single(prev.from, prev.to);\n    let config = view.state.facet(searchConfigFacet);\n    view.dispatch({\n        selection,\n        effects: [\n            announceMatch(view, prev),\n            config.scrollToMatch(selection.main, view)\n        ],\n        userEvent: \"select.search\"\n    });\n    selectSearchInput(view);\n    return true;\n});\n/**\nSelect all instances of the search query.\n*/ const selectMatches = /*@__PURE__*/ searchCommand((view, { query })=>{\n    let ranges = query.matchAll(view.state, 1000);\n    if (!ranges || !ranges.length) return false;\n    view.dispatch({\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges.map((r)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.from, r.to))),\n        userEvent: \"select.search.matches\"\n    });\n    return true;\n});\n/**\nSelect all instances of the currently selected text.\n*/ const selectSelectionMatches = ({ state, dispatch })=>{\n    let sel = state.selection;\n    if (sel.ranges.length > 1 || sel.main.empty) return false;\n    let { from, to } = sel.main;\n    let ranges = [], main = 0;\n    for(let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;){\n        if (ranges.length > 1000) return false;\n        if (cur.value.from == from) main = ranges.length;\n        ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(cur.value.from, cur.value.to));\n    }\n    dispatch(state.update({\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges, main),\n        userEvent: \"select.search.matches\"\n    }));\n    return true;\n};\n/**\nReplace the current match of the search query.\n*/ const replaceNext = /*@__PURE__*/ searchCommand((view, { query })=>{\n    let { state } = view, { from, to } = state.selection.main;\n    if (state.readOnly) return false;\n    let next = query.nextMatch(state, from, from);\n    if (!next) return false;\n    let changes = [], selection, replacement;\n    let effects = [];\n    if (next.from == from && next.to == to) {\n        replacement = state.toText(query.getReplacement(next));\n        changes.push({\n            from: next.from,\n            to: next.to,\n            insert: replacement\n        });\n        next = query.nextMatch(state, next.from, next.to);\n        effects.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(state.phrase(\"replaced match on line $\", state.doc.lineAt(from).number) + \".\"));\n    }\n    if (next) {\n        let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;\n        selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.single(next.from - off, next.to - off);\n        effects.push(announceMatch(view, next));\n        effects.push(state.facet(searchConfigFacet).scrollToMatch(selection.main, view));\n    }\n    view.dispatch({\n        changes,\n        selection,\n        effects,\n        userEvent: \"input.replace\"\n    });\n    return true;\n});\n/**\nReplace all instances of the search query with the given\nreplacement.\n*/ const replaceAll = /*@__PURE__*/ searchCommand((view, { query })=>{\n    if (view.state.readOnly) return false;\n    let changes = query.matchAll(view.state, 1e9).map((match)=>{\n        let { from, to } = match;\n        return {\n            from,\n            to,\n            insert: query.getReplacement(match)\n        };\n    });\n    if (!changes.length) return false;\n    let announceText = view.state.phrase(\"replaced $ matches\", changes.length) + \".\";\n    view.dispatch({\n        changes,\n        effects: _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(announceText),\n        userEvent: \"input.replace.all\"\n    });\n    return true;\n});\nfunction createSearchPanel(view) {\n    return view.state.facet(searchConfigFacet).createPanel(view);\n}\nfunction defaultQuery(state, fallback) {\n    var _a, _b, _c, _d, _e;\n    let sel = state.selection.main;\n    let selText = sel.empty || sel.to > sel.from + 100 ? \"\" : state.sliceDoc(sel.from, sel.to);\n    if (fallback && !selText) return fallback;\n    let config = state.facet(searchConfigFacet);\n    return new SearchQuery({\n        search: ((_a = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a !== void 0 ? _a : config.literal) ? selText : selText.replace(/\\n/g, \"\\\\n\"),\n        caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config.caseSensitive,\n        literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config.literal,\n        regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config.regexp,\n        wholeWord: (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e !== void 0 ? _e : config.wholeWord\n    });\n}\nfunction getSearchInput(view) {\n    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createSearchPanel);\n    return panel && panel.dom.querySelector(\"[main-field]\");\n}\nfunction selectSearchInput(view) {\n    let input = getSearchInput(view);\n    if (input && input == view.root.activeElement) input.select();\n}\n/**\nMake sure the search panel is open and focused.\n*/ const openSearchPanel = (view)=>{\n    let state = view.state.field(searchState, false);\n    if (state && state.panel) {\n        let searchInput = getSearchInput(view);\n        if (searchInput && searchInput != view.root.activeElement) {\n            let query = defaultQuery(view.state, state.query.spec);\n            if (query.valid) view.dispatch({\n                effects: setSearchQuery.of(query)\n            });\n            searchInput.focus();\n            searchInput.select();\n        }\n    } else {\n        view.dispatch({\n            effects: [\n                togglePanel.of(true),\n                state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of(searchExtensions)\n            ]\n        });\n    }\n    return true;\n};\n/**\nClose the search panel.\n*/ const closeSearchPanel = (view)=>{\n    let state = view.state.field(searchState, false);\n    if (!state || !state.panel) return false;\n    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createSearchPanel);\n    if (panel && panel.dom.contains(view.root.activeElement)) view.focus();\n    view.dispatch({\n        effects: togglePanel.of(false)\n    });\n    return true;\n};\n/**\nDefault search-related key bindings.\n\n - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)\n - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)\n - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)\n - Mod-Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)\n - Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)\n*/ const searchKeymap = [\n    {\n        key: \"Mod-f\",\n        run: openSearchPanel,\n        scope: \"editor search-panel\"\n    },\n    {\n        key: \"F3\",\n        run: findNext,\n        shift: findPrevious,\n        scope: \"editor search-panel\",\n        preventDefault: true\n    },\n    {\n        key: \"Mod-g\",\n        run: findNext,\n        shift: findPrevious,\n        scope: \"editor search-panel\",\n        preventDefault: true\n    },\n    {\n        key: \"Escape\",\n        run: closeSearchPanel,\n        scope: \"editor search-panel\"\n    },\n    {\n        key: \"Mod-Shift-l\",\n        run: selectSelectionMatches\n    },\n    {\n        key: \"Mod-Alt-g\",\n        run: gotoLine\n    },\n    {\n        key: \"Mod-d\",\n        run: selectNextOccurrence,\n        preventDefault: true\n    }\n];\nclass SearchPanel {\n    constructor(view){\n        this.view = view;\n        let query = this.query = view.state.field(searchState).query.spec;\n        this.commit = this.commit.bind(this);\n        this.searchField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            value: query.search,\n            placeholder: phrase(view, \"Find\"),\n            \"aria-label\": phrase(view, \"Find\"),\n            class: \"cm-textfield\",\n            name: \"search\",\n            form: \"\",\n            \"main-field\": \"true\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.replaceField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            value: query.replace,\n            placeholder: phrase(view, \"Replace\"),\n            \"aria-label\": phrase(view, \"Replace\"),\n            class: \"cm-textfield\",\n            name: \"replace\",\n            form: \"\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.caseField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            type: \"checkbox\",\n            name: \"case\",\n            form: \"\",\n            checked: query.caseSensitive,\n            onchange: this.commit\n        });\n        this.reField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            type: \"checkbox\",\n            name: \"re\",\n            form: \"\",\n            checked: query.regexp,\n            onchange: this.commit\n        });\n        this.wordField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            type: \"checkbox\",\n            name: \"word\",\n            form: \"\",\n            checked: query.wholeWord,\n            onchange: this.commit\n        });\n        function button(name, onclick, content) {\n            return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n                class: \"cm-button\",\n                name,\n                onclick,\n                type: \"button\"\n            }, content);\n        }\n        this.dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"div\", {\n            onkeydown: (e)=>this.keydown(e),\n            class: \"cm-search\"\n        }, [\n            this.searchField,\n            button(\"next\", ()=>findNext(view), [\n                phrase(view, \"next\")\n            ]),\n            button(\"prev\", ()=>findPrevious(view), [\n                phrase(view, \"previous\")\n            ]),\n            button(\"select\", ()=>selectMatches(view), [\n                phrase(view, \"all\")\n            ]),\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [\n                this.caseField,\n                phrase(view, \"match case\")\n            ]),\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [\n                this.reField,\n                phrase(view, \"regexp\")\n            ]),\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [\n                this.wordField,\n                phrase(view, \"by word\")\n            ]),\n            ...view.state.readOnly ? [] : [\n                (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"br\"),\n                this.replaceField,\n                button(\"replace\", ()=>replaceNext(view), [\n                    phrase(view, \"replace\")\n                ]),\n                button(\"replaceAll\", ()=>replaceAll(view), [\n                    phrase(view, \"replace all\")\n                ])\n            ],\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n                name: \"close\",\n                onclick: ()=>closeSearchPanel(view),\n                \"aria-label\": phrase(view, \"close\"),\n                type: \"button\"\n            }, [\n                \"\\xd7\"\n            ])\n        ]);\n    }\n    commit() {\n        let query = new SearchQuery({\n            search: this.searchField.value,\n            caseSensitive: this.caseField.checked,\n            regexp: this.reField.checked,\n            wholeWord: this.wordField.checked,\n            replace: this.replaceField.value\n        });\n        if (!query.eq(this.query)) {\n            this.query = query;\n            this.view.dispatch({\n                effects: setSearchQuery.of(query)\n            });\n        }\n    }\n    keydown(e) {\n        if ((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.runScopeHandlers)(this.view, e, \"search-panel\")) {\n            e.preventDefault();\n        } else if (e.keyCode == 13 && e.target == this.searchField) {\n            e.preventDefault();\n            (e.shiftKey ? findPrevious : findNext)(this.view);\n        } else if (e.keyCode == 13 && e.target == this.replaceField) {\n            e.preventDefault();\n            replaceNext(this.view);\n        }\n    }\n    update(update) {\n        for (let tr of update.transactions)for (let effect of tr.effects){\n            if (effect.is(setSearchQuery) && !effect.value.eq(this.query)) this.setQuery(effect.value);\n        }\n    }\n    setQuery(query) {\n        this.query = query;\n        this.searchField.value = query.search;\n        this.replaceField.value = query.replace;\n        this.caseField.checked = query.caseSensitive;\n        this.reField.checked = query.regexp;\n        this.wordField.checked = query.wholeWord;\n    }\n    mount() {\n        this.searchField.select();\n    }\n    get pos() {\n        return 80;\n    }\n    get top() {\n        return this.view.state.facet(searchConfigFacet).top;\n    }\n}\nfunction phrase(view, phrase) {\n    return view.state.phrase(phrase);\n}\nconst AnnounceMargin = 30;\nconst Break = /[\\s\\.,:;?!]/;\nfunction announceMatch(view, { from, to }) {\n    let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;\n    let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);\n    let text = view.state.sliceDoc(start, end);\n    if (start != line.from) {\n        for(let i = 0; i < AnnounceMargin; i++)if (!Break.test(text[i + 1]) && Break.test(text[i])) {\n            text = text.slice(i);\n            break;\n        }\n    }\n    if (end != lineEnd) {\n        for(let i = text.length - 1; i > text.length - AnnounceMargin; i--)if (!Break.test(text[i - 1]) && Break.test(text[i])) {\n            text = text.slice(0, i);\n            break;\n        }\n    }\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(`${view.state.phrase(\"current match\")}. ${text} ${view.state.phrase(\"on line\")} ${line.number}.`);\n}\nconst baseTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-panel.cm-search\": {\n        padding: \"2px 6px 4px\",\n        position: \"relative\",\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"4px\",\n            backgroundColor: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        },\n        \"& input, & button, & label\": {\n            margin: \".2em .6em .2em 0\"\n        },\n        \"& input[type=checkbox]\": {\n            marginRight: \".2em\"\n        },\n        \"& label\": {\n            fontSize: \"80%\",\n            whiteSpace: \"pre\"\n        }\n    },\n    \"&light .cm-searchMatch\": {\n        backgroundColor: \"#ffff0054\"\n    },\n    \"&dark .cm-searchMatch\": {\n        backgroundColor: \"#00ffff8a\"\n    },\n    \"&light .cm-searchMatch-selected\": {\n        backgroundColor: \"#ff6a0054\"\n    },\n    \"&dark .cm-searchMatch-selected\": {\n        backgroundColor: \"#ff00ff8a\"\n    }\n});\nconst searchExtensions = [\n    searchState,\n    /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.low(searchHighlighter),\n    baseTheme\n];\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivc2VhcmNoL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2RztBQUNxRztBQUMxTDtBQUV4QixNQUFNb0IsaUJBQWlCLE9BQU9DLE9BQU9DLFNBQVMsQ0FBQ0MsU0FBUyxJQUFJLGFBQ3REQyxDQUFBQSxJQUFLQSxFQUFFRCxTQUFTLENBQUMsVUFBVUMsQ0FBQUEsSUFBS0E7QUFDdEM7OztBQUdBLEdBQ0EsTUFBTUM7SUFDRjs7Ozs7Ozs7Ozs7O0lBWUEsR0FDQUMsWUFBWUMsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLE9BQU8sQ0FBQyxFQUFFQyxLQUFLSCxLQUFLSSxNQUFNLEVBQUVSLFNBQVMsRUFBRVMsSUFBSSxDQUFFO1FBQ2xFLElBQUksQ0FBQ0EsSUFBSSxHQUFHQTtRQUNaOzs7O1FBSUEsR0FDQSxJQUFJLENBQUNDLEtBQUssR0FBRztZQUFFSixNQUFNO1lBQUdDLElBQUk7UUFBRTtRQUM5Qjs7UUFFQSxHQUNBLElBQUksQ0FBQ0ksSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDQyxPQUFPLEdBQUcsRUFBRTtRQUNqQixJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0MsSUFBSSxHQUFHWCxLQUFLWSxTQUFTLENBQUNWLE1BQU1DO1FBQ2pDLElBQUksQ0FBQ1UsV0FBVyxHQUFHWDtRQUNuQixJQUFJLENBQUNOLFNBQVMsR0FBR0EsWUFBWUMsQ0FBQUEsSUFBS0QsVUFBVUgsZUFBZUksTUFBTUo7UUFDakUsSUFBSSxDQUFDUSxLQUFLLEdBQUcsSUFBSSxDQUFDTCxTQUFTLENBQUNLO0lBQ2hDO0lBQ0FhLE9BQU87UUFDSCxJQUFJLElBQUksQ0FBQ0osU0FBUyxJQUFJLElBQUksQ0FBQ0QsTUFBTSxDQUFDTCxNQUFNLEVBQUU7WUFDdEMsSUFBSSxDQUFDUyxXQUFXLElBQUksSUFBSSxDQUFDSixNQUFNLENBQUNMLE1BQU07WUFDdEMsSUFBSSxDQUFDTyxJQUFJLENBQUNJLElBQUk7WUFDZCxJQUFJLElBQUksQ0FBQ0osSUFBSSxDQUFDSixJQUFJLEVBQ2QsT0FBTyxDQUFDO1lBQ1osSUFBSSxDQUFDRyxTQUFTLEdBQUc7WUFDakIsSUFBSSxDQUFDRCxNQUFNLEdBQUcsSUFBSSxDQUFDRSxJQUFJLENBQUNMLEtBQUs7UUFDakM7UUFDQSxPQUFPM0IsOERBQVdBLENBQUMsSUFBSSxDQUFDOEIsTUFBTSxFQUFFLElBQUksQ0FBQ0MsU0FBUztJQUNsRDtJQUNBOzs7OztJQUtBLEdBQ0FLLE9BQU87UUFDSCxNQUFPLElBQUksQ0FBQ1AsT0FBTyxDQUFDSixNQUFNLENBQ3RCLElBQUksQ0FBQ0ksT0FBTyxDQUFDUSxHQUFHO1FBQ3BCLE9BQU8sSUFBSSxDQUFDQyxlQUFlO0lBQy9CO0lBQ0E7Ozs7SUFJQSxHQUNBQSxrQkFBa0I7UUFDZCxPQUFTO1lBQ0wsSUFBSUYsT0FBTyxJQUFJLENBQUNELElBQUk7WUFDcEIsSUFBSUMsT0FBTyxHQUFHO2dCQUNWLElBQUksQ0FBQ1IsSUFBSSxHQUFHO2dCQUNaLE9BQU8sSUFBSTtZQUNmO1lBQ0EsSUFBSVcsTUFBTXRDLGdFQUFhQSxDQUFDbUMsT0FBT0ksUUFBUSxJQUFJLENBQUNOLFdBQVcsR0FBRyxJQUFJLENBQUNILFNBQVM7WUFDeEUsSUFBSSxDQUFDQSxTQUFTLElBQUk3QixnRUFBYUEsQ0FBQ2tDO1lBQ2hDLElBQUlLLE9BQU8sSUFBSSxDQUFDeEIsU0FBUyxDQUFDc0I7WUFDMUIsSUFBSyxJQUFJRyxJQUFJLEdBQUdDLE1BQU1ILFFBQVFFLElBQUs7Z0JBQy9CLElBQUlFLE9BQU9ILEtBQUtJLFVBQVUsQ0FBQ0g7Z0JBQzNCLElBQUlJLFFBQVEsSUFBSSxDQUFDQSxLQUFLLENBQUNGLE1BQU1EO2dCQUM3QixJQUFJRCxLQUFLRCxLQUFLaEIsTUFBTSxHQUFHLEdBQUc7b0JBQ3RCLElBQUlxQixPQUFPO3dCQUNQLElBQUksQ0FBQ25CLEtBQUssR0FBR21CO3dCQUNiLE9BQU8sSUFBSTtvQkFDZjtvQkFDQTtnQkFDSjtnQkFDQSxJQUFJSCxPQUFPSCxTQUFTRSxJQUFJSCxJQUFJZCxNQUFNLElBQUljLElBQUlNLFVBQVUsQ0FBQ0gsTUFBTUUsTUFDdkREO1lBQ1I7UUFDSjtJQUNKO0lBQ0FHLE1BQU1GLElBQUksRUFBRUQsR0FBRyxFQUFFO1FBQ2IsSUFBSUcsUUFBUTtRQUNaLElBQUssSUFBSUosSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ2IsT0FBTyxDQUFDSixNQUFNLEVBQUVpQixLQUFLLEVBQUc7WUFDN0MsSUFBSUssUUFBUSxJQUFJLENBQUNsQixPQUFPLENBQUNhLEVBQUUsRUFBRU0sT0FBTztZQUNwQyxJQUFJLElBQUksQ0FBQzFCLEtBQUssQ0FBQ3VCLFVBQVUsQ0FBQ0UsVUFBVUgsTUFBTTtnQkFDdEMsSUFBSUcsU0FBUyxJQUFJLENBQUN6QixLQUFLLENBQUNHLE1BQU0sR0FBRyxHQUFHO29CQUNoQ3FCLFFBQVE7d0JBQUV2QixNQUFNLElBQUksQ0FBQ00sT0FBTyxDQUFDYSxJQUFJLEVBQUU7d0JBQUVsQixJQUFJbUIsTUFBTTtvQkFBRTtnQkFDckQsT0FDSztvQkFDRCxJQUFJLENBQUNkLE9BQU8sQ0FBQ2EsRUFBRTtvQkFDZk0sT0FBTztnQkFDWDtZQUNKO1lBQ0EsSUFBSSxDQUFDQSxNQUFNO2dCQUNQLElBQUksQ0FBQ25CLE9BQU8sQ0FBQ29CLE1BQU0sQ0FBQ1AsR0FBRztnQkFDdkJBLEtBQUs7WUFDVDtRQUNKO1FBQ0EsSUFBSSxJQUFJLENBQUNwQixLQUFLLENBQUN1QixVQUFVLENBQUMsTUFBTUQsTUFBTTtZQUNsQyxJQUFJLElBQUksQ0FBQ3RCLEtBQUssQ0FBQ0csTUFBTSxJQUFJLEdBQ3JCcUIsUUFBUTtnQkFBRXZCLE1BQU1vQjtnQkFBS25CLElBQUltQixNQUFNO1lBQUU7aUJBRWpDLElBQUksQ0FBQ2QsT0FBTyxDQUFDcUIsSUFBSSxDQUFDLEdBQUdQO1FBQzdCO1FBQ0EsSUFBSUcsU0FBUyxJQUFJLENBQUNwQixJQUFJLElBQUksQ0FBQyxJQUFJLENBQUNBLElBQUksQ0FBQ29CLE1BQU12QixJQUFJLEVBQUV1QixNQUFNdEIsRUFBRSxFQUFFLElBQUksQ0FBQ00sTUFBTSxFQUFFLElBQUksQ0FBQ0ksV0FBVyxHQUNwRlksUUFBUTtRQUNaLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLElBQUksT0FBT0ssVUFBVSxhQUNqQmhDLGFBQWFILFNBQVMsQ0FBQ21DLE9BQU9DLFFBQVEsQ0FBQyxHQUFHO0lBQWMsT0FBTyxJQUFJO0FBQUU7QUFFekUsTUFBTUMsUUFBUTtJQUFFOUIsTUFBTSxDQUFDO0lBQUdDLElBQUksQ0FBQztJQUFHc0IsT0FBTyxXQUFXLEdBQUUsS0FBS1EsSUFBSSxDQUFDO0FBQUk7QUFDcEUsTUFBTUMsWUFBWSxPQUFRLEtBQUlDLE9BQU8sSUFBSSxPQUFPLEtBQUssR0FBRTtBQUN2RDs7OztBQUlBLEdBQ0EsTUFBTUM7SUFDRjs7OztJQUlBLEdBQ0FyQyxZQUFZQyxJQUFJLEVBQUVDLEtBQUssRUFBRW9DLE9BQU8sRUFBRW5DLE9BQU8sQ0FBQyxFQUFFQyxLQUFLSCxLQUFLSSxNQUFNLENBQUU7UUFDMUQsSUFBSSxDQUFDSixJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDRyxFQUFFLEdBQUdBO1FBQ1YsSUFBSSxDQUFDbUMsT0FBTyxHQUFHO1FBQ2Y7OztRQUdBLEdBQ0EsSUFBSSxDQUFDL0IsSUFBSSxHQUFHO1FBQ1o7Ozs7UUFJQSxHQUNBLElBQUksQ0FBQ0QsS0FBSyxHQUFHMEI7UUFDYixJQUFJLHVCQUF1QjNCLElBQUksQ0FBQ0osUUFDNUIsT0FBTyxJQUFJc0Msc0JBQXNCdkMsTUFBTUMsT0FBT29DLFNBQVNuQyxNQUFNQztRQUNqRSxJQUFJLENBQUNxQyxFQUFFLEdBQUcsSUFBSUMsT0FBT3hDLE9BQU9pQyxZQUFhLEVBQUNHLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRSyxVQUFVLElBQUksTUFBTSxFQUFDO1FBQ3pILElBQUksQ0FBQ3JDLElBQUksR0FBR2dDLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRaEMsSUFBSTtRQUMxRSxJQUFJLENBQUNNLElBQUksR0FBR1gsS0FBS1csSUFBSTtRQUNyQixJQUFJZ0MsWUFBWTNDLEtBQUs0QyxNQUFNLENBQUMxQztRQUM1QixJQUFJLENBQUMyQyxZQUFZLEdBQUdGLFVBQVV6QyxJQUFJO1FBQ2xDLElBQUksQ0FBQzRDLFFBQVEsR0FBR0MsVUFBVS9DLE1BQU1FO1FBQ2hDLElBQUksQ0FBQzhDLE9BQU8sQ0FBQyxJQUFJLENBQUNILFlBQVk7SUFDbEM7SUFDQUcsUUFBUUMsSUFBSSxFQUFFO1FBQ1YsSUFBSSxDQUFDdEMsSUFBSSxDQUFDSSxJQUFJLENBQUNrQztRQUNmLElBQUksSUFBSSxDQUFDdEMsSUFBSSxDQUFDdUMsU0FBUyxFQUFFO1lBQ3JCLElBQUksQ0FBQ1osT0FBTyxHQUFHO1FBQ25CLE9BQ0s7WUFDRCxJQUFJLENBQUNBLE9BQU8sR0FBRyxJQUFJLENBQUMzQixJQUFJLENBQUNMLEtBQUs7WUFDOUIsSUFBSSxJQUFJLENBQUN1QyxZQUFZLEdBQUcsSUFBSSxDQUFDUCxPQUFPLENBQUNsQyxNQUFNLEdBQUcsSUFBSSxDQUFDRCxFQUFFLEVBQ2pELElBQUksQ0FBQ21DLE9BQU8sR0FBRyxJQUFJLENBQUNBLE9BQU8sQ0FBQ2EsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDaEQsRUFBRSxHQUFHLElBQUksQ0FBQzBDLFlBQVk7WUFDcEUsSUFBSSxDQUFDbEMsSUFBSSxDQUFDSSxJQUFJO1FBQ2xCO0lBQ0o7SUFDQXFDLFdBQVc7UUFDUCxJQUFJLENBQUNQLFlBQVksR0FBRyxJQUFJLENBQUNBLFlBQVksR0FBRyxJQUFJLENBQUNQLE9BQU8sQ0FBQ2xDLE1BQU0sR0FBRztRQUM5RCxJQUFJLElBQUksQ0FBQ3lDLFlBQVksR0FBRyxJQUFJLENBQUMxQyxFQUFFLEVBQzNCLElBQUksQ0FBQ21DLE9BQU8sR0FBRzthQUVmLElBQUksQ0FBQ1UsT0FBTyxDQUFDO0lBQ3JCO0lBQ0E7O0lBRUEsR0FDQWpDLE9BQU87UUFDSCxJQUFLLElBQUlzQyxNQUFNLElBQUksQ0FBQ1AsUUFBUSxHQUFHLElBQUksQ0FBQ0QsWUFBWSxHQUFJO1lBQ2hELElBQUksQ0FBQ0wsRUFBRSxDQUFDYyxTQUFTLEdBQUdEO1lBQ3BCLElBQUk1QixRQUFRLElBQUksQ0FBQ3FCLFFBQVEsSUFBSSxJQUFJLENBQUMzQyxFQUFFLElBQUksSUFBSSxDQUFDcUMsRUFBRSxDQUFDUCxJQUFJLENBQUMsSUFBSSxDQUFDSyxPQUFPO1lBQ2pFLElBQUliLE9BQU87Z0JBQ1AsSUFBSXZCLE9BQU8sSUFBSSxDQUFDMkMsWUFBWSxHQUFHcEIsTUFBTUMsS0FBSyxFQUFFdkIsS0FBS0QsT0FBT3VCLEtBQUssQ0FBQyxFQUFFLENBQUNyQixNQUFNO2dCQUN2RSxJQUFJLENBQUMwQyxRQUFRLEdBQUdDLFVBQVUsSUFBSSxDQUFDL0MsSUFBSSxFQUFFRyxLQUFNRCxDQUFBQSxRQUFRQyxLQUFLLElBQUk7Z0JBQzVELElBQUlELFFBQVEsSUFBSSxDQUFDMkMsWUFBWSxHQUFHLElBQUksQ0FBQ1AsT0FBTyxDQUFDbEMsTUFBTSxFQUMvQyxJQUFJLENBQUNnRCxRQUFRO2dCQUNqQixJQUFJLENBQUNsRCxPQUFPQyxNQUFNRCxPQUFPLElBQUksQ0FBQ0ksS0FBSyxDQUFDSCxFQUFFLEtBQU0sRUFBQyxJQUFJLENBQUNFLElBQUksSUFBSSxJQUFJLENBQUNBLElBQUksQ0FBQ0gsTUFBTUMsSUFBSXNCLE1BQUssR0FBSTtvQkFDbkYsSUFBSSxDQUFDbkIsS0FBSyxHQUFHO3dCQUFFSjt3QkFBTUM7d0JBQUlzQjtvQkFBTTtvQkFDL0IsT0FBTyxJQUFJO2dCQUNmO2dCQUNBNEIsTUFBTSxJQUFJLENBQUNQLFFBQVEsR0FBRyxJQUFJLENBQUNELFlBQVk7WUFDM0MsT0FDSyxJQUFJLElBQUksQ0FBQ0EsWUFBWSxHQUFHLElBQUksQ0FBQ1AsT0FBTyxDQUFDbEMsTUFBTSxHQUFHLElBQUksQ0FBQ0QsRUFBRSxFQUFFO2dCQUN4RCxJQUFJLENBQUNpRCxRQUFRO2dCQUNiQyxNQUFNO1lBQ1YsT0FDSztnQkFDRCxJQUFJLENBQUM5QyxJQUFJLEdBQUc7Z0JBQ1osT0FBTyxJQUFJO1lBQ2Y7UUFDSjtJQUNKO0FBQ0o7QUFDQSxNQUFNZ0QsWUFBWSxXQUFXLEdBQUUsSUFBSUM7QUFDbkMsa0RBQWtEO0FBQ2xELE1BQU1DO0lBQ0YxRCxZQUFZRyxJQUFJLEVBQUVGLElBQUksQ0FBRTtRQUNwQixJQUFJLENBQUNFLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNGLElBQUksR0FBR0E7SUFDaEI7SUFDQSxJQUFJRyxLQUFLO1FBQUUsT0FBTyxJQUFJLENBQUNELElBQUksR0FBRyxJQUFJLENBQUNGLElBQUksQ0FBQ0ksTUFBTTtJQUFFO0lBQ2hELE9BQU9zRCxJQUFJQyxHQUFHLEVBQUV6RCxJQUFJLEVBQUVDLEVBQUUsRUFBRTtRQUN0QixJQUFJeUQsU0FBU0wsVUFBVUcsR0FBRyxDQUFDQztRQUMzQixJQUFJLENBQUNDLFVBQVVBLE9BQU8xRCxJQUFJLElBQUlDLE1BQU15RCxPQUFPekQsRUFBRSxJQUFJRCxNQUFNO1lBQ25ELElBQUkyRCxPQUFPLElBQUlKLGFBQWF2RCxNQUFNeUQsSUFBSUcsV0FBVyxDQUFDNUQsTUFBTUM7WUFDeERvRCxVQUFVUSxHQUFHLENBQUNKLEtBQUtFO1lBQ25CLE9BQU9BO1FBQ1g7UUFDQSxJQUFJRCxPQUFPMUQsSUFBSSxJQUFJQSxRQUFRMEQsT0FBT3pELEVBQUUsSUFBSUEsSUFDcEMsT0FBT3lEO1FBQ1gsSUFBSSxFQUFFNUQsSUFBSSxFQUFFRSxNQUFNOEQsVUFBVSxFQUFFLEdBQUdKO1FBQ2pDLElBQUlJLGFBQWE5RCxNQUFNO1lBQ25CRixPQUFPMkQsSUFBSUcsV0FBVyxDQUFDNUQsTUFBTThELGNBQWNoRTtZQUMzQ2dFLGFBQWE5RDtRQUNqQjtRQUNBLElBQUkwRCxPQUFPekQsRUFBRSxHQUFHQSxJQUNaSCxRQUFRMkQsSUFBSUcsV0FBVyxDQUFDRixPQUFPekQsRUFBRSxFQUFFQTtRQUN2Q29ELFVBQVVRLEdBQUcsQ0FBQ0osS0FBSyxJQUFJRixhQUFhTyxZQUFZaEU7UUFDaEQsT0FBTyxJQUFJeUQsYUFBYXZELE1BQU1GLEtBQUttRCxLQUFLLENBQUNqRCxPQUFPOEQsWUFBWTdELEtBQUs2RDtJQUNyRTtBQUNKO0FBQ0EsTUFBTXpCO0lBQ0Z4QyxZQUFZQyxJQUFJLEVBQUVDLEtBQUssRUFBRW9DLE9BQU8sRUFBRW5DLElBQUksRUFBRUMsRUFBRSxDQUFFO1FBQ3hDLElBQUksQ0FBQ0gsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0csRUFBRSxHQUFHQTtRQUNWLElBQUksQ0FBQ0ksSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDRCxLQUFLLEdBQUcwQjtRQUNiLElBQUksQ0FBQ2MsUUFBUSxHQUFHQyxVQUFVL0MsTUFBTUU7UUFDaEMsSUFBSSxDQUFDc0MsRUFBRSxHQUFHLElBQUlDLE9BQU94QyxPQUFPaUMsWUFBYSxFQUFDRyxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUUssVUFBVSxJQUFJLE1BQU0sRUFBQztRQUN6SCxJQUFJLENBQUNyQyxJQUFJLEdBQUdnQyxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUWhDLElBQUk7UUFDMUUsSUFBSSxDQUFDd0QsSUFBSSxHQUFHSixhQUFhQyxHQUFHLENBQUMxRCxNQUFNRSxNQUFNLElBQUksQ0FBQytELFFBQVEsQ0FBQy9ELE9BQU8sS0FBSyxjQUFjO0lBQ3JGO0lBQ0ErRCxTQUFTM0MsR0FBRyxFQUFFO1FBQ1YsT0FBT0EsT0FBTyxJQUFJLENBQUNuQixFQUFFLEdBQUcsSUFBSSxDQUFDQSxFQUFFLEdBQUcsSUFBSSxDQUFDSCxJQUFJLENBQUM0QyxNQUFNLENBQUN0QixLQUFLbkIsRUFBRTtJQUM5RDtJQUNBWSxPQUFPO1FBQ0gsT0FBUztZQUNMLElBQUlzQyxNQUFNLElBQUksQ0FBQ2IsRUFBRSxDQUFDYyxTQUFTLEdBQUcsSUFBSSxDQUFDUixRQUFRLEdBQUcsSUFBSSxDQUFDZSxJQUFJLENBQUMzRCxJQUFJO1lBQzVELElBQUl1QixRQUFRLElBQUksQ0FBQ2UsRUFBRSxDQUFDUCxJQUFJLENBQUMsSUFBSSxDQUFDNEIsSUFBSSxDQUFDN0QsSUFBSTtZQUN2QyxtREFBbUQ7WUFDbkQsSUFBSXlCLFNBQVMsQ0FBQ0EsS0FBSyxDQUFDLEVBQUUsSUFBSUEsTUFBTUMsS0FBSyxJQUFJMkIsS0FBSztnQkFDMUMsSUFBSSxDQUFDYixFQUFFLENBQUNjLFNBQVMsR0FBR0QsTUFBTTtnQkFDMUI1QixRQUFRLElBQUksQ0FBQ2UsRUFBRSxDQUFDUCxJQUFJLENBQUMsSUFBSSxDQUFDNEIsSUFBSSxDQUFDN0QsSUFBSTtZQUN2QztZQUNBLElBQUl5QixPQUFPO2dCQUNQLElBQUl2QixPQUFPLElBQUksQ0FBQzJELElBQUksQ0FBQzNELElBQUksR0FBR3VCLE1BQU1DLEtBQUssRUFBRXZCLEtBQUtELE9BQU91QixLQUFLLENBQUMsRUFBRSxDQUFDckIsTUFBTTtnQkFDcEUsZ0VBQWdFO2dCQUNoRSxrREFBa0Q7Z0JBQ2xELElBQUksQ0FBQyxJQUFJLENBQUN5RCxJQUFJLENBQUMxRCxFQUFFLElBQUksSUFBSSxDQUFDQSxFQUFFLElBQUlzQixNQUFNQyxLQUFLLEdBQUdELEtBQUssQ0FBQyxFQUFFLENBQUNyQixNQUFNLElBQUksSUFBSSxDQUFDeUQsSUFBSSxDQUFDN0QsSUFBSSxDQUFDSSxNQUFNLEdBQUcsRUFBQyxLQUNyRixFQUFDLElBQUksQ0FBQ0MsSUFBSSxJQUFJLElBQUksQ0FBQ0EsSUFBSSxDQUFDSCxNQUFNQyxJQUFJc0IsTUFBSyxHQUFJO29CQUM1QyxJQUFJLENBQUNuQixLQUFLLEdBQUc7d0JBQUVKO3dCQUFNQzt3QkFBSXNCO29CQUFNO29CQUMvQixJQUFJLENBQUNxQixRQUFRLEdBQUdDLFVBQVUsSUFBSSxDQUFDL0MsSUFBSSxFQUFFRyxLQUFNRCxDQUFBQSxRQUFRQyxLQUFLLElBQUk7b0JBQzVELE9BQU8sSUFBSTtnQkFDZjtZQUNKO1lBQ0EsSUFBSSxJQUFJLENBQUMwRCxJQUFJLENBQUMxRCxFQUFFLElBQUksSUFBSSxDQUFDQSxFQUFFLEVBQUU7Z0JBQ3pCLElBQUksQ0FBQ0ksSUFBSSxHQUFHO2dCQUNaLE9BQU8sSUFBSTtZQUNmO1lBQ0EseUJBQXlCO1lBQ3pCLElBQUksQ0FBQ3NELElBQUksR0FBR0osYUFBYUMsR0FBRyxDQUFDLElBQUksQ0FBQzFELElBQUksRUFBRSxJQUFJLENBQUM2RCxJQUFJLENBQUMzRCxJQUFJLEVBQUUsSUFBSSxDQUFDK0QsUUFBUSxDQUFDLElBQUksQ0FBQ0osSUFBSSxDQUFDM0QsSUFBSSxHQUFHLElBQUksQ0FBQzJELElBQUksQ0FBQzdELElBQUksQ0FBQ0ksTUFBTSxHQUFHO1FBQ25IO0lBQ0o7QUFDSjtBQUNBLElBQUksT0FBTzBCLFVBQVUsYUFBYTtJQUM5Qk0sYUFBYXpDLFNBQVMsQ0FBQ21DLE9BQU9DLFFBQVEsQ0FBQyxHQUFHUSxzQkFBc0I1QyxTQUFTLENBQUNtQyxPQUFPQyxRQUFRLENBQUMsR0FDdEY7UUFBYyxPQUFPLElBQUk7SUFBRTtBQUNuQztBQUNBLFNBQVNtQyxZQUFZQyxNQUFNO0lBQ3ZCLElBQUk7UUFDQSxJQUFJMUIsT0FBTzBCLFFBQVFqQztRQUNuQixPQUFPO0lBQ1gsRUFDQSxPQUFPa0MsSUFBSTtRQUNQLE9BQU87SUFDWDtBQUNKO0FBQ0EsU0FBU3JCLFVBQVUvQyxJQUFJLEVBQUVzQixHQUFHO0lBQ3hCLElBQUlBLE9BQU90QixLQUFLSSxNQUFNLEVBQ2xCLE9BQU9rQjtJQUNYLElBQUkrQyxPQUFPckUsS0FBSzRDLE1BQU0sQ0FBQ3RCLE1BQU1QO0lBQzdCLE1BQU9PLE1BQU0rQyxLQUFLbEUsRUFBRSxJQUFJLENBQUNZLE9BQU9zRCxLQUFLckUsSUFBSSxDQUFDd0IsVUFBVSxDQUFDRixNQUFNK0MsS0FBS25FLElBQUksTUFBTSxVQUFVYSxPQUFPLE9BQ3ZGTztJQUNKLE9BQU9BO0FBQ1g7QUFFQSxTQUFTZ0QsaUJBQWlCQyxJQUFJO0lBQzFCLElBQUlGLE9BQU8zRSxPQUFPNkUsS0FBS0MsS0FBSyxDQUFDYixHQUFHLENBQUNmLE1BQU0sQ0FBQzJCLEtBQUtDLEtBQUssQ0FBQ0MsU0FBUyxDQUFDQyxJQUFJLENBQUNDLElBQUksRUFBRUMsTUFBTTtJQUM5RSxJQUFJQyxRQUFRckYsaURBQUdBLENBQUMsU0FBUztRQUFFc0YsT0FBTztRQUFnQkMsTUFBTTtRQUFRekUsT0FBTytEO0lBQUs7SUFDNUUsSUFBSVcsTUFBTXhGLGlEQUFHQSxDQUFDLFFBQVE7UUFDbEJzRixPQUFPO1FBQ1BHLFdBQVcsQ0FBQ0M7WUFDUixJQUFJQSxNQUFNQyxPQUFPLElBQUksSUFBSTtnQkFDckJELE1BQU1FLGNBQWM7Z0JBQ3BCYixLQUFLYyxRQUFRLENBQUM7b0JBQUVDLFNBQVNDLGFBQWFDLEVBQUUsQ0FBQztnQkFBTztnQkFDaERqQixLQUFLa0IsS0FBSztZQUNkLE9BQ0ssSUFBSVAsTUFBTUMsT0FBTyxJQUFJLElBQUk7Z0JBQzFCRCxNQUFNRSxjQUFjO2dCQUNwQk07WUFDSjtRQUNKO1FBQ0FDLFVBQVUsQ0FBQ1Q7WUFDUEEsTUFBTUUsY0FBYztZQUNwQk07UUFDSjtJQUNKLEdBQUdsRyxpREFBR0EsQ0FBQyxTQUFTK0UsS0FBS0MsS0FBSyxDQUFDb0IsTUFBTSxDQUFDLGVBQWUsTUFBTWYsUUFBUSxLQUFLckYsaURBQUdBLENBQUMsVUFBVTtRQUFFc0YsT0FBTztRQUFhZSxNQUFNO0lBQVMsR0FBR3RCLEtBQUtDLEtBQUssQ0FBQ29CLE1BQU0sQ0FBQztJQUM1SSxTQUFTRjtRQUNMLElBQUlqRSxRQUFRLDZCQUE2QlEsSUFBSSxDQUFDNEMsTUFBTXZFLEtBQUs7UUFDekQsSUFBSSxDQUFDbUIsT0FDRDtRQUNKLElBQUksRUFBRStDLEtBQUssRUFBRSxHQUFHRCxNQUFNNUIsWUFBWTZCLE1BQU1iLEdBQUcsQ0FBQ2YsTUFBTSxDQUFDNEIsTUFBTUMsU0FBUyxDQUFDQyxJQUFJLENBQUNDLElBQUk7UUFDNUUsSUFBSSxHQUFHbUIsTUFBTUMsSUFBSUMsSUFBSUMsUUFBUSxHQUFHeEU7UUFDaEMsSUFBSXlFLE1BQU1GLEtBQUssQ0FBQ0EsR0FBRzdDLEtBQUssQ0FBQyxLQUFLO1FBQzlCLElBQUlrQixPQUFPMEIsS0FBSyxDQUFDQSxLQUFLcEQsVUFBVWlDLE1BQU07UUFDdEMsSUFBSW1CLE1BQU1FLFNBQVM7WUFDZixJQUFJRSxLQUFLOUIsT0FBTztZQUNoQixJQUFJeUIsTUFDQUssS0FBS0EsS0FBTUwsQ0FBQUEsUUFBUSxNQUFNLENBQUMsSUFBSSxLQUFNbkQsVUFBVWlDLE1BQU0sR0FBR0osTUFBTWIsR0FBRyxDQUFDeUMsS0FBSztZQUMxRS9CLE9BQU9nQyxLQUFLQyxLQUFLLENBQUM5QixNQUFNYixHQUFHLENBQUN5QyxLQUFLLEdBQUdEO1FBQ3hDLE9BQ0ssSUFBSUosTUFBTUQsTUFBTTtZQUNqQnpCLE9BQU9BLE9BQVF5QixDQUFBQSxRQUFRLE1BQU0sQ0FBQyxJQUFJLEtBQUtuRCxVQUFVaUMsTUFBTTtRQUMzRDtRQUNBLElBQUkyQixVQUFVL0IsTUFBTWIsR0FBRyxDQUFDVSxJQUFJLENBQUNnQyxLQUFLRyxHQUFHLENBQUMsR0FBR0gsS0FBS0ksR0FBRyxDQUFDakMsTUFBTWIsR0FBRyxDQUFDeUMsS0FBSyxFQUFFL0I7UUFDbkUsSUFBSUksWUFBWXpGLDhEQUFlQSxDQUFDMEgsTUFBTSxDQUFDSCxRQUFRckcsSUFBSSxHQUFHbUcsS0FBS0csR0FBRyxDQUFDLEdBQUdILEtBQUtJLEdBQUcsQ0FBQ1AsS0FBS0ssUUFBUW5HLE1BQU07UUFDOUZtRSxLQUFLYyxRQUFRLENBQUM7WUFDVkMsU0FBUztnQkFBQ0MsYUFBYUMsRUFBRSxDQUFDO2dCQUFRbEgsd0RBQVVBLENBQUNxSSxjQUFjLENBQUNsQyxVQUFVdkUsSUFBSSxFQUFFO29CQUFFMEcsR0FBRztnQkFBUzthQUFHO1lBQzdGbkM7UUFDSjtRQUNBRixLQUFLa0IsS0FBSztJQUNkO0lBQ0EsT0FBTztRQUFFVDtJQUFJO0FBQ2pCO0FBQ0EsTUFBTU8sZUFBZSxXQUFXLEdBQUV6RywwREFBV0EsQ0FBQytILE1BQU07QUFDcEQsTUFBTUMsY0FBYyxXQUFXLEdBQUUvSCx5REFBVUEsQ0FBQzhILE1BQU0sQ0FBQztJQUMvQ0U7UUFBVyxPQUFPO0lBQU07SUFDeEJDLFFBQU8xRyxLQUFLLEVBQUUyRyxFQUFFO1FBQ1osS0FBSyxJQUFJQyxLQUFLRCxHQUFHM0IsT0FBTyxDQUNwQixJQUFJNEIsRUFBRUMsRUFBRSxDQUFDNUIsZUFDTGpGLFFBQVE0RyxFQUFFNUcsS0FBSztRQUN2QixPQUFPQTtJQUNYO0lBQ0E4RyxTQUFTQyxDQUFBQSxJQUFLaEosdURBQVNBLENBQUM2QixJQUFJLENBQUNtSCxHQUFHQyxDQUFBQSxNQUFPQSxNQUFNaEQsbUJBQW1CO0FBQ3BFO0FBQ0E7Ozs7Ozs7O0FBUUEsR0FDQSxNQUFNaUQsV0FBV2hELENBQUFBO0lBQ2IsSUFBSWlELFFBQVFqSiwwREFBUUEsQ0FBQ2dHLE1BQU1EO0lBQzNCLElBQUksQ0FBQ2tELE9BQU87UUFDUixJQUFJbEMsVUFBVTtZQUFDQyxhQUFhQyxFQUFFLENBQUM7U0FBTTtRQUNyQyxJQUFJakIsS0FBS0MsS0FBSyxDQUFDaUQsS0FBSyxDQUFDWCxhQUFhLFVBQVUsTUFDeEN4QixRQUFRekQsSUFBSSxDQUFDL0MsMERBQVdBLENBQUM0SSxZQUFZLENBQUNsQyxFQUFFLENBQUM7WUFBQ3NCO1lBQWFhO1NBQVk7UUFDdkVwRCxLQUFLYyxRQUFRLENBQUM7WUFBRUM7UUFBUTtRQUN4QmtDLFFBQVFqSiwwREFBUUEsQ0FBQ2dHLE1BQU1EO0lBQzNCO0lBQ0EsSUFBSWtELE9BQ0FBLE1BQU14QyxHQUFHLENBQUM0QyxhQUFhLENBQUMsU0FBU0MsTUFBTTtJQUMzQyxPQUFPO0FBQ1g7QUFDQSxNQUFNRixjQUFjLFdBQVcsR0FBRXJKLHdEQUFVQSxDQUFDd0osU0FBUyxDQUFDO0lBQ2xELHlCQUF5QjtRQUNyQkMsU0FBUztRQUNULFdBQVc7WUFBRUMsVUFBVTtRQUFNO0lBQ2pDO0FBQ0o7QUFFQSxNQUFNQywwQkFBMEI7SUFDNUJDLDJCQUEyQjtJQUMzQkMsb0JBQW9CO0lBQ3BCQyxZQUFZO0lBQ1pDLFlBQVk7QUFDaEI7QUFDQSxNQUFNQyxrQkFBa0IsV0FBVyxHQUFFckosb0RBQUtBLENBQUM0SCxNQUFNLENBQUM7SUFDOUMwQixTQUFRbEcsT0FBTztRQUNYLE9BQU9uRCxnRUFBYUEsQ0FBQ21ELFNBQVM0Rix5QkFBeUI7WUFDbkRDLDJCQUEyQixDQUFDTSxHQUFHQyxJQUFNRCxLQUFLQztZQUMxQ04sb0JBQW9COUIsS0FBS0ksR0FBRztZQUM1QjJCLFlBQVkvQixLQUFLSSxHQUFHO1FBQ3hCO0lBQ0o7QUFDSjtBQUNBOzs7OztBQUtBLEdBQ0EsU0FBU2lDLDBCQUEwQnJHLE9BQU87SUFDdEMsSUFBSXNHLE1BQU07UUFBQ0M7UUFBY0M7S0FBaUI7SUFDMUMsSUFBSXhHLFNBQ0FzRyxJQUFJOUcsSUFBSSxDQUFDeUcsZ0JBQWdCOUMsRUFBRSxDQUFDbkQ7SUFDaEMsT0FBT3NHO0FBQ1g7QUFDQSxNQUFNRyxZQUFZLFdBQVcsR0FBRXRLLHdEQUFVQSxDQUFDdUssSUFBSSxDQUFDO0lBQUVqRSxPQUFPO0FBQW9CO0FBQzVFLE1BQU1rRSxnQkFBZ0IsV0FBVyxHQUFFeEssd0RBQVVBLENBQUN1SyxJQUFJLENBQUM7SUFBRWpFLE9BQU87QUFBMkM7QUFDdkcsc0ZBQXNGO0FBQ3RGLFNBQVNtRSxxQkFBcUJDLEtBQUssRUFBRTFFLEtBQUssRUFBRXRFLElBQUksRUFBRUMsRUFBRTtJQUNoRCxPQUFPLENBQUNELFFBQVEsS0FBS2dKLE1BQU0xRSxNQUFNMkUsUUFBUSxDQUFDakosT0FBTyxHQUFHQSxVQUFVZiwyREFBWUEsQ0FBQ2lLLElBQUksS0FDMUVqSixDQUFBQSxNQUFNcUUsTUFBTWIsR0FBRyxDQUFDdkQsTUFBTSxJQUFJOEksTUFBTTFFLE1BQU0yRSxRQUFRLENBQUNoSixJQUFJQSxLQUFLLE9BQU9oQiwyREFBWUEsQ0FBQ2lLLElBQUk7QUFDekY7QUFDQSw2RUFBNkU7QUFDN0UsU0FBU0MsV0FBV0gsS0FBSyxFQUFFMUUsS0FBSyxFQUFFdEUsSUFBSSxFQUFFQyxFQUFFO0lBQ3RDLE9BQU8rSSxNQUFNMUUsTUFBTTJFLFFBQVEsQ0FBQ2pKLE1BQU1BLE9BQU8sT0FBT2YsMkRBQVlBLENBQUNpSyxJQUFJLElBQzFERixNQUFNMUUsTUFBTTJFLFFBQVEsQ0FBQ2hKLEtBQUssR0FBR0EsUUFBUWhCLDJEQUFZQSxDQUFDaUssSUFBSTtBQUNqRTtBQUNBLE1BQU1QLG1CQUFtQixXQUFXLEdBQUVwSyx3REFBVUEsQ0FBQzZLLFNBQVMsQ0FBQztJQUN2RHZKLFlBQVl3RSxJQUFJLENBQUU7UUFDZCxJQUFJLENBQUNnRixXQUFXLEdBQUcsSUFBSSxDQUFDQyxPQUFPLENBQUNqRjtJQUNwQztJQUNBeUMsT0FBT0EsTUFBTSxFQUFFO1FBQ1gsSUFBSUEsT0FBT3lDLFlBQVksSUFBSXpDLE9BQU8wQyxVQUFVLElBQUkxQyxPQUFPMkMsZUFBZSxFQUNsRSxJQUFJLENBQUNKLFdBQVcsR0FBRyxJQUFJLENBQUNDLE9BQU8sQ0FBQ3hDLE9BQU96QyxJQUFJO0lBQ25EO0lBQ0FpRixRQUFRakYsSUFBSSxFQUFFO1FBQ1YsSUFBSXFGLE9BQU9yRixLQUFLQyxLQUFLLENBQUNxRixLQUFLLENBQUN2QjtRQUM1QixJQUFJLEVBQUU5RCxLQUFLLEVBQUUsR0FBR0QsTUFBTXVGLE1BQU10RixNQUFNQyxTQUFTO1FBQzNDLElBQUlxRixJQUFJQyxNQUFNLENBQUMzSixNQUFNLEdBQUcsR0FDcEIsT0FBTzVCLHdEQUFVQSxDQUFDd0wsSUFBSTtRQUMxQixJQUFJQyxRQUFRSCxJQUFJcEYsSUFBSSxFQUFFekUsT0FBT2lKLFFBQVE7UUFDckMsSUFBSWUsTUFBTWpJLEtBQUssRUFBRTtZQUNiLElBQUksQ0FBQzRILEtBQUsxQix5QkFBeUIsRUFDL0IsT0FBTzFKLHdEQUFVQSxDQUFDd0wsSUFBSTtZQUMxQixJQUFJRSxPQUFPMUYsTUFBTTJGLE1BQU0sQ0FBQ0YsTUFBTXRGLElBQUk7WUFDbEMsSUFBSSxDQUFDdUYsTUFDRCxPQUFPMUwsd0RBQVVBLENBQUN3TCxJQUFJO1lBQzFCZCxRQUFRMUUsTUFBTTRGLGVBQWUsQ0FBQ0gsTUFBTXRGLElBQUk7WUFDeEMxRSxRQUFRdUUsTUFBTTJFLFFBQVEsQ0FBQ2UsS0FBS2hLLElBQUksRUFBRWdLLEtBQUsvSixFQUFFO1FBQzdDLE9BQ0s7WUFDRCxJQUFJa0ssTUFBTUosTUFBTTlKLEVBQUUsR0FBRzhKLE1BQU0vSixJQUFJO1lBQy9CLElBQUltSyxNQUFNVCxLQUFLekIsa0JBQWtCLElBQUlrQyxNQUFNLEtBQ3ZDLE9BQU83TCx3REFBVUEsQ0FBQ3dMLElBQUk7WUFDMUIsSUFBSUosS0FBS3ZCLFVBQVUsRUFBRTtnQkFDakJwSSxRQUFRdUUsTUFBTTJFLFFBQVEsQ0FBQ2MsTUFBTS9KLElBQUksRUFBRStKLE1BQU05SixFQUFFLEdBQUcsa0RBQWtEO2dCQUNoRytJLFFBQVExRSxNQUFNNEYsZUFBZSxDQUFDSCxNQUFNdEYsSUFBSTtnQkFDeEMsSUFBSSxDQUFFc0UsQ0FBQUEscUJBQXFCQyxPQUFPMUUsT0FBT3lGLE1BQU0vSixJQUFJLEVBQUUrSixNQUFNOUosRUFBRSxLQUN0RGtKLFdBQVdILE9BQU8xRSxPQUFPeUYsTUFBTS9KLElBQUksRUFBRStKLE1BQU05SixFQUFFLElBQ2hELE9BQU8zQix3REFBVUEsQ0FBQ3dMLElBQUk7WUFDOUIsT0FDSztnQkFDRC9KLFFBQVF1RSxNQUFNMkUsUUFBUSxDQUFDYyxNQUFNL0osSUFBSSxFQUFFK0osTUFBTTlKLEVBQUUsRUFBRW1LLElBQUk7Z0JBQ2pELElBQUksQ0FBQ3JLLE9BQ0QsT0FBT3pCLHdEQUFVQSxDQUFDd0wsSUFBSTtZQUM5QjtRQUNKO1FBQ0EsSUFBSU8sT0FBTyxFQUFFO1FBQ2IsS0FBSyxJQUFJQyxRQUFRakcsS0FBS2tHLGFBQWEsQ0FBRTtZQUNqQyxJQUFJL0QsU0FBUyxJQUFJNUcsYUFBYTBFLE1BQU1iLEdBQUcsRUFBRTFELE9BQU91SyxLQUFLdEssSUFBSSxFQUFFc0ssS0FBS3JLLEVBQUU7WUFDbEUsTUFBTyxDQUFDdUcsT0FBTzNGLElBQUksR0FBR1IsSUFBSSxDQUFFO2dCQUN4QixJQUFJLEVBQUVMLElBQUksRUFBRUMsRUFBRSxFQUFFLEdBQUd1RyxPQUFPcEcsS0FBSztnQkFDL0IsSUFBSSxDQUFDNEksU0FBU0QscUJBQXFCQyxPQUFPMUUsT0FBT3RFLE1BQU1DLEtBQUs7b0JBQ3hELElBQUk4SixNQUFNakksS0FBSyxJQUFJOUIsUUFBUStKLE1BQU0vSixJQUFJLElBQUlDLE1BQU04SixNQUFNOUosRUFBRSxFQUNuRG9LLEtBQUsxSSxJQUFJLENBQUNtSCxjQUFjaUIsS0FBSyxDQUFDL0osTUFBTUM7eUJBQ25DLElBQUlELFFBQVErSixNQUFNOUosRUFBRSxJQUFJQSxNQUFNOEosTUFBTS9KLElBQUksRUFDekNxSyxLQUFLMUksSUFBSSxDQUFDaUgsVUFBVW1CLEtBQUssQ0FBQy9KLE1BQU1DO29CQUNwQyxJQUFJb0ssS0FBS25LLE1BQU0sR0FBR3dKLEtBQUt4QixVQUFVLEVBQzdCLE9BQU81Six3REFBVUEsQ0FBQ3dMLElBQUk7Z0JBQzlCO1lBQ0o7UUFDSjtRQUNBLE9BQU94TCx3REFBVUEsQ0FBQ3VGLEdBQUcsQ0FBQ3dHO0lBQzFCO0FBQ0osR0FBRztJQUNDaEIsYUFBYW1CLENBQUFBLElBQUtBLEVBQUVuQixXQUFXO0FBQ25DO0FBQ0EsTUFBTVgsZUFBZSxXQUFXLEdBQUV0Syx3REFBVUEsQ0FBQ3dKLFNBQVMsQ0FBQztJQUNuRCxzQkFBc0I7UUFBRTZDLGlCQUFpQjtJQUFZO0lBQ3JELHNDQUFzQztRQUFFQSxpQkFBaUI7SUFBYztBQUMzRTtBQUNBLHVDQUF1QztBQUN2QyxNQUFNQyxhQUFhLENBQUMsRUFBRXBHLEtBQUssRUFBRWEsUUFBUSxFQUFFO0lBQ25DLElBQUksRUFBRVosU0FBUyxFQUFFLEdBQUdEO0lBQ3BCLElBQUlxRyxTQUFTN0wsOERBQWVBLENBQUMrSCxNQUFNLENBQUN0QyxVQUFVc0YsTUFBTSxDQUFDZSxHQUFHLENBQUNiLENBQUFBLFFBQVN6RixNQUFNMkYsTUFBTSxDQUFDRixNQUFNdEYsSUFBSSxLQUFLM0YsOERBQWVBLENBQUMwSCxNQUFNLENBQUN1RCxNQUFNdEYsSUFBSSxJQUFJRixVQUFVc0csU0FBUztJQUN0SixJQUFJRixPQUFPRyxFQUFFLENBQUN2RyxZQUNWLE9BQU87SUFDWFksU0FBU2IsTUFBTXdDLE1BQU0sQ0FBQztRQUFFdkMsV0FBV29HO0lBQU87SUFDMUMsT0FBTztBQUNYO0FBQ0EscUVBQXFFO0FBQ3JFLDZDQUE2QztBQUM3QyxTQUFTSSxtQkFBbUJ6RyxLQUFLLEVBQUV2RSxLQUFLO0lBQ3BDLElBQUksRUFBRXlFLElBQUksRUFBRXFGLE1BQU0sRUFBRSxHQUFHdkYsTUFBTUMsU0FBUztJQUN0QyxJQUFJeUYsT0FBTzFGLE1BQU0yRixNQUFNLENBQUN6RixLQUFLQyxJQUFJLEdBQUd1RyxXQUFXaEIsUUFBUUEsS0FBS2hLLElBQUksSUFBSXdFLEtBQUt4RSxJQUFJLElBQUlnSyxLQUFLL0osRUFBRSxJQUFJdUUsS0FBS3ZFLEVBQUU7SUFDbkcsSUFBSyxJQUFJZ0wsU0FBUyxPQUFPekUsU0FBUyxJQUFJNUcsYUFBYTBFLE1BQU1iLEdBQUcsRUFBRTFELE9BQU84SixNQUFNLENBQUNBLE9BQU8zSixNQUFNLEdBQUcsRUFBRSxDQUFDRCxFQUFFLElBQUs7UUFDbEd1RyxPQUFPM0YsSUFBSTtRQUNYLElBQUkyRixPQUFPbkcsSUFBSSxFQUFFO1lBQ2IsSUFBSTRLLFFBQ0EsT0FBTztZQUNYekUsU0FBUyxJQUFJNUcsYUFBYTBFLE1BQU1iLEdBQUcsRUFBRTFELE9BQU8sR0FBR29HLEtBQUtHLEdBQUcsQ0FBQyxHQUFHdUQsTUFBTSxDQUFDQSxPQUFPM0osTUFBTSxHQUFHLEVBQUUsQ0FBQ0YsSUFBSSxHQUFHO1lBQzVGaUwsU0FBUztRQUNiLE9BQ0s7WUFDRCxJQUFJQSxVQUFVcEIsT0FBT3FCLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRW5MLElBQUksSUFBSXdHLE9BQU9wRyxLQUFLLENBQUNKLElBQUksR0FDdEQ7WUFDSixJQUFJZ0wsVUFBVTtnQkFDVixJQUFJaEIsT0FBTzFGLE1BQU0yRixNQUFNLENBQUN6RCxPQUFPcEcsS0FBSyxDQUFDSixJQUFJO2dCQUN6QyxJQUFJLENBQUNnSyxRQUFRQSxLQUFLaEssSUFBSSxJQUFJd0csT0FBT3BHLEtBQUssQ0FBQ0osSUFBSSxJQUFJZ0ssS0FBSy9KLEVBQUUsSUFBSXVHLE9BQU9wRyxLQUFLLENBQUNILEVBQUUsRUFDckU7WUFDUjtZQUNBLE9BQU91RyxPQUFPcEcsS0FBSztRQUN2QjtJQUNKO0FBQ0o7QUFDQTs7O0FBR0EsR0FDQSxNQUFNZ0wsdUJBQXVCLENBQUMsRUFBRTlHLEtBQUssRUFBRWEsUUFBUSxFQUFFO0lBQzdDLElBQUksRUFBRTBFLE1BQU0sRUFBRSxHQUFHdkYsTUFBTUMsU0FBUztJQUNoQyxJQUFJc0YsT0FBT3FCLElBQUksQ0FBQ3RCLENBQUFBLE1BQU9BLElBQUk1SixJQUFJLEtBQUs0SixJQUFJM0osRUFBRSxHQUN0QyxPQUFPeUssV0FBVztRQUFFcEc7UUFBT2E7SUFBUztJQUN4QyxJQUFJa0csZUFBZS9HLE1BQU0yRSxRQUFRLENBQUNZLE1BQU0sQ0FBQyxFQUFFLENBQUM3SixJQUFJLEVBQUU2SixNQUFNLENBQUMsRUFBRSxDQUFDNUosRUFBRTtJQUM5RCxJQUFJcUUsTUFBTUMsU0FBUyxDQUFDc0YsTUFBTSxDQUFDcUIsSUFBSSxDQUFDQyxDQUFBQSxJQUFLN0csTUFBTTJFLFFBQVEsQ0FBQ2tDLEVBQUVuTCxJQUFJLEVBQUVtTCxFQUFFbEwsRUFBRSxLQUFLb0wsZUFDakUsT0FBTztJQUNYLElBQUl0QixRQUFRZ0IsbUJBQW1CekcsT0FBTytHO0lBQ3RDLElBQUksQ0FBQ3RCLE9BQ0QsT0FBTztJQUNYNUUsU0FBU2IsTUFBTXdDLE1BQU0sQ0FBQztRQUNsQnZDLFdBQVdELE1BQU1DLFNBQVMsQ0FBQytHLFFBQVEsQ0FBQ3hNLDhEQUFlQSxDQUFDaUwsS0FBSyxDQUFDQSxNQUFNL0osSUFBSSxFQUFFK0osTUFBTTlKLEVBQUUsR0FBRztRQUNqRm1GLFNBQVNoSCx3REFBVUEsQ0FBQ3FJLGNBQWMsQ0FBQ3NELE1BQU05SixFQUFFO0lBQy9DO0lBQ0EsT0FBTztBQUNYO0FBRUEsTUFBTXNMLG9CQUFvQixXQUFXLEdBQUV4TSxvREFBS0EsQ0FBQzRILE1BQU0sQ0FBQztJQUNoRDBCLFNBQVFtRCxPQUFPO1FBQ1gsT0FBT3hNLGdFQUFhQSxDQUFDd00sU0FBUztZQUMxQkMsS0FBSztZQUNMQyxlQUFlO1lBQ2ZDLFNBQVM7WUFDVEMsUUFBUTtZQUNSQyxXQUFXO1lBQ1hDLGFBQWF6SCxDQUFBQSxPQUFRLElBQUkwSCxZQUFZMUg7WUFDckMySCxlQUFlakMsQ0FBQUEsUUFBUzNMLHdEQUFVQSxDQUFDcUksY0FBYyxDQUFDc0Q7UUFDdEQ7SUFDSjtBQUNKO0FBQ0E7Ozs7O0FBS0EsR0FDQSxTQUFTa0MsT0FBT0MsTUFBTTtJQUNsQixPQUFPQSxTQUFTO1FBQUNYLGtCQUFrQmpHLEVBQUUsQ0FBQzRHO1FBQVNDO0tBQWlCLEdBQUdBO0FBQ3ZFO0FBQ0E7O0FBRUEsR0FDQSxNQUFNQztJQUNGOztJQUVBLEdBQ0F2TSxZQUFZcU0sTUFBTSxDQUFFO1FBQ2hCLElBQUksQ0FBQ0QsTUFBTSxHQUFHQyxPQUFPRCxNQUFNO1FBQzNCLElBQUksQ0FBQ1AsYUFBYSxHQUFHLENBQUMsQ0FBQ1EsT0FBT1IsYUFBYTtRQUMzQyxJQUFJLENBQUNDLE9BQU8sR0FBRyxDQUFDLENBQUNPLE9BQU9QLE9BQU87UUFDL0IsSUFBSSxDQUFDQyxNQUFNLEdBQUcsQ0FBQyxDQUFDTSxPQUFPTixNQUFNO1FBQzdCLElBQUksQ0FBQ1MsT0FBTyxHQUFHSCxPQUFPRyxPQUFPLElBQUk7UUFDakMsSUFBSSxDQUFDQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQ0wsTUFBTSxJQUFLLEVBQUMsSUFBSSxDQUFDTCxNQUFNLElBQUk1SCxZQUFZLElBQUksQ0FBQ2lJLE1BQU07UUFDdEUsSUFBSSxDQUFDTSxRQUFRLEdBQUcsSUFBSSxDQUFDQyxPQUFPLENBQUMsSUFBSSxDQUFDUCxNQUFNO1FBQ3hDLElBQUksQ0FBQ0osU0FBUyxHQUFHLENBQUMsQ0FBQ0ssT0FBT0wsU0FBUztJQUN2QztJQUNBOztJQUVBLEdBQ0FXLFFBQVExTSxJQUFJLEVBQUU7UUFDVixPQUFPLElBQUksQ0FBQzZMLE9BQU8sR0FBRzdMLE9BQ2xCQSxLQUFLdU0sT0FBTyxDQUFDLGdCQUFnQixDQUFDSSxHQUFHQyxLQUFPQSxNQUFNLE1BQU0sT0FBT0EsTUFBTSxNQUFNLE9BQU9BLE1BQU0sTUFBTSxNQUFPO0lBQ3pHO0lBQ0E7O0lBRUEsR0FDQTVCLEdBQUc2QixLQUFLLEVBQUU7UUFDTixPQUFPLElBQUksQ0FBQ1YsTUFBTSxJQUFJVSxNQUFNVixNQUFNLElBQUksSUFBSSxDQUFDSSxPQUFPLElBQUlNLE1BQU1OLE9BQU8sSUFDL0QsSUFBSSxDQUFDWCxhQUFhLElBQUlpQixNQUFNakIsYUFBYSxJQUFJLElBQUksQ0FBQ0UsTUFBTSxJQUFJZSxNQUFNZixNQUFNLElBQ3hFLElBQUksQ0FBQ0MsU0FBUyxJQUFJYyxNQUFNZCxTQUFTO0lBQ3pDO0lBQ0E7O0lBRUEsR0FDQWhGLFNBQVM7UUFDTCxPQUFPLElBQUksQ0FBQytFLE1BQU0sR0FBRyxJQUFJZ0IsWUFBWSxJQUFJLElBQUksSUFBSUMsWUFBWSxJQUFJO0lBQ3JFO0lBQ0E7OztJQUdBLEdBQ0FDLFVBQVV4SSxLQUFLLEVBQUV0RSxPQUFPLENBQUMsRUFBRUMsRUFBRSxFQUFFO1FBQzNCLElBQUk4TSxLQUFLekksTUFBTWIsR0FBRyxHQUFHYSxRQUFRbEYsMERBQVdBLENBQUN5SCxNQUFNLENBQUM7WUFBRXBELEtBQUthO1FBQU07UUFDN0QsSUFBSXJFLE1BQU0sTUFDTkEsS0FBSzhNLEdBQUd0SixHQUFHLENBQUN2RCxNQUFNO1FBQ3RCLE9BQU8sSUFBSSxDQUFDMEwsTUFBTSxHQUFHb0IsYUFBYSxJQUFJLEVBQUVELElBQUkvTSxNQUFNQyxNQUFNZ04sYUFBYSxJQUFJLEVBQUVGLElBQUkvTSxNQUFNQztJQUN6RjtBQUNKO0FBQ0EsTUFBTWlOO0lBQ0ZyTixZQUFZc04sSUFBSSxDQUFFO1FBQ2QsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO0lBQ2hCO0FBQ0o7QUFDQSxTQUFTRixhQUFhRSxJQUFJLEVBQUU3SSxLQUFLLEVBQUV0RSxJQUFJLEVBQUVDLEVBQUU7SUFDdkMsT0FBTyxJQUFJTCxhQUFhMEUsTUFBTWIsR0FBRyxFQUFFMEosS0FBS1osUUFBUSxFQUFFdk0sTUFBTUMsSUFBSWtOLEtBQUt6QixhQUFhLEdBQUcwQixZQUFZek4sQ0FBQUEsSUFBS0EsRUFBRTBOLFdBQVcsSUFBSUYsS0FBS3RCLFNBQVMsR0FBR3lCLGVBQWVoSixNQUFNYixHQUFHLEVBQUVhLE1BQU00RixlQUFlLENBQUM1RixNQUFNQyxTQUFTLENBQUNDLElBQUksQ0FBQ0MsSUFBSSxLQUFLMkk7QUFDdE47QUFDQSxTQUFTRSxlQUFlN0osR0FBRyxFQUFFOEosV0FBVztJQUNwQyxPQUFPLENBQUN2TixNQUFNQyxJQUFJdU4sS0FBS0M7UUFDbkIsSUFBSUEsU0FBU3pOLFFBQVF5TixTQUFTRCxJQUFJdE4sTUFBTSxHQUFHRCxJQUFJO1lBQzNDd04sU0FBU3RILEtBQUtHLEdBQUcsQ0FBQyxHQUFHdEcsT0FBTztZQUM1QndOLE1BQU0vSixJQUFJRyxXQUFXLENBQUM2SixRQUFRdEgsS0FBS0ksR0FBRyxDQUFDOUMsSUFBSXZELE1BQU0sRUFBRUQsS0FBSztRQUM1RDtRQUNBLE9BQU8sQ0FBQ3NOLFlBQVlHLFdBQVdGLEtBQUt4TixPQUFPeU4sWUFBWXhPLDJEQUFZQSxDQUFDaUssSUFBSSxJQUNwRXFFLFlBQVlJLFVBQVVILEtBQUt4TixPQUFPeU4sWUFBWXhPLDJEQUFZQSxDQUFDaUssSUFBSSxLQUM5RHFFLENBQUFBLFlBQVlJLFVBQVVILEtBQUt2TixLQUFLd04sWUFBWXhPLDJEQUFZQSxDQUFDaUssSUFBSSxJQUMxRHFFLFlBQVlHLFdBQVdGLEtBQUt2TixLQUFLd04sWUFBWXhPLDJEQUFZQSxDQUFDaUssSUFBSTtJQUMxRTtBQUNKO0FBQ0EsTUFBTTJELG9CQUFvQks7SUFDdEJyTixZQUFZc04sSUFBSSxDQUFFO1FBQ2QsS0FBSyxDQUFDQTtJQUNWO0lBQ0FTLFVBQVV0SixLQUFLLEVBQUV1SixPQUFPLEVBQUVDLEtBQUssRUFBRTtRQUM3QixJQUFJdEgsU0FBU3lHLGFBQWEsSUFBSSxDQUFDRSxJQUFJLEVBQUU3SSxPQUFPd0osT0FBT3hKLE1BQU1iLEdBQUcsQ0FBQ3ZELE1BQU0sRUFBRWEsZUFBZTtRQUNwRixJQUFJeUYsT0FBT25HLElBQUksRUFDWG1HLFNBQVN5RyxhQUFhLElBQUksQ0FBQ0UsSUFBSSxFQUFFN0ksT0FBTyxHQUFHdUosU0FBUzlNLGVBQWU7UUFDdkUsT0FBT3lGLE9BQU9uRyxJQUFJLEdBQUcsT0FBT21HLE9BQU9wRyxLQUFLO0lBQzVDO0lBQ0EsdUVBQXVFO0lBQ3ZFLHNEQUFzRDtJQUN0RDJOLGlCQUFpQnpKLEtBQUssRUFBRXRFLElBQUksRUFBRUMsRUFBRSxFQUFFO1FBQzlCLElBQUssSUFBSW1CLE1BQU1uQixLQUFNO1lBQ2pCLElBQUlnQixRQUFRa0YsS0FBS0csR0FBRyxDQUFDdEcsTUFBTW9CLE1BQU0sTUFBTSxzQkFBc0IsTUFBSyxJQUFJLENBQUMrTCxJQUFJLENBQUNaLFFBQVEsQ0FBQ3JNLE1BQU07WUFDM0YsSUFBSXNHLFNBQVN5RyxhQUFhLElBQUksQ0FBQ0UsSUFBSSxFQUFFN0ksT0FBT3JELE9BQU9HLE1BQU0ySSxRQUFRO1lBQ2pFLE1BQU8sQ0FBQ3ZELE9BQU96RixlQUFlLEdBQUdWLElBQUksQ0FDakMwSixRQUFRdkQsT0FBT3BHLEtBQUs7WUFDeEIsSUFBSTJKLE9BQ0EsT0FBT0E7WUFDWCxJQUFJOUksU0FBU2pCLE1BQ1QsT0FBTztZQUNYb0IsT0FBTyxNQUFNLHNCQUFzQjtRQUN2QztJQUNKO0lBQ0E0TSxVQUFVMUosS0FBSyxFQUFFdUosT0FBTyxFQUFFQyxLQUFLLEVBQUU7UUFDN0IsT0FBTyxJQUFJLENBQUNDLGdCQUFnQixDQUFDekosT0FBTyxHQUFHdUosWUFDbkMsSUFBSSxDQUFDRSxnQkFBZ0IsQ0FBQ3pKLE9BQU93SixPQUFPeEosTUFBTWIsR0FBRyxDQUFDdkQsTUFBTTtJQUM1RDtJQUNBK04sZUFBZUMsT0FBTyxFQUFFO1FBQUUsT0FBTyxJQUFJLENBQUNmLElBQUksQ0FBQ1gsT0FBTyxDQUFDLElBQUksQ0FBQ1csSUFBSSxDQUFDZCxPQUFPO0lBQUc7SUFDdkU4QixTQUFTN0osS0FBSyxFQUFFOEosS0FBSyxFQUFFO1FBQ25CLElBQUk1SCxTQUFTeUcsYUFBYSxJQUFJLENBQUNFLElBQUksRUFBRTdJLE9BQU8sR0FBR0EsTUFBTWIsR0FBRyxDQUFDdkQsTUFBTSxHQUFHMkosU0FBUyxFQUFFO1FBQzdFLE1BQU8sQ0FBQ3JELE9BQU8zRixJQUFJLEdBQUdSLElBQUksQ0FBRTtZQUN4QixJQUFJd0osT0FBTzNKLE1BQU0sSUFBSWtPLE9BQ2pCLE9BQU87WUFDWHZFLE9BQU9sSSxJQUFJLENBQUM2RSxPQUFPcEcsS0FBSztRQUM1QjtRQUNBLE9BQU95SjtJQUNYO0lBQ0F3RSxVQUFVL0osS0FBSyxFQUFFdEUsSUFBSSxFQUFFQyxFQUFFLEVBQUVxTyxHQUFHLEVBQUU7UUFDNUIsSUFBSTlILFNBQVN5RyxhQUFhLElBQUksQ0FBQ0UsSUFBSSxFQUFFN0ksT0FBTzZCLEtBQUtHLEdBQUcsQ0FBQyxHQUFHdEcsT0FBTyxJQUFJLENBQUNtTixJQUFJLENBQUNaLFFBQVEsQ0FBQ3JNLE1BQU0sR0FBR2lHLEtBQUtJLEdBQUcsQ0FBQ3RHLEtBQUssSUFBSSxDQUFDa04sSUFBSSxDQUFDWixRQUFRLENBQUNyTSxNQUFNLEVBQUVvRSxNQUFNYixHQUFHLENBQUN2RCxNQUFNO1FBQ3BKLE1BQU8sQ0FBQ3NHLE9BQU8zRixJQUFJLEdBQUdSLElBQUksQ0FDdEJpTyxJQUFJOUgsT0FBT3BHLEtBQUssQ0FBQ0osSUFBSSxFQUFFd0csT0FBT3BHLEtBQUssQ0FBQ0gsRUFBRTtJQUM5QztBQUNKO0FBQ0EsU0FBUytNLGFBQWFHLElBQUksRUFBRTdJLEtBQUssRUFBRXRFLElBQUksRUFBRUMsRUFBRTtJQUN2QyxPQUFPLElBQUlpQyxhQUFhb0MsTUFBTWIsR0FBRyxFQUFFMEosS0FBS2xCLE1BQU0sRUFBRTtRQUM1Q3pKLFlBQVksQ0FBQzJLLEtBQUt6QixhQUFhO1FBQy9CdkwsTUFBTWdOLEtBQUt0QixTQUFTLEdBQUcwQyxlQUFlakssTUFBTTRGLGVBQWUsQ0FBQzVGLE1BQU1DLFNBQVMsQ0FBQ0MsSUFBSSxDQUFDQyxJQUFJLEtBQUsySTtJQUM5RixHQUFHcE4sTUFBTUM7QUFDYjtBQUNBLFNBQVN5TixXQUFXMU0sR0FBRyxFQUFFUSxLQUFLO0lBQzFCLE9BQU9SLElBQUlpQyxLQUFLLENBQUM1RCxtRUFBZ0JBLENBQUMyQixLQUFLUSxPQUFPLFFBQVFBO0FBQzFEO0FBQ0EsU0FBU21NLFVBQVUzTSxHQUFHLEVBQUVRLEtBQUs7SUFDekIsT0FBT1IsSUFBSWlDLEtBQUssQ0FBQ3pCLE9BQU9uQyxtRUFBZ0JBLENBQUMyQixLQUFLUTtBQUNsRDtBQUNBLFNBQVMrTSxlQUFlaEIsV0FBVztJQUMvQixPQUFPLENBQUNpQixPQUFPQyxLQUFLbE4sUUFBVSxDQUFDQSxLQUFLLENBQUMsRUFBRSxDQUFDckIsTUFBTSxJQUMxQyxDQUFDcU4sWUFBWUcsV0FBV25NLE1BQU1vRCxLQUFLLEVBQUVwRCxNQUFNQyxLQUFLLE1BQU12QywyREFBWUEsQ0FBQ2lLLElBQUksSUFDbkVxRSxZQUFZSSxVQUFVcE0sTUFBTW9ELEtBQUssRUFBRXBELE1BQU1DLEtBQUssTUFBTXZDLDJEQUFZQSxDQUFDaUssSUFBSSxLQUNwRXFFLENBQUFBLFlBQVlJLFVBQVVwTSxNQUFNb0QsS0FBSyxFQUFFcEQsTUFBTUMsS0FBSyxHQUFHRCxLQUFLLENBQUMsRUFBRSxDQUFDckIsTUFBTSxNQUFNakIsMkRBQVlBLENBQUNpSyxJQUFJLElBQ3BGcUUsWUFBWUcsV0FBV25NLE1BQU1vRCxLQUFLLEVBQUVwRCxNQUFNQyxLQUFLLEdBQUdELEtBQUssQ0FBQyxFQUFFLENBQUNyQixNQUFNLE1BQU1qQiwyREFBWUEsQ0FBQ2lLLElBQUk7QUFDeEc7QUFDQSxNQUFNMEQsb0JBQW9CTTtJQUN0QlUsVUFBVXRKLEtBQUssRUFBRXVKLE9BQU8sRUFBRUMsS0FBSyxFQUFFO1FBQzdCLElBQUl0SCxTQUFTd0csYUFBYSxJQUFJLENBQUNHLElBQUksRUFBRTdJLE9BQU93SixPQUFPeEosTUFBTWIsR0FBRyxDQUFDdkQsTUFBTSxFQUFFVyxJQUFJO1FBQ3pFLElBQUkyRixPQUFPbkcsSUFBSSxFQUNYbUcsU0FBU3dHLGFBQWEsSUFBSSxDQUFDRyxJQUFJLEVBQUU3SSxPQUFPLEdBQUd1SixTQUFTaE4sSUFBSTtRQUM1RCxPQUFPMkYsT0FBT25HLElBQUksR0FBRyxPQUFPbUcsT0FBT3BHLEtBQUs7SUFDNUM7SUFDQTJOLGlCQUFpQnpKLEtBQUssRUFBRXRFLElBQUksRUFBRUMsRUFBRSxFQUFFO1FBQzlCLElBQUssSUFBSXlPLE9BQU8sSUFBSUEsT0FBUTtZQUN4QixJQUFJek4sUUFBUWtGLEtBQUtHLEdBQUcsQ0FBQ3RHLE1BQU1DLEtBQUt5TyxPQUFPLE1BQU0sc0JBQXNCO1lBQ25FLElBQUlsSSxTQUFTd0csYUFBYSxJQUFJLENBQUNHLElBQUksRUFBRTdJLE9BQU9yRCxPQUFPaEIsS0FBSzhKLFFBQVE7WUFDaEUsTUFBTyxDQUFDdkQsT0FBTzNGLElBQUksR0FBR1IsSUFBSSxDQUN0QjBKLFFBQVF2RCxPQUFPcEcsS0FBSztZQUN4QixJQUFJMkosU0FBVTlJLENBQUFBLFNBQVNqQixRQUFRK0osTUFBTS9KLElBQUksR0FBR2lCLFFBQVEsRUFBQyxHQUNqRCxPQUFPOEk7WUFDWCxJQUFJOUksU0FBU2pCLE1BQ1QsT0FBTztRQUNmO0lBQ0o7SUFDQWdPLFVBQVUxSixLQUFLLEVBQUV1SixPQUFPLEVBQUVDLEtBQUssRUFBRTtRQUM3QixPQUFPLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUN6SixPQUFPLEdBQUd1SixZQUNuQyxJQUFJLENBQUNFLGdCQUFnQixDQUFDekosT0FBT3dKLE9BQU94SixNQUFNYixHQUFHLENBQUN2RCxNQUFNO0lBQzVEO0lBQ0ErTixlQUFlVSxNQUFNLEVBQUU7UUFDbkIsT0FBTyxJQUFJLENBQUN4QixJQUFJLENBQUNYLE9BQU8sQ0FBQyxJQUFJLENBQUNXLElBQUksQ0FBQ2QsT0FBTyxFQUFFQSxPQUFPLENBQUMsZ0JBQWdCLENBQUN1QyxHQUFHek4sSUFBTUEsS0FBSyxNQUFNLE1BQ25GQSxLQUFLLE1BQU13TixPQUFPcE4sS0FBSyxDQUFDLEVBQUUsR0FDdEJKLEtBQUssT0FBTyxDQUFDQSxJQUFJd04sT0FBT3BOLEtBQUssQ0FBQ3JCLE1BQU0sR0FBR3lPLE9BQU9wTixLQUFLLENBQUNKLEVBQUUsR0FDbER5TjtJQUNsQjtJQUNBVCxTQUFTN0osS0FBSyxFQUFFOEosS0FBSyxFQUFFO1FBQ25CLElBQUk1SCxTQUFTd0csYUFBYSxJQUFJLENBQUNHLElBQUksRUFBRTdJLE9BQU8sR0FBR0EsTUFBTWIsR0FBRyxDQUFDdkQsTUFBTSxHQUFHMkosU0FBUyxFQUFFO1FBQzdFLE1BQU8sQ0FBQ3JELE9BQU8zRixJQUFJLEdBQUdSLElBQUksQ0FBRTtZQUN4QixJQUFJd0osT0FBTzNKLE1BQU0sSUFBSWtPLE9BQ2pCLE9BQU87WUFDWHZFLE9BQU9sSSxJQUFJLENBQUM2RSxPQUFPcEcsS0FBSztRQUM1QjtRQUNBLE9BQU95SjtJQUNYO0lBQ0F3RSxVQUFVL0osS0FBSyxFQUFFdEUsSUFBSSxFQUFFQyxFQUFFLEVBQUVxTyxHQUFHLEVBQUU7UUFDNUIsSUFBSTlILFNBQVN3RyxhQUFhLElBQUksQ0FBQ0csSUFBSSxFQUFFN0ksT0FBTzZCLEtBQUtHLEdBQUcsQ0FBQyxHQUFHdEcsT0FBTyxJQUFJLDBCQUEwQixNQUFLbUcsS0FBS0ksR0FBRyxDQUFDdEcsS0FBSyxJQUFJLDBCQUEwQixLQUFJcUUsTUFBTWIsR0FBRyxDQUFDdkQsTUFBTTtRQUNsSyxNQUFPLENBQUNzRyxPQUFPM0YsSUFBSSxHQUFHUixJQUFJLENBQ3RCaU8sSUFBSTlILE9BQU9wRyxLQUFLLENBQUNKLElBQUksRUFBRXdHLE9BQU9wRyxLQUFLLENBQUNILEVBQUU7SUFDOUM7QUFDSjtBQUNBOzs7Ozs7QUFNQSxHQUNBLE1BQU00TyxpQkFBaUIsV0FBVyxHQUFFalEsMERBQVdBLENBQUMrSCxNQUFNO0FBQ3RELE1BQU1tSSxjQUFjLFdBQVcsR0FBRWxRLDBEQUFXQSxDQUFDK0gsTUFBTTtBQUNuRCxNQUFNb0ksY0FBYyxXQUFXLEdBQUVsUSx5REFBVUEsQ0FBQzhILE1BQU0sQ0FBQztJQUMvQ0UsUUFBT3ZDLEtBQUs7UUFDUixPQUFPLElBQUkwSyxZQUFZQyxhQUFhM0ssT0FBT3VDLE1BQU0sSUFBSTtJQUN6RDtJQUNBQyxRQUFPMUcsS0FBSyxFQUFFMkcsRUFBRTtRQUNaLEtBQUssSUFBSW1JLFVBQVVuSSxHQUFHM0IsT0FBTyxDQUFFO1lBQzNCLElBQUk4SixPQUFPakksRUFBRSxDQUFDNEgsaUJBQ1Z6TyxRQUFRLElBQUk0TyxZQUFZRSxPQUFPOU8sS0FBSyxDQUFDeUcsTUFBTSxJQUFJekcsTUFBTWtILEtBQUs7aUJBQ3pELElBQUk0SCxPQUFPakksRUFBRSxDQUFDNkgsY0FDZjFPLFFBQVEsSUFBSTRPLFlBQVk1TyxNQUFNTCxLQUFLLEVBQUVtUCxPQUFPOU8sS0FBSyxHQUFHK08sb0JBQW9CO1FBQ2hGO1FBQ0EsT0FBTy9PO0lBQ1g7SUFDQThHLFNBQVNDLENBQUFBLElBQUtoSix1REFBU0EsQ0FBQzZCLElBQUksQ0FBQ21ILEdBQUdDLENBQUFBLE1BQU9BLElBQUlFLEtBQUs7QUFDcEQ7QUFDQTs7QUFFQSxHQUNBLFNBQVM4SCxlQUFlOUssS0FBSztJQUN6QixJQUFJK0ssV0FBVy9LLE1BQU1pRCxLQUFLLENBQUN3SCxhQUFhO0lBQ3hDLE9BQU9NLFdBQVdBLFNBQVN0UCxLQUFLLENBQUNvTixJQUFJLEdBQUc4QixhQUFhM0s7QUFDekQ7QUFDQTs7QUFFQSxHQUNBLFNBQVNnTCxnQkFBZ0JoTCxLQUFLO0lBQzFCLElBQUlKO0lBQ0osT0FBTyxDQUFDLENBQUNBLEtBQUtJLE1BQU1pRCxLQUFLLENBQUN3SCxhQUFhLE1BQUssTUFBTyxRQUFRN0ssT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHb0QsS0FBSyxLQUFLO0FBQ3JHO0FBQ0EsTUFBTTBIO0lBQ0ZuUCxZQUFZRSxLQUFLLEVBQUV1SCxLQUFLLENBQUU7UUFDdEIsSUFBSSxDQUFDdkgsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ3VILEtBQUssR0FBR0E7SUFDakI7QUFDSjtBQUNBLE1BQU1pSSxZQUFZLFdBQVcsR0FBRWpSLHdEQUFVQSxDQUFDdUssSUFBSSxDQUFDO0lBQUVqRSxPQUFPO0FBQWlCLElBQUk0SyxvQkFBb0IsV0FBVyxHQUFFbFIsd0RBQVVBLENBQUN1SyxJQUFJLENBQUM7SUFBRWpFLE9BQU87QUFBeUM7QUFDaEwsTUFBTTZLLG9CQUFvQixXQUFXLEdBQUVsUix3REFBVUEsQ0FBQzZLLFNBQVMsQ0FBQztJQUN4RHZKLFlBQVl3RSxJQUFJLENBQUU7UUFDZCxJQUFJLENBQUNBLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNnRixXQUFXLEdBQUcsSUFBSSxDQUFDZ0YsU0FBUyxDQUFDaEssS0FBS0MsS0FBSyxDQUFDaUQsS0FBSyxDQUFDd0g7SUFDdkQ7SUFDQWpJLE9BQU9BLE1BQU0sRUFBRTtRQUNYLElBQUl4QyxRQUFRd0MsT0FBT3hDLEtBQUssQ0FBQ2lELEtBQUssQ0FBQ3dIO1FBQy9CLElBQUl6SyxTQUFTd0MsT0FBTzRJLFVBQVUsQ0FBQ25JLEtBQUssQ0FBQ3dILGdCQUFnQmpJLE9BQU8wQyxVQUFVLElBQUkxQyxPQUFPeUMsWUFBWSxJQUFJekMsT0FBTzJDLGVBQWUsRUFDbkgsSUFBSSxDQUFDSixXQUFXLEdBQUcsSUFBSSxDQUFDZ0YsU0FBUyxDQUFDL0o7SUFDMUM7SUFDQStKLFVBQVUsRUFBRXRPLEtBQUssRUFBRXVILEtBQUssRUFBRSxFQUFFO1FBQ3hCLElBQUksQ0FBQ0EsU0FBUyxDQUFDdkgsTUFBTW9OLElBQUksQ0FBQ2IsS0FBSyxFQUMzQixPQUFPaE8sd0RBQVVBLENBQUN3TCxJQUFJO1FBQzFCLElBQUksRUFBRXpGLElBQUksRUFBRSxHQUFHLElBQUk7UUFDbkIsSUFBSXNMLFVBQVUsSUFBSXpRLDhEQUFlQTtRQUNqQyxJQUFLLElBQUlpQyxJQUFJLEdBQUcwSSxTQUFTeEYsS0FBS2tHLGFBQWEsRUFBRXFGLElBQUkvRixPQUFPM0osTUFBTSxFQUFFaUIsSUFBSXlPLEdBQUd6TyxJQUFLO1lBQ3hFLElBQUksRUFBRW5CLElBQUksRUFBRUMsRUFBRSxFQUFFLEdBQUc0SixNQUFNLENBQUMxSSxFQUFFO1lBQzVCLE1BQU9BLElBQUl5TyxJQUFJLEtBQUszUCxLQUFLNEosTUFBTSxDQUFDMUksSUFBSSxFQUFFLENBQUNuQixJQUFJLEdBQUcsSUFBSSxJQUFJLDBCQUEwQixJQUM1RUMsS0FBSzRKLE1BQU0sQ0FBQyxFQUFFMUksRUFBRSxDQUFDbEIsRUFBRTtZQUN2QkYsTUFBTXNPLFNBQVMsQ0FBQ2hLLEtBQUtDLEtBQUssRUFBRXRFLE1BQU1DLElBQUksQ0FBQ0QsTUFBTUM7Z0JBQ3pDLElBQUk0UCxXQUFXeEwsS0FBS0MsS0FBSyxDQUFDQyxTQUFTLENBQUNzRixNQUFNLENBQUNxQixJQUFJLENBQUNDLENBQUFBLElBQUtBLEVBQUVuTCxJQUFJLElBQUlBLFFBQVFtTCxFQUFFbEwsRUFBRSxJQUFJQTtnQkFDL0UwUCxRQUFRckIsR0FBRyxDQUFDdE8sTUFBTUMsSUFBSTRQLFdBQVdMLG9CQUFvQkQ7WUFDekQ7UUFDSjtRQUNBLE9BQU9JLFFBQVFHLE1BQU07SUFDekI7QUFDSixHQUFHO0lBQ0N6RyxhQUFhbUIsQ0FBQUEsSUFBS0EsRUFBRW5CLFdBQVc7QUFDbkM7QUFDQSxTQUFTMEcsY0FBYzVJLENBQUM7SUFDcEIsT0FBTzlDLENBQUFBO1FBQ0gsSUFBSUMsUUFBUUQsS0FBS0MsS0FBSyxDQUFDaUQsS0FBSyxDQUFDd0gsYUFBYTtRQUMxQyxPQUFPekssU0FBU0EsTUFBTXZFLEtBQUssQ0FBQ29OLElBQUksQ0FBQ2IsS0FBSyxHQUFHbkYsRUFBRTlDLE1BQU1DLFNBQVMwTCxnQkFBZ0IzTDtJQUM5RTtBQUNKO0FBQ0E7Ozs7O0FBS0EsR0FDQSxNQUFNNEwsV0FBVyxXQUFXLEdBQUVGLGNBQWMsQ0FBQzFMLE1BQU0sRUFBRXRFLEtBQUssRUFBRTtJQUN4RCxJQUFJLEVBQUVFLEVBQUUsRUFBRSxHQUFHb0UsS0FBS0MsS0FBSyxDQUFDQyxTQUFTLENBQUNDLElBQUk7SUFDdEMsSUFBSTNELE9BQU9kLE1BQU02TixTQUFTLENBQUN2SixLQUFLQyxLQUFLLEVBQUVyRSxJQUFJQTtJQUMzQyxJQUFJLENBQUNZLE1BQ0QsT0FBTztJQUNYLElBQUkwRCxZQUFZekYsOERBQWVBLENBQUNvUixNQUFNLENBQUNyUCxLQUFLYixJQUFJLEVBQUVhLEtBQUtaLEVBQUU7SUFDekQsSUFBSWlNLFNBQVM3SCxLQUFLQyxLQUFLLENBQUNxRixLQUFLLENBQUM0QjtJQUM5QmxILEtBQUtjLFFBQVEsQ0FBQztRQUNWWjtRQUNBYSxTQUFTO1lBQUMrSyxjQUFjOUwsTUFBTXhEO1lBQU9xTCxPQUFPRixhQUFhLENBQUN6SCxVQUFVQyxJQUFJLEVBQUVIO1NBQU07UUFDaEYrTCxXQUFXO0lBQ2Y7SUFDQUMsa0JBQWtCaE07SUFDbEIsT0FBTztBQUNYO0FBQ0E7Ozs7QUFJQSxHQUNBLE1BQU1pTSxlQUFlLFdBQVcsR0FBRVAsY0FBYyxDQUFDMUwsTUFBTSxFQUFFdEUsS0FBSyxFQUFFO0lBQzVELElBQUksRUFBRXVFLEtBQUssRUFBRSxHQUFHRCxNQUFNLEVBQUVyRSxJQUFJLEVBQUUsR0FBR3NFLE1BQU1DLFNBQVMsQ0FBQ0MsSUFBSTtJQUNyRCxJQUFJK0wsT0FBT3hRLE1BQU1pTyxTQUFTLENBQUMxSixPQUFPdEUsTUFBTUE7SUFDeEMsSUFBSSxDQUFDdVEsTUFDRCxPQUFPO0lBQ1gsSUFBSWhNLFlBQVl6Riw4REFBZUEsQ0FBQ29SLE1BQU0sQ0FBQ0ssS0FBS3ZRLElBQUksRUFBRXVRLEtBQUt0USxFQUFFO0lBQ3pELElBQUlpTSxTQUFTN0gsS0FBS0MsS0FBSyxDQUFDcUYsS0FBSyxDQUFDNEI7SUFDOUJsSCxLQUFLYyxRQUFRLENBQUM7UUFDVlo7UUFDQWEsU0FBUztZQUFDK0ssY0FBYzlMLE1BQU1rTTtZQUFPckUsT0FBT0YsYUFBYSxDQUFDekgsVUFBVUMsSUFBSSxFQUFFSDtTQUFNO1FBQ2hGK0wsV0FBVztJQUNmO0lBQ0FDLGtCQUFrQmhNO0lBQ2xCLE9BQU87QUFDWDtBQUNBOztBQUVBLEdBQ0EsTUFBTW1NLGdCQUFnQixXQUFXLEdBQUVULGNBQWMsQ0FBQzFMLE1BQU0sRUFBRXRFLEtBQUssRUFBRTtJQUM3RCxJQUFJOEosU0FBUzlKLE1BQU1vTyxRQUFRLENBQUM5SixLQUFLQyxLQUFLLEVBQUU7SUFDeEMsSUFBSSxDQUFDdUYsVUFBVSxDQUFDQSxPQUFPM0osTUFBTSxFQUN6QixPQUFPO0lBQ1htRSxLQUFLYyxRQUFRLENBQUM7UUFDVlosV0FBV3pGLDhEQUFlQSxDQUFDK0gsTUFBTSxDQUFDZ0QsT0FBT2UsR0FBRyxDQUFDTyxDQUFBQSxJQUFLck0sOERBQWVBLENBQUNpTCxLQUFLLENBQUNvQixFQUFFbkwsSUFBSSxFQUFFbUwsRUFBRWxMLEVBQUU7UUFDcEZtUSxXQUFXO0lBQ2Y7SUFDQSxPQUFPO0FBQ1g7QUFDQTs7QUFFQSxHQUNBLE1BQU1LLHlCQUF5QixDQUFDLEVBQUVuTSxLQUFLLEVBQUVhLFFBQVEsRUFBRTtJQUMvQyxJQUFJeUUsTUFBTXRGLE1BQU1DLFNBQVM7SUFDekIsSUFBSXFGLElBQUlDLE1BQU0sQ0FBQzNKLE1BQU0sR0FBRyxLQUFLMEosSUFBSXBGLElBQUksQ0FBQzFDLEtBQUssRUFDdkMsT0FBTztJQUNYLElBQUksRUFBRTlCLElBQUksRUFBRUMsRUFBRSxFQUFFLEdBQUcySixJQUFJcEYsSUFBSTtJQUMzQixJQUFJcUYsU0FBUyxFQUFFLEVBQUVyRixPQUFPO0lBQ3hCLElBQUssSUFBSWtNLE1BQU0sSUFBSTlRLGFBQWEwRSxNQUFNYixHQUFHLEVBQUVhLE1BQU0yRSxRQUFRLENBQUNqSixNQUFNQyxNQUFNLENBQUN5USxJQUFJN1AsSUFBSSxHQUFHUixJQUFJLEVBQUc7UUFDckYsSUFBSXdKLE9BQU8zSixNQUFNLEdBQUcsTUFDaEIsT0FBTztRQUNYLElBQUl3USxJQUFJdFEsS0FBSyxDQUFDSixJQUFJLElBQUlBLE1BQ2xCd0UsT0FBT3FGLE9BQU8zSixNQUFNO1FBQ3hCMkosT0FBT2xJLElBQUksQ0FBQzdDLDhEQUFlQSxDQUFDaUwsS0FBSyxDQUFDMkcsSUFBSXRRLEtBQUssQ0FBQ0osSUFBSSxFQUFFMFEsSUFBSXRRLEtBQUssQ0FBQ0gsRUFBRTtJQUNsRTtJQUNBa0YsU0FBU2IsTUFBTXdDLE1BQU0sQ0FBQztRQUNsQnZDLFdBQVd6Riw4REFBZUEsQ0FBQytILE1BQU0sQ0FBQ2dELFFBQVFyRjtRQUMxQzRMLFdBQVc7SUFDZjtJQUNBLE9BQU87QUFDWDtBQUNBOztBQUVBLEdBQ0EsTUFBTU8sY0FBYyxXQUFXLEdBQUVaLGNBQWMsQ0FBQzFMLE1BQU0sRUFBRXRFLEtBQUssRUFBRTtJQUMzRCxJQUFJLEVBQUV1RSxLQUFLLEVBQUUsR0FBR0QsTUFBTSxFQUFFckUsSUFBSSxFQUFFQyxFQUFFLEVBQUUsR0FBR3FFLE1BQU1DLFNBQVMsQ0FBQ0MsSUFBSTtJQUN6RCxJQUFJRixNQUFNc00sUUFBUSxFQUNkLE9BQU87SUFDWCxJQUFJL1AsT0FBT2QsTUFBTTZOLFNBQVMsQ0FBQ3RKLE9BQU90RSxNQUFNQTtJQUN4QyxJQUFJLENBQUNhLE1BQ0QsT0FBTztJQUNYLElBQUlnUSxVQUFVLEVBQUUsRUFBRXRNLFdBQVd1TTtJQUM3QixJQUFJMUwsVUFBVSxFQUFFO0lBQ2hCLElBQUl2RSxLQUFLYixJQUFJLElBQUlBLFFBQVFhLEtBQUtaLEVBQUUsSUFBSUEsSUFBSTtRQUNwQzZRLGNBQWN4TSxNQUFNeU0sTUFBTSxDQUFDaFIsTUFBTWtPLGNBQWMsQ0FBQ3BOO1FBQ2hEZ1EsUUFBUWxQLElBQUksQ0FBQztZQUFFM0IsTUFBTWEsS0FBS2IsSUFBSTtZQUFFQyxJQUFJWSxLQUFLWixFQUFFO1lBQUUrUSxRQUFRRjtRQUFZO1FBQ2pFalEsT0FBT2QsTUFBTTZOLFNBQVMsQ0FBQ3RKLE9BQU96RCxLQUFLYixJQUFJLEVBQUVhLEtBQUtaLEVBQUU7UUFDaERtRixRQUFRekQsSUFBSSxDQUFDdkQsd0RBQVVBLENBQUM2UyxRQUFRLENBQUMzTCxFQUFFLENBQUNoQixNQUFNb0IsTUFBTSxDQUFDLDRCQUE0QnBCLE1BQU1iLEdBQUcsQ0FBQ2YsTUFBTSxDQUFDMUMsTUFBTTBFLE1BQU0sSUFBSTtJQUNsSDtJQUNBLElBQUk3RCxNQUFNO1FBQ04sSUFBSXNDLE1BQU0wTixRQUFRM1EsTUFBTSxJQUFJLEtBQUsyUSxPQUFPLENBQUMsRUFBRSxDQUFDN1EsSUFBSSxJQUFJYSxLQUFLWixFQUFFLEdBQUcsSUFBSVksS0FBS1osRUFBRSxHQUFHWSxLQUFLYixJQUFJLEdBQUc4USxZQUFZNVEsTUFBTTtRQUMxR3FFLFlBQVl6Riw4REFBZUEsQ0FBQ29SLE1BQU0sQ0FBQ3JQLEtBQUtiLElBQUksR0FBR21ELEtBQUt0QyxLQUFLWixFQUFFLEdBQUdrRDtRQUM5RGlDLFFBQVF6RCxJQUFJLENBQUN3TyxjQUFjOUwsTUFBTXhEO1FBQ2pDdUUsUUFBUXpELElBQUksQ0FBQzJDLE1BQU1xRixLQUFLLENBQUM0QixtQkFBbUJTLGFBQWEsQ0FBQ3pILFVBQVVDLElBQUksRUFBRUg7SUFDOUU7SUFDQUEsS0FBS2MsUUFBUSxDQUFDO1FBQ1YwTDtRQUFTdE07UUFBV2E7UUFDcEJnTCxXQUFXO0lBQ2Y7SUFDQSxPQUFPO0FBQ1g7QUFDQTs7O0FBR0EsR0FDQSxNQUFNYyxhQUFhLFdBQVcsR0FBRW5CLGNBQWMsQ0FBQzFMLE1BQU0sRUFBRXRFLEtBQUssRUFBRTtJQUMxRCxJQUFJc0UsS0FBS0MsS0FBSyxDQUFDc00sUUFBUSxFQUNuQixPQUFPO0lBQ1gsSUFBSUMsVUFBVTlRLE1BQU1vTyxRQUFRLENBQUM5SixLQUFLQyxLQUFLLEVBQUUsS0FBS3NHLEdBQUcsQ0FBQ3JKLENBQUFBO1FBQzlDLElBQUksRUFBRXZCLElBQUksRUFBRUMsRUFBRSxFQUFFLEdBQUdzQjtRQUNuQixPQUFPO1lBQUV2QjtZQUFNQztZQUFJK1EsUUFBUWpSLE1BQU1rTyxjQUFjLENBQUMxTTtRQUFPO0lBQzNEO0lBQ0EsSUFBSSxDQUFDc1AsUUFBUTNRLE1BQU0sRUFDZixPQUFPO0lBQ1gsSUFBSWlSLGVBQWU5TSxLQUFLQyxLQUFLLENBQUNvQixNQUFNLENBQUMsc0JBQXNCbUwsUUFBUTNRLE1BQU0sSUFBSTtJQUM3RW1FLEtBQUtjLFFBQVEsQ0FBQztRQUNWMEw7UUFDQXpMLFNBQVNoSCx3REFBVUEsQ0FBQzZTLFFBQVEsQ0FBQzNMLEVBQUUsQ0FBQzZMO1FBQ2hDZixXQUFXO0lBQ2Y7SUFDQSxPQUFPO0FBQ1g7QUFDQSxTQUFTakIsa0JBQWtCOUssSUFBSTtJQUMzQixPQUFPQSxLQUFLQyxLQUFLLENBQUNxRixLQUFLLENBQUM0QixtQkFBbUJPLFdBQVcsQ0FBQ3pIO0FBQzNEO0FBQ0EsU0FBUzRLLGFBQWEzSyxLQUFLLEVBQUU4TSxRQUFRO0lBQ2pDLElBQUlsTixJQUFJbU4sSUFBSUMsSUFBSUMsSUFBSUM7SUFDcEIsSUFBSTVILE1BQU10RixNQUFNQyxTQUFTLENBQUNDLElBQUk7SUFDOUIsSUFBSWlOLFVBQVU3SCxJQUFJOUgsS0FBSyxJQUFJOEgsSUFBSTNKLEVBQUUsR0FBRzJKLElBQUk1SixJQUFJLEdBQUcsTUFBTSxLQUFLc0UsTUFBTTJFLFFBQVEsQ0FBQ1csSUFBSTVKLElBQUksRUFBRTRKLElBQUkzSixFQUFFO0lBQ3pGLElBQUltUixZQUFZLENBQUNLLFNBQ2IsT0FBT0w7SUFDWCxJQUFJbEYsU0FBUzVILE1BQU1xRixLQUFLLENBQUM0QjtJQUN6QixPQUFPLElBQUlhLFlBQVk7UUFDbkJILFFBQVEsQ0FBQyxDQUFDL0gsS0FBS2tOLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTekYsT0FBTyxNQUFNLFFBQVF6SCxPQUFPLEtBQUssSUFBSUEsS0FBS2dJLE9BQU9QLE9BQU8sSUFBSThGLFVBQVVBLFFBQVFwRixPQUFPLENBQUMsT0FBTztRQUN6S1gsZUFBZSxDQUFDMkYsS0FBS0QsYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSSxLQUFLLElBQUlBLFNBQVMxRixhQUFhLE1BQU0sUUFBUTJGLE9BQU8sS0FBSyxJQUFJQSxLQUFLbkYsT0FBT1IsYUFBYTtRQUN0SkMsU0FBUyxDQUFDMkYsS0FBS0YsYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSSxLQUFLLElBQUlBLFNBQVN6RixPQUFPLE1BQU0sUUFBUTJGLE9BQU8sS0FBSyxJQUFJQSxLQUFLcEYsT0FBT1AsT0FBTztRQUNwSUMsUUFBUSxDQUFDMkYsS0FBS0gsYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSSxLQUFLLElBQUlBLFNBQVN4RixNQUFNLE1BQU0sUUFBUTJGLE9BQU8sS0FBSyxJQUFJQSxLQUFLckYsT0FBT04sTUFBTTtRQUNqSUMsV0FBVyxDQUFDMkYsS0FBS0osYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSSxLQUFLLElBQUlBLFNBQVN2RixTQUFTLE1BQU0sUUFBUTJGLE9BQU8sS0FBSyxJQUFJQSxLQUFLdEYsT0FBT0wsU0FBUztJQUM5STtBQUNKO0FBQ0EsU0FBUzZGLGVBQWVyTixJQUFJO0lBQ3hCLElBQUlpRCxRQUFRakosMERBQVFBLENBQUNnRyxNQUFNOEs7SUFDM0IsT0FBTzdILFNBQVNBLE1BQU14QyxHQUFHLENBQUM0QyxhQUFhLENBQUM7QUFDNUM7QUFDQSxTQUFTMkksa0JBQWtCaE0sSUFBSTtJQUMzQixJQUFJTSxRQUFRK00sZUFBZXJOO0lBQzNCLElBQUlNLFNBQVNBLFNBQVNOLEtBQUtzTixJQUFJLENBQUNDLGFBQWEsRUFDekNqTixNQUFNZ0QsTUFBTTtBQUNwQjtBQUNBOztBQUVBLEdBQ0EsTUFBTXFJLGtCQUFrQjNMLENBQUFBO0lBQ3BCLElBQUlDLFFBQVFELEtBQUtDLEtBQUssQ0FBQ2lELEtBQUssQ0FBQ3dILGFBQWE7SUFDMUMsSUFBSXpLLFNBQVNBLE1BQU1nRCxLQUFLLEVBQUU7UUFDdEIsSUFBSXVLLGNBQWNILGVBQWVyTjtRQUNqQyxJQUFJd04sZUFBZUEsZUFBZXhOLEtBQUtzTixJQUFJLENBQUNDLGFBQWEsRUFBRTtZQUN2RCxJQUFJN1IsUUFBUWtQLGFBQWE1SyxLQUFLQyxLQUFLLEVBQUVBLE1BQU12RSxLQUFLLENBQUNvTixJQUFJO1lBQ3JELElBQUlwTixNQUFNdU0sS0FBSyxFQUNYakksS0FBS2MsUUFBUSxDQUFDO2dCQUFFQyxTQUFTeUosZUFBZXZKLEVBQUUsQ0FBQ3ZGO1lBQU87WUFDdEQ4UixZQUFZdE0sS0FBSztZQUNqQnNNLFlBQVlsSyxNQUFNO1FBQ3RCO0lBQ0osT0FDSztRQUNEdEQsS0FBS2MsUUFBUSxDQUFDO1lBQUVDLFNBQVM7Z0JBQ2pCMEosWUFBWXhKLEVBQUUsQ0FBQztnQkFDZmhCLFFBQVF1SyxlQUFldkosRUFBRSxDQUFDMkosYUFBYTVLLEtBQUtDLEtBQUssRUFBRUEsTUFBTXZFLEtBQUssQ0FBQ29OLElBQUksS0FBS3ZPLDBEQUFXQSxDQUFDNEksWUFBWSxDQUFDbEMsRUFBRSxDQUFDNkc7YUFDdkc7UUFBQztJQUNWO0lBQ0EsT0FBTztBQUNYO0FBQ0E7O0FBRUEsR0FDQSxNQUFNMkYsbUJBQW1Cek4sQ0FBQUE7SUFDckIsSUFBSUMsUUFBUUQsS0FBS0MsS0FBSyxDQUFDaUQsS0FBSyxDQUFDd0gsYUFBYTtJQUMxQyxJQUFJLENBQUN6SyxTQUFTLENBQUNBLE1BQU1nRCxLQUFLLEVBQ3RCLE9BQU87SUFDWCxJQUFJQSxRQUFRakosMERBQVFBLENBQUNnRyxNQUFNOEs7SUFDM0IsSUFBSTdILFNBQVNBLE1BQU14QyxHQUFHLENBQUNpTixRQUFRLENBQUMxTixLQUFLc04sSUFBSSxDQUFDQyxhQUFhLEdBQ25Edk4sS0FBS2tCLEtBQUs7SUFDZGxCLEtBQUtjLFFBQVEsQ0FBQztRQUFFQyxTQUFTMEosWUFBWXhKLEVBQUUsQ0FBQztJQUFPO0lBQy9DLE9BQU87QUFDWDtBQUNBOzs7Ozs7OztBQVFBLEdBQ0EsTUFBTTBNLGVBQWU7SUFDakI7UUFBRUMsS0FBSztRQUFTQyxLQUFLbEM7UUFBaUJtQyxPQUFPO0lBQXNCO0lBQ25FO1FBQUVGLEtBQUs7UUFBTUMsS0FBS2pDO1FBQVVtQyxPQUFPOUI7UUFBYzZCLE9BQU87UUFBdUJqTixnQkFBZ0I7SUFBSztJQUNwRztRQUFFK00sS0FBSztRQUFTQyxLQUFLakM7UUFBVW1DLE9BQU85QjtRQUFjNkIsT0FBTztRQUF1QmpOLGdCQUFnQjtJQUFLO0lBQ3ZHO1FBQUUrTSxLQUFLO1FBQVVDLEtBQUtKO1FBQWtCSyxPQUFPO0lBQXNCO0lBQ3JFO1FBQUVGLEtBQUs7UUFBZUMsS0FBS3pCO0lBQXVCO0lBQ2xEO1FBQUV3QixLQUFLO1FBQWFDLEtBQUs3SztJQUFTO0lBQ2xDO1FBQUU0SyxLQUFLO1FBQVNDLEtBQUs5RztRQUFzQmxHLGdCQUFnQjtJQUFLO0NBQ25FO0FBQ0QsTUFBTTZHO0lBQ0ZsTSxZQUFZd0UsSUFBSSxDQUFFO1FBQ2QsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO1FBQ1osSUFBSXRFLFFBQVEsSUFBSSxDQUFDQSxLQUFLLEdBQUdzRSxLQUFLQyxLQUFLLENBQUNpRCxLQUFLLENBQUN3SCxhQUFhaFAsS0FBSyxDQUFDb04sSUFBSTtRQUNqRSxJQUFJLENBQUNrRixNQUFNLEdBQUcsSUFBSSxDQUFDQSxNQUFNLENBQUNDLElBQUksQ0FBQyxJQUFJO1FBQ25DLElBQUksQ0FBQ0MsV0FBVyxHQUFHalQsaURBQUdBLENBQUMsU0FBUztZQUM1QmMsT0FBT0wsTUFBTWtNLE1BQU07WUFDbkJ1RyxhQUFhOU0sT0FBT3JCLE1BQU07WUFDMUIsY0FBY3FCLE9BQU9yQixNQUFNO1lBQzNCTyxPQUFPO1lBQ1BDLE1BQU07WUFDTjROLE1BQU07WUFDTixjQUFjO1lBQ2RDLFVBQVUsSUFBSSxDQUFDTCxNQUFNO1lBQ3JCTSxTQUFTLElBQUksQ0FBQ04sTUFBTTtRQUN4QjtRQUNBLElBQUksQ0FBQ08sWUFBWSxHQUFHdFQsaURBQUdBLENBQUMsU0FBUztZQUM3QmMsT0FBT0wsTUFBTXNNLE9BQU87WUFDcEJtRyxhQUFhOU0sT0FBT3JCLE1BQU07WUFDMUIsY0FBY3FCLE9BQU9yQixNQUFNO1lBQzNCTyxPQUFPO1lBQ1BDLE1BQU07WUFDTjROLE1BQU07WUFDTkMsVUFBVSxJQUFJLENBQUNMLE1BQU07WUFDckJNLFNBQVMsSUFBSSxDQUFDTixNQUFNO1FBQ3hCO1FBQ0EsSUFBSSxDQUFDUSxTQUFTLEdBQUd2VCxpREFBR0EsQ0FBQyxTQUFTO1lBQzFCcUcsTUFBTTtZQUNOZCxNQUFNO1lBQ040TixNQUFNO1lBQ05LLFNBQVMvUyxNQUFNMkwsYUFBYTtZQUM1QmdILFVBQVUsSUFBSSxDQUFDTCxNQUFNO1FBQ3pCO1FBQ0EsSUFBSSxDQUFDVSxPQUFPLEdBQUd6VCxpREFBR0EsQ0FBQyxTQUFTO1lBQ3hCcUcsTUFBTTtZQUNOZCxNQUFNO1lBQ040TixNQUFNO1lBQ05LLFNBQVMvUyxNQUFNNkwsTUFBTTtZQUNyQjhHLFVBQVUsSUFBSSxDQUFDTCxNQUFNO1FBQ3pCO1FBQ0EsSUFBSSxDQUFDVyxTQUFTLEdBQUcxVCxpREFBR0EsQ0FBQyxTQUFTO1lBQzFCcUcsTUFBTTtZQUNOZCxNQUFNO1lBQ040TixNQUFNO1lBQ05LLFNBQVMvUyxNQUFNOEwsU0FBUztZQUN4QjZHLFVBQVUsSUFBSSxDQUFDTCxNQUFNO1FBQ3pCO1FBQ0EsU0FBU1ksT0FBT3BPLElBQUksRUFBRXFPLE9BQU8sRUFBRUMsT0FBTztZQUNsQyxPQUFPN1QsaURBQUdBLENBQUMsVUFBVTtnQkFBRXNGLE9BQU87Z0JBQWFDO2dCQUFNcU87Z0JBQVN2TixNQUFNO1lBQVMsR0FBR3dOO1FBQ2hGO1FBQ0EsSUFBSSxDQUFDck8sR0FBRyxHQUFHeEYsaURBQUdBLENBQUMsT0FBTztZQUFFeUYsV0FBVyxDQUFDaUMsSUFBTSxJQUFJLENBQUNvTSxPQUFPLENBQUNwTTtZQUFJcEMsT0FBTztRQUFZLEdBQUc7WUFDN0UsSUFBSSxDQUFDMk4sV0FBVztZQUNoQlUsT0FBTyxRQUFRLElBQU1oRCxTQUFTNUwsT0FBTztnQkFBQ3FCLE9BQU9yQixNQUFNO2FBQVE7WUFDM0Q0TyxPQUFPLFFBQVEsSUFBTTNDLGFBQWFqTSxPQUFPO2dCQUFDcUIsT0FBT3JCLE1BQU07YUFBWTtZQUNuRTRPLE9BQU8sVUFBVSxJQUFNekMsY0FBY25NLE9BQU87Z0JBQUNxQixPQUFPckIsTUFBTTthQUFPO1lBQ2pFL0UsaURBQUdBLENBQUMsU0FBUyxNQUFNO2dCQUFDLElBQUksQ0FBQ3VULFNBQVM7Z0JBQUVuTixPQUFPckIsTUFBTTthQUFjO1lBQy9EL0UsaURBQUdBLENBQUMsU0FBUyxNQUFNO2dCQUFDLElBQUksQ0FBQ3lULE9BQU87Z0JBQUVyTixPQUFPckIsTUFBTTthQUFVO1lBQ3pEL0UsaURBQUdBLENBQUMsU0FBUyxNQUFNO2dCQUFDLElBQUksQ0FBQzBULFNBQVM7Z0JBQUV0TixPQUFPckIsTUFBTTthQUFXO2VBQ3pEQSxLQUFLQyxLQUFLLENBQUNzTSxRQUFRLEdBQUcsRUFBRSxHQUFHO2dCQUMxQnRSLGlEQUFHQSxDQUFDO2dCQUNKLElBQUksQ0FBQ3NULFlBQVk7Z0JBQ2pCSyxPQUFPLFdBQVcsSUFBTXRDLFlBQVl0TSxPQUFPO29CQUFDcUIsT0FBT3JCLE1BQU07aUJBQVc7Z0JBQ3BFNE8sT0FBTyxjQUFjLElBQU0vQixXQUFXN00sT0FBTztvQkFBQ3FCLE9BQU9yQixNQUFNO2lCQUFlO2FBQzdFO1lBQ0QvRSxpREFBR0EsQ0FBQyxVQUFVO2dCQUNWdUYsTUFBTTtnQkFDTnFPLFNBQVMsSUFBTXBCLGlCQUFpQnpOO2dCQUNoQyxjQUFjcUIsT0FBT3JCLE1BQU07Z0JBQzNCc0IsTUFBTTtZQUNWLEdBQUc7Z0JBQUM7YUFBSTtTQUNYO0lBQ0w7SUFDQTBNLFNBQVM7UUFDTCxJQUFJdFMsUUFBUSxJQUFJcU0sWUFBWTtZQUN4QkgsUUFBUSxJQUFJLENBQUNzRyxXQUFXLENBQUNuUyxLQUFLO1lBQzlCc0wsZUFBZSxJQUFJLENBQUNtSCxTQUFTLENBQUNDLE9BQU87WUFDckNsSCxRQUFRLElBQUksQ0FBQ21ILE9BQU8sQ0FBQ0QsT0FBTztZQUM1QmpILFdBQVcsSUFBSSxDQUFDbUgsU0FBUyxDQUFDRixPQUFPO1lBQ2pDekcsU0FBUyxJQUFJLENBQUN1RyxZQUFZLENBQUN4UyxLQUFLO1FBQ3BDO1FBQ0EsSUFBSSxDQUFDTCxNQUFNK0ssRUFBRSxDQUFDLElBQUksQ0FBQy9LLEtBQUssR0FBRztZQUN2QixJQUFJLENBQUNBLEtBQUssR0FBR0E7WUFDYixJQUFJLENBQUNzRSxJQUFJLENBQUNjLFFBQVEsQ0FBQztnQkFBRUMsU0FBU3lKLGVBQWV2SixFQUFFLENBQUN2RjtZQUFPO1FBQzNEO0lBQ0o7SUFDQXFULFFBQVFwTSxDQUFDLEVBQUU7UUFDUCxJQUFJeEksa0VBQWdCQSxDQUFDLElBQUksQ0FBQzZGLElBQUksRUFBRTJDLEdBQUcsaUJBQWlCO1lBQ2hEQSxFQUFFOUIsY0FBYztRQUNwQixPQUNLLElBQUk4QixFQUFFL0IsT0FBTyxJQUFJLE1BQU0rQixFQUFFcU0sTUFBTSxJQUFJLElBQUksQ0FBQ2QsV0FBVyxFQUFFO1lBQ3REdkwsRUFBRTlCLGNBQWM7WUFDZjhCLENBQUFBLEVBQUVzTSxRQUFRLEdBQUdoRCxlQUFlTCxRQUFPLEVBQUcsSUFBSSxDQUFDNUwsSUFBSTtRQUNwRCxPQUNLLElBQUkyQyxFQUFFL0IsT0FBTyxJQUFJLE1BQU0rQixFQUFFcU0sTUFBTSxJQUFJLElBQUksQ0FBQ1QsWUFBWSxFQUFFO1lBQ3ZENUwsRUFBRTlCLGNBQWM7WUFDaEJ5TCxZQUFZLElBQUksQ0FBQ3RNLElBQUk7UUFDekI7SUFDSjtJQUNBeUMsT0FBT0EsTUFBTSxFQUFFO1FBQ1gsS0FBSyxJQUFJQyxNQUFNRCxPQUFPeU0sWUFBWSxDQUM5QixLQUFLLElBQUlyRSxVQUFVbkksR0FBRzNCLE9BQU8sQ0FBRTtZQUMzQixJQUFJOEosT0FBT2pJLEVBQUUsQ0FBQzRILG1CQUFtQixDQUFDSyxPQUFPOU8sS0FBSyxDQUFDMEssRUFBRSxDQUFDLElBQUksQ0FBQy9LLEtBQUssR0FDeEQsSUFBSSxDQUFDeVQsUUFBUSxDQUFDdEUsT0FBTzlPLEtBQUs7UUFDbEM7SUFDUjtJQUNBb1QsU0FBU3pULEtBQUssRUFBRTtRQUNaLElBQUksQ0FBQ0EsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ3dTLFdBQVcsQ0FBQ25TLEtBQUssR0FBR0wsTUFBTWtNLE1BQU07UUFDckMsSUFBSSxDQUFDMkcsWUFBWSxDQUFDeFMsS0FBSyxHQUFHTCxNQUFNc00sT0FBTztRQUN2QyxJQUFJLENBQUN3RyxTQUFTLENBQUNDLE9BQU8sR0FBRy9TLE1BQU0yTCxhQUFhO1FBQzVDLElBQUksQ0FBQ3FILE9BQU8sQ0FBQ0QsT0FBTyxHQUFHL1MsTUFBTTZMLE1BQU07UUFDbkMsSUFBSSxDQUFDb0gsU0FBUyxDQUFDRixPQUFPLEdBQUcvUyxNQUFNOEwsU0FBUztJQUM1QztJQUNBNEgsUUFBUTtRQUNKLElBQUksQ0FBQ2xCLFdBQVcsQ0FBQzVLLE1BQU07SUFDM0I7SUFDQSxJQUFJdkcsTUFBTTtRQUFFLE9BQU87SUFBSTtJQUN2QixJQUFJcUssTUFBTTtRQUFFLE9BQU8sSUFBSSxDQUFDcEgsSUFBSSxDQUFDQyxLQUFLLENBQUNxRixLQUFLLENBQUM0QixtQkFBbUJFLEdBQUc7SUFBRTtBQUNyRTtBQUNBLFNBQVMvRixPQUFPckIsSUFBSSxFQUFFcUIsTUFBTTtJQUFJLE9BQU9yQixLQUFLQyxLQUFLLENBQUNvQixNQUFNLENBQUNBO0FBQVM7QUFDbEUsTUFBTWdPLGlCQUFpQjtBQUN2QixNQUFNQyxRQUFRO0FBQ2QsU0FBU3hELGNBQWM5TCxJQUFJLEVBQUUsRUFBRXJFLElBQUksRUFBRUMsRUFBRSxFQUFFO0lBQ3JDLElBQUlrRSxPQUFPRSxLQUFLQyxLQUFLLENBQUNiLEdBQUcsQ0FBQ2YsTUFBTSxDQUFDMUMsT0FBTzRULFVBQVV2UCxLQUFLQyxLQUFLLENBQUNiLEdBQUcsQ0FBQ2YsTUFBTSxDQUFDekMsSUFBSUEsRUFBRTtJQUM5RSxJQUFJZ0IsUUFBUWtGLEtBQUtHLEdBQUcsQ0FBQ25DLEtBQUtuRSxJQUFJLEVBQUVBLE9BQU8wVCxpQkFBaUJHLE1BQU0xTixLQUFLSSxHQUFHLENBQUNxTixTQUFTM1QsS0FBS3lUO0lBQ3JGLElBQUk1VCxPQUFPdUUsS0FBS0MsS0FBSyxDQUFDMkUsUUFBUSxDQUFDaEksT0FBTzRTO0lBQ3RDLElBQUk1UyxTQUFTa0QsS0FBS25FLElBQUksRUFBRTtRQUNwQixJQUFLLElBQUltQixJQUFJLEdBQUdBLElBQUl1UyxnQkFBZ0J2UyxJQUNoQyxJQUFJLENBQUN3UyxNQUFNeFQsSUFBSSxDQUFDTCxJQUFJLENBQUNxQixJQUFJLEVBQUUsS0FBS3dTLE1BQU14VCxJQUFJLENBQUNMLElBQUksQ0FBQ3FCLEVBQUUsR0FBRztZQUNqRHJCLE9BQU9BLEtBQUttRCxLQUFLLENBQUM5QjtZQUNsQjtRQUNKO0lBQ1I7SUFDQSxJQUFJMFMsT0FBT0QsU0FBUztRQUNoQixJQUFLLElBQUl6UyxJQUFJckIsS0FBS0ksTUFBTSxHQUFHLEdBQUdpQixJQUFJckIsS0FBS0ksTUFBTSxHQUFHd1QsZ0JBQWdCdlMsSUFDNUQsSUFBSSxDQUFDd1MsTUFBTXhULElBQUksQ0FBQ0wsSUFBSSxDQUFDcUIsSUFBSSxFQUFFLEtBQUt3UyxNQUFNeFQsSUFBSSxDQUFDTCxJQUFJLENBQUNxQixFQUFFLEdBQUc7WUFDakRyQixPQUFPQSxLQUFLbUQsS0FBSyxDQUFDLEdBQUc5QjtZQUNyQjtRQUNKO0lBQ1I7SUFDQSxPQUFPL0Msd0RBQVVBLENBQUM2UyxRQUFRLENBQUMzTCxFQUFFLENBQUMsQ0FBQyxFQUFFakIsS0FBS0MsS0FBSyxDQUFDb0IsTUFBTSxDQUFDLGlCQUFpQixFQUFFLEVBQUU1RixLQUFLLENBQUMsRUFBRXVFLEtBQUtDLEtBQUssQ0FBQ29CLE1BQU0sQ0FBQyxXQUFXLENBQUMsRUFBRXZCLEtBQUtPLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDbEk7QUFDQSxNQUFNa0QsWUFBWSxXQUFXLEdBQUV4Six3REFBVUEsQ0FBQ3dKLFNBQVMsQ0FBQztJQUNoRCx1QkFBdUI7UUFDbkJDLFNBQVM7UUFDVGlNLFVBQVU7UUFDVixrQkFBa0I7WUFDZEEsVUFBVTtZQUNWckksS0FBSztZQUNMc0ksT0FBTztZQUNQdEosaUJBQWlCO1lBQ2pCdUosUUFBUTtZQUNSQyxNQUFNO1lBQ05wTSxTQUFTO1lBQ1RxTSxRQUFRO1FBQ1o7UUFDQSw4QkFBOEI7WUFDMUJBLFFBQVE7UUFDWjtRQUNBLDBCQUEwQjtZQUN0QkMsYUFBYTtRQUNqQjtRQUNBLFdBQVc7WUFDUHJNLFVBQVU7WUFDVnNNLFlBQVk7UUFDaEI7SUFDSjtJQUNBLDBCQUEwQjtRQUFFM0osaUJBQWlCO0lBQVk7SUFDekQseUJBQXlCO1FBQUVBLGlCQUFpQjtJQUFZO0lBQ3hELG1DQUFtQztRQUFFQSxpQkFBaUI7SUFBWTtJQUNsRSxrQ0FBa0M7UUFBRUEsaUJBQWlCO0lBQVk7QUFDckU7QUFDQSxNQUFNMEIsbUJBQW1CO0lBQ3JCNEM7SUFDQSxXQUFXLEdBQUU1UCxtREFBSUEsQ0FBQ2tWLEdBQUcsQ0FBQzVFO0lBQ3RCN0g7Q0FDSDtBQUUrUyIsInNvdXJjZXMiOlsid2VicGFjazovL21iYy8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9zZWFyY2gvZGlzdC9pbmRleC5qcz9jZDJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNob3dQYW5lbCwgRWRpdG9yVmlldywgZ2V0UGFuZWwsIERlY29yYXRpb24sIFZpZXdQbHVnaW4sIHJ1blNjb3BlSGFuZGxlcnMgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IGNvZGVQb2ludEF0LCBmcm9tQ29kZVBvaW50LCBjb2RlUG9pbnRTaXplLCBTdGF0ZUVmZmVjdCwgU3RhdGVGaWVsZCwgRWRpdG9yU2VsZWN0aW9uLCBGYWNldCwgY29tYmluZUNvbmZpZywgQ2hhckNhdGVnb3J5LCBSYW5nZVNldEJ1aWxkZXIsIFByZWMsIEVkaXRvclN0YXRlLCBmaW5kQ2x1c3RlckJyZWFrIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IGVsdCBmcm9tICdjcmVsdCc7XG5cbmNvbnN0IGJhc2ljTm9ybWFsaXplID0gdHlwZW9mIFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplID09IFwiZnVuY3Rpb25cIlxuICAgID8geCA9PiB4Lm5vcm1hbGl6ZShcIk5GS0RcIikgOiB4ID0+IHg7XG4vKipcbkEgc2VhcmNoIGN1cnNvciBwcm92aWRlcyBhbiBpdGVyYXRvciBvdmVyIHRleHQgbWF0Y2hlcyBpbiBhXG5kb2N1bWVudC5cbiovXG5jbGFzcyBTZWFyY2hDdXJzb3Ige1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRleHQgY3Vyc29yLiBUaGUgcXVlcnkgaXMgdGhlIHNlYXJjaCBzdHJpbmcsIGBmcm9tYCB0b1xuICAgIGB0b2AgcHJvdmlkZXMgdGhlIHJlZ2lvbiB0byBzZWFyY2guXG4gICAgXG4gICAgV2hlbiBgbm9ybWFsaXplYCBpcyBnaXZlbiwgaXQgd2lsbCBiZSBjYWxsZWQsIG9uIGJvdGggdGhlIHF1ZXJ5XG4gICAgc3RyaW5nIGFuZCB0aGUgY29udGVudCBpdCBpcyBtYXRjaGVkIGFnYWluc3QsIGJlZm9yZSBjb21wYXJpbmcuXG4gICAgWW91IGNhbiwgZm9yIGV4YW1wbGUsIGNyZWF0ZSBhIGNhc2UtaW5zZW5zaXRpdmUgc2VhcmNoIGJ5XG4gICAgcGFzc2luZyBgcyA9PiBzLnRvTG93ZXJDYXNlKClgLlxuICAgIFxuICAgIFRleHQgaXMgYWx3YXlzIG5vcm1hbGl6ZWQgd2l0aFxuICAgIFtgLm5vcm1hbGl6ZShcIk5GS0RcIilgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvbm9ybWFsaXplKVxuICAgICh3aGVuIHN1cHBvcnRlZCkuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBxdWVyeSwgZnJvbSA9IDAsIHRvID0gdGV4dC5sZW5ndGgsIG5vcm1hbGl6ZSwgdGVzdCkge1xuICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIGN1cnJlbnQgbWF0Y2ggKG9ubHkgaG9sZHMgYSBtZWFuaW5nZnVsIHZhbHVlIGFmdGVyXG4gICAgICAgIFtgbmV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLlNlYXJjaEN1cnNvci5uZXh0KSBoYXMgYmVlbiBjYWxsZWQgYW5kIHdoZW5cbiAgICAgICAgYGRvbmVgIGlzIGZhbHNlKS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZSA9IHsgZnJvbTogMCwgdG86IDAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgIFdoZXRoZXIgdGhlIGVuZCBvZiB0aGUgaXRlcmF0ZWQgcmVnaW9uIGhhcyBiZWVuIHJlYWNoZWQuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1hdGNoZXMgPSBbXTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBcIlwiO1xuICAgICAgICB0aGlzLmJ1ZmZlclBvcyA9IDA7XG4gICAgICAgIHRoaXMuaXRlciA9IHRleHQuaXRlclJhbmdlKGZyb20sIHRvKTtcbiAgICAgICAgdGhpcy5idWZmZXJTdGFydCA9IGZyb207XG4gICAgICAgIHRoaXMubm9ybWFsaXplID0gbm9ybWFsaXplID8geCA9PiBub3JtYWxpemUoYmFzaWNOb3JtYWxpemUoeCkpIDogYmFzaWNOb3JtYWxpemU7XG4gICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLm5vcm1hbGl6ZShxdWVyeSk7XG4gICAgfVxuICAgIHBlZWsoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlclBvcyA9PSB0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyU3RhcnQgKz0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5pdGVyLm5leHQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLml0ZXIuZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclBvcyA9IDA7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuaXRlci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZVBvaW50QXQodGhpcy5idWZmZXIsIHRoaXMuYnVmZmVyUG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTG9vayBmb3IgdGhlIG5leHQgbWF0Y2guIFVwZGF0ZXMgdGhlIGl0ZXJhdG9yJ3NcbiAgICBbYHZhbHVlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guU2VhcmNoQ3Vyc29yLnZhbHVlKSBhbmRcbiAgICBbYGRvbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5TZWFyY2hDdXJzb3IuZG9uZSkgcHJvcGVydGllcy4gU2hvdWxkIGJlIGNhbGxlZFxuICAgIGF0IGxlYXN0IG9uY2UgYmVmb3JlIHVzaW5nIHRoZSBjdXJzb3IuXG4gICAgKi9cbiAgICBuZXh0KCkge1xuICAgICAgICB3aGlsZSAodGhpcy5tYXRjaGVzLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMubWF0Y2hlcy5wb3AoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dE92ZXJsYXBwaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBgbmV4dGAgbWV0aG9kIHdpbGwgaWdub3JlIG1hdGNoZXMgdGhhdCBwYXJ0aWFsbHkgb3ZlcmxhcCBhXG4gICAgcHJldmlvdXMgbWF0Y2guIFRoaXMgbWV0aG9kIGJlaGF2ZXMgbGlrZSBgbmV4dGAsIGJ1dCBpbmNsdWRlc1xuICAgIHN1Y2ggbWF0Y2hlcy5cbiAgICAqL1xuICAgIG5leHRPdmVybGFwcGluZygpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgICAgIGlmIChuZXh0IDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3RyID0gZnJvbUNvZGVQb2ludChuZXh0KSwgc3RhcnQgPSB0aGlzLmJ1ZmZlclN0YXJ0ICsgdGhpcy5idWZmZXJQb3M7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclBvcyArPSBjb2RlUG9pbnRTaXplKG5leHQpO1xuICAgICAgICAgICAgbGV0IG5vcm0gPSB0aGlzLm5vcm1hbGl6ZShzdHIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IHN0YXJ0OzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGUgPSBub3JtLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5tYXRjaChjb2RlLCBwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChpID09IG5vcm0ubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBtYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zID09IHN0YXJ0ICYmIGkgPCBzdHIubGVuZ3RoICYmIHN0ci5jaGFyQ29kZUF0KGkpID09IGNvZGUpXG4gICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG1hdGNoKGNvZGUsIHBvcykge1xuICAgICAgICBsZXQgbWF0Y2ggPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWF0Y2hlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5tYXRjaGVzW2ldLCBrZWVwID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5xdWVyeS5jaGFyQ29kZUF0KGluZGV4KSA9PSBjb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IHRoaXMucXVlcnkubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHsgZnJvbTogdGhpcy5tYXRjaGVzW2kgKyAxXSwgdG86IHBvcyArIDEgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlc1tpXSsrO1xuICAgICAgICAgICAgICAgICAgICBrZWVwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWtlZXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXMuc3BsaWNlKGksIDIpO1xuICAgICAgICAgICAgICAgIGkgLT0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5xdWVyeS5jaGFyQ29kZUF0KDApID09IGNvZGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnF1ZXJ5Lmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgICAgIG1hdGNoID0geyBmcm9tOiBwb3MsIHRvOiBwb3MgKyAxIH07XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzLnB1c2goMSwgcG9zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2ggJiYgdGhpcy50ZXN0ICYmICF0aGlzLnRlc3QobWF0Y2guZnJvbSwgbWF0Y2gudG8sIHRoaXMuYnVmZmVyLCB0aGlzLmJ1ZmZlclN0YXJ0KSlcbiAgICAgICAgICAgIG1hdGNoID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbn1cbmlmICh0eXBlb2YgU3ltYm9sICE9IFwidW5kZWZpbmVkXCIpXG4gICAgU2VhcmNoQ3Vyc29yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxuY29uc3QgZW1wdHkgPSB7IGZyb206IC0xLCB0bzogLTEsIG1hdGNoOiAvKkBfX1BVUkVfXyovLy4qLy5leGVjKFwiXCIpIH07XG5jb25zdCBiYXNlRmxhZ3MgPSBcImdtXCIgKyAoL3gvLnVuaWNvZGUgPT0gbnVsbCA/IFwiXCIgOiBcInVcIik7XG4vKipcblRoaXMgY2xhc3MgaXMgc2ltaWxhciB0byBbYFNlYXJjaEN1cnNvcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLlNlYXJjaEN1cnNvcilcbmJ1dCBzZWFyY2hlcyBmb3IgYSByZWd1bGFyIGV4cHJlc3Npb24gcGF0dGVybiBpbnN0ZWFkIG9mIGEgcGxhaW5cbnN0cmluZy5cbiovXG5jbGFzcyBSZWdFeHBDdXJzb3Ige1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIGN1cnNvciB0aGF0IHdpbGwgc2VhcmNoIHRoZSBnaXZlbiByYW5nZSBpbiB0aGUgZ2l2ZW5cbiAgICBkb2N1bWVudC4gYHF1ZXJ5YCBzaG91bGQgYmUgdGhlIHJhdyBwYXR0ZXJuIChhcyB5b3UnZCBwYXNzIGl0IHRvXG4gICAgYG5ldyBSZWdFeHBgKS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIHF1ZXJ5LCBvcHRpb25zLCBmcm9tID0gMCwgdG8gPSB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuY3VyTGluZSA9IFwiXCI7XG4gICAgICAgIC8qKlxuICAgICAgICBTZXQgdG8gYHRydWVgIHdoZW4gdGhlIGN1cnNvciBoYXMgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBzZWFyY2hcbiAgICAgICAgcmFuZ2UuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgV2lsbCBjb250YWluIGFuIG9iamVjdCB3aXRoIHRoZSBleHRlbnQgb2YgdGhlIG1hdGNoIGFuZCB0aGVcbiAgICAgICAgbWF0Y2ggb2JqZWN0IHdoZW4gW2BuZXh0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guUmVnRXhwQ3Vyc29yLm5leHQpXG4gICAgICAgIHN1Y2Vzc2Z1bGx5IGZpbmRzIGEgbWF0Y2guXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWUgPSBlbXB0eTtcbiAgICAgICAgaWYgKC9cXFxcW3NXRG5yXXxcXG58XFxyfFxcW1xcXi8udGVzdChxdWVyeSkpXG4gICAgICAgICAgICByZXR1cm4gbmV3IE11bHRpbGluZVJlZ0V4cEN1cnNvcih0ZXh0LCBxdWVyeSwgb3B0aW9ucywgZnJvbSwgdG8pO1xuICAgICAgICB0aGlzLnJlID0gbmV3IFJlZ0V4cChxdWVyeSwgYmFzZUZsYWdzICsgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaWdub3JlQ2FzZSkgPyBcImlcIiA6IFwiXCIpKTtcbiAgICAgICAgdGhpcy50ZXN0ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRlc3Q7XG4gICAgICAgIHRoaXMuaXRlciA9IHRleHQuaXRlcigpO1xuICAgICAgICBsZXQgc3RhcnRMaW5lID0gdGV4dC5saW5lQXQoZnJvbSk7XG4gICAgICAgIHRoaXMuY3VyTGluZVN0YXJ0ID0gc3RhcnRMaW5lLmZyb207XG4gICAgICAgIHRoaXMubWF0Y2hQb3MgPSB0b0NoYXJFbmQodGV4dCwgZnJvbSk7XG4gICAgICAgIHRoaXMuZ2V0TGluZSh0aGlzLmN1ckxpbmVTdGFydCk7XG4gICAgfVxuICAgIGdldExpbmUoc2tpcCkge1xuICAgICAgICB0aGlzLml0ZXIubmV4dChza2lwKTtcbiAgICAgICAgaWYgKHRoaXMuaXRlci5saW5lQnJlYWspIHtcbiAgICAgICAgICAgIHRoaXMuY3VyTGluZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1ckxpbmUgPSB0aGlzLml0ZXIudmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJMaW5lU3RhcnQgKyB0aGlzLmN1ckxpbmUubGVuZ3RoID4gdGhpcy50bylcbiAgICAgICAgICAgICAgICB0aGlzLmN1ckxpbmUgPSB0aGlzLmN1ckxpbmUuc2xpY2UoMCwgdGhpcy50byAtIHRoaXMuY3VyTGluZVN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuaXRlci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV4dExpbmUoKSB7XG4gICAgICAgIHRoaXMuY3VyTGluZVN0YXJ0ID0gdGhpcy5jdXJMaW5lU3RhcnQgKyB0aGlzLmN1ckxpbmUubGVuZ3RoICsgMTtcbiAgICAgICAgaWYgKHRoaXMuY3VyTGluZVN0YXJ0ID4gdGhpcy50bylcbiAgICAgICAgICAgIHRoaXMuY3VyTGluZSA9IFwiXCI7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbmV4dCBtYXRjaCwgaWYgdGhlcmUgaXMgb25lLlxuICAgICovXG4gICAgbmV4dCgpIHtcbiAgICAgICAgZm9yIChsZXQgb2ZmID0gdGhpcy5tYXRjaFBvcyAtIHRoaXMuY3VyTGluZVN0YXJ0OzspIHtcbiAgICAgICAgICAgIHRoaXMucmUubGFzdEluZGV4ID0gb2ZmO1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5tYXRjaFBvcyA8PSB0aGlzLnRvICYmIHRoaXMucmUuZXhlYyh0aGlzLmN1ckxpbmUpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSB0aGlzLmN1ckxpbmVTdGFydCArIG1hdGNoLmluZGV4LCB0byA9IGZyb20gKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaFBvcyA9IHRvQ2hhckVuZCh0aGlzLnRleHQsIHRvICsgKGZyb20gPT0gdG8gPyAxIDogMCkpO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID09IHRoaXMuY3VyTGluZVN0YXJ0ICsgdGhpcy5jdXJMaW5lLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0TGluZSgpO1xuICAgICAgICAgICAgICAgIGlmICgoZnJvbSA8IHRvIHx8IGZyb20gPiB0aGlzLnZhbHVlLnRvKSAmJiAoIXRoaXMudGVzdCB8fCB0aGlzLnRlc3QoZnJvbSwgdG8sIG1hdGNoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHsgZnJvbSwgdG8sIG1hdGNoIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmYgPSB0aGlzLm1hdGNoUG9zIC0gdGhpcy5jdXJMaW5lU3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmN1ckxpbmVTdGFydCArIHRoaXMuY3VyTGluZS5sZW5ndGggPCB0aGlzLnRvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0TGluZSgpO1xuICAgICAgICAgICAgICAgIG9mZiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgZmxhdHRlbmVkID0gLypAX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG4vLyBSZXVzYWJsZSAocGFydGlhbGx5KSBmbGF0dGVuZWQgZG9jdW1lbnQgc3RyaW5nc1xuY2xhc3MgRmxhdHRlbmVkRG9jIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0ZXh0KSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgfVxuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuZnJvbSArIHRoaXMudGV4dC5sZW5ndGg7IH1cbiAgICBzdGF0aWMgZ2V0KGRvYywgZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGNhY2hlZCA9IGZsYXR0ZW5lZC5nZXQoZG9jKTtcbiAgICAgICAgaWYgKCFjYWNoZWQgfHwgY2FjaGVkLmZyb20gPj0gdG8gfHwgY2FjaGVkLnRvIDw9IGZyb20pIHtcbiAgICAgICAgICAgIGxldCBmbGF0ID0gbmV3IEZsYXR0ZW5lZERvYyhmcm9tLCBkb2Muc2xpY2VTdHJpbmcoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgIGZsYXR0ZW5lZC5zZXQoZG9jLCBmbGF0KTtcbiAgICAgICAgICAgIHJldHVybiBmbGF0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWNoZWQuZnJvbSA9PSBmcm9tICYmIGNhY2hlZC50byA9PSB0bylcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIGxldCB7IHRleHQsIGZyb206IGNhY2hlZEZyb20gfSA9IGNhY2hlZDtcbiAgICAgICAgaWYgKGNhY2hlZEZyb20gPiBmcm9tKSB7XG4gICAgICAgICAgICB0ZXh0ID0gZG9jLnNsaWNlU3RyaW5nKGZyb20sIGNhY2hlZEZyb20pICsgdGV4dDtcbiAgICAgICAgICAgIGNhY2hlZEZyb20gPSBmcm9tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWNoZWQudG8gPCB0bylcbiAgICAgICAgICAgIHRleHQgKz0gZG9jLnNsaWNlU3RyaW5nKGNhY2hlZC50bywgdG8pO1xuICAgICAgICBmbGF0dGVuZWQuc2V0KGRvYywgbmV3IEZsYXR0ZW5lZERvYyhjYWNoZWRGcm9tLCB0ZXh0KSk7XG4gICAgICAgIHJldHVybiBuZXcgRmxhdHRlbmVkRG9jKGZyb20sIHRleHQuc2xpY2UoZnJvbSAtIGNhY2hlZEZyb20sIHRvIC0gY2FjaGVkRnJvbSkpO1xuICAgIH1cbn1cbmNsYXNzIE11bHRpbGluZVJlZ0V4cEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IodGV4dCwgcXVlcnksIG9wdGlvbnMsIGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmFsdWUgPSBlbXB0eTtcbiAgICAgICAgdGhpcy5tYXRjaFBvcyA9IHRvQ2hhckVuZCh0ZXh0LCBmcm9tKTtcbiAgICAgICAgdGhpcy5yZSA9IG5ldyBSZWdFeHAocXVlcnksIGJhc2VGbGFncyArICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmlnbm9yZUNhc2UpID8gXCJpXCIgOiBcIlwiKSk7XG4gICAgICAgIHRoaXMudGVzdCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50ZXN0O1xuICAgICAgICB0aGlzLmZsYXQgPSBGbGF0dGVuZWREb2MuZ2V0KHRleHQsIGZyb20sIHRoaXMuY2h1bmtFbmQoZnJvbSArIDUwMDAgLyogQ2h1bmsuQmFzZSAqLykpO1xuICAgIH1cbiAgICBjaHVua0VuZChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHBvcyA+PSB0aGlzLnRvID8gdGhpcy50byA6IHRoaXMudGV4dC5saW5lQXQocG9zKS50bztcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG9mZiA9IHRoaXMucmUubGFzdEluZGV4ID0gdGhpcy5tYXRjaFBvcyAtIHRoaXMuZmxhdC5mcm9tO1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5yZS5leGVjKHRoaXMuZmxhdC50ZXh0KTtcbiAgICAgICAgICAgIC8vIFNraXAgZW1wdHkgbWF0Y2hlcyBkaXJlY3RseSBhZnRlciB0aGUgbGFzdCBtYXRjaFxuICAgICAgICAgICAgaWYgKG1hdGNoICYmICFtYXRjaFswXSAmJiBtYXRjaC5pbmRleCA9PSBvZmYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlLmxhc3RJbmRleCA9IG9mZiArIDE7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSB0aGlzLnJlLmV4ZWModGhpcy5mbGF0LnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSB0aGlzLmZsYXQuZnJvbSArIG1hdGNoLmluZGV4LCB0byA9IGZyb20gKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgLy8gSWYgYSBtYXRjaCBnb2VzIGFsbW9zdCB0byB0aGUgZW5kIG9mIGEgbm9uY29tcGxldGUgY2h1bmssIHRyeVxuICAgICAgICAgICAgICAgIC8vIGFnYWluLCBzaW5jZSBpdCdsbCBsaWtlbHkgYmUgYWJsZSB0byBtYXRjaCBtb3JlXG4gICAgICAgICAgICAgICAgaWYgKCh0aGlzLmZsYXQudG8gPj0gdGhpcy50byB8fCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCA8PSB0aGlzLmZsYXQudGV4dC5sZW5ndGggLSAxMCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCF0aGlzLnRlc3QgfHwgdGhpcy50ZXN0KGZyb20sIHRvLCBtYXRjaCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB7IGZyb20sIHRvLCBtYXRjaCB9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoUG9zID0gdG9DaGFyRW5kKHRoaXMudGV4dCwgdG8gKyAoZnJvbSA9PSB0byA/IDEgOiAwKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmZsYXQudG8gPT0gdGhpcy50bykge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHcm93IHRoZSBmbGF0dGVuZWQgZG9jXG4gICAgICAgICAgICB0aGlzLmZsYXQgPSBGbGF0dGVuZWREb2MuZ2V0KHRoaXMudGV4dCwgdGhpcy5mbGF0LmZyb20sIHRoaXMuY2h1bmtFbmQodGhpcy5mbGF0LmZyb20gKyB0aGlzLmZsYXQudGV4dC5sZW5ndGggKiAyKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAodHlwZW9mIFN5bWJvbCAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgUmVnRXhwQ3Vyc29yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gTXVsdGlsaW5lUmVnRXhwQ3Vyc29yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID1cbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkUmVnRXhwKHNvdXJjZSkge1xuICAgIHRyeSB7XG4gICAgICAgIG5ldyBSZWdFeHAoc291cmNlLCBiYXNlRmxhZ3MpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b0NoYXJFbmQodGV4dCwgcG9zKSB7XG4gICAgaWYgKHBvcyA+PSB0ZXh0Lmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICBsZXQgbGluZSA9IHRleHQubGluZUF0KHBvcyksIG5leHQ7XG4gICAgd2hpbGUgKHBvcyA8IGxpbmUudG8gJiYgKG5leHQgPSBsaW5lLnRleHQuY2hhckNvZGVBdChwb3MgLSBsaW5lLmZyb20pKSA+PSAweERDMDAgJiYgbmV4dCA8IDB4RTAwMClcbiAgICAgICAgcG9zKys7XG4gICAgcmV0dXJuIHBvcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGluZURpYWxvZyh2aWV3KSB7XG4gICAgbGV0IGxpbmUgPSBTdHJpbmcodmlldy5zdGF0ZS5kb2MubGluZUF0KHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCkubnVtYmVyKTtcbiAgICBsZXQgaW5wdXQgPSBlbHQoXCJpbnB1dFwiLCB7IGNsYXNzOiBcImNtLXRleHRmaWVsZFwiLCBuYW1lOiBcImxpbmVcIiwgdmFsdWU6IGxpbmUgfSk7XG4gICAgbGV0IGRvbSA9IGVsdChcImZvcm1cIiwge1xuICAgICAgICBjbGFzczogXCJjbS1nb3RvTGluZVwiLFxuICAgICAgICBvbmtleWRvd246IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMjcpIHsgLy8gRXNjYXBlXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogZGlhbG9nRWZmZWN0Lm9mKGZhbHNlKSB9KTtcbiAgICAgICAgICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IDEzKSB7IC8vIEVudGVyXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBnbygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbnN1Ym1pdDogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZ28oKTtcbiAgICAgICAgfVxuICAgIH0sIGVsdChcImxhYmVsXCIsIHZpZXcuc3RhdGUucGhyYXNlKFwiR28gdG8gbGluZVwiKSwgXCI6IFwiLCBpbnB1dCksIFwiIFwiLCBlbHQoXCJidXR0b25cIiwgeyBjbGFzczogXCJjbS1idXR0b25cIiwgdHlwZTogXCJzdWJtaXRcIiB9LCB2aWV3LnN0YXRlLnBocmFzZShcImdvXCIpKSk7XG4gICAgZnVuY3Rpb24gZ28oKSB7XG4gICAgICAgIGxldCBtYXRjaCA9IC9eKFsrLV0pPyhcXGQrKT8oOlxcZCspPyglKT8kLy5leGVjKGlucHV0LnZhbHVlKTtcbiAgICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHN0YXJ0TGluZSA9IHN0YXRlLmRvYy5saW5lQXQoc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCk7XG4gICAgICAgIGxldCBbLCBzaWduLCBsbiwgY2wsIHBlcmNlbnRdID0gbWF0Y2g7XG4gICAgICAgIGxldCBjb2wgPSBjbCA/ICtjbC5zbGljZSgxKSA6IDA7XG4gICAgICAgIGxldCBsaW5lID0gbG4gPyArbG4gOiBzdGFydExpbmUubnVtYmVyO1xuICAgICAgICBpZiAobG4gJiYgcGVyY2VudCkge1xuICAgICAgICAgICAgbGV0IHBjID0gbGluZSAvIDEwMDtcbiAgICAgICAgICAgIGlmIChzaWduKVxuICAgICAgICAgICAgICAgIHBjID0gcGMgKiAoc2lnbiA9PSBcIi1cIiA/IC0xIDogMSkgKyAoc3RhcnRMaW5lLm51bWJlciAvIHN0YXRlLmRvYy5saW5lcyk7XG4gICAgICAgICAgICBsaW5lID0gTWF0aC5yb3VuZChzdGF0ZS5kb2MubGluZXMgKiBwYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobG4gJiYgc2lnbikge1xuICAgICAgICAgICAgbGluZSA9IGxpbmUgKiAoc2lnbiA9PSBcIi1cIiA/IC0xIDogMSkgKyBzdGFydExpbmUubnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkb2NMaW5lID0gc3RhdGUuZG9jLmxpbmUoTWF0aC5tYXgoMSwgTWF0aC5taW4oc3RhdGUuZG9jLmxpbmVzLCBsaW5lKSkpO1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihkb2NMaW5lLmZyb20gKyBNYXRoLm1heCgwLCBNYXRoLm1pbihjb2wsIGRvY0xpbmUubGVuZ3RoKSkpO1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIGVmZmVjdHM6IFtkaWFsb2dFZmZlY3Qub2YoZmFsc2UpLCBFZGl0b3JWaWV3LnNjcm9sbEludG9WaWV3KHNlbGVjdGlvbi5mcm9tLCB7IHk6ICdjZW50ZXInIH0pXSxcbiAgICAgICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgfSk7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZG9tIH07XG59XG5jb25zdCBkaWFsb2dFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBkaWFsb2dGaWVsZCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGZvciAobGV0IGUgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgIGlmIChlLmlzKGRpYWxvZ0VmZmVjdCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlLnZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBwcm92aWRlOiBmID0+IHNob3dQYW5lbC5mcm9tKGYsIHZhbCA9PiB2YWwgPyBjcmVhdGVMaW5lRGlhbG9nIDogbnVsbClcbn0pO1xuLyoqXG5Db21tYW5kIHRoYXQgc2hvd3MgYSBkaWFsb2cgYXNraW5nIHRoZSB1c2VyIGZvciBhIGxpbmUgbnVtYmVyLCBhbmRcbndoZW4gYSB2YWxpZCBwb3NpdGlvbiBpcyBwcm92aWRlZCwgbW92ZXMgdGhlIGN1cnNvciB0byB0aGF0IGxpbmUuXG5cblN1cHBvcnRzIGxpbmUgbnVtYmVycywgcmVsYXRpdmUgbGluZSBvZmZzZXRzIHByZWZpeGVkIHdpdGggYCtgIG9yXG5gLWAsIGRvY3VtZW50IHBlcmNlbnRhZ2VzIHN1ZmZpeGVkIHdpdGggYCVgLCBhbmQgYW4gb3B0aW9uYWxcbmNvbHVtbiBwb3NpdGlvbiBieSBhZGRpbmcgYDpgIGFuZCBhIHNlY29uZCBudW1iZXIgYWZ0ZXIgdGhlIGxpbmVcbm51bWJlci5cbiovXG5jb25zdCBnb3RvTGluZSA9IHZpZXcgPT4ge1xuICAgIGxldCBwYW5lbCA9IGdldFBhbmVsKHZpZXcsIGNyZWF0ZUxpbmVEaWFsb2cpO1xuICAgIGlmICghcGFuZWwpIHtcbiAgICAgICAgbGV0IGVmZmVjdHMgPSBbZGlhbG9nRWZmZWN0Lm9mKHRydWUpXTtcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUuZmllbGQoZGlhbG9nRmllbGQsIGZhbHNlKSA9PSBudWxsKVxuICAgICAgICAgICAgZWZmZWN0cy5wdXNoKFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihbZGlhbG9nRmllbGQsIGJhc2VUaGVtZSQxXSkpO1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0cyB9KTtcbiAgICAgICAgcGFuZWwgPSBnZXRQYW5lbCh2aWV3LCBjcmVhdGVMaW5lRGlhbG9nKTtcbiAgICB9XG4gICAgaWYgKHBhbmVsKVxuICAgICAgICBwYW5lbC5kb20ucXVlcnlTZWxlY3RvcihcImlucHV0XCIpLnNlbGVjdCgpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmNvbnN0IGJhc2VUaGVtZSQxID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS1wYW5lbC5jbS1nb3RvTGluZVwiOiB7XG4gICAgICAgIHBhZGRpbmc6IFwiMnB4IDZweCA0cHhcIixcbiAgICAgICAgXCImIGxhYmVsXCI6IHsgZm9udFNpemU6IFwiODAlXCIgfVxuICAgIH1cbn0pO1xuXG5jb25zdCBkZWZhdWx0SGlnaGxpZ2h0T3B0aW9ucyA9IHtcbiAgICBoaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yOiBmYWxzZSxcbiAgICBtaW5TZWxlY3Rpb25MZW5ndGg6IDEsXG4gICAgbWF4TWF0Y2hlczogMTAwLFxuICAgIHdob2xlV29yZHM6IGZhbHNlXG59O1xuY29uc3QgaGlnaGxpZ2h0Q29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKG9wdGlvbnMsIGRlZmF1bHRIaWdobGlnaHRPcHRpb25zLCB7XG4gICAgICAgICAgICBoaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yOiAoYSwgYikgPT4gYSB8fCBiLFxuICAgICAgICAgICAgbWluU2VsZWN0aW9uTGVuZ3RoOiBNYXRoLm1pbixcbiAgICAgICAgICAgIG1heE1hdGNoZXM6IE1hdGgubWluXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuLyoqXG5UaGlzIGV4dGVuc2lvbiBoaWdobGlnaHRzIHRleHQgdGhhdCBtYXRjaGVzIHRoZSBzZWxlY3Rpb24uIEl0IHVzZXNcbnRoZSBgXCJjbS1zZWxlY3Rpb25NYXRjaFwiYCBjbGFzcyBmb3IgdGhlIGhpZ2hsaWdodGluZy4gV2hlblxuYGhpZ2hsaWdodFdvcmRBcm91bmRDdXJzb3JgIGlzIGVuYWJsZWQsIHRoZSB3b3JkIGF0IHRoZSBjdXJzb3Jcbml0c2VsZiB3aWxsIGJlIGhpZ2hsaWdodGVkIHdpdGggYFwiY20tc2VsZWN0aW9uTWF0Y2gtbWFpblwiYC5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRTZWxlY3Rpb25NYXRjaGVzKG9wdGlvbnMpIHtcbiAgICBsZXQgZXh0ID0gW2RlZmF1bHRUaGVtZSwgbWF0Y2hIaWdobGlnaHRlcl07XG4gICAgaWYgKG9wdGlvbnMpXG4gICAgICAgIGV4dC5wdXNoKGhpZ2hsaWdodENvbmZpZy5vZihvcHRpb25zKSk7XG4gICAgcmV0dXJuIGV4dDtcbn1cbmNvbnN0IG1hdGNoRGVjbyA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1zZWxlY3Rpb25NYXRjaFwiIH0pO1xuY29uc3QgbWFpbk1hdGNoRGVjbyA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1zZWxlY3Rpb25NYXRjaCBjbS1zZWxlY3Rpb25NYXRjaC1tYWluXCIgfSk7XG4vLyBXaGV0aGVyIHRoZSBjaGFyYWN0ZXJzIGRpcmVjdGx5IG91dHNpZGUgdGhlIGdpdmVuIHBvc2l0aW9ucyBhcmUgbm9uLXdvcmQgY2hhcmFjdGVyc1xuZnVuY3Rpb24gaW5zaWRlV29yZEJvdW5kYXJpZXMoY2hlY2ssIHN0YXRlLCBmcm9tLCB0bykge1xuICAgIHJldHVybiAoZnJvbSA9PSAwIHx8IGNoZWNrKHN0YXRlLnNsaWNlRG9jKGZyb20gLSAxLCBmcm9tKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpICYmXG4gICAgICAgICh0byA9PSBzdGF0ZS5kb2MubGVuZ3RoIHx8IGNoZWNrKHN0YXRlLnNsaWNlRG9jKHRvLCB0byArIDEpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCk7XG59XG4vLyBXaGV0aGVyIHRoZSBjaGFyYWN0ZXJzIGRpcmVjdGx5IGF0IHRoZSBnaXZlbiBwb3NpdGlvbnMgYXJlIHdvcmQgY2hhcmFjdGVyc1xuZnVuY3Rpb24gaW5zaWRlV29yZChjaGVjaywgc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIGNoZWNrKHN0YXRlLnNsaWNlRG9jKGZyb20sIGZyb20gKyAxKSkgPT0gQ2hhckNhdGVnb3J5LldvcmRcbiAgICAgICAgJiYgY2hlY2soc3RhdGUuc2xpY2VEb2ModG8gLSAxLCB0bykpID09IENoYXJDYXRlZ29yeS5Xb3JkO1xufVxuY29uc3QgbWF0Y2hIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5nZXREZWNvKHZpZXcpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGlmICh1cGRhdGUuc2VsZWN0aW9uU2V0IHx8IHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQpXG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5nZXREZWNvKHVwZGF0ZS52aWV3KTtcbiAgICB9XG4gICAgZ2V0RGVjbyh2aWV3KSB7XG4gICAgICAgIGxldCBjb25mID0gdmlldy5zdGF0ZS5mYWNldChoaWdobGlnaHRDb25maWcpO1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoc2VsLnJhbmdlcy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgbGV0IHJhbmdlID0gc2VsLm1haW4sIHF1ZXJ5LCBjaGVjayA9IG51bGw7XG4gICAgICAgIGlmIChyYW5nZS5lbXB0eSkge1xuICAgICAgICAgICAgaWYgKCFjb25mLmhpZ2hsaWdodFdvcmRBcm91bmRDdXJzb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgICAgIGxldCB3b3JkID0gc3RhdGUud29yZEF0KHJhbmdlLmhlYWQpO1xuICAgICAgICAgICAgaWYgKCF3b3JkKVxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICBjaGVjayA9IHN0YXRlLmNoYXJDYXRlZ29yaXplcihyYW5nZS5oZWFkKTtcbiAgICAgICAgICAgIHF1ZXJ5ID0gc3RhdGUuc2xpY2VEb2Mod29yZC5mcm9tLCB3b3JkLnRvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSByYW5nZS50byAtIHJhbmdlLmZyb207XG4gICAgICAgICAgICBpZiAobGVuIDwgY29uZi5taW5TZWxlY3Rpb25MZW5ndGggfHwgbGVuID4gMjAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICBpZiAoY29uZi53aG9sZVdvcmRzKSB7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBzdGF0ZS5zbGljZURvYyhyYW5nZS5mcm9tLCByYW5nZS50byk7IC8vIFRPRE86IGFsbG93IGFuZCBpbmNsdWRlIGxlYWRpbmcvdHJhaWxpbmcgc3BhY2U/XG4gICAgICAgICAgICAgICAgY2hlY2sgPSBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocmFuZ2UuaGVhZCk7XG4gICAgICAgICAgICAgICAgaWYgKCEoaW5zaWRlV29yZEJvdW5kYXJpZXMoY2hlY2ssIHN0YXRlLCByYW5nZS5mcm9tLCByYW5nZS50bylcbiAgICAgICAgICAgICAgICAgICAgJiYgaW5zaWRlV29yZChjaGVjaywgc3RhdGUsIHJhbmdlLmZyb20sIHJhbmdlLnRvKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdWVyeSA9IHN0YXRlLnNsaWNlRG9jKHJhbmdlLmZyb20sIHJhbmdlLnRvKS50cmltKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFxdWVyeSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVjbyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIHZpZXcudmlzaWJsZVJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBxdWVyeSwgcGFydC5mcm9tLCBwYXJ0LnRvKTtcbiAgICAgICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrIHx8IGluc2lkZVdvcmRCb3VuZGFyaWVzKGNoZWNrLCBzdGF0ZSwgZnJvbSwgdG8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS5lbXB0eSAmJiBmcm9tIDw9IHJhbmdlLmZyb20gJiYgdG8gPj0gcmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvLnB1c2gobWFpbk1hdGNoRGVjby5yYW5nZShmcm9tLCB0bykpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmcm9tID49IHJhbmdlLnRvIHx8IHRvIDw9IHJhbmdlLmZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvLnB1c2gobWF0Y2hEZWNvLnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWNvLmxlbmd0aCA+IGNvbmYubWF4TWF0Y2hlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChkZWNvKTtcbiAgICB9XG59LCB7XG4gICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xufSk7XG5jb25zdCBkZWZhdWx0VGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLXNlbGVjdGlvbk1hdGNoXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiM5OWZmNzc4MFwiIH0sXG4gICAgXCIuY20tc2VhcmNoTWF0Y2ggLmNtLXNlbGVjdGlvbk1hdGNoXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50XCIgfVxufSk7XG4vLyBTZWxlY3QgdGhlIHdvcmRzIGFyb3VuZCB0aGUgY3Vyc29ycy5cbmNvbnN0IHNlbGVjdFdvcmQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCB7IHNlbGVjdGlvbiB9ID0gc3RhdGU7XG4gICAgbGV0IG5ld1NlbCA9IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoc2VsZWN0aW9uLnJhbmdlcy5tYXAocmFuZ2UgPT4gc3RhdGUud29yZEF0KHJhbmdlLmhlYWQpIHx8IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuaGVhZCkpLCBzZWxlY3Rpb24ubWFpbkluZGV4KTtcbiAgICBpZiAobmV3U2VsLmVxKHNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBzZWxlY3Rpb246IG5ld1NlbCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLy8gRmluZCBuZXh0IG9jY3VycmVuY2Ugb2YgcXVlcnkgcmVsYXRpdmUgdG8gbGFzdCBjdXJzb3IuIFdyYXAgYXJvdW5kXG4vLyB0aGUgZG9jdW1lbnQgaWYgdGhlcmUgYXJlIG5vIG1vcmUgbWF0Y2hlcy5cbmZ1bmN0aW9uIGZpbmROZXh0T2NjdXJyZW5jZShzdGF0ZSwgcXVlcnkpIHtcbiAgICBsZXQgeyBtYWluLCByYW5nZXMgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgd29yZCA9IHN0YXRlLndvcmRBdChtYWluLmhlYWQpLCBmdWxsV29yZCA9IHdvcmQgJiYgd29yZC5mcm9tID09IG1haW4uZnJvbSAmJiB3b3JkLnRvID09IG1haW4udG87XG4gICAgZm9yIChsZXQgY3ljbGVkID0gZmFsc2UsIGN1cnNvciA9IG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBxdWVyeSwgcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50byk7Oykge1xuICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICBpZiAoY3Vyc29yLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChjeWNsZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjdXJzb3IgPSBuZXcgU2VhcmNoQ3Vyc29yKHN0YXRlLmRvYywgcXVlcnksIDAsIE1hdGgubWF4KDAsIHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0uZnJvbSAtIDEpKTtcbiAgICAgICAgICAgIGN5Y2xlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY3ljbGVkICYmIHJhbmdlcy5zb21lKHIgPT4gci5mcm9tID09IGN1cnNvci52YWx1ZS5mcm9tKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChmdWxsV29yZCkge1xuICAgICAgICAgICAgICAgIGxldCB3b3JkID0gc3RhdGUud29yZEF0KGN1cnNvci52YWx1ZS5mcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoIXdvcmQgfHwgd29yZC5mcm9tICE9IGN1cnNvci52YWx1ZS5mcm9tIHx8IHdvcmQudG8gIT0gY3Vyc29yLnZhbHVlLnRvKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJzb3IudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcblNlbGVjdCBuZXh0IG9jY3VycmVuY2Ugb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBFeHBhbmQgc2VsZWN0aW9uXG50byB0aGUgc3Vycm91bmRpbmcgd29yZCB3aGVuIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkuXG4qL1xuY29uc3Qgc2VsZWN0TmV4dE9jY3VycmVuY2UgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCB7IHJhbmdlcyB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmIChyYW5nZXMuc29tZShzZWwgPT4gc2VsLmZyb20gPT09IHNlbC50bykpXG4gICAgICAgIHJldHVybiBzZWxlY3RXb3JkKHsgc3RhdGUsIGRpc3BhdGNoIH0pO1xuICAgIGxldCBzZWFyY2hlZFRleHQgPSBzdGF0ZS5zbGljZURvYyhyYW5nZXNbMF0uZnJvbSwgcmFuZ2VzWzBdLnRvKTtcbiAgICBpZiAoc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5zb21lKHIgPT4gc3RhdGUuc2xpY2VEb2Moci5mcm9tLCByLnRvKSAhPSBzZWFyY2hlZFRleHQpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHJhbmdlID0gZmluZE5leHRPY2N1cnJlbmNlKHN0YXRlLCBzZWFyY2hlZFRleHQpO1xuICAgIGlmICghcmFuZ2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoe1xuICAgICAgICBzZWxlY3Rpb246IHN0YXRlLnNlbGVjdGlvbi5hZGRSYW5nZShFZGl0b3JTZWxlY3Rpb24ucmFuZ2UocmFuZ2UuZnJvbSwgcmFuZ2UudG8pLCBmYWxzZSksXG4gICAgICAgIGVmZmVjdHM6IEVkaXRvclZpZXcuc2Nyb2xsSW50b1ZpZXcocmFuZ2UudG8pXG4gICAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuY29uc3Qgc2VhcmNoQ29uZmlnRmFjZXQgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgdG9wOiBmYWxzZSxcbiAgICAgICAgICAgIGNhc2VTZW5zaXRpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbGl0ZXJhbDogZmFsc2UsXG4gICAgICAgICAgICByZWdleHA6IGZhbHNlLFxuICAgICAgICAgICAgd2hvbGVXb3JkOiBmYWxzZSxcbiAgICAgICAgICAgIGNyZWF0ZVBhbmVsOiB2aWV3ID0+IG5ldyBTZWFyY2hQYW5lbCh2aWV3KSxcbiAgICAgICAgICAgIHNjcm9sbFRvTWF0Y2g6IHJhbmdlID0+IEVkaXRvclZpZXcuc2Nyb2xsSW50b1ZpZXcocmFuZ2UpXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuLyoqXG5BZGQgc2VhcmNoIHN0YXRlIHRvIHRoZSBlZGl0b3IgY29uZmlndXJhdGlvbiwgYW5kIG9wdGlvbmFsbHlcbmNvbmZpZ3VyZSB0aGUgc2VhcmNoIGV4dGVuc2lvbi5cbihbYG9wZW5TZWFyY2hQYW5lbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLm9wZW5TZWFyY2hQYW5lbCkgd2lsbCBhdXRvbWF0aWNhbGx5XG5lbmFibGUgdGhpcyBpZiBpdCBpc24ndCBhbHJlYWR5IG9uKS5cbiovXG5mdW5jdGlvbiBzZWFyY2goY29uZmlnKSB7XG4gICAgcmV0dXJuIGNvbmZpZyA/IFtzZWFyY2hDb25maWdGYWNldC5vZihjb25maWcpLCBzZWFyY2hFeHRlbnNpb25zXSA6IHNlYXJjaEV4dGVuc2lvbnM7XG59XG4vKipcbkEgc2VhcmNoIHF1ZXJ5LiBQYXJ0IG9mIHRoZSBlZGl0b3IncyBzZWFyY2ggc3RhdGUuXG4qL1xuY2xhc3MgU2VhcmNoUXVlcnkge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHF1ZXJ5IG9iamVjdC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IGNvbmZpZy5zZWFyY2g7XG4gICAgICAgIHRoaXMuY2FzZVNlbnNpdGl2ZSA9ICEhY29uZmlnLmNhc2VTZW5zaXRpdmU7XG4gICAgICAgIHRoaXMubGl0ZXJhbCA9ICEhY29uZmlnLmxpdGVyYWw7XG4gICAgICAgIHRoaXMucmVnZXhwID0gISFjb25maWcucmVnZXhwO1xuICAgICAgICB0aGlzLnJlcGxhY2UgPSBjb25maWcucmVwbGFjZSB8fCBcIlwiO1xuICAgICAgICB0aGlzLnZhbGlkID0gISF0aGlzLnNlYXJjaCAmJiAoIXRoaXMucmVnZXhwIHx8IHZhbGlkUmVnRXhwKHRoaXMuc2VhcmNoKSk7XG4gICAgICAgIHRoaXMudW5xdW90ZWQgPSB0aGlzLnVucXVvdGUodGhpcy5zZWFyY2gpO1xuICAgICAgICB0aGlzLndob2xlV29yZCA9ICEhY29uZmlnLndob2xlV29yZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB1bnF1b3RlKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGl0ZXJhbCA/IHRleHQgOlxuICAgICAgICAgICAgdGV4dC5yZXBsYWNlKC9cXFxcKFtucnRcXFxcXSkvZywgKF8sIGNoKSA9PiBjaCA9PSBcIm5cIiA/IFwiXFxuXCIgOiBjaCA9PSBcInJcIiA/IFwiXFxyXCIgOiBjaCA9PSBcInRcIiA/IFwiXFx0XCIgOiBcIlxcXFxcIik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyBxdWVyeSB0byBhbm90aGVyIHF1ZXJ5LlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoID09IG90aGVyLnNlYXJjaCAmJiB0aGlzLnJlcGxhY2UgPT0gb3RoZXIucmVwbGFjZSAmJlxuICAgICAgICAgICAgdGhpcy5jYXNlU2Vuc2l0aXZlID09IG90aGVyLmNhc2VTZW5zaXRpdmUgJiYgdGhpcy5yZWdleHAgPT0gb3RoZXIucmVnZXhwICYmXG4gICAgICAgICAgICB0aGlzLndob2xlV29yZCA9PSBvdGhlci53aG9sZVdvcmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdleHAgPyBuZXcgUmVnRXhwUXVlcnkodGhpcykgOiBuZXcgU3RyaW5nUXVlcnkodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIHNlYXJjaCBjdXJzb3IgZm9yIHRoaXMgcXVlcnksIHNlYXJjaGluZyB0aHJvdWdoIHRoZSBnaXZlblxuICAgIHJhbmdlIGluIHRoZSBnaXZlbiBzdGF0ZS5cbiAgICAqL1xuICAgIGdldEN1cnNvcihzdGF0ZSwgZnJvbSA9IDAsIHRvKSB7XG4gICAgICAgIGxldCBzdCA9IHN0YXRlLmRvYyA/IHN0YXRlIDogRWRpdG9yU3RhdGUuY3JlYXRlKHsgZG9jOiBzdGF0ZSB9KTtcbiAgICAgICAgaWYgKHRvID09IG51bGwpXG4gICAgICAgICAgICB0byA9IHN0LmRvYy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2V4cCA/IHJlZ2V4cEN1cnNvcih0aGlzLCBzdCwgZnJvbSwgdG8pIDogc3RyaW5nQ3Vyc29yKHRoaXMsIHN0LCBmcm9tLCB0byk7XG4gICAgfVxufVxuY2xhc3MgUXVlcnlUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgfVxufVxuZnVuY3Rpb24gc3RyaW5nQ3Vyc29yKHNwZWMsIHN0YXRlLCBmcm9tLCB0bykge1xuICAgIHJldHVybiBuZXcgU2VhcmNoQ3Vyc29yKHN0YXRlLmRvYywgc3BlYy51bnF1b3RlZCwgZnJvbSwgdG8sIHNwZWMuY2FzZVNlbnNpdGl2ZSA/IHVuZGVmaW5lZCA6IHggPT4geC50b0xvd2VyQ2FzZSgpLCBzcGVjLndob2xlV29yZCA/IHN0cmluZ1dvcmRUZXN0KHN0YXRlLmRvYywgc3RhdGUuY2hhckNhdGVnb3JpemVyKHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpKSA6IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBzdHJpbmdXb3JkVGVzdChkb2MsIGNhdGVnb3JpemVyKSB7XG4gICAgcmV0dXJuIChmcm9tLCB0bywgYnVmLCBidWZQb3MpID0+IHtcbiAgICAgICAgaWYgKGJ1ZlBvcyA+IGZyb20gfHwgYnVmUG9zICsgYnVmLmxlbmd0aCA8IHRvKSB7XG4gICAgICAgICAgICBidWZQb3MgPSBNYXRoLm1heCgwLCBmcm9tIC0gMik7XG4gICAgICAgICAgICBidWYgPSBkb2Muc2xpY2VTdHJpbmcoYnVmUG9zLCBNYXRoLm1pbihkb2MubGVuZ3RoLCB0byArIDIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNhdGVnb3JpemVyKGNoYXJCZWZvcmUoYnVmLCBmcm9tIC0gYnVmUG9zKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQgfHxcbiAgICAgICAgICAgIGNhdGVnb3JpemVyKGNoYXJBZnRlcihidWYsIGZyb20gLSBidWZQb3MpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCkgJiZcbiAgICAgICAgICAgIChjYXRlZ29yaXplcihjaGFyQWZ0ZXIoYnVmLCB0byAtIGJ1ZlBvcykpICE9IENoYXJDYXRlZ29yeS5Xb3JkIHx8XG4gICAgICAgICAgICAgICAgY2F0ZWdvcml6ZXIoY2hhckJlZm9yZShidWYsIHRvIC0gYnVmUG9zKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpO1xuICAgIH07XG59XG5jbGFzcyBTdHJpbmdRdWVyeSBleHRlbmRzIFF1ZXJ5VHlwZSB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBzdXBlcihzcGVjKTtcbiAgICB9XG4gICAgbmV4dE1hdGNoKHN0YXRlLCBjdXJGcm9tLCBjdXJUbykge1xuICAgICAgICBsZXQgY3Vyc29yID0gc3RyaW5nQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIGN1clRvLCBzdGF0ZS5kb2MubGVuZ3RoKS5uZXh0T3ZlcmxhcHBpbmcoKTtcbiAgICAgICAgaWYgKGN1cnNvci5kb25lKVxuICAgICAgICAgICAgY3Vyc29yID0gc3RyaW5nQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIDAsIGN1ckZyb20pLm5leHRPdmVybGFwcGluZygpO1xuICAgICAgICByZXR1cm4gY3Vyc29yLmRvbmUgPyBudWxsIDogY3Vyc29yLnZhbHVlO1xuICAgIH1cbiAgICAvLyBTZWFyY2hpbmcgaW4gcmV2ZXJzZSBpcywgcmF0aGVyIHRoYW4gaW1wbGVtZW50aW5nIGFuIGludmVydGVkIHNlYXJjaFxuICAgIC8vIGN1cnNvciwgZG9uZSBieSBzY2FubmluZyBjaHVuayBhZnRlciBjaHVuayBmb3J3YXJkLlxuICAgIHByZXZNYXRjaEluUmFuZ2Uoc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHRvOzspIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KGZyb20sIHBvcyAtIDEwMDAwIC8qIEZpbmRQcmV2LkNodW5rU2l6ZSAqLyAtIHRoaXMuc3BlYy51bnF1b3RlZC5sZW5ndGgpO1xuICAgICAgICAgICAgbGV0IGN1cnNvciA9IHN0cmluZ0N1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBzdGFydCwgcG9zKSwgcmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dE92ZXJsYXBwaW5nKCkuZG9uZSlcbiAgICAgICAgICAgICAgICByYW5nZSA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgIGlmIChyYW5nZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPT0gZnJvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHBvcyAtPSAxMDAwMCAvKiBGaW5kUHJldi5DaHVua1NpemUgKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJldk1hdGNoKHN0YXRlLCBjdXJGcm9tLCBjdXJUbykge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCAwLCBjdXJGcm9tKSB8fFxuICAgICAgICAgICAgdGhpcy5wcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCBjdXJUbywgc3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgfVxuICAgIGdldFJlcGxhY2VtZW50KF9yZXN1bHQpIHsgcmV0dXJuIHRoaXMuc3BlYy51bnF1b3RlKHRoaXMuc3BlYy5yZXBsYWNlKTsgfVxuICAgIG1hdGNoQWxsKHN0YXRlLCBsaW1pdCkge1xuICAgICAgICBsZXQgY3Vyc29yID0gc3RyaW5nQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIDAsIHN0YXRlLmRvYy5sZW5ndGgpLCByYW5nZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID49IGxpbWl0KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2goY3Vyc29yLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgIH1cbiAgICBoaWdobGlnaHQoc3RhdGUsIGZyb20sIHRvLCBhZGQpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHN0cmluZ0N1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBNYXRoLm1heCgwLCBmcm9tIC0gdGhpcy5zcGVjLnVucXVvdGVkLmxlbmd0aCksIE1hdGgubWluKHRvICsgdGhpcy5zcGVjLnVucXVvdGVkLmxlbmd0aCwgc3RhdGUuZG9jLmxlbmd0aCkpO1xuICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSlcbiAgICAgICAgICAgIGFkZChjdXJzb3IudmFsdWUuZnJvbSwgY3Vyc29yLnZhbHVlLnRvKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZWdleHBDdXJzb3Ioc3BlYywgc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHBDdXJzb3Ioc3RhdGUuZG9jLCBzcGVjLnNlYXJjaCwge1xuICAgICAgICBpZ25vcmVDYXNlOiAhc3BlYy5jYXNlU2Vuc2l0aXZlLFxuICAgICAgICB0ZXN0OiBzcGVjLndob2xlV29yZCA/IHJlZ2V4cFdvcmRUZXN0KHN0YXRlLmNoYXJDYXRlZ29yaXplcihzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKSkgOiB1bmRlZmluZWRcbiAgICB9LCBmcm9tLCB0byk7XG59XG5mdW5jdGlvbiBjaGFyQmVmb3JlKHN0ciwgaW5kZXgpIHtcbiAgICByZXR1cm4gc3RyLnNsaWNlKGZpbmRDbHVzdGVyQnJlYWsoc3RyLCBpbmRleCwgZmFsc2UpLCBpbmRleCk7XG59XG5mdW5jdGlvbiBjaGFyQWZ0ZXIoc3RyLCBpbmRleCkge1xuICAgIHJldHVybiBzdHIuc2xpY2UoaW5kZXgsIGZpbmRDbHVzdGVyQnJlYWsoc3RyLCBpbmRleCkpO1xufVxuZnVuY3Rpb24gcmVnZXhwV29yZFRlc3QoY2F0ZWdvcml6ZXIpIHtcbiAgICByZXR1cm4gKF9mcm9tLCBfdG8sIG1hdGNoKSA9PiAhbWF0Y2hbMF0ubGVuZ3RoIHx8XG4gICAgICAgIChjYXRlZ29yaXplcihjaGFyQmVmb3JlKG1hdGNoLmlucHV0LCBtYXRjaC5pbmRleCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkIHx8XG4gICAgICAgICAgICBjYXRlZ29yaXplcihjaGFyQWZ0ZXIobWF0Y2guaW5wdXQsIG1hdGNoLmluZGV4KSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpICYmXG4gICAgICAgICAgICAoY2F0ZWdvcml6ZXIoY2hhckFmdGVyKG1hdGNoLmlucHV0LCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkIHx8XG4gICAgICAgICAgICAgICAgY2F0ZWdvcml6ZXIoY2hhckJlZm9yZShtYXRjaC5pbnB1dCwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCk7XG59XG5jbGFzcyBSZWdFeHBRdWVyeSBleHRlbmRzIFF1ZXJ5VHlwZSB7XG4gICAgbmV4dE1hdGNoKHN0YXRlLCBjdXJGcm9tLCBjdXJUbykge1xuICAgICAgICBsZXQgY3Vyc29yID0gcmVnZXhwQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIGN1clRvLCBzdGF0ZS5kb2MubGVuZ3RoKS5uZXh0KCk7XG4gICAgICAgIGlmIChjdXJzb3IuZG9uZSlcbiAgICAgICAgICAgIGN1cnNvciA9IHJlZ2V4cEN1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCAwLCBjdXJGcm9tKS5uZXh0KCk7XG4gICAgICAgIHJldHVybiBjdXJzb3IuZG9uZSA/IG51bGwgOiBjdXJzb3IudmFsdWU7XG4gICAgfVxuICAgIHByZXZNYXRjaEluUmFuZ2Uoc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgICAgIGZvciAobGV0IHNpemUgPSAxOzsgc2l6ZSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChmcm9tLCB0byAtIHNpemUgKiAxMDAwMCAvKiBGaW5kUHJldi5DaHVua1NpemUgKi8pO1xuICAgICAgICAgICAgbGV0IGN1cnNvciA9IHJlZ2V4cEN1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBzdGFydCwgdG8pLCByYW5nZSA9IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSlcbiAgICAgICAgICAgICAgICByYW5nZSA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgIGlmIChyYW5nZSAmJiAoc3RhcnQgPT0gZnJvbSB8fCByYW5nZS5mcm9tID4gc3RhcnQgKyAxMCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGZyb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJldk1hdGNoKHN0YXRlLCBjdXJGcm9tLCBjdXJUbykge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCAwLCBjdXJGcm9tKSB8fFxuICAgICAgICAgICAgdGhpcy5wcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCBjdXJUbywgc3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgfVxuICAgIGdldFJlcGxhY2VtZW50KHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGVjLnVucXVvdGUodGhpcy5zcGVjLnJlcGxhY2UpLnJlcGxhY2UoL1xcJChbJCZcXGQrXSkvZywgKG0sIGkpID0+IGkgPT0gXCIkXCIgPyBcIiRcIlxuICAgICAgICAgICAgOiBpID09IFwiJlwiID8gcmVzdWx0Lm1hdGNoWzBdXG4gICAgICAgICAgICAgICAgOiBpICE9IFwiMFwiICYmICtpIDwgcmVzdWx0Lm1hdGNoLmxlbmd0aCA/IHJlc3VsdC5tYXRjaFtpXVxuICAgICAgICAgICAgICAgICAgICA6IG0pO1xuICAgIH1cbiAgICBtYXRjaEFsbChzdGF0ZSwgbGltaXQpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHJlZ2V4cEN1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCAwLCBzdGF0ZS5kb2MubGVuZ3RoKSwgcmFuZ2VzID0gW107XG4gICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA+PSBsaW1pdClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKGN1cnNvci52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICB9XG4gICAgaGlnaGxpZ2h0KHN0YXRlLCBmcm9tLCB0bywgYWRkKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSByZWdleHBDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgTWF0aC5tYXgoMCwgZnJvbSAtIDI1MCAvKiBSZWdFeHAuSGlnaGxpZ2h0TWFyZ2luICovKSwgTWF0aC5taW4odG8gKyAyNTAgLyogUmVnRXhwLkhpZ2hsaWdodE1hcmdpbiAqLywgc3RhdGUuZG9jLmxlbmd0aCkpO1xuICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSlcbiAgICAgICAgICAgIGFkZChjdXJzb3IudmFsdWUuZnJvbSwgY3Vyc29yLnZhbHVlLnRvKTtcbiAgICB9XG59XG4vKipcbkEgc3RhdGUgZWZmZWN0IHRoYXQgdXBkYXRlcyB0aGUgY3VycmVudCBzZWFyY2ggcXVlcnkuIE5vdGUgdGhhdFxudGhpcyBvbmx5IGhhcyBhbiBlZmZlY3QgaWYgdGhlIHNlYXJjaCBzdGF0ZSBoYXMgYmVlbiBpbml0aWFsaXplZFxuKGJ5IGluY2x1ZGluZyBbYHNlYXJjaGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLnNlYXJjaCkgaW4geW91ciBjb25maWd1cmF0aW9uIG9yXG5ieSBydW5uaW5nIFtgb3BlblNlYXJjaFBhbmVsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2gub3BlblNlYXJjaFBhbmVsKSBhdCBsZWFzdFxub25jZSkuXG4qL1xuY29uc3Qgc2V0U2VhcmNoUXVlcnkgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCB0b2dnbGVQYW5lbCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IHNlYXJjaFN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWFyY2hTdGF0ZShkZWZhdWx0UXVlcnkoc3RhdGUpLmNyZWF0ZSgpLCBudWxsKTtcbiAgICB9LFxuICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0U2VhcmNoUXVlcnkpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IFNlYXJjaFN0YXRlKGVmZmVjdC52YWx1ZS5jcmVhdGUoKSwgdmFsdWUucGFuZWwpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKHRvZ2dsZVBhbmVsKSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBTZWFyY2hTdGF0ZSh2YWx1ZS5xdWVyeSwgZWZmZWN0LnZhbHVlID8gY3JlYXRlU2VhcmNoUGFuZWwgOiBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBwcm92aWRlOiBmID0+IHNob3dQYW5lbC5mcm9tKGYsIHZhbCA9PiB2YWwucGFuZWwpXG59KTtcbi8qKlxuR2V0IHRoZSBjdXJyZW50IHNlYXJjaCBxdWVyeSBmcm9tIGFuIGVkaXRvciBzdGF0ZS5cbiovXG5mdW5jdGlvbiBnZXRTZWFyY2hRdWVyeShzdGF0ZSkge1xuICAgIGxldCBjdXJTdGF0ZSA9IHN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlLCBmYWxzZSk7XG4gICAgcmV0dXJuIGN1clN0YXRlID8gY3VyU3RhdGUucXVlcnkuc3BlYyA6IGRlZmF1bHRRdWVyeShzdGF0ZSk7XG59XG4vKipcblF1ZXJ5IHdoZXRoZXIgdGhlIHNlYXJjaCBwYW5lbCBpcyBvcGVuIGluIHRoZSBnaXZlbiBlZGl0b3Igc3RhdGUuXG4qL1xuZnVuY3Rpb24gc2VhcmNoUGFuZWxPcGVuKHN0YXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhbmVsKSAhPSBudWxsO1xufVxuY2xhc3MgU2VhcmNoU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKHF1ZXJ5LCBwYW5lbCkge1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIHRoaXMucGFuZWwgPSBwYW5lbDtcbiAgICB9XG59XG5jb25zdCBtYXRjaE1hcmsgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tc2VhcmNoTWF0Y2hcIiB9KSwgc2VsZWN0ZWRNYXRjaE1hcmsgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tc2VhcmNoTWF0Y2ggY20tc2VhcmNoTWF0Y2gtc2VsZWN0ZWRcIiB9KTtcbmNvbnN0IHNlYXJjaEhpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmhpZ2hsaWdodCh2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlKSk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdXBkYXRlLnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlKTtcbiAgICAgICAgaWYgKHN0YXRlICE9IHVwZGF0ZS5zdGFydFN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlKSB8fCB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuc2VsZWN0aW9uU2V0IHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQpXG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5oaWdobGlnaHQoc3RhdGUpO1xuICAgIH1cbiAgICBoaWdobGlnaHQoeyBxdWVyeSwgcGFuZWwgfSkge1xuICAgICAgICBpZiAoIXBhbmVsIHx8ICFxdWVyeS5zcGVjLnZhbGlkKVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCByYW5nZXMgPSB2aWV3LnZpc2libGVSYW5nZXMsIGwgPSByYW5nZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBsIC0gMSAmJiB0byA+IHJhbmdlc1tpICsgMV0uZnJvbSAtIDIgKiAyNTAgLyogUmVnRXhwLkhpZ2hsaWdodE1hcmdpbiAqLylcbiAgICAgICAgICAgICAgICB0byA9IHJhbmdlc1srK2ldLnRvO1xuICAgICAgICAgICAgcXVlcnkuaGlnaGxpZ2h0KHZpZXcuc3RhdGUsIGZyb20sIHRvLCAoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgc2VsZWN0ZWQgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMuc29tZShyID0+IHIuZnJvbSA9PSBmcm9tICYmIHIudG8gPT0gdG8pO1xuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkKGZyb20sIHRvLCBzZWxlY3RlZCA/IHNlbGVjdGVkTWF0Y2hNYXJrIDogbWF0Y2hNYXJrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaCgpO1xuICAgIH1cbn0sIHtcbiAgICBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zXG59KTtcbmZ1bmN0aW9uIHNlYXJjaENvbW1hbmQoZikge1xuICAgIHJldHVybiB2aWV3ID0+IHtcbiAgICAgICAgbGV0IHN0YXRlID0gdmlldy5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gc3RhdGUgJiYgc3RhdGUucXVlcnkuc3BlYy52YWxpZCA/IGYodmlldywgc3RhdGUpIDogb3BlblNlYXJjaFBhbmVsKHZpZXcpO1xuICAgIH07XG59XG4vKipcbk9wZW4gdGhlIHNlYXJjaCBwYW5lbCBpZiBpdCBpc24ndCBhbHJlYWR5IG9wZW4sIGFuZCBtb3ZlIHRoZVxuc2VsZWN0aW9uIHRvIHRoZSBmaXJzdCBtYXRjaCBhZnRlciB0aGUgY3VycmVudCBtYWluIHNlbGVjdGlvbi5cbldpbGwgd3JhcCBhcm91bmQgdG8gdGhlIHN0YXJ0IG9mIHRoZSBkb2N1bWVudCB3aGVuIGl0IHJlYWNoZXMgdGhlXG5lbmQuXG4qL1xuY29uc3QgZmluZE5leHQgPSAvKkBfX1BVUkVfXyovc2VhcmNoQ29tbWFuZCgodmlldywgeyBxdWVyeSB9KSA9PiB7XG4gICAgbGV0IHsgdG8gfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgbGV0IG5leHQgPSBxdWVyeS5uZXh0TWF0Y2godmlldy5zdGF0ZSwgdG8sIHRvKTtcbiAgICBpZiAoIW5leHQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc2VsZWN0aW9uID0gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShuZXh0LmZyb20sIG5leHQudG8pO1xuICAgIGxldCBjb25maWcgPSB2aWV3LnN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KTtcbiAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgc2VsZWN0aW9uLFxuICAgICAgICBlZmZlY3RzOiBbYW5ub3VuY2VNYXRjaCh2aWV3LCBuZXh0KSwgY29uZmlnLnNjcm9sbFRvTWF0Y2goc2VsZWN0aW9uLm1haW4sIHZpZXcpXSxcbiAgICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5zZWFyY2hcIlxuICAgIH0pO1xuICAgIHNlbGVjdFNlYXJjaElucHV0KHZpZXcpO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgcHJldmlvdXMgaW5zdGFuY2Ugb2YgdGhlIHNlYXJjaCBxdWVyeSxcbmJlZm9yZSB0aGUgY3VycmVudCBtYWluIHNlbGVjdGlvbi4gV2lsbCB3cmFwIHBhc3QgdGhlIHN0YXJ0XG5vZiB0aGUgZG9jdW1lbnQgdG8gc3RhcnQgc2VhcmNoaW5nIGF0IHRoZSBlbmQgYWdhaW4uXG4qL1xuY29uc3QgZmluZFByZXZpb3VzID0gLypAX19QVVJFX18qL3NlYXJjaENvbW1hbmQoKHZpZXcsIHsgcXVlcnkgfSkgPT4ge1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCB7IGZyb20gfSA9IHN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGxldCBwcmV2ID0gcXVlcnkucHJldk1hdGNoKHN0YXRlLCBmcm9tLCBmcm9tKTtcbiAgICBpZiAoIXByZXYpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc2VsZWN0aW9uID0gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShwcmV2LmZyb20sIHByZXYudG8pO1xuICAgIGxldCBjb25maWcgPSB2aWV3LnN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KTtcbiAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgc2VsZWN0aW9uLFxuICAgICAgICBlZmZlY3RzOiBbYW5ub3VuY2VNYXRjaCh2aWV3LCBwcmV2KSwgY29uZmlnLnNjcm9sbFRvTWF0Y2goc2VsZWN0aW9uLm1haW4sIHZpZXcpXSxcbiAgICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5zZWFyY2hcIlxuICAgIH0pO1xuICAgIHNlbGVjdFNlYXJjaElucHV0KHZpZXcpO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcblNlbGVjdCBhbGwgaW5zdGFuY2VzIG9mIHRoZSBzZWFyY2ggcXVlcnkuXG4qL1xuY29uc3Qgc2VsZWN0TWF0Y2hlcyA9IC8qQF9fUFVSRV9fKi9zZWFyY2hDb21tYW5kKCh2aWV3LCB7IHF1ZXJ5IH0pID0+IHtcbiAgICBsZXQgcmFuZ2VzID0gcXVlcnkubWF0Y2hBbGwodmlldy5zdGF0ZSwgMTAwMCk7XG4gICAgaWYgKCFyYW5nZXMgfHwgIXJhbmdlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcy5tYXAociA9PiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2Uoci5mcm9tLCByLnRvKSkpLFxuICAgICAgICB1c2VyRXZlbnQ6IFwic2VsZWN0LnNlYXJjaC5tYXRjaGVzXCJcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG5TZWxlY3QgYWxsIGluc3RhbmNlcyBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRleHQuXG4qL1xuY29uc3Qgc2VsZWN0U2VsZWN0aW9uTWF0Y2hlcyA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoc2VsLnJhbmdlcy5sZW5ndGggPiAxIHx8IHNlbC5tYWluLmVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHsgZnJvbSwgdG8gfSA9IHNlbC5tYWluO1xuICAgIGxldCByYW5nZXMgPSBbXSwgbWFpbiA9IDA7XG4gICAgZm9yIChsZXQgY3VyID0gbmV3IFNlYXJjaEN1cnNvcihzdGF0ZS5kb2MsIHN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKSk7ICFjdXIubmV4dCgpLmRvbmU7KSB7XG4gICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID4gMTAwMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGN1ci52YWx1ZS5mcm9tID09IGZyb20pXG4gICAgICAgICAgICBtYWluID0gcmFuZ2VzLmxlbmd0aDtcbiAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGN1ci52YWx1ZS5mcm9tLCBjdXIudmFsdWUudG8pKTtcbiAgICB9XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHtcbiAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcywgbWFpbiksXG4gICAgICAgIHVzZXJFdmVudDogXCJzZWxlY3Quc2VhcmNoLm1hdGNoZXNcIlxuICAgIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblJlcGxhY2UgdGhlIGN1cnJlbnQgbWF0Y2ggb2YgdGhlIHNlYXJjaCBxdWVyeS5cbiovXG5jb25zdCByZXBsYWNlTmV4dCA9IC8qQF9fUFVSRV9fKi9zZWFyY2hDb21tYW5kKCh2aWV3LCB7IHF1ZXJ5IH0pID0+IHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgeyBmcm9tLCB0byB9ID0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IG5leHQgPSBxdWVyeS5uZXh0TWF0Y2goc3RhdGUsIGZyb20sIGZyb20pO1xuICAgIGlmICghbmV4dClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gW10sIHNlbGVjdGlvbiwgcmVwbGFjZW1lbnQ7XG4gICAgbGV0IGVmZmVjdHMgPSBbXTtcbiAgICBpZiAobmV4dC5mcm9tID09IGZyb20gJiYgbmV4dC50byA9PSB0bykge1xuICAgICAgICByZXBsYWNlbWVudCA9IHN0YXRlLnRvVGV4dChxdWVyeS5nZXRSZXBsYWNlbWVudChuZXh0KSk7XG4gICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IG5leHQuZnJvbSwgdG86IG5leHQudG8sIGluc2VydDogcmVwbGFjZW1lbnQgfSk7XG4gICAgICAgIG5leHQgPSBxdWVyeS5uZXh0TWF0Y2goc3RhdGUsIG5leHQuZnJvbSwgbmV4dC50byk7XG4gICAgICAgIGVmZmVjdHMucHVzaChFZGl0b3JWaWV3LmFubm91bmNlLm9mKHN0YXRlLnBocmFzZShcInJlcGxhY2VkIG1hdGNoIG9uIGxpbmUgJFwiLCBzdGF0ZS5kb2MubGluZUF0KGZyb20pLm51bWJlcikgKyBcIi5cIikpO1xuICAgIH1cbiAgICBpZiAobmV4dCkge1xuICAgICAgICBsZXQgb2ZmID0gY2hhbmdlcy5sZW5ndGggPT0gMCB8fCBjaGFuZ2VzWzBdLmZyb20gPj0gbmV4dC50byA/IDAgOiBuZXh0LnRvIC0gbmV4dC5mcm9tIC0gcmVwbGFjZW1lbnQubGVuZ3RoO1xuICAgICAgICBzZWxlY3Rpb24gPSBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKG5leHQuZnJvbSAtIG9mZiwgbmV4dC50byAtIG9mZik7XG4gICAgICAgIGVmZmVjdHMucHVzaChhbm5vdW5jZU1hdGNoKHZpZXcsIG5leHQpKTtcbiAgICAgICAgZWZmZWN0cy5wdXNoKHN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KS5zY3JvbGxUb01hdGNoKHNlbGVjdGlvbi5tYWluLCB2aWV3KSk7XG4gICAgfVxuICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBjaGFuZ2VzLCBzZWxlY3Rpb24sIGVmZmVjdHMsXG4gICAgICAgIHVzZXJFdmVudDogXCJpbnB1dC5yZXBsYWNlXCJcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG5SZXBsYWNlIGFsbCBpbnN0YW5jZXMgb2YgdGhlIHNlYXJjaCBxdWVyeSB3aXRoIHRoZSBnaXZlblxucmVwbGFjZW1lbnQuXG4qL1xuY29uc3QgcmVwbGFjZUFsbCA9IC8qQF9fUFVSRV9fKi9zZWFyY2hDb21tYW5kKCh2aWV3LCB7IHF1ZXJ5IH0pID0+IHtcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gcXVlcnkubWF0Y2hBbGwodmlldy5zdGF0ZSwgMWU5KS5tYXAobWF0Y2ggPT4ge1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gbWF0Y2g7XG4gICAgICAgIHJldHVybiB7IGZyb20sIHRvLCBpbnNlcnQ6IHF1ZXJ5LmdldFJlcGxhY2VtZW50KG1hdGNoKSB9O1xuICAgIH0pO1xuICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYW5ub3VuY2VUZXh0ID0gdmlldy5zdGF0ZS5waHJhc2UoXCJyZXBsYWNlZCAkIG1hdGNoZXNcIiwgY2hhbmdlcy5sZW5ndGgpICsgXCIuXCI7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIGNoYW5nZXMsXG4gICAgICAgIGVmZmVjdHM6IEVkaXRvclZpZXcuYW5ub3VuY2Uub2YoYW5ub3VuY2VUZXh0KSxcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnJlcGxhY2UuYWxsXCJcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuZnVuY3Rpb24gY3JlYXRlU2VhcmNoUGFuZWwodmlldykge1xuICAgIHJldHVybiB2aWV3LnN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KS5jcmVhdGVQYW5lbCh2aWV3KTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRRdWVyeShzdGF0ZSwgZmFsbGJhY2spIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBsZXQgc2VsVGV4dCA9IHNlbC5lbXB0eSB8fCBzZWwudG8gPiBzZWwuZnJvbSArIDEwMCA/IFwiXCIgOiBzdGF0ZS5zbGljZURvYyhzZWwuZnJvbSwgc2VsLnRvKTtcbiAgICBpZiAoZmFsbGJhY2sgJiYgIXNlbFRleHQpXG4gICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICBsZXQgY29uZmlnID0gc3RhdGUuZmFjZXQoc2VhcmNoQ29uZmlnRmFjZXQpO1xuICAgIHJldHVybiBuZXcgU2VhcmNoUXVlcnkoe1xuICAgICAgICBzZWFyY2g6ICgoX2EgPSBmYWxsYmFjayA9PT0gbnVsbCB8fCBmYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmFsbGJhY2subGl0ZXJhbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29uZmlnLmxpdGVyYWwpID8gc2VsVGV4dCA6IHNlbFRleHQucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIiksXG4gICAgICAgIGNhc2VTZW5zaXRpdmU6IChfYiA9IGZhbGxiYWNrID09PSBudWxsIHx8IGZhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYWxsYmFjay5jYXNlU2Vuc2l0aXZlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBjb25maWcuY2FzZVNlbnNpdGl2ZSxcbiAgICAgICAgbGl0ZXJhbDogKF9jID0gZmFsbGJhY2sgPT09IG51bGwgfHwgZmFsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZhbGxiYWNrLmxpdGVyYWwpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGNvbmZpZy5saXRlcmFsLFxuICAgICAgICByZWdleHA6IChfZCA9IGZhbGxiYWNrID09PSBudWxsIHx8IGZhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYWxsYmFjay5yZWdleHApICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGNvbmZpZy5yZWdleHAsXG4gICAgICAgIHdob2xlV29yZDogKF9lID0gZmFsbGJhY2sgPT09IG51bGwgfHwgZmFsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZhbGxiYWNrLndob2xlV29yZCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogY29uZmlnLndob2xlV29yZFxuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0U2VhcmNoSW5wdXQodmlldykge1xuICAgIGxldCBwYW5lbCA9IGdldFBhbmVsKHZpZXcsIGNyZWF0ZVNlYXJjaFBhbmVsKTtcbiAgICByZXR1cm4gcGFuZWwgJiYgcGFuZWwuZG9tLnF1ZXJ5U2VsZWN0b3IoXCJbbWFpbi1maWVsZF1cIik7XG59XG5mdW5jdGlvbiBzZWxlY3RTZWFyY2hJbnB1dCh2aWV3KSB7XG4gICAgbGV0IGlucHV0ID0gZ2V0U2VhcmNoSW5wdXQodmlldyk7XG4gICAgaWYgKGlucHV0ICYmIGlucHV0ID09IHZpZXcucm9vdC5hY3RpdmVFbGVtZW50KVxuICAgICAgICBpbnB1dC5zZWxlY3QoKTtcbn1cbi8qKlxuTWFrZSBzdXJlIHRoZSBzZWFyY2ggcGFuZWwgaXMgb3BlbiBhbmQgZm9jdXNlZC5cbiovXG5jb25zdCBvcGVuU2VhcmNoUGFuZWwgPSB2aWV3ID0+IHtcbiAgICBsZXQgc3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKHN0YXRlICYmIHN0YXRlLnBhbmVsKSB7XG4gICAgICAgIGxldCBzZWFyY2hJbnB1dCA9IGdldFNlYXJjaElucHV0KHZpZXcpO1xuICAgICAgICBpZiAoc2VhcmNoSW5wdXQgJiYgc2VhcmNoSW5wdXQgIT0gdmlldy5yb290LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IGRlZmF1bHRRdWVyeSh2aWV3LnN0YXRlLCBzdGF0ZS5xdWVyeS5zcGVjKTtcbiAgICAgICAgICAgIGlmIChxdWVyeS52YWxpZClcbiAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0U2VhcmNoUXVlcnkub2YocXVlcnkpIH0pO1xuICAgICAgICAgICAgc2VhcmNoSW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgIHNlYXJjaElucHV0LnNlbGVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogW1xuICAgICAgICAgICAgICAgIHRvZ2dsZVBhbmVsLm9mKHRydWUpLFxuICAgICAgICAgICAgICAgIHN0YXRlID8gc2V0U2VhcmNoUXVlcnkub2YoZGVmYXVsdFF1ZXJ5KHZpZXcuc3RhdGUsIHN0YXRlLnF1ZXJ5LnNwZWMpKSA6IFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihzZWFyY2hFeHRlbnNpb25zKVxuICAgICAgICAgICAgXSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5DbG9zZSB0aGUgc2VhcmNoIHBhbmVsLlxuKi9cbmNvbnN0IGNsb3NlU2VhcmNoUGFuZWwgPSB2aWV3ID0+IHtcbiAgICBsZXQgc3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUucGFuZWwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgcGFuZWwgPSBnZXRQYW5lbCh2aWV3LCBjcmVhdGVTZWFyY2hQYW5lbCk7XG4gICAgaWYgKHBhbmVsICYmIHBhbmVsLmRvbS5jb250YWlucyh2aWV3LnJvb3QuYWN0aXZlRWxlbWVudCkpXG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdG9nZ2xlUGFuZWwub2YoZmFsc2UpIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuRGVmYXVsdCBzZWFyY2gtcmVsYXRlZCBrZXkgYmluZGluZ3MuXG5cbiAtIE1vZC1mOiBbYG9wZW5TZWFyY2hQYW5lbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLm9wZW5TZWFyY2hQYW5lbClcbiAtIEYzLCBNb2QtZzogW2BmaW5kTmV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLmZpbmROZXh0KVxuIC0gU2hpZnQtRjMsIFNoaWZ0LU1vZC1nOiBbYGZpbmRQcmV2aW91c2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLmZpbmRQcmV2aW91cylcbiAtIE1vZC1BbHQtZzogW2Bnb3RvTGluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLmdvdG9MaW5lKVxuIC0gTW9kLWQ6IFtgc2VsZWN0TmV4dE9jY3VycmVuY2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5zZWxlY3ROZXh0T2NjdXJyZW5jZSlcbiovXG5jb25zdCBzZWFyY2hLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiTW9kLWZcIiwgcnVuOiBvcGVuU2VhcmNoUGFuZWwsIHNjb3BlOiBcImVkaXRvciBzZWFyY2gtcGFuZWxcIiB9LFxuICAgIHsga2V5OiBcIkYzXCIsIHJ1bjogZmluZE5leHQsIHNoaWZ0OiBmaW5kUHJldmlvdXMsIHNjb3BlOiBcImVkaXRvciBzZWFyY2gtcGFuZWxcIiwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtZ1wiLCBydW46IGZpbmROZXh0LCBzaGlmdDogZmluZFByZXZpb3VzLCBzY29wZTogXCJlZGl0b3Igc2VhcmNoLXBhbmVsXCIsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiRXNjYXBlXCIsIHJ1bjogY2xvc2VTZWFyY2hQYW5lbCwgc2NvcGU6IFwiZWRpdG9yIHNlYXJjaC1wYW5lbFwiIH0sXG4gICAgeyBrZXk6IFwiTW9kLVNoaWZ0LWxcIiwgcnVuOiBzZWxlY3RTZWxlY3Rpb25NYXRjaGVzIH0sXG4gICAgeyBrZXk6IFwiTW9kLUFsdC1nXCIsIHJ1bjogZ290b0xpbmUgfSxcbiAgICB7IGtleTogXCJNb2QtZFwiLCBydW46IHNlbGVjdE5leHRPY2N1cnJlbmNlLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuXTtcbmNsYXNzIFNlYXJjaFBhbmVsIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMucXVlcnkgPSB2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlKS5xdWVyeS5zcGVjO1xuICAgICAgICB0aGlzLmNvbW1pdCA9IHRoaXMuY29tbWl0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2VhcmNoRmllbGQgPSBlbHQoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogcXVlcnkuc2VhcmNoLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6IHBocmFzZSh2aWV3LCBcIkZpbmRcIiksXG4gICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogcGhyYXNlKHZpZXcsIFwiRmluZFwiKSxcbiAgICAgICAgICAgIGNsYXNzOiBcImNtLXRleHRmaWVsZFwiLFxuICAgICAgICAgICAgbmFtZTogXCJzZWFyY2hcIixcbiAgICAgICAgICAgIGZvcm06IFwiXCIsXG4gICAgICAgICAgICBcIm1haW4tZmllbGRcIjogXCJ0cnVlXCIsXG4gICAgICAgICAgICBvbmNoYW5nZTogdGhpcy5jb21taXQsXG4gICAgICAgICAgICBvbmtleXVwOiB0aGlzLmNvbW1pdFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZXBsYWNlRmllbGQgPSBlbHQoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogcXVlcnkucmVwbGFjZSxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBwaHJhc2UodmlldywgXCJSZXBsYWNlXCIpLFxuICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHBocmFzZSh2aWV3LCBcIlJlcGxhY2VcIiksXG4gICAgICAgICAgICBjbGFzczogXCJjbS10ZXh0ZmllbGRcIixcbiAgICAgICAgICAgIG5hbWU6IFwicmVwbGFjZVwiLFxuICAgICAgICAgICAgZm9ybTogXCJcIixcbiAgICAgICAgICAgIG9uY2hhbmdlOiB0aGlzLmNvbW1pdCxcbiAgICAgICAgICAgIG9ua2V5dXA6IHRoaXMuY29tbWl0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhc2VGaWVsZCA9IGVsdChcImlucHV0XCIsIHtcbiAgICAgICAgICAgIHR5cGU6IFwiY2hlY2tib3hcIixcbiAgICAgICAgICAgIG5hbWU6IFwiY2FzZVwiLFxuICAgICAgICAgICAgZm9ybTogXCJcIixcbiAgICAgICAgICAgIGNoZWNrZWQ6IHF1ZXJ5LmNhc2VTZW5zaXRpdmUsXG4gICAgICAgICAgICBvbmNoYW5nZTogdGhpcy5jb21taXRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVGaWVsZCA9IGVsdChcImlucHV0XCIsIHtcbiAgICAgICAgICAgIHR5cGU6IFwiY2hlY2tib3hcIixcbiAgICAgICAgICAgIG5hbWU6IFwicmVcIixcbiAgICAgICAgICAgIGZvcm06IFwiXCIsXG4gICAgICAgICAgICBjaGVja2VkOiBxdWVyeS5yZWdleHAsXG4gICAgICAgICAgICBvbmNoYW5nZTogdGhpcy5jb21taXRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud29yZEZpZWxkID0gZWx0KFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgdHlwZTogXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgbmFtZTogXCJ3b3JkXCIsXG4gICAgICAgICAgICBmb3JtOiBcIlwiLFxuICAgICAgICAgICAgY2hlY2tlZDogcXVlcnkud2hvbGVXb3JkLFxuICAgICAgICAgICAgb25jaGFuZ2U6IHRoaXMuY29tbWl0XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBidXR0b24obmFtZSwgb25jbGljaywgY29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsdChcImJ1dHRvblwiLCB7IGNsYXNzOiBcImNtLWJ1dHRvblwiLCBuYW1lLCBvbmNsaWNrLCB0eXBlOiBcImJ1dHRvblwiIH0sIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9tID0gZWx0KFwiZGl2XCIsIHsgb25rZXlkb3duOiAoZSkgPT4gdGhpcy5rZXlkb3duKGUpLCBjbGFzczogXCJjbS1zZWFyY2hcIiB9LCBbXG4gICAgICAgICAgICB0aGlzLnNlYXJjaEZpZWxkLFxuICAgICAgICAgICAgYnV0dG9uKFwibmV4dFwiLCAoKSA9PiBmaW5kTmV4dCh2aWV3KSwgW3BocmFzZSh2aWV3LCBcIm5leHRcIildKSxcbiAgICAgICAgICAgIGJ1dHRvbihcInByZXZcIiwgKCkgPT4gZmluZFByZXZpb3VzKHZpZXcpLCBbcGhyYXNlKHZpZXcsIFwicHJldmlvdXNcIildKSxcbiAgICAgICAgICAgIGJ1dHRvbihcInNlbGVjdFwiLCAoKSA9PiBzZWxlY3RNYXRjaGVzKHZpZXcpLCBbcGhyYXNlKHZpZXcsIFwiYWxsXCIpXSksXG4gICAgICAgICAgICBlbHQoXCJsYWJlbFwiLCBudWxsLCBbdGhpcy5jYXNlRmllbGQsIHBocmFzZSh2aWV3LCBcIm1hdGNoIGNhc2VcIildKSxcbiAgICAgICAgICAgIGVsdChcImxhYmVsXCIsIG51bGwsIFt0aGlzLnJlRmllbGQsIHBocmFzZSh2aWV3LCBcInJlZ2V4cFwiKV0pLFxuICAgICAgICAgICAgZWx0KFwibGFiZWxcIiwgbnVsbCwgW3RoaXMud29yZEZpZWxkLCBwaHJhc2UodmlldywgXCJieSB3b3JkXCIpXSksXG4gICAgICAgICAgICAuLi52aWV3LnN0YXRlLnJlYWRPbmx5ID8gW10gOiBbXG4gICAgICAgICAgICAgICAgZWx0KFwiYnJcIiksXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlRmllbGQsXG4gICAgICAgICAgICAgICAgYnV0dG9uKFwicmVwbGFjZVwiLCAoKSA9PiByZXBsYWNlTmV4dCh2aWV3KSwgW3BocmFzZSh2aWV3LCBcInJlcGxhY2VcIildKSxcbiAgICAgICAgICAgICAgICBidXR0b24oXCJyZXBsYWNlQWxsXCIsICgpID0+IHJlcGxhY2VBbGwodmlldyksIFtwaHJhc2UodmlldywgXCJyZXBsYWNlIGFsbFwiKV0pXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZWx0KFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImNsb3NlXCIsXG4gICAgICAgICAgICAgICAgb25jbGljazogKCkgPT4gY2xvc2VTZWFyY2hQYW5lbCh2aWV3KSxcbiAgICAgICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogcGhyYXNlKHZpZXcsIFwiY2xvc2VcIiksXG4gICAgICAgICAgICAgICAgdHlwZTogXCJidXR0b25cIlxuICAgICAgICAgICAgfSwgW1wiw5dcIl0pXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjb21taXQoKSB7XG4gICAgICAgIGxldCBxdWVyeSA9IG5ldyBTZWFyY2hRdWVyeSh7XG4gICAgICAgICAgICBzZWFyY2g6IHRoaXMuc2VhcmNoRmllbGQudmFsdWUsXG4gICAgICAgICAgICBjYXNlU2Vuc2l0aXZlOiB0aGlzLmNhc2VGaWVsZC5jaGVja2VkLFxuICAgICAgICAgICAgcmVnZXhwOiB0aGlzLnJlRmllbGQuY2hlY2tlZCxcbiAgICAgICAgICAgIHdob2xlV29yZDogdGhpcy53b3JkRmllbGQuY2hlY2tlZCxcbiAgICAgICAgICAgIHJlcGxhY2U6IHRoaXMucmVwbGFjZUZpZWxkLnZhbHVlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFxdWVyeS5lcSh0aGlzLnF1ZXJ5KSkge1xuICAgICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0U2VhcmNoUXVlcnkub2YocXVlcnkpIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGtleWRvd24oZSkge1xuICAgICAgICBpZiAocnVuU2NvcGVIYW5kbGVycyh0aGlzLnZpZXcsIGUsIFwic2VhcmNoLXBhbmVsXCIpKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZS5rZXlDb2RlID09IDEzICYmIGUudGFyZ2V0ID09IHRoaXMuc2VhcmNoRmllbGQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIChlLnNoaWZ0S2V5ID8gZmluZFByZXZpb3VzIDogZmluZE5leHQpKHRoaXMudmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZS5rZXlDb2RlID09IDEzICYmIGUudGFyZ2V0ID09IHRoaXMucmVwbGFjZUZpZWxkKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXBsYWNlTmV4dCh0aGlzLnZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgZm9yIChsZXQgdHIgb2YgdXBkYXRlLnRyYW5zYWN0aW9ucylcbiAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXRTZWFyY2hRdWVyeSkgJiYgIWVmZmVjdC52YWx1ZS5lcSh0aGlzLnF1ZXJ5KSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRRdWVyeShlZmZlY3QudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBzZXRRdWVyeShxdWVyeSkge1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIHRoaXMuc2VhcmNoRmllbGQudmFsdWUgPSBxdWVyeS5zZWFyY2g7XG4gICAgICAgIHRoaXMucmVwbGFjZUZpZWxkLnZhbHVlID0gcXVlcnkucmVwbGFjZTtcbiAgICAgICAgdGhpcy5jYXNlRmllbGQuY2hlY2tlZCA9IHF1ZXJ5LmNhc2VTZW5zaXRpdmU7XG4gICAgICAgIHRoaXMucmVGaWVsZC5jaGVja2VkID0gcXVlcnkucmVnZXhwO1xuICAgICAgICB0aGlzLndvcmRGaWVsZC5jaGVja2VkID0gcXVlcnkud2hvbGVXb3JkO1xuICAgIH1cbiAgICBtb3VudCgpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hGaWVsZC5zZWxlY3QoKTtcbiAgICB9XG4gICAgZ2V0IHBvcygpIHsgcmV0dXJuIDgwOyB9XG4gICAgZ2V0IHRvcCgpIHsgcmV0dXJuIHRoaXMudmlldy5zdGF0ZS5mYWNldChzZWFyY2hDb25maWdGYWNldCkudG9wOyB9XG59XG5mdW5jdGlvbiBwaHJhc2UodmlldywgcGhyYXNlKSB7IHJldHVybiB2aWV3LnN0YXRlLnBocmFzZShwaHJhc2UpOyB9XG5jb25zdCBBbm5vdW5jZU1hcmdpbiA9IDMwO1xuY29uc3QgQnJlYWsgPSAvW1xcc1xcLiw6Oz8hXS87XG5mdW5jdGlvbiBhbm5vdW5jZU1hdGNoKHZpZXcsIHsgZnJvbSwgdG8gfSkge1xuICAgIGxldCBsaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KGZyb20pLCBsaW5lRW5kID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHRvKS50bztcbiAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChsaW5lLmZyb20sIGZyb20gLSBBbm5vdW5jZU1hcmdpbiksIGVuZCA9IE1hdGgubWluKGxpbmVFbmQsIHRvICsgQW5ub3VuY2VNYXJnaW4pO1xuICAgIGxldCB0ZXh0ID0gdmlldy5zdGF0ZS5zbGljZURvYyhzdGFydCwgZW5kKTtcbiAgICBpZiAoc3RhcnQgIT0gbGluZS5mcm9tKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQW5ub3VuY2VNYXJnaW47IGkrKylcbiAgICAgICAgICAgIGlmICghQnJlYWsudGVzdCh0ZXh0W2kgKyAxXSkgJiYgQnJlYWsudGVzdCh0ZXh0W2ldKSkge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKGkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5kICE9IGxpbmVFbmQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRleHQubGVuZ3RoIC0gMTsgaSA+IHRleHQubGVuZ3RoIC0gQW5ub3VuY2VNYXJnaW47IGktLSlcbiAgICAgICAgICAgIGlmICghQnJlYWsudGVzdCh0ZXh0W2kgLSAxXSkgJiYgQnJlYWsudGVzdCh0ZXh0W2ldKSkge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gRWRpdG9yVmlldy5hbm5vdW5jZS5vZihgJHt2aWV3LnN0YXRlLnBocmFzZShcImN1cnJlbnQgbWF0Y2hcIil9LiAke3RleHR9ICR7dmlldy5zdGF0ZS5waHJhc2UoXCJvbiBsaW5lXCIpfSAke2xpbmUubnVtYmVyfS5gKTtcbn1cbmNvbnN0IGJhc2VUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tcGFuZWwuY20tc2VhcmNoXCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIycHggNnB4IDRweFwiLFxuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICBcIiYgW25hbWU9Y2xvc2VdXCI6IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICB0b3A6IFwiMFwiLFxuICAgICAgICAgICAgcmlnaHQ6IFwiNHB4XCIsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiaW5oZXJpdFwiLFxuICAgICAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgICAgIGZvbnQ6IFwiaW5oZXJpdFwiLFxuICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgIG1hcmdpbjogMFxuICAgICAgICB9LFxuICAgICAgICBcIiYgaW5wdXQsICYgYnV0dG9uLCAmIGxhYmVsXCI6IHtcbiAgICAgICAgICAgIG1hcmdpbjogXCIuMmVtIC42ZW0gLjJlbSAwXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCImIGlucHV0W3R5cGU9Y2hlY2tib3hdXCI6IHtcbiAgICAgICAgICAgIG1hcmdpblJpZ2h0OiBcIi4yZW1cIlxuICAgICAgICB9LFxuICAgICAgICBcIiYgbGFiZWxcIjoge1xuICAgICAgICAgICAgZm9udFNpemU6IFwiODAlXCIsXG4gICAgICAgICAgICB3aGl0ZVNwYWNlOiBcInByZVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1zZWFyY2hNYXRjaFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmZmZjAwNTRcIiB9LFxuICAgIFwiJmRhcmsgLmNtLXNlYXJjaE1hdGNoXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiMwMGZmZmY4YVwiIH0sXG4gICAgXCImbGlnaHQgLmNtLXNlYXJjaE1hdGNoLXNlbGVjdGVkXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNmZjZhMDA1NFwiIH0sXG4gICAgXCImZGFyayAuY20tc2VhcmNoTWF0Y2gtc2VsZWN0ZWRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmMDBmZjhhXCIgfVxufSk7XG5jb25zdCBzZWFyY2hFeHRlbnNpb25zID0gW1xuICAgIHNlYXJjaFN0YXRlLFxuICAgIC8qQF9fUFVSRV9fKi9QcmVjLmxvdyhzZWFyY2hIaWdobGlnaHRlciksXG4gICAgYmFzZVRoZW1lXG5dO1xuXG5leHBvcnQgeyBSZWdFeHBDdXJzb3IsIFNlYXJjaEN1cnNvciwgU2VhcmNoUXVlcnksIGNsb3NlU2VhcmNoUGFuZWwsIGZpbmROZXh0LCBmaW5kUHJldmlvdXMsIGdldFNlYXJjaFF1ZXJ5LCBnb3RvTGluZSwgaGlnaGxpZ2h0U2VsZWN0aW9uTWF0Y2hlcywgb3BlblNlYXJjaFBhbmVsLCByZXBsYWNlQWxsLCByZXBsYWNlTmV4dCwgc2VhcmNoLCBzZWFyY2hLZXltYXAsIHNlYXJjaFBhbmVsT3Blbiwgc2VsZWN0TWF0Y2hlcywgc2VsZWN0TmV4dE9jY3VycmVuY2UsIHNlbGVjdFNlbGVjdGlvbk1hdGNoZXMsIHNldFNlYXJjaFF1ZXJ5IH07XG4iXSwibmFtZXMiOlsic2hvd1BhbmVsIiwiRWRpdG9yVmlldyIsImdldFBhbmVsIiwiRGVjb3JhdGlvbiIsIlZpZXdQbHVnaW4iLCJydW5TY29wZUhhbmRsZXJzIiwiY29kZVBvaW50QXQiLCJmcm9tQ29kZVBvaW50IiwiY29kZVBvaW50U2l6ZSIsIlN0YXRlRWZmZWN0IiwiU3RhdGVGaWVsZCIsIkVkaXRvclNlbGVjdGlvbiIsIkZhY2V0IiwiY29tYmluZUNvbmZpZyIsIkNoYXJDYXRlZ29yeSIsIlJhbmdlU2V0QnVpbGRlciIsIlByZWMiLCJFZGl0b3JTdGF0ZSIsImZpbmRDbHVzdGVyQnJlYWsiLCJlbHQiLCJiYXNpY05vcm1hbGl6ZSIsIlN0cmluZyIsInByb3RvdHlwZSIsIm5vcm1hbGl6ZSIsIngiLCJTZWFyY2hDdXJzb3IiLCJjb25zdHJ1Y3RvciIsInRleHQiLCJxdWVyeSIsImZyb20iLCJ0byIsImxlbmd0aCIsInRlc3QiLCJ2YWx1ZSIsImRvbmUiLCJtYXRjaGVzIiwiYnVmZmVyIiwiYnVmZmVyUG9zIiwiaXRlciIsIml0ZXJSYW5nZSIsImJ1ZmZlclN0YXJ0IiwicGVlayIsIm5leHQiLCJwb3AiLCJuZXh0T3ZlcmxhcHBpbmciLCJzdHIiLCJzdGFydCIsIm5vcm0iLCJpIiwicG9zIiwiY29kZSIsImNoYXJDb2RlQXQiLCJtYXRjaCIsImluZGV4Iiwia2VlcCIsInNwbGljZSIsInB1c2giLCJTeW1ib2wiLCJpdGVyYXRvciIsImVtcHR5IiwiZXhlYyIsImJhc2VGbGFncyIsInVuaWNvZGUiLCJSZWdFeHBDdXJzb3IiLCJvcHRpb25zIiwiY3VyTGluZSIsIk11bHRpbGluZVJlZ0V4cEN1cnNvciIsInJlIiwiUmVnRXhwIiwiaWdub3JlQ2FzZSIsInN0YXJ0TGluZSIsImxpbmVBdCIsImN1ckxpbmVTdGFydCIsIm1hdGNoUG9zIiwidG9DaGFyRW5kIiwiZ2V0TGluZSIsInNraXAiLCJsaW5lQnJlYWsiLCJzbGljZSIsIm5leHRMaW5lIiwib2ZmIiwibGFzdEluZGV4IiwiZmxhdHRlbmVkIiwiV2Vha01hcCIsIkZsYXR0ZW5lZERvYyIsImdldCIsImRvYyIsImNhY2hlZCIsImZsYXQiLCJzbGljZVN0cmluZyIsInNldCIsImNhY2hlZEZyb20iLCJjaHVua0VuZCIsInZhbGlkUmVnRXhwIiwic291cmNlIiwiX2EiLCJsaW5lIiwiY3JlYXRlTGluZURpYWxvZyIsInZpZXciLCJzdGF0ZSIsInNlbGVjdGlvbiIsIm1haW4iLCJoZWFkIiwibnVtYmVyIiwiaW5wdXQiLCJjbGFzcyIsIm5hbWUiLCJkb20iLCJvbmtleWRvd24iLCJldmVudCIsImtleUNvZGUiLCJwcmV2ZW50RGVmYXVsdCIsImRpc3BhdGNoIiwiZWZmZWN0cyIsImRpYWxvZ0VmZmVjdCIsIm9mIiwiZm9jdXMiLCJnbyIsIm9uc3VibWl0IiwicGhyYXNlIiwidHlwZSIsInNpZ24iLCJsbiIsImNsIiwicGVyY2VudCIsImNvbCIsInBjIiwibGluZXMiLCJNYXRoIiwicm91bmQiLCJkb2NMaW5lIiwibWF4IiwibWluIiwiY3Vyc29yIiwic2Nyb2xsSW50b1ZpZXciLCJ5IiwiZGVmaW5lIiwiZGlhbG9nRmllbGQiLCJjcmVhdGUiLCJ1cGRhdGUiLCJ0ciIsImUiLCJpcyIsInByb3ZpZGUiLCJmIiwidmFsIiwiZ290b0xpbmUiLCJwYW5lbCIsImZpZWxkIiwiYXBwZW5kQ29uZmlnIiwiYmFzZVRoZW1lJDEiLCJxdWVyeVNlbGVjdG9yIiwic2VsZWN0IiwiYmFzZVRoZW1lIiwicGFkZGluZyIsImZvbnRTaXplIiwiZGVmYXVsdEhpZ2hsaWdodE9wdGlvbnMiLCJoaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yIiwibWluU2VsZWN0aW9uTGVuZ3RoIiwibWF4TWF0Y2hlcyIsIndob2xlV29yZHMiLCJoaWdobGlnaHRDb25maWciLCJjb21iaW5lIiwiYSIsImIiLCJoaWdobGlnaHRTZWxlY3Rpb25NYXRjaGVzIiwiZXh0IiwiZGVmYXVsdFRoZW1lIiwibWF0Y2hIaWdobGlnaHRlciIsIm1hdGNoRGVjbyIsIm1hcmsiLCJtYWluTWF0Y2hEZWNvIiwiaW5zaWRlV29yZEJvdW5kYXJpZXMiLCJjaGVjayIsInNsaWNlRG9jIiwiV29yZCIsImluc2lkZVdvcmQiLCJmcm9tQ2xhc3MiLCJkZWNvcmF0aW9ucyIsImdldERlY28iLCJzZWxlY3Rpb25TZXQiLCJkb2NDaGFuZ2VkIiwidmlld3BvcnRDaGFuZ2VkIiwiY29uZiIsImZhY2V0Iiwic2VsIiwicmFuZ2VzIiwibm9uZSIsInJhbmdlIiwid29yZCIsIndvcmRBdCIsImNoYXJDYXRlZ29yaXplciIsImxlbiIsInRyaW0iLCJkZWNvIiwicGFydCIsInZpc2libGVSYW5nZXMiLCJ2IiwiYmFja2dyb3VuZENvbG9yIiwic2VsZWN0V29yZCIsIm5ld1NlbCIsIm1hcCIsIm1haW5JbmRleCIsImVxIiwiZmluZE5leHRPY2N1cnJlbmNlIiwiZnVsbFdvcmQiLCJjeWNsZWQiLCJzb21lIiwiciIsInNlbGVjdE5leHRPY2N1cnJlbmNlIiwic2VhcmNoZWRUZXh0IiwiYWRkUmFuZ2UiLCJzZWFyY2hDb25maWdGYWNldCIsImNvbmZpZ3MiLCJ0b3AiLCJjYXNlU2Vuc2l0aXZlIiwibGl0ZXJhbCIsInJlZ2V4cCIsIndob2xlV29yZCIsImNyZWF0ZVBhbmVsIiwiU2VhcmNoUGFuZWwiLCJzY3JvbGxUb01hdGNoIiwic2VhcmNoIiwiY29uZmlnIiwic2VhcmNoRXh0ZW5zaW9ucyIsIlNlYXJjaFF1ZXJ5IiwicmVwbGFjZSIsInZhbGlkIiwidW5xdW90ZWQiLCJ1bnF1b3RlIiwiXyIsImNoIiwib3RoZXIiLCJSZWdFeHBRdWVyeSIsIlN0cmluZ1F1ZXJ5IiwiZ2V0Q3Vyc29yIiwic3QiLCJyZWdleHBDdXJzb3IiLCJzdHJpbmdDdXJzb3IiLCJRdWVyeVR5cGUiLCJzcGVjIiwidW5kZWZpbmVkIiwidG9Mb3dlckNhc2UiLCJzdHJpbmdXb3JkVGVzdCIsImNhdGVnb3JpemVyIiwiYnVmIiwiYnVmUG9zIiwiY2hhckJlZm9yZSIsImNoYXJBZnRlciIsIm5leHRNYXRjaCIsImN1ckZyb20iLCJjdXJUbyIsInByZXZNYXRjaEluUmFuZ2UiLCJwcmV2TWF0Y2giLCJnZXRSZXBsYWNlbWVudCIsIl9yZXN1bHQiLCJtYXRjaEFsbCIsImxpbWl0IiwiaGlnaGxpZ2h0IiwiYWRkIiwicmVnZXhwV29yZFRlc3QiLCJfZnJvbSIsIl90byIsInNpemUiLCJyZXN1bHQiLCJtIiwic2V0U2VhcmNoUXVlcnkiLCJ0b2dnbGVQYW5lbCIsInNlYXJjaFN0YXRlIiwiU2VhcmNoU3RhdGUiLCJkZWZhdWx0UXVlcnkiLCJlZmZlY3QiLCJjcmVhdGVTZWFyY2hQYW5lbCIsImdldFNlYXJjaFF1ZXJ5IiwiY3VyU3RhdGUiLCJzZWFyY2hQYW5lbE9wZW4iLCJtYXRjaE1hcmsiLCJzZWxlY3RlZE1hdGNoTWFyayIsInNlYXJjaEhpZ2hsaWdodGVyIiwic3RhcnRTdGF0ZSIsImJ1aWxkZXIiLCJsIiwic2VsZWN0ZWQiLCJmaW5pc2giLCJzZWFyY2hDb21tYW5kIiwib3BlblNlYXJjaFBhbmVsIiwiZmluZE5leHQiLCJzaW5nbGUiLCJhbm5vdW5jZU1hdGNoIiwidXNlckV2ZW50Iiwic2VsZWN0U2VhcmNoSW5wdXQiLCJmaW5kUHJldmlvdXMiLCJwcmV2Iiwic2VsZWN0TWF0Y2hlcyIsInNlbGVjdFNlbGVjdGlvbk1hdGNoZXMiLCJjdXIiLCJyZXBsYWNlTmV4dCIsInJlYWRPbmx5IiwiY2hhbmdlcyIsInJlcGxhY2VtZW50IiwidG9UZXh0IiwiaW5zZXJ0IiwiYW5ub3VuY2UiLCJyZXBsYWNlQWxsIiwiYW5ub3VuY2VUZXh0IiwiZmFsbGJhY2siLCJfYiIsIl9jIiwiX2QiLCJfZSIsInNlbFRleHQiLCJnZXRTZWFyY2hJbnB1dCIsInJvb3QiLCJhY3RpdmVFbGVtZW50Iiwic2VhcmNoSW5wdXQiLCJjbG9zZVNlYXJjaFBhbmVsIiwiY29udGFpbnMiLCJzZWFyY2hLZXltYXAiLCJrZXkiLCJydW4iLCJzY29wZSIsInNoaWZ0IiwiY29tbWl0IiwiYmluZCIsInNlYXJjaEZpZWxkIiwicGxhY2Vob2xkZXIiLCJmb3JtIiwib25jaGFuZ2UiLCJvbmtleXVwIiwicmVwbGFjZUZpZWxkIiwiY2FzZUZpZWxkIiwiY2hlY2tlZCIsInJlRmllbGQiLCJ3b3JkRmllbGQiLCJidXR0b24iLCJvbmNsaWNrIiwiY29udGVudCIsImtleWRvd24iLCJ0YXJnZXQiLCJzaGlmdEtleSIsInRyYW5zYWN0aW9ucyIsInNldFF1ZXJ5IiwibW91bnQiLCJBbm5vdW5jZU1hcmdpbiIsIkJyZWFrIiwibGluZUVuZCIsImVuZCIsInBvc2l0aW9uIiwicmlnaHQiLCJib3JkZXIiLCJmb250IiwibWFyZ2luIiwibWFyZ2luUmlnaHQiLCJ3aGl0ZVNwYWNlIiwibG93Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/search/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/state/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@codemirror/state/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Annotation: () => (/* binding */ Annotation),\n/* harmony export */   AnnotationType: () => (/* binding */ AnnotationType),\n/* harmony export */   ChangeDesc: () => (/* binding */ ChangeDesc),\n/* harmony export */   ChangeSet: () => (/* binding */ ChangeSet),\n/* harmony export */   CharCategory: () => (/* binding */ CharCategory),\n/* harmony export */   Compartment: () => (/* binding */ Compartment),\n/* harmony export */   EditorSelection: () => (/* binding */ EditorSelection),\n/* harmony export */   EditorState: () => (/* binding */ EditorState),\n/* harmony export */   Facet: () => (/* binding */ Facet),\n/* harmony export */   Line: () => (/* binding */ Line),\n/* harmony export */   MapMode: () => (/* binding */ MapMode),\n/* harmony export */   Prec: () => (/* binding */ Prec),\n/* harmony export */   Range: () => (/* binding */ Range),\n/* harmony export */   RangeSet: () => (/* binding */ RangeSet),\n/* harmony export */   RangeSetBuilder: () => (/* binding */ RangeSetBuilder),\n/* harmony export */   RangeValue: () => (/* binding */ RangeValue),\n/* harmony export */   SelectionRange: () => (/* binding */ SelectionRange),\n/* harmony export */   StateEffect: () => (/* binding */ StateEffect),\n/* harmony export */   StateEffectType: () => (/* binding */ StateEffectType),\n/* harmony export */   StateField: () => (/* binding */ StateField),\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   codePointAt: () => (/* binding */ codePointAt),\n/* harmony export */   codePointSize: () => (/* binding */ codePointSize),\n/* harmony export */   combineConfig: () => (/* binding */ combineConfig),\n/* harmony export */   countColumn: () => (/* binding */ countColumn),\n/* harmony export */   findClusterBreak: () => (/* binding */ findClusterBreak),\n/* harmony export */   findColumn: () => (/* binding */ findColumn),\n/* harmony export */   fromCodePoint: () => (/* binding */ fromCodePoint)\n/* harmony export */ });\n/**\nThe data structure for documents. @nonabstract\n*/ class Text {\n    /**\n    Get the line description around the given position.\n    */ lineAt(pos) {\n        if (pos < 0 || pos > this.length) throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);\n        return this.lineInner(pos, false, 1, 0);\n    }\n    /**\n    Get the description for the given (1-based) line number.\n    */ line(n) {\n        if (n < 1 || n > this.lines) throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);\n        return this.lineInner(n, true, 1, 0);\n    }\n    /**\n    Replace a range of the text with the given content.\n    */ replace(from, to, text) {\n        [from, to] = clip(this, from, to);\n        let parts = [];\n        this.decompose(0, from, parts, 2 /* Open.To */ );\n        if (text.length) text.decompose(0, text.length, parts, 1 /* Open.From */  | 2 /* Open.To */ );\n        this.decompose(to, this.length, parts, 1 /* Open.From */ );\n        return TextNode.from(parts, this.length - (to - from) + text.length);\n    }\n    /**\n    Append another document to this one.\n    */ append(other) {\n        return this.replace(this.length, this.length, other);\n    }\n    /**\n    Retrieve the text between the given points.\n    */ slice(from, to = this.length) {\n        [from, to] = clip(this, from, to);\n        let parts = [];\n        this.decompose(from, to, parts, 0);\n        return TextNode.from(parts, to - from);\n    }\n    /**\n    Test whether this text is equal to another instance.\n    */ eq(other) {\n        if (other == this) return true;\n        if (other.length != this.length || other.lines != this.lines) return false;\n        let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);\n        let a = new RawTextCursor(this), b = new RawTextCursor(other);\n        for(let skip = start, pos = start;;){\n            a.next(skip);\n            b.next(skip);\n            skip = 0;\n            if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value) return false;\n            pos += a.value.length;\n            if (a.done || pos >= end) return true;\n        }\n    }\n    /**\n    Iterate over the text. When `dir` is `-1`, iteration happens\n    from end to start. This will return lines and the breaks between\n    them as separate strings.\n    */ iter(dir = 1) {\n        return new RawTextCursor(this, dir);\n    }\n    /**\n    Iterate over a range of the text. When `from` > `to`, the\n    iterator will run in reverse.\n    */ iterRange(from, to = this.length) {\n        return new PartialTextCursor(this, from, to);\n    }\n    /**\n    Return a cursor that iterates over the given range of lines,\n    _without_ returning the line breaks between, and yielding empty\n    strings for empty lines.\n    \n    When `from` and `to` are given, they should be 1-based line numbers.\n    */ iterLines(from, to) {\n        let inner;\n        if (from == null) {\n            inner = this.iter();\n        } else {\n            if (to == null) to = this.lines + 1;\n            let start = this.line(from).from;\n            inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));\n        }\n        return new LineCursor(inner);\n    }\n    /**\n    Return the document as a string, using newline characters to\n    separate lines.\n    */ toString() {\n        return this.sliceString(0);\n    }\n    /**\n    Convert the document to an array of lines (which can be\n    deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).\n    */ toJSON() {\n        let lines = [];\n        this.flatten(lines);\n        return lines;\n    }\n    /**\n    @internal\n    */ constructor(){}\n    /**\n    Create a `Text` instance for the given array of lines.\n    */ static of(text) {\n        if (text.length == 0) throw new RangeError(\"A document must have at least one line\");\n        if (text.length == 1 && !text[0]) return Text.empty;\n        return text.length <= 32 /* Tree.Branch */  ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));\n    }\n}\n// Leaves store an array of line strings. There are always line breaks\n// between these strings. Leaves are limited in size and have to be\n// contained in TextNode instances for bigger documents.\nclass TextLeaf extends Text {\n    constructor(text, length = textLength(text)){\n        super();\n        this.text = text;\n        this.length = length;\n    }\n    get lines() {\n        return this.text.length;\n    }\n    get children() {\n        return null;\n    }\n    lineInner(target, isLine, line, offset) {\n        for(let i = 0;; i++){\n            let string = this.text[i], end = offset + string.length;\n            if ((isLine ? line : end) >= target) return new Line(offset, end, line, string);\n            offset = end + 1;\n            line++;\n        }\n    }\n    decompose(from, to, target, open) {\n        let text = from <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));\n        if (open & 1 /* Open.From */ ) {\n            let prev = target.pop();\n            let joined = appendText(text.text, prev.text.slice(), 0, text.length);\n            if (joined.length <= 32 /* Tree.Branch */ ) {\n                target.push(new TextLeaf(joined, prev.length + text.length));\n            } else {\n                let mid = joined.length >> 1;\n                target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));\n            }\n        } else {\n            target.push(text);\n        }\n    }\n    replace(from, to, text) {\n        if (!(text instanceof TextLeaf)) return super.replace(from, to, text);\n        [from, to] = clip(this, from, to);\n        let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);\n        let newLen = this.length + text.length - (to - from);\n        if (lines.length <= 32 /* Tree.Branch */ ) return new TextLeaf(lines, newLen);\n        return TextNode.from(TextLeaf.split(lines, []), newLen);\n    }\n    sliceString(from, to = this.length, lineSep = \"\\n\") {\n        [from, to] = clip(this, from, to);\n        let result = \"\";\n        for(let pos = 0, i = 0; pos <= to && i < this.text.length; i++){\n            let line = this.text[i], end = pos + line.length;\n            if (pos > from && i) result += lineSep;\n            if (from < end && to > pos) result += line.slice(Math.max(0, from - pos), to - pos);\n            pos = end + 1;\n        }\n        return result;\n    }\n    flatten(target) {\n        for (let line of this.text)target.push(line);\n    }\n    scanIdentical() {\n        return 0;\n    }\n    static split(text, target) {\n        let part = [], len = -1;\n        for (let line of text){\n            part.push(line);\n            len += line.length + 1;\n            if (part.length == 32 /* Tree.Branch */ ) {\n                target.push(new TextLeaf(part, len));\n                part = [];\n                len = -1;\n            }\n        }\n        if (len > -1) target.push(new TextLeaf(part, len));\n        return target;\n    }\n}\n// Nodes provide the tree structure of the `Text` type. They store a\n// number of other nodes or leaves, taking care to balance themselves\n// on changes. There are implied line breaks _between_ the children of\n// a node (but not before the first or after the last child).\nclass TextNode extends Text {\n    constructor(children, length){\n        super();\n        this.children = children;\n        this.length = length;\n        this.lines = 0;\n        for (let child of children)this.lines += child.lines;\n    }\n    lineInner(target, isLine, line, offset) {\n        for(let i = 0;; i++){\n            let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;\n            if ((isLine ? endLine : end) >= target) return child.lineInner(target, isLine, line, offset);\n            offset = end + 1;\n            line = endLine + 1;\n        }\n    }\n    decompose(from, to, target, open) {\n        for(let i = 0, pos = 0; pos <= to && i < this.children.length; i++){\n            let child = this.children[i], end = pos + child.length;\n            if (from <= end && to >= pos) {\n                let childOpen = open & ((pos <= from ? 1 /* Open.From */  : 0) | (end >= to ? 2 /* Open.To */  : 0));\n                if (pos >= from && end <= to && !childOpen) target.push(child);\n                else child.decompose(from - pos, to - pos, target, childOpen);\n            }\n            pos = end + 1;\n        }\n    }\n    replace(from, to, text) {\n        [from, to] = clip(this, from, to);\n        if (text.lines < this.lines) for(let i = 0, pos = 0; i < this.children.length; i++){\n            let child = this.children[i], end = pos + child.length;\n            // Fast path: if the change only affects one child and the\n            // child's size remains in the acceptable range, only update\n            // that child\n            if (from >= pos && to <= end) {\n                let updated = child.replace(from - pos, to - pos, text);\n                let totalLines = this.lines - child.lines + updated.lines;\n                if (updated.lines < totalLines >> 5 /* Tree.BranchShift */  - 1 && updated.lines > totalLines >> 5 /* Tree.BranchShift */  + 1) {\n                    let copy = this.children.slice();\n                    copy[i] = updated;\n                    return new TextNode(copy, this.length - (to - from) + text.length);\n                }\n                return super.replace(pos, end, updated);\n            }\n            pos = end + 1;\n        }\n        return super.replace(from, to, text);\n    }\n    sliceString(from, to = this.length, lineSep = \"\\n\") {\n        [from, to] = clip(this, from, to);\n        let result = \"\";\n        for(let i = 0, pos = 0; i < this.children.length && pos <= to; i++){\n            let child = this.children[i], end = pos + child.length;\n            if (pos > from && i) result += lineSep;\n            if (from < end && to > pos) result += child.sliceString(from - pos, to - pos, lineSep);\n            pos = end + 1;\n        }\n        return result;\n    }\n    flatten(target) {\n        for (let child of this.children)child.flatten(target);\n    }\n    scanIdentical(other, dir) {\n        if (!(other instanceof TextNode)) return 0;\n        let length = 0;\n        let [iA, iB, eA, eB] = dir > 0 ? [\n            0,\n            0,\n            this.children.length,\n            other.children.length\n        ] : [\n            this.children.length - 1,\n            other.children.length - 1,\n            -1,\n            -1\n        ];\n        for(;; iA += dir, iB += dir){\n            if (iA == eA || iB == eB) return length;\n            let chA = this.children[iA], chB = other.children[iB];\n            if (chA != chB) return length + chA.scanIdentical(chB, dir);\n            length += chA.length + 1;\n        }\n    }\n    static from(children, length = children.reduce((l, ch)=>l + ch.length + 1, -1)) {\n        let lines = 0;\n        for (let ch of children)lines += ch.lines;\n        if (lines < 32 /* Tree.Branch */ ) {\n            let flat = [];\n            for (let ch of children)ch.flatten(flat);\n            return new TextLeaf(flat, length);\n        }\n        let chunk = Math.max(32 /* Tree.Branch */ , lines >> 5 /* Tree.BranchShift */ ), maxChunk = chunk << 1, minChunk = chunk >> 1;\n        let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];\n        function add(child) {\n            let last;\n            if (child.lines > maxChunk && child instanceof TextNode) {\n                for (let node of child.children)add(node);\n            } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {\n                flush();\n                chunked.push(child);\n            } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32 /* Tree.Branch */ ) {\n                currentLines += child.lines;\n                currentLen += child.length + 1;\n                currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);\n            } else {\n                if (currentLines + child.lines > chunk) flush();\n                currentLines += child.lines;\n                currentLen += child.length + 1;\n                currentChunk.push(child);\n            }\n        }\n        function flush() {\n            if (currentLines == 0) return;\n            chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));\n            currentLen = -1;\n            currentLines = currentChunk.length = 0;\n        }\n        for (let child of children)add(child);\n        flush();\n        return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);\n    }\n}\nText.empty = /*@__PURE__*/ new TextLeaf([\n    \"\"\n], 0);\nfunction textLength(text) {\n    let length = -1;\n    for (let line of text)length += line.length + 1;\n    return length;\n}\nfunction appendText(text, target, from = 0, to = 1e9) {\n    for(let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++){\n        let line = text[i], end = pos + line.length;\n        if (end >= from) {\n            if (end > to) line = line.slice(0, to - pos);\n            if (pos < from) line = line.slice(from - pos);\n            if (first) {\n                target[target.length - 1] += line;\n                first = false;\n            } else target.push(line);\n        }\n        pos = end + 1;\n    }\n    return target;\n}\nfunction sliceText(text, from, to) {\n    return appendText(text, [\n        \"\"\n    ], from, to);\n}\nclass RawTextCursor {\n    constructor(text, dir = 1){\n        this.dir = dir;\n        this.done = false;\n        this.lineBreak = false;\n        this.value = \"\";\n        this.nodes = [\n            text\n        ];\n        this.offsets = [\n            dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1\n        ];\n    }\n    nextInner(skip, dir) {\n        this.done = this.lineBreak = false;\n        for(;;){\n            let last = this.nodes.length - 1;\n            let top = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;\n            let size = top instanceof TextLeaf ? top.text.length : top.children.length;\n            if (offset == (dir > 0 ? size : 0)) {\n                if (last == 0) {\n                    this.done = true;\n                    this.value = \"\";\n                    return this;\n                }\n                if (dir > 0) this.offsets[last - 1]++;\n                this.nodes.pop();\n                this.offsets.pop();\n            } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {\n                this.offsets[last] += dir;\n                if (skip == 0) {\n                    this.lineBreak = true;\n                    this.value = \"\\n\";\n                    return this;\n                }\n                skip--;\n            } else if (top instanceof TextLeaf) {\n                // Move to the next string\n                let next = top.text[offset + (dir < 0 ? -1 : 0)];\n                this.offsets[last] += dir;\n                if (next.length > Math.max(0, skip)) {\n                    this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);\n                    return this;\n                }\n                skip -= next.length;\n            } else {\n                let next = top.children[offset + (dir < 0 ? -1 : 0)];\n                if (skip > next.length) {\n                    skip -= next.length;\n                    this.offsets[last] += dir;\n                } else {\n                    if (dir < 0) this.offsets[last]--;\n                    this.nodes.push(next);\n                    this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);\n                }\n            }\n        }\n    }\n    next(skip = 0) {\n        if (skip < 0) {\n            this.nextInner(-skip, -this.dir);\n            skip = this.value.length;\n        }\n        return this.nextInner(skip, this.dir);\n    }\n}\nclass PartialTextCursor {\n    constructor(text, start, end){\n        this.value = \"\";\n        this.done = false;\n        this.cursor = new RawTextCursor(text, start > end ? -1 : 1);\n        this.pos = start > end ? text.length : 0;\n        this.from = Math.min(start, end);\n        this.to = Math.max(start, end);\n    }\n    nextInner(skip, dir) {\n        if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {\n            this.value = \"\";\n            this.done = true;\n            return this;\n        }\n        skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);\n        let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;\n        if (skip > limit) skip = limit;\n        limit -= skip;\n        let { value } = this.cursor.next(skip);\n        this.pos += (value.length + skip) * dir;\n        this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);\n        this.done = !this.value;\n        return this;\n    }\n    next(skip = 0) {\n        if (skip < 0) skip = Math.max(skip, this.from - this.pos);\n        else if (skip > 0) skip = Math.min(skip, this.to - this.pos);\n        return this.nextInner(skip, this.cursor.dir);\n    }\n    get lineBreak() {\n        return this.cursor.lineBreak && this.value != \"\";\n    }\n}\nclass LineCursor {\n    constructor(inner){\n        this.inner = inner;\n        this.afterBreak = true;\n        this.value = \"\";\n        this.done = false;\n    }\n    next(skip = 0) {\n        let { done, lineBreak, value } = this.inner.next(skip);\n        if (done && this.afterBreak) {\n            this.value = \"\";\n            this.afterBreak = false;\n        } else if (done) {\n            this.done = true;\n            this.value = \"\";\n        } else if (lineBreak) {\n            if (this.afterBreak) {\n                this.value = \"\";\n            } else {\n                this.afterBreak = true;\n                this.next();\n            }\n        } else {\n            this.value = value;\n            this.afterBreak = false;\n        }\n        return this;\n    }\n    get lineBreak() {\n        return false;\n    }\n}\nif (typeof Symbol != \"undefined\") {\n    Text.prototype[Symbol.iterator] = function() {\n        return this.iter();\n    };\n    RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {\n        return this;\n    };\n}\n/**\nThis type describes a line in the document. It is created\non-demand when lines are [queried](https://codemirror.net/6/docs/ref/#state.Text.lineAt).\n*/ class Line {\n    /**\n    @internal\n    */ constructor(/**\n    The position of the start of the line.\n    */ from, /**\n    The position at the end of the line (_before_ the line break,\n    or at the end of document for the last line).\n    */ to, /**\n    This line's line number (1-based).\n    */ number, /**\n    The line's content.\n    */ text){\n        this.from = from;\n        this.to = to;\n        this.number = number;\n        this.text = text;\n    }\n    /**\n    The length of the line (not including any line break after it).\n    */ get length() {\n        return this.to - this.from;\n    }\n}\nfunction clip(text, from, to) {\n    from = Math.max(0, Math.min(text.length, from));\n    return [\n        from,\n        Math.max(from, Math.min(text.length, to))\n    ];\n}\n// Compressed representation of the Grapheme_Cluster_Break=Extend\n// information from\n// http://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakProperty.txt.\n// Each pair of elements represents a range, as an offet from the\n// previous range and a length. Numbers are in base-36, with the empty\n// string being a shorthand for 1.\nlet extend = /*@__PURE__*/ \"lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o\".split(\",\").map((s)=>s ? parseInt(s, 36) : 1);\n// Convert offsets into absolute values\nfor(let i = 1; i < extend.length; i++)extend[i] += extend[i - 1];\nfunction isExtendingChar(code) {\n    for(let i = 1; i < extend.length; i += 2)if (extend[i] > code) return extend[i - 1] <= code;\n    return false;\n}\nfunction isRegionalIndicator(code) {\n    return code >= 0x1F1E6 && code <= 0x1F1FF;\n}\nconst ZWJ = 0x200d;\n/**\nReturns a next grapheme cluster break _after_ (not equal to)\n`pos`, if `forward` is true, or before otherwise. Returns `pos`\nitself if no further cluster break is available in the string.\nMoves across surrogate pairs, extending characters (when\n`includeExtending` is true), characters joined with zero-width\njoiners, and flag emoji.\n*/ function findClusterBreak(str, pos, forward = true, includeExtending = true) {\n    return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);\n}\nfunction nextClusterBreak(str, pos, includeExtending) {\n    if (pos == str.length) return pos;\n    // If pos is in the middle of a surrogate pair, move to its start\n    if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1))) pos--;\n    let prev = codePointAt(str, pos);\n    pos += codePointSize(prev);\n    while(pos < str.length){\n        let next = codePointAt(str, pos);\n        if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {\n            pos += codePointSize(next);\n            prev = next;\n        } else if (isRegionalIndicator(next)) {\n            let countBefore = 0, i = pos - 2;\n            while(i >= 0 && isRegionalIndicator(codePointAt(str, i))){\n                countBefore++;\n                i -= 2;\n            }\n            if (countBefore % 2 == 0) break;\n            else pos += 2;\n        } else {\n            break;\n        }\n    }\n    return pos;\n}\nfunction prevClusterBreak(str, pos, includeExtending) {\n    while(pos > 0){\n        let found = nextClusterBreak(str, pos - 2, includeExtending);\n        if (found < pos) return found;\n        pos--;\n    }\n    return 0;\n}\nfunction surrogateLow(ch) {\n    return ch >= 0xDC00 && ch < 0xE000;\n}\nfunction surrogateHigh(ch) {\n    return ch >= 0xD800 && ch < 0xDC00;\n}\n/**\nFind the code point at the given position in a string (like the\n[`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)\nstring method).\n*/ function codePointAt(str, pos) {\n    let code0 = str.charCodeAt(pos);\n    if (!surrogateHigh(code0) || pos + 1 == str.length) return code0;\n    let code1 = str.charCodeAt(pos + 1);\n    if (!surrogateLow(code1)) return code0;\n    return (code0 - 0xd800 << 10) + (code1 - 0xdc00) + 0x10000;\n}\n/**\nGiven a Unicode codepoint, return the JavaScript string that\nrespresents it (like\n[`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)).\n*/ function fromCodePoint(code) {\n    if (code <= 0xffff) return String.fromCharCode(code);\n    code -= 0x10000;\n    return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);\n}\n/**\nThe amount of positions a character takes up a JavaScript string.\n*/ function codePointSize(code) {\n    return code < 0x10000 ? 1 : 2;\n}\nconst DefaultSplit = /\\r\\n?|\\n/;\n/**\nDistinguishes different ways in which positions can be mapped.\n*/ var MapMode = /*@__PURE__*/ function(MapMode) {\n    /**\n    Map a position to a valid new position, even when its context\n    was deleted.\n    */ MapMode[MapMode[\"Simple\"] = 0] = \"Simple\";\n    /**\n    Return null if deletion happens across the position.\n    */ MapMode[MapMode[\"TrackDel\"] = 1] = \"TrackDel\";\n    /**\n    Return null if the character _before_ the position is deleted.\n    */ MapMode[MapMode[\"TrackBefore\"] = 2] = \"TrackBefore\";\n    /**\n    Return null if the character _after_ the position is deleted.\n    */ MapMode[MapMode[\"TrackAfter\"] = 3] = \"TrackAfter\";\n    return MapMode;\n}(MapMode || (MapMode = {}));\n/**\nA change description is a variant of [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet)\nthat doesn't store the inserted text. As such, it can't be\napplied, but is cheaper to store and manipulate.\n*/ class ChangeDesc {\n    // Sections are encoded as pairs of integers. The first is the\n    // length in the current document, and the second is -1 for\n    // unaffected sections, and the length of the replacement content\n    // otherwise. So an insertion would be (0, n>0), a deletion (n>0,\n    // 0), and a replacement two positive numbers.\n    /**\n    @internal\n    */ constructor(/**\n    @internal\n    */ sections){\n        this.sections = sections;\n    }\n    /**\n    The length of the document before the change.\n    */ get length() {\n        let result = 0;\n        for(let i = 0; i < this.sections.length; i += 2)result += this.sections[i];\n        return result;\n    }\n    /**\n    The length of the document after the change.\n    */ get newLength() {\n        let result = 0;\n        for(let i = 0; i < this.sections.length; i += 2){\n            let ins = this.sections[i + 1];\n            result += ins < 0 ? this.sections[i] : ins;\n        }\n        return result;\n    }\n    /**\n    False when there are actual changes in this set.\n    */ get empty() {\n        return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;\n    }\n    /**\n    Iterate over the unchanged parts left by these changes. `posA`\n    provides the position of the range in the old document, `posB`\n    the new position in the changed document.\n    */ iterGaps(f) {\n        for(let i = 0, posA = 0, posB = 0; i < this.sections.length;){\n            let len = this.sections[i++], ins = this.sections[i++];\n            if (ins < 0) {\n                f(posA, posB, len);\n                posB += len;\n            } else {\n                posB += ins;\n            }\n            posA += len;\n        }\n    }\n    /**\n    Iterate over the ranges changed by these changes. (See\n    [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a\n    variant that also provides you with the inserted text.)\n    `fromA`/`toA` provides the extent of the change in the starting\n    document, `fromB`/`toB` the extent of the replacement in the\n    changed document.\n    \n    When `individual` is true, adjacent changes (which are kept\n    separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are\n    reported separately.\n    */ iterChangedRanges(f, individual = false) {\n        iterChanges(this, f, individual);\n    }\n    /**\n    Get a description of the inverted form of these changes.\n    */ get invertedDesc() {\n        let sections = [];\n        for(let i = 0; i < this.sections.length;){\n            let len = this.sections[i++], ins = this.sections[i++];\n            if (ins < 0) sections.push(len, ins);\n            else sections.push(ins, len);\n        }\n        return new ChangeDesc(sections);\n    }\n    /**\n    Compute the combined effect of applying another set of changes\n    after this one. The length of the document after this set should\n    match the length before `other`.\n    */ composeDesc(other) {\n        return this.empty ? other : other.empty ? this : composeSets(this, other);\n    }\n    /**\n    Map this description, which should start with the same document\n    as `other`, over another set of changes, so that it can be\n    applied after it. When `before` is true, map as if the changes\n    in `other` happened before the ones in `this`.\n    */ mapDesc(other, before = false) {\n        return other.empty ? this : mapSet(this, other, before);\n    }\n    mapPos(pos, assoc = -1, mode = MapMode.Simple) {\n        let posA = 0, posB = 0;\n        for(let i = 0; i < this.sections.length;){\n            let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;\n            if (ins < 0) {\n                if (endA > pos) return posB + (pos - posA);\n                posB += len;\n            } else {\n                if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos)) return null;\n                if (endA > pos || endA == pos && assoc < 0 && !len) return pos == posA || assoc < 0 ? posB : posB + ins;\n                posB += ins;\n            }\n            posA = endA;\n        }\n        if (pos > posA) throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);\n        return posB;\n    }\n    /**\n    Check whether these changes touch a given range. When one of the\n    changes entirely covers the range, the string `\"cover\"` is\n    returned.\n    */ touchesRange(from, to = from) {\n        for(let i = 0, pos = 0; i < this.sections.length && pos <= to;){\n            let len = this.sections[i++], ins = this.sections[i++], end = pos + len;\n            if (ins >= 0 && pos <= to && end >= from) return pos < from && end > to ? \"cover\" : true;\n            pos = end;\n        }\n        return false;\n    }\n    /**\n    @internal\n    */ toString() {\n        let result = \"\";\n        for(let i = 0; i < this.sections.length;){\n            let len = this.sections[i++], ins = this.sections[i++];\n            result += (result ? \" \" : \"\") + len + (ins >= 0 ? \":\" + ins : \"\");\n        }\n        return result;\n    }\n    /**\n    Serialize this change desc to a JSON-representable value.\n    */ toJSON() {\n        return this.sections;\n    }\n    /**\n    Create a change desc from its JSON representation (as produced\n    by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).\n    */ static fromJSON(json) {\n        if (!Array.isArray(json) || json.length % 2 || json.some((a)=>typeof a != \"number\")) throw new RangeError(\"Invalid JSON representation of ChangeDesc\");\n        return new ChangeDesc(json);\n    }\n    /**\n    @internal\n    */ static create(sections) {\n        return new ChangeDesc(sections);\n    }\n}\n/**\nA change set represents a group of modifications to a document. It\nstores the document length, and can only be applied to documents\nwith exactly that length.\n*/ class ChangeSet extends ChangeDesc {\n    constructor(sections, /**\n    @internal\n    */ inserted){\n        super(sections);\n        this.inserted = inserted;\n    }\n    /**\n    Apply the changes to a document, returning the modified\n    document.\n    */ apply(doc) {\n        if (this.length != doc.length) throw new RangeError(\"Applying change set to a document with the wrong length\");\n        iterChanges(this, (fromA, toA, fromB, _toB, text)=>doc = doc.replace(fromB, fromB + (toA - fromA), text), false);\n        return doc;\n    }\n    mapDesc(other, before = false) {\n        return mapSet(this, other, before, true);\n    }\n    /**\n    Given the document as it existed _before_ the changes, return a\n    change set that represents the inverse of this set, which could\n    be used to go from the document created by the changes back to\n    the document as it existed before the changes.\n    */ invert(doc) {\n        let sections = this.sections.slice(), inserted = [];\n        for(let i = 0, pos = 0; i < sections.length; i += 2){\n            let len = sections[i], ins = sections[i + 1];\n            if (ins >= 0) {\n                sections[i] = ins;\n                sections[i + 1] = len;\n                let index = i >> 1;\n                while(inserted.length < index)inserted.push(Text.empty);\n                inserted.push(len ? doc.slice(pos, pos + len) : Text.empty);\n            }\n            pos += len;\n        }\n        return new ChangeSet(sections, inserted);\n    }\n    /**\n    Combine two subsequent change sets into a single set. `other`\n    must start in the document produced by `this`. If `this` goes\n    `docA` → `docB` and `other` represents `docB` → `docC`, the\n    returned value will represent the change `docA` → `docC`.\n    */ compose(other) {\n        return this.empty ? other : other.empty ? this : composeSets(this, other, true);\n    }\n    /**\n    Given another change set starting in the same document, maps this\n    change set over the other, producing a new change set that can be\n    applied to the document produced by applying `other`. When\n    `before` is `true`, order changes as if `this` comes before\n    `other`, otherwise (the default) treat `other` as coming first.\n    \n    Given two changes `A` and `B`, `A.compose(B.map(A))` and\n    `B.compose(A.map(B, true))` will produce the same document. This\n    provides a basic form of [operational\n    transformation](https://en.wikipedia.org/wiki/Operational_transformation),\n    and can be used for collaborative editing.\n    */ map(other, before = false) {\n        return other.empty ? this : mapSet(this, other, before, true);\n    }\n    /**\n    Iterate over the changed ranges in the document, calling `f` for\n    each, with the range in the original document (`fromA`-`toA`)\n    and the range that replaces it in the new document\n    (`fromB`-`toB`).\n    \n    When `individual` is true, adjacent changes are reported\n    separately.\n    */ iterChanges(f, individual = false) {\n        iterChanges(this, f, individual);\n    }\n    /**\n    Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change\n    set.\n    */ get desc() {\n        return ChangeDesc.create(this.sections);\n    }\n    /**\n    @internal\n    */ filter(ranges) {\n        let resultSections = [], resultInserted = [], filteredSections = [];\n        let iter = new SectionIter(this);\n        done: for(let i = 0, pos = 0;;){\n            let next = i == ranges.length ? 1e9 : ranges[i++];\n            while(pos < next || pos == next && iter.len == 0){\n                if (iter.done) break done;\n                let len = Math.min(iter.len, next - pos);\n                addSection(filteredSections, len, -1);\n                let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;\n                addSection(resultSections, len, ins);\n                if (ins > 0) addInsert(resultInserted, resultSections, iter.text);\n                iter.forward(len);\n                pos += len;\n            }\n            let end = ranges[i++];\n            while(pos < end){\n                if (iter.done) break done;\n                let len = Math.min(iter.len, end - pos);\n                addSection(resultSections, len, -1);\n                addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);\n                iter.forward(len);\n                pos += len;\n            }\n        }\n        return {\n            changes: new ChangeSet(resultSections, resultInserted),\n            filtered: ChangeDesc.create(filteredSections)\n        };\n    }\n    /**\n    Serialize this change set to a JSON-representable value.\n    */ toJSON() {\n        let parts = [];\n        for(let i = 0; i < this.sections.length; i += 2){\n            let len = this.sections[i], ins = this.sections[i + 1];\n            if (ins < 0) parts.push(len);\n            else if (ins == 0) parts.push([\n                len\n            ]);\n            else parts.push([\n                len\n            ].concat(this.inserted[i >> 1].toJSON()));\n        }\n        return parts;\n    }\n    /**\n    Create a change set for the given changes, for a document of the\n    given length, using `lineSep` as line separator.\n    */ static of(changes, length, lineSep) {\n        let sections = [], inserted = [], pos = 0;\n        let total = null;\n        function flush(force = false) {\n            if (!force && !sections.length) return;\n            if (pos < length) addSection(sections, length - pos, -1);\n            let set = new ChangeSet(sections, inserted);\n            total = total ? total.compose(set.map(total)) : set;\n            sections = [];\n            inserted = [];\n            pos = 0;\n        }\n        function process(spec) {\n            if (Array.isArray(spec)) {\n                for (let sub of spec)process(sub);\n            } else if (spec instanceof ChangeSet) {\n                if (spec.length != length) throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);\n                flush();\n                total = total ? total.compose(spec.map(total)) : spec;\n            } else {\n                let { from, to = from, insert } = spec;\n                if (from > to || from < 0 || to > length) throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);\n                let insText = !insert ? Text.empty : typeof insert == \"string\" ? Text.of(insert.split(lineSep || DefaultSplit)) : insert;\n                let insLen = insText.length;\n                if (from == to && insLen == 0) return;\n                if (from < pos) flush();\n                if (from > pos) addSection(sections, from - pos, -1);\n                addSection(sections, to - from, insLen);\n                addInsert(inserted, sections, insText);\n                pos = to;\n            }\n        }\n        process(changes);\n        flush(!total);\n        return total;\n    }\n    /**\n    Create an empty changeset of the given length.\n    */ static empty(length) {\n        return new ChangeSet(length ? [\n            length,\n            -1\n        ] : [], []);\n    }\n    /**\n    Create a changeset from its JSON representation (as produced by\n    [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).\n    */ static fromJSON(json) {\n        if (!Array.isArray(json)) throw new RangeError(\"Invalid JSON representation of ChangeSet\");\n        let sections = [], inserted = [];\n        for(let i = 0; i < json.length; i++){\n            let part = json[i];\n            if (typeof part == \"number\") {\n                sections.push(part, -1);\n            } else if (!Array.isArray(part) || typeof part[0] != \"number\" || part.some((e, i)=>i && typeof e != \"string\")) {\n                throw new RangeError(\"Invalid JSON representation of ChangeSet\");\n            } else if (part.length == 1) {\n                sections.push(part[0], 0);\n            } else {\n                while(inserted.length < i)inserted.push(Text.empty);\n                inserted[i] = Text.of(part.slice(1));\n                sections.push(part[0], inserted[i].length);\n            }\n        }\n        return new ChangeSet(sections, inserted);\n    }\n    /**\n    @internal\n    */ static createSet(sections, inserted) {\n        return new ChangeSet(sections, inserted);\n    }\n}\nfunction addSection(sections, len, ins, forceJoin = false) {\n    if (len == 0 && ins <= 0) return;\n    let last = sections.length - 2;\n    if (last >= 0 && ins <= 0 && ins == sections[last + 1]) sections[last] += len;\n    else if (len == 0 && sections[last] == 0) sections[last + 1] += ins;\n    else if (forceJoin) {\n        sections[last] += len;\n        sections[last + 1] += ins;\n    } else sections.push(len, ins);\n}\nfunction addInsert(values, sections, value) {\n    if (value.length == 0) return;\n    let index = sections.length - 2 >> 1;\n    if (index < values.length) {\n        values[values.length - 1] = values[values.length - 1].append(value);\n    } else {\n        while(values.length < index)values.push(Text.empty);\n        values.push(value);\n    }\n}\nfunction iterChanges(desc, f, individual) {\n    let inserted = desc.inserted;\n    for(let posA = 0, posB = 0, i = 0; i < desc.sections.length;){\n        let len = desc.sections[i++], ins = desc.sections[i++];\n        if (ins < 0) {\n            posA += len;\n            posB += len;\n        } else {\n            let endA = posA, endB = posB, text = Text.empty;\n            for(;;){\n                endA += len;\n                endB += ins;\n                if (ins && inserted) text = text.append(inserted[i - 2 >> 1]);\n                if (individual || i == desc.sections.length || desc.sections[i + 1] < 0) break;\n                len = desc.sections[i++];\n                ins = desc.sections[i++];\n            }\n            f(posA, endA, posB, endB, text);\n            posA = endA;\n            posB = endB;\n        }\n    }\n}\nfunction mapSet(setA, setB, before, mkSet = false) {\n    // Produce a copy of setA that applies to the document after setB\n    // has been applied (assuming both start at the same document).\n    let sections = [], insert = mkSet ? [] : null;\n    let a = new SectionIter(setA), b = new SectionIter(setB);\n    // Iterate over both sets in parallel. inserted tracks, for changes\n    // in A that have to be processed piece-by-piece, whether their\n    // content has been inserted already, and refers to the section\n    // index.\n    for(let inserted = -1;;){\n        if (a.ins == -1 && b.ins == -1) {\n            // Move across ranges skipped by both sets.\n            let len = Math.min(a.len, b.len);\n            addSection(sections, len, -1);\n            a.forward(len);\n            b.forward(len);\n        } else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {\n            // If there's a change in B that comes before the next change in\n            // A (ordered by start pos, then len, then before flag), skip\n            // that (and process any changes in A it covers).\n            let len = b.len;\n            addSection(sections, b.ins, -1);\n            while(len){\n                let piece = Math.min(a.len, len);\n                if (a.ins >= 0 && inserted < a.i && a.len <= piece) {\n                    addSection(sections, 0, a.ins);\n                    if (insert) addInsert(insert, sections, a.text);\n                    inserted = a.i;\n                }\n                a.forward(piece);\n                len -= piece;\n            }\n            b.next();\n        } else if (a.ins >= 0) {\n            // Process the part of a change in A up to the start of the next\n            // non-deletion change in B (if overlapping).\n            let len = 0, left = a.len;\n            while(left){\n                if (b.ins == -1) {\n                    let piece = Math.min(left, b.len);\n                    len += piece;\n                    left -= piece;\n                    b.forward(piece);\n                } else if (b.ins == 0 && b.len < left) {\n                    left -= b.len;\n                    b.next();\n                } else {\n                    break;\n                }\n            }\n            addSection(sections, len, inserted < a.i ? a.ins : 0);\n            if (insert && inserted < a.i) addInsert(insert, sections, a.text);\n            inserted = a.i;\n            a.forward(a.len - left);\n        } else if (a.done && b.done) {\n            return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);\n        } else {\n            throw new Error(\"Mismatched change set lengths\");\n        }\n    }\n}\nfunction composeSets(setA, setB, mkSet = false) {\n    let sections = [];\n    let insert = mkSet ? [] : null;\n    let a = new SectionIter(setA), b = new SectionIter(setB);\n    for(let open = false;;){\n        if (a.done && b.done) {\n            return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);\n        } else if (a.ins == 0) {\n            addSection(sections, a.len, 0, open);\n            a.next();\n        } else if (b.len == 0 && !b.done) {\n            addSection(sections, 0, b.ins, open);\n            if (insert) addInsert(insert, sections, b.text);\n            b.next();\n        } else if (a.done || b.done) {\n            throw new Error(\"Mismatched change set lengths\");\n        } else {\n            let len = Math.min(a.len2, b.len), sectionLen = sections.length;\n            if (a.ins == -1) {\n                let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;\n                addSection(sections, len, insB, open);\n                if (insert && insB) addInsert(insert, sections, b.text);\n            } else if (b.ins == -1) {\n                addSection(sections, a.off ? 0 : a.len, len, open);\n                if (insert) addInsert(insert, sections, a.textBit(len));\n            } else {\n                addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);\n                if (insert && !b.off) addInsert(insert, sections, b.text);\n            }\n            open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);\n            a.forward2(len);\n            b.forward(len);\n        }\n    }\n}\nclass SectionIter {\n    constructor(set){\n        this.set = set;\n        this.i = 0;\n        this.next();\n    }\n    next() {\n        let { sections } = this.set;\n        if (this.i < sections.length) {\n            this.len = sections[this.i++];\n            this.ins = sections[this.i++];\n        } else {\n            this.len = 0;\n            this.ins = -2;\n        }\n        this.off = 0;\n    }\n    get done() {\n        return this.ins == -2;\n    }\n    get len2() {\n        return this.ins < 0 ? this.len : this.ins;\n    }\n    get text() {\n        let { inserted } = this.set, index = this.i - 2 >> 1;\n        return index >= inserted.length ? Text.empty : inserted[index];\n    }\n    textBit(len) {\n        let { inserted } = this.set, index = this.i - 2 >> 1;\n        return index >= inserted.length && !len ? Text.empty : inserted[index].slice(this.off, len == null ? undefined : this.off + len);\n    }\n    forward(len) {\n        if (len == this.len) this.next();\n        else {\n            this.len -= len;\n            this.off += len;\n        }\n    }\n    forward2(len) {\n        if (this.ins == -1) this.forward(len);\n        else if (len == this.ins) this.next();\n        else {\n            this.ins -= len;\n            this.off += len;\n        }\n    }\n}\n/**\nA single selection range. When\n[`allowMultipleSelections`](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)\nis enabled, a [selection](https://codemirror.net/6/docs/ref/#state.EditorSelection) may hold\nmultiple ranges. By default, selections hold exactly one range.\n*/ class SelectionRange {\n    constructor(/**\n    The lower boundary of the range.\n    */ from, /**\n    The upper boundary of the range.\n    */ to, flags){\n        this.from = from;\n        this.to = to;\n        this.flags = flags;\n    }\n    /**\n    The anchor of the range—the side that doesn't move when you\n    extend it.\n    */ get anchor() {\n        return this.flags & 32 /* RangeFlag.Inverted */  ? this.to : this.from;\n    }\n    /**\n    The head of the range, which is moved when the range is\n    [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).\n    */ get head() {\n        return this.flags & 32 /* RangeFlag.Inverted */  ? this.from : this.to;\n    }\n    /**\n    True when `anchor` and `head` are at the same position.\n    */ get empty() {\n        return this.from == this.to;\n    }\n    /**\n    If this is a cursor that is explicitly associated with the\n    character on one of its sides, this returns the side. -1 means\n    the character before its position, 1 the character after, and 0\n    means no association.\n    */ get assoc() {\n        return this.flags & 8 /* RangeFlag.AssocBefore */  ? -1 : this.flags & 16 /* RangeFlag.AssocAfter */  ? 1 : 0;\n    }\n    /**\n    The bidirectional text level associated with this cursor, if\n    any.\n    */ get bidiLevel() {\n        let level = this.flags & 7 /* RangeFlag.BidiLevelMask */ ;\n        return level == 7 ? null : level;\n    }\n    /**\n    The goal column (stored vertical offset) associated with a\n    cursor. This is used to preserve the vertical position when\n    [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across\n    lines of different length.\n    */ get goalColumn() {\n        let value = this.flags >> 6 /* RangeFlag.GoalColumnOffset */ ;\n        return value == 16777215 /* RangeFlag.NoGoalColumn */  ? undefined : value;\n    }\n    /**\n    Map this range through a change, producing a valid range in the\n    updated document.\n    */ map(change, assoc = -1) {\n        let from, to;\n        if (this.empty) {\n            from = to = change.mapPos(this.from, assoc);\n        } else {\n            from = change.mapPos(this.from, 1);\n            to = change.mapPos(this.to, -1);\n        }\n        return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);\n    }\n    /**\n    Extend this range to cover at least `from` to `to`.\n    */ extend(from, to = from) {\n        if (from <= this.anchor && to >= this.anchor) return EditorSelection.range(from, to);\n        let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;\n        return EditorSelection.range(this.anchor, head);\n    }\n    /**\n    Compare this range to another range.\n    */ eq(other, includeAssoc = false) {\n        return this.anchor == other.anchor && this.head == other.head && (!includeAssoc || !this.empty || this.assoc == other.assoc);\n    }\n    /**\n    Return a JSON-serializable object representing the range.\n    */ toJSON() {\n        return {\n            anchor: this.anchor,\n            head: this.head\n        };\n    }\n    /**\n    Convert a JSON representation of a range to a `SelectionRange`\n    instance.\n    */ static fromJSON(json) {\n        if (!json || typeof json.anchor != \"number\" || typeof json.head != \"number\") throw new RangeError(\"Invalid JSON representation for SelectionRange\");\n        return EditorSelection.range(json.anchor, json.head);\n    }\n    /**\n    @internal\n    */ static create(from, to, flags) {\n        return new SelectionRange(from, to, flags);\n    }\n}\n/**\nAn editor selection holds one or more selection ranges.\n*/ class EditorSelection {\n    constructor(/**\n    The ranges in the selection, sorted by position. Ranges cannot\n    overlap (but they may touch, if they aren't empty).\n    */ ranges, /**\n    The index of the _main_ range in the selection (which is\n    usually the range that was added last).\n    */ mainIndex){\n        this.ranges = ranges;\n        this.mainIndex = mainIndex;\n    }\n    /**\n    Map a selection through a change. Used to adjust the selection\n    position for changes.\n    */ map(change, assoc = -1) {\n        if (change.empty) return this;\n        return EditorSelection.create(this.ranges.map((r)=>r.map(change, assoc)), this.mainIndex);\n    }\n    /**\n    Compare this selection to another selection. By default, ranges\n    are compared only by position. When `includeAssoc` is true,\n    cursor ranges must also have the same\n    [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.\n    */ eq(other, includeAssoc = false) {\n        if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex) return false;\n        for(let i = 0; i < this.ranges.length; i++)if (!this.ranges[i].eq(other.ranges[i], includeAssoc)) return false;\n        return true;\n    }\n    /**\n    Get the primary selection range. Usually, you should make sure\n    your code applies to _all_ ranges, by using methods like\n    [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).\n    */ get main() {\n        return this.ranges[this.mainIndex];\n    }\n    /**\n    Make sure the selection only has one range. Returns a selection\n    holding only the main range from this selection.\n    */ asSingle() {\n        return this.ranges.length == 1 ? this : new EditorSelection([\n            this.main\n        ], 0);\n    }\n    /**\n    Extend this selection with an extra range.\n    */ addRange(range, main = true) {\n        return EditorSelection.create([\n            range\n        ].concat(this.ranges), main ? 0 : this.mainIndex + 1);\n    }\n    /**\n    Replace a given range with another range, and then normalize the\n    selection to merge and sort ranges if necessary.\n    */ replaceRange(range, which = this.mainIndex) {\n        let ranges = this.ranges.slice();\n        ranges[which] = range;\n        return EditorSelection.create(ranges, this.mainIndex);\n    }\n    /**\n    Convert this selection to an object that can be serialized to\n    JSON.\n    */ toJSON() {\n        return {\n            ranges: this.ranges.map((r)=>r.toJSON()),\n            main: this.mainIndex\n        };\n    }\n    /**\n    Create a selection from a JSON representation.\n    */ static fromJSON(json) {\n        if (!json || !Array.isArray(json.ranges) || typeof json.main != \"number\" || json.main >= json.ranges.length) throw new RangeError(\"Invalid JSON representation for EditorSelection\");\n        return new EditorSelection(json.ranges.map((r)=>SelectionRange.fromJSON(r)), json.main);\n    }\n    /**\n    Create a selection holding a single range.\n    */ static single(anchor, head = anchor) {\n        return new EditorSelection([\n            EditorSelection.range(anchor, head)\n        ], 0);\n    }\n    /**\n    Sort and merge the given set of ranges, creating a valid\n    selection.\n    */ static create(ranges, mainIndex = 0) {\n        if (ranges.length == 0) throw new RangeError(\"A selection needs at least one range\");\n        for(let pos = 0, i = 0; i < ranges.length; i++){\n            let range = ranges[i];\n            if (range.empty ? range.from <= pos : range.from < pos) return EditorSelection.normalized(ranges.slice(), mainIndex);\n            pos = range.to;\n        }\n        return new EditorSelection(ranges, mainIndex);\n    }\n    /**\n    Create a cursor selection range at the given position. You can\n    safely ignore the optional arguments in most situations.\n    */ static cursor(pos, assoc = 0, bidiLevel, goalColumn) {\n        return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 /* RangeFlag.AssocBefore */  : 16 /* RangeFlag.AssocAfter */ ) | (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215 /* RangeFlag.NoGoalColumn */ ) << 6 /* RangeFlag.GoalColumnOffset */ );\n    }\n    /**\n    Create a selection range.\n    */ static range(anchor, head, goalColumn, bidiLevel) {\n        let flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215 /* RangeFlag.NoGoalColumn */ ) << 6 /* RangeFlag.GoalColumnOffset */  | (bidiLevel == null ? 7 : Math.min(6, bidiLevel));\n        return head < anchor ? SelectionRange.create(head, anchor, 32 /* RangeFlag.Inverted */  | 16 /* RangeFlag.AssocAfter */  | flags) : SelectionRange.create(anchor, head, (head > anchor ? 8 /* RangeFlag.AssocBefore */  : 0) | flags);\n    }\n    /**\n    @internal\n    */ static normalized(ranges, mainIndex = 0) {\n        let main = ranges[mainIndex];\n        ranges.sort((a, b)=>a.from - b.from);\n        mainIndex = ranges.indexOf(main);\n        for(let i = 1; i < ranges.length; i++){\n            let range = ranges[i], prev = ranges[i - 1];\n            if (range.empty ? range.from <= prev.to : range.from < prev.to) {\n                let from = prev.from, to = Math.max(range.to, prev.to);\n                if (i <= mainIndex) mainIndex--;\n                ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));\n            }\n        }\n        return new EditorSelection(ranges, mainIndex);\n    }\n}\nfunction checkSelection(selection, docLength) {\n    for (let range of selection.ranges)if (range.to > docLength) throw new RangeError(\"Selection points outside of document\");\n}\nlet nextID = 0;\n/**\nA facet is a labeled value that is associated with an editor\nstate. It takes inputs from any number of extensions, and combines\nthose into a single output value.\n\nExamples of uses of facets are the [tab\nsize](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize), [editor\nattributes](https://codemirror.net/6/docs/ref/#view.EditorView^editorAttributes), and [update\nlisteners](https://codemirror.net/6/docs/ref/#view.EditorView^updateListener).\n\nNote that `Facet` instances can be used anywhere where\n[`FacetReader`](https://codemirror.net/6/docs/ref/#state.FacetReader) is expected.\n*/ class Facet {\n    constructor(/**\n    @internal\n    */ combine, /**\n    @internal\n    */ compareInput, /**\n    @internal\n    */ compare, isStatic, enables){\n        this.combine = combine;\n        this.compareInput = compareInput;\n        this.compare = compare;\n        this.isStatic = isStatic;\n        /**\n        @internal\n        */ this.id = nextID++;\n        this.default = combine([]);\n        this.extensions = typeof enables == \"function\" ? enables(this) : enables;\n    }\n    /**\n    Returns a facet reader for this facet, which can be used to\n    [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.\n    */ get reader() {\n        return this;\n    }\n    /**\n    Define a new facet.\n    */ static define(config = {}) {\n        return new Facet(config.combine || ((a)=>a), config.compareInput || ((a, b)=>a === b), config.compare || (!config.combine ? sameArray : (a, b)=>a === b), !!config.static, config.enables);\n    }\n    /**\n    Returns an extension that adds the given value to this facet.\n    */ of(value) {\n        return new FacetProvider([], this, 0 /* Provider.Static */ , value);\n    }\n    /**\n    Create an extension that computes a value for the facet from a\n    state. You must take care to declare the parts of the state that\n    this value depends on, since your function is only called again\n    for a new state when one of those parts changed.\n    \n    In cases where your value depends only on a single field, you'll\n    want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.\n    */ compute(deps, get) {\n        if (this.isStatic) throw new Error(\"Can't compute a static facet\");\n        return new FacetProvider(deps, this, 1 /* Provider.Single */ , get);\n    }\n    /**\n    Create an extension that computes zero or more values for this\n    facet from a state.\n    */ computeN(deps, get) {\n        if (this.isStatic) throw new Error(\"Can't compute a static facet\");\n        return new FacetProvider(deps, this, 2 /* Provider.Multi */ , get);\n    }\n    from(field, get) {\n        if (!get) get = (x)=>x;\n        return this.compute([\n            field\n        ], (state)=>get(state.field(field)));\n    }\n}\nfunction sameArray(a, b) {\n    return a == b || a.length == b.length && a.every((e, i)=>e === b[i]);\n}\nclass FacetProvider {\n    constructor(dependencies, facet, type, value){\n        this.dependencies = dependencies;\n        this.facet = facet;\n        this.type = type;\n        this.value = value;\n        this.id = nextID++;\n    }\n    dynamicSlot(addresses) {\n        var _a;\n        let getter = this.value;\n        let compare = this.facet.compareInput;\n        let id = this.id, idx = addresses[id] >> 1, multi = this.type == 2 /* Provider.Multi */ ;\n        let depDoc = false, depSel = false, depAddrs = [];\n        for (let dep of this.dependencies){\n            if (dep == \"doc\") depDoc = true;\n            else if (dep == \"selection\") depSel = true;\n            else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0) depAddrs.push(addresses[dep.id]);\n        }\n        return {\n            create (state) {\n                state.values[idx] = getter(state);\n                return 1 /* SlotStatus.Changed */ ;\n            },\n            update (state, tr) {\n                if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state, depAddrs)) {\n                    let newVal = getter(state);\n                    if (multi ? !compareArray(newVal, state.values[idx], compare) : !compare(newVal, state.values[idx])) {\n                        state.values[idx] = newVal;\n                        return 1 /* SlotStatus.Changed */ ;\n                    }\n                }\n                return 0;\n            },\n            reconfigure: (state, oldState)=>{\n                let newVal, oldAddr = oldState.config.address[id];\n                if (oldAddr != null) {\n                    let oldVal = getAddr(oldState, oldAddr);\n                    if (this.dependencies.every((dep)=>{\n                        return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;\n                    }) || (multi ? compareArray(newVal = getter(state), oldVal, compare) : compare(newVal = getter(state), oldVal))) {\n                        state.values[idx] = oldVal;\n                        return 0;\n                    }\n                } else {\n                    newVal = getter(state);\n                }\n                state.values[idx] = newVal;\n                return 1 /* SlotStatus.Changed */ ;\n            }\n        };\n    }\n}\nfunction compareArray(a, b, compare) {\n    if (a.length != b.length) return false;\n    for(let i = 0; i < a.length; i++)if (!compare(a[i], b[i])) return false;\n    return true;\n}\nfunction ensureAll(state, addrs) {\n    let changed = false;\n    for (let addr of addrs)if (ensureAddr(state, addr) & 1 /* SlotStatus.Changed */ ) changed = true;\n    return changed;\n}\nfunction dynamicFacetSlot(addresses, facet, providers) {\n    let providerAddrs = providers.map((p)=>addresses[p.id]);\n    let providerTypes = providers.map((p)=>p.type);\n    let dynamic = providerAddrs.filter((p)=>!(p & 1));\n    let idx = addresses[facet.id] >> 1;\n    function get(state) {\n        let values = [];\n        for(let i = 0; i < providerAddrs.length; i++){\n            let value = getAddr(state, providerAddrs[i]);\n            if (providerTypes[i] == 2 /* Provider.Multi */ ) for (let val of value)values.push(val);\n            else values.push(value);\n        }\n        return facet.combine(values);\n    }\n    return {\n        create (state) {\n            for (let addr of providerAddrs)ensureAddr(state, addr);\n            state.values[idx] = get(state);\n            return 1 /* SlotStatus.Changed */ ;\n        },\n        update (state, tr) {\n            if (!ensureAll(state, dynamic)) return 0;\n            let value = get(state);\n            if (facet.compare(value, state.values[idx])) return 0;\n            state.values[idx] = value;\n            return 1 /* SlotStatus.Changed */ ;\n        },\n        reconfigure (state, oldState) {\n            let depChanged = ensureAll(state, providerAddrs);\n            let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);\n            if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {\n                state.values[idx] = oldValue;\n                return 0;\n            }\n            let value = get(state);\n            if (facet.compare(value, oldValue)) {\n                state.values[idx] = oldValue;\n                return 0;\n            }\n            state.values[idx] = value;\n            return 1 /* SlotStatus.Changed */ ;\n        }\n    };\n}\nconst initField = /*@__PURE__*/ Facet.define({\n    static: true\n});\n/**\nFields can store additional information in an editor state, and\nkeep it in sync with the rest of the state.\n*/ class StateField {\n    constructor(/**\n    @internal\n    */ id, createF, updateF, compareF, /**\n    @internal\n    */ spec){\n        this.id = id;\n        this.createF = createF;\n        this.updateF = updateF;\n        this.compareF = compareF;\n        this.spec = spec;\n        /**\n        @internal\n        */ this.provides = undefined;\n    }\n    /**\n    Define a state field.\n    */ static define(config) {\n        let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b)=>a === b), config);\n        if (config.provide) field.provides = config.provide(field);\n        return field;\n    }\n    create(state) {\n        let init = state.facet(initField).find((i)=>i.field == this);\n        return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);\n    }\n    /**\n    @internal\n    */ slot(addresses) {\n        let idx = addresses[this.id] >> 1;\n        return {\n            create: (state)=>{\n                state.values[idx] = this.create(state);\n                return 1 /* SlotStatus.Changed */ ;\n            },\n            update: (state, tr)=>{\n                let oldVal = state.values[idx];\n                let value = this.updateF(oldVal, tr);\n                if (this.compareF(oldVal, value)) return 0;\n                state.values[idx] = value;\n                return 1 /* SlotStatus.Changed */ ;\n            },\n            reconfigure: (state, oldState)=>{\n                if (oldState.config.address[this.id] != null) {\n                    state.values[idx] = oldState.field(this);\n                    return 0;\n                }\n                state.values[idx] = this.create(state);\n                return 1 /* SlotStatus.Changed */ ;\n            }\n        };\n    }\n    /**\n    Returns an extension that enables this field and overrides the\n    way it is initialized. Can be useful when you need to provide a\n    non-default starting value for the field.\n    */ init(create) {\n        return [\n            this,\n            initField.of({\n                field: this,\n                create\n            })\n        ];\n    }\n    /**\n    State field instances can be used as\n    [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a\n    given state.\n    */ get extension() {\n        return this;\n    }\n}\nconst Prec_ = {\n    lowest: 4,\n    low: 3,\n    default: 2,\n    high: 1,\n    highest: 0\n};\nfunction prec(value) {\n    return (ext)=>new PrecExtension(ext, value);\n}\n/**\nBy default extensions are registered in the order they are found\nin the flattened form of nested array that was provided.\nIndividual extension values can be assigned a precedence to\noverride this. Extensions that do not have a precedence set get\nthe precedence of the nearest parent with a precedence, or\n[`default`](https://codemirror.net/6/docs/ref/#state.Prec.default) if there is no such parent. The\nfinal ordering of extensions is determined by first sorting by\nprecedence and then by order within each precedence.\n*/ const Prec = {\n    /**\n    The highest precedence level, for extensions that should end up\n    near the start of the precedence ordering.\n    */ highest: /*@__PURE__*/ prec(Prec_.highest),\n    /**\n    A higher-than-default precedence, for extensions that should\n    come before those with default precedence.\n    */ high: /*@__PURE__*/ prec(Prec_.high),\n    /**\n    The default precedence, which is also used for extensions\n    without an explicit precedence.\n    */ default: /*@__PURE__*/ prec(Prec_.default),\n    /**\n    A lower-than-default precedence.\n    */ low: /*@__PURE__*/ prec(Prec_.low),\n    /**\n    The lowest precedence level. Meant for things that should end up\n    near the end of the extension order.\n    */ lowest: /*@__PURE__*/ prec(Prec_.lowest)\n};\nclass PrecExtension {\n    constructor(inner, prec){\n        this.inner = inner;\n        this.prec = prec;\n    }\n}\n/**\nExtension compartments can be used to make a configuration\ndynamic. By [wrapping](https://codemirror.net/6/docs/ref/#state.Compartment.of) part of your\nconfiguration in a compartment, you can later\n[replace](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure) that part through a\ntransaction.\n*/ class Compartment {\n    /**\n    Create an instance of this compartment to add to your [state\n    configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).\n    */ of(ext) {\n        return new CompartmentInstance(this, ext);\n    }\n    /**\n    Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that\n    reconfigures this compartment.\n    */ reconfigure(content) {\n        return Compartment.reconfigure.of({\n            compartment: this,\n            extension: content\n        });\n    }\n    /**\n    Get the current content of the compartment in the state, or\n    `undefined` if it isn't present.\n    */ get(state) {\n        return state.config.compartments.get(this);\n    }\n}\nclass CompartmentInstance {\n    constructor(compartment, inner){\n        this.compartment = compartment;\n        this.inner = inner;\n    }\n}\nclass Configuration {\n    constructor(base, compartments, dynamicSlots, address, staticValues, facets){\n        this.base = base;\n        this.compartments = compartments;\n        this.dynamicSlots = dynamicSlots;\n        this.address = address;\n        this.staticValues = staticValues;\n        this.facets = facets;\n        this.statusTemplate = [];\n        while(this.statusTemplate.length < dynamicSlots.length)this.statusTemplate.push(0 /* SlotStatus.Unresolved */ );\n    }\n    staticFacet(facet) {\n        let addr = this.address[facet.id];\n        return addr == null ? facet.default : this.staticValues[addr >> 1];\n    }\n    static resolve(base, compartments, oldState) {\n        let fields = [];\n        let facets = Object.create(null);\n        let newCompartments = new Map();\n        for (let ext of flatten(base, compartments, newCompartments)){\n            if (ext instanceof StateField) fields.push(ext);\n            else (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);\n        }\n        let address = Object.create(null);\n        let staticValues = [];\n        let dynamicSlots = [];\n        for (let field of fields){\n            address[field.id] = dynamicSlots.length << 1;\n            dynamicSlots.push((a)=>field.slot(a));\n        }\n        let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;\n        for(let id in facets){\n            let providers = facets[id], facet = providers[0].facet;\n            let oldProviders = oldFacets && oldFacets[id] || [];\n            if (providers.every((p)=>p.type == 0 /* Provider.Static */ )) {\n                address[facet.id] = staticValues.length << 1 | 1;\n                if (sameArray(oldProviders, providers)) {\n                    staticValues.push(oldState.facet(facet));\n                } else {\n                    let value = facet.combine(providers.map((p)=>p.value));\n                    staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);\n                }\n            } else {\n                for (let p of providers){\n                    if (p.type == 0 /* Provider.Static */ ) {\n                        address[p.id] = staticValues.length << 1 | 1;\n                        staticValues.push(p.value);\n                    } else {\n                        address[p.id] = dynamicSlots.length << 1;\n                        dynamicSlots.push((a)=>p.dynamicSlot(a));\n                    }\n                }\n                address[facet.id] = dynamicSlots.length << 1;\n                dynamicSlots.push((a)=>dynamicFacetSlot(a, facet, providers));\n            }\n        }\n        let dynamic = dynamicSlots.map((f)=>f(address));\n        return new Configuration(base, newCompartments, dynamic, address, staticValues, facets);\n    }\n}\nfunction flatten(extension, compartments, newCompartments) {\n    let result = [\n        [],\n        [],\n        [],\n        [],\n        []\n    ];\n    let seen = new Map();\n    function inner(ext, prec) {\n        let known = seen.get(ext);\n        if (known != null) {\n            if (known <= prec) return;\n            let found = result[known].indexOf(ext);\n            if (found > -1) result[known].splice(found, 1);\n            if (ext instanceof CompartmentInstance) newCompartments.delete(ext.compartment);\n        }\n        seen.set(ext, prec);\n        if (Array.isArray(ext)) {\n            for (let e of ext)inner(e, prec);\n        } else if (ext instanceof CompartmentInstance) {\n            if (newCompartments.has(ext.compartment)) throw new RangeError(`Duplicate use of compartment in extensions`);\n            let content = compartments.get(ext.compartment) || ext.inner;\n            newCompartments.set(ext.compartment, content);\n            inner(content, prec);\n        } else if (ext instanceof PrecExtension) {\n            inner(ext.inner, ext.prec);\n        } else if (ext instanceof StateField) {\n            result[prec].push(ext);\n            if (ext.provides) inner(ext.provides, prec);\n        } else if (ext instanceof FacetProvider) {\n            result[prec].push(ext);\n            if (ext.facet.extensions) inner(ext.facet.extensions, Prec_.default);\n        } else {\n            let content = ext.extension;\n            if (!content) throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);\n            inner(content, prec);\n        }\n    }\n    inner(extension, Prec_.default);\n    return result.reduce((a, b)=>a.concat(b));\n}\nfunction ensureAddr(state, addr) {\n    if (addr & 1) return 2 /* SlotStatus.Computed */ ;\n    let idx = addr >> 1;\n    let status = state.status[idx];\n    if (status == 4 /* SlotStatus.Computing */ ) throw new Error(\"Cyclic dependency between fields and/or facets\");\n    if (status & 2 /* SlotStatus.Computed */ ) return status;\n    state.status[idx] = 4 /* SlotStatus.Computing */ ;\n    let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);\n    return state.status[idx] = 2 /* SlotStatus.Computed */  | changed;\n}\nfunction getAddr(state, addr) {\n    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];\n}\nconst languageData = /*@__PURE__*/ Facet.define();\nconst allowMultipleSelections = /*@__PURE__*/ Facet.define({\n    combine: (values)=>values.some((v)=>v),\n    static: true\n});\nconst lineSeparator = /*@__PURE__*/ Facet.define({\n    combine: (values)=>values.length ? values[0] : undefined,\n    static: true\n});\nconst changeFilter = /*@__PURE__*/ Facet.define();\nconst transactionFilter = /*@__PURE__*/ Facet.define();\nconst transactionExtender = /*@__PURE__*/ Facet.define();\nconst readOnly = /*@__PURE__*/ Facet.define({\n    combine: (values)=>values.length ? values[0] : false\n});\n/**\nAnnotations are tagged values that are used to add metadata to\ntransactions in an extensible way. They should be used to model\nthings that effect the entire transaction (such as its [time\nstamp](https://codemirror.net/6/docs/ref/#state.Transaction^time) or information about its\n[origin](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent)). For effects that happen\n_alongside_ the other changes made by the transaction, [state\neffects](https://codemirror.net/6/docs/ref/#state.StateEffect) are more appropriate.\n*/ class Annotation {\n    /**\n    @internal\n    */ constructor(/**\n    The annotation type.\n    */ type, /**\n    The value of this annotation.\n    */ value){\n        this.type = type;\n        this.value = value;\n    }\n    /**\n    Define a new type of annotation.\n    */ static define() {\n        return new AnnotationType();\n    }\n}\n/**\nMarker that identifies a type of [annotation](https://codemirror.net/6/docs/ref/#state.Annotation).\n*/ class AnnotationType {\n    /**\n    Create an instance of this annotation.\n    */ of(value) {\n        return new Annotation(this, value);\n    }\n}\n/**\nRepresentation of a type of state effect. Defined with\n[`StateEffect.define`](https://codemirror.net/6/docs/ref/#state.StateEffect^define).\n*/ class StateEffectType {\n    /**\n    @internal\n    */ constructor(// The `any` types in these function types are there to work\n    // around TypeScript issue #37631, where the type guard on\n    // `StateEffect.is` mysteriously stops working when these properly\n    // have type `Value`.\n    /**\n    @internal\n    */ map){\n        this.map = map;\n    }\n    /**\n    Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this\n    type.\n    */ of(value) {\n        return new StateEffect(this, value);\n    }\n}\n/**\nState effects can be used to represent additional effects\nassociated with a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction.effects). They\nare often useful to model changes to custom [state\nfields](https://codemirror.net/6/docs/ref/#state.StateField), when those changes aren't implicit in\ndocument or selection changes.\n*/ class StateEffect {\n    /**\n    @internal\n    */ constructor(/**\n    @internal\n    */ type, /**\n    The value of this effect.\n    */ value){\n        this.type = type;\n        this.value = value;\n    }\n    /**\n    Map this effect through a position mapping. Will return\n    `undefined` when that ends up deleting the effect.\n    */ map(mapping) {\n        let mapped = this.type.map(this.value, mapping);\n        return mapped === undefined ? undefined : mapped == this.value ? this : new StateEffect(this.type, mapped);\n    }\n    /**\n    Tells you whether this effect object is of a given\n    [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).\n    */ is(type) {\n        return this.type == type;\n    }\n    /**\n    Define a new effect type. The type parameter indicates the type\n    of values that his effect holds. It should be a type that\n    doesn't include `undefined`, since that is used in\n    [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is\n    removed.\n    */ static define(spec = {}) {\n        return new StateEffectType(spec.map || ((v)=>v));\n    }\n    /**\n    Map an array of effects through a change set.\n    */ static mapEffects(effects, mapping) {\n        if (!effects.length) return effects;\n        let result = [];\n        for (let effect of effects){\n            let mapped = effect.map(mapping);\n            if (mapped) result.push(mapped);\n        }\n        return result;\n    }\n}\n/**\nThis effect can be used to reconfigure the root extensions of\nthe editor. Doing this will discard any extensions\n[appended](https://codemirror.net/6/docs/ref/#state.StateEffect^appendConfig), but does not reset\nthe content of [reconfigured](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure)\ncompartments.\n*/ StateEffect.reconfigure = /*@__PURE__*/ StateEffect.define();\n/**\nAppend extensions to the top-level configuration of the editor.\n*/ StateEffect.appendConfig = /*@__PURE__*/ StateEffect.define();\n/**\nChanges to the editor state are grouped into transactions.\nTypically, a user action creates a single transaction, which may\ncontain any number of document changes, may change the selection,\nor have other effects. Create a transaction by calling\n[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update), or immediately\ndispatch one by calling\n[`EditorView.dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch).\n*/ class Transaction {\n    constructor(/**\n    The state from which the transaction starts.\n    */ startState, /**\n    The document changes made by this transaction.\n    */ changes, /**\n    The selection set by this transaction, or undefined if it\n    doesn't explicitly set a selection.\n    */ selection, /**\n    The effects added to the transaction.\n    */ effects, /**\n    @internal\n    */ annotations, /**\n    Whether the selection should be scrolled into view after this\n    transaction is dispatched.\n    */ scrollIntoView){\n        this.startState = startState;\n        this.changes = changes;\n        this.selection = selection;\n        this.effects = effects;\n        this.annotations = annotations;\n        this.scrollIntoView = scrollIntoView;\n        /**\n        @internal\n        */ this._doc = null;\n        /**\n        @internal\n        */ this._state = null;\n        if (selection) checkSelection(selection, changes.newLength);\n        if (!annotations.some((a)=>a.type == Transaction.time)) this.annotations = annotations.concat(Transaction.time.of(Date.now()));\n    }\n    /**\n    @internal\n    */ static create(startState, changes, selection, effects, annotations, scrollIntoView) {\n        return new Transaction(startState, changes, selection, effects, annotations, scrollIntoView);\n    }\n    /**\n    The new document produced by the transaction. Contrary to\n    [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't\n    force the entire new state to be computed right away, so it is\n    recommended that [transaction\n    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter\n    when they need to look at the new document.\n    */ get newDoc() {\n        return this._doc || (this._doc = this.changes.apply(this.startState.doc));\n    }\n    /**\n    The new selection produced by the transaction. If\n    [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,\n    this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's\n    current selection through the changes made by the transaction.\n    */ get newSelection() {\n        return this.selection || this.startState.selection.map(this.changes);\n    }\n    /**\n    The new state created by the transaction. Computed on demand\n    (but retained for subsequent access), so it is recommended not to\n    access it in [transaction\n    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.\n    */ get state() {\n        if (!this._state) this.startState.applyTransaction(this);\n        return this._state;\n    }\n    /**\n    Get the value of the given annotation type, if any.\n    */ annotation(type) {\n        for (let ann of this.annotations)if (ann.type == type) return ann.value;\n        return undefined;\n    }\n    /**\n    Indicates whether the transaction changed the document.\n    */ get docChanged() {\n        return !this.changes.empty;\n    }\n    /**\n    Indicates whether this transaction reconfigures the state\n    (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or\n    with a top-level configuration\n    [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).\n    */ get reconfigured() {\n        return this.startState.config != this.state.config;\n    }\n    /**\n    Returns true if the transaction has a [user\n    event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to\n    or more specific than `event`. For example, if the transaction\n    has `\"select.pointer\"` as user event, `\"select\"` and\n    `\"select.pointer\"` will match it.\n    */ isUserEvent(event) {\n        let e = this.annotation(Transaction.userEvent);\n        return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == \".\"));\n    }\n}\n/**\nAnnotation used to store transaction timestamps. Automatically\nadded to every transaction, holding `Date.now()`.\n*/ Transaction.time = /*@__PURE__*/ Annotation.define();\n/**\nAnnotation used to associate a transaction with a user interface\nevent. Holds a string identifying the event, using a\ndot-separated format to support attaching more specific\ninformation. The events used by the core libraries are:\n\n - `\"input\"` when content is entered\n   - `\"input.type\"` for typed input\n     - `\"input.type.compose\"` for composition\n   - `\"input.paste\"` for pasted input\n   - `\"input.drop\"` when adding content with drag-and-drop\n   - `\"input.complete\"` when autocompleting\n - `\"delete\"` when the user deletes content\n   - `\"delete.selection\"` when deleting the selection\n   - `\"delete.forward\"` when deleting forward from the selection\n   - `\"delete.backward\"` when deleting backward from the selection\n   - `\"delete.cut\"` when cutting to the clipboard\n - `\"move\"` when content is moved\n   - `\"move.drop\"` when content is moved within the editor through drag-and-drop\n - `\"select\"` when explicitly changing the selection\n   - `\"select.pointer\"` when selecting with a mouse or other pointing device\n - `\"undo\"` and `\"redo\"` for history actions\n\nUse [`isUserEvent`](https://codemirror.net/6/docs/ref/#state.Transaction.isUserEvent) to check\nwhether the annotation matches a given event.\n*/ Transaction.userEvent = /*@__PURE__*/ Annotation.define();\n/**\nAnnotation indicating whether a transaction should be added to\nthe undo history or not.\n*/ Transaction.addToHistory = /*@__PURE__*/ Annotation.define();\n/**\nAnnotation indicating (when present and true) that a transaction\nrepresents a change made by some other actor, not the user. This\nis used, for example, to tag other people's changes in\ncollaborative editing.\n*/ Transaction.remote = /*@__PURE__*/ Annotation.define();\nfunction joinRanges(a, b) {\n    let result = [];\n    for(let iA = 0, iB = 0;;){\n        let from, to;\n        if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {\n            from = a[iA++];\n            to = a[iA++];\n        } else if (iB < b.length) {\n            from = b[iB++];\n            to = b[iB++];\n        } else return result;\n        if (!result.length || result[result.length - 1] < from) result.push(from, to);\n        else if (result[result.length - 1] < to) result[result.length - 1] = to;\n    }\n}\nfunction mergeTransaction(a, b, sequential) {\n    var _a;\n    let mapForA, mapForB, changes;\n    if (sequential) {\n        mapForA = b.changes;\n        mapForB = ChangeSet.empty(b.changes.length);\n        changes = a.changes.compose(b.changes);\n    } else {\n        mapForA = b.changes.map(a.changes);\n        mapForB = a.changes.mapDesc(b.changes, true);\n        changes = a.changes.compose(mapForA);\n    }\n    return {\n        changes,\n        selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),\n        effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),\n        annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,\n        scrollIntoView: a.scrollIntoView || b.scrollIntoView\n    };\n}\nfunction resolveTransactionInner(state, spec, docSize) {\n    let sel = spec.selection, annotations = asArray(spec.annotations);\n    if (spec.userEvent) annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));\n    return {\n        changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),\n        selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),\n        effects: asArray(spec.effects),\n        annotations,\n        scrollIntoView: !!spec.scrollIntoView\n    };\n}\nfunction resolveTransaction(state, specs, filter) {\n    let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);\n    if (specs.length && specs[0].filter === false) filter = false;\n    for(let i = 1; i < specs.length; i++){\n        if (specs[i].filter === false) filter = false;\n        let seq = !!specs[i].sequential;\n        s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);\n    }\n    let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);\n    return extendTransaction(filter ? filterTransaction(tr) : tr);\n}\n// Finish a transaction by applying filters if necessary.\nfunction filterTransaction(tr) {\n    let state = tr.startState;\n    // Change filters\n    let result = true;\n    for (let filter of state.facet(changeFilter)){\n        let value = filter(tr);\n        if (value === false) {\n            result = false;\n            break;\n        }\n        if (Array.isArray(value)) result = result === true ? value : joinRanges(result, value);\n    }\n    if (result !== true) {\n        let changes, back;\n        if (result === false) {\n            back = tr.changes.invertedDesc;\n            changes = ChangeSet.empty(state.doc.length);\n        } else {\n            let filtered = tr.changes.filter(result);\n            changes = filtered.changes;\n            back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;\n        }\n        tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);\n    }\n    // Transaction filters\n    let filters = state.facet(transactionFilter);\n    for(let i = filters.length - 1; i >= 0; i--){\n        let filtered = filters[i](tr);\n        if (filtered instanceof Transaction) tr = filtered;\n        else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction) tr = filtered[0];\n        else tr = resolveTransaction(state, asArray(filtered), false);\n    }\n    return tr;\n}\nfunction extendTransaction(tr) {\n    let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;\n    for(let i = extenders.length - 1; i >= 0; i--){\n        let extension = extenders[i](tr);\n        if (extension && Object.keys(extension).length) spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);\n    }\n    return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);\n}\nconst none = [];\nfunction asArray(value) {\n    return value == null ? none : Array.isArray(value) ? value : [\n        value\n    ];\n}\n/**\nThe categories produced by a [character\ncategorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer). These are used\ndo things like selecting by word.\n*/ var CharCategory = /*@__PURE__*/ function(CharCategory) {\n    /**\n    Word characters.\n    */ CharCategory[CharCategory[\"Word\"] = 0] = \"Word\";\n    /**\n    Whitespace.\n    */ CharCategory[CharCategory[\"Space\"] = 1] = \"Space\";\n    /**\n    Anything else.\n    */ CharCategory[CharCategory[\"Other\"] = 2] = \"Other\";\n    return CharCategory;\n}(CharCategory || (CharCategory = {}));\nconst nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\nlet wordChar;\ntry {\n    wordChar = /*@__PURE__*/ new RegExp(\"[\\\\p{Alphabetic}\\\\p{Number}_]\", \"u\");\n} catch (_) {}\nfunction hasWordChar(str) {\n    if (wordChar) return wordChar.test(str);\n    for(let i = 0; i < str.length; i++){\n        let ch = str[i];\n        if (/\\w/.test(ch) || ch > \"\\x80\" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))) return true;\n    }\n    return false;\n}\nfunction makeCategorizer(wordChars) {\n    return (char)=>{\n        if (!/\\S/.test(char)) return CharCategory.Space;\n        if (hasWordChar(char)) return CharCategory.Word;\n        for(let i = 0; i < wordChars.length; i++)if (char.indexOf(wordChars[i]) > -1) return CharCategory.Word;\n        return CharCategory.Other;\n    };\n}\n/**\nThe editor state class is a persistent (immutable) data structure.\nTo update a state, you [create](https://codemirror.net/6/docs/ref/#state.EditorState.update) a\n[transaction](https://codemirror.net/6/docs/ref/#state.Transaction), which produces a _new_ state\ninstance, without modifying the original object.\n\nAs such, _never_ mutate properties of a state directly. That'll\njust break things.\n*/ class EditorState {\n    constructor(/**\n    @internal\n    */ config, /**\n    The current document.\n    */ doc, /**\n    The current selection.\n    */ selection, /**\n    @internal\n    */ values, computeSlot, tr){\n        this.config = config;\n        this.doc = doc;\n        this.selection = selection;\n        this.values = values;\n        this.status = config.statusTemplate.slice();\n        this.computeSlot = computeSlot;\n        // Fill in the computed state immediately, so that further queries\n        // for it made during the update return this state\n        if (tr) tr._state = this;\n        for(let i = 0; i < this.config.dynamicSlots.length; i++)ensureAddr(this, i << 1);\n        this.computeSlot = null;\n    }\n    field(field, require = true) {\n        let addr = this.config.address[field.id];\n        if (addr == null) {\n            if (require) throw new RangeError(\"Field is not present in this state\");\n            return undefined;\n        }\n        ensureAddr(this, addr);\n        return getAddr(this, addr);\n    }\n    /**\n    Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this\n    state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)\n    can be passed. Unless\n    [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the\n    [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec\n    are assumed to start in the _current_ document (not the document\n    produced by previous specs), and its\n    [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and\n    [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer\n    to the document created by its _own_ changes. The resulting\n    transaction contains the combined effect of all the different\n    specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later\n    specs take precedence over earlier ones.\n    */ update(...specs) {\n        return resolveTransaction(this, specs, true);\n    }\n    /**\n    @internal\n    */ applyTransaction(tr) {\n        let conf = this.config, { base, compartments } = conf;\n        for (let effect of tr.effects){\n            if (effect.is(Compartment.reconfigure)) {\n                if (conf) {\n                    compartments = new Map;\n                    conf.compartments.forEach((val, key)=>compartments.set(key, val));\n                    conf = null;\n                }\n                compartments.set(effect.value.compartment, effect.value.extension);\n            } else if (effect.is(StateEffect.reconfigure)) {\n                conf = null;\n                base = effect.value;\n            } else if (effect.is(StateEffect.appendConfig)) {\n                conf = null;\n                base = asArray(base).concat(effect.value);\n            }\n        }\n        let startValues;\n        if (!conf) {\n            conf = Configuration.resolve(base, compartments, this);\n            let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(()=>null), (state, slot)=>slot.reconfigure(state, this), null);\n            startValues = intermediateState.values;\n        } else {\n            startValues = tr.startState.values.slice();\n        }\n        let selection = tr.startState.facet(allowMultipleSelections) ? tr.newSelection : tr.newSelection.asSingle();\n        new EditorState(conf, tr.newDoc, selection, startValues, (state, slot)=>slot.update(state, tr), tr);\n    }\n    /**\n    Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that\n    replaces every selection range with the given content.\n    */ replaceSelection(text) {\n        if (typeof text == \"string\") text = this.toText(text);\n        return this.changeByRange((range)=>({\n                changes: {\n                    from: range.from,\n                    to: range.to,\n                    insert: text\n                },\n                range: EditorSelection.cursor(range.from + text.length)\n            }));\n    }\n    /**\n    Create a set of changes and a new selection by running the given\n    function for each range in the active selection. The function\n    can return an optional set of changes (in the coordinate space\n    of the start document), plus an updated range (in the coordinate\n    space of the document produced by the call's own changes). This\n    method will merge all the changes and ranges into a single\n    changeset and selection, and return it as a [transaction\n    spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to\n    [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).\n    */ changeByRange(f) {\n        let sel = this.selection;\n        let result1 = f(sel.ranges[0]);\n        let changes = this.changes(result1.changes), ranges = [\n            result1.range\n        ];\n        let effects = asArray(result1.effects);\n        for(let i = 1; i < sel.ranges.length; i++){\n            let result = f(sel.ranges[i]);\n            let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);\n            for(let j = 0; j < i; j++)ranges[j] = ranges[j].map(newMapped);\n            let mapBy = changes.mapDesc(newChanges, true);\n            ranges.push(result.range.map(mapBy));\n            changes = changes.compose(newMapped);\n            effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));\n        }\n        return {\n            changes,\n            selection: EditorSelection.create(ranges, sel.mainIndex),\n            effects\n        };\n    }\n    /**\n    Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change\n    description, taking the state's document length and line\n    separator into account.\n    */ changes(spec = []) {\n        if (spec instanceof ChangeSet) return spec;\n        return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));\n    }\n    /**\n    Using the state's [line\n    separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a\n    [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.\n    */ toText(string) {\n        return Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));\n    }\n    /**\n    Return the given range of the document as a string.\n    */ sliceDoc(from = 0, to = this.doc.length) {\n        return this.doc.sliceString(from, to, this.lineBreak);\n    }\n    /**\n    Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).\n    */ facet(facet) {\n        let addr = this.config.address[facet.id];\n        if (addr == null) return facet.default;\n        ensureAddr(this, addr);\n        return getAddr(this, addr);\n    }\n    /**\n    Convert this state to a JSON-serializable object. When custom\n    fields should be serialized, you can pass them in as an object\n    mapping property names (in the resulting object, which should\n    not use `doc` or `selection`) to fields.\n    */ toJSON(fields) {\n        let result = {\n            doc: this.sliceDoc(),\n            selection: this.selection.toJSON()\n        };\n        if (fields) for(let prop in fields){\n            let value = fields[prop];\n            if (value instanceof StateField && this.config.address[value.id] != null) result[prop] = value.spec.toJSON(this.field(fields[prop]), this);\n        }\n        return result;\n    }\n    /**\n    Deserialize a state from its JSON representation. When custom\n    fields should be deserialized, pass the same object you passed\n    to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as\n    third argument.\n    */ static fromJSON(json, config = {}, fields) {\n        if (!json || typeof json.doc != \"string\") throw new RangeError(\"Invalid JSON representation for EditorState\");\n        let fieldInit = [];\n        if (fields) for(let prop in fields){\n            if (Object.prototype.hasOwnProperty.call(json, prop)) {\n                let field = fields[prop], value = json[prop];\n                fieldInit.push(field.init((state)=>field.spec.fromJSON(value, state)));\n            }\n        }\n        return EditorState.create({\n            doc: json.doc,\n            selection: EditorSelection.fromJSON(json.selection),\n            extensions: config.extensions ? fieldInit.concat([\n                config.extensions\n            ]) : fieldInit\n        });\n    }\n    /**\n    Create a new state. You'll usually only need this when\n    initializing an editor—updated states are created by applying\n    transactions.\n    */ static create(config = {}) {\n        let configuration = Configuration.resolve(config.extensions || [], new Map);\n        let doc = config.doc instanceof Text ? config.doc : Text.of((config.doc || \"\").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));\n        let selection = !config.selection ? EditorSelection.single(0) : config.selection instanceof EditorSelection ? config.selection : EditorSelection.single(config.selection.anchor, config.selection.head);\n        checkSelection(selection, doc.length);\n        if (!configuration.staticFacet(allowMultipleSelections)) selection = selection.asSingle();\n        return new EditorState(configuration, doc, selection, configuration.dynamicSlots.map(()=>null), (state, slot)=>slot.create(state), null);\n    }\n    /**\n    The size (in columns) of a tab in the document, determined by\n    the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.\n    */ get tabSize() {\n        return this.facet(EditorState.tabSize);\n    }\n    /**\n    Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)\n    string for this state.\n    */ get lineBreak() {\n        return this.facet(EditorState.lineSeparator) || \"\\n\";\n    }\n    /**\n    Returns true when the editor is\n    [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.\n    */ get readOnly() {\n        return this.facet(readOnly);\n    }\n    /**\n    Look up a translation for the given phrase (via the\n    [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the\n    original string if no translation is found.\n    \n    If additional arguments are passed, they will be inserted in\n    place of markers like `$1` (for the first value) and `$2`, etc.\n    A single `$` is equivalent to `$1`, and `$$` will produce a\n    literal dollar sign.\n    */ phrase(phrase, ...insert) {\n        for (let map of this.facet(EditorState.phrases))if (Object.prototype.hasOwnProperty.call(map, phrase)) {\n            phrase = map[phrase];\n            break;\n        }\n        if (insert.length) phrase = phrase.replace(/\\$(\\$|\\d*)/g, (m, i)=>{\n            if (i == \"$\") return \"$\";\n            let n = +(i || 1);\n            return !n || n > insert.length ? m : insert[n - 1];\n        });\n        return phrase;\n    }\n    /**\n    Find the values for a given language data field, provided by the\n    the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.\n    \n    Examples of language data fields are...\n    \n    - [`\"commentTokens\"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying\n      comment syntax.\n    - [`\"autocomplete\"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)\n      for providing language-specific completion sources.\n    - [`\"wordChars\"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding\n      characters that should be considered part of words in this\n      language.\n    - [`\"closeBrackets\"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls\n      bracket closing behavior.\n    */ languageDataAt(name, pos, side = -1) {\n        let values = [];\n        for (let provider of this.facet(languageData)){\n            for (let result of provider(this, pos, side)){\n                if (Object.prototype.hasOwnProperty.call(result, name)) values.push(result[name]);\n            }\n        }\n        return values;\n    }\n    /**\n    Return a function that can categorize strings (expected to\n    represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))\n    into one of:\n    \n     - Word (contains an alphanumeric character or a character\n       explicitly listed in the local language's `\"wordChars\"`\n       language data, which should be a string)\n     - Space (contains only whitespace)\n     - Other (anything else)\n    */ charCategorizer(at) {\n        return makeCategorizer(this.languageDataAt(\"wordChars\", at).join(\"\"));\n    }\n    /**\n    Find the word at the given position, meaning the range\n    containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters\n    around it. If no word characters are adjacent to the position,\n    this returns null.\n    */ wordAt(pos) {\n        let { text, from, length } = this.doc.lineAt(pos);\n        let cat = this.charCategorizer(pos);\n        let start = pos - from, end = pos - from;\n        while(start > 0){\n            let prev = findClusterBreak(text, start, false);\n            if (cat(text.slice(prev, start)) != CharCategory.Word) break;\n            start = prev;\n        }\n        while(end < length){\n            let next = findClusterBreak(text, end);\n            if (cat(text.slice(end, next)) != CharCategory.Word) break;\n            end = next;\n        }\n        return start == end ? null : EditorSelection.range(start + from, end + from);\n    }\n}\n/**\nA facet that, when enabled, causes the editor to allow multiple\nranges to be selected. Be careful though, because by default the\neditor relies on the native DOM selection, which cannot handle\nmultiple selections. An extension like\n[`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) can be used to make\nsecondary selections visible to the user.\n*/ EditorState.allowMultipleSelections = allowMultipleSelections;\n/**\nConfigures the tab size to use in this state. The first\n(highest-precedence) value of the facet is used. If no value is\ngiven, this defaults to 4.\n*/ EditorState.tabSize = /*@__PURE__*/ Facet.define({\n    combine: (values)=>values.length ? values[0] : 4\n});\n/**\nThe line separator to use. By default, any of `\"\\n\"`, `\"\\r\\n\"`\nand `\"\\r\"` is treated as a separator when splitting lines, and\nlines are joined with `\"\\n\"`.\n\nWhen you configure a value here, only that precise separator\nwill be used, allowing you to round-trip documents through the\neditor without normalizing line separators.\n*/ EditorState.lineSeparator = lineSeparator;\n/**\nThis facet controls the value of the\n[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) getter, which is\nconsulted by commands and extensions that implement editing\nfunctionality to determine whether they should apply. It\ndefaults to false, but when its highest-precedence value is\n`true`, such functionality disables itself.\n\nNot to be confused with\n[`EditorView.editable`](https://codemirror.net/6/docs/ref/#view.EditorView^editable), which\ncontrols whether the editor's DOM is set to be editable (and\nthus focusable).\n*/ EditorState.readOnly = readOnly;\n/**\nRegisters translation phrases. The\n[`phrase`](https://codemirror.net/6/docs/ref/#state.EditorState.phrase) method will look through\nall objects registered with this facet to find translations for\nits argument.\n*/ EditorState.phrases = /*@__PURE__*/ Facet.define({\n    compare (a, b) {\n        let kA = Object.keys(a), kB = Object.keys(b);\n        return kA.length == kB.length && kA.every((k)=>a[k] == b[k]);\n    }\n});\n/**\nA facet used to register [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) providers.\n*/ EditorState.languageData = languageData;\n/**\nFacet used to register change filters, which are called for each\ntransaction (unless explicitly\n[disabled](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter)), and can suppress\npart of the transaction's changes.\n\nSuch a function can return `true` to indicate that it doesn't\nwant to do anything, `false` to completely stop the changes in\nthe transaction, or a set of ranges in which changes should be\nsuppressed. Such ranges are represented as an array of numbers,\nwith each pair of two numbers indicating the start and end of a\nrange. So for example `[10, 20, 100, 110]` suppresses changes\nbetween 10 and 20, and between 100 and 110.\n*/ EditorState.changeFilter = changeFilter;\n/**\nFacet used to register a hook that gets a chance to update or\nreplace transaction specs before they are applied. This will\nonly be applied for transactions that don't have\n[`filter`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter) set to `false`. You\ncan either return a single transaction spec (possibly the input\ntransaction), or an array of specs (which will be combined in\nthe same way as the arguments to\n[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update)).\n\nWhen possible, it is recommended to avoid accessing\n[`Transaction.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state) in a filter,\nsince it will force creation of a state that will then be\ndiscarded again, if the transaction is actually filtered.\n\n(This functionality should be used with care. Indiscriminately\nmodifying transaction is likely to break something or degrade\nthe user experience.)\n*/ EditorState.transactionFilter = transactionFilter;\n/**\nThis is a more limited form of\n[`transactionFilter`](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter),\nwhich can only add\n[annotations](https://codemirror.net/6/docs/ref/#state.TransactionSpec.annotations) and\n[effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects). _But_, this type\nof filter runs even if the transaction has disabled regular\n[filtering](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter), making it suitable\nfor effects that don't need to touch the changes or selection,\nbut do want to process every transaction.\n\nExtenders run _after_ filters, when both are present.\n*/ EditorState.transactionExtender = transactionExtender;\nCompartment.reconfigure = /*@__PURE__*/ StateEffect.define();\n/**\nUtility function for combining behaviors to fill in a config\nobject from an array of provided configs. `defaults` should hold\ndefault values for all optional fields in `Config`.\n\nThe function will, by default, error\nwhen a field gets two values that aren't `===`-equal, but you can\nprovide combine functions per field to do something else.\n*/ function combineConfig(configs, defaults, combine = {}) {\n    let result = {};\n    for (let config of configs)for (let key of Object.keys(config)){\n        let value = config[key], current = result[key];\n        if (current === undefined) result[key] = value;\n        else if (current === value || value === undefined) ; // No conflict\n        else if (Object.hasOwnProperty.call(combine, key)) result[key] = combine[key](current, value);\n        else throw new Error(\"Config merge conflict for field \" + key);\n    }\n    for(let key in defaults)if (result[key] === undefined) result[key] = defaults[key];\n    return result;\n}\n/**\nEach range is associated with a value, which must inherit from\nthis class.\n*/ class RangeValue {\n    /**\n    Compare this value with another value. Used when comparing\n    rangesets. The default implementation compares by identity.\n    Unless you are only creating a fixed number of unique instances\n    of your value type, it is a good idea to implement this\n    properly.\n    */ eq(other) {\n        return this == other;\n    }\n    /**\n    Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.\n    */ range(from, to = from) {\n        return Range.create(from, to, this);\n    }\n}\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;\nRangeValue.prototype.point = false;\nRangeValue.prototype.mapMode = MapMode.TrackDel;\n/**\nA range associates a value with a range of positions.\n*/ class Range {\n    constructor(/**\n    The range's start position.\n    */ from, /**\n    Its end position.\n    */ to, /**\n    The value associated with this range.\n    */ value){\n        this.from = from;\n        this.to = to;\n        this.value = value;\n    }\n    /**\n    @internal\n    */ static create(from, to, value) {\n        return new Range(from, to, value);\n    }\n}\nfunction cmpRange(a, b) {\n    return a.from - b.from || a.value.startSide - b.value.startSide;\n}\nclass Chunk {\n    constructor(from, to, value, // Chunks are marked with the largest point that occurs\n    // in them (or -1 for no points), so that scans that are\n    // only interested in points (such as the\n    // heightmap-related logic) can skip range-only chunks.\n    maxPoint){\n        this.from = from;\n        this.to = to;\n        this.value = value;\n        this.maxPoint = maxPoint;\n    }\n    get length() {\n        return this.to[this.to.length - 1];\n    }\n    // Find the index of the given position and side. Use the ranges'\n    // `from` pos when `end == false`, `to` when `end == true`.\n    findIndex(pos, side, end, startAt = 0) {\n        let arr = end ? this.to : this.from;\n        for(let lo = startAt, hi = arr.length;;){\n            if (lo == hi) return lo;\n            let mid = lo + hi >> 1;\n            let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;\n            if (mid == lo) return diff >= 0 ? lo : hi;\n            if (diff >= 0) hi = mid;\n            else lo = mid + 1;\n        }\n    }\n    between(offset, from, to, f) {\n        for(let i = this.findIndex(from, -1000000000 /* C.Far */ , true), e = this.findIndex(to, 1000000000 /* C.Far */ , false, i); i < e; i++)if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false) return false;\n    }\n    map(offset, changes) {\n        let value = [], from = [], to = [], newPos = -1, maxPoint = -1;\n        for(let i = 0; i < this.value.length; i++){\n            let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;\n            if (curFrom == curTo) {\n                let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);\n                if (mapped == null) continue;\n                newFrom = newTo = mapped;\n                if (val.startSide != val.endSide) {\n                    newTo = changes.mapPos(curFrom, val.endSide);\n                    if (newTo < newFrom) continue;\n                }\n            } else {\n                newFrom = changes.mapPos(curFrom, val.startSide);\n                newTo = changes.mapPos(curTo, val.endSide);\n                if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0) continue;\n            }\n            if ((newTo - newFrom || val.endSide - val.startSide) < 0) continue;\n            if (newPos < 0) newPos = newFrom;\n            if (val.point) maxPoint = Math.max(maxPoint, newTo - newFrom);\n            value.push(val);\n            from.push(newFrom - newPos);\n            to.push(newTo - newPos);\n        }\n        return {\n            mapped: value.length ? new Chunk(from, to, value, maxPoint) : null,\n            pos: newPos\n        };\n    }\n}\n/**\nA range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#state.Range) in a\nway that makes them efficient to [map](https://codemirror.net/6/docs/ref/#state.RangeSet.map) and\n[update](https://codemirror.net/6/docs/ref/#state.RangeSet.update). This is an immutable data\nstructure.\n*/ class RangeSet {\n    constructor(/**\n    @internal\n    */ chunkPos, /**\n    @internal\n    */ chunk, /**\n    @internal\n    */ nextLayer, /**\n    @internal\n    */ maxPoint){\n        this.chunkPos = chunkPos;\n        this.chunk = chunk;\n        this.nextLayer = nextLayer;\n        this.maxPoint = maxPoint;\n    }\n    /**\n    @internal\n    */ static create(chunkPos, chunk, nextLayer, maxPoint) {\n        return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);\n    }\n    /**\n    @internal\n    */ get length() {\n        let last = this.chunk.length - 1;\n        return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);\n    }\n    /**\n    The number of ranges in the set.\n    */ get size() {\n        if (this.isEmpty) return 0;\n        let size = this.nextLayer.size;\n        for (let chunk of this.chunk)size += chunk.value.length;\n        return size;\n    }\n    /**\n    @internal\n    */ chunkEnd(index) {\n        return this.chunkPos[index] + this.chunk[index].length;\n    }\n    /**\n    Update the range set, optionally adding new ranges or filtering\n    out existing ones.\n    \n    (Note: The type parameter is just there as a kludge to work\n    around TypeScript variance issues that prevented `RangeSet<X>`\n    from being a subtype of `RangeSet<Y>` when `X` is a subtype of\n    `Y`.)\n    */ update(updateSpec) {\n        let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;\n        let filter = updateSpec.filter;\n        if (add.length == 0 && !filter) return this;\n        if (sort) add = add.slice().sort(cmpRange);\n        if (this.isEmpty) return add.length ? RangeSet.of(add) : this;\n        let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];\n        let builder = new RangeSetBuilder();\n        while(cur.value || i < add.length){\n            if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {\n                let range = add[i++];\n                if (!builder.addInner(range.from, range.to, range.value)) spill.push(range);\n            } else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length && (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) && (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) && builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {\n                cur.nextChunk();\n            } else {\n                if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {\n                    if (!builder.addInner(cur.from, cur.to, cur.value)) spill.push(Range.create(cur.from, cur.to, cur.value));\n                }\n                cur.next();\n            }\n        }\n        return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({\n            add: spill,\n            filter,\n            filterFrom,\n            filterTo\n        }));\n    }\n    /**\n    Map this range set through a set of changes, return the new set.\n    */ map(changes) {\n        if (changes.empty || this.isEmpty) return this;\n        let chunks = [], chunkPos = [], maxPoint = -1;\n        for(let i = 0; i < this.chunk.length; i++){\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            let touch = changes.touchesRange(start, start + chunk.length);\n            if (touch === false) {\n                maxPoint = Math.max(maxPoint, chunk.maxPoint);\n                chunks.push(chunk);\n                chunkPos.push(changes.mapPos(start));\n            } else if (touch === true) {\n                let { mapped, pos } = chunk.map(start, changes);\n                if (mapped) {\n                    maxPoint = Math.max(maxPoint, mapped.maxPoint);\n                    chunks.push(mapped);\n                    chunkPos.push(pos);\n                }\n            }\n        }\n        let next = this.nextLayer.map(changes);\n        return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);\n    }\n    /**\n    Iterate over the ranges that touch the region `from` to `to`,\n    calling `f` for each. There is no guarantee that the ranges will\n    be reported in any specific order. When the callback returns\n    `false`, iteration stops.\n    */ between(from, to, f) {\n        if (this.isEmpty) return;\n        for(let i = 0; i < this.chunk.length; i++){\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false) return;\n        }\n        this.nextLayer.between(from, to, f);\n    }\n    /**\n    Iterate over the ranges in this set, in order, including all\n    ranges that end at or after `from`.\n    */ iter(from = 0) {\n        return HeapCursor.from([\n            this\n        ]).goto(from);\n    }\n    /**\n    @internal\n    */ get isEmpty() {\n        return this.nextLayer == this;\n    }\n    /**\n    Iterate over the ranges in a collection of sets, in order,\n    starting from `from`.\n    */ static iter(sets, from = 0) {\n        return HeapCursor.from(sets).goto(from);\n    }\n    /**\n    Iterate over two groups of sets, calling methods on `comparator`\n    to notify it of possible differences.\n    */ static compare(oldSets, newSets, /**\n    This indicates how the underlying data changed between these\n    ranges, and is needed to synchronize the iteration.\n    */ textDiff, comparator, /**\n    Can be used to ignore all non-point ranges, and points below\n    the given size. When -1, all ranges are compared.\n    */ minPointSize = -1) {\n        let a = oldSets.filter((set)=>set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\n        let b = newSets.filter((set)=>set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\n        let sharedChunks = findSharedChunks(a, b, textDiff);\n        let sideA = new SpanCursor(a, sharedChunks, minPointSize);\n        let sideB = new SpanCursor(b, sharedChunks, minPointSize);\n        textDiff.iterGaps((fromA, fromB, length)=>compare(sideA, fromA, sideB, fromB, length, comparator));\n        if (textDiff.empty && textDiff.length == 0) compare(sideA, 0, sideB, 0, 0, comparator);\n    }\n    /**\n    Compare the contents of two groups of range sets, returning true\n    if they are equivalent in the given range.\n    */ static eq(oldSets, newSets, from = 0, to) {\n        if (to == null) to = 1000000000 /* C.Far */  - 1;\n        let a = oldSets.filter((set)=>!set.isEmpty && newSets.indexOf(set) < 0);\n        let b = newSets.filter((set)=>!set.isEmpty && oldSets.indexOf(set) < 0);\n        if (a.length != b.length) return false;\n        if (!a.length) return true;\n        let sharedChunks = findSharedChunks(a, b);\n        let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);\n        for(;;){\n            if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point))) return false;\n            if (sideA.to > to) return true;\n            sideA.next();\n            sideB.next();\n        }\n    }\n    /**\n    Iterate over a group of range sets at the same time, notifying\n    the iterator about the ranges covering every given piece of\n    content. Returns the open count (see\n    [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end\n    of the iteration.\n    */ static spans(sets, from, to, iterator, /**\n    When given and greater than -1, only points of at least this\n    size are taken into account.\n    */ minPointSize = -1) {\n        let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;\n        let openRanges = cursor.openStart;\n        for(;;){\n            let curTo = Math.min(cursor.to, to);\n            if (cursor.point) {\n                let active = cursor.activeForPoint(cursor.to);\n                let openCount = cursor.pointFrom < from ? active.length + 1 : Math.min(active.length, openRanges);\n                iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);\n                openRanges = Math.min(cursor.openEnd(curTo), active.length);\n            } else if (curTo > pos) {\n                iterator.span(pos, curTo, cursor.active, openRanges);\n                openRanges = cursor.openEnd(curTo);\n            }\n            if (cursor.to > to) return openRanges + (cursor.point && cursor.to > to ? 1 : 0);\n            pos = cursor.to;\n            cursor.next();\n        }\n    }\n    /**\n    Create a range set for the given range or array of ranges. By\n    default, this expects the ranges to be _sorted_ (by start\n    position and, if two start at the same position,\n    `value.startSide`). You can pass `true` as second argument to\n    cause the method to sort them.\n    */ static of(ranges, sort = false) {\n        let build = new RangeSetBuilder();\n        for (let range of ranges instanceof Range ? [\n            ranges\n        ] : sort ? lazySort(ranges) : ranges)build.add(range.from, range.to, range.value);\n        return build.finish();\n    }\n    /**\n    Join an array of range sets into a single set.\n    */ static join(sets) {\n        if (!sets.length) return RangeSet.empty;\n        let result = sets[sets.length - 1];\n        for(let i = sets.length - 2; i >= 0; i--){\n            for(let layer = sets[i]; layer != RangeSet.empty; layer = layer.nextLayer)result = new RangeSet(layer.chunkPos, layer.chunk, result, Math.max(layer.maxPoint, result.maxPoint));\n        }\n        return result;\n    }\n}\n/**\nThe empty set of ranges.\n*/ RangeSet.empty = /*@__PURE__*/ new RangeSet([], [], null, -1);\nfunction lazySort(ranges) {\n    if (ranges.length > 1) for(let prev = ranges[0], i = 1; i < ranges.length; i++){\n        let cur = ranges[i];\n        if (cmpRange(prev, cur) > 0) return ranges.slice().sort(cmpRange);\n        prev = cur;\n    }\n    return ranges;\n}\nRangeSet.empty.nextLayer = RangeSet.empty;\n/**\nA range set builder is a data structure that helps build up a\n[range set](https://codemirror.net/6/docs/ref/#state.RangeSet) directly, without first allocating\nan array of [`Range`](https://codemirror.net/6/docs/ref/#state.Range) objects.\n*/ class RangeSetBuilder {\n    finishChunk(newArrays) {\n        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));\n        this.chunkPos.push(this.chunkStart);\n        this.chunkStart = -1;\n        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);\n        this.maxPoint = -1;\n        if (newArrays) {\n            this.from = [];\n            this.to = [];\n            this.value = [];\n        }\n    }\n    /**\n    Create an empty builder.\n    */ constructor(){\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunkStart = -1;\n        this.last = null;\n        this.lastFrom = -1000000000 /* C.Far */ ;\n        this.lastTo = -1000000000 /* C.Far */ ;\n        this.from = [];\n        this.to = [];\n        this.value = [];\n        this.maxPoint = -1;\n        this.setMaxPoint = -1;\n        this.nextLayer = null;\n    }\n    /**\n    Add a range. Ranges should be added in sorted (by `from` and\n    `value.startSide`) order.\n    */ add(from, to, value) {\n        if (!this.addInner(from, to, value)) (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value);\n    }\n    /**\n    @internal\n    */ addInner(from, to, value) {\n        let diff = from - this.lastTo || value.startSide - this.last.endSide;\n        if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0) throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\");\n        if (diff < 0) return false;\n        if (this.from.length == 250 /* C.ChunkSize */ ) this.finishChunk(true);\n        if (this.chunkStart < 0) this.chunkStart = from;\n        this.from.push(from - this.chunkStart);\n        this.to.push(to - this.chunkStart);\n        this.last = value;\n        this.lastFrom = from;\n        this.lastTo = to;\n        this.value.push(value);\n        if (value.point) this.maxPoint = Math.max(this.maxPoint, to - from);\n        return true;\n    }\n    /**\n    @internal\n    */ addChunk(from, chunk) {\n        if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0) return false;\n        if (this.from.length) this.finishChunk(true);\n        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);\n        this.chunks.push(chunk);\n        this.chunkPos.push(from);\n        let last = chunk.value.length - 1;\n        this.last = chunk.value[last];\n        this.lastFrom = chunk.from[last] + from;\n        this.lastTo = chunk.to[last] + from;\n        return true;\n    }\n    /**\n    Finish the range set. Returns the new set. The builder can't be\n    used anymore after this has been called.\n    */ finish() {\n        return this.finishInner(RangeSet.empty);\n    }\n    /**\n    @internal\n    */ finishInner(next) {\n        if (this.from.length) this.finishChunk(false);\n        if (this.chunks.length == 0) return next;\n        let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);\n        this.from = null; // Make sure further `add` calls produce errors\n        return result;\n    }\n}\nfunction findSharedChunks(a, b, textDiff) {\n    let inA = new Map();\n    for (let set of a)for(let i = 0; i < set.chunk.length; i++)if (set.chunk[i].maxPoint <= 0) inA.set(set.chunk[i], set.chunkPos[i]);\n    let shared = new Set();\n    for (let set of b)for(let i = 0; i < set.chunk.length; i++){\n        let known = inA.get(set.chunk[i]);\n        if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length))) shared.add(set.chunk[i]);\n    }\n    return shared;\n}\nclass LayerCursor {\n    constructor(layer, skip, minPoint, rank = 0){\n        this.layer = layer;\n        this.skip = skip;\n        this.minPoint = minPoint;\n        this.rank = rank;\n    }\n    get startSide() {\n        return this.value ? this.value.startSide : 0;\n    }\n    get endSide() {\n        return this.value ? this.value.endSide : 0;\n    }\n    goto(pos, side = -1000000000 /* C.Far */ ) {\n        this.chunkIndex = this.rangeIndex = 0;\n        this.gotoInner(pos, side, false);\n        return this;\n    }\n    gotoInner(pos, side, forward) {\n        while(this.chunkIndex < this.layer.chunk.length){\n            let next = this.layer.chunk[this.chunkIndex];\n            if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint)) break;\n            this.chunkIndex++;\n            forward = false;\n        }\n        if (this.chunkIndex < this.layer.chunk.length) {\n            let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);\n            if (!forward || this.rangeIndex < rangeIndex) this.setRangeIndex(rangeIndex);\n        }\n        this.next();\n    }\n    forward(pos, side) {\n        if ((this.to - pos || this.endSide - side) < 0) this.gotoInner(pos, side, true);\n    }\n    next() {\n        for(;;){\n            if (this.chunkIndex == this.layer.chunk.length) {\n                this.from = this.to = 1000000000 /* C.Far */ ;\n                this.value = null;\n                break;\n            } else {\n                let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];\n                let from = chunkPos + chunk.from[this.rangeIndex];\n                this.from = from;\n                this.to = chunkPos + chunk.to[this.rangeIndex];\n                this.value = chunk.value[this.rangeIndex];\n                this.setRangeIndex(this.rangeIndex + 1);\n                if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint) break;\n            }\n        }\n    }\n    setRangeIndex(index) {\n        if (index == this.layer.chunk[this.chunkIndex].value.length) {\n            this.chunkIndex++;\n            if (this.skip) {\n                while(this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))this.chunkIndex++;\n            }\n            this.rangeIndex = 0;\n        } else {\n            this.rangeIndex = index;\n        }\n    }\n    nextChunk() {\n        this.chunkIndex++;\n        this.rangeIndex = 0;\n        this.next();\n    }\n    compare(other) {\n        return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;\n    }\n}\nclass HeapCursor {\n    constructor(heap){\n        this.heap = heap;\n    }\n    static from(sets, skip = null, minPoint = -1) {\n        let heap = [];\n        for(let i = 0; i < sets.length; i++){\n            for(let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer){\n                if (cur.maxPoint >= minPoint) heap.push(new LayerCursor(cur, skip, minPoint, i));\n            }\n        }\n        return heap.length == 1 ? heap[0] : new HeapCursor(heap);\n    }\n    get startSide() {\n        return this.value ? this.value.startSide : 0;\n    }\n    goto(pos, side = -1000000000 /* C.Far */ ) {\n        for (let cur of this.heap)cur.goto(pos, side);\n        for(let i = this.heap.length >> 1; i >= 0; i--)heapBubble(this.heap, i);\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        for (let cur of this.heap)cur.forward(pos, side);\n        for(let i = this.heap.length >> 1; i >= 0; i--)heapBubble(this.heap, i);\n        if ((this.to - pos || this.value.endSide - side) < 0) this.next();\n    }\n    next() {\n        if (this.heap.length == 0) {\n            this.from = this.to = 1000000000 /* C.Far */ ;\n            this.value = null;\n            this.rank = -1;\n        } else {\n            let top = this.heap[0];\n            this.from = top.from;\n            this.to = top.to;\n            this.value = top.value;\n            this.rank = top.rank;\n            if (top.value) top.next();\n            heapBubble(this.heap, 0);\n        }\n    }\n}\nfunction heapBubble(heap, index) {\n    for(let cur = heap[index];;){\n        let childIndex = (index << 1) + 1;\n        if (childIndex >= heap.length) break;\n        let child = heap[childIndex];\n        if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {\n            child = heap[childIndex + 1];\n            childIndex++;\n        }\n        if (cur.compare(child) < 0) break;\n        heap[childIndex] = cur;\n        heap[index] = child;\n        index = childIndex;\n    }\n}\nclass SpanCursor {\n    constructor(sets, skip, minPoint){\n        this.minPoint = minPoint;\n        this.active = [];\n        this.activeTo = [];\n        this.activeRank = [];\n        this.minActive = -1;\n        // A currently active point range, if any\n        this.point = null;\n        this.pointFrom = 0;\n        this.pointRank = 0;\n        this.to = -1000000000 /* C.Far */ ;\n        this.endSide = 0;\n        // The amount of open active ranges at the start of the iterator.\n        // Not including points.\n        this.openStart = -1;\n        this.cursor = HeapCursor.from(sets, skip, minPoint);\n    }\n    goto(pos, side = -1000000000 /* C.Far */ ) {\n        this.cursor.goto(pos, side);\n        this.active.length = this.activeTo.length = this.activeRank.length = 0;\n        this.minActive = -1;\n        this.to = pos;\n        this.endSide = side;\n        this.openStart = -1;\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        while(this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)this.removeActive(this.minActive);\n        this.cursor.forward(pos, side);\n    }\n    removeActive(index) {\n        remove(this.active, index);\n        remove(this.activeTo, index);\n        remove(this.activeRank, index);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    addActive(trackOpen) {\n        let i = 0, { value, to, rank } = this.cursor;\n        // Organize active marks by rank first, then by size\n        while(i < this.activeRank.length && (rank - this.activeRank[i] || to - this.activeTo[i]) > 0)i++;\n        insert(this.active, i, value);\n        insert(this.activeTo, i, to);\n        insert(this.activeRank, i, rank);\n        if (trackOpen) insert(trackOpen, i, this.cursor.from);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    // After calling this, if `this.point` != null, the next range is a\n    // point. Otherwise, it's a regular range, covered by `this.active`.\n    next() {\n        let from = this.to, wasPoint = this.point;\n        this.point = null;\n        let trackOpen = this.openStart < 0 ? [] : null;\n        for(;;){\n            let a = this.minActive;\n            if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {\n                if (this.activeTo[a] > from) {\n                    this.to = this.activeTo[a];\n                    this.endSide = this.active[a].endSide;\n                    break;\n                }\n                this.removeActive(a);\n                if (trackOpen) remove(trackOpen, a);\n            } else if (!this.cursor.value) {\n                this.to = this.endSide = 1000000000 /* C.Far */ ;\n                break;\n            } else if (this.cursor.from > from) {\n                this.to = this.cursor.from;\n                this.endSide = this.cursor.startSide;\n                break;\n            } else {\n                let nextVal = this.cursor.value;\n                if (!nextVal.point) {\n                    this.addActive(trackOpen);\n                    this.cursor.next();\n                } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {\n                    // Ignore any non-empty points that end precisely at the end of the prev point\n                    this.cursor.next();\n                } else {\n                    this.point = nextVal;\n                    this.pointFrom = this.cursor.from;\n                    this.pointRank = this.cursor.rank;\n                    this.to = this.cursor.to;\n                    this.endSide = nextVal.endSide;\n                    this.cursor.next();\n                    this.forward(this.to, this.endSide);\n                    break;\n                }\n            }\n        }\n        if (trackOpen) {\n            this.openStart = 0;\n            for(let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from; i--)this.openStart++;\n        }\n    }\n    activeForPoint(to) {\n        if (!this.active.length) return this.active;\n        let active = [];\n        for(let i = this.active.length - 1; i >= 0; i--){\n            if (this.activeRank[i] < this.pointRank) break;\n            if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide) active.push(this.active[i]);\n        }\n        return active.reverse();\n    }\n    openEnd(to) {\n        let open = 0;\n        for(let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)open++;\n        return open;\n    }\n}\nfunction compare(a, startA, b, startB, length, comparator) {\n    a.goto(startA);\n    b.goto(startB);\n    let endB = startB + length;\n    let pos = startB, dPos = startB - startA;\n    for(;;){\n        let diff = a.to + dPos - b.to || a.endSide - b.endSide;\n        let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);\n        if (a.point || b.point) {\n            if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to), b.activeForPoint(b.to)))) comparator.comparePoint(pos, clipEnd, a.point, b.point);\n        } else {\n            if (clipEnd > pos && !sameValues(a.active, b.active)) comparator.compareRange(pos, clipEnd, a.active, b.active);\n        }\n        if (end > endB) break;\n        pos = end;\n        if (diff <= 0) a.next();\n        if (diff >= 0) b.next();\n    }\n}\nfunction sameValues(a, b) {\n    if (a.length != b.length) return false;\n    for(let i = 0; i < a.length; i++)if (a[i] != b[i] && !a[i].eq(b[i])) return false;\n    return true;\n}\nfunction remove(array, index) {\n    for(let i = index, e = array.length - 1; i < e; i++)array[i] = array[i + 1];\n    array.pop();\n}\nfunction insert(array, index, value) {\n    for(let i = array.length - 1; i >= index; i--)array[i + 1] = array[i];\n    array[index] = value;\n}\nfunction findMinIndex(value, array) {\n    let found = -1, foundPos = 1000000000 /* C.Far */ ;\n    for(let i = 0; i < array.length; i++)if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {\n        found = i;\n        foundPos = array[i];\n    }\n    return found;\n}\n/**\nCount the column position at the given offset into the string,\ntaking extending characters and tab size into account.\n*/ function countColumn(string, tabSize, to = string.length) {\n    let n = 0;\n    for(let i = 0; i < to;){\n        if (string.charCodeAt(i) == 9) {\n            n += tabSize - n % tabSize;\n            i++;\n        } else {\n            n++;\n            i = findClusterBreak(string, i);\n        }\n    }\n    return n;\n}\n/**\nFind the offset that corresponds to the given column position in a\nstring, taking extending characters and tab size into account. By\ndefault, the string length is returned when it is too short to\nreach the column. Pass `strict` true to make it return -1 in that\nsituation.\n*/ function findColumn(string, col, tabSize, strict) {\n    for(let i = 0, n = 0;;){\n        if (n >= col) return i;\n        if (i == string.length) break;\n        n += string.charCodeAt(i) == 9 ? tabSize - n % tabSize : 1;\n        i = findClusterBreak(string, i);\n    }\n    return strict === true ? -1 : string.length;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivc3RhdGUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUVBLEdBQ0EsTUFBTUE7SUFDRjs7SUFFQSxHQUNBQyxPQUFPQyxHQUFHLEVBQUU7UUFDUixJQUFJQSxNQUFNLEtBQUtBLE1BQU0sSUFBSSxDQUFDQyxNQUFNLEVBQzVCLE1BQU0sSUFBSUMsV0FBVyxDQUFDLGlCQUFpQixFQUFFRixJQUFJLHVCQUF1QixFQUFFLElBQUksQ0FBQ0MsTUFBTSxDQUFDLENBQUM7UUFDdkYsT0FBTyxJQUFJLENBQUNFLFNBQVMsQ0FBQ0gsS0FBSyxPQUFPLEdBQUc7SUFDekM7SUFDQTs7SUFFQSxHQUNBSSxLQUFLQyxDQUFDLEVBQUU7UUFDSixJQUFJQSxJQUFJLEtBQUtBLElBQUksSUFBSSxDQUFDQyxLQUFLLEVBQ3ZCLE1BQU0sSUFBSUosV0FBVyxDQUFDLG9CQUFvQixFQUFFRyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUNDLEtBQUssQ0FBQyxjQUFjLENBQUM7UUFDbEYsT0FBTyxJQUFJLENBQUNILFNBQVMsQ0FBQ0UsR0FBRyxNQUFNLEdBQUc7SUFDdEM7SUFDQTs7SUFFQSxHQUNBRSxRQUFRQyxJQUFJLEVBQUVDLEVBQUUsRUFBRUMsSUFBSSxFQUFFO1FBQ3BCLENBQUNGLE1BQU1DLEdBQUcsR0FBR0UsS0FBSyxJQUFJLEVBQUVILE1BQU1DO1FBQzlCLElBQUlHLFFBQVEsRUFBRTtRQUNkLElBQUksQ0FBQ0MsU0FBUyxDQUFDLEdBQUdMLE1BQU1JLE9BQU8sRUFBRSxXQUFXO1FBQzVDLElBQUlGLEtBQUtULE1BQU0sRUFDWFMsS0FBS0csU0FBUyxDQUFDLEdBQUdILEtBQUtULE1BQU0sRUFBRVcsT0FBTyxFQUFFLGFBQWEsTUFBSyxFQUFFLFdBQVc7UUFDM0UsSUFBSSxDQUFDQyxTQUFTLENBQUNKLElBQUksSUFBSSxDQUFDUixNQUFNLEVB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LE1BQU07QUFDL0M7QUFFa1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYmMvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivc3RhdGUvZGlzdC9pbmRleC5qcz84YzhhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuVGhlIGRhdGEgc3RydWN0dXJlIGZvciBkb2N1bWVudHMuIEBub25hYnN0cmFjdFxuKi9cbmNsYXNzIFRleHQge1xuICAgIC8qKlxuICAgIEdldCB0aGUgbGluZSBkZXNjcmlwdGlvbiBhcm91bmQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgbGluZUF0KHBvcykge1xuICAgICAgICBpZiAocG9zIDwgMCB8fCBwb3MgPiB0aGlzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIHBvc2l0aW9uICR7cG9zfSBpbiBkb2N1bWVudCBvZiBsZW5ndGggJHt0aGlzLmxlbmd0aH1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUlubmVyKHBvcywgZmFsc2UsIDEsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGRlc2NyaXB0aW9uIGZvciB0aGUgZ2l2ZW4gKDEtYmFzZWQpIGxpbmUgbnVtYmVyLlxuICAgICovXG4gICAgbGluZShuKSB7XG4gICAgICAgIGlmIChuIDwgMSB8fCBuID4gdGhpcy5saW5lcylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGxpbmUgbnVtYmVyICR7bn0gaW4gJHt0aGlzLmxpbmVzfS1saW5lIGRvY3VtZW50YCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVJbm5lcihuLCB0cnVlLCAxLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSBhIHJhbmdlIG9mIHRoZSB0ZXh0IHdpdGggdGhlIGdpdmVuIGNvbnRlbnQuXG4gICAgKi9cbiAgICByZXBsYWNlKGZyb20sIHRvLCB0ZXh0KSB7XG4gICAgICAgIFtmcm9tLCB0b10gPSBjbGlwKHRoaXMsIGZyb20sIHRvKTtcbiAgICAgICAgbGV0IHBhcnRzID0gW107XG4gICAgICAgIHRoaXMuZGVjb21wb3NlKDAsIGZyb20sIHBhcnRzLCAyIC8qIE9wZW4uVG8gKi8pO1xuICAgICAgICBpZiAodGV4dC5sZW5ndGgpXG4gICAgICAgICAgICB0ZXh0LmRlY29tcG9zZSgwLCB0ZXh0Lmxlbmd0aCwgcGFydHMsIDEgLyogT3Blbi5Gcm9tICovIHwgMiAvKiBPcGVuLlRvICovKTtcbiAgICAgICAgdGhpcy5kZWNvbXBvc2UodG8sIHRoaXMubGVuZ3RoLCBwYXJ0cywgMSAvKiBPcGVuLkZyb20gKi8pO1xuICAgICAgICByZXR1cm4gVGV4dE5vZGUuZnJvbShwYXJ0cywgdGhpcy5sZW5ndGggLSAodG8gLSBmcm9tKSArIHRleHQubGVuZ3RoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQXBwZW5kIGFub3RoZXIgZG9jdW1lbnQgdG8gdGhpcyBvbmUuXG4gICAgKi9cbiAgICBhcHBlbmQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZSh0aGlzLmxlbmd0aCwgdGhpcy5sZW5ndGgsIG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0cmlldmUgdGhlIHRleHQgYmV0d2VlbiB0aGUgZ2l2ZW4gcG9pbnRzLlxuICAgICovXG4gICAgc2xpY2UoZnJvbSwgdG8gPSB0aGlzLmxlbmd0aCkge1xuICAgICAgICBbZnJvbSwgdG9dID0gY2xpcCh0aGlzLCBmcm9tLCB0byk7XG4gICAgICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLmRlY29tcG9zZShmcm9tLCB0bywgcGFydHMsIDApO1xuICAgICAgICByZXR1cm4gVGV4dE5vZGUuZnJvbShwYXJ0cywgdG8gLSBmcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoaXMgdGV4dCBpcyBlcXVhbCB0byBhbm90aGVyIGluc3RhbmNlLlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyID09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG90aGVyLmxlbmd0aCAhPSB0aGlzLmxlbmd0aCB8fCBvdGhlci5saW5lcyAhPSB0aGlzLmxpbmVzKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnNjYW5JZGVudGljYWwob3RoZXIsIDEpLCBlbmQgPSB0aGlzLmxlbmd0aCAtIHRoaXMuc2NhbklkZW50aWNhbChvdGhlciwgLTEpO1xuICAgICAgICBsZXQgYSA9IG5ldyBSYXdUZXh0Q3Vyc29yKHRoaXMpLCBiID0gbmV3IFJhd1RleHRDdXJzb3Iob3RoZXIpO1xuICAgICAgICBmb3IgKGxldCBza2lwID0gc3RhcnQsIHBvcyA9IHN0YXJ0OzspIHtcbiAgICAgICAgICAgIGEubmV4dChza2lwKTtcbiAgICAgICAgICAgIGIubmV4dChza2lwKTtcbiAgICAgICAgICAgIHNraXAgPSAwO1xuICAgICAgICAgICAgaWYgKGEubGluZUJyZWFrICE9IGIubGluZUJyZWFrIHx8IGEuZG9uZSAhPSBiLmRvbmUgfHwgYS52YWx1ZSAhPSBiLnZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHBvcyArPSBhLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChhLmRvbmUgfHwgcG9zID49IGVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHRleHQuIFdoZW4gYGRpcmAgaXMgYC0xYCwgaXRlcmF0aW9uIGhhcHBlbnNcbiAgICBmcm9tIGVuZCB0byBzdGFydC4gVGhpcyB3aWxsIHJldHVybiBsaW5lcyBhbmQgdGhlIGJyZWFrcyBiZXR3ZWVuXG4gICAgdGhlbSBhcyBzZXBhcmF0ZSBzdHJpbmdzLlxuICAgICovXG4gICAgaXRlcihkaXIgPSAxKSB7IHJldHVybiBuZXcgUmF3VGV4dEN1cnNvcih0aGlzLCBkaXIpOyB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIGEgcmFuZ2Ugb2YgdGhlIHRleHQuIFdoZW4gYGZyb21gID4gYHRvYCwgdGhlXG4gICAgaXRlcmF0b3Igd2lsbCBydW4gaW4gcmV2ZXJzZS5cbiAgICAqL1xuICAgIGl0ZXJSYW5nZShmcm9tLCB0byA9IHRoaXMubGVuZ3RoKSB7IHJldHVybiBuZXcgUGFydGlhbFRleHRDdXJzb3IodGhpcywgZnJvbSwgdG8pOyB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgY3Vyc29yIHRoYXQgaXRlcmF0ZXMgb3ZlciB0aGUgZ2l2ZW4gcmFuZ2Ugb2YgbGluZXMsXG4gICAgX3dpdGhvdXRfIHJldHVybmluZyB0aGUgbGluZSBicmVha3MgYmV0d2VlbiwgYW5kIHlpZWxkaW5nIGVtcHR5XG4gICAgc3RyaW5ncyBmb3IgZW1wdHkgbGluZXMuXG4gICAgXG4gICAgV2hlbiBgZnJvbWAgYW5kIGB0b2AgYXJlIGdpdmVuLCB0aGV5IHNob3VsZCBiZSAxLWJhc2VkIGxpbmUgbnVtYmVycy5cbiAgICAqL1xuICAgIGl0ZXJMaW5lcyhmcm9tLCB0bykge1xuICAgICAgICBsZXQgaW5uZXI7XG4gICAgICAgIGlmIChmcm9tID09IG51bGwpIHtcbiAgICAgICAgICAgIGlubmVyID0gdGhpcy5pdGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodG8gPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0byA9IHRoaXMubGluZXMgKyAxO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5saW5lKGZyb20pLmZyb207XG4gICAgICAgICAgICBpbm5lciA9IHRoaXMuaXRlclJhbmdlKHN0YXJ0LCBNYXRoLm1heChzdGFydCwgdG8gPT0gdGhpcy5saW5lcyArIDEgPyB0aGlzLmxlbmd0aCA6IHRvIDw9IDEgPyAwIDogdGhpcy5saW5lKHRvIC0gMSkudG8pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExpbmVDdXJzb3IoaW5uZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gdGhlIGRvY3VtZW50IGFzIGEgc3RyaW5nLCB1c2luZyBuZXdsaW5lIGNoYXJhY3RlcnMgdG9cbiAgICBzZXBhcmF0ZSBsaW5lcy5cbiAgICAqL1xuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5zbGljZVN0cmluZygwKTsgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgdGhlIGRvY3VtZW50IHRvIGFuIGFycmF5IG9mIGxpbmVzICh3aGljaCBjYW4gYmVcbiAgICBkZXNlcmlhbGl6ZWQgYWdhaW4gdmlhIFtgVGV4dC5vZmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVGV4dF5vZikpLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgbGluZXMgPSBbXTtcbiAgICAgICAgdGhpcy5mbGF0dGVuKGxpbmVzKTtcbiAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkgeyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgYFRleHRgIGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2YgbGluZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgb2YodGV4dCkge1xuICAgICAgICBpZiAodGV4dC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQSBkb2N1bWVudCBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGxpbmVcIik7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PSAxICYmICF0ZXh0WzBdKVxuICAgICAgICAgICAgcmV0dXJuIFRleHQuZW1wdHk7XG4gICAgICAgIHJldHVybiB0ZXh0Lmxlbmd0aCA8PSAzMiAvKiBUcmVlLkJyYW5jaCAqLyA/IG5ldyBUZXh0TGVhZih0ZXh0KSA6IFRleHROb2RlLmZyb20oVGV4dExlYWYuc3BsaXQodGV4dCwgW10pKTtcbiAgICB9XG59XG4vLyBMZWF2ZXMgc3RvcmUgYW4gYXJyYXkgb2YgbGluZSBzdHJpbmdzLiBUaGVyZSBhcmUgYWx3YXlzIGxpbmUgYnJlYWtzXG4vLyBiZXR3ZWVuIHRoZXNlIHN0cmluZ3MuIExlYXZlcyBhcmUgbGltaXRlZCBpbiBzaXplIGFuZCBoYXZlIHRvIGJlXG4vLyBjb250YWluZWQgaW4gVGV4dE5vZGUgaW5zdGFuY2VzIGZvciBiaWdnZXIgZG9jdW1lbnRzLlxuY2xhc3MgVGV4dExlYWYgZXh0ZW5kcyBUZXh0IHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBsZW5ndGggPSB0ZXh0TGVuZ3RoKHRleHQpKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgbGluZXMoKSB7IHJldHVybiB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgZ2V0IGNoaWxkcmVuKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGxpbmVJbm5lcih0YXJnZXQsIGlzTGluZSwgbGluZSwgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RyaW5nID0gdGhpcy50ZXh0W2ldLCBlbmQgPSBvZmZzZXQgKyBzdHJpbmcubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKChpc0xpbmUgPyBsaW5lIDogZW5kKSA+PSB0YXJnZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMaW5lKG9mZnNldCwgZW5kLCBsaW5lLCBzdHJpbmcpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kICsgMTtcbiAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWNvbXBvc2UoZnJvbSwgdG8sIHRhcmdldCwgb3Blbikge1xuICAgICAgICBsZXQgdGV4dCA9IGZyb20gPD0gMCAmJiB0byA+PSB0aGlzLmxlbmd0aCA/IHRoaXNcbiAgICAgICAgICAgIDogbmV3IFRleHRMZWFmKHNsaWNlVGV4dCh0aGlzLnRleHQsIGZyb20sIHRvKSwgTWF0aC5taW4odG8sIHRoaXMubGVuZ3RoKSAtIE1hdGgubWF4KDAsIGZyb20pKTtcbiAgICAgICAgaWYgKG9wZW4gJiAxIC8qIE9wZW4uRnJvbSAqLykge1xuICAgICAgICAgICAgbGV0IHByZXYgPSB0YXJnZXQucG9wKCk7XG4gICAgICAgICAgICBsZXQgam9pbmVkID0gYXBwZW5kVGV4dCh0ZXh0LnRleHQsIHByZXYudGV4dC5zbGljZSgpLCAwLCB0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoam9pbmVkLmxlbmd0aCA8PSAzMiAvKiBUcmVlLkJyYW5jaCAqLykge1xuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ldyBUZXh0TGVhZihqb2luZWQsIHByZXYubGVuZ3RoICsgdGV4dC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBtaWQgPSBqb2luZWQubGVuZ3RoID4+IDE7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobmV3IFRleHRMZWFmKGpvaW5lZC5zbGljZSgwLCBtaWQpKSwgbmV3IFRleHRMZWFmKGpvaW5lZC5zbGljZShtaWQpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQucHVzaCh0ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKGZyb20sIHRvLCB0ZXh0KSB7XG4gICAgICAgIGlmICghKHRleHQgaW5zdGFuY2VvZiBUZXh0TGVhZikpXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIucmVwbGFjZShmcm9tLCB0bywgdGV4dCk7XG4gICAgICAgIFtmcm9tLCB0b10gPSBjbGlwKHRoaXMsIGZyb20sIHRvKTtcbiAgICAgICAgbGV0IGxpbmVzID0gYXBwZW5kVGV4dCh0aGlzLnRleHQsIGFwcGVuZFRleHQodGV4dC50ZXh0LCBzbGljZVRleHQodGhpcy50ZXh0LCAwLCBmcm9tKSksIHRvKTtcbiAgICAgICAgbGV0IG5ld0xlbiA9IHRoaXMubGVuZ3RoICsgdGV4dC5sZW5ndGggLSAodG8gLSBmcm9tKTtcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA8PSAzMiAvKiBUcmVlLkJyYW5jaCAqLylcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dExlYWYobGluZXMsIG5ld0xlbik7XG4gICAgICAgIHJldHVybiBUZXh0Tm9kZS5mcm9tKFRleHRMZWFmLnNwbGl0KGxpbmVzLCBbXSksIG5ld0xlbik7XG4gICAgfVxuICAgIHNsaWNlU3RyaW5nKGZyb20sIHRvID0gdGhpcy5sZW5ndGgsIGxpbmVTZXAgPSBcIlxcblwiKSB7XG4gICAgICAgIFtmcm9tLCB0b10gPSBjbGlwKHRoaXMsIGZyb20sIHRvKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGkgPSAwOyBwb3MgPD0gdG8gJiYgaSA8IHRoaXMudGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnRleHRbaV0sIGVuZCA9IHBvcyArIGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20gJiYgaSlcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gbGluZVNlcDtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgZW5kICYmIHRvID4gcG9zKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lLnNsaWNlKE1hdGgubWF4KDAsIGZyb20gLSBwb3MpLCB0byAtIHBvcyk7XG4gICAgICAgICAgICBwb3MgPSBlbmQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZsYXR0ZW4odGFyZ2V0KSB7XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGhpcy50ZXh0KVxuICAgICAgICAgICAgdGFyZ2V0LnB1c2gobGluZSk7XG4gICAgfVxuICAgIHNjYW5JZGVudGljYWwoKSB7IHJldHVybiAwOyB9XG4gICAgc3RhdGljIHNwbGl0KHRleHQsIHRhcmdldCkge1xuICAgICAgICBsZXQgcGFydCA9IFtdLCBsZW4gPSAtMTtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0ZXh0KSB7XG4gICAgICAgICAgICBwYXJ0LnB1c2gobGluZSk7XG4gICAgICAgICAgICBsZW4gKz0gbGluZS5sZW5ndGggKyAxO1xuICAgICAgICAgICAgaWYgKHBhcnQubGVuZ3RoID09IDMyIC8qIFRyZWUuQnJhbmNoICovKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobmV3IFRleHRMZWFmKHBhcnQsIGxlbikpO1xuICAgICAgICAgICAgICAgIHBhcnQgPSBbXTtcbiAgICAgICAgICAgICAgICBsZW4gPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuID4gLTEpXG4gICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVGV4dExlYWYocGFydCwgbGVuKSk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxufVxuLy8gTm9kZXMgcHJvdmlkZSB0aGUgdHJlZSBzdHJ1Y3R1cmUgb2YgdGhlIGBUZXh0YCB0eXBlLiBUaGV5IHN0b3JlIGFcbi8vIG51bWJlciBvZiBvdGhlciBub2RlcyBvciBsZWF2ZXMsIHRha2luZyBjYXJlIHRvIGJhbGFuY2UgdGhlbXNlbHZlc1xuLy8gb24gY2hhbmdlcy4gVGhlcmUgYXJlIGltcGxpZWQgbGluZSBicmVha3MgX2JldHdlZW5fIHRoZSBjaGlsZHJlbiBvZlxuLy8gYSBub2RlIChidXQgbm90IGJlZm9yZSB0aGUgZmlyc3Qgb3IgYWZ0ZXIgdGhlIGxhc3QgY2hpbGQpLlxuY2xhc3MgVGV4dE5vZGUgZXh0ZW5kcyBUZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihjaGlsZHJlbiwgbGVuZ3RoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMubGluZXMgPSAwO1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZHJlbilcbiAgICAgICAgICAgIHRoaXMubGluZXMgKz0gY2hpbGQubGluZXM7XG4gICAgfVxuICAgIGxpbmVJbm5lcih0YXJnZXQsIGlzTGluZSwgbGluZSwgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBvZmZzZXQgKyBjaGlsZC5sZW5ndGgsIGVuZExpbmUgPSBsaW5lICsgY2hpbGQubGluZXMgLSAxO1xuICAgICAgICAgICAgaWYgKChpc0xpbmUgPyBlbmRMaW5lIDogZW5kKSA+PSB0YXJnZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmxpbmVJbm5lcih0YXJnZXQsIGlzTGluZSwgbGluZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCA9IGVuZCArIDE7XG4gICAgICAgICAgICBsaW5lID0gZW5kTGluZSArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVjb21wb3NlKGZyb20sIHRvLCB0YXJnZXQsIG9wZW4pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IHBvcyA8PSB0byAmJiBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gcG9zICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGZyb20gPD0gZW5kICYmIHRvID49IHBvcykge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZE9wZW4gPSBvcGVuICYgKChwb3MgPD0gZnJvbSA/IDEgLyogT3Blbi5Gcm9tICovIDogMCkgfCAoZW5kID49IHRvID8gMiAvKiBPcGVuLlRvICovIDogMCkpO1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gZnJvbSAmJiBlbmQgPD0gdG8gJiYgIWNoaWxkT3BlbilcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGVjb21wb3NlKGZyb20gLSBwb3MsIHRvIC0gcG9zLCB0YXJnZXQsIGNoaWxkT3Blbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSBlbmQgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2UoZnJvbSwgdG8sIHRleHQpIHtcbiAgICAgICAgW2Zyb20sIHRvXSA9IGNsaXAodGhpcywgZnJvbSwgdG8pO1xuICAgICAgICBpZiAodGV4dC5saW5lcyA8IHRoaXMubGluZXMpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiBpZiB0aGUgY2hhbmdlIG9ubHkgYWZmZWN0cyBvbmUgY2hpbGQgYW5kIHRoZVxuICAgICAgICAgICAgICAgIC8vIGNoaWxkJ3Mgc2l6ZSByZW1haW5zIGluIHRoZSBhY2NlcHRhYmxlIHJhbmdlLCBvbmx5IHVwZGF0ZVxuICAgICAgICAgICAgICAgIC8vIHRoYXQgY2hpbGRcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBwb3MgJiYgdG8gPD0gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB1cGRhdGVkID0gY2hpbGQucmVwbGFjZShmcm9tIC0gcG9zLCB0byAtIHBvcywgdGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0b3RhbExpbmVzID0gdGhpcy5saW5lcyAtIGNoaWxkLmxpbmVzICsgdXBkYXRlZC5saW5lcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZWQubGluZXMgPCAodG90YWxMaW5lcyA+PiAoNSAvKiBUcmVlLkJyYW5jaFNoaWZ0ICovIC0gMSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLmxpbmVzID4gKHRvdGFsTGluZXMgPj4gKDUgLyogVHJlZS5CcmFuY2hTaGlmdCAqLyArIDEpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvcHkgPSB0aGlzLmNoaWxkcmVuLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5W2ldID0gdXBkYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dE5vZGUoY29weSwgdGhpcy5sZW5ndGggLSAodG8gLSBmcm9tKSArIHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VwZXIucmVwbGFjZShwb3MsIGVuZCwgdXBkYXRlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5yZXBsYWNlKGZyb20sIHRvLCB0ZXh0KTtcbiAgICB9XG4gICAgc2xpY2VTdHJpbmcoZnJvbSwgdG8gPSB0aGlzLmxlbmd0aCwgbGluZVNlcCA9IFwiXFxuXCIpIHtcbiAgICAgICAgW2Zyb20sIHRvXSA9IGNsaXAodGhpcywgZnJvbSwgdG8pO1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aCAmJiBwb3MgPD0gdG87IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gcG9zICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20gJiYgaSlcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gbGluZVNlcDtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgZW5kICYmIHRvID4gcG9zKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjaGlsZC5zbGljZVN0cmluZyhmcm9tIC0gcG9zLCB0byAtIHBvcywgbGluZVNlcCk7XG4gICAgICAgICAgICBwb3MgPSBlbmQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZsYXR0ZW4odGFyZ2V0KSB7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pXG4gICAgICAgICAgICBjaGlsZC5mbGF0dGVuKHRhcmdldCk7XG4gICAgfVxuICAgIHNjYW5JZGVudGljYWwob3RoZXIsIGRpcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFRleHROb2RlKSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICAgICAgbGV0IFtpQSwgaUIsIGVBLCBlQl0gPSBkaXIgPiAwID8gWzAsIDAsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoLCBvdGhlci5jaGlsZHJlbi5sZW5ndGhdXG4gICAgICAgICAgICA6IFt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDEsIG90aGVyLmNoaWxkcmVuLmxlbmd0aCAtIDEsIC0xLCAtMV07XG4gICAgICAgIGZvciAoOzsgaUEgKz0gZGlyLCBpQiArPSBkaXIpIHtcbiAgICAgICAgICAgIGlmIChpQSA9PSBlQSB8fCBpQiA9PSBlQilcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGNoQSA9IHRoaXMuY2hpbGRyZW5baUFdLCBjaEIgPSBvdGhlci5jaGlsZHJlbltpQl07XG4gICAgICAgICAgICBpZiAoY2hBICE9IGNoQilcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoICsgY2hBLnNjYW5JZGVudGljYWwoY2hCLCBkaXIpO1xuICAgICAgICAgICAgbGVuZ3RoICs9IGNoQS5sZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKGNoaWxkcmVuLCBsZW5ndGggPSBjaGlsZHJlbi5yZWR1Y2UoKGwsIGNoKSA9PiBsICsgY2gubGVuZ3RoICsgMSwgLTEpKSB7XG4gICAgICAgIGxldCBsaW5lcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoIG9mIGNoaWxkcmVuKVxuICAgICAgICAgICAgbGluZXMgKz0gY2gubGluZXM7XG4gICAgICAgIGlmIChsaW5lcyA8IDMyIC8qIFRyZWUuQnJhbmNoICovKSB7XG4gICAgICAgICAgICBsZXQgZmxhdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgY2ggb2YgY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgY2guZmxhdHRlbihmbGF0KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dExlYWYoZmxhdCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2h1bmsgPSBNYXRoLm1heCgzMiAvKiBUcmVlLkJyYW5jaCAqLywgbGluZXMgPj4gNSAvKiBUcmVlLkJyYW5jaFNoaWZ0ICovKSwgbWF4Q2h1bmsgPSBjaHVuayA8PCAxLCBtaW5DaHVuayA9IGNodW5rID4+IDE7XG4gICAgICAgIGxldCBjaHVua2VkID0gW10sIGN1cnJlbnRMaW5lcyA9IDAsIGN1cnJlbnRMZW4gPSAtMSwgY3VycmVudENodW5rID0gW107XG4gICAgICAgIGZ1bmN0aW9uIGFkZChjaGlsZCkge1xuICAgICAgICAgICAgbGV0IGxhc3Q7XG4gICAgICAgICAgICBpZiAoY2hpbGQubGluZXMgPiBtYXhDaHVuayAmJiBjaGlsZCBpbnN0YW5jZW9mIFRleHROb2RlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBjaGlsZC5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICAgICAgYWRkKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQubGluZXMgPiBtaW5DaHVuayAmJiAoY3VycmVudExpbmVzID4gbWluQ2h1bmsgfHwgIWN1cnJlbnRMaW5lcykpIHtcbiAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgIGNodW5rZWQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRleHRMZWFmICYmIGN1cnJlbnRMaW5lcyAmJlxuICAgICAgICAgICAgICAgIChsYXN0ID0gY3VycmVudENodW5rW2N1cnJlbnRDaHVuay5sZW5ndGggLSAxXSkgaW5zdGFuY2VvZiBUZXh0TGVhZiAmJlxuICAgICAgICAgICAgICAgIGNoaWxkLmxpbmVzICsgbGFzdC5saW5lcyA8PSAzMiAvKiBUcmVlLkJyYW5jaCAqLykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lcyArPSBjaGlsZC5saW5lcztcbiAgICAgICAgICAgICAgICBjdXJyZW50TGVuICs9IGNoaWxkLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgY3VycmVudENodW5rW2N1cnJlbnRDaHVuay5sZW5ndGggLSAxXSA9IG5ldyBUZXh0TGVhZihsYXN0LnRleHQuY29uY2F0KGNoaWxkLnRleHQpLCBsYXN0Lmxlbmd0aCArIDEgKyBjaGlsZC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRMaW5lcyArIGNoaWxkLmxpbmVzID4gY2h1bmspXG4gICAgICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgY3VycmVudExpbmVzICs9IGNoaWxkLmxpbmVzO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMZW4gKz0gY2hpbGQubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2h1bmsucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudExpbmVzID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2h1bmtlZC5wdXNoKGN1cnJlbnRDaHVuay5sZW5ndGggPT0gMSA/IGN1cnJlbnRDaHVua1swXSA6IFRleHROb2RlLmZyb20oY3VycmVudENodW5rLCBjdXJyZW50TGVuKSk7XG4gICAgICAgICAgICBjdXJyZW50TGVuID0gLTE7XG4gICAgICAgICAgICBjdXJyZW50TGluZXMgPSBjdXJyZW50Q2h1bmsubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZHJlbilcbiAgICAgICAgICAgIGFkZChjaGlsZCk7XG4gICAgICAgIGZsdXNoKCk7XG4gICAgICAgIHJldHVybiBjaHVua2VkLmxlbmd0aCA9PSAxID8gY2h1bmtlZFswXSA6IG5ldyBUZXh0Tm9kZShjaHVua2VkLCBsZW5ndGgpO1xuICAgIH1cbn1cblRleHQuZW1wdHkgPSAvKkBfX1BVUkVfXyovbmV3IFRleHRMZWFmKFtcIlwiXSwgMCk7XG5mdW5jdGlvbiB0ZXh0TGVuZ3RoKHRleHQpIHtcbiAgICBsZXQgbGVuZ3RoID0gLTE7XG4gICAgZm9yIChsZXQgbGluZSBvZiB0ZXh0KVxuICAgICAgICBsZW5ndGggKz0gbGluZS5sZW5ndGggKyAxO1xuICAgIHJldHVybiBsZW5ndGg7XG59XG5mdW5jdGlvbiBhcHBlbmRUZXh0KHRleHQsIHRhcmdldCwgZnJvbSA9IDAsIHRvID0gMWU5KSB7XG4gICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDAsIGZpcnN0ID0gdHJ1ZTsgaSA8IHRleHQubGVuZ3RoICYmIHBvcyA8PSB0bzsgaSsrKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGV4dFtpXSwgZW5kID0gcG9zICsgbGluZS5sZW5ndGg7XG4gICAgICAgIGlmIChlbmQgPj0gZnJvbSkge1xuICAgICAgICAgICAgaWYgKGVuZCA+IHRvKVxuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIHRvIC0gcG9zKTtcbiAgICAgICAgICAgIGlmIChwb3MgPCBmcm9tKVxuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKGZyb20gLSBwb3MpO1xuICAgICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3RhcmdldC5sZW5ndGggLSAxXSArPSBsaW5lO1xuICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gZW5kICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIHNsaWNlVGV4dCh0ZXh0LCBmcm9tLCB0bykge1xuICAgIHJldHVybiBhcHBlbmRUZXh0KHRleHQsIFtcIlwiXSwgZnJvbSwgdG8pO1xufVxuY2xhc3MgUmF3VGV4dEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IodGV4dCwgZGlyID0gMSkge1xuICAgICAgICB0aGlzLmRpciA9IGRpcjtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGluZUJyZWFrID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLm5vZGVzID0gW3RleHRdO1xuICAgICAgICB0aGlzLm9mZnNldHMgPSBbZGlyID4gMCA/IDEgOiAodGV4dCBpbnN0YW5jZW9mIFRleHRMZWFmID8gdGV4dC50ZXh0Lmxlbmd0aCA6IHRleHQuY2hpbGRyZW4ubGVuZ3RoKSA8PCAxXTtcbiAgICB9XG4gICAgbmV4dElubmVyKHNraXAsIGRpcikge1xuICAgICAgICB0aGlzLmRvbmUgPSB0aGlzLmxpbmVCcmVhayA9IGZhbHNlO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IHRoaXMubm9kZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGxldCB0b3AgPSB0aGlzLm5vZGVzW2xhc3RdLCBvZmZzZXRWYWx1ZSA9IHRoaXMub2Zmc2V0c1tsYXN0XSwgb2Zmc2V0ID0gb2Zmc2V0VmFsdWUgPj4gMTtcbiAgICAgICAgICAgIGxldCBzaXplID0gdG9wIGluc3RhbmNlb2YgVGV4dExlYWYgPyB0b3AudGV4dC5sZW5ndGggOiB0b3AuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA9PSAoZGlyID4gMCA/IHNpemUgOiAwKSkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGlyID4gMClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3QgLSAxXSsrO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKG9mZnNldFZhbHVlICYgMSkgPT0gKGRpciA+IDAgPyAwIDogMSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHNbbGFzdF0gKz0gZGlyO1xuICAgICAgICAgICAgICAgIGlmIChza2lwID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lQnJlYWsgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNraXAtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRvcCBpbnN0YW5jZW9mIFRleHRMZWFmKSB7XG4gICAgICAgICAgICAgICAgLy8gTW92ZSB0byB0aGUgbmV4dCBzdHJpbmdcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRvcC50ZXh0W29mZnNldCArIChkaXIgPCAwID8gLTEgOiAwKV07XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3RdICs9IGRpcjtcbiAgICAgICAgICAgICAgICBpZiAobmV4dC5sZW5ndGggPiBNYXRoLm1heCgwLCBza2lwKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gc2tpcCA9PSAwID8gbmV4dCA6IGRpciA+IDAgPyBuZXh0LnNsaWNlKHNraXApIDogbmV4dC5zbGljZSgwLCBuZXh0Lmxlbmd0aCAtIHNraXApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2tpcCAtPSBuZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdG9wLmNoaWxkcmVuW29mZnNldCArIChkaXIgPCAwID8gLTEgOiAwKV07XG4gICAgICAgICAgICAgICAgaWYgKHNraXAgPiBuZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBza2lwIC09IG5leHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHNbbGFzdF0gKz0gZGlyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpciA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHNbbGFzdF0tLTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHMucHVzaChkaXIgPiAwID8gMSA6IChuZXh0IGluc3RhbmNlb2YgVGV4dExlYWYgPyBuZXh0LnRleHQubGVuZ3RoIDogbmV4dC5jaGlsZHJlbi5sZW5ndGgpIDw8IDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXh0KHNraXAgPSAwKSB7XG4gICAgICAgIGlmIChza2lwIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0SW5uZXIoLXNraXAsICgtdGhpcy5kaXIpKTtcbiAgICAgICAgICAgIHNraXAgPSB0aGlzLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0SW5uZXIoc2tpcCwgdGhpcy5kaXIpO1xuICAgIH1cbn1cbmNsYXNzIFBhcnRpYWxUZXh0Q3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBuZXcgUmF3VGV4dEN1cnNvcih0ZXh0LCBzdGFydCA+IGVuZCA/IC0xIDogMSk7XG4gICAgICAgIHRoaXMucG9zID0gc3RhcnQgPiBlbmQgPyB0ZXh0Lmxlbmd0aCA6IDA7XG4gICAgICAgIHRoaXMuZnJvbSA9IE1hdGgubWluKHN0YXJ0LCBlbmQpO1xuICAgICAgICB0aGlzLnRvID0gTWF0aC5tYXgoc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIG5leHRJbm5lcihza2lwLCBkaXIpIHtcbiAgICAgICAgaWYgKGRpciA8IDAgPyB0aGlzLnBvcyA8PSB0aGlzLmZyb20gOiB0aGlzLnBvcyA+PSB0aGlzLnRvKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBza2lwICs9IE1hdGgubWF4KDAsIGRpciA8IDAgPyB0aGlzLnBvcyAtIHRoaXMudG8gOiB0aGlzLmZyb20gLSB0aGlzLnBvcyk7XG4gICAgICAgIGxldCBsaW1pdCA9IGRpciA8IDAgPyB0aGlzLnBvcyAtIHRoaXMuZnJvbSA6IHRoaXMudG8gLSB0aGlzLnBvcztcbiAgICAgICAgaWYgKHNraXAgPiBsaW1pdClcbiAgICAgICAgICAgIHNraXAgPSBsaW1pdDtcbiAgICAgICAgbGltaXQgLT0gc2tpcDtcbiAgICAgICAgbGV0IHsgdmFsdWUgfSA9IHRoaXMuY3Vyc29yLm5leHQoc2tpcCk7XG4gICAgICAgIHRoaXMucG9zICs9ICh2YWx1ZS5sZW5ndGggKyBza2lwKSAqIGRpcjtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlLmxlbmd0aCA8PSBsaW1pdCA/IHZhbHVlIDogZGlyIDwgMCA/IHZhbHVlLnNsaWNlKHZhbHVlLmxlbmd0aCAtIGxpbWl0KSA6IHZhbHVlLnNsaWNlKDAsIGxpbWl0KTtcbiAgICAgICAgdGhpcy5kb25lID0gIXRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBuZXh0KHNraXAgPSAwKSB7XG4gICAgICAgIGlmIChza2lwIDwgMClcbiAgICAgICAgICAgIHNraXAgPSBNYXRoLm1heChza2lwLCB0aGlzLmZyb20gLSB0aGlzLnBvcyk7XG4gICAgICAgIGVsc2UgaWYgKHNraXAgPiAwKVxuICAgICAgICAgICAgc2tpcCA9IE1hdGgubWluKHNraXAsIHRoaXMudG8gLSB0aGlzLnBvcyk7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRJbm5lcihza2lwLCB0aGlzLmN1cnNvci5kaXIpO1xuICAgIH1cbiAgICBnZXQgbGluZUJyZWFrKCkgeyByZXR1cm4gdGhpcy5jdXJzb3IubGluZUJyZWFrICYmIHRoaXMudmFsdWUgIT0gXCJcIjsgfVxufVxuY2xhc3MgTGluZUN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoaW5uZXIpIHtcbiAgICAgICAgdGhpcy5pbm5lciA9IGlubmVyO1xuICAgICAgICB0aGlzLmFmdGVyQnJlYWsgPSB0cnVlO1xuICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgfVxuICAgIG5leHQoc2tpcCA9IDApIHtcbiAgICAgICAgbGV0IHsgZG9uZSwgbGluZUJyZWFrLCB2YWx1ZSB9ID0gdGhpcy5pbm5lci5uZXh0KHNraXApO1xuICAgICAgICBpZiAoZG9uZSAmJiB0aGlzLmFmdGVyQnJlYWspIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5hZnRlckJyZWFrID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG9uZSkge1xuICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxpbmVCcmVhaykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWZ0ZXJCcmVhaykge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZnRlckJyZWFrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJCcmVhayA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbGluZUJyZWFrKCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbmlmICh0eXBlb2YgU3ltYm9sICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICBUZXh0LnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5pdGVyKCk7IH07XG4gICAgUmF3VGV4dEN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IFBhcnRpYWxUZXh0Q3Vyc29yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID1cbiAgICAgICAgTGluZUN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG59XG4vKipcblRoaXMgdHlwZSBkZXNjcmliZXMgYSBsaW5lIGluIHRoZSBkb2N1bWVudC4gSXQgaXMgY3JlYXRlZFxub24tZGVtYW5kIHdoZW4gbGluZXMgYXJlIFtxdWVyaWVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRleHQubGluZUF0KS5cbiovXG5jbGFzcyBMaW5lIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBvZiB0aGUgc3RhcnQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgbGluZSAoX2JlZm9yZV8gdGhlIGxpbmUgYnJlYWssXG4gICAgb3IgYXQgdGhlIGVuZCBvZiBkb2N1bWVudCBmb3IgdGhlIGxhc3QgbGluZSkuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhpcyBsaW5lJ3MgbGluZSBudW1iZXIgKDEtYmFzZWQpLlxuICAgICovXG4gICAgbnVtYmVyLCBcbiAgICAvKipcbiAgICBUaGUgbGluZSdzIGNvbnRlbnQuXG4gICAgKi9cbiAgICB0ZXh0KSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5udW1iZXIgPSBudW1iZXI7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBsZW5ndGggb2YgdGhlIGxpbmUgKG5vdCBpbmNsdWRpbmcgYW55IGxpbmUgYnJlYWsgYWZ0ZXIgaXQpLlxuICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMudG8gLSB0aGlzLmZyb207IH1cbn1cbmZ1bmN0aW9uIGNsaXAodGV4dCwgZnJvbSwgdG8pIHtcbiAgICBmcm9tID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGV4dC5sZW5ndGgsIGZyb20pKTtcbiAgICByZXR1cm4gW2Zyb20sIE1hdGgubWF4KGZyb20sIE1hdGgubWluKHRleHQubGVuZ3RoLCB0bykpXTtcbn1cblxuLy8gQ29tcHJlc3NlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgR3JhcGhlbWVfQ2x1c3Rlcl9CcmVhaz1FeHRlbmRcbi8vIGluZm9ybWF0aW9uIGZyb21cbi8vIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvUHVibGljLzEzLjAuMC91Y2QvYXV4aWxpYXJ5L0dyYXBoZW1lQnJlYWtQcm9wZXJ0eS50eHQuXG4vLyBFYWNoIHBhaXIgb2YgZWxlbWVudHMgcmVwcmVzZW50cyBhIHJhbmdlLCBhcyBhbiBvZmZldCBmcm9tIHRoZVxuLy8gcHJldmlvdXMgcmFuZ2UgYW5kIGEgbGVuZ3RoLiBOdW1iZXJzIGFyZSBpbiBiYXNlLTM2LCB3aXRoIHRoZSBlbXB0eVxuLy8gc3RyaW5nIGJlaW5nIGEgc2hvcnRoYW5kIGZvciAxLlxubGV0IGV4dGVuZCA9IC8qQF9fUFVSRV9fKi9cImxjLDM0LDduLDcsN2IsMTksLCwsMiwsMiwsLDIwLGIsMWMsbCxnLCwydCw3LDIsNiwyLDIsLDQseiwsdSxyLDJqLGIsMW0sOSw5LCxvLDQsLDksLDMsLDUsMTcsMywzYixmLCx3LDFqLCwsLDQsOCw0LCwzLDcsYSwyLHQsLDFtLCwsLDIsNCw4LCw5LCxhLDIscSwsMiwyLDFsLCw0LDIsNCwyLDIsMywzLCx1LDIsMywsYiwyLDFsLCw0LDUsLDIsNCwsaywyLG0sNiwsLDFtLCwsMiwsNCw4LCw3LDMsYSwyLHUsLDFuLCwsLGMsLDksLDE0LCwzLCwxbCwzLDUsMywsNCw3LDIsYiwyLHQsLDFtLCwyLCwyLCwzLCw1LDIsNywyLGIsMixzLDIsMWwsMiwsLDIsNCw4LCw5LCxhLDIsdCwsMjAsLDQsLDIsMywsLDgsLDI5LCwyLDcsYyw4LDJxLCwyLDksYiw2LDIyLDIsciwsLCwsLDFqLGUsLDUsLDIsNSxiLCwxMCw5LCwydSw0LCw2LCwyLDIsMixwLDIsNCwzLGcsNCxkLCwyLDIsNiwsZiwsamosMyxxYSwzLHQsMyx0LDIsdSwyLDFzLDIsLDcsOCwsMixiLDksLDE5LDMsM2IsMix5LCwzYSwzLDQsMiw5LCw2LDMsNjMsMiwyLCwxbSwsLDcsLCwsLDIsOCw2LGEsMiwsMWMsaCwxciw0LDFjLDcsLCw1LCwxNCw5LGMsMix3LDQsMiwyLCwzLDFrLCwsMiwzLCwsMywxbSw4LDIsMiw0OCwzLCxkLCw3LDQsLDYsLDMsMiw1aSwxbSwsNSxlaywsNWYseCwyZGEsMywzeCwsMm8sdyxmZSw2LDJ4LDIsbjl3LDQsLGEsdywyLDI4LDIsN2ssLDMsLDQsLHAsMiw1LCw0NywyLHEsaSxkLCwxMiw4LHAsYiwxYSwzLDFjLCwyLDQsMiwyLDEzLCwxdiw2LDIsMiwyLDIsYywsOCwsMWIsLDFmLCwsMywyLDIsNSwyLCwsMTYsMiw4LCw2bSwsMiwsNCwsZm40LCxraCxnLGcsZyxhNiwyLGd0LCw2YSwsNDUsNSwxYWUsMywsMiw1LDQsMTQsMyw0LCw0bCwyLGZ4LDQsYXIsMiw0OSxiLDR3LCwxaSxmLDFrLDMsMWQsNCwyLDIsMXgsMywxMCw1LCw4LDFxLCxjLDIsMWcsOSxhLDQsMiwsMm4sMywyLCwsMiw2LCw0ZywsMyw4LGwsMiwxbCwyLCwsLCxtLCxlLDcsMyw1LDVmLDgsMiwzLCwsbiwsMjksLDIsNiwsLDIsLCwyLCwyLDZqLCwyLDQsNiwyLCwyLHIsMiwyZCw4LDIsLCwyLDJ5LCwsLDIsNiwsLDJ0LDMsMiw0LCw1LDc3LDksLDIsNnQsLGEsMiwsLDQsLDQwLDQsMiwyLDQsLHcsYSwxNCw2LDIsNCw4LCw5LDYsMiwzLDFhLGQsLDIsYmEsNywsNiwsLDJhLG0sMiw3LCwyLCwyLDNlLDYsMywsLDIsLDcsLCwyMCwyLDMsLCwsOW4sMixmMGIsNSwxbiw3LHQ0LCwxciw0LDI5LCxmNWssMiw0M3EsLCwzLDQsNSw4LDgsMiw3LHUsNCw0NCwzLDFpeiwxaiw0LDFlLDgsLGUsLG0sNSwsZiwxMXMsNywsaCwyLDcsLDIsLDUsNzksNyxjNSw0LDE1cyw3LDMxLDcsMjQwLDUsZ3g3aywybywzayw2b1wiLnNwbGl0KFwiLFwiKS5tYXAocyA9PiBzID8gcGFyc2VJbnQocywgMzYpIDogMSk7XG4vLyBDb252ZXJ0IG9mZnNldHMgaW50byBhYnNvbHV0ZSB2YWx1ZXNcbmZvciAobGV0IGkgPSAxOyBpIDwgZXh0ZW5kLmxlbmd0aDsgaSsrKVxuICAgIGV4dGVuZFtpXSArPSBleHRlbmRbaSAtIDFdO1xuZnVuY3Rpb24gaXNFeHRlbmRpbmdDaGFyKGNvZGUpIHtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGV4dGVuZC5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgaWYgKGV4dGVuZFtpXSA+IGNvZGUpXG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5kW2kgLSAxXSA8PSBjb2RlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzUmVnaW9uYWxJbmRpY2F0b3IoY29kZSkge1xuICAgIHJldHVybiBjb2RlID49IDB4MUYxRTYgJiYgY29kZSA8PSAweDFGMUZGO1xufVxuY29uc3QgWldKID0gMHgyMDBkO1xuLyoqXG5SZXR1cm5zIGEgbmV4dCBncmFwaGVtZSBjbHVzdGVyIGJyZWFrIF9hZnRlcl8gKG5vdCBlcXVhbCB0bylcbmBwb3NgLCBpZiBgZm9yd2FyZGAgaXMgdHJ1ZSwgb3IgYmVmb3JlIG90aGVyd2lzZS4gUmV0dXJucyBgcG9zYFxuaXRzZWxmIGlmIG5vIGZ1cnRoZXIgY2x1c3RlciBicmVhayBpcyBhdmFpbGFibGUgaW4gdGhlIHN0cmluZy5cbk1vdmVzIGFjcm9zcyBzdXJyb2dhdGUgcGFpcnMsIGV4dGVuZGluZyBjaGFyYWN0ZXJzICh3aGVuXG5gaW5jbHVkZUV4dGVuZGluZ2AgaXMgdHJ1ZSksIGNoYXJhY3RlcnMgam9pbmVkIHdpdGggemVyby13aWR0aFxuam9pbmVycywgYW5kIGZsYWcgZW1vamkuXG4qL1xuZnVuY3Rpb24gZmluZENsdXN0ZXJCcmVhayhzdHIsIHBvcywgZm9yd2FyZCA9IHRydWUsIGluY2x1ZGVFeHRlbmRpbmcgPSB0cnVlKSB7XG4gICAgcmV0dXJuIChmb3J3YXJkID8gbmV4dENsdXN0ZXJCcmVhayA6IHByZXZDbHVzdGVyQnJlYWspKHN0ciwgcG9zLCBpbmNsdWRlRXh0ZW5kaW5nKTtcbn1cbmZ1bmN0aW9uIG5leHRDbHVzdGVyQnJlYWsoc3RyLCBwb3MsIGluY2x1ZGVFeHRlbmRpbmcpIHtcbiAgICBpZiAocG9zID09IHN0ci5sZW5ndGgpXG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgLy8gSWYgcG9zIGlzIGluIHRoZSBtaWRkbGUgb2YgYSBzdXJyb2dhdGUgcGFpciwgbW92ZSB0byBpdHMgc3RhcnRcbiAgICBpZiAocG9zICYmIHN1cnJvZ2F0ZUxvdyhzdHIuY2hhckNvZGVBdChwb3MpKSAmJiBzdXJyb2dhdGVIaWdoKHN0ci5jaGFyQ29kZUF0KHBvcyAtIDEpKSlcbiAgICAgICAgcG9zLS07XG4gICAgbGV0IHByZXYgPSBjb2RlUG9pbnRBdChzdHIsIHBvcyk7XG4gICAgcG9zICs9IGNvZGVQb2ludFNpemUocHJldik7XG4gICAgd2hpbGUgKHBvcyA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgbGV0IG5leHQgPSBjb2RlUG9pbnRBdChzdHIsIHBvcyk7XG4gICAgICAgIGlmIChwcmV2ID09IFpXSiB8fCBuZXh0ID09IFpXSiB8fCBpbmNsdWRlRXh0ZW5kaW5nICYmIGlzRXh0ZW5kaW5nQ2hhcihuZXh0KSkge1xuICAgICAgICAgICAgcG9zICs9IGNvZGVQb2ludFNpemUobmV4dCk7XG4gICAgICAgICAgICBwcmV2ID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1JlZ2lvbmFsSW5kaWNhdG9yKG5leHQpKSB7XG4gICAgICAgICAgICBsZXQgY291bnRCZWZvcmUgPSAwLCBpID0gcG9zIC0gMjtcbiAgICAgICAgICAgIHdoaWxlIChpID49IDAgJiYgaXNSZWdpb25hbEluZGljYXRvcihjb2RlUG9pbnRBdChzdHIsIGkpKSkge1xuICAgICAgICAgICAgICAgIGNvdW50QmVmb3JlKys7XG4gICAgICAgICAgICAgICAgaSAtPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvdW50QmVmb3JlICUgMiA9PSAwKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBvcztcbn1cbmZ1bmN0aW9uIHByZXZDbHVzdGVyQnJlYWsoc3RyLCBwb3MsIGluY2x1ZGVFeHRlbmRpbmcpIHtcbiAgICB3aGlsZSAocG9zID4gMCkge1xuICAgICAgICBsZXQgZm91bmQgPSBuZXh0Q2x1c3RlckJyZWFrKHN0ciwgcG9zIC0gMiwgaW5jbHVkZUV4dGVuZGluZyk7XG4gICAgICAgIGlmIChmb3VuZCA8IHBvcylcbiAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgcG9zLS07XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gc3Vycm9nYXRlTG93KGNoKSB7IHJldHVybiBjaCA+PSAweERDMDAgJiYgY2ggPCAweEUwMDA7IH1cbmZ1bmN0aW9uIHN1cnJvZ2F0ZUhpZ2goY2gpIHsgcmV0dXJuIGNoID49IDB4RDgwMCAmJiBjaCA8IDB4REMwMDsgfVxuLyoqXG5GaW5kIHRoZSBjb2RlIHBvaW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBpbiBhIHN0cmluZyAobGlrZSB0aGVcbltgY29kZVBvaW50QXRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvY29kZVBvaW50QXQpXG5zdHJpbmcgbWV0aG9kKS5cbiovXG5mdW5jdGlvbiBjb2RlUG9pbnRBdChzdHIsIHBvcykge1xuICAgIGxldCBjb2RlMCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKCFzdXJyb2dhdGVIaWdoKGNvZGUwKSB8fCBwb3MgKyAxID09IHN0ci5sZW5ndGgpXG4gICAgICAgIHJldHVybiBjb2RlMDtcbiAgICBsZXQgY29kZTEgPSBzdHIuY2hhckNvZGVBdChwb3MgKyAxKTtcbiAgICBpZiAoIXN1cnJvZ2F0ZUxvdyhjb2RlMSkpXG4gICAgICAgIHJldHVybiBjb2RlMDtcbiAgICByZXR1cm4gKChjb2RlMCAtIDB4ZDgwMCkgPDwgMTApICsgKGNvZGUxIC0gMHhkYzAwKSArIDB4MTAwMDA7XG59XG4vKipcbkdpdmVuIGEgVW5pY29kZSBjb2RlcG9pbnQsIHJldHVybiB0aGUgSmF2YVNjcmlwdCBzdHJpbmcgdGhhdFxucmVzcHJlc2VudHMgaXQgKGxpa2VcbltgU3RyaW5nLmZyb21Db2RlUG9pbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZnJvbUNvZGVQb2ludCkpLlxuKi9cbmZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoY29kZSkge1xuICAgIGlmIChjb2RlIDw9IDB4ZmZmZilcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgY29kZSAtPSAweDEwMDAwO1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKChjb2RlID4+IDEwKSArIDB4ZDgwMCwgKGNvZGUgJiAxMDIzKSArIDB4ZGMwMCk7XG59XG4vKipcblRoZSBhbW91bnQgb2YgcG9zaXRpb25zIGEgY2hhcmFjdGVyIHRha2VzIHVwIGEgSmF2YVNjcmlwdCBzdHJpbmcuXG4qL1xuZnVuY3Rpb24gY29kZVBvaW50U2l6ZShjb2RlKSB7IHJldHVybiBjb2RlIDwgMHgxMDAwMCA/IDEgOiAyOyB9XG5cbmNvbnN0IERlZmF1bHRTcGxpdCA9IC9cXHJcXG4/fFxcbi87XG4vKipcbkRpc3Rpbmd1aXNoZXMgZGlmZmVyZW50IHdheXMgaW4gd2hpY2ggcG9zaXRpb25zIGNhbiBiZSBtYXBwZWQuXG4qL1xudmFyIE1hcE1vZGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChNYXBNb2RlKSB7XG4gICAgLyoqXG4gICAgTWFwIGEgcG9zaXRpb24gdG8gYSB2YWxpZCBuZXcgcG9zaXRpb24sIGV2ZW4gd2hlbiBpdHMgY29udGV4dFxuICAgIHdhcyBkZWxldGVkLlxuICAgICovXG4gICAgTWFwTW9kZVtNYXBNb2RlW1wiU2ltcGxlXCJdID0gMF0gPSBcIlNpbXBsZVwiO1xuICAgIC8qKlxuICAgIFJldHVybiBudWxsIGlmIGRlbGV0aW9uIGhhcHBlbnMgYWNyb3NzIHRoZSBwb3NpdGlvbi5cbiAgICAqL1xuICAgIE1hcE1vZGVbTWFwTW9kZVtcIlRyYWNrRGVsXCJdID0gMV0gPSBcIlRyYWNrRGVsXCI7XG4gICAgLyoqXG4gICAgUmV0dXJuIG51bGwgaWYgdGhlIGNoYXJhY3RlciBfYmVmb3JlXyB0aGUgcG9zaXRpb24gaXMgZGVsZXRlZC5cbiAgICAqL1xuICAgIE1hcE1vZGVbTWFwTW9kZVtcIlRyYWNrQmVmb3JlXCJdID0gMl0gPSBcIlRyYWNrQmVmb3JlXCI7XG4gICAgLyoqXG4gICAgUmV0dXJuIG51bGwgaWYgdGhlIGNoYXJhY3RlciBfYWZ0ZXJfIHRoZSBwb3NpdGlvbiBpcyBkZWxldGVkLlxuICAgICovXG4gICAgTWFwTW9kZVtNYXBNb2RlW1wiVHJhY2tBZnRlclwiXSA9IDNdID0gXCJUcmFja0FmdGVyXCI7XG5yZXR1cm4gTWFwTW9kZX0pKE1hcE1vZGUgfHwgKE1hcE1vZGUgPSB7fSkpO1xuLyoqXG5BIGNoYW5nZSBkZXNjcmlwdGlvbiBpcyBhIHZhcmlhbnQgb2YgW2NoYW5nZSBzZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlU2V0KVxudGhhdCBkb2Vzbid0IHN0b3JlIHRoZSBpbnNlcnRlZCB0ZXh0LiBBcyBzdWNoLCBpdCBjYW4ndCBiZVxuYXBwbGllZCwgYnV0IGlzIGNoZWFwZXIgdG8gc3RvcmUgYW5kIG1hbmlwdWxhdGUuXG4qL1xuY2xhc3MgQ2hhbmdlRGVzYyB7XG4gICAgLy8gU2VjdGlvbnMgYXJlIGVuY29kZWQgYXMgcGFpcnMgb2YgaW50ZWdlcnMuIFRoZSBmaXJzdCBpcyB0aGVcbiAgICAvLyBsZW5ndGggaW4gdGhlIGN1cnJlbnQgZG9jdW1lbnQsIGFuZCB0aGUgc2Vjb25kIGlzIC0xIGZvclxuICAgIC8vIHVuYWZmZWN0ZWQgc2VjdGlvbnMsIGFuZCB0aGUgbGVuZ3RoIG9mIHRoZSByZXBsYWNlbWVudCBjb250ZW50XG4gICAgLy8gb3RoZXJ3aXNlLiBTbyBhbiBpbnNlcnRpb24gd291bGQgYmUgKDAsIG4+MCksIGEgZGVsZXRpb24gKG4+MCxcbiAgICAvLyAwKSwgYW5kIGEgcmVwbGFjZW1lbnQgdHdvIHBvc2l0aXZlIG51bWJlcnMuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNlY3Rpb25zKSB7XG4gICAgICAgIHRoaXMuc2VjdGlvbnMgPSBzZWN0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGxlbmd0aCBvZiB0aGUgZG9jdW1lbnQgYmVmb3JlIHRoZSBjaGFuZ2UuXG4gICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuc2VjdGlvbnNbaV07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBsZW5ndGggb2YgdGhlIGRvY3VtZW50IGFmdGVyIHRoZSBjaGFuZ2UuXG4gICAgKi9cbiAgICBnZXQgbmV3TGVuZ3RoKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgaW5zID0gdGhpcy5zZWN0aW9uc1tpICsgMV07XG4gICAgICAgICAgICByZXN1bHQgKz0gaW5zIDwgMCA/IHRoaXMuc2VjdGlvbnNbaV0gOiBpbnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgRmFsc2Ugd2hlbiB0aGVyZSBhcmUgYWN0dWFsIGNoYW5nZXMgaW4gdGhpcyBzZXQuXG4gICAgKi9cbiAgICBnZXQgZW1wdHkoKSB7IHJldHVybiB0aGlzLnNlY3Rpb25zLmxlbmd0aCA9PSAwIHx8IHRoaXMuc2VjdGlvbnMubGVuZ3RoID09IDIgJiYgdGhpcy5zZWN0aW9uc1sxXSA8IDA7IH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHVuY2hhbmdlZCBwYXJ0cyBsZWZ0IGJ5IHRoZXNlIGNoYW5nZXMuIGBwb3NBYFxuICAgIHByb3ZpZGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgcmFuZ2UgaW4gdGhlIG9sZCBkb2N1bWVudCwgYHBvc0JgXG4gICAgdGhlIG5ldyBwb3NpdGlvbiBpbiB0aGUgY2hhbmdlZCBkb2N1bWVudC5cbiAgICAqL1xuICAgIGl0ZXJHYXBzKGYpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvc0EgPSAwLCBwb3NCID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgaWYgKGlucyA8IDApIHtcbiAgICAgICAgICAgICAgICBmKHBvc0EsIHBvc0IsIGxlbik7XG4gICAgICAgICAgICAgICAgcG9zQiArPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb3NCICs9IGlucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc0EgKz0gbGVuO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgcmFuZ2VzIGNoYW5nZWQgYnkgdGhlc2UgY2hhbmdlcy4gKFNlZVxuICAgIFtgQ2hhbmdlU2V0Lml0ZXJDaGFuZ2VzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VTZXQuaXRlckNoYW5nZXMpIGZvciBhXG4gICAgdmFyaWFudCB0aGF0IGFsc28gcHJvdmlkZXMgeW91IHdpdGggdGhlIGluc2VydGVkIHRleHQuKVxuICAgIGBmcm9tQWAvYHRvQWAgcHJvdmlkZXMgdGhlIGV4dGVudCBvZiB0aGUgY2hhbmdlIGluIHRoZSBzdGFydGluZ1xuICAgIGRvY3VtZW50LCBgZnJvbUJgL2B0b0JgIHRoZSBleHRlbnQgb2YgdGhlIHJlcGxhY2VtZW50IGluIHRoZVxuICAgIGNoYW5nZWQgZG9jdW1lbnQuXG4gICAgXG4gICAgV2hlbiBgaW5kaXZpZHVhbGAgaXMgdHJ1ZSwgYWRqYWNlbnQgY2hhbmdlcyAod2hpY2ggYXJlIGtlcHRcbiAgICBzZXBhcmF0ZSBmb3IgW3Bvc2l0aW9uIG1hcHBpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlRGVzYy5tYXBQb3MpKSBhcmVcbiAgICByZXBvcnRlZCBzZXBhcmF0ZWx5LlxuICAgICovXG4gICAgaXRlckNoYW5nZWRSYW5nZXMoZiwgaW5kaXZpZHVhbCA9IGZhbHNlKSB7XG4gICAgICAgIGl0ZXJDaGFuZ2VzKHRoaXMsIGYsIGluZGl2aWR1YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBkZXNjcmlwdGlvbiBvZiB0aGUgaW52ZXJ0ZWQgZm9ybSBvZiB0aGVzZSBjaGFuZ2VzLlxuICAgICovXG4gICAgZ2V0IGludmVydGVkRGVzYygpIHtcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK107XG4gICAgICAgICAgICBpZiAoaW5zIDwgMClcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKGxlbiwgaW5zKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKGlucywgbGVuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENoYW5nZURlc2Moc2VjdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wdXRlIHRoZSBjb21iaW5lZCBlZmZlY3Qgb2YgYXBwbHlpbmcgYW5vdGhlciBzZXQgb2YgY2hhbmdlc1xuICAgIGFmdGVyIHRoaXMgb25lLiBUaGUgbGVuZ3RoIG9mIHRoZSBkb2N1bWVudCBhZnRlciB0aGlzIHNldCBzaG91bGRcbiAgICBtYXRjaCB0aGUgbGVuZ3RoIGJlZm9yZSBgb3RoZXJgLlxuICAgICovXG4gICAgY29tcG9zZURlc2Mob3RoZXIpIHsgcmV0dXJuIHRoaXMuZW1wdHkgPyBvdGhlciA6IG90aGVyLmVtcHR5ID8gdGhpcyA6IGNvbXBvc2VTZXRzKHRoaXMsIG90aGVyKTsgfVxuICAgIC8qKlxuICAgIE1hcCB0aGlzIGRlc2NyaXB0aW9uLCB3aGljaCBzaG91bGQgc3RhcnQgd2l0aCB0aGUgc2FtZSBkb2N1bWVudFxuICAgIGFzIGBvdGhlcmAsIG92ZXIgYW5vdGhlciBzZXQgb2YgY2hhbmdlcywgc28gdGhhdCBpdCBjYW4gYmVcbiAgICBhcHBsaWVkIGFmdGVyIGl0LiBXaGVuIGBiZWZvcmVgIGlzIHRydWUsIG1hcCBhcyBpZiB0aGUgY2hhbmdlc1xuICAgIGluIGBvdGhlcmAgaGFwcGVuZWQgYmVmb3JlIHRoZSBvbmVzIGluIGB0aGlzYC5cbiAgICAqL1xuICAgIG1hcERlc2Mob3RoZXIsIGJlZm9yZSA9IGZhbHNlKSB7IHJldHVybiBvdGhlci5lbXB0eSA/IHRoaXMgOiBtYXBTZXQodGhpcywgb3RoZXIsIGJlZm9yZSk7IH1cbiAgICBtYXBQb3MocG9zLCBhc3NvYyA9IC0xLCBtb2RlID0gTWFwTW9kZS5TaW1wbGUpIHtcbiAgICAgICAgbGV0IHBvc0EgPSAwLCBwb3NCID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2krK10sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgZW5kQSA9IHBvc0EgKyBsZW47XG4gICAgICAgICAgICBpZiAoaW5zIDwgMCkge1xuICAgICAgICAgICAgICAgIGlmIChlbmRBID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zQiArIChwb3MgLSBwb3NBKTtcbiAgICAgICAgICAgICAgICBwb3NCICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChtb2RlICE9IE1hcE1vZGUuU2ltcGxlICYmIGVuZEEgPj0gcG9zICYmXG4gICAgICAgICAgICAgICAgICAgIChtb2RlID09IE1hcE1vZGUuVHJhY2tEZWwgJiYgcG9zQSA8IHBvcyAmJiBlbmRBID4gcG9zIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID09IE1hcE1vZGUuVHJhY2tCZWZvcmUgJiYgcG9zQSA8IHBvcyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9PSBNYXBNb2RlLlRyYWNrQWZ0ZXIgJiYgZW5kQSA+IHBvcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChlbmRBID4gcG9zIHx8IGVuZEEgPT0gcG9zICYmIGFzc29jIDwgMCAmJiAhbGVuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zID09IHBvc0EgfHwgYXNzb2MgPCAwID8gcG9zQiA6IHBvc0IgKyBpbnM7XG4gICAgICAgICAgICAgICAgcG9zQiArPSBpbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3NBID0gZW5kQTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zID4gcG9zQSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBQb3NpdGlvbiAke3Bvc30gaXMgb3V0IG9mIHJhbmdlIGZvciBjaGFuZ2VzZXQgb2YgbGVuZ3RoICR7cG9zQX1gKTtcbiAgICAgICAgcmV0dXJuIHBvc0I7XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIHdoZXRoZXIgdGhlc2UgY2hhbmdlcyB0b3VjaCBhIGdpdmVuIHJhbmdlLiBXaGVuIG9uZSBvZiB0aGVcbiAgICBjaGFuZ2VzIGVudGlyZWx5IGNvdmVycyB0aGUgcmFuZ2UsIHRoZSBzdHJpbmcgYFwiY292ZXJcImAgaXNcbiAgICByZXR1cm5lZC5cbiAgICAqL1xuICAgIHRvdWNoZXNSYW5nZShmcm9tLCB0byA9IGZyb20pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aCAmJiBwb3MgPD0gdG87KSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK10sIGVuZCA9IHBvcyArIGxlbjtcbiAgICAgICAgICAgIGlmIChpbnMgPj0gMCAmJiBwb3MgPD0gdG8gJiYgZW5kID49IGZyb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcyA8IGZyb20gJiYgZW5kID4gdG8gPyBcImNvdmVyXCIgOiB0cnVlO1xuICAgICAgICAgICAgcG9zID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK107XG4gICAgICAgICAgICByZXN1bHQgKz0gKHJlc3VsdCA/IFwiIFwiIDogXCJcIikgKyBsZW4gKyAoaW5zID49IDAgPyBcIjpcIiArIGlucyA6IFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFNlcmlhbGl6ZSB0aGlzIGNoYW5nZSBkZXNjIHRvIGEgSlNPTi1yZXByZXNlbnRhYmxlIHZhbHVlLlxuICAgICovXG4gICAgdG9KU09OKCkgeyByZXR1cm4gdGhpcy5zZWN0aW9uczsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNoYW5nZSBkZXNjIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24gKGFzIHByb2R1Y2VkXG4gICAgYnkgW2B0b0pTT05gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZURlc2MudG9KU09OKS5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShqc29uKSB8fCBqc29uLmxlbmd0aCAlIDIgfHwganNvbi5zb21lKGEgPT4gdHlwZW9mIGEgIT0gXCJudW1iZXJcIikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBDaGFuZ2VEZXNjXCIpO1xuICAgICAgICByZXR1cm4gbmV3IENoYW5nZURlc2MoanNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShzZWN0aW9ucykgeyByZXR1cm4gbmV3IENoYW5nZURlc2Moc2VjdGlvbnMpOyB9XG59XG4vKipcbkEgY2hhbmdlIHNldCByZXByZXNlbnRzIGEgZ3JvdXAgb2YgbW9kaWZpY2F0aW9ucyB0byBhIGRvY3VtZW50LiBJdFxuc3RvcmVzIHRoZSBkb2N1bWVudCBsZW5ndGgsIGFuZCBjYW4gb25seSBiZSBhcHBsaWVkIHRvIGRvY3VtZW50c1xud2l0aCBleGFjdGx5IHRoYXQgbGVuZ3RoLlxuKi9cbmNsYXNzIENoYW5nZVNldCBleHRlbmRzIENoYW5nZURlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHNlY3Rpb25zLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGluc2VydGVkKSB7XG4gICAgICAgIHN1cGVyKHNlY3Rpb25zKTtcbiAgICAgICAgdGhpcy5pbnNlcnRlZCA9IGluc2VydGVkO1xuICAgIH1cbiAgICAvKipcbiAgICBBcHBseSB0aGUgY2hhbmdlcyB0byBhIGRvY3VtZW50LCByZXR1cm5pbmcgdGhlIG1vZGlmaWVkXG4gICAgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoICE9IGRvYy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkFwcGx5aW5nIGNoYW5nZSBzZXQgdG8gYSBkb2N1bWVudCB3aXRoIHRoZSB3cm9uZyBsZW5ndGhcIik7XG4gICAgICAgIGl0ZXJDaGFuZ2VzKHRoaXMsIChmcm9tQSwgdG9BLCBmcm9tQiwgX3RvQiwgdGV4dCkgPT4gZG9jID0gZG9jLnJlcGxhY2UoZnJvbUIsIGZyb21CICsgKHRvQSAtIGZyb21BKSwgdGV4dCksIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGRvYztcbiAgICB9XG4gICAgbWFwRGVzYyhvdGhlciwgYmVmb3JlID0gZmFsc2UpIHsgcmV0dXJuIG1hcFNldCh0aGlzLCBvdGhlciwgYmVmb3JlLCB0cnVlKTsgfVxuICAgIC8qKlxuICAgIEdpdmVuIHRoZSBkb2N1bWVudCBhcyBpdCBleGlzdGVkIF9iZWZvcmVfIHRoZSBjaGFuZ2VzLCByZXR1cm4gYVxuICAgIGNoYW5nZSBzZXQgdGhhdCByZXByZXNlbnRzIHRoZSBpbnZlcnNlIG9mIHRoaXMgc2V0LCB3aGljaCBjb3VsZFxuICAgIGJlIHVzZWQgdG8gZ28gZnJvbSB0aGUgZG9jdW1lbnQgY3JlYXRlZCBieSB0aGUgY2hhbmdlcyBiYWNrIHRvXG4gICAgdGhlIGRvY3VtZW50IGFzIGl0IGV4aXN0ZWQgYmVmb3JlIHRoZSBjaGFuZ2VzLlxuICAgICovXG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSB0aGlzLnNlY3Rpb25zLnNsaWNlKCksIGluc2VydGVkID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgc2VjdGlvbnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSBzZWN0aW9uc1tpXSwgaW5zID0gc2VjdGlvbnNbaSArIDFdO1xuICAgICAgICAgICAgaWYgKGlucyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnNbaV0gPSBpbnM7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnNbaSArIDFdID0gbGVuO1xuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IGkgPj4gMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5zZXJ0ZWQubGVuZ3RoIDwgaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIGluc2VydGVkLnB1c2goVGV4dC5lbXB0eSk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWQucHVzaChsZW4gPyBkb2Muc2xpY2UocG9zLCBwb3MgKyBsZW4pIDogVGV4dC5lbXB0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgKz0gbGVuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlU2V0KHNlY3Rpb25zLCBpbnNlcnRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbWJpbmUgdHdvIHN1YnNlcXVlbnQgY2hhbmdlIHNldHMgaW50byBhIHNpbmdsZSBzZXQuIGBvdGhlcmBcbiAgICBtdXN0IHN0YXJ0IGluIHRoZSBkb2N1bWVudCBwcm9kdWNlZCBieSBgdGhpc2AuIElmIGB0aGlzYCBnb2VzXG4gICAgYGRvY0FgIOKGkiBgZG9jQmAgYW5kIGBvdGhlcmAgcmVwcmVzZW50cyBgZG9jQmAg4oaSIGBkb2NDYCwgdGhlXG4gICAgcmV0dXJuZWQgdmFsdWUgd2lsbCByZXByZXNlbnQgdGhlIGNoYW5nZSBgZG9jQWAg4oaSIGBkb2NDYC5cbiAgICAqL1xuICAgIGNvbXBvc2Uob3RoZXIpIHsgcmV0dXJuIHRoaXMuZW1wdHkgPyBvdGhlciA6IG90aGVyLmVtcHR5ID8gdGhpcyA6IGNvbXBvc2VTZXRzKHRoaXMsIG90aGVyLCB0cnVlKTsgfVxuICAgIC8qKlxuICAgIEdpdmVuIGFub3RoZXIgY2hhbmdlIHNldCBzdGFydGluZyBpbiB0aGUgc2FtZSBkb2N1bWVudCwgbWFwcyB0aGlzXG4gICAgY2hhbmdlIHNldCBvdmVyIHRoZSBvdGhlciwgcHJvZHVjaW5nIGEgbmV3IGNoYW5nZSBzZXQgdGhhdCBjYW4gYmVcbiAgICBhcHBsaWVkIHRvIHRoZSBkb2N1bWVudCBwcm9kdWNlZCBieSBhcHBseWluZyBgb3RoZXJgLiBXaGVuXG4gICAgYGJlZm9yZWAgaXMgYHRydWVgLCBvcmRlciBjaGFuZ2VzIGFzIGlmIGB0aGlzYCBjb21lcyBiZWZvcmVcbiAgICBgb3RoZXJgLCBvdGhlcndpc2UgKHRoZSBkZWZhdWx0KSB0cmVhdCBgb3RoZXJgIGFzIGNvbWluZyBmaXJzdC5cbiAgICBcbiAgICBHaXZlbiB0d28gY2hhbmdlcyBgQWAgYW5kIGBCYCwgYEEuY29tcG9zZShCLm1hcChBKSlgIGFuZFxuICAgIGBCLmNvbXBvc2UoQS5tYXAoQiwgdHJ1ZSkpYCB3aWxsIHByb2R1Y2UgdGhlIHNhbWUgZG9jdW1lbnQuIFRoaXNcbiAgICBwcm92aWRlcyBhIGJhc2ljIGZvcm0gb2YgW29wZXJhdGlvbmFsXG4gICAgdHJhbnNmb3JtYXRpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL09wZXJhdGlvbmFsX3RyYW5zZm9ybWF0aW9uKSxcbiAgICBhbmQgY2FuIGJlIHVzZWQgZm9yIGNvbGxhYm9yYXRpdmUgZWRpdGluZy5cbiAgICAqL1xuICAgIG1hcChvdGhlciwgYmVmb3JlID0gZmFsc2UpIHsgcmV0dXJuIG90aGVyLmVtcHR5ID8gdGhpcyA6IG1hcFNldCh0aGlzLCBvdGhlciwgYmVmb3JlLCB0cnVlKTsgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgY2hhbmdlZCByYW5nZXMgaW4gdGhlIGRvY3VtZW50LCBjYWxsaW5nIGBmYCBmb3JcbiAgICBlYWNoLCB3aXRoIHRoZSByYW5nZSBpbiB0aGUgb3JpZ2luYWwgZG9jdW1lbnQgKGBmcm9tQWAtYHRvQWApXG4gICAgYW5kIHRoZSByYW5nZSB0aGF0IHJlcGxhY2VzIGl0IGluIHRoZSBuZXcgZG9jdW1lbnRcbiAgICAoYGZyb21CYC1gdG9CYCkuXG4gICAgXG4gICAgV2hlbiBgaW5kaXZpZHVhbGAgaXMgdHJ1ZSwgYWRqYWNlbnQgY2hhbmdlcyBhcmUgcmVwb3J0ZWRcbiAgICBzZXBhcmF0ZWx5LlxuICAgICovXG4gICAgaXRlckNoYW5nZXMoZiwgaW5kaXZpZHVhbCA9IGZhbHNlKSB7XG4gICAgICAgIGl0ZXJDaGFuZ2VzKHRoaXMsIGYsIGluZGl2aWR1YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbY2hhbmdlIGRlc2NyaXB0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZURlc2MpIGZvciB0aGlzIGNoYW5nZVxuICAgIHNldC5cbiAgICAqL1xuICAgIGdldCBkZXNjKCkgeyByZXR1cm4gQ2hhbmdlRGVzYy5jcmVhdGUodGhpcy5zZWN0aW9ucyk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZpbHRlcihyYW5nZXMpIHtcbiAgICAgICAgbGV0IHJlc3VsdFNlY3Rpb25zID0gW10sIHJlc3VsdEluc2VydGVkID0gW10sIGZpbHRlcmVkU2VjdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IGl0ZXIgPSBuZXcgU2VjdGlvbkl0ZXIodGhpcyk7XG4gICAgICAgIGRvbmU6IGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaSA9PSByYW5nZXMubGVuZ3RoID8gMWU5IDogcmFuZ2VzW2krK107XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgbmV4dCB8fCBwb3MgPT0gbmV4dCAmJiBpdGVyLmxlbiA9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZXIuZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgZG9uZTtcbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gTWF0aC5taW4oaXRlci5sZW4sIG5leHQgLSBwb3MpO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oZmlsdGVyZWRTZWN0aW9ucywgbGVuLCAtMSk7XG4gICAgICAgICAgICAgICAgbGV0IGlucyA9IGl0ZXIuaW5zID09IC0xID8gLTEgOiBpdGVyLm9mZiA9PSAwID8gaXRlci5pbnMgOiAwO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24ocmVzdWx0U2VjdGlvbnMsIGxlbiwgaW5zKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zID4gMClcbiAgICAgICAgICAgICAgICAgICAgYWRkSW5zZXJ0KHJlc3VsdEluc2VydGVkLCByZXN1bHRTZWN0aW9ucywgaXRlci50ZXh0KTtcbiAgICAgICAgICAgICAgICBpdGVyLmZvcndhcmQobGVuKTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGVuZCA9IHJhbmdlc1tpKytdO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVyLmRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGRvbmU7XG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IE1hdGgubWluKGl0ZXIubGVuLCBlbmQgLSBwb3MpO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24ocmVzdWx0U2VjdGlvbnMsIGxlbiwgLTEpO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oZmlsdGVyZWRTZWN0aW9ucywgbGVuLCBpdGVyLmlucyA9PSAtMSA/IC0xIDogaXRlci5vZmYgPT0gMCA/IGl0ZXIuaW5zIDogMCk7XG4gICAgICAgICAgICAgICAgaXRlci5mb3J3YXJkKGxlbik7XG4gICAgICAgICAgICAgICAgcG9zICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBuZXcgQ2hhbmdlU2V0KHJlc3VsdFNlY3Rpb25zLCByZXN1bHRJbnNlcnRlZCksXG4gICAgICAgICAgICBmaWx0ZXJlZDogQ2hhbmdlRGVzYy5jcmVhdGUoZmlsdGVyZWRTZWN0aW9ucykgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgU2VyaWFsaXplIHRoaXMgY2hhbmdlIHNldCB0byBhIEpTT04tcmVwcmVzZW50YWJsZSB2YWx1ZS5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IHBhcnRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaV0sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSArIDFdO1xuICAgICAgICAgICAgaWYgKGlucyA8IDApXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChsZW4pO1xuICAgICAgICAgICAgZWxzZSBpZiAoaW5zID09IDApXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChbbGVuXSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChbbGVuXS5jb25jYXQodGhpcy5pbnNlcnRlZFtpID4+IDFdLnRvSlNPTigpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjaGFuZ2Ugc2V0IGZvciB0aGUgZ2l2ZW4gY2hhbmdlcywgZm9yIGEgZG9jdW1lbnQgb2YgdGhlXG4gICAgZ2l2ZW4gbGVuZ3RoLCB1c2luZyBgbGluZVNlcGAgYXMgbGluZSBzZXBhcmF0b3IuXG4gICAgKi9cbiAgICBzdGF0aWMgb2YoY2hhbmdlcywgbGVuZ3RoLCBsaW5lU2VwKSB7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdLCBpbnNlcnRlZCA9IFtdLCBwb3MgPSAwO1xuICAgICAgICBsZXQgdG90YWwgPSBudWxsO1xuICAgICAgICBmdW5jdGlvbiBmbHVzaChmb3JjZSA9IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAoIWZvcmNlICYmICFzZWN0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHBvcyA8IGxlbmd0aClcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBsZW5ndGggLSBwb3MsIC0xKTtcbiAgICAgICAgICAgIGxldCBzZXQgPSBuZXcgQ2hhbmdlU2V0KHNlY3Rpb25zLCBpbnNlcnRlZCk7XG4gICAgICAgICAgICB0b3RhbCA9IHRvdGFsID8gdG90YWwuY29tcG9zZShzZXQubWFwKHRvdGFsKSkgOiBzZXQ7XG4gICAgICAgICAgICBzZWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgaW5zZXJ0ZWQgPSBbXTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcHJvY2VzcyhzcGVjKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzcGVjKSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHN1YiBvZiBzcGVjKVxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKHN1Yik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzcGVjIGluc3RhbmNlb2YgQ2hhbmdlU2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwZWMubGVuZ3RoICE9IGxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYE1pc21hdGNoZWQgY2hhbmdlIHNldCBsZW5ndGggKGdvdCAke3NwZWMubGVuZ3RofSwgZXhwZWN0ZWQgJHtsZW5ndGh9KWApO1xuICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgdG90YWwgPSB0b3RhbCA/IHRvdGFsLmNvbXBvc2Uoc3BlYy5tYXAodG90YWwpKSA6IHNwZWM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBmcm9tLCB0byA9IGZyb20sIGluc2VydCB9ID0gc3BlYztcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+IHRvIHx8IGZyb20gPCAwIHx8IHRvID4gbGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBjaGFuZ2UgcmFuZ2UgJHtmcm9tfSB0byAke3RvfSAoaW4gZG9jIG9mIGxlbmd0aCAke2xlbmd0aH0pYCk7XG4gICAgICAgICAgICAgICAgbGV0IGluc1RleHQgPSAhaW5zZXJ0ID8gVGV4dC5lbXB0eSA6IHR5cGVvZiBpbnNlcnQgPT0gXCJzdHJpbmdcIiA/IFRleHQub2YoaW5zZXJ0LnNwbGl0KGxpbmVTZXAgfHwgRGVmYXVsdFNwbGl0KSkgOiBpbnNlcnQ7XG4gICAgICAgICAgICAgICAgbGV0IGluc0xlbiA9IGluc1RleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID09IHRvICYmIGluc0xlbiA9PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPCBwb3MpXG4gICAgICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGZyb20gLSBwb3MsIC0xKTtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCB0byAtIGZyb20sIGluc0xlbik7XG4gICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydGVkLCBzZWN0aW9ucywgaW5zVGV4dCk7XG4gICAgICAgICAgICAgICAgcG9zID0gdG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2VzcyhjaGFuZ2VzKTtcbiAgICAgICAgZmx1c2goIXRvdGFsKTtcbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZW1wdHkgY2hhbmdlc2V0IG9mIHRoZSBnaXZlbiBsZW5ndGguXG4gICAgKi9cbiAgICBzdGF0aWMgZW1wdHkobGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlU2V0KGxlbmd0aCA/IFtsZW5ndGgsIC0xXSA6IFtdLCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNoYW5nZXNldCBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uIChhcyBwcm9kdWNlZCBieVxuICAgIFtgdG9KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VTZXQudG9KU09OKS5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShqc29uKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIG9mIENoYW5nZVNldFwiKTtcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gW10sIGluc2VydGVkID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwganNvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHBhcnQgPSBqc29uW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0ID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHBhcnQsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHBhcnQpIHx8IHR5cGVvZiBwYXJ0WzBdICE9IFwibnVtYmVyXCIgfHwgcGFydC5zb21lKChlLCBpKSA9PiBpICYmIHR5cGVvZiBlICE9IFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gb2YgQ2hhbmdlU2V0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFydC5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2gocGFydFswXSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5zZXJ0ZWQubGVuZ3RoIDwgaSlcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWQucHVzaChUZXh0LmVtcHR5KTtcbiAgICAgICAgICAgICAgICBpbnNlcnRlZFtpXSA9IFRleHQub2YocGFydC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChwYXJ0WzBdLCBpbnNlcnRlZFtpXS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlU2V0KHNlY3Rpb25zLCBpbnNlcnRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VTZXQoc2VjdGlvbnMsIGluc2VydGVkKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRTZWN0aW9uKHNlY3Rpb25zLCBsZW4sIGlucywgZm9yY2VKb2luID0gZmFsc2UpIHtcbiAgICBpZiAobGVuID09IDAgJiYgaW5zIDw9IDApXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgbGFzdCA9IHNlY3Rpb25zLmxlbmd0aCAtIDI7XG4gICAgaWYgKGxhc3QgPj0gMCAmJiBpbnMgPD0gMCAmJiBpbnMgPT0gc2VjdGlvbnNbbGFzdCArIDFdKVxuICAgICAgICBzZWN0aW9uc1tsYXN0XSArPSBsZW47XG4gICAgZWxzZSBpZiAobGVuID09IDAgJiYgc2VjdGlvbnNbbGFzdF0gPT0gMClcbiAgICAgICAgc2VjdGlvbnNbbGFzdCArIDFdICs9IGlucztcbiAgICBlbHNlIGlmIChmb3JjZUpvaW4pIHtcbiAgICAgICAgc2VjdGlvbnNbbGFzdF0gKz0gbGVuO1xuICAgICAgICBzZWN0aW9uc1tsYXN0ICsgMV0gKz0gaW5zO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIHNlY3Rpb25zLnB1c2gobGVuLCBpbnMpO1xufVxuZnVuY3Rpb24gYWRkSW5zZXJ0KHZhbHVlcywgc2VjdGlvbnMsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGluZGV4ID0gKHNlY3Rpb25zLmxlbmd0aCAtIDIpID4+IDE7XG4gICAgaWYgKGluZGV4IDwgdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXS5hcHBlbmQodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd2hpbGUgKHZhbHVlcy5sZW5ndGggPCBpbmRleClcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKFRleHQuZW1wdHkpO1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXRlckNoYW5nZXMoZGVzYywgZiwgaW5kaXZpZHVhbCkge1xuICAgIGxldCBpbnNlcnRlZCA9IGRlc2MuaW5zZXJ0ZWQ7XG4gICAgZm9yIChsZXQgcG9zQSA9IDAsIHBvc0IgPSAwLCBpID0gMDsgaSA8IGRlc2Muc2VjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICBsZXQgbGVuID0gZGVzYy5zZWN0aW9uc1tpKytdLCBpbnMgPSBkZXNjLnNlY3Rpb25zW2krK107XG4gICAgICAgIGlmIChpbnMgPCAwKSB7XG4gICAgICAgICAgICBwb3NBICs9IGxlbjtcbiAgICAgICAgICAgIHBvc0IgKz0gbGVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGVuZEEgPSBwb3NBLCBlbmRCID0gcG9zQiwgdGV4dCA9IFRleHQuZW1wdHk7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgZW5kQSArPSBsZW47XG4gICAgICAgICAgICAgICAgZW5kQiArPSBpbnM7XG4gICAgICAgICAgICAgICAgaWYgKGlucyAmJiBpbnNlcnRlZClcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuYXBwZW5kKGluc2VydGVkWyhpIC0gMikgPj4gMV0pO1xuICAgICAgICAgICAgICAgIGlmIChpbmRpdmlkdWFsIHx8IGkgPT0gZGVzYy5zZWN0aW9ucy5sZW5ndGggfHwgZGVzYy5zZWN0aW9uc1tpICsgMV0gPCAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBsZW4gPSBkZXNjLnNlY3Rpb25zW2krK107XG4gICAgICAgICAgICAgICAgaW5zID0gZGVzYy5zZWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZihwb3NBLCBlbmRBLCBwb3NCLCBlbmRCLCB0ZXh0KTtcbiAgICAgICAgICAgIHBvc0EgPSBlbmRBO1xuICAgICAgICAgICAgcG9zQiA9IGVuZEI7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBtYXBTZXQoc2V0QSwgc2V0QiwgYmVmb3JlLCBta1NldCA9IGZhbHNlKSB7XG4gICAgLy8gUHJvZHVjZSBhIGNvcHkgb2Ygc2V0QSB0aGF0IGFwcGxpZXMgdG8gdGhlIGRvY3VtZW50IGFmdGVyIHNldEJcbiAgICAvLyBoYXMgYmVlbiBhcHBsaWVkIChhc3N1bWluZyBib3RoIHN0YXJ0IGF0IHRoZSBzYW1lIGRvY3VtZW50KS5cbiAgICBsZXQgc2VjdGlvbnMgPSBbXSwgaW5zZXJ0ID0gbWtTZXQgPyBbXSA6IG51bGw7XG4gICAgbGV0IGEgPSBuZXcgU2VjdGlvbkl0ZXIoc2V0QSksIGIgPSBuZXcgU2VjdGlvbkl0ZXIoc2V0Qik7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGJvdGggc2V0cyBpbiBwYXJhbGxlbC4gaW5zZXJ0ZWQgdHJhY2tzLCBmb3IgY2hhbmdlc1xuICAgIC8vIGluIEEgdGhhdCBoYXZlIHRvIGJlIHByb2Nlc3NlZCBwaWVjZS1ieS1waWVjZSwgd2hldGhlciB0aGVpclxuICAgIC8vIGNvbnRlbnQgaGFzIGJlZW4gaW5zZXJ0ZWQgYWxyZWFkeSwgYW5kIHJlZmVycyB0byB0aGUgc2VjdGlvblxuICAgIC8vIGluZGV4LlxuICAgIGZvciAobGV0IGluc2VydGVkID0gLTE7Oykge1xuICAgICAgICBpZiAoYS5pbnMgPT0gLTEgJiYgYi5pbnMgPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIE1vdmUgYWNyb3NzIHJhbmdlcyBza2lwcGVkIGJ5IGJvdGggc2V0cy5cbiAgICAgICAgICAgIGxldCBsZW4gPSBNYXRoLm1pbihhLmxlbiwgYi5sZW4pO1xuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuLCAtMSk7XG4gICAgICAgICAgICBhLmZvcndhcmQobGVuKTtcbiAgICAgICAgICAgIGIuZm9yd2FyZChsZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIuaW5zID49IDAgJiYgKGEuaW5zIDwgMCB8fCBpbnNlcnRlZCA9PSBhLmkgfHwgYS5vZmYgPT0gMCAmJiAoYi5sZW4gPCBhLmxlbiB8fCBiLmxlbiA9PSBhLmxlbiAmJiAhYmVmb3JlKSkpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSBjaGFuZ2UgaW4gQiB0aGF0IGNvbWVzIGJlZm9yZSB0aGUgbmV4dCBjaGFuZ2UgaW5cbiAgICAgICAgICAgIC8vIEEgKG9yZGVyZWQgYnkgc3RhcnQgcG9zLCB0aGVuIGxlbiwgdGhlbiBiZWZvcmUgZmxhZyksIHNraXBcbiAgICAgICAgICAgIC8vIHRoYXQgKGFuZCBwcm9jZXNzIGFueSBjaGFuZ2VzIGluIEEgaXQgY292ZXJzKS5cbiAgICAgICAgICAgIGxldCBsZW4gPSBiLmxlbjtcbiAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGIuaW5zLCAtMSk7XG4gICAgICAgICAgICB3aGlsZSAobGVuKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBpZWNlID0gTWF0aC5taW4oYS5sZW4sIGxlbik7XG4gICAgICAgICAgICAgICAgaWYgKGEuaW5zID49IDAgJiYgaW5zZXJ0ZWQgPCBhLmkgJiYgYS5sZW4gPD0gcGllY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgMCwgYS5pbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGEudGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydGVkID0gYS5pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhLmZvcndhcmQocGllY2UpO1xuICAgICAgICAgICAgICAgIGxlbiAtPSBwaWVjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuaW5zID49IDApIHtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIHBhcnQgb2YgYSBjaGFuZ2UgaW4gQSB1cCB0byB0aGUgc3RhcnQgb2YgdGhlIG5leHRcbiAgICAgICAgICAgIC8vIG5vbi1kZWxldGlvbiBjaGFuZ2UgaW4gQiAoaWYgb3ZlcmxhcHBpbmcpLlxuICAgICAgICAgICAgbGV0IGxlbiA9IDAsIGxlZnQgPSBhLmxlbjtcbiAgICAgICAgICAgIHdoaWxlIChsZWZ0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGIuaW5zID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwaWVjZSA9IE1hdGgubWluKGxlZnQsIGIubGVuKTtcbiAgICAgICAgICAgICAgICAgICAgbGVuICs9IHBpZWNlO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0IC09IHBpZWNlO1xuICAgICAgICAgICAgICAgICAgICBiLmZvcndhcmQocGllY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChiLmlucyA9PSAwICYmIGIubGVuIDwgbGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0IC09IGIubGVuO1xuICAgICAgICAgICAgICAgICAgICBiLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGxlbiwgaW5zZXJ0ZWQgPCBhLmkgPyBhLmlucyA6IDApO1xuICAgICAgICAgICAgaWYgKGluc2VydCAmJiBpbnNlcnRlZCA8IGEuaSlcbiAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYS50ZXh0KTtcbiAgICAgICAgICAgIGluc2VydGVkID0gYS5pO1xuICAgICAgICAgICAgYS5mb3J3YXJkKGEubGVuIC0gbGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5kb25lICYmIGIuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIGluc2VydCA/IENoYW5nZVNldC5jcmVhdGVTZXQoc2VjdGlvbnMsIGluc2VydCkgOiBDaGFuZ2VEZXNjLmNyZWF0ZShzZWN0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIGNoYW5nZSBzZXQgbGVuZ3Roc1wiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBvc2VTZXRzKHNldEEsIHNldEIsIG1rU2V0ID0gZmFsc2UpIHtcbiAgICBsZXQgc2VjdGlvbnMgPSBbXTtcbiAgICBsZXQgaW5zZXJ0ID0gbWtTZXQgPyBbXSA6IG51bGw7XG4gICAgbGV0IGEgPSBuZXcgU2VjdGlvbkl0ZXIoc2V0QSksIGIgPSBuZXcgU2VjdGlvbkl0ZXIoc2V0Qik7XG4gICAgZm9yIChsZXQgb3BlbiA9IGZhbHNlOzspIHtcbiAgICAgICAgaWYgKGEuZG9uZSAmJiBiLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNlcnQgPyBDaGFuZ2VTZXQuY3JlYXRlU2V0KHNlY3Rpb25zLCBpbnNlcnQpIDogQ2hhbmdlRGVzYy5jcmVhdGUoc2VjdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuaW5zID09IDApIHsgLy8gRGVsZXRpb24gaW4gQVxuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgYS5sZW4sIDAsIG9wZW4pO1xuICAgICAgICAgICAgYS5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYi5sZW4gPT0gMCAmJiAhYi5kb25lKSB7IC8vIEluc2VydGlvbiBpbiBCXG4gICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCAwLCBiLmlucywgb3Blbik7XG4gICAgICAgICAgICBpZiAoaW5zZXJ0KVxuICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBiLnRleHQpO1xuICAgICAgICAgICAgYi5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5kb25lIHx8IGIuZG9uZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBjaGFuZ2Ugc2V0IGxlbmd0aHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gTWF0aC5taW4oYS5sZW4yLCBiLmxlbiksIHNlY3Rpb25MZW4gPSBzZWN0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoYS5pbnMgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5zQiA9IGIuaW5zID09IC0xID8gLTEgOiBiLm9mZiA/IDAgOiBiLmlucztcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBsZW4sIGluc0IsIG9wZW4pO1xuICAgICAgICAgICAgICAgIGlmIChpbnNlcnQgJiYgaW5zQilcbiAgICAgICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGIudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiLmlucyA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGEub2ZmID8gMCA6IGEubGVuLCBsZW4sIG9wZW4pO1xuICAgICAgICAgICAgICAgIGlmIChpbnNlcnQpXG4gICAgICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBhLnRleHRCaXQobGVuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBhLm9mZiA/IDAgOiBhLmxlbiwgYi5vZmYgPyAwIDogYi5pbnMsIG9wZW4pO1xuICAgICAgICAgICAgICAgIGlmIChpbnNlcnQgJiYgIWIub2ZmKVxuICAgICAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYi50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wZW4gPSAoYS5pbnMgPiBsZW4gfHwgYi5pbnMgPj0gMCAmJiBiLmxlbiA+IGxlbikgJiYgKG9wZW4gfHwgc2VjdGlvbnMubGVuZ3RoID4gc2VjdGlvbkxlbik7XG4gICAgICAgICAgICBhLmZvcndhcmQyKGxlbik7XG4gICAgICAgICAgICBiLmZvcndhcmQobGVuKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFNlY3Rpb25JdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzZXQpIHtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBsZXQgeyBzZWN0aW9ucyB9ID0gdGhpcy5zZXQ7XG4gICAgICAgIGlmICh0aGlzLmkgPCBzZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubGVuID0gc2VjdGlvbnNbdGhpcy5pKytdO1xuICAgICAgICAgICAgdGhpcy5pbnMgPSBzZWN0aW9uc1t0aGlzLmkrK107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxlbiA9IDA7XG4gICAgICAgICAgICB0aGlzLmlucyA9IC0yO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2ZmID0gMDtcbiAgICB9XG4gICAgZ2V0IGRvbmUoKSB7IHJldHVybiB0aGlzLmlucyA9PSAtMjsgfVxuICAgIGdldCBsZW4yKCkgeyByZXR1cm4gdGhpcy5pbnMgPCAwID8gdGhpcy5sZW4gOiB0aGlzLmluczsgfVxuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICBsZXQgeyBpbnNlcnRlZCB9ID0gdGhpcy5zZXQsIGluZGV4ID0gKHRoaXMuaSAtIDIpID4+IDE7XG4gICAgICAgIHJldHVybiBpbmRleCA+PSBpbnNlcnRlZC5sZW5ndGggPyBUZXh0LmVtcHR5IDogaW5zZXJ0ZWRbaW5kZXhdO1xuICAgIH1cbiAgICB0ZXh0Qml0KGxlbikge1xuICAgICAgICBsZXQgeyBpbnNlcnRlZCB9ID0gdGhpcy5zZXQsIGluZGV4ID0gKHRoaXMuaSAtIDIpID4+IDE7XG4gICAgICAgIHJldHVybiBpbmRleCA+PSBpbnNlcnRlZC5sZW5ndGggJiYgIWxlbiA/IFRleHQuZW1wdHlcbiAgICAgICAgICAgIDogaW5zZXJ0ZWRbaW5kZXhdLnNsaWNlKHRoaXMub2ZmLCBsZW4gPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHRoaXMub2ZmICsgbGVuKTtcbiAgICB9XG4gICAgZm9yd2FyZChsZW4pIHtcbiAgICAgICAgaWYgKGxlbiA9PSB0aGlzLmxlbilcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGVuIC09IGxlbjtcbiAgICAgICAgICAgIHRoaXMub2ZmICs9IGxlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3J3YXJkMihsZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zID09IC0xKVxuICAgICAgICAgICAgdGhpcy5mb3J3YXJkKGxlbik7XG4gICAgICAgIGVsc2UgaWYgKGxlbiA9PSB0aGlzLmlucylcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5zIC09IGxlbjtcbiAgICAgICAgICAgIHRoaXMub2ZmICs9IGxlbjtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG5BIHNpbmdsZSBzZWxlY3Rpb24gcmFuZ2UuIFdoZW5cbltgYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmFsbG93TXVsdGlwbGVTZWxlY3Rpb25zKVxuaXMgZW5hYmxlZCwgYSBbc2VsZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclNlbGVjdGlvbikgbWF5IGhvbGRcbm11bHRpcGxlIHJhbmdlcy4gQnkgZGVmYXVsdCwgc2VsZWN0aW9ucyBob2xkIGV4YWN0bHkgb25lIHJhbmdlLlxuKi9cbmNsYXNzIFNlbGVjdGlvblJhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbG93ZXIgYm91bmRhcnkgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIHVwcGVyIGJvdW5kYXJ5IG9mIHRoZSByYW5nZS5cbiAgICAqL1xuICAgIHRvLCBmbGFncykge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGFuY2hvciBvZiB0aGUgcmFuZ2XigJR0aGUgc2lkZSB0aGF0IGRvZXNuJ3QgbW92ZSB3aGVuIHlvdVxuICAgIGV4dGVuZCBpdC5cbiAgICAqL1xuICAgIGdldCBhbmNob3IoKSB7IHJldHVybiB0aGlzLmZsYWdzICYgMzIgLyogUmFuZ2VGbGFnLkludmVydGVkICovID8gdGhpcy50byA6IHRoaXMuZnJvbTsgfVxuICAgIC8qKlxuICAgIFRoZSBoZWFkIG9mIHRoZSByYW5nZSwgd2hpY2ggaXMgbW92ZWQgd2hlbiB0aGUgcmFuZ2UgaXNcbiAgICBbZXh0ZW5kZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU2VsZWN0aW9uUmFuZ2UuZXh0ZW5kKS5cbiAgICAqL1xuICAgIGdldCBoZWFkKCkgeyByZXR1cm4gdGhpcy5mbGFncyAmIDMyIC8qIFJhbmdlRmxhZy5JbnZlcnRlZCAqLyA/IHRoaXMuZnJvbSA6IHRoaXMudG87IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gYGFuY2hvcmAgYW5kIGBoZWFkYCBhcmUgYXQgdGhlIHNhbWUgcG9zaXRpb24uXG4gICAgKi9cbiAgICBnZXQgZW1wdHkoKSB7IHJldHVybiB0aGlzLmZyb20gPT0gdGhpcy50bzsgfVxuICAgIC8qKlxuICAgIElmIHRoaXMgaXMgYSBjdXJzb3IgdGhhdCBpcyBleHBsaWNpdGx5IGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgICBjaGFyYWN0ZXIgb24gb25lIG9mIGl0cyBzaWRlcywgdGhpcyByZXR1cm5zIHRoZSBzaWRlLiAtMSBtZWFuc1xuICAgIHRoZSBjaGFyYWN0ZXIgYmVmb3JlIGl0cyBwb3NpdGlvbiwgMSB0aGUgY2hhcmFjdGVyIGFmdGVyLCBhbmQgMFxuICAgIG1lYW5zIG5vIGFzc29jaWF0aW9uLlxuICAgICovXG4gICAgZ2V0IGFzc29jKCkgeyByZXR1cm4gdGhpcy5mbGFncyAmIDggLyogUmFuZ2VGbGFnLkFzc29jQmVmb3JlICovID8gLTEgOiB0aGlzLmZsYWdzICYgMTYgLyogUmFuZ2VGbGFnLkFzc29jQWZ0ZXIgKi8gPyAxIDogMDsgfVxuICAgIC8qKlxuICAgIFRoZSBiaWRpcmVjdGlvbmFsIHRleHQgbGV2ZWwgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY3Vyc29yLCBpZlxuICAgIGFueS5cbiAgICAqL1xuICAgIGdldCBiaWRpTGV2ZWwoKSB7XG4gICAgICAgIGxldCBsZXZlbCA9IHRoaXMuZmxhZ3MgJiA3IC8qIFJhbmdlRmxhZy5CaWRpTGV2ZWxNYXNrICovO1xuICAgICAgICByZXR1cm4gbGV2ZWwgPT0gNyA/IG51bGwgOiBsZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGdvYWwgY29sdW1uIChzdG9yZWQgdmVydGljYWwgb2Zmc2V0KSBhc3NvY2lhdGVkIHdpdGggYVxuICAgIGN1cnNvci4gVGhpcyBpcyB1c2VkIHRvIHByZXNlcnZlIHRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiB3aGVuXG4gICAgW21vdmluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubW92ZVZlcnRpY2FsbHkpIGFjcm9zc1xuICAgIGxpbmVzIG9mIGRpZmZlcmVudCBsZW5ndGguXG4gICAgKi9cbiAgICBnZXQgZ29hbENvbHVtbigpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5mbGFncyA+PiA2IC8qIFJhbmdlRmxhZy5Hb2FsQ29sdW1uT2Zmc2V0ICovO1xuICAgICAgICByZXR1cm4gdmFsdWUgPT0gMTY3NzcyMTUgLyogUmFuZ2VGbGFnLk5vR29hbENvbHVtbiAqLyA/IHVuZGVmaW5lZCA6IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgdGhpcyByYW5nZSB0aHJvdWdoIGEgY2hhbmdlLCBwcm9kdWNpbmcgYSB2YWxpZCByYW5nZSBpbiB0aGVcbiAgICB1cGRhdGVkIGRvY3VtZW50LlxuICAgICovXG4gICAgbWFwKGNoYW5nZSwgYXNzb2MgPSAtMSkge1xuICAgICAgICBsZXQgZnJvbSwgdG87XG4gICAgICAgIGlmICh0aGlzLmVtcHR5KSB7XG4gICAgICAgICAgICBmcm9tID0gdG8gPSBjaGFuZ2UubWFwUG9zKHRoaXMuZnJvbSwgYXNzb2MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnJvbSA9IGNoYW5nZS5tYXBQb3ModGhpcy5mcm9tLCAxKTtcbiAgICAgICAgICAgIHRvID0gY2hhbmdlLm1hcFBvcyh0aGlzLnRvLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyb20gPT0gdGhpcy5mcm9tICYmIHRvID09IHRoaXMudG8gPyB0aGlzIDogbmV3IFNlbGVjdGlvblJhbmdlKGZyb20sIHRvLCB0aGlzLmZsYWdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRXh0ZW5kIHRoaXMgcmFuZ2UgdG8gY292ZXIgYXQgbGVhc3QgYGZyb21gIHRvIGB0b2AuXG4gICAgKi9cbiAgICBleHRlbmQoZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgICAgIGlmIChmcm9tIDw9IHRoaXMuYW5jaG9yICYmIHRvID49IHRoaXMuYW5jaG9yKVxuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0byk7XG4gICAgICAgIGxldCBoZWFkID0gTWF0aC5hYnMoZnJvbSAtIHRoaXMuYW5jaG9yKSA+IE1hdGguYWJzKHRvIC0gdGhpcy5hbmNob3IpID8gZnJvbSA6IHRvO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHRoaXMuYW5jaG9yLCBoZWFkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIHJhbmdlIHRvIGFub3RoZXIgcmFuZ2UuXG4gICAgKi9cbiAgICBlcShvdGhlciwgaW5jbHVkZUFzc29jID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5jaG9yID09IG90aGVyLmFuY2hvciAmJiB0aGlzLmhlYWQgPT0gb3RoZXIuaGVhZCAmJlxuICAgICAgICAgICAgKCFpbmNsdWRlQXNzb2MgfHwgIXRoaXMuZW1wdHkgfHwgdGhpcy5hc3NvYyA9PSBvdGhlci5hc3NvYyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIEpTT04tc2VyaWFsaXphYmxlIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHJhbmdlLlxuICAgICovXG4gICAgdG9KU09OKCkgeyByZXR1cm4geyBhbmNob3I6IHRoaXMuYW5jaG9yLCBoZWFkOiB0aGlzLmhlYWQgfTsgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgcmFuZ2UgdG8gYSBgU2VsZWN0aW9uUmFuZ2VgXG4gICAgaW5zdGFuY2UuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIWpzb24gfHwgdHlwZW9mIGpzb24uYW5jaG9yICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uaGVhZCAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIFNlbGVjdGlvblJhbmdlXCIpO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGpzb24uYW5jaG9yLCBqc29uLmhlYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZnJvbSwgdG8sIGZsYWdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uUmFuZ2UoZnJvbSwgdG8sIGZsYWdzKTtcbiAgICB9XG59XG4vKipcbkFuIGVkaXRvciBzZWxlY3Rpb24gaG9sZHMgb25lIG9yIG1vcmUgc2VsZWN0aW9uIHJhbmdlcy5cbiovXG5jbGFzcyBFZGl0b3JTZWxlY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSByYW5nZXMgaW4gdGhlIHNlbGVjdGlvbiwgc29ydGVkIGJ5IHBvc2l0aW9uLiBSYW5nZXMgY2Fubm90XG4gICAgb3ZlcmxhcCAoYnV0IHRoZXkgbWF5IHRvdWNoLCBpZiB0aGV5IGFyZW4ndCBlbXB0eSkuXG4gICAgKi9cbiAgICByYW5nZXMsIFxuICAgIC8qKlxuICAgIFRoZSBpbmRleCBvZiB0aGUgX21haW5fIHJhbmdlIGluIHRoZSBzZWxlY3Rpb24gKHdoaWNoIGlzXG4gICAgdXN1YWxseSB0aGUgcmFuZ2UgdGhhdCB3YXMgYWRkZWQgbGFzdCkuXG4gICAgKi9cbiAgICBtYWluSW5kZXgpIHtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMubWFpbkluZGV4ID0gbWFpbkluZGV4O1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgYSBzZWxlY3Rpb24gdGhyb3VnaCBhIGNoYW5nZS4gVXNlZCB0byBhZGp1c3QgdGhlIHNlbGVjdGlvblxuICAgIHBvc2l0aW9uIGZvciBjaGFuZ2VzLlxuICAgICovXG4gICAgbWFwKGNoYW5nZSwgYXNzb2MgPSAtMSkge1xuICAgICAgICBpZiAoY2hhbmdlLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHRoaXMucmFuZ2VzLm1hcChyID0+IHIubWFwKGNoYW5nZSwgYXNzb2MpKSwgdGhpcy5tYWluSW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgc2VsZWN0aW9uIHRvIGFub3RoZXIgc2VsZWN0aW9uLiBCeSBkZWZhdWx0LCByYW5nZXNcbiAgICBhcmUgY29tcGFyZWQgb25seSBieSBwb3NpdGlvbi4gV2hlbiBgaW5jbHVkZUFzc29jYCBpcyB0cnVlLFxuICAgIGN1cnNvciByYW5nZXMgbXVzdCBhbHNvIGhhdmUgdGhlIHNhbWVcbiAgICBbYGFzc29jYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25SYW5nZS5hc3NvYykgdmFsdWUuXG4gICAgKi9cbiAgICBlcShvdGhlciwgaW5jbHVkZUFzc29jID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2VzLmxlbmd0aCAhPSBvdGhlci5yYW5nZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICB0aGlzLm1haW5JbmRleCAhPSBvdGhlci5tYWluSW5kZXgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMucmFuZ2VzW2ldLmVxKG90aGVyLnJhbmdlc1tpXSwgaW5jbHVkZUFzc29jKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHByaW1hcnkgc2VsZWN0aW9uIHJhbmdlLiBVc3VhbGx5LCB5b3Ugc2hvdWxkIG1ha2Ugc3VyZVxuICAgIHlvdXIgY29kZSBhcHBsaWVzIHRvIF9hbGxfIHJhbmdlcywgYnkgdXNpbmcgbWV0aG9kcyBsaWtlXG4gICAgW2BjaGFuZ2VCeVJhbmdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5jaGFuZ2VCeVJhbmdlKS5cbiAgICAqL1xuICAgIGdldCBtYWluKCkgeyByZXR1cm4gdGhpcy5yYW5nZXNbdGhpcy5tYWluSW5kZXhdOyB9XG4gICAgLyoqXG4gICAgTWFrZSBzdXJlIHRoZSBzZWxlY3Rpb24gb25seSBoYXMgb25lIHJhbmdlLiBSZXR1cm5zIGEgc2VsZWN0aW9uXG4gICAgaG9sZGluZyBvbmx5IHRoZSBtYWluIHJhbmdlIGZyb20gdGhpcyBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBhc1NpbmdsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VzLmxlbmd0aCA9PSAxID8gdGhpcyA6IG5ldyBFZGl0b3JTZWxlY3Rpb24oW3RoaXMubWFpbl0sIDApO1xuICAgIH1cbiAgICAvKipcbiAgICBFeHRlbmQgdGhpcyBzZWxlY3Rpb24gd2l0aCBhbiBleHRyYSByYW5nZS5cbiAgICAqL1xuICAgIGFkZFJhbmdlKHJhbmdlLCBtYWluID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShbcmFuZ2VdLmNvbmNhdCh0aGlzLnJhbmdlcyksIG1haW4gPyAwIDogdGhpcy5tYWluSW5kZXggKyAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSBhIGdpdmVuIHJhbmdlIHdpdGggYW5vdGhlciByYW5nZSwgYW5kIHRoZW4gbm9ybWFsaXplIHRoZVxuICAgIHNlbGVjdGlvbiB0byBtZXJnZSBhbmQgc29ydCByYW5nZXMgaWYgbmVjZXNzYXJ5LlxuICAgICovXG4gICAgcmVwbGFjZVJhbmdlKHJhbmdlLCB3aGljaCA9IHRoaXMubWFpbkluZGV4KSB7XG4gICAgICAgIGxldCByYW5nZXMgPSB0aGlzLnJhbmdlcy5zbGljZSgpO1xuICAgICAgICByYW5nZXNbd2hpY2hdID0gcmFuZ2U7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcywgdGhpcy5tYWluSW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb252ZXJ0IHRoaXMgc2VsZWN0aW9uIHRvIGFuIG9iamVjdCB0aGF0IGNhbiBiZSBzZXJpYWxpemVkIHRvXG4gICAgSlNPTi5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2VzOiB0aGlzLnJhbmdlcy5tYXAociA9PiByLnRvSlNPTigpKSwgbWFpbjogdGhpcy5tYWluSW5kZXggfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2VsZWN0aW9uIGZyb20gYSBKU09OIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uIHx8ICFBcnJheS5pc0FycmF5KGpzb24ucmFuZ2VzKSB8fCB0eXBlb2YganNvbi5tYWluICE9IFwibnVtYmVyXCIgfHwganNvbi5tYWluID49IGpzb24ucmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIGZvciBFZGl0b3JTZWxlY3Rpb25cIik7XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU2VsZWN0aW9uKGpzb24ucmFuZ2VzLm1hcCgocikgPT4gU2VsZWN0aW9uUmFuZ2UuZnJvbUpTT04ocikpLCBqc29uLm1haW4pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZWxlY3Rpb24gaG9sZGluZyBhIHNpbmdsZSByYW5nZS5cbiAgICAqL1xuICAgIHN0YXRpYyBzaW5nbGUoYW5jaG9yLCBoZWFkID0gYW5jaG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU2VsZWN0aW9uKFtFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoYW5jaG9yLCBoZWFkKV0sIDApO1xuICAgIH1cbiAgICAvKipcbiAgICBTb3J0IGFuZCBtZXJnZSB0aGUgZ2l2ZW4gc2V0IG9mIHJhbmdlcywgY3JlYXRpbmcgYSB2YWxpZFxuICAgIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUocmFuZ2VzLCBtYWluSW5kZXggPSAwKSB7XG4gICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkEgc2VsZWN0aW9uIG5lZWRzIGF0IGxlYXN0IG9uZSByYW5nZVwiKTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5lbXB0eSA/IHJhbmdlLmZyb20gPD0gcG9zIDogcmFuZ2UuZnJvbSA8IHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLm5vcm1hbGl6ZWQocmFuZ2VzLnNsaWNlKCksIG1haW5JbmRleCk7XG4gICAgICAgICAgICBwb3MgPSByYW5nZS50bztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVkaXRvclNlbGVjdGlvbihyYW5nZXMsIG1haW5JbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGN1cnNvciBzZWxlY3Rpb24gcmFuZ2UgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLiBZb3UgY2FuXG4gICAgc2FmZWx5IGlnbm9yZSB0aGUgb3B0aW9uYWwgYXJndW1lbnRzIGluIG1vc3Qgc2l0dWF0aW9ucy5cbiAgICAqL1xuICAgIHN0YXRpYyBjdXJzb3IocG9zLCBhc3NvYyA9IDAsIGJpZGlMZXZlbCwgZ29hbENvbHVtbikge1xuICAgICAgICByZXR1cm4gU2VsZWN0aW9uUmFuZ2UuY3JlYXRlKHBvcywgcG9zLCAoYXNzb2MgPT0gMCA/IDAgOiBhc3NvYyA8IDAgPyA4IC8qIFJhbmdlRmxhZy5Bc3NvY0JlZm9yZSAqLyA6IDE2IC8qIFJhbmdlRmxhZy5Bc3NvY0FmdGVyICovKSB8XG4gICAgICAgICAgICAoYmlkaUxldmVsID09IG51bGwgPyA3IDogTWF0aC5taW4oNiwgYmlkaUxldmVsKSkgfFxuICAgICAgICAgICAgKChnb2FsQ29sdW1uICE9PSBudWxsICYmIGdvYWxDb2x1bW4gIT09IHZvaWQgMCA/IGdvYWxDb2x1bW4gOiAxNjc3NzIxNSAvKiBSYW5nZUZsYWcuTm9Hb2FsQ29sdW1uICovKSA8PCA2IC8qIFJhbmdlRmxhZy5Hb2FsQ29sdW1uT2Zmc2V0ICovKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNlbGVjdGlvbiByYW5nZS5cbiAgICAqL1xuICAgIHN0YXRpYyByYW5nZShhbmNob3IsIGhlYWQsIGdvYWxDb2x1bW4sIGJpZGlMZXZlbCkge1xuICAgICAgICBsZXQgZmxhZ3MgPSAoKGdvYWxDb2x1bW4gIT09IG51bGwgJiYgZ29hbENvbHVtbiAhPT0gdm9pZCAwID8gZ29hbENvbHVtbiA6IDE2Nzc3MjE1IC8qIFJhbmdlRmxhZy5Ob0dvYWxDb2x1bW4gKi8pIDw8IDYgLyogUmFuZ2VGbGFnLkdvYWxDb2x1bW5PZmZzZXQgKi8pIHxcbiAgICAgICAgICAgIChiaWRpTGV2ZWwgPT0gbnVsbCA/IDcgOiBNYXRoLm1pbig2LCBiaWRpTGV2ZWwpKTtcbiAgICAgICAgcmV0dXJuIGhlYWQgPCBhbmNob3IgPyBTZWxlY3Rpb25SYW5nZS5jcmVhdGUoaGVhZCwgYW5jaG9yLCAzMiAvKiBSYW5nZUZsYWcuSW52ZXJ0ZWQgKi8gfCAxNiAvKiBSYW5nZUZsYWcuQXNzb2NBZnRlciAqLyB8IGZsYWdzKVxuICAgICAgICAgICAgOiBTZWxlY3Rpb25SYW5nZS5jcmVhdGUoYW5jaG9yLCBoZWFkLCAoaGVhZCA+IGFuY2hvciA/IDggLyogUmFuZ2VGbGFnLkFzc29jQmVmb3JlICovIDogMCkgfCBmbGFncyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIG5vcm1hbGl6ZWQocmFuZ2VzLCBtYWluSW5kZXggPSAwKSB7XG4gICAgICAgIGxldCBtYWluID0gcmFuZ2VzW21haW5JbmRleF07XG4gICAgICAgIHJhbmdlcy5zb3J0KChhLCBiKSA9PiBhLmZyb20gLSBiLmZyb20pO1xuICAgICAgICBtYWluSW5kZXggPSByYW5nZXMuaW5kZXhPZihtYWluKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHJhbmdlc1tpXSwgcHJldiA9IHJhbmdlc1tpIC0gMV07XG4gICAgICAgICAgICBpZiAocmFuZ2UuZW1wdHkgPyByYW5nZS5mcm9tIDw9IHByZXYudG8gOiByYW5nZS5mcm9tIDwgcHJldi50bykge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gcHJldi5mcm9tLCB0byA9IE1hdGgubWF4KHJhbmdlLnRvLCBwcmV2LnRvKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA8PSBtYWluSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIG1haW5JbmRleC0tO1xuICAgICAgICAgICAgICAgIHJhbmdlcy5zcGxpY2UoLS1pLCAyLCByYW5nZS5hbmNob3IgPiByYW5nZS5oZWFkID8gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHRvLCBmcm9tKSA6IEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU2VsZWN0aW9uKHJhbmdlcywgbWFpbkluZGV4KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1NlbGVjdGlvbihzZWxlY3Rpb24sIGRvY0xlbmd0aCkge1xuICAgIGZvciAobGV0IHJhbmdlIG9mIHNlbGVjdGlvbi5yYW5nZXMpXG4gICAgICAgIGlmIChyYW5nZS50byA+IGRvY0xlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiU2VsZWN0aW9uIHBvaW50cyBvdXRzaWRlIG9mIGRvY3VtZW50XCIpO1xufVxuXG5sZXQgbmV4dElEID0gMDtcbi8qKlxuQSBmYWNldCBpcyBhIGxhYmVsZWQgdmFsdWUgdGhhdCBpcyBhc3NvY2lhdGVkIHdpdGggYW4gZWRpdG9yXG5zdGF0ZS4gSXQgdGFrZXMgaW5wdXRzIGZyb20gYW55IG51bWJlciBvZiBleHRlbnNpb25zLCBhbmQgY29tYmluZXNcbnRob3NlIGludG8gYSBzaW5nbGUgb3V0cHV0IHZhbHVlLlxuXG5FeGFtcGxlcyBvZiB1c2VzIG9mIGZhY2V0cyBhcmUgdGhlIFt0YWJcbnNpemVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedGFiU2l6ZSksIFtlZGl0b3JcbmF0dHJpYnV0ZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmVkaXRvckF0dHJpYnV0ZXMpLCBhbmQgW3VwZGF0ZVxubGlzdGVuZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld151cGRhdGVMaXN0ZW5lcikuXG5cbk5vdGUgdGhhdCBgRmFjZXRgIGluc3RhbmNlcyBjYW4gYmUgdXNlZCBhbnl3aGVyZSB3aGVyZVxuW2BGYWNldFJlYWRlcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRmFjZXRSZWFkZXIpIGlzIGV4cGVjdGVkLlxuKi9cbmNsYXNzIEZhY2V0IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbWJpbmUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcGFyZUlucHV0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXBhcmUsIGlzU3RhdGljLCBlbmFibGVzKSB7XG4gICAgICAgIHRoaXMuY29tYmluZSA9IGNvbWJpbmU7XG4gICAgICAgIHRoaXMuY29tcGFyZUlucHV0ID0gY29tcGFyZUlucHV0O1xuICAgICAgICB0aGlzLmNvbXBhcmUgPSBjb21wYXJlO1xuICAgICAgICB0aGlzLmlzU3RhdGljID0gaXNTdGF0aWM7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IG5leHRJRCsrO1xuICAgICAgICB0aGlzLmRlZmF1bHQgPSBjb21iaW5lKFtdKTtcbiAgICAgICAgdGhpcy5leHRlbnNpb25zID0gdHlwZW9mIGVuYWJsZXMgPT0gXCJmdW5jdGlvblwiID8gZW5hYmxlcyh0aGlzKSA6IGVuYWJsZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYSBmYWNldCByZWFkZXIgZm9yIHRoaXMgZmFjZXQsIHdoaWNoIGNhbiBiZSB1c2VkIHRvXG4gICAgW3JlYWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuZmFjZXQpIGl0IGJ1dCBub3QgdG8gZGVmaW5lIHZhbHVlcyBmb3IgaXQuXG4gICAgKi9cbiAgICBnZXQgcmVhZGVyKCkgeyByZXR1cm4gdGhpczsgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIG5ldyBmYWNldC5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoY29uZmlnID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGYWNldChjb25maWcuY29tYmluZSB8fCAoKGEpID0+IGEpLCBjb25maWcuY29tcGFyZUlucHV0IHx8ICgoYSwgYikgPT4gYSA9PT0gYiksIGNvbmZpZy5jb21wYXJlIHx8ICghY29uZmlnLmNvbWJpbmUgPyBzYW1lQXJyYXkgOiAoYSwgYikgPT4gYSA9PT0gYiksICEhY29uZmlnLnN0YXRpYywgY29uZmlnLmVuYWJsZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGFkZHMgdGhlIGdpdmVuIHZhbHVlIHRvIHRoaXMgZmFjZXQuXG4gICAgKi9cbiAgICBvZih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IEZhY2V0UHJvdmlkZXIoW10sIHRoaXMsIDAgLyogUHJvdmlkZXIuU3RhdGljICovLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBjb21wdXRlcyBhIHZhbHVlIGZvciB0aGUgZmFjZXQgZnJvbSBhXG4gICAgc3RhdGUuIFlvdSBtdXN0IHRha2UgY2FyZSB0byBkZWNsYXJlIHRoZSBwYXJ0cyBvZiB0aGUgc3RhdGUgdGhhdFxuICAgIHRoaXMgdmFsdWUgZGVwZW5kcyBvbiwgc2luY2UgeW91ciBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBhZ2FpblxuICAgIGZvciBhIG5ldyBzdGF0ZSB3aGVuIG9uZSBvZiB0aG9zZSBwYXJ0cyBjaGFuZ2VkLlxuICAgIFxuICAgIEluIGNhc2VzIHdoZXJlIHlvdXIgdmFsdWUgZGVwZW5kcyBvbmx5IG9uIGEgc2luZ2xlIGZpZWxkLCB5b3UnbGxcbiAgICB3YW50IHRvIHVzZSB0aGUgW2Bmcm9tYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5GYWNldC5mcm9tKSBtZXRob2QgaW5zdGVhZC5cbiAgICAqL1xuICAgIGNvbXB1dGUoZGVwcywgZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzU3RhdGljKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY29tcHV0ZSBhIHN0YXRpYyBmYWNldFwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGYWNldFByb3ZpZGVyKGRlcHMsIHRoaXMsIDEgLyogUHJvdmlkZXIuU2luZ2xlICovLCBnZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgY29tcHV0ZXMgemVybyBvciBtb3JlIHZhbHVlcyBmb3IgdGhpc1xuICAgIGZhY2V0IGZyb20gYSBzdGF0ZS5cbiAgICAqL1xuICAgIGNvbXB1dGVOKGRlcHMsIGdldCkge1xuICAgICAgICBpZiAodGhpcy5pc1N0YXRpYylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGNvbXB1dGUgYSBzdGF0aWMgZmFjZXRcIik7XG4gICAgICAgIHJldHVybiBuZXcgRmFjZXRQcm92aWRlcihkZXBzLCB0aGlzLCAyIC8qIFByb3ZpZGVyLk11bHRpICovLCBnZXQpO1xuICAgIH1cbiAgICBmcm9tKGZpZWxkLCBnZXQpIHtcbiAgICAgICAgaWYgKCFnZXQpXG4gICAgICAgICAgICBnZXQgPSB4ID0+IHg7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGUoW2ZpZWxkXSwgc3RhdGUgPT4gZ2V0KHN0YXRlLmZpZWxkKGZpZWxkKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbWVBcnJheShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT0gYiB8fCBhLmxlbmd0aCA9PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KChlLCBpKSA9PiBlID09PSBiW2ldKTtcbn1cbmNsYXNzIEZhY2V0UHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKGRlcGVuZGVuY2llcywgZmFjZXQsIHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgICAgICB0aGlzLmZhY2V0ID0gZmFjZXQ7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRJRCsrO1xuICAgIH1cbiAgICBkeW5hbWljU2xvdChhZGRyZXNzZXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgZ2V0dGVyID0gdGhpcy52YWx1ZTtcbiAgICAgICAgbGV0IGNvbXBhcmUgPSB0aGlzLmZhY2V0LmNvbXBhcmVJbnB1dDtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5pZCwgaWR4ID0gYWRkcmVzc2VzW2lkXSA+PiAxLCBtdWx0aSA9IHRoaXMudHlwZSA9PSAyIC8qIFByb3ZpZGVyLk11bHRpICovO1xuICAgICAgICBsZXQgZGVwRG9jID0gZmFsc2UsIGRlcFNlbCA9IGZhbHNlLCBkZXBBZGRycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBkZXAgb2YgdGhpcy5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgIGlmIChkZXAgPT0gXCJkb2NcIilcbiAgICAgICAgICAgICAgICBkZXBEb2MgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoZGVwID09IFwic2VsZWN0aW9uXCIpXG4gICAgICAgICAgICAgICAgZGVwU2VsID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCgoKF9hID0gYWRkcmVzc2VzW2RlcC5pZF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEpICYgMSkgPT0gMClcbiAgICAgICAgICAgICAgICBkZXBBZGRycy5wdXNoKGFkZHJlc3Nlc1tkZXAuaWRdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3JlYXRlKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSBnZXR0ZXIoc3RhdGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGUoc3RhdGUsIHRyKSB7XG4gICAgICAgICAgICAgICAgaWYgKChkZXBEb2MgJiYgdHIuZG9jQ2hhbmdlZCkgfHwgKGRlcFNlbCAmJiAodHIuZG9jQ2hhbmdlZCB8fCB0ci5zZWxlY3Rpb24pKSB8fCBlbnN1cmVBbGwoc3RhdGUsIGRlcEFkZHJzKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3VmFsID0gZ2V0dGVyKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpID8gIWNvbXBhcmVBcnJheShuZXdWYWwsIHN0YXRlLnZhbHVlc1tpZHhdLCBjb21wYXJlKSA6ICFjb21wYXJlKG5ld1ZhbCwgc3RhdGUudmFsdWVzW2lkeF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG5ld1ZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWNvbmZpZ3VyZTogKHN0YXRlLCBvbGRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBuZXdWYWwsIG9sZEFkZHIgPSBvbGRTdGF0ZS5jb25maWcuYWRkcmVzc1tpZF07XG4gICAgICAgICAgICAgICAgaWYgKG9sZEFkZHIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb2xkVmFsID0gZ2V0QWRkcihvbGRTdGF0ZSwgb2xkQWRkcik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlcGVuZGVuY2llcy5ldmVyeShkZXAgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlcCBpbnN0YW5jZW9mIEZhY2V0ID8gb2xkU3RhdGUuZmFjZXQoZGVwKSA9PT0gc3RhdGUuZmFjZXQoZGVwKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwIGluc3RhbmNlb2YgU3RhdGVGaWVsZCA/IG9sZFN0YXRlLmZpZWxkKGRlcCwgZmFsc2UpID09IHN0YXRlLmZpZWxkKGRlcCwgZmFsc2UpIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSkgfHwgKG11bHRpID8gY29tcGFyZUFycmF5KG5ld1ZhbCA9IGdldHRlcihzdGF0ZSksIG9sZFZhbCwgY29tcGFyZSkgOiBjb21wYXJlKG5ld1ZhbCA9IGdldHRlcihzdGF0ZSksIG9sZFZhbCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG9sZFZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWwgPSBnZXR0ZXIoc3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG5ld1ZhbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGFyZUFycmF5KGEsIGIsIGNvbXBhcmUpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghY29tcGFyZShhW2ldLCBiW2ldKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUFsbChzdGF0ZSwgYWRkcnMpIHtcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGFkZHIgb2YgYWRkcnMpXG4gICAgICAgIGlmIChlbnN1cmVBZGRyKHN0YXRlLCBhZGRyKSAmIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovKVxuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG59XG5mdW5jdGlvbiBkeW5hbWljRmFjZXRTbG90KGFkZHJlc3NlcywgZmFjZXQsIHByb3ZpZGVycykge1xuICAgIGxldCBwcm92aWRlckFkZHJzID0gcHJvdmlkZXJzLm1hcChwID0+IGFkZHJlc3Nlc1twLmlkXSk7XG4gICAgbGV0IHByb3ZpZGVyVHlwZXMgPSBwcm92aWRlcnMubWFwKHAgPT4gcC50eXBlKTtcbiAgICBsZXQgZHluYW1pYyA9IHByb3ZpZGVyQWRkcnMuZmlsdGVyKHAgPT4gIShwICYgMSkpO1xuICAgIGxldCBpZHggPSBhZGRyZXNzZXNbZmFjZXQuaWRdID4+IDE7XG4gICAgZnVuY3Rpb24gZ2V0KHN0YXRlKSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm92aWRlckFkZHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBnZXRBZGRyKHN0YXRlLCBwcm92aWRlckFkZHJzW2ldKTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlclR5cGVzW2ldID09IDIgLyogUHJvdmlkZXIuTXVsdGkgKi8pXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdmFsIG9mIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWwpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFjZXQuY29tYmluZSh2YWx1ZXMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjcmVhdGUoc3RhdGUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGFkZHIgb2YgcHJvdmlkZXJBZGRycylcbiAgICAgICAgICAgICAgICBlbnN1cmVBZGRyKHN0YXRlLCBhZGRyKTtcbiAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gZ2V0KHN0YXRlKTtcbiAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlKHN0YXRlLCB0cikge1xuICAgICAgICAgICAgaWYgKCFlbnN1cmVBbGwoc3RhdGUsIGR5bmFtaWMpKVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gZ2V0KHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChmYWNldC5jb21wYXJlKHZhbHVlLCBzdGF0ZS52YWx1ZXNbaWR4XSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICB9LFxuICAgICAgICByZWNvbmZpZ3VyZShzdGF0ZSwgb2xkU3RhdGUpIHtcbiAgICAgICAgICAgIGxldCBkZXBDaGFuZ2VkID0gZW5zdXJlQWxsKHN0YXRlLCBwcm92aWRlckFkZHJzKTtcbiAgICAgICAgICAgIGxldCBvbGRQcm92aWRlcnMgPSBvbGRTdGF0ZS5jb25maWcuZmFjZXRzW2ZhY2V0LmlkXSwgb2xkVmFsdWUgPSBvbGRTdGF0ZS5mYWNldChmYWNldCk7XG4gICAgICAgICAgICBpZiAob2xkUHJvdmlkZXJzICYmICFkZXBDaGFuZ2VkICYmIHNhbWVBcnJheShwcm92aWRlcnMsIG9sZFByb3ZpZGVycykpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG9sZFZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZhbHVlID0gZ2V0KHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChmYWNldC5jb21wYXJlKHZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG9sZFZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgfVxuICAgIH07XG59XG5jb25zdCBpbml0RmllbGQgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgc3RhdGljOiB0cnVlIH0pO1xuLyoqXG5GaWVsZHMgY2FuIHN0b3JlIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gaW4gYW4gZWRpdG9yIHN0YXRlLCBhbmRcbmtlZXAgaXQgaW4gc3luYyB3aXRoIHRoZSByZXN0IG9mIHRoZSBzdGF0ZS5cbiovXG5jbGFzcyBTdGF0ZUZpZWxkIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGlkLCBjcmVhdGVGLCB1cGRhdGVGLCBjb21wYXJlRiwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzcGVjKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5jcmVhdGVGID0gY3JlYXRlRjtcbiAgICAgICAgdGhpcy51cGRhdGVGID0gdXBkYXRlRjtcbiAgICAgICAgdGhpcy5jb21wYXJlRiA9IGNvbXBhcmVGO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMucHJvdmlkZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIHN0YXRlIGZpZWxkLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShjb25maWcpIHtcbiAgICAgICAgbGV0IGZpZWxkID0gbmV3IFN0YXRlRmllbGQobmV4dElEKyssIGNvbmZpZy5jcmVhdGUsIGNvbmZpZy51cGRhdGUsIGNvbmZpZy5jb21wYXJlIHx8ICgoYSwgYikgPT4gYSA9PT0gYiksIGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcucHJvdmlkZSlcbiAgICAgICAgICAgIGZpZWxkLnByb3ZpZGVzID0gY29uZmlnLnByb3ZpZGUoZmllbGQpO1xuICAgICAgICByZXR1cm4gZmllbGQ7XG4gICAgfVxuICAgIGNyZWF0ZShzdGF0ZSkge1xuICAgICAgICBsZXQgaW5pdCA9IHN0YXRlLmZhY2V0KGluaXRGaWVsZCkuZmluZChpID0+IGkuZmllbGQgPT0gdGhpcyk7XG4gICAgICAgIHJldHVybiAoKGluaXQgPT09IG51bGwgfHwgaW5pdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdC5jcmVhdGUpIHx8IHRoaXMuY3JlYXRlRikoc3RhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNsb3QoYWRkcmVzc2VzKSB7XG4gICAgICAgIGxldCBpZHggPSBhZGRyZXNzZXNbdGhpcy5pZF0gPj4gMTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNyZWF0ZTogKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB0aGlzLmNyZWF0ZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZTogKHN0YXRlLCB0cikgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBvbGRWYWwgPSBzdGF0ZS52YWx1ZXNbaWR4XTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLnVwZGF0ZUYob2xkVmFsLCB0cik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFyZUYob2xkVmFsLCB2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlY29uZmlndXJlOiAoc3RhdGUsIG9sZFN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZFN0YXRlLmNvbmZpZy5hZGRyZXNzW3RoaXMuaWRdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSBvbGRTdGF0ZS5maWVsZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gdGhpcy5jcmVhdGUoc3RhdGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBlbmFibGVzIHRoaXMgZmllbGQgYW5kIG92ZXJyaWRlcyB0aGVcbiAgICB3YXkgaXQgaXMgaW5pdGlhbGl6ZWQuIENhbiBiZSB1c2VmdWwgd2hlbiB5b3UgbmVlZCB0byBwcm92aWRlIGFcbiAgICBub24tZGVmYXVsdCBzdGFydGluZyB2YWx1ZSBmb3IgdGhlIGZpZWxkLlxuICAgICovXG4gICAgaW5pdChjcmVhdGUpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLCBpbml0RmllbGQub2YoeyBmaWVsZDogdGhpcywgY3JlYXRlIH0pXTtcbiAgICB9XG4gICAgLyoqXG4gICAgU3RhdGUgZmllbGQgaW5zdGFuY2VzIGNhbiBiZSB1c2VkIGFzXG4gICAgW2BFeHRlbnNpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkV4dGVuc2lvbikgdmFsdWVzIHRvIGVuYWJsZSB0aGUgZmllbGQgaW4gYVxuICAgIGdpdmVuIHN0YXRlLlxuICAgICovXG4gICAgZ2V0IGV4dGVuc2lvbigpIHsgcmV0dXJuIHRoaXM7IH1cbn1cbmNvbnN0IFByZWNfID0geyBsb3dlc3Q6IDQsIGxvdzogMywgZGVmYXVsdDogMiwgaGlnaDogMSwgaGlnaGVzdDogMCB9O1xuZnVuY3Rpb24gcHJlYyh2YWx1ZSkge1xuICAgIHJldHVybiAoZXh0KSA9PiBuZXcgUHJlY0V4dGVuc2lvbihleHQsIHZhbHVlKTtcbn1cbi8qKlxuQnkgZGVmYXVsdCBleHRlbnNpb25zIGFyZSByZWdpc3RlcmVkIGluIHRoZSBvcmRlciB0aGV5IGFyZSBmb3VuZFxuaW4gdGhlIGZsYXR0ZW5lZCBmb3JtIG9mIG5lc3RlZCBhcnJheSB0aGF0IHdhcyBwcm92aWRlZC5cbkluZGl2aWR1YWwgZXh0ZW5zaW9uIHZhbHVlcyBjYW4gYmUgYXNzaWduZWQgYSBwcmVjZWRlbmNlIHRvXG5vdmVycmlkZSB0aGlzLiBFeHRlbnNpb25zIHRoYXQgZG8gbm90IGhhdmUgYSBwcmVjZWRlbmNlIHNldCBnZXRcbnRoZSBwcmVjZWRlbmNlIG9mIHRoZSBuZWFyZXN0IHBhcmVudCB3aXRoIGEgcHJlY2VkZW5jZSwgb3JcbltgZGVmYXVsdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUHJlYy5kZWZhdWx0KSBpZiB0aGVyZSBpcyBubyBzdWNoIHBhcmVudC4gVGhlXG5maW5hbCBvcmRlcmluZyBvZiBleHRlbnNpb25zIGlzIGRldGVybWluZWQgYnkgZmlyc3Qgc29ydGluZyBieVxucHJlY2VkZW5jZSBhbmQgdGhlbiBieSBvcmRlciB3aXRoaW4gZWFjaCBwcmVjZWRlbmNlLlxuKi9cbmNvbnN0IFByZWMgPSB7XG4gICAgLyoqXG4gICAgVGhlIGhpZ2hlc3QgcHJlY2VkZW5jZSBsZXZlbCwgZm9yIGV4dGVuc2lvbnMgdGhhdCBzaG91bGQgZW5kIHVwXG4gICAgbmVhciB0aGUgc3RhcnQgb2YgdGhlIHByZWNlZGVuY2Ugb3JkZXJpbmcuXG4gICAgKi9cbiAgICBoaWdoZXN0OiAvKkBfX1BVUkVfXyovcHJlYyhQcmVjXy5oaWdoZXN0KSxcbiAgICAvKipcbiAgICBBIGhpZ2hlci10aGFuLWRlZmF1bHQgcHJlY2VkZW5jZSwgZm9yIGV4dGVuc2lvbnMgdGhhdCBzaG91bGRcbiAgICBjb21lIGJlZm9yZSB0aG9zZSB3aXRoIGRlZmF1bHQgcHJlY2VkZW5jZS5cbiAgICAqL1xuICAgIGhpZ2g6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmhpZ2gpLFxuICAgIC8qKlxuICAgIFRoZSBkZWZhdWx0IHByZWNlZGVuY2UsIHdoaWNoIGlzIGFsc28gdXNlZCBmb3IgZXh0ZW5zaW9uc1xuICAgIHdpdGhvdXQgYW4gZXhwbGljaXQgcHJlY2VkZW5jZS5cbiAgICAqL1xuICAgIGRlZmF1bHQ6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmRlZmF1bHQpLFxuICAgIC8qKlxuICAgIEEgbG93ZXItdGhhbi1kZWZhdWx0IHByZWNlZGVuY2UuXG4gICAgKi9cbiAgICBsb3c6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmxvdyksXG4gICAgLyoqXG4gICAgVGhlIGxvd2VzdCBwcmVjZWRlbmNlIGxldmVsLiBNZWFudCBmb3IgdGhpbmdzIHRoYXQgc2hvdWxkIGVuZCB1cFxuICAgIG5lYXIgdGhlIGVuZCBvZiB0aGUgZXh0ZW5zaW9uIG9yZGVyLlxuICAgICovXG4gICAgbG93ZXN0OiAvKkBfX1BVUkVfXyovcHJlYyhQcmVjXy5sb3dlc3QpXG59O1xuY2xhc3MgUHJlY0V4dGVuc2lvbiB7XG4gICAgY29uc3RydWN0b3IoaW5uZXIsIHByZWMpIHtcbiAgICAgICAgdGhpcy5pbm5lciA9IGlubmVyO1xuICAgICAgICB0aGlzLnByZWMgPSBwcmVjO1xuICAgIH1cbn1cbi8qKlxuRXh0ZW5zaW9uIGNvbXBhcnRtZW50cyBjYW4gYmUgdXNlZCB0byBtYWtlIGEgY29uZmlndXJhdGlvblxuZHluYW1pYy4gQnkgW3dyYXBwaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNvbXBhcnRtZW50Lm9mKSBwYXJ0IG9mIHlvdXJcbmNvbmZpZ3VyYXRpb24gaW4gYSBjb21wYXJ0bWVudCwgeW91IGNhbiBsYXRlclxuW3JlcGxhY2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ29tcGFydG1lbnQucmVjb25maWd1cmUpIHRoYXQgcGFydCB0aHJvdWdoIGFcbnRyYW5zYWN0aW9uLlxuKi9cbmNsYXNzIENvbXBhcnRtZW50IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjb21wYXJ0bWVudCB0byBhZGQgdG8geW91ciBbc3RhdGVcbiAgICBjb25maWd1cmF0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlQ29uZmlnLmV4dGVuc2lvbnMpLlxuICAgICovXG4gICAgb2YoZXh0KSB7IHJldHVybiBuZXcgQ29tcGFydG1lbnRJbnN0YW5jZSh0aGlzLCBleHQpOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIFtlZmZlY3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmVmZmVjdHMpIHRoYXRcbiAgICByZWNvbmZpZ3VyZXMgdGhpcyBjb21wYXJ0bWVudC5cbiAgICAqL1xuICAgIHJlY29uZmlndXJlKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIENvbXBhcnRtZW50LnJlY29uZmlndXJlLm9mKHsgY29tcGFydG1lbnQ6IHRoaXMsIGV4dGVuc2lvbjogY29udGVudCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjdXJyZW50IGNvbnRlbnQgb2YgdGhlIGNvbXBhcnRtZW50IGluIHRoZSBzdGF0ZSwgb3JcbiAgICBgdW5kZWZpbmVkYCBpZiBpdCBpc24ndCBwcmVzZW50LlxuICAgICovXG4gICAgZ2V0KHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5jb25maWcuY29tcGFydG1lbnRzLmdldCh0aGlzKTtcbiAgICB9XG59XG5jbGFzcyBDb21wYXJ0bWVudEluc3RhbmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wYXJ0bWVudCwgaW5uZXIpIHtcbiAgICAgICAgdGhpcy5jb21wYXJ0bWVudCA9IGNvbXBhcnRtZW50O1xuICAgICAgICB0aGlzLmlubmVyID0gaW5uZXI7XG4gICAgfVxufVxuY2xhc3MgQ29uZmlndXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoYmFzZSwgY29tcGFydG1lbnRzLCBkeW5hbWljU2xvdHMsIGFkZHJlc3MsIHN0YXRpY1ZhbHVlcywgZmFjZXRzKSB7XG4gICAgICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgICAgIHRoaXMuY29tcGFydG1lbnRzID0gY29tcGFydG1lbnRzO1xuICAgICAgICB0aGlzLmR5bmFtaWNTbG90cyA9IGR5bmFtaWNTbG90cztcbiAgICAgICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcbiAgICAgICAgdGhpcy5zdGF0aWNWYWx1ZXMgPSBzdGF0aWNWYWx1ZXM7XG4gICAgICAgIHRoaXMuZmFjZXRzID0gZmFjZXRzO1xuICAgICAgICB0aGlzLnN0YXR1c1RlbXBsYXRlID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnN0YXR1c1RlbXBsYXRlLmxlbmd0aCA8IGR5bmFtaWNTbG90cy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLnN0YXR1c1RlbXBsYXRlLnB1c2goMCAvKiBTbG90U3RhdHVzLlVucmVzb2x2ZWQgKi8pO1xuICAgIH1cbiAgICBzdGF0aWNGYWNldChmYWNldCkge1xuICAgICAgICBsZXQgYWRkciA9IHRoaXMuYWRkcmVzc1tmYWNldC5pZF07XG4gICAgICAgIHJldHVybiBhZGRyID09IG51bGwgPyBmYWNldC5kZWZhdWx0IDogdGhpcy5zdGF0aWNWYWx1ZXNbYWRkciA+PiAxXTtcbiAgICB9XG4gICAgc3RhdGljIHJlc29sdmUoYmFzZSwgY29tcGFydG1lbnRzLCBvbGRTdGF0ZSkge1xuICAgICAgICBsZXQgZmllbGRzID0gW107XG4gICAgICAgIGxldCBmYWNldHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBsZXQgbmV3Q29tcGFydG1lbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGxldCBleHQgb2YgZmxhdHRlbihiYXNlLCBjb21wYXJ0bWVudHMsIG5ld0NvbXBhcnRtZW50cykpIHtcbiAgICAgICAgICAgIGlmIChleHQgaW5zdGFuY2VvZiBTdGF0ZUZpZWxkKVxuICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoKGV4dCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgKGZhY2V0c1tleHQuZmFjZXQuaWRdIHx8IChmYWNldHNbZXh0LmZhY2V0LmlkXSA9IFtdKSkucHVzaChleHQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhZGRyZXNzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbGV0IHN0YXRpY1ZhbHVlcyA9IFtdO1xuICAgICAgICBsZXQgZHluYW1pY1Nsb3RzID0gW107XG4gICAgICAgIGZvciAobGV0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgICAgICAgYWRkcmVzc1tmaWVsZC5pZF0gPSBkeW5hbWljU2xvdHMubGVuZ3RoIDw8IDE7XG4gICAgICAgICAgICBkeW5hbWljU2xvdHMucHVzaChhID0+IGZpZWxkLnNsb3QoYSkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvbGRGYWNldHMgPSBvbGRTdGF0ZSA9PT0gbnVsbCB8fCBvbGRTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2xkU3RhdGUuY29uZmlnLmZhY2V0cztcbiAgICAgICAgZm9yIChsZXQgaWQgaW4gZmFjZXRzKSB7XG4gICAgICAgICAgICBsZXQgcHJvdmlkZXJzID0gZmFjZXRzW2lkXSwgZmFjZXQgPSBwcm92aWRlcnNbMF0uZmFjZXQ7XG4gICAgICAgICAgICBsZXQgb2xkUHJvdmlkZXJzID0gb2xkRmFjZXRzICYmIG9sZEZhY2V0c1tpZF0gfHwgW107XG4gICAgICAgICAgICBpZiAocHJvdmlkZXJzLmV2ZXJ5KHAgPT4gcC50eXBlID09IDAgLyogUHJvdmlkZXIuU3RhdGljICovKSkge1xuICAgICAgICAgICAgICAgIGFkZHJlc3NbZmFjZXQuaWRdID0gKHN0YXRpY1ZhbHVlcy5sZW5ndGggPDwgMSkgfCAxO1xuICAgICAgICAgICAgICAgIGlmIChzYW1lQXJyYXkob2xkUHJvdmlkZXJzLCBwcm92aWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY1ZhbHVlcy5wdXNoKG9sZFN0YXRlLmZhY2V0KGZhY2V0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBmYWNldC5jb21iaW5lKHByb3ZpZGVycy5tYXAocCA9PiBwLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY1ZhbHVlcy5wdXNoKG9sZFN0YXRlICYmIGZhY2V0LmNvbXBhcmUodmFsdWUsIG9sZFN0YXRlLmZhY2V0KGZhY2V0KSkgPyBvbGRTdGF0ZS5mYWNldChmYWNldCkgOiB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcCBvZiBwcm92aWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAudHlwZSA9PSAwIC8qIFByb3ZpZGVyLlN0YXRpYyAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc1twLmlkXSA9IChzdGF0aWNWYWx1ZXMubGVuZ3RoIDw8IDEpIHwgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY1ZhbHVlcy5wdXNoKHAudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc1twLmlkXSA9IGR5bmFtaWNTbG90cy5sZW5ndGggPDwgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR5bmFtaWNTbG90cy5wdXNoKGEgPT4gcC5keW5hbWljU2xvdChhKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkcmVzc1tmYWNldC5pZF0gPSBkeW5hbWljU2xvdHMubGVuZ3RoIDw8IDE7XG4gICAgICAgICAgICAgICAgZHluYW1pY1Nsb3RzLnB1c2goYSA9PiBkeW5hbWljRmFjZXRTbG90KGEsIGZhY2V0LCBwcm92aWRlcnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZHluYW1pYyA9IGR5bmFtaWNTbG90cy5tYXAoZiA9PiBmKGFkZHJlc3MpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb25maWd1cmF0aW9uKGJhc2UsIG5ld0NvbXBhcnRtZW50cywgZHluYW1pYywgYWRkcmVzcywgc3RhdGljVmFsdWVzLCBmYWNldHMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZsYXR0ZW4oZXh0ZW5zaW9uLCBjb21wYXJ0bWVudHMsIG5ld0NvbXBhcnRtZW50cykge1xuICAgIGxldCByZXN1bHQgPSBbW10sIFtdLCBbXSwgW10sIFtdXTtcbiAgICBsZXQgc2VlbiA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBpbm5lcihleHQsIHByZWMpIHtcbiAgICAgICAgbGV0IGtub3duID0gc2Vlbi5nZXQoZXh0KTtcbiAgICAgICAgaWYgKGtub3duICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChrbm93biA8PSBwcmVjKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IHJlc3VsdFtrbm93bl0uaW5kZXhPZihleHQpO1xuICAgICAgICAgICAgaWYgKGZvdW5kID4gLTEpXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tub3duXS5zcGxpY2UoZm91bmQsIDEpO1xuICAgICAgICAgICAgaWYgKGV4dCBpbnN0YW5jZW9mIENvbXBhcnRtZW50SW5zdGFuY2UpXG4gICAgICAgICAgICAgICAgbmV3Q29tcGFydG1lbnRzLmRlbGV0ZShleHQuY29tcGFydG1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHNlZW4uc2V0KGV4dCwgcHJlYyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV4dCkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGUgb2YgZXh0KVxuICAgICAgICAgICAgICAgIGlubmVyKGUsIHByZWMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4dCBpbnN0YW5jZW9mIENvbXBhcnRtZW50SW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGlmIChuZXdDb21wYXJ0bWVudHMuaGFzKGV4dC5jb21wYXJ0bWVudCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYER1cGxpY2F0ZSB1c2Ugb2YgY29tcGFydG1lbnQgaW4gZXh0ZW5zaW9uc2ApO1xuICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBjb21wYXJ0bWVudHMuZ2V0KGV4dC5jb21wYXJ0bWVudCkgfHwgZXh0LmlubmVyO1xuICAgICAgICAgICAgbmV3Q29tcGFydG1lbnRzLnNldChleHQuY29tcGFydG1lbnQsIGNvbnRlbnQpO1xuICAgICAgICAgICAgaW5uZXIoY29udGVudCwgcHJlYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXh0IGluc3RhbmNlb2YgUHJlY0V4dGVuc2lvbikge1xuICAgICAgICAgICAgaW5uZXIoZXh0LmlubmVyLCBleHQucHJlYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXh0IGluc3RhbmNlb2YgU3RhdGVGaWVsZCkge1xuICAgICAgICAgICAgcmVzdWx0W3ByZWNdLnB1c2goZXh0KTtcbiAgICAgICAgICAgIGlmIChleHQucHJvdmlkZXMpXG4gICAgICAgICAgICAgICAgaW5uZXIoZXh0LnByb3ZpZGVzLCBwcmVjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHQgaW5zdGFuY2VvZiBGYWNldFByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXN1bHRbcHJlY10ucHVzaChleHQpO1xuICAgICAgICAgICAgaWYgKGV4dC5mYWNldC5leHRlbnNpb25zKVxuICAgICAgICAgICAgICAgIGlubmVyKGV4dC5mYWNldC5leHRlbnNpb25zLCBQcmVjXy5kZWZhdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gZXh0LmV4dGVuc2lvbjtcbiAgICAgICAgICAgIGlmICghY29udGVudClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBleHRlbnNpb24gdmFsdWUgaW4gZXh0ZW5zaW9uIHNldCAoJHtleHR9KS4gVGhpcyBzb21ldGltZXMgaGFwcGVucyBiZWNhdXNlIG11bHRpcGxlIGluc3RhbmNlcyBvZiBAY29kZW1pcnJvci9zdGF0ZSBhcmUgbG9hZGVkLCBicmVha2luZyBpbnN0YW5jZW9mIGNoZWNrcy5gKTtcbiAgICAgICAgICAgIGlubmVyKGNvbnRlbnQsIHByZWMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlubmVyKGV4dGVuc2lvbiwgUHJlY18uZGVmYXVsdCk7XG4gICAgcmV0dXJuIHJlc3VsdC5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpKTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUFkZHIoc3RhdGUsIGFkZHIpIHtcbiAgICBpZiAoYWRkciAmIDEpXG4gICAgICAgIHJldHVybiAyIC8qIFNsb3RTdGF0dXMuQ29tcHV0ZWQgKi87XG4gICAgbGV0IGlkeCA9IGFkZHIgPj4gMTtcbiAgICBsZXQgc3RhdHVzID0gc3RhdGUuc3RhdHVzW2lkeF07XG4gICAgaWYgKHN0YXR1cyA9PSA0IC8qIFNsb3RTdGF0dXMuQ29tcHV0aW5nICovKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDeWNsaWMgZGVwZW5kZW5jeSBiZXR3ZWVuIGZpZWxkcyBhbmQvb3IgZmFjZXRzXCIpO1xuICAgIGlmIChzdGF0dXMgJiAyIC8qIFNsb3RTdGF0dXMuQ29tcHV0ZWQgKi8pXG4gICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgc3RhdGUuc3RhdHVzW2lkeF0gPSA0IC8qIFNsb3RTdGF0dXMuQ29tcHV0aW5nICovO1xuICAgIGxldCBjaGFuZ2VkID0gc3RhdGUuY29tcHV0ZVNsb3Qoc3RhdGUsIHN0YXRlLmNvbmZpZy5keW5hbWljU2xvdHNbaWR4XSk7XG4gICAgcmV0dXJuIHN0YXRlLnN0YXR1c1tpZHhdID0gMiAvKiBTbG90U3RhdHVzLkNvbXB1dGVkICovIHwgY2hhbmdlZDtcbn1cbmZ1bmN0aW9uIGdldEFkZHIoc3RhdGUsIGFkZHIpIHtcbiAgICByZXR1cm4gYWRkciAmIDEgPyBzdGF0ZS5jb25maWcuc3RhdGljVmFsdWVzW2FkZHIgPj4gMV0gOiBzdGF0ZS52YWx1ZXNbYWRkciA+PiAxXTtcbn1cblxuY29uc3QgbGFuZ3VhZ2VEYXRhID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnNvbWUodiA9PiB2KSxcbiAgICBzdGF0aWM6IHRydWVcbn0pO1xuY29uc3QgbGluZVNlcGFyYXRvciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMubGVuZ3RoID8gdmFsdWVzWzBdIDogdW5kZWZpbmVkLFxuICAgIHN0YXRpYzogdHJ1ZVxufSk7XG5jb25zdCBjaGFuZ2VGaWx0ZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCB0cmFuc2FjdGlvbkZpbHRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHRyYW5zYWN0aW9uRXh0ZW5kZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCByZWFkT25seSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMubGVuZ3RoID8gdmFsdWVzWzBdIDogZmFsc2Vcbn0pO1xuXG4vKipcbkFubm90YXRpb25zIGFyZSB0YWdnZWQgdmFsdWVzIHRoYXQgYXJlIHVzZWQgdG8gYWRkIG1ldGFkYXRhIHRvXG50cmFuc2FjdGlvbnMgaW4gYW4gZXh0ZW5zaWJsZSB3YXkuIFRoZXkgc2hvdWxkIGJlIHVzZWQgdG8gbW9kZWxcbnRoaW5ncyB0aGF0IGVmZmVjdCB0aGUgZW50aXJlIHRyYW5zYWN0aW9uIChzdWNoIGFzIGl0cyBbdGltZVxuc3RhbXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25edGltZSkgb3IgaW5mb3JtYXRpb24gYWJvdXQgaXRzXG5bb3JpZ2luXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uXnVzZXJFdmVudCkpLiBGb3IgZWZmZWN0cyB0aGF0IGhhcHBlblxuX2Fsb25nc2lkZV8gdGhlIG90aGVyIGNoYW5nZXMgbWFkZSBieSB0aGUgdHJhbnNhY3Rpb24sIFtzdGF0ZVxuZWZmZWN0c10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdCkgYXJlIG1vcmUgYXBwcm9wcmlhdGUuXG4qL1xuY2xhc3MgQW5ub3RhdGlvbiB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgYW5ub3RhdGlvbiB0eXBlLlxuICAgICovXG4gICAgdHlwZSwgXG4gICAgLyoqXG4gICAgVGhlIHZhbHVlIG9mIHRoaXMgYW5ub3RhdGlvbi5cbiAgICAqL1xuICAgIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgbmV3IHR5cGUgb2YgYW5ub3RhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoKSB7IHJldHVybiBuZXcgQW5ub3RhdGlvblR5cGUoKTsgfVxufVxuLyoqXG5NYXJrZXIgdGhhdCBpZGVudGlmaWVzIGEgdHlwZSBvZiBbYW5ub3RhdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Bbm5vdGF0aW9uKS5cbiovXG5jbGFzcyBBbm5vdGF0aW9uVHlwZSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgYW5ub3RhdGlvbi5cbiAgICAqL1xuICAgIG9mKHZhbHVlKSB7IHJldHVybiBuZXcgQW5ub3RhdGlvbih0aGlzLCB2YWx1ZSk7IH1cbn1cbi8qKlxuUmVwcmVzZW50YXRpb24gb2YgYSB0eXBlIG9mIHN0YXRlIGVmZmVjdC4gRGVmaW5lZCB3aXRoXG5bYFN0YXRlRWZmZWN0LmRlZmluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3ReZGVmaW5lKS5cbiovXG5jbGFzcyBTdGF0ZUVmZmVjdFR5cGUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gVGhlIGBhbnlgIHR5cGVzIGluIHRoZXNlIGZ1bmN0aW9uIHR5cGVzIGFyZSB0aGVyZSB0byB3b3JrXG4gICAgLy8gYXJvdW5kIFR5cGVTY3JpcHQgaXNzdWUgIzM3NjMxLCB3aGVyZSB0aGUgdHlwZSBndWFyZCBvblxuICAgIC8vIGBTdGF0ZUVmZmVjdC5pc2AgbXlzdGVyaW91c2x5IHN0b3BzIHdvcmtpbmcgd2hlbiB0aGVzZSBwcm9wZXJseVxuICAgIC8vIGhhdmUgdHlwZSBgVmFsdWVgLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWFwKSB7XG4gICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBbc3RhdGUgZWZmZWN0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0KSBpbnN0YW5jZSBvZiB0aGlzXG4gICAgdHlwZS5cbiAgICAqL1xuICAgIG9mKHZhbHVlKSB7IHJldHVybiBuZXcgU3RhdGVFZmZlY3QodGhpcywgdmFsdWUpOyB9XG59XG4vKipcblN0YXRlIGVmZmVjdHMgY2FuIGJlIHVzZWQgdG8gcmVwcmVzZW50IGFkZGl0aW9uYWwgZWZmZWN0c1xuYXNzb2NpYXRlZCB3aXRoIGEgW3RyYW5zYWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLmVmZmVjdHMpLiBUaGV5XG5hcmUgb2Z0ZW4gdXNlZnVsIHRvIG1vZGVsIGNoYW5nZXMgdG8gY3VzdG9tIFtzdGF0ZVxuZmllbGRzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRmllbGQpLCB3aGVuIHRob3NlIGNoYW5nZXMgYXJlbid0IGltcGxpY2l0IGluXG5kb2N1bWVudCBvciBzZWxlY3Rpb24gY2hhbmdlcy5cbiovXG5jbGFzcyBTdGF0ZUVmZmVjdCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHR5cGUsIFxuICAgIC8qKlxuICAgIFRoZSB2YWx1ZSBvZiB0aGlzIGVmZmVjdC5cbiAgICAqL1xuICAgIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIHRoaXMgZWZmZWN0IHRocm91Z2ggYSBwb3NpdGlvbiBtYXBwaW5nLiBXaWxsIHJldHVyblxuICAgIGB1bmRlZmluZWRgIHdoZW4gdGhhdCBlbmRzIHVwIGRlbGV0aW5nIHRoZSBlZmZlY3QuXG4gICAgKi9cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgbWFwcGVkID0gdGhpcy50eXBlLm1hcCh0aGlzLnZhbHVlLCBtYXBwaW5nKTtcbiAgICAgICAgcmV0dXJuIG1hcHBlZCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogbWFwcGVkID09IHRoaXMudmFsdWUgPyB0aGlzIDogbmV3IFN0YXRlRWZmZWN0KHRoaXMudHlwZSwgbWFwcGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhpcyBlZmZlY3Qgb2JqZWN0IGlzIG9mIGEgZ2l2ZW5cbiAgICBbdHlwZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdFR5cGUpLlxuICAgICovXG4gICAgaXModHlwZSkgeyByZXR1cm4gdGhpcy50eXBlID09IHR5cGU7IH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBuZXcgZWZmZWN0IHR5cGUuIFRoZSB0eXBlIHBhcmFtZXRlciBpbmRpY2F0ZXMgdGhlIHR5cGVcbiAgICBvZiB2YWx1ZXMgdGhhdCBoaXMgZWZmZWN0IGhvbGRzLiBJdCBzaG91bGQgYmUgYSB0eXBlIHRoYXRcbiAgICBkb2Vzbid0IGluY2x1ZGUgYHVuZGVmaW5lZGAsIHNpbmNlIHRoYXQgaXMgdXNlZCBpblxuICAgIFttYXBwaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0Lm1hcCkgdG8gaW5kaWNhdGUgdGhhdCBhbiBlZmZlY3QgaXNcbiAgICByZW1vdmVkLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShzcGVjID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGF0ZUVmZmVjdFR5cGUoc3BlYy5tYXAgfHwgKHYgPT4gdikpO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgYW4gYXJyYXkgb2YgZWZmZWN0cyB0aHJvdWdoIGEgY2hhbmdlIHNldC5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXBFZmZlY3RzKGVmZmVjdHMsIG1hcHBpbmcpIHtcbiAgICAgICAgaWYgKCFlZmZlY3RzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBlZmZlY3RzO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICBsZXQgbWFwcGVkID0gZWZmZWN0Lm1hcChtYXBwaW5nKTtcbiAgICAgICAgICAgIGlmIChtYXBwZWQpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobWFwcGVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8qKlxuVGhpcyBlZmZlY3QgY2FuIGJlIHVzZWQgdG8gcmVjb25maWd1cmUgdGhlIHJvb3QgZXh0ZW5zaW9ucyBvZlxudGhlIGVkaXRvci4gRG9pbmcgdGhpcyB3aWxsIGRpc2NhcmQgYW55IGV4dGVuc2lvbnNcblthcHBlbmRlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdF5hcHBlbmRDb25maWcpLCBidXQgZG9lcyBub3QgcmVzZXRcbnRoZSBjb250ZW50IG9mIFtyZWNvbmZpZ3VyZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ29tcGFydG1lbnQucmVjb25maWd1cmUpXG5jb21wYXJ0bWVudHMuXG4qL1xuU3RhdGVFZmZlY3QucmVjb25maWd1cmUgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG4vKipcbkFwcGVuZCBleHRlbnNpb25zIHRvIHRoZSB0b3AtbGV2ZWwgY29uZmlndXJhdGlvbiBvZiB0aGUgZWRpdG9yLlxuKi9cblN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbi8qKlxuQ2hhbmdlcyB0byB0aGUgZWRpdG9yIHN0YXRlIGFyZSBncm91cGVkIGludG8gdHJhbnNhY3Rpb25zLlxuVHlwaWNhbGx5LCBhIHVzZXIgYWN0aW9uIGNyZWF0ZXMgYSBzaW5nbGUgdHJhbnNhY3Rpb24sIHdoaWNoIG1heVxuY29udGFpbiBhbnkgbnVtYmVyIG9mIGRvY3VtZW50IGNoYW5nZXMsIG1heSBjaGFuZ2UgdGhlIHNlbGVjdGlvbixcbm9yIGhhdmUgb3RoZXIgZWZmZWN0cy4gQ3JlYXRlIGEgdHJhbnNhY3Rpb24gYnkgY2FsbGluZ1xuW2BFZGl0b3JTdGF0ZS51cGRhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnVwZGF0ZSksIG9yIGltbWVkaWF0ZWx5XG5kaXNwYXRjaCBvbmUgYnkgY2FsbGluZ1xuW2BFZGl0b3JWaWV3LmRpc3BhdGNoYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZGlzcGF0Y2gpLlxuKi9cbmNsYXNzIFRyYW5zYWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhdGUgZnJvbSB3aGljaCB0aGUgdHJhbnNhY3Rpb24gc3RhcnRzLlxuICAgICovXG4gICAgc3RhcnRTdGF0ZSwgXG4gICAgLyoqXG4gICAgVGhlIGRvY3VtZW50IGNoYW5nZXMgbWFkZSBieSB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgY2hhbmdlcywgXG4gICAgLyoqXG4gICAgVGhlIHNlbGVjdGlvbiBzZXQgYnkgdGhpcyB0cmFuc2FjdGlvbiwgb3IgdW5kZWZpbmVkIGlmIGl0XG4gICAgZG9lc24ndCBleHBsaWNpdGx5IHNldCBhIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIHNlbGVjdGlvbiwgXG4gICAgLyoqXG4gICAgVGhlIGVmZmVjdHMgYWRkZWQgdG8gdGhlIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgZWZmZWN0cywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhbm5vdGF0aW9ucywgXG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgc2VsZWN0aW9uIHNob3VsZCBiZSBzY3JvbGxlZCBpbnRvIHZpZXcgYWZ0ZXIgdGhpc1xuICAgIHRyYW5zYWN0aW9uIGlzIGRpc3BhdGNoZWQuXG4gICAgKi9cbiAgICBzY3JvbGxJbnRvVmlldykge1xuICAgICAgICB0aGlzLnN0YXJ0U3RhdGUgPSBzdGFydFN0YXRlO1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBjaGFuZ2VzO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5lZmZlY3RzID0gZWZmZWN0cztcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9ucyA9IGFubm90YXRpb25zO1xuICAgICAgICB0aGlzLnNjcm9sbEludG9WaWV3ID0gc2Nyb2xsSW50b1ZpZXc7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZG9jID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IG51bGw7XG4gICAgICAgIGlmIChzZWxlY3Rpb24pXG4gICAgICAgICAgICBjaGVja1NlbGVjdGlvbihzZWxlY3Rpb24sIGNoYW5nZXMubmV3TGVuZ3RoKTtcbiAgICAgICAgaWYgKCFhbm5vdGF0aW9ucy5zb21lKChhKSA9PiBhLnR5cGUgPT0gVHJhbnNhY3Rpb24udGltZSkpXG4gICAgICAgICAgICB0aGlzLmFubm90YXRpb25zID0gYW5ub3RhdGlvbnMuY29uY2F0KFRyYW5zYWN0aW9uLnRpbWUub2YoRGF0ZS5ub3coKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoc3RhcnRTdGF0ZSwgY2hhbmdlcywgc2VsZWN0aW9uLCBlZmZlY3RzLCBhbm5vdGF0aW9ucywgc2Nyb2xsSW50b1ZpZXcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbihzdGFydFN0YXRlLCBjaGFuZ2VzLCBzZWxlY3Rpb24sIGVmZmVjdHMsIGFubm90YXRpb25zLCBzY3JvbGxJbnRvVmlldyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBuZXcgZG9jdW1lbnQgcHJvZHVjZWQgYnkgdGhlIHRyYW5zYWN0aW9uLiBDb250cmFyeSB0b1xuICAgIFtgLnN0YXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5zdGF0ZSlgLmRvY2AsIGFjY2Vzc2luZyB0aGlzIHdvbid0XG4gICAgZm9yY2UgdGhlIGVudGlyZSBuZXcgc3RhdGUgdG8gYmUgY29tcHV0ZWQgcmlnaHQgYXdheSwgc28gaXQgaXNcbiAgICByZWNvbW1lbmRlZCB0aGF0IFt0cmFuc2FjdGlvblxuICAgIGZpbHRlcnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedHJhbnNhY3Rpb25GaWx0ZXIpIHVzZSB0aGlzIGdldHRlclxuICAgIHdoZW4gdGhleSBuZWVkIHRvIGxvb2sgYXQgdGhlIG5ldyBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldCBuZXdEb2MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kb2MgfHwgKHRoaXMuX2RvYyA9IHRoaXMuY2hhbmdlcy5hcHBseSh0aGlzLnN0YXJ0U3RhdGUuZG9jKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBuZXcgc2VsZWN0aW9uIHByb2R1Y2VkIGJ5IHRoZSB0cmFuc2FjdGlvbi4gSWZcbiAgICBbYHRoaXMuc2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5zZWxlY3Rpb24pIGlzIHVuZGVmaW5lZCxcbiAgICB0aGlzIHdpbGwgW21hcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTZWxlY3Rpb24ubWFwKSB0aGUgc3RhcnQgc3RhdGUnc1xuICAgIGN1cnJlbnQgc2VsZWN0aW9uIHRocm91Z2ggdGhlIGNoYW5nZXMgbWFkZSBieSB0aGUgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBnZXQgbmV3U2VsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24gfHwgdGhpcy5zdGFydFN0YXRlLnNlbGVjdGlvbi5tYXAodGhpcy5jaGFuZ2VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG5ldyBzdGF0ZSBjcmVhdGVkIGJ5IHRoZSB0cmFuc2FjdGlvbi4gQ29tcHV0ZWQgb24gZGVtYW5kXG4gICAgKGJ1dCByZXRhaW5lZCBmb3Igc3Vic2VxdWVudCBhY2Nlc3MpLCBzbyBpdCBpcyByZWNvbW1lbmRlZCBub3QgdG9cbiAgICBhY2Nlc3MgaXQgaW4gW3RyYW5zYWN0aW9uXG4gICAgZmlsdGVyc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50cmFuc2FjdGlvbkZpbHRlcikgd2hlbiBwb3NzaWJsZS5cbiAgICAqL1xuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zdGF0ZSlcbiAgICAgICAgICAgIHRoaXMuc3RhcnRTdGF0ZS5hcHBseVRyYW5zYWN0aW9uKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIGFubm90YXRpb24gdHlwZSwgaWYgYW55LlxuICAgICovXG4gICAgYW5ub3RhdGlvbih0eXBlKSB7XG4gICAgICAgIGZvciAobGV0IGFubiBvZiB0aGlzLmFubm90YXRpb25zKVxuICAgICAgICAgICAgaWYgKGFubi50eXBlID09IHR5cGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFubi52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRyYW5zYWN0aW9uIGNoYW5nZWQgdGhlIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IGRvY0NoYW5nZWQoKSB7IHJldHVybiAhdGhpcy5jaGFuZ2VzLmVtcHR5OyB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyB0cmFuc2FjdGlvbiByZWNvbmZpZ3VyZXMgdGhlIHN0YXRlXG4gICAgKHRocm91Z2ggYSBbY29uZmlndXJhdGlvbiBjb21wYXJ0bWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Db21wYXJ0bWVudCkgb3JcbiAgICB3aXRoIGEgdG9wLWxldmVsIGNvbmZpZ3VyYXRpb25cbiAgICBbZWZmZWN0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0XnJlY29uZmlndXJlKS5cbiAgICAqL1xuICAgIGdldCByZWNvbmZpZ3VyZWQoKSB7IHJldHVybiB0aGlzLnN0YXJ0U3RhdGUuY29uZmlnICE9IHRoaXMuc3RhdGUuY29uZmlnOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2FjdGlvbiBoYXMgYSBbdXNlclxuICAgIGV2ZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uXnVzZXJFdmVudCkgYW5ub3RhdGlvbiB0aGF0IGlzIGVxdWFsIHRvXG4gICAgb3IgbW9yZSBzcGVjaWZpYyB0aGFuIGBldmVudGAuIEZvciBleGFtcGxlLCBpZiB0aGUgdHJhbnNhY3Rpb25cbiAgICBoYXMgYFwic2VsZWN0LnBvaW50ZXJcImAgYXMgdXNlciBldmVudCwgYFwic2VsZWN0XCJgIGFuZFxuICAgIGBcInNlbGVjdC5wb2ludGVyXCJgIHdpbGwgbWF0Y2ggaXQuXG4gICAgKi9cbiAgICBpc1VzZXJFdmVudChldmVudCkge1xuICAgICAgICBsZXQgZSA9IHRoaXMuYW5ub3RhdGlvbihUcmFuc2FjdGlvbi51c2VyRXZlbnQpO1xuICAgICAgICByZXR1cm4gISEoZSAmJiAoZSA9PSBldmVudCB8fCBlLmxlbmd0aCA+IGV2ZW50Lmxlbmd0aCAmJiBlLnNsaWNlKDAsIGV2ZW50Lmxlbmd0aCkgPT0gZXZlbnQgJiYgZVtldmVudC5sZW5ndGhdID09IFwiLlwiKSk7XG4gICAgfVxufVxuLyoqXG5Bbm5vdGF0aW9uIHVzZWQgdG8gc3RvcmUgdHJhbnNhY3Rpb24gdGltZXN0YW1wcy4gQXV0b21hdGljYWxseVxuYWRkZWQgdG8gZXZlcnkgdHJhbnNhY3Rpb24sIGhvbGRpbmcgYERhdGUubm93KClgLlxuKi9cblRyYW5zYWN0aW9uLnRpbWUgPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbi8qKlxuQW5ub3RhdGlvbiB1c2VkIHRvIGFzc29jaWF0ZSBhIHRyYW5zYWN0aW9uIHdpdGggYSB1c2VyIGludGVyZmFjZVxuZXZlbnQuIEhvbGRzIGEgc3RyaW5nIGlkZW50aWZ5aW5nIHRoZSBldmVudCwgdXNpbmcgYVxuZG90LXNlcGFyYXRlZCBmb3JtYXQgdG8gc3VwcG9ydCBhdHRhY2hpbmcgbW9yZSBzcGVjaWZpY1xuaW5mb3JtYXRpb24uIFRoZSBldmVudHMgdXNlZCBieSB0aGUgY29yZSBsaWJyYXJpZXMgYXJlOlxuXG4gLSBgXCJpbnB1dFwiYCB3aGVuIGNvbnRlbnQgaXMgZW50ZXJlZFxuICAgLSBgXCJpbnB1dC50eXBlXCJgIGZvciB0eXBlZCBpbnB1dFxuICAgICAtIGBcImlucHV0LnR5cGUuY29tcG9zZVwiYCBmb3IgY29tcG9zaXRpb25cbiAgIC0gYFwiaW5wdXQucGFzdGVcImAgZm9yIHBhc3RlZCBpbnB1dFxuICAgLSBgXCJpbnB1dC5kcm9wXCJgIHdoZW4gYWRkaW5nIGNvbnRlbnQgd2l0aCBkcmFnLWFuZC1kcm9wXG4gICAtIGBcImlucHV0LmNvbXBsZXRlXCJgIHdoZW4gYXV0b2NvbXBsZXRpbmdcbiAtIGBcImRlbGV0ZVwiYCB3aGVuIHRoZSB1c2VyIGRlbGV0ZXMgY29udGVudFxuICAgLSBgXCJkZWxldGUuc2VsZWN0aW9uXCJgIHdoZW4gZGVsZXRpbmcgdGhlIHNlbGVjdGlvblxuICAgLSBgXCJkZWxldGUuZm9yd2FyZFwiYCB3aGVuIGRlbGV0aW5nIGZvcndhcmQgZnJvbSB0aGUgc2VsZWN0aW9uXG4gICAtIGBcImRlbGV0ZS5iYWNrd2FyZFwiYCB3aGVuIGRlbGV0aW5nIGJhY2t3YXJkIGZyb20gdGhlIHNlbGVjdGlvblxuICAgLSBgXCJkZWxldGUuY3V0XCJgIHdoZW4gY3V0dGluZyB0byB0aGUgY2xpcGJvYXJkXG4gLSBgXCJtb3ZlXCJgIHdoZW4gY29udGVudCBpcyBtb3ZlZFxuICAgLSBgXCJtb3ZlLmRyb3BcImAgd2hlbiBjb250ZW50IGlzIG1vdmVkIHdpdGhpbiB0aGUgZWRpdG9yIHRocm91Z2ggZHJhZy1hbmQtZHJvcFxuIC0gYFwic2VsZWN0XCJgIHdoZW4gZXhwbGljaXRseSBjaGFuZ2luZyB0aGUgc2VsZWN0aW9uXG4gICAtIGBcInNlbGVjdC5wb2ludGVyXCJgIHdoZW4gc2VsZWN0aW5nIHdpdGggYSBtb3VzZSBvciBvdGhlciBwb2ludGluZyBkZXZpY2VcbiAtIGBcInVuZG9cImAgYW5kIGBcInJlZG9cImAgZm9yIGhpc3RvcnkgYWN0aW9uc1xuXG5Vc2UgW2Bpc1VzZXJFdmVudGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uaXNVc2VyRXZlbnQpIHRvIGNoZWNrXG53aGV0aGVyIHRoZSBhbm5vdGF0aW9uIG1hdGNoZXMgYSBnaXZlbiBldmVudC5cbiovXG5UcmFuc2FjdGlvbi51c2VyRXZlbnQgPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbi8qKlxuQW5ub3RhdGlvbiBpbmRpY2F0aW5nIHdoZXRoZXIgYSB0cmFuc2FjdGlvbiBzaG91bGQgYmUgYWRkZWQgdG9cbnRoZSB1bmRvIGhpc3Rvcnkgb3Igbm90LlxuKi9cblRyYW5zYWN0aW9uLmFkZFRvSGlzdG9yeSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5Bbm5vdGF0aW9uIGluZGljYXRpbmcgKHdoZW4gcHJlc2VudCBhbmQgdHJ1ZSkgdGhhdCBhIHRyYW5zYWN0aW9uXG5yZXByZXNlbnRzIGEgY2hhbmdlIG1hZGUgYnkgc29tZSBvdGhlciBhY3Rvciwgbm90IHRoZSB1c2VyLiBUaGlzXG5pcyB1c2VkLCBmb3IgZXhhbXBsZSwgdG8gdGFnIG90aGVyIHBlb3BsZSdzIGNoYW5nZXMgaW5cbmNvbGxhYm9yYXRpdmUgZWRpdGluZy5cbiovXG5UcmFuc2FjdGlvbi5yZW1vdGUgPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbmZ1bmN0aW9uIGpvaW5SYW5nZXMoYSwgYikge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpQSA9IDAsIGlCID0gMDs7KSB7XG4gICAgICAgIGxldCBmcm9tLCB0bztcbiAgICAgICAgaWYgKGlBIDwgYS5sZW5ndGggJiYgKGlCID09IGIubGVuZ3RoIHx8IGJbaUJdID49IGFbaUFdKSkge1xuICAgICAgICAgICAgZnJvbSA9IGFbaUErK107XG4gICAgICAgICAgICB0byA9IGFbaUErK107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaUIgPCBiLmxlbmd0aCkge1xuICAgICAgICAgICAgZnJvbSA9IGJbaUIrK107XG4gICAgICAgICAgICB0byA9IGJbaUIrK107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoIHx8IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPCBmcm9tKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJvbSwgdG8pO1xuICAgICAgICBlbHNlIGlmIChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdIDwgdG8pXG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gdG87XG4gICAgfVxufVxuZnVuY3Rpb24gbWVyZ2VUcmFuc2FjdGlvbihhLCBiLCBzZXF1ZW50aWFsKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBtYXBGb3JBLCBtYXBGb3JCLCBjaGFuZ2VzO1xuICAgIGlmIChzZXF1ZW50aWFsKSB7XG4gICAgICAgIG1hcEZvckEgPSBiLmNoYW5nZXM7XG4gICAgICAgIG1hcEZvckIgPSBDaGFuZ2VTZXQuZW1wdHkoYi5jaGFuZ2VzLmxlbmd0aCk7XG4gICAgICAgIGNoYW5nZXMgPSBhLmNoYW5nZXMuY29tcG9zZShiLmNoYW5nZXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWFwRm9yQSA9IGIuY2hhbmdlcy5tYXAoYS5jaGFuZ2VzKTtcbiAgICAgICAgbWFwRm9yQiA9IGEuY2hhbmdlcy5tYXBEZXNjKGIuY2hhbmdlcywgdHJ1ZSk7XG4gICAgICAgIGNoYW5nZXMgPSBhLmNoYW5nZXMuY29tcG9zZShtYXBGb3JBKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgc2VsZWN0aW9uOiBiLnNlbGVjdGlvbiA/IGIuc2VsZWN0aW9uLm1hcChtYXBGb3JCKSA6IChfYSA9IGEuc2VsZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKG1hcEZvckEpLFxuICAgICAgICBlZmZlY3RzOiBTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGEuZWZmZWN0cywgbWFwRm9yQSkuY29uY2F0KFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoYi5lZmZlY3RzLCBtYXBGb3JCKSksXG4gICAgICAgIGFubm90YXRpb25zOiBhLmFubm90YXRpb25zLmxlbmd0aCA/IGEuYW5ub3RhdGlvbnMuY29uY2F0KGIuYW5ub3RhdGlvbnMpIDogYi5hbm5vdGF0aW9ucyxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IGEuc2Nyb2xsSW50b1ZpZXcgfHwgYi5zY3JvbGxJbnRvVmlld1xuICAgIH07XG59XG5mdW5jdGlvbiByZXNvbHZlVHJhbnNhY3Rpb25Jbm5lcihzdGF0ZSwgc3BlYywgZG9jU2l6ZSkge1xuICAgIGxldCBzZWwgPSBzcGVjLnNlbGVjdGlvbiwgYW5ub3RhdGlvbnMgPSBhc0FycmF5KHNwZWMuYW5ub3RhdGlvbnMpO1xuICAgIGlmIChzcGVjLnVzZXJFdmVudClcbiAgICAgICAgYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucy5jb25jYXQoVHJhbnNhY3Rpb24udXNlckV2ZW50Lm9mKHNwZWMudXNlckV2ZW50KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hhbmdlczogc3BlYy5jaGFuZ2VzIGluc3RhbmNlb2YgQ2hhbmdlU2V0ID8gc3BlYy5jaGFuZ2VzXG4gICAgICAgICAgICA6IENoYW5nZVNldC5vZihzcGVjLmNoYW5nZXMgfHwgW10sIGRvY1NpemUsIHN0YXRlLmZhY2V0KGxpbmVTZXBhcmF0b3IpKSxcbiAgICAgICAgc2VsZWN0aW9uOiBzZWwgJiYgKHNlbCBpbnN0YW5jZW9mIEVkaXRvclNlbGVjdGlvbiA/IHNlbCA6IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoc2VsLmFuY2hvciwgc2VsLmhlYWQpKSxcbiAgICAgICAgZWZmZWN0czogYXNBcnJheShzcGVjLmVmZmVjdHMpLFxuICAgICAgICBhbm5vdGF0aW9ucyxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6ICEhc3BlYy5zY3JvbGxJbnRvVmlld1xuICAgIH07XG59XG5mdW5jdGlvbiByZXNvbHZlVHJhbnNhY3Rpb24oc3RhdGUsIHNwZWNzLCBmaWx0ZXIpIHtcbiAgICBsZXQgcyA9IHJlc29sdmVUcmFuc2FjdGlvbklubmVyKHN0YXRlLCBzcGVjcy5sZW5ndGggPyBzcGVjc1swXSA6IHt9LCBzdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICBpZiAoc3BlY3MubGVuZ3RoICYmIHNwZWNzWzBdLmZpbHRlciA9PT0gZmFsc2UpXG4gICAgICAgIGZpbHRlciA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3BlY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNwZWNzW2ldLmZpbHRlciA9PT0gZmFsc2UpXG4gICAgICAgICAgICBmaWx0ZXIgPSBmYWxzZTtcbiAgICAgICAgbGV0IHNlcSA9ICEhc3BlY3NbaV0uc2VxdWVudGlhbDtcbiAgICAgICAgcyA9IG1lcmdlVHJhbnNhY3Rpb24ocywgcmVzb2x2ZVRyYW5zYWN0aW9uSW5uZXIoc3RhdGUsIHNwZWNzW2ldLCBzZXEgPyBzLmNoYW5nZXMubmV3TGVuZ3RoIDogc3RhdGUuZG9jLmxlbmd0aCksIHNlcSk7XG4gICAgfVxuICAgIGxldCB0ciA9IFRyYW5zYWN0aW9uLmNyZWF0ZShzdGF0ZSwgcy5jaGFuZ2VzLCBzLnNlbGVjdGlvbiwgcy5lZmZlY3RzLCBzLmFubm90YXRpb25zLCBzLnNjcm9sbEludG9WaWV3KTtcbiAgICByZXR1cm4gZXh0ZW5kVHJhbnNhY3Rpb24oZmlsdGVyID8gZmlsdGVyVHJhbnNhY3Rpb24odHIpIDogdHIpO1xufVxuLy8gRmluaXNoIGEgdHJhbnNhY3Rpb24gYnkgYXBwbHlpbmcgZmlsdGVycyBpZiBuZWNlc3NhcnkuXG5mdW5jdGlvbiBmaWx0ZXJUcmFuc2FjdGlvbih0cikge1xuICAgIGxldCBzdGF0ZSA9IHRyLnN0YXJ0U3RhdGU7XG4gICAgLy8gQ2hhbmdlIGZpbHRlcnNcbiAgICBsZXQgcmVzdWx0ID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBmaWx0ZXIgb2Ygc3RhdGUuZmFjZXQoY2hhbmdlRmlsdGVyKSkge1xuICAgICAgICBsZXQgdmFsdWUgPSBmaWx0ZXIodHIpO1xuICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gdHJ1ZSA/IHZhbHVlIDogam9pblJhbmdlcyhyZXN1bHQsIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCAhPT0gdHJ1ZSkge1xuICAgICAgICBsZXQgY2hhbmdlcywgYmFjaztcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJhY2sgPSB0ci5jaGFuZ2VzLmludmVydGVkRGVzYztcbiAgICAgICAgICAgIGNoYW5nZXMgPSBDaGFuZ2VTZXQuZW1wdHkoc3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZmlsdGVyZWQgPSB0ci5jaGFuZ2VzLmZpbHRlcihyZXN1bHQpO1xuICAgICAgICAgICAgY2hhbmdlcyA9IGZpbHRlcmVkLmNoYW5nZXM7XG4gICAgICAgICAgICBiYWNrID0gZmlsdGVyZWQuZmlsdGVyZWQubWFwRGVzYyhmaWx0ZXJlZC5jaGFuZ2VzKS5pbnZlcnRlZERlc2M7XG4gICAgICAgIH1cbiAgICAgICAgdHIgPSBUcmFuc2FjdGlvbi5jcmVhdGUoc3RhdGUsIGNoYW5nZXMsIHRyLnNlbGVjdGlvbiAmJiB0ci5zZWxlY3Rpb24ubWFwKGJhY2spLCBTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKHRyLmVmZmVjdHMsIGJhY2spLCB0ci5hbm5vdGF0aW9ucywgdHIuc2Nyb2xsSW50b1ZpZXcpO1xuICAgIH1cbiAgICAvLyBUcmFuc2FjdGlvbiBmaWx0ZXJzXG4gICAgbGV0IGZpbHRlcnMgPSBzdGF0ZS5mYWNldCh0cmFuc2FjdGlvbkZpbHRlcik7XG4gICAgZm9yIChsZXQgaSA9IGZpbHRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IGZpbHRlcmVkID0gZmlsdGVyc1tpXSh0cik7XG4gICAgICAgIGlmIChmaWx0ZXJlZCBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgdHIgPSBmaWx0ZXJlZDtcbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXJlZCkgJiYgZmlsdGVyZWQubGVuZ3RoID09IDEgJiYgZmlsdGVyZWRbMF0gaW5zdGFuY2VvZiBUcmFuc2FjdGlvbilcbiAgICAgICAgICAgIHRyID0gZmlsdGVyZWRbMF07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRyID0gcmVzb2x2ZVRyYW5zYWN0aW9uKHN0YXRlLCBhc0FycmF5KGZpbHRlcmVkKSwgZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdHI7XG59XG5mdW5jdGlvbiBleHRlbmRUcmFuc2FjdGlvbih0cikge1xuICAgIGxldCBzdGF0ZSA9IHRyLnN0YXJ0U3RhdGUsIGV4dGVuZGVycyA9IHN0YXRlLmZhY2V0KHRyYW5zYWN0aW9uRXh0ZW5kZXIpLCBzcGVjID0gdHI7XG4gICAgZm9yIChsZXQgaSA9IGV4dGVuZGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgZXh0ZW5zaW9uID0gZXh0ZW5kZXJzW2ldKHRyKTtcbiAgICAgICAgaWYgKGV4dGVuc2lvbiAmJiBPYmplY3Qua2V5cyhleHRlbnNpb24pLmxlbmd0aClcbiAgICAgICAgICAgIHNwZWMgPSBtZXJnZVRyYW5zYWN0aW9uKHNwZWMsIHJlc29sdmVUcmFuc2FjdGlvbklubmVyKHN0YXRlLCBleHRlbnNpb24sIHRyLmNoYW5nZXMubmV3TGVuZ3RoKSwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiBzcGVjID09IHRyID8gdHIgOiBUcmFuc2FjdGlvbi5jcmVhdGUoc3RhdGUsIHRyLmNoYW5nZXMsIHRyLnNlbGVjdGlvbiwgc3BlYy5lZmZlY3RzLCBzcGVjLmFubm90YXRpb25zLCBzcGVjLnNjcm9sbEludG9WaWV3KTtcbn1cbmNvbnN0IG5vbmUgPSBbXTtcbmZ1bmN0aW9uIGFzQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IG5vbmUgOiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbn1cblxuLyoqXG5UaGUgY2F0ZWdvcmllcyBwcm9kdWNlZCBieSBhIFtjaGFyYWN0ZXJcbmNhdGVnb3JpemVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYXJDYXRlZ29yaXplcikuIFRoZXNlIGFyZSB1c2VkXG5kbyB0aGluZ3MgbGlrZSBzZWxlY3RpbmcgYnkgd29yZC5cbiovXG52YXIgQ2hhckNhdGVnb3J5ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQ2hhckNhdGVnb3J5KSB7XG4gICAgLyoqXG4gICAgV29yZCBjaGFyYWN0ZXJzLlxuICAgICovXG4gICAgQ2hhckNhdGVnb3J5W0NoYXJDYXRlZ29yeVtcIldvcmRcIl0gPSAwXSA9IFwiV29yZFwiO1xuICAgIC8qKlxuICAgIFdoaXRlc3BhY2UuXG4gICAgKi9cbiAgICBDaGFyQ2F0ZWdvcnlbQ2hhckNhdGVnb3J5W1wiU3BhY2VcIl0gPSAxXSA9IFwiU3BhY2VcIjtcbiAgICAvKipcbiAgICBBbnl0aGluZyBlbHNlLlxuICAgICovXG4gICAgQ2hhckNhdGVnb3J5W0NoYXJDYXRlZ29yeVtcIk90aGVyXCJdID0gMl0gPSBcIk90aGVyXCI7XG5yZXR1cm4gQ2hhckNhdGVnb3J5fSkoQ2hhckNhdGVnb3J5IHx8IChDaGFyQ2F0ZWdvcnkgPSB7fSkpO1xuY29uc3Qgbm9uQVNDSUlTaW5nbGVDYXNlV29yZENoYXIgPSAvW1xcdTAwZGZcXHUwNTg3XFx1MDU5MC1cXHUwNWY0XFx1MDYwMC1cXHUwNmZmXFx1MzA0MC1cXHUzMDlmXFx1MzBhMC1cXHUzMGZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmNjXFx1YWMwMC1cXHVkN2FmXS87XG5sZXQgd29yZENoYXI7XG50cnkge1xuICAgIHdvcmRDaGFyID0gLypAX19QVVJFX18qL25ldyBSZWdFeHAoXCJbXFxcXHB7QWxwaGFiZXRpY31cXFxccHtOdW1iZXJ9X11cIiwgXCJ1XCIpO1xufVxuY2F0Y2ggKF8pIHsgfVxuZnVuY3Rpb24gaGFzV29yZENoYXIoc3RyKSB7XG4gICAgaWYgKHdvcmRDaGFyKVxuICAgICAgICByZXR1cm4gd29yZENoYXIudGVzdChzdHIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjaCA9IHN0cltpXTtcbiAgICAgICAgaWYgKC9cXHcvLnRlc3QoY2gpIHx8IGNoID4gXCJcXHg4MFwiICYmIChjaC50b1VwcGVyQ2FzZSgpICE9IGNoLnRvTG93ZXJDYXNlKCkgfHwgbm9uQVNDSUlTaW5nbGVDYXNlV29yZENoYXIudGVzdChjaCkpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG1ha2VDYXRlZ29yaXplcih3b3JkQ2hhcnMpIHtcbiAgICByZXR1cm4gKGNoYXIpID0+IHtcbiAgICAgICAgaWYgKCEvXFxTLy50ZXN0KGNoYXIpKVxuICAgICAgICAgICAgcmV0dXJuIENoYXJDYXRlZ29yeS5TcGFjZTtcbiAgICAgICAgaWYgKGhhc1dvcmRDaGFyKGNoYXIpKVxuICAgICAgICAgICAgcmV0dXJuIENoYXJDYXRlZ29yeS5Xb3JkO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRDaGFycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChjaGFyLmluZGV4T2Yod29yZENoYXJzW2ldKSA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiBDaGFyQ2F0ZWdvcnkuV29yZDtcbiAgICAgICAgcmV0dXJuIENoYXJDYXRlZ29yeS5PdGhlcjtcbiAgICB9O1xufVxuXG4vKipcblRoZSBlZGl0b3Igc3RhdGUgY2xhc3MgaXMgYSBwZXJzaXN0ZW50IChpbW11dGFibGUpIGRhdGEgc3RydWN0dXJlLlxuVG8gdXBkYXRlIGEgc3RhdGUsIHlvdSBbY3JlYXRlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnVwZGF0ZSkgYVxuW3RyYW5zYWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uKSwgd2hpY2ggcHJvZHVjZXMgYSBfbmV3XyBzdGF0ZVxuaW5zdGFuY2UsIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbCBvYmplY3QuXG5cbkFzIHN1Y2gsIF9uZXZlcl8gbXV0YXRlIHByb3BlcnRpZXMgb2YgYSBzdGF0ZSBkaXJlY3RseS4gVGhhdCdsbFxuanVzdCBicmVhayB0aGluZ3MuXG4qL1xuY2xhc3MgRWRpdG9yU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uZmlnLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBkb2N1bWVudC5cbiAgICAqL1xuICAgIGRvYywgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICovXG4gICAgc2VsZWN0aW9uLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHZhbHVlcywgY29tcHV0ZVNsb3QsIHRyKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IGNvbmZpZy5zdGF0dXNUZW1wbGF0ZS5zbGljZSgpO1xuICAgICAgICB0aGlzLmNvbXB1dGVTbG90ID0gY29tcHV0ZVNsb3Q7XG4gICAgICAgIC8vIEZpbGwgaW4gdGhlIGNvbXB1dGVkIHN0YXRlIGltbWVkaWF0ZWx5LCBzbyB0aGF0IGZ1cnRoZXIgcXVlcmllc1xuICAgICAgICAvLyBmb3IgaXQgbWFkZSBkdXJpbmcgdGhlIHVwZGF0ZSByZXR1cm4gdGhpcyBzdGF0ZVxuICAgICAgICBpZiAodHIpXG4gICAgICAgICAgICB0ci5fc3RhdGUgPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29uZmlnLmR5bmFtaWNTbG90cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGVuc3VyZUFkZHIodGhpcywgaSA8PCAxKTtcbiAgICAgICAgdGhpcy5jb21wdXRlU2xvdCA9IG51bGw7XG4gICAgfVxuICAgIGZpZWxkKGZpZWxkLCByZXF1aXJlID0gdHJ1ZSkge1xuICAgICAgICBsZXQgYWRkciA9IHRoaXMuY29uZmlnLmFkZHJlc3NbZmllbGQuaWRdO1xuICAgICAgICBpZiAoYWRkciA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmVxdWlyZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkZpZWxkIGlzIG5vdCBwcmVzZW50IGluIHRoaXMgc3RhdGVcIik7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVuc3VyZUFkZHIodGhpcywgYWRkcik7XG4gICAgICAgIHJldHVybiBnZXRBZGRyKHRoaXMsIGFkZHIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBbdHJhbnNhY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24pIHRoYXQgdXBkYXRlcyB0aGlzXG4gICAgc3RhdGUuIEFueSBudW1iZXIgb2YgW3RyYW5zYWN0aW9uIHNwZWNzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYylcbiAgICBjYW4gYmUgcGFzc2VkLiBVbmxlc3NcbiAgICBbYHNlcXVlbnRpYWxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5zZXF1ZW50aWFsKSBpcyBzZXQsIHRoZVxuICAgIFtjaGFuZ2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5jaGFuZ2VzKSAoaWYgYW55KSBvZiBlYWNoIHNwZWNcbiAgICBhcmUgYXNzdW1lZCB0byBzdGFydCBpbiB0aGUgX2N1cnJlbnRfIGRvY3VtZW50IChub3QgdGhlIGRvY3VtZW50XG4gICAgcHJvZHVjZWQgYnkgcHJldmlvdXMgc3BlY3MpLCBhbmQgaXRzXG4gICAgW3NlbGVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuc2VsZWN0aW9uKSBhbmRcbiAgICBbZWZmZWN0c10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZWZmZWN0cykgYXJlIGFzc3VtZWQgdG8gcmVmZXJcbiAgICB0byB0aGUgZG9jdW1lbnQgY3JlYXRlZCBieSBpdHMgX293bl8gY2hhbmdlcy4gVGhlIHJlc3VsdGluZ1xuICAgIHRyYW5zYWN0aW9uIGNvbnRhaW5zIHRoZSBjb21iaW5lZCBlZmZlY3Qgb2YgYWxsIHRoZSBkaWZmZXJlbnRcbiAgICBzcGVjcy4gRm9yIFtzZWxlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLnNlbGVjdGlvbiksIGxhdGVyXG4gICAgc3BlY3MgdGFrZSBwcmVjZWRlbmNlIG92ZXIgZWFybGllciBvbmVzLlxuICAgICovXG4gICAgdXBkYXRlKC4uLnNwZWNzKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlVHJhbnNhY3Rpb24odGhpcywgc3BlY3MsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFwcGx5VHJhbnNhY3Rpb24odHIpIHtcbiAgICAgICAgbGV0IGNvbmYgPSB0aGlzLmNvbmZpZywgeyBiYXNlLCBjb21wYXJ0bWVudHMgfSA9IGNvbmY7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKENvbXBhcnRtZW50LnJlY29uZmlndXJlKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb25mKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhcnRtZW50cyA9IG5ldyBNYXA7XG4gICAgICAgICAgICAgICAgICAgIGNvbmYuY29tcGFydG1lbnRzLmZvckVhY2goKHZhbCwga2V5KSA9PiBjb21wYXJ0bWVudHMuc2V0KGtleSwgdmFsKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbmYgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb21wYXJ0bWVudHMuc2V0KGVmZmVjdC52YWx1ZS5jb21wYXJ0bWVudCwgZWZmZWN0LnZhbHVlLmV4dGVuc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXMoU3RhdGVFZmZlY3QucmVjb25maWd1cmUpKSB7XG4gICAgICAgICAgICAgICAgY29uZiA9IG51bGw7XG4gICAgICAgICAgICAgICAgYmFzZSA9IGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyhTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgY29uZiA9IG51bGw7XG4gICAgICAgICAgICAgICAgYmFzZSA9IGFzQXJyYXkoYmFzZSkuY29uY2F0KGVmZmVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0VmFsdWVzO1xuICAgICAgICBpZiAoIWNvbmYpIHtcbiAgICAgICAgICAgIGNvbmYgPSBDb25maWd1cmF0aW9uLnJlc29sdmUoYmFzZSwgY29tcGFydG1lbnRzLCB0aGlzKTtcbiAgICAgICAgICAgIGxldCBpbnRlcm1lZGlhdGVTdGF0ZSA9IG5ldyBFZGl0b3JTdGF0ZShjb25mLCB0aGlzLmRvYywgdGhpcy5zZWxlY3Rpb24sIGNvbmYuZHluYW1pY1Nsb3RzLm1hcCgoKSA9PiBudWxsKSwgKHN0YXRlLCBzbG90KSA9PiBzbG90LnJlY29uZmlndXJlKHN0YXRlLCB0aGlzKSwgbnVsbCk7XG4gICAgICAgICAgICBzdGFydFZhbHVlcyA9IGludGVybWVkaWF0ZVN0YXRlLnZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0VmFsdWVzID0gdHIuc3RhcnRTdGF0ZS52YWx1ZXMuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2VsZWN0aW9uID0gdHIuc3RhcnRTdGF0ZS5mYWNldChhbGxvd011bHRpcGxlU2VsZWN0aW9ucykgPyB0ci5uZXdTZWxlY3Rpb24gOiB0ci5uZXdTZWxlY3Rpb24uYXNTaW5nbGUoKTtcbiAgICAgICAgbmV3IEVkaXRvclN0YXRlKGNvbmYsIHRyLm5ld0RvYywgc2VsZWN0aW9uLCBzdGFydFZhbHVlcywgKHN0YXRlLCBzbG90KSA9PiBzbG90LnVwZGF0ZShzdGF0ZSwgdHIpLCB0cik7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFt0cmFuc2FjdGlvbiBzcGVjXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYykgdGhhdFxuICAgIHJlcGxhY2VzIGV2ZXJ5IHNlbGVjdGlvbiByYW5nZSB3aXRoIHRoZSBnaXZlbiBjb250ZW50LlxuICAgICovXG4gICAgcmVwbGFjZVNlbGVjdGlvbih0ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGV4dCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGV4dCA9IHRoaXMudG9UZXh0KHRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+ICh7IGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuZnJvbSwgdG86IHJhbmdlLnRvLCBpbnNlcnQ6IHRleHQgfSxcbiAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20gKyB0ZXh0Lmxlbmd0aCkgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZXQgb2YgY2hhbmdlcyBhbmQgYSBuZXcgc2VsZWN0aW9uIGJ5IHJ1bm5pbmcgdGhlIGdpdmVuXG4gICAgZnVuY3Rpb24gZm9yIGVhY2ggcmFuZ2UgaW4gdGhlIGFjdGl2ZSBzZWxlY3Rpb24uIFRoZSBmdW5jdGlvblxuICAgIGNhbiByZXR1cm4gYW4gb3B0aW9uYWwgc2V0IG9mIGNoYW5nZXMgKGluIHRoZSBjb29yZGluYXRlIHNwYWNlXG4gICAgb2YgdGhlIHN0YXJ0IGRvY3VtZW50KSwgcGx1cyBhbiB1cGRhdGVkIHJhbmdlIChpbiB0aGUgY29vcmRpbmF0ZVxuICAgIHNwYWNlIG9mIHRoZSBkb2N1bWVudCBwcm9kdWNlZCBieSB0aGUgY2FsbCdzIG93biBjaGFuZ2VzKS4gVGhpc1xuICAgIG1ldGhvZCB3aWxsIG1lcmdlIGFsbCB0aGUgY2hhbmdlcyBhbmQgcmFuZ2VzIGludG8gYSBzaW5nbGVcbiAgICBjaGFuZ2VzZXQgYW5kIHNlbGVjdGlvbiwgYW5kIHJldHVybiBpdCBhcyBhIFt0cmFuc2FjdGlvblxuICAgIHNwZWNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjKSwgd2hpY2ggY2FuIGJlIHBhc3NlZCB0b1xuICAgIFtgdXBkYXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS51cGRhdGUpLlxuICAgICovXG4gICAgY2hhbmdlQnlSYW5nZShmKSB7XG4gICAgICAgIGxldCBzZWwgPSB0aGlzLnNlbGVjdGlvbjtcbiAgICAgICAgbGV0IHJlc3VsdDEgPSBmKHNlbC5yYW5nZXNbMF0pO1xuICAgICAgICBsZXQgY2hhbmdlcyA9IHRoaXMuY2hhbmdlcyhyZXN1bHQxLmNoYW5nZXMpLCByYW5nZXMgPSBbcmVzdWx0MS5yYW5nZV07XG4gICAgICAgIGxldCBlZmZlY3RzID0gYXNBcnJheShyZXN1bHQxLmVmZmVjdHMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBmKHNlbC5yYW5nZXNbaV0pO1xuICAgICAgICAgICAgbGV0IG5ld0NoYW5nZXMgPSB0aGlzLmNoYW5nZXMocmVzdWx0LmNoYW5nZXMpLCBuZXdNYXBwZWQgPSBuZXdDaGFuZ2VzLm1hcChjaGFuZ2VzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaTsgaisrKVxuICAgICAgICAgICAgICAgIHJhbmdlc1tqXSA9IHJhbmdlc1tqXS5tYXAobmV3TWFwcGVkKTtcbiAgICAgICAgICAgIGxldCBtYXBCeSA9IGNoYW5nZXMubWFwRGVzYyhuZXdDaGFuZ2VzLCB0cnVlKTtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHJlc3VsdC5yYW5nZS5tYXAobWFwQnkpKTtcbiAgICAgICAgICAgIGNoYW5nZXMgPSBjaGFuZ2VzLmNvbXBvc2UobmV3TWFwcGVkKTtcbiAgICAgICAgICAgIGVmZmVjdHMgPSBTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGVmZmVjdHMsIG5ld01hcHBlZCkuY29uY2F0KFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoYXNBcnJheShyZXN1bHQuZWZmZWN0cyksIG1hcEJ5KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYW5nZXMsXG4gICAgICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLCBzZWwubWFpbkluZGV4KSxcbiAgICAgICAgICAgIGVmZmVjdHNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgW2NoYW5nZSBzZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlU2V0KSBmcm9tIHRoZSBnaXZlbiBjaGFuZ2VcbiAgICBkZXNjcmlwdGlvbiwgdGFraW5nIHRoZSBzdGF0ZSdzIGRvY3VtZW50IGxlbmd0aCBhbmQgbGluZVxuICAgIHNlcGFyYXRvciBpbnRvIGFjY291bnQuXG4gICAgKi9cbiAgICBjaGFuZ2VzKHNwZWMgPSBbXSkge1xuICAgICAgICBpZiAoc3BlYyBpbnN0YW5jZW9mIENoYW5nZVNldClcbiAgICAgICAgICAgIHJldHVybiBzcGVjO1xuICAgICAgICByZXR1cm4gQ2hhbmdlU2V0Lm9mKHNwZWMsIHRoaXMuZG9jLmxlbmd0aCwgdGhpcy5mYWNldChFZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVzaW5nIHRoZSBzdGF0ZSdzIFtsaW5lXG4gICAgc2VwYXJhdG9yXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmxpbmVTZXBhcmF0b3IpLCBjcmVhdGUgYVxuICAgIFtgVGV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVGV4dCkgaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgICovXG4gICAgdG9UZXh0KHN0cmluZykge1xuICAgICAgICByZXR1cm4gVGV4dC5vZihzdHJpbmcuc3BsaXQodGhpcy5mYWNldChFZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yKSB8fCBEZWZhdWx0U3BsaXQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIHRoZSBnaXZlbiByYW5nZSBvZiB0aGUgZG9jdW1lbnQgYXMgYSBzdHJpbmcuXG4gICAgKi9cbiAgICBzbGljZURvYyhmcm9tID0gMCwgdG8gPSB0aGlzLmRvYy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jLnNsaWNlU3RyaW5nKGZyb20sIHRvLCB0aGlzLmxpbmVCcmVhayk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdmFsdWUgb2YgYSBzdGF0ZSBbZmFjZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRmFjZXQpLlxuICAgICovXG4gICAgZmFjZXQoZmFjZXQpIHtcbiAgICAgICAgbGV0IGFkZHIgPSB0aGlzLmNvbmZpZy5hZGRyZXNzW2ZhY2V0LmlkXTtcbiAgICAgICAgaWYgKGFkZHIgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWNldC5kZWZhdWx0O1xuICAgICAgICBlbnN1cmVBZGRyKHRoaXMsIGFkZHIpO1xuICAgICAgICByZXR1cm4gZ2V0QWRkcih0aGlzLCBhZGRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29udmVydCB0aGlzIHN0YXRlIHRvIGEgSlNPTi1zZXJpYWxpemFibGUgb2JqZWN0LiBXaGVuIGN1c3RvbVxuICAgIGZpZWxkcyBzaG91bGQgYmUgc2VyaWFsaXplZCwgeW91IGNhbiBwYXNzIHRoZW0gaW4gYXMgYW4gb2JqZWN0XG4gICAgbWFwcGluZyBwcm9wZXJ0eSBuYW1lcyAoaW4gdGhlIHJlc3VsdGluZyBvYmplY3QsIHdoaWNoIHNob3VsZFxuICAgIG5vdCB1c2UgYGRvY2Agb3IgYHNlbGVjdGlvbmApIHRvIGZpZWxkcy5cbiAgICAqL1xuICAgIHRvSlNPTihmaWVsZHMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGRvYzogdGhpcy5zbGljZURvYygpLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiB0aGlzLnNlbGVjdGlvbi50b0pTT04oKVxuICAgICAgICB9O1xuICAgICAgICBpZiAoZmllbGRzKVxuICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBmaWVsZHNbcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU3RhdGVGaWVsZCAmJiB0aGlzLmNvbmZpZy5hZGRyZXNzW3ZhbHVlLmlkXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcHJvcF0gPSB2YWx1ZS5zcGVjLnRvSlNPTih0aGlzLmZpZWxkKGZpZWxkc1twcm9wXSksIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIHN0YXRlIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uIFdoZW4gY3VzdG9tXG4gICAgZmllbGRzIHNob3VsZCBiZSBkZXNlcmlhbGl6ZWQsIHBhc3MgdGhlIHNhbWUgb2JqZWN0IHlvdSBwYXNzZWRcbiAgICB0byBbYHRvSlNPTmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudG9KU09OKSB3aGVuIHNlcmlhbGl6aW5nIGFzXG4gICAgdGhpcmQgYXJndW1lbnQuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbiwgY29uZmlnID0ge30sIGZpZWxkcykge1xuICAgICAgICBpZiAoIWpzb24gfHwgdHlwZW9mIGpzb24uZG9jICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBmb3IgRWRpdG9yU3RhdGVcIik7XG4gICAgICAgIGxldCBmaWVsZEluaXQgPSBbXTtcbiAgICAgICAgaWYgKGZpZWxkcylcbiAgICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChqc29uLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmllbGQgPSBmaWVsZHNbcHJvcF0sIHZhbHVlID0ganNvbltwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRJbml0LnB1c2goZmllbGQuaW5pdChzdGF0ZSA9PiBmaWVsZC5zcGVjLmZyb21KU09OKHZhbHVlLCBzdGF0ZSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBFZGl0b3JTdGF0ZS5jcmVhdGUoe1xuICAgICAgICAgICAgZG9jOiBqc29uLmRvYyxcbiAgICAgICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmZyb21KU09OKGpzb24uc2VsZWN0aW9uKSxcbiAgICAgICAgICAgIGV4dGVuc2lvbnM6IGNvbmZpZy5leHRlbnNpb25zID8gZmllbGRJbml0LmNvbmNhdChbY29uZmlnLmV4dGVuc2lvbnNdKSA6IGZpZWxkSW5pdFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IHN0YXRlLiBZb3UnbGwgdXN1YWxseSBvbmx5IG5lZWQgdGhpcyB3aGVuXG4gICAgaW5pdGlhbGl6aW5nIGFuIGVkaXRvcuKAlHVwZGF0ZWQgc3RhdGVzIGFyZSBjcmVhdGVkIGJ5IGFwcGx5aW5nXG4gICAgdHJhbnNhY3Rpb25zLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShjb25maWcgPSB7fSkge1xuICAgICAgICBsZXQgY29uZmlndXJhdGlvbiA9IENvbmZpZ3VyYXRpb24ucmVzb2x2ZShjb25maWcuZXh0ZW5zaW9ucyB8fCBbXSwgbmV3IE1hcCk7XG4gICAgICAgIGxldCBkb2MgPSBjb25maWcuZG9jIGluc3RhbmNlb2YgVGV4dCA/IGNvbmZpZy5kb2NcbiAgICAgICAgICAgIDogVGV4dC5vZigoY29uZmlnLmRvYyB8fCBcIlwiKS5zcGxpdChjb25maWd1cmF0aW9uLnN0YXRpY0ZhY2V0KEVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IpIHx8IERlZmF1bHRTcGxpdCkpO1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gIWNvbmZpZy5zZWxlY3Rpb24gPyBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKDApXG4gICAgICAgICAgICA6IGNvbmZpZy5zZWxlY3Rpb24gaW5zdGFuY2VvZiBFZGl0b3JTZWxlY3Rpb24gPyBjb25maWcuc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgOiBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKGNvbmZpZy5zZWxlY3Rpb24uYW5jaG9yLCBjb25maWcuc2VsZWN0aW9uLmhlYWQpO1xuICAgICAgICBjaGVja1NlbGVjdGlvbihzZWxlY3Rpb24sIGRvYy5sZW5ndGgpO1xuICAgICAgICBpZiAoIWNvbmZpZ3VyYXRpb24uc3RhdGljRmFjZXQoYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMpKVxuICAgICAgICAgICAgc2VsZWN0aW9uID0gc2VsZWN0aW9uLmFzU2luZ2xlKCk7XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU3RhdGUoY29uZmlndXJhdGlvbiwgZG9jLCBzZWxlY3Rpb24sIGNvbmZpZ3VyYXRpb24uZHluYW1pY1Nsb3RzLm1hcCgoKSA9PiBudWxsKSwgKHN0YXRlLCBzbG90KSA9PiBzbG90LmNyZWF0ZShzdGF0ZSksIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc2l6ZSAoaW4gY29sdW1ucykgb2YgYSB0YWIgaW4gdGhlIGRvY3VtZW50LCBkZXRlcm1pbmVkIGJ5XG4gICAgdGhlIFtgdGFiU2l6ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedGFiU2l6ZSkgZmFjZXQuXG4gICAgKi9cbiAgICBnZXQgdGFiU2l6ZSgpIHsgcmV0dXJuIHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUudGFiU2l6ZSk7IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHByb3BlciBbbGluZS1icmVha10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5saW5lU2VwYXJhdG9yKVxuICAgIHN0cmluZyBmb3IgdGhpcyBzdGF0ZS5cbiAgICAqL1xuICAgIGdldCBsaW5lQnJlYWsoKSB7IHJldHVybiB0aGlzLmZhY2V0KEVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IpIHx8IFwiXFxuXCI7IH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgd2hlbiB0aGUgZWRpdG9yIGlzXG4gICAgW2NvbmZpZ3VyZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVecmVhZE9ubHkpIHRvIGJlIHJlYWQtb25seS5cbiAgICAqL1xuICAgIGdldCByZWFkT25seSgpIHsgcmV0dXJuIHRoaXMuZmFjZXQocmVhZE9ubHkpOyB9XG4gICAgLyoqXG4gICAgTG9vayB1cCBhIHRyYW5zbGF0aW9uIGZvciB0aGUgZ2l2ZW4gcGhyYXNlICh2aWEgdGhlXG4gICAgW2BwaHJhc2VzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5waHJhc2VzKSBmYWNldCksIG9yIHJldHVybiB0aGVcbiAgICBvcmlnaW5hbCBzdHJpbmcgaWYgbm8gdHJhbnNsYXRpb24gaXMgZm91bmQuXG4gICAgXG4gICAgSWYgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHBhc3NlZCwgdGhleSB3aWxsIGJlIGluc2VydGVkIGluXG4gICAgcGxhY2Ugb2YgbWFya2VycyBsaWtlIGAkMWAgKGZvciB0aGUgZmlyc3QgdmFsdWUpIGFuZCBgJDJgLCBldGMuXG4gICAgQSBzaW5nbGUgYCRgIGlzIGVxdWl2YWxlbnQgdG8gYCQxYCwgYW5kIGAkJGAgd2lsbCBwcm9kdWNlIGFcbiAgICBsaXRlcmFsIGRvbGxhciBzaWduLlxuICAgICovXG4gICAgcGhyYXNlKHBocmFzZSwgLi4uaW5zZXJ0KSB7XG4gICAgICAgIGZvciAobGV0IG1hcCBvZiB0aGlzLmZhY2V0KEVkaXRvclN0YXRlLnBocmFzZXMpKVxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIHBocmFzZSkpIHtcbiAgICAgICAgICAgICAgICBwaHJhc2UgPSBtYXBbcGhyYXNlXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKGluc2VydC5sZW5ndGgpXG4gICAgICAgICAgICBwaHJhc2UgPSBwaHJhc2UucmVwbGFjZSgvXFwkKFxcJHxcXGQqKS9nLCAobSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpID09IFwiJFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIkXCI7XG4gICAgICAgICAgICAgICAgbGV0IG4gPSArKGkgfHwgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFuIHx8IG4gPiBpbnNlcnQubGVuZ3RoID8gbSA6IGluc2VydFtuIC0gMV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBocmFzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgdmFsdWVzIGZvciBhIGdpdmVuIGxhbmd1YWdlIGRhdGEgZmllbGQsIHByb3ZpZGVkIGJ5IHRoZVxuICAgIHRoZSBbYGxhbmd1YWdlRGF0YWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVebGFuZ3VhZ2VEYXRhKSBmYWNldC5cbiAgICBcbiAgICBFeGFtcGxlcyBvZiBsYW5ndWFnZSBkYXRhIGZpZWxkcyBhcmUuLi5cbiAgICBcbiAgICAtIFtgXCJjb21tZW50VG9rZW5zXCJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLkNvbW1lbnRUb2tlbnMpIGZvciBzcGVjaWZ5aW5nXG4gICAgICBjb21tZW50IHN5bnRheC5cbiAgICAtIFtgXCJhdXRvY29tcGxldGVcImBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmF1dG9jb21wbGV0aW9uXmNvbmZpZy5vdmVycmlkZSlcbiAgICAgIGZvciBwcm92aWRpbmcgbGFuZ3VhZ2Utc3BlY2lmaWMgY29tcGxldGlvbiBzb3VyY2VzLlxuICAgIC0gW2BcIndvcmRDaGFyc1wiYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIpIGZvciBhZGRpbmdcbiAgICAgIGNoYXJhY3RlcnMgdGhhdCBzaG91bGQgYmUgY29uc2lkZXJlZCBwYXJ0IG9mIHdvcmRzIGluIHRoaXNcbiAgICAgIGxhbmd1YWdlLlxuICAgIC0gW2BcImNsb3NlQnJhY2tldHNcImBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLkNsb3NlQnJhY2tldENvbmZpZykgY29udHJvbHNcbiAgICAgIGJyYWNrZXQgY2xvc2luZyBiZWhhdmlvci5cbiAgICAqL1xuICAgIGxhbmd1YWdlRGF0YUF0KG5hbWUsIHBvcywgc2lkZSA9IC0xKSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcHJvdmlkZXIgb2YgdGhpcy5mYWNldChsYW5ndWFnZURhdGEpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCByZXN1bHQgb2YgcHJvdmlkZXIodGhpcywgcG9zLCBzaWRlKSkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBuYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gocmVzdWx0W25hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGNhbiBjYXRlZ29yaXplIHN0cmluZ3MgKGV4cGVjdGVkIHRvXG4gICAgcmVwcmVzZW50IGEgc2luZ2xlIFtncmFwaGVtZSBjbHVzdGVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLmZpbmRDbHVzdGVyQnJlYWspKVxuICAgIGludG8gb25lIG9mOlxuICAgIFxuICAgICAtIFdvcmQgKGNvbnRhaW5zIGFuIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXIgb3IgYSBjaGFyYWN0ZXJcbiAgICAgICBleHBsaWNpdGx5IGxpc3RlZCBpbiB0aGUgbG9jYWwgbGFuZ3VhZ2UncyBgXCJ3b3JkQ2hhcnNcImBcbiAgICAgICBsYW5ndWFnZSBkYXRhLCB3aGljaCBzaG91bGQgYmUgYSBzdHJpbmcpXG4gICAgIC0gU3BhY2UgKGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZSlcbiAgICAgLSBPdGhlciAoYW55dGhpbmcgZWxzZSlcbiAgICAqL1xuICAgIGNoYXJDYXRlZ29yaXplcihhdCkge1xuICAgICAgICByZXR1cm4gbWFrZUNhdGVnb3JpemVyKHRoaXMubGFuZ3VhZ2VEYXRhQXQoXCJ3b3JkQ2hhcnNcIiwgYXQpLmpvaW4oXCJcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSB3b3JkIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiwgbWVhbmluZyB0aGUgcmFuZ2VcbiAgICBjb250YWluaW5nIGFsbCBbd29yZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFyQ2F0ZWdvcnkuV29yZCkgY2hhcmFjdGVyc1xuICAgIGFyb3VuZCBpdC4gSWYgbm8gd29yZCBjaGFyYWN0ZXJzIGFyZSBhZGphY2VudCB0byB0aGUgcG9zaXRpb24sXG4gICAgdGhpcyByZXR1cm5zIG51bGwuXG4gICAgKi9cbiAgICB3b3JkQXQocG9zKSB7XG4gICAgICAgIGxldCB7IHRleHQsIGZyb20sIGxlbmd0aCB9ID0gdGhpcy5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgIGxldCBjYXQgPSB0aGlzLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgICAgICBsZXQgc3RhcnQgPSBwb3MgLSBmcm9tLCBlbmQgPSBwb3MgLSBmcm9tO1xuICAgICAgICB3aGlsZSAoc3RhcnQgPiAwKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IGZpbmRDbHVzdGVyQnJlYWsodGV4dCwgc3RhcnQsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChjYXQodGV4dC5zbGljZShwcmV2LCBzdGFydCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3RhcnQgPSBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChlbmQgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZmluZENsdXN0ZXJCcmVhayh0ZXh0LCBlbmQpO1xuICAgICAgICAgICAgaWYgKGNhdCh0ZXh0LnNsaWNlKGVuZCwgbmV4dCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZW5kID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhcnQgPT0gZW5kID8gbnVsbCA6IEVkaXRvclNlbGVjdGlvbi5yYW5nZShzdGFydCArIGZyb20sIGVuZCArIGZyb20pO1xuICAgIH1cbn1cbi8qKlxuQSBmYWNldCB0aGF0LCB3aGVuIGVuYWJsZWQsIGNhdXNlcyB0aGUgZWRpdG9yIHRvIGFsbG93IG11bHRpcGxlXG5yYW5nZXMgdG8gYmUgc2VsZWN0ZWQuIEJlIGNhcmVmdWwgdGhvdWdoLCBiZWNhdXNlIGJ5IGRlZmF1bHQgdGhlXG5lZGl0b3IgcmVsaWVzIG9uIHRoZSBuYXRpdmUgRE9NIHNlbGVjdGlvbiwgd2hpY2ggY2Fubm90IGhhbmRsZVxubXVsdGlwbGUgc2VsZWN0aW9ucy4gQW4gZXh0ZW5zaW9uIGxpa2VcbltgZHJhd1NlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5kcmF3U2VsZWN0aW9uKSBjYW4gYmUgdXNlZCB0byBtYWtlXG5zZWNvbmRhcnkgc2VsZWN0aW9ucyB2aXNpYmxlIHRvIHRoZSB1c2VyLlxuKi9cbkVkaXRvclN0YXRlLmFsbG93TXVsdGlwbGVTZWxlY3Rpb25zID0gYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnM7XG4vKipcbkNvbmZpZ3VyZXMgdGhlIHRhYiBzaXplIHRvIHVzZSBpbiB0aGlzIHN0YXRlLiBUaGUgZmlyc3RcbihoaWdoZXN0LXByZWNlZGVuY2UpIHZhbHVlIG9mIHRoZSBmYWNldCBpcyB1c2VkLiBJZiBubyB2YWx1ZSBpc1xuZ2l2ZW4sIHRoaXMgZGVmYXVsdHMgdG8gNC5cbiovXG5FZGl0b3JTdGF0ZS50YWJTaXplID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiA0XG59KTtcbi8qKlxuVGhlIGxpbmUgc2VwYXJhdG9yIHRvIHVzZS4gQnkgZGVmYXVsdCwgYW55IG9mIGBcIlxcblwiYCwgYFwiXFxyXFxuXCJgXG5hbmQgYFwiXFxyXCJgIGlzIHRyZWF0ZWQgYXMgYSBzZXBhcmF0b3Igd2hlbiBzcGxpdHRpbmcgbGluZXMsIGFuZFxubGluZXMgYXJlIGpvaW5lZCB3aXRoIGBcIlxcblwiYC5cblxuV2hlbiB5b3UgY29uZmlndXJlIGEgdmFsdWUgaGVyZSwgb25seSB0aGF0IHByZWNpc2Ugc2VwYXJhdG9yXG53aWxsIGJlIHVzZWQsIGFsbG93aW5nIHlvdSB0byByb3VuZC10cmlwIGRvY3VtZW50cyB0aHJvdWdoIHRoZVxuZWRpdG9yIHdpdGhvdXQgbm9ybWFsaXppbmcgbGluZSBzZXBhcmF0b3JzLlxuKi9cbkVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IgPSBsaW5lU2VwYXJhdG9yO1xuLyoqXG5UaGlzIGZhY2V0IGNvbnRyb2xzIHRoZSB2YWx1ZSBvZiB0aGVcbltgcmVhZE9ubHlgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnJlYWRPbmx5KSBnZXR0ZXIsIHdoaWNoIGlzXG5jb25zdWx0ZWQgYnkgY29tbWFuZHMgYW5kIGV4dGVuc2lvbnMgdGhhdCBpbXBsZW1lbnQgZWRpdGluZ1xuZnVuY3Rpb25hbGl0eSB0byBkZXRlcm1pbmUgd2hldGhlciB0aGV5IHNob3VsZCBhcHBseS4gSXRcbmRlZmF1bHRzIHRvIGZhbHNlLCBidXQgd2hlbiBpdHMgaGlnaGVzdC1wcmVjZWRlbmNlIHZhbHVlIGlzXG5gdHJ1ZWAsIHN1Y2ggZnVuY3Rpb25hbGl0eSBkaXNhYmxlcyBpdHNlbGYuXG5cbk5vdCB0byBiZSBjb25mdXNlZCB3aXRoXG5bYEVkaXRvclZpZXcuZWRpdGFibGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15lZGl0YWJsZSksIHdoaWNoXG5jb250cm9scyB3aGV0aGVyIHRoZSBlZGl0b3IncyBET00gaXMgc2V0IHRvIGJlIGVkaXRhYmxlIChhbmRcbnRodXMgZm9jdXNhYmxlKS5cbiovXG5FZGl0b3JTdGF0ZS5yZWFkT25seSA9IHJlYWRPbmx5O1xuLyoqXG5SZWdpc3RlcnMgdHJhbnNsYXRpb24gcGhyYXNlcy4gVGhlXG5bYHBocmFzZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUucGhyYXNlKSBtZXRob2Qgd2lsbCBsb29rIHRocm91Z2hcbmFsbCBvYmplY3RzIHJlZ2lzdGVyZWQgd2l0aCB0aGlzIGZhY2V0IHRvIGZpbmQgdHJhbnNsYXRpb25zIGZvclxuaXRzIGFyZ3VtZW50LlxuKi9cbkVkaXRvclN0YXRlLnBocmFzZXMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21wYXJlKGEsIGIpIHtcbiAgICAgICAgbGV0IGtBID0gT2JqZWN0LmtleXMoYSksIGtCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIHJldHVybiBrQS5sZW5ndGggPT0ga0IubGVuZ3RoICYmIGtBLmV2ZXJ5KGsgPT4gYVtrXSA9PSBiW2tdKTtcbiAgICB9XG59KTtcbi8qKlxuQSBmYWNldCB1c2VkIHRvIHJlZ2lzdGVyIFtsYW5ndWFnZVxuZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkgcHJvdmlkZXJzLlxuKi9cbkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YSA9IGxhbmd1YWdlRGF0YTtcbi8qKlxuRmFjZXQgdXNlZCB0byByZWdpc3RlciBjaGFuZ2UgZmlsdGVycywgd2hpY2ggYXJlIGNhbGxlZCBmb3IgZWFjaFxudHJhbnNhY3Rpb24gKHVubGVzcyBleHBsaWNpdGx5XG5bZGlzYWJsZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmZpbHRlcikpLCBhbmQgY2FuIHN1cHByZXNzXG5wYXJ0IG9mIHRoZSB0cmFuc2FjdGlvbidzIGNoYW5nZXMuXG5cblN1Y2ggYSBmdW5jdGlvbiBjYW4gcmV0dXJuIGB0cnVlYCB0byBpbmRpY2F0ZSB0aGF0IGl0IGRvZXNuJ3RcbndhbnQgdG8gZG8gYW55dGhpbmcsIGBmYWxzZWAgdG8gY29tcGxldGVseSBzdG9wIHRoZSBjaGFuZ2VzIGluXG50aGUgdHJhbnNhY3Rpb24sIG9yIGEgc2V0IG9mIHJhbmdlcyBpbiB3aGljaCBjaGFuZ2VzIHNob3VsZCBiZVxuc3VwcHJlc3NlZC4gU3VjaCByYW5nZXMgYXJlIHJlcHJlc2VudGVkIGFzIGFuIGFycmF5IG9mIG51bWJlcnMsXG53aXRoIGVhY2ggcGFpciBvZiB0d28gbnVtYmVycyBpbmRpY2F0aW5nIHRoZSBzdGFydCBhbmQgZW5kIG9mIGFcbnJhbmdlLiBTbyBmb3IgZXhhbXBsZSBgWzEwLCAyMCwgMTAwLCAxMTBdYCBzdXBwcmVzc2VzIGNoYW5nZXNcbmJldHdlZW4gMTAgYW5kIDIwLCBhbmQgYmV0d2VlbiAxMDAgYW5kIDExMC5cbiovXG5FZGl0b3JTdGF0ZS5jaGFuZ2VGaWx0ZXIgPSBjaGFuZ2VGaWx0ZXI7XG4vKipcbkZhY2V0IHVzZWQgdG8gcmVnaXN0ZXIgYSBob29rIHRoYXQgZ2V0cyBhIGNoYW5jZSB0byB1cGRhdGUgb3JcbnJlcGxhY2UgdHJhbnNhY3Rpb24gc3BlY3MgYmVmb3JlIHRoZXkgYXJlIGFwcGxpZWQuIFRoaXMgd2lsbFxub25seSBiZSBhcHBsaWVkIGZvciB0cmFuc2FjdGlvbnMgdGhhdCBkb24ndCBoYXZlXG5bYGZpbHRlcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmZpbHRlcikgc2V0IHRvIGBmYWxzZWAuIFlvdVxuY2FuIGVpdGhlciByZXR1cm4gYSBzaW5nbGUgdHJhbnNhY3Rpb24gc3BlYyAocG9zc2libHkgdGhlIGlucHV0XG50cmFuc2FjdGlvbiksIG9yIGFuIGFycmF5IG9mIHNwZWNzICh3aGljaCB3aWxsIGJlIGNvbWJpbmVkIGluXG50aGUgc2FtZSB3YXkgYXMgdGhlIGFyZ3VtZW50cyB0b1xuW2BFZGl0b3JTdGF0ZS51cGRhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnVwZGF0ZSkpLlxuXG5XaGVuIHBvc3NpYmxlLCBpdCBpcyByZWNvbW1lbmRlZCB0byBhdm9pZCBhY2Nlc3NpbmdcbltgVHJhbnNhY3Rpb24uc3RhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLnN0YXRlKSBpbiBhIGZpbHRlcixcbnNpbmNlIGl0IHdpbGwgZm9yY2UgY3JlYXRpb24gb2YgYSBzdGF0ZSB0aGF0IHdpbGwgdGhlbiBiZVxuZGlzY2FyZGVkIGFnYWluLCBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYWN0dWFsbHkgZmlsdGVyZWQuXG5cbihUaGlzIGZ1bmN0aW9uYWxpdHkgc2hvdWxkIGJlIHVzZWQgd2l0aCBjYXJlLiBJbmRpc2NyaW1pbmF0ZWx5XG5tb2RpZnlpbmcgdHJhbnNhY3Rpb24gaXMgbGlrZWx5IHRvIGJyZWFrIHNvbWV0aGluZyBvciBkZWdyYWRlXG50aGUgdXNlciBleHBlcmllbmNlLilcbiovXG5FZGl0b3JTdGF0ZS50cmFuc2FjdGlvbkZpbHRlciA9IHRyYW5zYWN0aW9uRmlsdGVyO1xuLyoqXG5UaGlzIGlzIGEgbW9yZSBsaW1pdGVkIGZvcm0gb2ZcbltgdHJhbnNhY3Rpb25GaWx0ZXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRyYW5zYWN0aW9uRmlsdGVyKSxcbndoaWNoIGNhbiBvbmx5IGFkZFxuW2Fubm90YXRpb25zXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5hbm5vdGF0aW9ucykgYW5kXG5bZWZmZWN0c10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZWZmZWN0cykuIF9CdXRfLCB0aGlzIHR5cGVcbm9mIGZpbHRlciBydW5zIGV2ZW4gaWYgdGhlIHRyYW5zYWN0aW9uIGhhcyBkaXNhYmxlZCByZWd1bGFyXG5bZmlsdGVyaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5maWx0ZXIpLCBtYWtpbmcgaXQgc3VpdGFibGVcbmZvciBlZmZlY3RzIHRoYXQgZG9uJ3QgbmVlZCB0byB0b3VjaCB0aGUgY2hhbmdlcyBvciBzZWxlY3Rpb24sXG5idXQgZG8gd2FudCB0byBwcm9jZXNzIGV2ZXJ5IHRyYW5zYWN0aW9uLlxuXG5FeHRlbmRlcnMgcnVuIF9hZnRlcl8gZmlsdGVycywgd2hlbiBib3RoIGFyZSBwcmVzZW50LlxuKi9cbkVkaXRvclN0YXRlLnRyYW5zYWN0aW9uRXh0ZW5kZXIgPSB0cmFuc2FjdGlvbkV4dGVuZGVyO1xuQ29tcGFydG1lbnQucmVjb25maWd1cmUgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5cbi8qKlxuVXRpbGl0eSBmdW5jdGlvbiBmb3IgY29tYmluaW5nIGJlaGF2aW9ycyB0byBmaWxsIGluIGEgY29uZmlnXG5vYmplY3QgZnJvbSBhbiBhcnJheSBvZiBwcm92aWRlZCBjb25maWdzLiBgZGVmYXVsdHNgIHNob3VsZCBob2xkXG5kZWZhdWx0IHZhbHVlcyBmb3IgYWxsIG9wdGlvbmFsIGZpZWxkcyBpbiBgQ29uZmlnYC5cblxuVGhlIGZ1bmN0aW9uIHdpbGwsIGJ5IGRlZmF1bHQsIGVycm9yXG53aGVuIGEgZmllbGQgZ2V0cyB0d28gdmFsdWVzIHRoYXQgYXJlbid0IGA9PT1gLWVxdWFsLCBidXQgeW91IGNhblxucHJvdmlkZSBjb21iaW5lIGZ1bmN0aW9ucyBwZXIgZmllbGQgdG8gZG8gc29tZXRoaW5nIGVsc2UuXG4qL1xuZnVuY3Rpb24gY29tYmluZUNvbmZpZyhjb25maWdzLCBkZWZhdWx0cywgLy8gU2hvdWxkIGhvbGQgb25seSB0aGUgb3B0aW9uYWwgcHJvcGVydGllcyBvZiBDb25maWcsIGJ1dCBJIGhhdmVuJ3QgbWFuYWdlZCB0byBleHByZXNzIHRoYXRcbmNvbWJpbmUgPSB7fSkge1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCBjb25maWcgb2YgY29uZmlncylcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKGNvbmZpZykpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGNvbmZpZ1trZXldLCBjdXJyZW50ID0gcmVzdWx0W2tleV07XG4gICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA7IC8vIE5vIGNvbmZsaWN0XG4gICAgICAgICAgICBlbHNlIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChjb21iaW5lLCBrZXkpKVxuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gY29tYmluZVtrZXldKGN1cnJlbnQsIHZhbHVlKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb25maWcgbWVyZ2UgY29uZmxpY3QgZm9yIGZpZWxkIFwiICsga2V5KTtcbiAgICAgICAgfVxuICAgIGZvciAobGV0IGtleSBpbiBkZWZhdWx0cylcbiAgICAgICAgaWYgKHJlc3VsdFtrZXldID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGRlZmF1bHRzW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG5FYWNoIHJhbmdlIGlzIGFzc29jaWF0ZWQgd2l0aCBhIHZhbHVlLCB3aGljaCBtdXN0IGluaGVyaXQgZnJvbVxudGhpcyBjbGFzcy5cbiovXG5jbGFzcyBSYW5nZVZhbHVlIHtcbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgdmFsdWUgd2l0aCBhbm90aGVyIHZhbHVlLiBVc2VkIHdoZW4gY29tcGFyaW5nXG4gICAgcmFuZ2VzZXRzLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBjb21wYXJlcyBieSBpZGVudGl0eS5cbiAgICBVbmxlc3MgeW91IGFyZSBvbmx5IGNyZWF0aW5nIGEgZml4ZWQgbnVtYmVyIG9mIHVuaXF1ZSBpbnN0YW5jZXNcbiAgICBvZiB5b3VyIHZhbHVlIHR5cGUsIGl0IGlzIGEgZ29vZCBpZGVhIHRvIGltcGxlbWVudCB0aGlzXG4gICAgcHJvcGVybHkuXG4gICAgKi9cbiAgICBlcShvdGhlcikgeyByZXR1cm4gdGhpcyA9PSBvdGhlcjsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFtyYW5nZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZSkgd2l0aCB0aGlzIHZhbHVlLlxuICAgICovXG4gICAgcmFuZ2UoZnJvbSwgdG8gPSBmcm9tKSB7IHJldHVybiBSYW5nZS5jcmVhdGUoZnJvbSwgdG8sIHRoaXMpOyB9XG59XG5SYW5nZVZhbHVlLnByb3RvdHlwZS5zdGFydFNpZGUgPSBSYW5nZVZhbHVlLnByb3RvdHlwZS5lbmRTaWRlID0gMDtcblJhbmdlVmFsdWUucHJvdG90eXBlLnBvaW50ID0gZmFsc2U7XG5SYW5nZVZhbHVlLnByb3RvdHlwZS5tYXBNb2RlID0gTWFwTW9kZS5UcmFja0RlbDtcbi8qKlxuQSByYW5nZSBhc3NvY2lhdGVzIGEgdmFsdWUgd2l0aCBhIHJhbmdlIG9mIHBvc2l0aW9ucy5cbiovXG5jbGFzcyBSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHJhbmdlJ3Mgc3RhcnQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBJdHMgZW5kIHBvc2l0aW9uLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhpcyByYW5nZS5cbiAgICAqL1xuICAgIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZnJvbSwgdG8sIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UoZnJvbSwgdG8sIHZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbXBSYW5nZShhLCBiKSB7XG4gICAgcmV0dXJuIGEuZnJvbSAtIGIuZnJvbSB8fCBhLnZhbHVlLnN0YXJ0U2lkZSAtIGIudmFsdWUuc3RhcnRTaWRlO1xufVxuY2xhc3MgQ2h1bmsge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvLCB2YWx1ZSwgXG4gICAgLy8gQ2h1bmtzIGFyZSBtYXJrZWQgd2l0aCB0aGUgbGFyZ2VzdCBwb2ludCB0aGF0IG9jY3Vyc1xuICAgIC8vIGluIHRoZW0gKG9yIC0xIGZvciBubyBwb2ludHMpLCBzbyB0aGF0IHNjYW5zIHRoYXQgYXJlXG4gICAgLy8gb25seSBpbnRlcmVzdGVkIGluIHBvaW50cyAoc3VjaCBhcyB0aGVcbiAgICAvLyBoZWlnaHRtYXAtcmVsYXRlZCBsb2dpYykgY2FuIHNraXAgcmFuZ2Utb25seSBjaHVua3MuXG4gICAgbWF4UG9pbnQpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubWF4UG9pbnQgPSBtYXhQb2ludDtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMudG9bdGhpcy50by5sZW5ndGggLSAxXTsgfVxuICAgIC8vIEZpbmQgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgc2lkZS4gVXNlIHRoZSByYW5nZXMnXG4gICAgLy8gYGZyb21gIHBvcyB3aGVuIGBlbmQgPT0gZmFsc2VgLCBgdG9gIHdoZW4gYGVuZCA9PSB0cnVlYC5cbiAgICBmaW5kSW5kZXgocG9zLCBzaWRlLCBlbmQsIHN0YXJ0QXQgPSAwKSB7XG4gICAgICAgIGxldCBhcnIgPSBlbmQgPyB0aGlzLnRvIDogdGhpcy5mcm9tO1xuICAgICAgICBmb3IgKGxldCBsbyA9IHN0YXJ0QXQsIGhpID0gYXJyLmxlbmd0aDs7KSB7XG4gICAgICAgICAgICBpZiAobG8gPT0gaGkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvO1xuICAgICAgICAgICAgbGV0IG1pZCA9IChsbyArIGhpKSA+PiAxO1xuICAgICAgICAgICAgbGV0IGRpZmYgPSBhcnJbbWlkXSAtIHBvcyB8fCAoZW5kID8gdGhpcy52YWx1ZVttaWRdLmVuZFNpZGUgOiB0aGlzLnZhbHVlW21pZF0uc3RhcnRTaWRlKSAtIHNpZGU7XG4gICAgICAgICAgICBpZiAobWlkID09IGxvKVxuICAgICAgICAgICAgICAgIHJldHVybiBkaWZmID49IDAgPyBsbyA6IGhpO1xuICAgICAgICAgICAgaWYgKGRpZmYgPj0gMClcbiAgICAgICAgICAgICAgICBoaSA9IG1pZDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBsbyA9IG1pZCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmV0d2VlbihvZmZzZXQsIGZyb20sIHRvLCBmKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZpbmRJbmRleChmcm9tLCAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLywgdHJ1ZSksIGUgPSB0aGlzLmZpbmRJbmRleCh0bywgMTAwMDAwMDAwMCAvKiBDLkZhciAqLywgZmFsc2UsIGkpOyBpIDwgZTsgaSsrKVxuICAgICAgICAgICAgaWYgKGYodGhpcy5mcm9tW2ldICsgb2Zmc2V0LCB0aGlzLnRvW2ldICsgb2Zmc2V0LCB0aGlzLnZhbHVlW2ldKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtYXAob2Zmc2V0LCBjaGFuZ2VzKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IFtdLCBmcm9tID0gW10sIHRvID0gW10sIG5ld1BvcyA9IC0xLCBtYXhQb2ludCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2YWwgPSB0aGlzLnZhbHVlW2ldLCBjdXJGcm9tID0gdGhpcy5mcm9tW2ldICsgb2Zmc2V0LCBjdXJUbyA9IHRoaXMudG9baV0gKyBvZmZzZXQsIG5ld0Zyb20sIG5ld1RvO1xuICAgICAgICAgICAgaWYgKGN1ckZyb20gPT0gY3VyVG8pIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFwcGVkID0gY2hhbmdlcy5tYXBQb3MoY3VyRnJvbSwgdmFsLnN0YXJ0U2lkZSwgdmFsLm1hcE1vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChtYXBwZWQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgbmV3RnJvbSA9IG5ld1RvID0gbWFwcGVkO1xuICAgICAgICAgICAgICAgIGlmICh2YWwuc3RhcnRTaWRlICE9IHZhbC5lbmRTaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1RvID0gY2hhbmdlcy5tYXBQb3MoY3VyRnJvbSwgdmFsLmVuZFNpZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3VG8gPCBuZXdGcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3RnJvbSA9IGNoYW5nZXMubWFwUG9zKGN1ckZyb20sIHZhbC5zdGFydFNpZGUpO1xuICAgICAgICAgICAgICAgIG5ld1RvID0gY2hhbmdlcy5tYXBQb3MoY3VyVG8sIHZhbC5lbmRTaWRlKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3RnJvbSA+IG5ld1RvIHx8IG5ld0Zyb20gPT0gbmV3VG8gJiYgdmFsLnN0YXJ0U2lkZSA+IDAgJiYgdmFsLmVuZFNpZGUgPD0gMClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG5ld1RvIC0gbmV3RnJvbSB8fCB2YWwuZW5kU2lkZSAtIHZhbC5zdGFydFNpZGUpIDwgMClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChuZXdQb3MgPCAwKVxuICAgICAgICAgICAgICAgIG5ld1BvcyA9IG5ld0Zyb207XG4gICAgICAgICAgICBpZiAodmFsLnBvaW50KVxuICAgICAgICAgICAgICAgIG1heFBvaW50ID0gTWF0aC5tYXgobWF4UG9pbnQsIG5ld1RvIC0gbmV3RnJvbSk7XG4gICAgICAgICAgICB2YWx1ZS5wdXNoKHZhbCk7XG4gICAgICAgICAgICBmcm9tLnB1c2gobmV3RnJvbSAtIG5ld1Bvcyk7XG4gICAgICAgICAgICB0by5wdXNoKG5ld1RvIC0gbmV3UG9zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtYXBwZWQ6IHZhbHVlLmxlbmd0aCA/IG5ldyBDaHVuayhmcm9tLCB0bywgdmFsdWUsIG1heFBvaW50KSA6IG51bGwsIHBvczogbmV3UG9zIH07XG4gICAgfVxufVxuLyoqXG5BIHJhbmdlIHNldCBzdG9yZXMgYSBjb2xsZWN0aW9uIG9mIFtyYW5nZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2UpIGluIGFcbndheSB0aGF0IG1ha2VzIHRoZW0gZWZmaWNpZW50IHRvIFttYXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2VTZXQubWFwKSBhbmRcblt1cGRhdGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2VTZXQudXBkYXRlKS4gVGhpcyBpcyBhbiBpbW11dGFibGUgZGF0YVxuc3RydWN0dXJlLlxuKi9cbmNsYXNzIFJhbmdlU2V0IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNodW5rUG9zLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNodW5rLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG5leHRMYXllciwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXhQb2ludCkge1xuICAgICAgICB0aGlzLmNodW5rUG9zID0gY2h1bmtQb3M7XG4gICAgICAgIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgICAgICAgdGhpcy5uZXh0TGF5ZXIgPSBuZXh0TGF5ZXI7XG4gICAgICAgIHRoaXMubWF4UG9pbnQgPSBtYXhQb2ludDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGNodW5rUG9zLCBjaHVuaywgbmV4dExheWVyLCBtYXhQb2ludCkge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlU2V0KGNodW5rUG9zLCBjaHVuaywgbmV4dExheWVyLCBtYXhQb2ludCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmNodW5rLmxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiBsYXN0IDwgMCA/IDAgOiBNYXRoLm1heCh0aGlzLmNodW5rRW5kKGxhc3QpLCB0aGlzLm5leHRMYXllci5sZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbnVtYmVyIG9mIHJhbmdlcyBpbiB0aGUgc2V0LlxuICAgICovXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IHNpemUgPSB0aGlzLm5leHRMYXllci5zaXplO1xuICAgICAgICBmb3IgKGxldCBjaHVuayBvZiB0aGlzLmNodW5rKVxuICAgICAgICAgICAgc2l6ZSArPSBjaHVuay52YWx1ZS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNodW5rRW5kKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNodW5rUG9zW2luZGV4XSArIHRoaXMuY2h1bmtbaW5kZXhdLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSByYW5nZSBzZXQsIG9wdGlvbmFsbHkgYWRkaW5nIG5ldyByYW5nZXMgb3IgZmlsdGVyaW5nXG4gICAgb3V0IGV4aXN0aW5nIG9uZXMuXG4gICAgXG4gICAgKE5vdGU6IFRoZSB0eXBlIHBhcmFtZXRlciBpcyBqdXN0IHRoZXJlIGFzIGEga2x1ZGdlIHRvIHdvcmtcbiAgICBhcm91bmQgVHlwZVNjcmlwdCB2YXJpYW5jZSBpc3N1ZXMgdGhhdCBwcmV2ZW50ZWQgYFJhbmdlU2V0PFg+YFxuICAgIGZyb20gYmVpbmcgYSBzdWJ0eXBlIG9mIGBSYW5nZVNldDxZPmAgd2hlbiBgWGAgaXMgYSBzdWJ0eXBlIG9mXG4gICAgYFlgLilcbiAgICAqL1xuICAgIHVwZGF0ZSh1cGRhdGVTcGVjKSB7XG4gICAgICAgIGxldCB7IGFkZCA9IFtdLCBzb3J0ID0gZmFsc2UsIGZpbHRlckZyb20gPSAwLCBmaWx0ZXJUbyA9IHRoaXMubGVuZ3RoIH0gPSB1cGRhdGVTcGVjO1xuICAgICAgICBsZXQgZmlsdGVyID0gdXBkYXRlU3BlYy5maWx0ZXI7XG4gICAgICAgIGlmIChhZGQubGVuZ3RoID09IDAgJiYgIWZpbHRlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAoc29ydClcbiAgICAgICAgICAgIGFkZCA9IGFkZC5zbGljZSgpLnNvcnQoY21wUmFuZ2UpO1xuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIGFkZC5sZW5ndGggPyBSYW5nZVNldC5vZihhZGQpIDogdGhpcztcbiAgICAgICAgbGV0IGN1ciA9IG5ldyBMYXllckN1cnNvcih0aGlzLCBudWxsLCAtMSkuZ290bygwKSwgaSA9IDAsIHNwaWxsID0gW107XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICB3aGlsZSAoY3VyLnZhbHVlIHx8IGkgPCBhZGQubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaSA8IGFkZC5sZW5ndGggJiYgKGN1ci5mcm9tIC0gYWRkW2ldLmZyb20gfHwgY3VyLnN0YXJ0U2lkZSAtIGFkZFtpXS52YWx1ZS5zdGFydFNpZGUpID49IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgcmFuZ2UgPSBhZGRbaSsrXTtcbiAgICAgICAgICAgICAgICBpZiAoIWJ1aWxkZXIuYWRkSW5uZXIocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHJhbmdlLnZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgc3BpbGwucHVzaChyYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXIucmFuZ2VJbmRleCA9PSAxICYmIGN1ci5jaHVua0luZGV4IDwgdGhpcy5jaHVuay5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAoaSA9PSBhZGQubGVuZ3RoIHx8IHRoaXMuY2h1bmtFbmQoY3VyLmNodW5rSW5kZXgpIDwgYWRkW2ldLmZyb20pICYmXG4gICAgICAgICAgICAgICAgKCFmaWx0ZXIgfHwgZmlsdGVyRnJvbSA+IHRoaXMuY2h1bmtFbmQoY3VyLmNodW5rSW5kZXgpIHx8IGZpbHRlclRvIDwgdGhpcy5jaHVua1Bvc1tjdXIuY2h1bmtJbmRleF0pICYmXG4gICAgICAgICAgICAgICAgYnVpbGRlci5hZGRDaHVuayh0aGlzLmNodW5rUG9zW2N1ci5jaHVua0luZGV4XSwgdGhpcy5jaHVua1tjdXIuY2h1bmtJbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgY3VyLm5leHRDaHVuaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyRnJvbSA+IGN1ci50byB8fCBmaWx0ZXJUbyA8IGN1ci5mcm9tIHx8IGZpbHRlcihjdXIuZnJvbSwgY3VyLnRvLCBjdXIudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYnVpbGRlci5hZGRJbm5lcihjdXIuZnJvbSwgY3VyLnRvLCBjdXIudmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3BpbGwucHVzaChSYW5nZS5jcmVhdGUoY3VyLmZyb20sIGN1ci50bywgY3VyLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1ci5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZmluaXNoSW5uZXIodGhpcy5uZXh0TGF5ZXIuaXNFbXB0eSAmJiAhc3BpbGwubGVuZ3RoID8gUmFuZ2VTZXQuZW1wdHlcbiAgICAgICAgICAgIDogdGhpcy5uZXh0TGF5ZXIudXBkYXRlKHsgYWRkOiBzcGlsbCwgZmlsdGVyLCBmaWx0ZXJGcm9tLCBmaWx0ZXJUbyB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCB0aGlzIHJhbmdlIHNldCB0aHJvdWdoIGEgc2V0IG9mIGNoYW5nZXMsIHJldHVybiB0aGUgbmV3IHNldC5cbiAgICAqL1xuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmVtcHR5IHx8IHRoaXMuaXNFbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgY2h1bmtzID0gW10sIGNodW5rUG9zID0gW10sIG1heFBvaW50ID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVuay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5jaHVua1Bvc1tpXSwgY2h1bmsgPSB0aGlzLmNodW5rW2ldO1xuICAgICAgICAgICAgbGV0IHRvdWNoID0gY2hhbmdlcy50b3VjaGVzUmFuZ2Uoc3RhcnQsIHN0YXJ0ICsgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmICh0b3VjaCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBtYXhQb2ludCA9IE1hdGgubWF4KG1heFBvaW50LCBjaHVuay5tYXhQb2ludCk7XG4gICAgICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgIGNodW5rUG9zLnB1c2goY2hhbmdlcy5tYXBQb3Moc3RhcnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRvdWNoID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgbWFwcGVkLCBwb3MgfSA9IGNodW5rLm1hcChzdGFydCwgY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICBtYXhQb2ludCA9IE1hdGgubWF4KG1heFBvaW50LCBtYXBwZWQubWF4UG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICBjaHVua3MucHVzaChtYXBwZWQpO1xuICAgICAgICAgICAgICAgICAgICBjaHVua1Bvcy5wdXNoKHBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5uZXh0TGF5ZXIubWFwKGNoYW5nZXMpO1xuICAgICAgICByZXR1cm4gY2h1bmtzLmxlbmd0aCA9PSAwID8gbmV4dCA6IG5ldyBSYW5nZVNldChjaHVua1BvcywgY2h1bmtzLCBuZXh0IHx8IFJhbmdlU2V0LmVtcHR5LCBtYXhQb2ludCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgcmFuZ2VzIHRoYXQgdG91Y2ggdGhlIHJlZ2lvbiBgZnJvbWAgdG8gYHRvYCxcbiAgICBjYWxsaW5nIGBmYCBmb3IgZWFjaC4gVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIHJhbmdlcyB3aWxsXG4gICAgYmUgcmVwb3J0ZWQgaW4gYW55IHNwZWNpZmljIG9yZGVyLiBXaGVuIHRoZSBjYWxsYmFjayByZXR1cm5zXG4gICAgYGZhbHNlYCwgaXRlcmF0aW9uIHN0b3BzLlxuICAgICovXG4gICAgYmV0d2Vlbihmcm9tLCB0bywgZikge1xuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmsubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMuY2h1bmtQb3NbaV0sIGNodW5rID0gdGhpcy5jaHVua1tpXTtcbiAgICAgICAgICAgIGlmICh0byA+PSBzdGFydCAmJiBmcm9tIDw9IHN0YXJ0ICsgY2h1bmsubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgY2h1bmsuYmV0d2VlbihzdGFydCwgZnJvbSAtIHN0YXJ0LCB0byAtIHN0YXJ0LCBmKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmV4dExheWVyLmJldHdlZW4oZnJvbSwgdG8sIGYpO1xuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHJhbmdlcyBpbiB0aGlzIHNldCwgaW4gb3JkZXIsIGluY2x1ZGluZyBhbGxcbiAgICByYW5nZXMgdGhhdCBlbmQgYXQgb3IgYWZ0ZXIgYGZyb21gLlxuICAgICovXG4gICAgaXRlcihmcm9tID0gMCkge1xuICAgICAgICByZXR1cm4gSGVhcEN1cnNvci5mcm9tKFt0aGlzXSkuZ290byhmcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgaXNFbXB0eSgpIHsgcmV0dXJuIHRoaXMubmV4dExheWVyID09IHRoaXM7IH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHJhbmdlcyBpbiBhIGNvbGxlY3Rpb24gb2Ygc2V0cywgaW4gb3JkZXIsXG4gICAgc3RhcnRpbmcgZnJvbSBgZnJvbWAuXG4gICAgKi9cbiAgICBzdGF0aWMgaXRlcihzZXRzLCBmcm9tID0gMCkge1xuICAgICAgICByZXR1cm4gSGVhcEN1cnNvci5mcm9tKHNldHMpLmdvdG8oZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0d28gZ3JvdXBzIG9mIHNldHMsIGNhbGxpbmcgbWV0aG9kcyBvbiBgY29tcGFyYXRvcmBcbiAgICB0byBub3RpZnkgaXQgb2YgcG9zc2libGUgZGlmZmVyZW5jZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgY29tcGFyZShvbGRTZXRzLCBuZXdTZXRzLCBcbiAgICAvKipcbiAgICBUaGlzIGluZGljYXRlcyBob3cgdGhlIHVuZGVybHlpbmcgZGF0YSBjaGFuZ2VkIGJldHdlZW4gdGhlc2VcbiAgICByYW5nZXMsIGFuZCBpcyBuZWVkZWQgdG8gc3luY2hyb25pemUgdGhlIGl0ZXJhdGlvbi5cbiAgICAqL1xuICAgIHRleHREaWZmLCBjb21wYXJhdG9yLCBcbiAgICAvKipcbiAgICBDYW4gYmUgdXNlZCB0byBpZ25vcmUgYWxsIG5vbi1wb2ludCByYW5nZXMsIGFuZCBwb2ludHMgYmVsb3dcbiAgICB0aGUgZ2l2ZW4gc2l6ZS4gV2hlbiAtMSwgYWxsIHJhbmdlcyBhcmUgY29tcGFyZWQuXG4gICAgKi9cbiAgICBtaW5Qb2ludFNpemUgPSAtMSkge1xuICAgICAgICBsZXQgYSA9IG9sZFNldHMuZmlsdGVyKHNldCA9PiBzZXQubWF4UG9pbnQgPiAwIHx8ICFzZXQuaXNFbXB0eSAmJiBzZXQubWF4UG9pbnQgPj0gbWluUG9pbnRTaXplKTtcbiAgICAgICAgbGV0IGIgPSBuZXdTZXRzLmZpbHRlcihzZXQgPT4gc2V0Lm1heFBvaW50ID4gMCB8fCAhc2V0LmlzRW1wdHkgJiYgc2V0Lm1heFBvaW50ID49IG1pblBvaW50U2l6ZSk7XG4gICAgICAgIGxldCBzaGFyZWRDaHVua3MgPSBmaW5kU2hhcmVkQ2h1bmtzKGEsIGIsIHRleHREaWZmKTtcbiAgICAgICAgbGV0IHNpZGVBID0gbmV3IFNwYW5DdXJzb3IoYSwgc2hhcmVkQ2h1bmtzLCBtaW5Qb2ludFNpemUpO1xuICAgICAgICBsZXQgc2lkZUIgPSBuZXcgU3BhbkN1cnNvcihiLCBzaGFyZWRDaHVua3MsIG1pblBvaW50U2l6ZSk7XG4gICAgICAgIHRleHREaWZmLml0ZXJHYXBzKChmcm9tQSwgZnJvbUIsIGxlbmd0aCkgPT4gY29tcGFyZShzaWRlQSwgZnJvbUEsIHNpZGVCLCBmcm9tQiwgbGVuZ3RoLCBjb21wYXJhdG9yKSk7XG4gICAgICAgIGlmICh0ZXh0RGlmZi5lbXB0eSAmJiB0ZXh0RGlmZi5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIGNvbXBhcmUoc2lkZUEsIDAsIHNpZGVCLCAwLCAwLCBjb21wYXJhdG9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGUgY29udGVudHMgb2YgdHdvIGdyb3VwcyBvZiByYW5nZSBzZXRzLCByZXR1cm5pbmcgdHJ1ZVxuICAgIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQgaW4gdGhlIGdpdmVuIHJhbmdlLlxuICAgICovXG4gICAgc3RhdGljIGVxKG9sZFNldHMsIG5ld1NldHMsIGZyb20gPSAwLCB0bykge1xuICAgICAgICBpZiAodG8gPT0gbnVsbClcbiAgICAgICAgICAgIHRvID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLyAtIDE7XG4gICAgICAgIGxldCBhID0gb2xkU2V0cy5maWx0ZXIoc2V0ID0+ICFzZXQuaXNFbXB0eSAmJiBuZXdTZXRzLmluZGV4T2Yoc2V0KSA8IDApO1xuICAgICAgICBsZXQgYiA9IG5ld1NldHMuZmlsdGVyKHNldCA9PiAhc2V0LmlzRW1wdHkgJiYgb2xkU2V0cy5pbmRleE9mKHNldCkgPCAwKTtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWEubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCBzaGFyZWRDaHVua3MgPSBmaW5kU2hhcmVkQ2h1bmtzKGEsIGIpO1xuICAgICAgICBsZXQgc2lkZUEgPSBuZXcgU3BhbkN1cnNvcihhLCBzaGFyZWRDaHVua3MsIDApLmdvdG8oZnJvbSksIHNpZGVCID0gbmV3IFNwYW5DdXJzb3IoYiwgc2hhcmVkQ2h1bmtzLCAwKS5nb3RvKGZyb20pO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoc2lkZUEudG8gIT0gc2lkZUIudG8gfHxcbiAgICAgICAgICAgICAgICAhc2FtZVZhbHVlcyhzaWRlQS5hY3RpdmUsIHNpZGVCLmFjdGl2ZSkgfHxcbiAgICAgICAgICAgICAgICBzaWRlQS5wb2ludCAmJiAoIXNpZGVCLnBvaW50IHx8ICFzaWRlQS5wb2ludC5lcShzaWRlQi5wb2ludCkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzaWRlQS50byA+IHRvKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgc2lkZUEubmV4dCgpO1xuICAgICAgICAgICAgc2lkZUIubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciBhIGdyb3VwIG9mIHJhbmdlIHNldHMgYXQgdGhlIHNhbWUgdGltZSwgbm90aWZ5aW5nXG4gICAgdGhlIGl0ZXJhdG9yIGFib3V0IHRoZSByYW5nZXMgY292ZXJpbmcgZXZlcnkgZ2l2ZW4gcGllY2Ugb2ZcbiAgICBjb250ZW50LiBSZXR1cm5zIHRoZSBvcGVuIGNvdW50IChzZWVcbiAgICBbYFNwYW5JdGVyYXRvci5zcGFuYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TcGFuSXRlcmF0b3Iuc3BhbikpIGF0IHRoZSBlbmRcbiAgICBvZiB0aGUgaXRlcmF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIHNwYW5zKHNldHMsIGZyb20sIHRvLCBpdGVyYXRvciwgXG4gICAgLyoqXG4gICAgV2hlbiBnaXZlbiBhbmQgZ3JlYXRlciB0aGFuIC0xLCBvbmx5IHBvaW50cyBvZiBhdCBsZWFzdCB0aGlzXG4gICAgc2l6ZSBhcmUgdGFrZW4gaW50byBhY2NvdW50LlxuICAgICovXG4gICAgbWluUG9pbnRTaXplID0gLTEpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBTcGFuQ3Vyc29yKHNldHMsIG51bGwsIG1pblBvaW50U2l6ZSkuZ290byhmcm9tKSwgcG9zID0gZnJvbTtcbiAgICAgICAgbGV0IG9wZW5SYW5nZXMgPSBjdXJzb3Iub3BlblN0YXJ0O1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgY3VyVG8gPSBNYXRoLm1pbihjdXJzb3IudG8sIHRvKTtcbiAgICAgICAgICAgIGlmIChjdXJzb3IucG9pbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWN0aXZlID0gY3Vyc29yLmFjdGl2ZUZvclBvaW50KGN1cnNvci50byk7XG4gICAgICAgICAgICAgICAgbGV0IG9wZW5Db3VudCA9IGN1cnNvci5wb2ludEZyb20gPCBmcm9tID8gYWN0aXZlLmxlbmd0aCArIDEgOiBNYXRoLm1pbihhY3RpdmUubGVuZ3RoLCBvcGVuUmFuZ2VzKTtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5wb2ludChwb3MsIGN1clRvLCBjdXJzb3IucG9pbnQsIGFjdGl2ZSwgb3BlbkNvdW50LCBjdXJzb3IucG9pbnRSYW5rKTtcbiAgICAgICAgICAgICAgICBvcGVuUmFuZ2VzID0gTWF0aC5taW4oY3Vyc29yLm9wZW5FbmQoY3VyVG8pLCBhY3RpdmUubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1clRvID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3Iuc3Bhbihwb3MsIGN1clRvLCBjdXJzb3IuYWN0aXZlLCBvcGVuUmFuZ2VzKTtcbiAgICAgICAgICAgICAgICBvcGVuUmFuZ2VzID0gY3Vyc29yLm9wZW5FbmQoY3VyVG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnNvci50byA+IHRvKVxuICAgICAgICAgICAgICAgIHJldHVybiBvcGVuUmFuZ2VzICsgKGN1cnNvci5wb2ludCAmJiBjdXJzb3IudG8gPiB0byA/IDEgOiAwKTtcbiAgICAgICAgICAgIHBvcyA9IGN1cnNvci50bztcbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcmFuZ2Ugc2V0IGZvciB0aGUgZ2l2ZW4gcmFuZ2Ugb3IgYXJyYXkgb2YgcmFuZ2VzLiBCeVxuICAgIGRlZmF1bHQsIHRoaXMgZXhwZWN0cyB0aGUgcmFuZ2VzIHRvIGJlIF9zb3J0ZWRfIChieSBzdGFydFxuICAgIHBvc2l0aW9uIGFuZCwgaWYgdHdvIHN0YXJ0IGF0IHRoZSBzYW1lIHBvc2l0aW9uLFxuICAgIGB2YWx1ZS5zdGFydFNpZGVgKS4gWW91IGNhbiBwYXNzIGB0cnVlYCBhcyBzZWNvbmQgYXJndW1lbnQgdG9cbiAgICBjYXVzZSB0aGUgbWV0aG9kIHRvIHNvcnQgdGhlbS5cbiAgICAqL1xuICAgIHN0YXRpYyBvZihyYW5nZXMsIHNvcnQgPSBmYWxzZSkge1xuICAgICAgICBsZXQgYnVpbGQgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgICAgIGZvciAobGV0IHJhbmdlIG9mIHJhbmdlcyBpbnN0YW5jZW9mIFJhbmdlID8gW3Jhbmdlc10gOiBzb3J0ID8gbGF6eVNvcnQocmFuZ2VzKSA6IHJhbmdlcylcbiAgICAgICAgICAgIGJ1aWxkLmFkZChyYW5nZS5mcm9tLCByYW5nZS50bywgcmFuZ2UudmFsdWUpO1xuICAgICAgICByZXR1cm4gYnVpbGQuZmluaXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEpvaW4gYW4gYXJyYXkgb2YgcmFuZ2Ugc2V0cyBpbnRvIGEgc2luZ2xlIHNldC5cbiAgICAqL1xuICAgIHN0YXRpYyBqb2luKHNldHMpIHtcbiAgICAgICAgaWYgKCFzZXRzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBSYW5nZVNldC5lbXB0eTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHNldHNbc2V0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHNldHMubGVuZ3RoIC0gMjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGxheWVyID0gc2V0c1tpXTsgbGF5ZXIgIT0gUmFuZ2VTZXQuZW1wdHk7IGxheWVyID0gbGF5ZXIubmV4dExheWVyKVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBSYW5nZVNldChsYXllci5jaHVua1BvcywgbGF5ZXIuY2h1bmssIHJlc3VsdCwgTWF0aC5tYXgobGF5ZXIubWF4UG9pbnQsIHJlc3VsdC5tYXhQb2ludCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG5UaGUgZW1wdHkgc2V0IG9mIHJhbmdlcy5cbiovXG5SYW5nZVNldC5lbXB0eSA9IC8qQF9fUFVSRV9fKi9uZXcgUmFuZ2VTZXQoW10sIFtdLCBudWxsLCAtMSk7XG5mdW5jdGlvbiBsYXp5U29ydChyYW5nZXMpIHtcbiAgICBpZiAocmFuZ2VzLmxlbmd0aCA+IDEpXG4gICAgICAgIGZvciAobGV0IHByZXYgPSByYW5nZXNbMF0sIGkgPSAxOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgaWYgKGNtcFJhbmdlKHByZXYsIGN1cikgPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZXMuc2xpY2UoKS5zb3J0KGNtcFJhbmdlKTtcbiAgICAgICAgICAgIHByZXYgPSBjdXI7XG4gICAgICAgIH1cbiAgICByZXR1cm4gcmFuZ2VzO1xufVxuUmFuZ2VTZXQuZW1wdHkubmV4dExheWVyID0gUmFuZ2VTZXQuZW1wdHk7XG4vKipcbkEgcmFuZ2Ugc2V0IGJ1aWxkZXIgaXMgYSBkYXRhIHN0cnVjdHVyZSB0aGF0IGhlbHBzIGJ1aWxkIHVwIGFcbltyYW5nZSBzZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2VTZXQpIGRpcmVjdGx5LCB3aXRob3V0IGZpcnN0IGFsbG9jYXRpbmdcbmFuIGFycmF5IG9mIFtgUmFuZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlKSBvYmplY3RzLlxuKi9cbmNsYXNzIFJhbmdlU2V0QnVpbGRlciB7XG4gICAgZmluaXNoQ2h1bmsobmV3QXJyYXlzKSB7XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2gobmV3IENodW5rKHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy52YWx1ZSwgdGhpcy5tYXhQb2ludCkpO1xuICAgICAgICB0aGlzLmNodW5rUG9zLnB1c2godGhpcy5jaHVua1N0YXJ0KTtcbiAgICAgICAgdGhpcy5jaHVua1N0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMuc2V0TWF4UG9pbnQgPSBNYXRoLm1heCh0aGlzLnNldE1heFBvaW50LCB0aGlzLm1heFBvaW50KTtcbiAgICAgICAgdGhpcy5tYXhQb2ludCA9IC0xO1xuICAgICAgICBpZiAobmV3QXJyYXlzKSB7XG4gICAgICAgICAgICB0aGlzLmZyb20gPSBbXTtcbiAgICAgICAgICAgIHRoaXMudG8gPSBbXTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZW1wdHkgYnVpbGRlci5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rUG9zID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtTdGFydCA9IC0xO1xuICAgICAgICB0aGlzLmxhc3QgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RGcm9tID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgICAgIHRoaXMubGFzdFRvID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgICAgIHRoaXMuZnJvbSA9IFtdO1xuICAgICAgICB0aGlzLnRvID0gW107XG4gICAgICAgIHRoaXMudmFsdWUgPSBbXTtcbiAgICAgICAgdGhpcy5tYXhQb2ludCA9IC0xO1xuICAgICAgICB0aGlzLnNldE1heFBvaW50ID0gLTE7XG4gICAgICAgIHRoaXMubmV4dExheWVyID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIGEgcmFuZ2UuIFJhbmdlcyBzaG91bGQgYmUgYWRkZWQgaW4gc29ydGVkIChieSBgZnJvbWAgYW5kXG4gICAgYHZhbHVlLnN0YXJ0U2lkZWApIG9yZGVyLlxuICAgICovXG4gICAgYWRkKGZyb20sIHRvLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuYWRkSW5uZXIoZnJvbSwgdG8sIHZhbHVlKSlcbiAgICAgICAgICAgICh0aGlzLm5leHRMYXllciB8fCAodGhpcy5uZXh0TGF5ZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKSkuYWRkKGZyb20sIHRvLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYWRkSW5uZXIoZnJvbSwgdG8sIHZhbHVlKSB7XG4gICAgICAgIGxldCBkaWZmID0gZnJvbSAtIHRoaXMubGFzdFRvIHx8IHZhbHVlLnN0YXJ0U2lkZSAtIHRoaXMubGFzdC5lbmRTaWRlO1xuICAgICAgICBpZiAoZGlmZiA8PSAwICYmIChmcm9tIC0gdGhpcy5sYXN0RnJvbSB8fCB2YWx1ZS5zdGFydFNpZGUgLSB0aGlzLmxhc3Quc3RhcnRTaWRlKSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSYW5nZXMgbXVzdCBiZSBhZGRlZCBzb3J0ZWQgYnkgYGZyb21gIHBvc2l0aW9uIGFuZCBgc3RhcnRTaWRlYFwiKTtcbiAgICAgICAgaWYgKGRpZmYgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5mcm9tLmxlbmd0aCA9PSAyNTAgLyogQy5DaHVua1NpemUgKi8pXG4gICAgICAgICAgICB0aGlzLmZpbmlzaENodW5rKHRydWUpO1xuICAgICAgICBpZiAodGhpcy5jaHVua1N0YXJ0IDwgMClcbiAgICAgICAgICAgIHRoaXMuY2h1bmtTdGFydCA9IGZyb207XG4gICAgICAgIHRoaXMuZnJvbS5wdXNoKGZyb20gLSB0aGlzLmNodW5rU3RhcnQpO1xuICAgICAgICB0aGlzLnRvLnB1c2godG8gLSB0aGlzLmNodW5rU3RhcnQpO1xuICAgICAgICB0aGlzLmxhc3QgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5sYXN0RnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMubGFzdFRvID0gdG87XG4gICAgICAgIHRoaXMudmFsdWUucHVzaCh2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZS5wb2ludClcbiAgICAgICAgICAgIHRoaXMubWF4UG9pbnQgPSBNYXRoLm1heCh0aGlzLm1heFBvaW50LCB0byAtIGZyb20pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhZGRDaHVuayhmcm9tLCBjaHVuaykge1xuICAgICAgICBpZiAoKGZyb20gLSB0aGlzLmxhc3RUbyB8fCBjaHVuay52YWx1ZVswXS5zdGFydFNpZGUgLSB0aGlzLmxhc3QuZW5kU2lkZSkgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5mcm9tLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuZmluaXNoQ2h1bmsodHJ1ZSk7XG4gICAgICAgIHRoaXMuc2V0TWF4UG9pbnQgPSBNYXRoLm1heCh0aGlzLnNldE1heFBvaW50LCBjaHVuay5tYXhQb2ludCk7XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICB0aGlzLmNodW5rUG9zLnB1c2goZnJvbSk7XG4gICAgICAgIGxldCBsYXN0ID0gY2h1bmsudmFsdWUubGVuZ3RoIC0gMTtcbiAgICAgICAgdGhpcy5sYXN0ID0gY2h1bmsudmFsdWVbbGFzdF07XG4gICAgICAgIHRoaXMubGFzdEZyb20gPSBjaHVuay5mcm9tW2xhc3RdICsgZnJvbTtcbiAgICAgICAgdGhpcy5sYXN0VG8gPSBjaHVuay50b1tsYXN0XSArIGZyb207XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5pc2ggdGhlIHJhbmdlIHNldC4gUmV0dXJucyB0aGUgbmV3IHNldC4gVGhlIGJ1aWxkZXIgY2FuJ3QgYmVcbiAgICB1c2VkIGFueW1vcmUgYWZ0ZXIgdGhpcyBoYXMgYmVlbiBjYWxsZWQuXG4gICAgKi9cbiAgICBmaW5pc2goKSB7IHJldHVybiB0aGlzLmZpbmlzaElubmVyKFJhbmdlU2V0LmVtcHR5KTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmluaXNoSW5uZXIobmV4dCkge1xuICAgICAgICBpZiAodGhpcy5mcm9tLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuZmluaXNoQ2h1bmsoZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5jaHVua3MubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFJhbmdlU2V0LmNyZWF0ZSh0aGlzLmNodW5rUG9zLCB0aGlzLmNodW5rcywgdGhpcy5uZXh0TGF5ZXIgPyB0aGlzLm5leHRMYXllci5maW5pc2hJbm5lcihuZXh0KSA6IG5leHQsIHRoaXMuc2V0TWF4UG9pbnQpO1xuICAgICAgICB0aGlzLmZyb20gPSBudWxsOyAvLyBNYWtlIHN1cmUgZnVydGhlciBgYWRkYCBjYWxscyBwcm9kdWNlIGVycm9yc1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRTaGFyZWRDaHVua3MoYSwgYiwgdGV4dERpZmYpIHtcbiAgICBsZXQgaW5BID0gbmV3IE1hcCgpO1xuICAgIGZvciAobGV0IHNldCBvZiBhKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5jaHVuay5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChzZXQuY2h1bmtbaV0ubWF4UG9pbnQgPD0gMClcbiAgICAgICAgICAgICAgICBpbkEuc2V0KHNldC5jaHVua1tpXSwgc2V0LmNodW5rUG9zW2ldKTtcbiAgICBsZXQgc2hhcmVkID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IHNldCBvZiBiKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5jaHVuay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGtub3duID0gaW5BLmdldChzZXQuY2h1bmtbaV0pO1xuICAgICAgICAgICAgaWYgKGtub3duICE9IG51bGwgJiYgKHRleHREaWZmID8gdGV4dERpZmYubWFwUG9zKGtub3duKSA6IGtub3duKSA9PSBzZXQuY2h1bmtQb3NbaV0gJiZcbiAgICAgICAgICAgICAgICAhKHRleHREaWZmID09PSBudWxsIHx8IHRleHREaWZmID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0ZXh0RGlmZi50b3VjaGVzUmFuZ2Uoa25vd24sIGtub3duICsgc2V0LmNodW5rW2ldLmxlbmd0aCkpKVxuICAgICAgICAgICAgICAgIHNoYXJlZC5hZGQoc2V0LmNodW5rW2ldKTtcbiAgICAgICAgfVxuICAgIHJldHVybiBzaGFyZWQ7XG59XG5jbGFzcyBMYXllckN1cnNvciB7XG4gICAgY29uc3RydWN0b3IobGF5ZXIsIHNraXAsIG1pblBvaW50LCByYW5rID0gMCkge1xuICAgICAgICB0aGlzLmxheWVyID0gbGF5ZXI7XG4gICAgICAgIHRoaXMuc2tpcCA9IHNraXA7XG4gICAgICAgIHRoaXMubWluUG9pbnQgPSBtaW5Qb2ludDtcbiAgICAgICAgdGhpcy5yYW5rID0gcmFuaztcbiAgICB9XG4gICAgZ2V0IHN0YXJ0U2lkZSgpIHsgcmV0dXJuIHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLnN0YXJ0U2lkZSA6IDA7IH1cbiAgICBnZXQgZW5kU2lkZSgpIHsgcmV0dXJuIHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLmVuZFNpZGUgOiAwOyB9XG4gICAgZ290byhwb3MsIHNpZGUgPSAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLykge1xuICAgICAgICB0aGlzLmNodW5rSW5kZXggPSB0aGlzLnJhbmdlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLmdvdG9Jbm5lcihwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdvdG9Jbm5lcihwb3MsIHNpZGUsIGZvcndhcmQpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY2h1bmtJbmRleCA8IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XTtcbiAgICAgICAgICAgIGlmICghKHRoaXMuc2tpcCAmJiB0aGlzLnNraXAuaGFzKG5leHQpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5sYXllci5jaHVua0VuZCh0aGlzLmNodW5rSW5kZXgpIDwgcG9zIHx8XG4gICAgICAgICAgICAgICAgbmV4dC5tYXhQb2ludCA8IHRoaXMubWluUG9pbnQpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XG4gICAgICAgICAgICBmb3J3YXJkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2h1bmtJbmRleCA8IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2VJbmRleCA9IHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XS5maW5kSW5kZXgocG9zIC0gdGhpcy5sYXllci5jaHVua1Bvc1t0aGlzLmNodW5rSW5kZXhdLCBzaWRlLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghZm9yd2FyZCB8fCB0aGlzLnJhbmdlSW5kZXggPCByYW5nZUluZGV4KVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmFuZ2VJbmRleChyYW5nZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgZm9yd2FyZChwb3MsIHNpZGUpIHtcbiAgICAgICAgaWYgKCh0aGlzLnRvIC0gcG9zIHx8IHRoaXMuZW5kU2lkZSAtIHNpZGUpIDwgMClcbiAgICAgICAgICAgIHRoaXMuZ290b0lubmVyKHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNodW5rSW5kZXggPT0gdGhpcy5sYXllci5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb20gPSB0aGlzLnRvID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBjaHVua1BvcyA9IHRoaXMubGF5ZXIuY2h1bmtQb3NbdGhpcy5jaHVua0luZGV4XSwgY2h1bmsgPSB0aGlzLmxheWVyLmNodW5rW3RoaXMuY2h1bmtJbmRleF07XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBjaHVua1BvcyArIGNodW5rLmZyb21bdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICAgICAgICAgIHRoaXMudG8gPSBjaHVua1BvcyArIGNodW5rLnRvW3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGNodW5rLnZhbHVlW3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSYW5nZUluZGV4KHRoaXMucmFuZ2VJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1pblBvaW50IDwgMCB8fCB0aGlzLnZhbHVlLnBvaW50ICYmIHRoaXMudG8gLSB0aGlzLmZyb20gPj0gdGhpcy5taW5Qb2ludClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0UmFuZ2VJbmRleChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XG4gICAgICAgICAgICBpZiAodGhpcy5za2lwKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuY2h1bmtJbmRleCA8IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoICYmIHRoaXMuc2tpcC5oYXModGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJhbmdlSW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV4dENodW5rKCkge1xuICAgICAgICB0aGlzLmNodW5rSW5kZXgrKztcbiAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIGNvbXBhcmUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbSAtIG90aGVyLmZyb20gfHwgdGhpcy5zdGFydFNpZGUgLSBvdGhlci5zdGFydFNpZGUgfHwgdGhpcy5yYW5rIC0gb3RoZXIucmFuayB8fFxuICAgICAgICAgICAgdGhpcy50byAtIG90aGVyLnRvIHx8IHRoaXMuZW5kU2lkZSAtIG90aGVyLmVuZFNpZGU7XG4gICAgfVxufVxuY2xhc3MgSGVhcEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoaGVhcCkge1xuICAgICAgICB0aGlzLmhlYXAgPSBoZWFwO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShzZXRzLCBza2lwID0gbnVsbCwgbWluUG9pbnQgPSAtMSkge1xuICAgICAgICBsZXQgaGVhcCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGN1ciA9IHNldHNbaV07ICFjdXIuaXNFbXB0eTsgY3VyID0gY3VyLm5leHRMYXllcikge1xuICAgICAgICAgICAgICAgIGlmIChjdXIubWF4UG9pbnQgPj0gbWluUG9pbnQpXG4gICAgICAgICAgICAgICAgICAgIGhlYXAucHVzaChuZXcgTGF5ZXJDdXJzb3IoY3VyLCBza2lwLCBtaW5Qb2ludCwgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFwLmxlbmd0aCA9PSAxID8gaGVhcFswXSA6IG5ldyBIZWFwQ3Vyc29yKGhlYXApO1xuICAgIH1cbiAgICBnZXQgc3RhcnRTaWRlKCkgeyByZXR1cm4gdGhpcy52YWx1ZSA/IHRoaXMudmFsdWUuc3RhcnRTaWRlIDogMDsgfVxuICAgIGdvdG8ocG9zLCBzaWRlID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi8pIHtcbiAgICAgICAgZm9yIChsZXQgY3VyIG9mIHRoaXMuaGVhcClcbiAgICAgICAgICAgIGN1ci5nb3RvKHBvcywgc2lkZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmhlYXAubGVuZ3RoID4+IDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgaGVhcEJ1YmJsZSh0aGlzLmhlYXAsIGkpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZvcndhcmQocG9zLCBzaWRlKSB7XG4gICAgICAgIGZvciAobGV0IGN1ciBvZiB0aGlzLmhlYXApXG4gICAgICAgICAgICBjdXIuZm9yd2FyZChwb3MsIHNpZGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5oZWFwLmxlbmd0aCA+PiAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgIGhlYXBCdWJibGUodGhpcy5oZWFwLCBpKTtcbiAgICAgICAgaWYgKCh0aGlzLnRvIC0gcG9zIHx8IHRoaXMudmFsdWUuZW5kU2lkZSAtIHNpZGUpIDwgMClcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5oZWFwLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmZyb20gPSB0aGlzLnRvID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yYW5rID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy5oZWFwWzBdO1xuICAgICAgICAgICAgdGhpcy5mcm9tID0gdG9wLmZyb207XG4gICAgICAgICAgICB0aGlzLnRvID0gdG9wLnRvO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRvcC52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMucmFuayA9IHRvcC5yYW5rO1xuICAgICAgICAgICAgaWYgKHRvcC52YWx1ZSlcbiAgICAgICAgICAgICAgICB0b3AubmV4dCgpO1xuICAgICAgICAgICAgaGVhcEJ1YmJsZSh0aGlzLmhlYXAsIDApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaGVhcEJ1YmJsZShoZWFwLCBpbmRleCkge1xuICAgIGZvciAobGV0IGN1ciA9IGhlYXBbaW5kZXhdOzspIHtcbiAgICAgICAgbGV0IGNoaWxkSW5kZXggPSAoaW5kZXggPDwgMSkgKyAxO1xuICAgICAgICBpZiAoY2hpbGRJbmRleCA+PSBoZWFwLmxlbmd0aClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgY2hpbGQgPSBoZWFwW2NoaWxkSW5kZXhdO1xuICAgICAgICBpZiAoY2hpbGRJbmRleCArIDEgPCBoZWFwLmxlbmd0aCAmJiBjaGlsZC5jb21wYXJlKGhlYXBbY2hpbGRJbmRleCArIDFdKSA+PSAwKSB7XG4gICAgICAgICAgICBjaGlsZCA9IGhlYXBbY2hpbGRJbmRleCArIDFdO1xuICAgICAgICAgICAgY2hpbGRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXIuY29tcGFyZShjaGlsZCkgPCAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGhlYXBbY2hpbGRJbmRleF0gPSBjdXI7XG4gICAgICAgIGhlYXBbaW5kZXhdID0gY2hpbGQ7XG4gICAgICAgIGluZGV4ID0gY2hpbGRJbmRleDtcbiAgICB9XG59XG5jbGFzcyBTcGFuQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihzZXRzLCBza2lwLCBtaW5Qb2ludCkge1xuICAgICAgICB0aGlzLm1pblBvaW50ID0gbWluUG9pbnQ7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlVG8gPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmVSYW5rID0gW107XG4gICAgICAgIHRoaXMubWluQWN0aXZlID0gLTE7XG4gICAgICAgIC8vIEEgY3VycmVudGx5IGFjdGl2ZSBwb2ludCByYW5nZSwgaWYgYW55XG4gICAgICAgIHRoaXMucG9pbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnBvaW50RnJvbSA9IDA7XG4gICAgICAgIHRoaXMucG9pbnRSYW5rID0gMDtcbiAgICAgICAgdGhpcy50byA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgICAgICB0aGlzLmVuZFNpZGUgPSAwO1xuICAgICAgICAvLyBUaGUgYW1vdW50IG9mIG9wZW4gYWN0aXZlIHJhbmdlcyBhdCB0aGUgc3RhcnQgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAvLyBOb3QgaW5jbHVkaW5nIHBvaW50cy5cbiAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBIZWFwQ3Vyc29yLmZyb20oc2V0cywgc2tpcCwgbWluUG9pbnQpO1xuICAgIH1cbiAgICBnb3RvKHBvcywgc2lkZSA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovKSB7XG4gICAgICAgIHRoaXMuY3Vyc29yLmdvdG8ocG9zLCBzaWRlKTtcbiAgICAgICAgdGhpcy5hY3RpdmUubGVuZ3RoID0gdGhpcy5hY3RpdmVUby5sZW5ndGggPSB0aGlzLmFjdGl2ZVJhbmsubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5taW5BY3RpdmUgPSAtMTtcbiAgICAgICAgdGhpcy50byA9IHBvcztcbiAgICAgICAgdGhpcy5lbmRTaWRlID0gc2lkZTtcbiAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmb3J3YXJkKHBvcywgc2lkZSkge1xuICAgICAgICB3aGlsZSAodGhpcy5taW5BY3RpdmUgPiAtMSAmJiAodGhpcy5hY3RpdmVUb1t0aGlzLm1pbkFjdGl2ZV0gLSBwb3MgfHwgdGhpcy5hY3RpdmVbdGhpcy5taW5BY3RpdmVdLmVuZFNpZGUgLSBzaWRlKSA8IDApXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFjdGl2ZSh0aGlzLm1pbkFjdGl2ZSk7XG4gICAgICAgIHRoaXMuY3Vyc29yLmZvcndhcmQocG9zLCBzaWRlKTtcbiAgICB9XG4gICAgcmVtb3ZlQWN0aXZlKGluZGV4KSB7XG4gICAgICAgIHJlbW92ZSh0aGlzLmFjdGl2ZSwgaW5kZXgpO1xuICAgICAgICByZW1vdmUodGhpcy5hY3RpdmVUbywgaW5kZXgpO1xuICAgICAgICByZW1vdmUodGhpcy5hY3RpdmVSYW5rLCBpbmRleCk7XG4gICAgICAgIHRoaXMubWluQWN0aXZlID0gZmluZE1pbkluZGV4KHRoaXMuYWN0aXZlLCB0aGlzLmFjdGl2ZVRvKTtcbiAgICB9XG4gICAgYWRkQWN0aXZlKHRyYWNrT3Blbikge1xuICAgICAgICBsZXQgaSA9IDAsIHsgdmFsdWUsIHRvLCByYW5rIH0gPSB0aGlzLmN1cnNvcjtcbiAgICAgICAgLy8gT3JnYW5pemUgYWN0aXZlIG1hcmtzIGJ5IHJhbmsgZmlyc3QsIHRoZW4gYnkgc2l6ZVxuICAgICAgICB3aGlsZSAoaSA8IHRoaXMuYWN0aXZlUmFuay5sZW5ndGggJiYgKHJhbmsgLSB0aGlzLmFjdGl2ZVJhbmtbaV0gfHwgdG8gLSB0aGlzLmFjdGl2ZVRvW2ldKSA+IDApXG4gICAgICAgICAgICBpKys7XG4gICAgICAgIGluc2VydCh0aGlzLmFjdGl2ZSwgaSwgdmFsdWUpO1xuICAgICAgICBpbnNlcnQodGhpcy5hY3RpdmVUbywgaSwgdG8pO1xuICAgICAgICBpbnNlcnQodGhpcy5hY3RpdmVSYW5rLCBpLCByYW5rKTtcbiAgICAgICAgaWYgKHRyYWNrT3BlbilcbiAgICAgICAgICAgIGluc2VydCh0cmFja09wZW4sIGksIHRoaXMuY3Vyc29yLmZyb20pO1xuICAgICAgICB0aGlzLm1pbkFjdGl2ZSA9IGZpbmRNaW5JbmRleCh0aGlzLmFjdGl2ZSwgdGhpcy5hY3RpdmVUbyk7XG4gICAgfVxuICAgIC8vIEFmdGVyIGNhbGxpbmcgdGhpcywgaWYgYHRoaXMucG9pbnRgICE9IG51bGwsIHRoZSBuZXh0IHJhbmdlIGlzIGFcbiAgICAvLyBwb2ludC4gT3RoZXJ3aXNlLCBpdCdzIGEgcmVndWxhciByYW5nZSwgY292ZXJlZCBieSBgdGhpcy5hY3RpdmVgLlxuICAgIG5leHQoKSB7XG4gICAgICAgIGxldCBmcm9tID0gdGhpcy50bywgd2FzUG9pbnQgPSB0aGlzLnBvaW50O1xuICAgICAgICB0aGlzLnBvaW50ID0gbnVsbDtcbiAgICAgICAgbGV0IHRyYWNrT3BlbiA9IHRoaXMub3BlblN0YXJ0IDwgMCA/IFtdIDogbnVsbDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGEgPSB0aGlzLm1pbkFjdGl2ZTtcbiAgICAgICAgICAgIGlmIChhID4gLTEgJiYgKHRoaXMuYWN0aXZlVG9bYV0gLSB0aGlzLmN1cnNvci5mcm9tIHx8IHRoaXMuYWN0aXZlW2FdLmVuZFNpZGUgLSB0aGlzLmN1cnNvci5zdGFydFNpZGUpIDwgMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVRvW2FdID4gZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvID0gdGhpcy5hY3RpdmVUb1thXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRTaWRlID0gdGhpcy5hY3RpdmVbYV0uZW5kU2lkZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQWN0aXZlKGEpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFja09wZW4pXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZSh0cmFja09wZW4sIGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuY3Vyc29yLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50byA9IHRoaXMuZW5kU2lkZSA9IDEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmN1cnNvci5mcm9tID4gZnJvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMudG8gPSB0aGlzLmN1cnNvci5mcm9tO1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kU2lkZSA9IHRoaXMuY3Vyc29yLnN0YXJ0U2lkZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0VmFsID0gdGhpcy5jdXJzb3IudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0VmFsLnBvaW50KSB7IC8vIE9wZW5pbmcgYSByYW5nZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEFjdGl2ZSh0cmFja09wZW4pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdhc1BvaW50ICYmIHRoaXMuY3Vyc29yLnRvID09IHRoaXMudG8gJiYgdGhpcy5jdXJzb3IuZnJvbSA8IHRoaXMuY3Vyc29yLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBhbnkgbm9uLWVtcHR5IHBvaW50cyB0aGF0IGVuZCBwcmVjaXNlbHkgYXQgdGhlIGVuZCBvZiB0aGUgcHJldiBwb2ludFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBOZXcgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludCA9IG5leHRWYWw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRGcm9tID0gdGhpcy5jdXJzb3IuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludFJhbmsgPSB0aGlzLmN1cnNvci5yYW5rO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvID0gdGhpcy5jdXJzb3IudG87XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kU2lkZSA9IG5leHRWYWwuZW5kU2lkZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcndhcmQodGhpcy50bywgdGhpcy5lbmRTaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFja09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMub3BlblN0YXJ0ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0cmFja09wZW4ubGVuZ3RoIC0gMTsgaSA+PSAwICYmIHRyYWNrT3BlbltpXSA8IGZyb207IGktLSlcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5TdGFydCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFjdGl2ZUZvclBvaW50KHRvKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlO1xuICAgICAgICBsZXQgYWN0aXZlID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmFjdGl2ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlUmFua1tpXSA8IHRoaXMucG9pbnRSYW5rKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlVG9baV0gPiB0byB8fCB0aGlzLmFjdGl2ZVRvW2ldID09IHRvICYmIHRoaXMuYWN0aXZlW2ldLmVuZFNpZGUgPj0gdGhpcy5wb2ludC5lbmRTaWRlKVxuICAgICAgICAgICAgICAgIGFjdGl2ZS5wdXNoKHRoaXMuYWN0aXZlW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0aXZlLnJldmVyc2UoKTtcbiAgICB9XG4gICAgb3BlbkVuZCh0bykge1xuICAgICAgICBsZXQgb3BlbiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmFjdGl2ZVRvLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiB0aGlzLmFjdGl2ZVRvW2ldID4gdG87IGktLSlcbiAgICAgICAgICAgIG9wZW4rKztcbiAgICAgICAgcmV0dXJuIG9wZW47XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGFyZShhLCBzdGFydEEsIGIsIHN0YXJ0QiwgbGVuZ3RoLCBjb21wYXJhdG9yKSB7XG4gICAgYS5nb3RvKHN0YXJ0QSk7XG4gICAgYi5nb3RvKHN0YXJ0Qik7XG4gICAgbGV0IGVuZEIgPSBzdGFydEIgKyBsZW5ndGg7XG4gICAgbGV0IHBvcyA9IHN0YXJ0QiwgZFBvcyA9IHN0YXJ0QiAtIHN0YXJ0QTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBkaWZmID0gKGEudG8gKyBkUG9zKSAtIGIudG8gfHwgYS5lbmRTaWRlIC0gYi5lbmRTaWRlO1xuICAgICAgICBsZXQgZW5kID0gZGlmZiA8IDAgPyBhLnRvICsgZFBvcyA6IGIudG8sIGNsaXBFbmQgPSBNYXRoLm1pbihlbmQsIGVuZEIpO1xuICAgICAgICBpZiAoYS5wb2ludCB8fCBiLnBvaW50KSB7XG4gICAgICAgICAgICBpZiAoIShhLnBvaW50ICYmIGIucG9pbnQgJiYgKGEucG9pbnQgPT0gYi5wb2ludCB8fCBhLnBvaW50LmVxKGIucG9pbnQpKSAmJlxuICAgICAgICAgICAgICAgIHNhbWVWYWx1ZXMoYS5hY3RpdmVGb3JQb2ludChhLnRvKSwgYi5hY3RpdmVGb3JQb2ludChiLnRvKSkpKVxuICAgICAgICAgICAgICAgIGNvbXBhcmF0b3IuY29tcGFyZVBvaW50KHBvcywgY2xpcEVuZCwgYS5wb2ludCwgYi5wb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2xpcEVuZCA+IHBvcyAmJiAhc2FtZVZhbHVlcyhhLmFjdGl2ZSwgYi5hY3RpdmUpKVxuICAgICAgICAgICAgICAgIGNvbXBhcmF0b3IuY29tcGFyZVJhbmdlKHBvcywgY2xpcEVuZCwgYS5hY3RpdmUsIGIuYWN0aXZlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID4gZW5kQilcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICAgIGlmIChkaWZmIDw9IDApXG4gICAgICAgICAgICBhLm5leHQoKTtcbiAgICAgICAgaWYgKGRpZmYgPj0gMClcbiAgICAgICAgICAgIGIubmV4dCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbWVWYWx1ZXMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKGFbaV0gIT0gYltpXSAmJiAhYVtpXS5lcShiW2ldKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlbW92ZShhcnJheSwgaW5kZXgpIHtcbiAgICBmb3IgKGxldCBpID0gaW5kZXgsIGUgPSBhcnJheS5sZW5ndGggLSAxOyBpIDwgZTsgaSsrKVxuICAgICAgICBhcnJheVtpXSA9IGFycmF5W2kgKyAxXTtcbiAgICBhcnJheS5wb3AoKTtcbn1cbmZ1bmN0aW9uIGluc2VydChhcnJheSwgaW5kZXgsIHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gaW5kZXg7IGktLSlcbiAgICAgICAgYXJyYXlbaSArIDFdID0gYXJyYXlbaV07XG4gICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7XG59XG5mdW5jdGlvbiBmaW5kTWluSW5kZXgodmFsdWUsIGFycmF5KSB7XG4gICAgbGV0IGZvdW5kID0gLTEsIGZvdW5kUG9zID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoKGFycmF5W2ldIC0gZm91bmRQb3MgfHwgdmFsdWVbaV0uZW5kU2lkZSAtIHZhbHVlW2ZvdW5kXS5lbmRTaWRlKSA8IDApIHtcbiAgICAgICAgICAgIGZvdW5kID0gaTtcbiAgICAgICAgICAgIGZvdW5kUG9zID0gYXJyYXlbaV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG59XG5cbi8qKlxuQ291bnQgdGhlIGNvbHVtbiBwb3NpdGlvbiBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IGludG8gdGhlIHN0cmluZyxcbnRha2luZyBleHRlbmRpbmcgY2hhcmFjdGVycyBhbmQgdGFiIHNpemUgaW50byBhY2NvdW50LlxuKi9cbmZ1bmN0aW9uIGNvdW50Q29sdW1uKHN0cmluZywgdGFiU2l6ZSwgdG8gPSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgbGV0IG4gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG87KSB7XG4gICAgICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdChpKSA9PSA5KSB7XG4gICAgICAgICAgICBuICs9IHRhYlNpemUgLSAobiAlIHRhYlNpemUpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbisrO1xuICAgICAgICAgICAgaSA9IGZpbmRDbHVzdGVyQnJlYWsoc3RyaW5nLCBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbjtcbn1cbi8qKlxuRmluZCB0aGUgb2Zmc2V0IHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGdpdmVuIGNvbHVtbiBwb3NpdGlvbiBpbiBhXG5zdHJpbmcsIHRha2luZyBleHRlbmRpbmcgY2hhcmFjdGVycyBhbmQgdGFiIHNpemUgaW50byBhY2NvdW50LiBCeVxuZGVmYXVsdCwgdGhlIHN0cmluZyBsZW5ndGggaXMgcmV0dXJuZWQgd2hlbiBpdCBpcyB0b28gc2hvcnQgdG9cbnJlYWNoIHRoZSBjb2x1bW4uIFBhc3MgYHN0cmljdGAgdHJ1ZSB0byBtYWtlIGl0IHJldHVybiAtMSBpbiB0aGF0XG5zaXR1YXRpb24uXG4qL1xuZnVuY3Rpb24gZmluZENvbHVtbihzdHJpbmcsIGNvbCwgdGFiU2l6ZSwgc3RyaWN0KSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSAwOzspIHtcbiAgICAgICAgaWYgKG4gPj0gY29sKVxuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIGlmIChpID09IHN0cmluZy5sZW5ndGgpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbiArPSBzdHJpbmcuY2hhckNvZGVBdChpKSA9PSA5ID8gdGFiU2l6ZSAtIChuICUgdGFiU2l6ZSkgOiAxO1xuICAgICAgICBpID0gZmluZENsdXN0ZXJCcmVhayhzdHJpbmcsIGkpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaWN0ID09PSB0cnVlID8gLTEgOiBzdHJpbmcubGVuZ3RoO1xufVxuXG5leHBvcnQgeyBBbm5vdGF0aW9uLCBBbm5vdGF0aW9uVHlwZSwgQ2hhbmdlRGVzYywgQ2hhbmdlU2V0LCBDaGFyQ2F0ZWdvcnksIENvbXBhcnRtZW50LCBFZGl0b3JTZWxlY3Rpb24sIEVkaXRvclN0YXRlLCBGYWNldCwgTGluZSwgTWFwTW9kZSwgUHJlYywgUmFuZ2UsIFJhbmdlU2V0LCBSYW5nZVNldEJ1aWxkZXIsIFJhbmdlVmFsdWUsIFNlbGVjdGlvblJhbmdlLCBTdGF0ZUVmZmVjdCwgU3RhdGVFZmZlY3RUeXBlLCBTdGF0ZUZpZWxkLCBUZXh0LCBUcmFuc2FjdGlvbiwgY29kZVBvaW50QXQsIGNvZGVQb2ludFNpemUsIGNvbWJpbmVDb25maWcsIGNvdW50Q29sdW1uLCBmaW5kQ2x1c3RlckJyZWFrLCBmaW5kQ29sdW1uLCBmcm9tQ29kZVBvaW50IH07XG4iXSwibmFtZXMiOlsiVGV4dCIsImxpbmVBdCIsInBvcyIsImxlbmd0aCIsIlJhbmdlRXJyb3IiLCJsaW5lSW5uZXIiLCJsaW5lIiwibiIsImxpbmVzIiwicmVwbGFjZSIsImZyb20iLCJ0byIsInRleHQiLCJjbGlwIiwicGFydHMiLCJkZWNvbXBvc2UiLCJUZXh0Tm9kZSIsImFwcGVuZCIsIm90aGVyIiwic2xpY2UiLCJlcSIsInN0YXJ0Iiwic2NhbklkZW50aWNhbCIsImVuZCIsImEiLCJSYXdUZXh0Q3Vyc29yIiwiYiIsInNraXAiLCJuZXh0IiwibGluZUJyZWFrIiwiZG9uZSIsInZhbHVlIiwiaXRlciIsImRpciIsIml0ZXJSYW5nZSIsIlBhcnRpYWxUZXh0Q3Vyc29yIiwiaXRlckxpbmVzIiwiaW5uZXIiLCJNYXRoIiwibWF4IiwiTGluZUN1cnNvciIsInRvU3RyaW5nIiwic2xpY2VTdHJpbmciLCJ0b0pTT04iLCJmbGF0dGVuIiwiY29uc3RydWN0b3IiLCJvZiIsImVtcHR5IiwiVGV4dExlYWYiLCJzcGxpdCIsInRleHRMZW5ndGgiLCJjaGlsZHJlbiIsInRhcmdldCIsImlzTGluZSIsIm9mZnNldCIsImkiLCJzdHJpbmciLCJMaW5lIiwib3BlbiIsInNsaWNlVGV4dCIsIm1pbiIsInByZXYiLCJwb3AiLCJqb2luZWQiLCJhcHBlbmRUZXh0IiwicHVzaCIsIm1pZCIsIm5ld0xlbiIsImxpbmVTZXAiLCJyZXN1bHQiLCJwYXJ0IiwibGVuIiwiY2hpbGQiLCJlbmRMaW5lIiwiY2hpbGRPcGVuIiwidXBkYXRlZCIsInRvdGFsTGluZXMiLCJjb3B5IiwiaUEiLCJpQiIsImVBIiwiZUIiLCJjaEEiLCJjaEIiLCJyZWR1Y2UiLCJsIiwiY2giLCJmbGF0IiwiY2h1bmsiLCJtYXhDaHVuayIsIm1pbkNodW5rIiwiY2h1bmtlZCIsImN1cnJlbnRMaW5lcyIsImN1cnJlbnRMZW4iLCJjdXJyZW50Q2h1bmsiLCJhZGQiLCJsYXN0Iiwibm9kZSIsImZsdXNoIiwiY29uY2F0IiwiZmlyc3QiLCJub2RlcyIsIm9mZnNldHMiLCJuZXh0SW5uZXIiLCJ0b3AiLCJvZmZzZXRWYWx1ZSIsInNpemUiLCJjdXJzb3IiLCJsaW1pdCIsImFmdGVyQnJlYWsiLCJTeW1ib2wiLCJwcm90b3R5cGUiLCJpdGVyYXRvciIsIm51bWJlciIsImV4dGVuZCIsIm1hcCIsInMiLCJwYXJzZUludCIsImlzRXh0ZW5kaW5nQ2hhciIsImNvZGUiLCJpc1JlZ2lvbmFsSW5kaWNhdG9yIiwiWldKIiwiZmluZENsdXN0ZXJCcmVhayIsInN0ciIsImZvcndhcmQiLCJpbmNsdWRlRXh0ZW5kaW5nIiwibmV4dENsdXN0ZXJCcmVhayIsInByZXZDbHVzdGVyQnJlYWsiLCJzdXJyb2dhdGVMb3ciLCJjaGFyQ29kZUF0Iiwic3Vycm9nYXRlSGlnaCIsImNvZGVQb2ludEF0IiwiY29kZVBvaW50U2l6ZSIsImNvdW50QmVmb3JlIiwiZm91bmQiLCJjb2RlMCIsImNvZGUxIiwiZnJvbUNvZGVQb2ludCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIkRlZmF1bHRTcGxpdCIsIk1hcE1vZGUiLCJDaGFuZ2VEZXNjIiwic2VjdGlvbnMiLCJuZXdMZW5ndGgiLCJpbnMiLCJpdGVyR2FwcyIsImYiLCJwb3NBIiwicG9zQiIsIml0ZXJDaGFuZ2VkUmFuZ2VzIiwiaW5kaXZpZHVhbCIsIml0ZXJDaGFuZ2VzIiwiaW52ZXJ0ZWREZXNjIiwiY29tcG9zZURlc2MiLCJjb21wb3NlU2V0cyIsIm1hcERlc2MiLCJiZWZvcmUiLCJtYXBTZXQiLCJtYXBQb3MiLCJhc3NvYyIsIm1vZGUiLCJTaW1wbGUiLCJlbmRBIiwiVHJhY2tEZWwiLCJUcmFja0JlZm9yZSIsIlRyYWNrQWZ0ZXIiLCJ0b3VjaGVzUmFuZ2UiLCJmcm9tSlNPTiIsImpzb24iLCJBcnJheSIsImlzQXJyYXkiLCJzb21lIiwiY3JlYXRlIiwiQ2hhbmdlU2V0IiwiaW5zZXJ0ZWQiLCJhcHBseSIsImRvYyIsImZyb21BIiwidG9BIiwiZnJvbUIiLCJfdG9CIiwiaW52ZXJ0IiwiaW5kZXgiLCJjb21wb3NlIiwiZGVzYyIsImZpbHRlciIsInJhbmdlcyIsInJlc3VsdFNlY3Rpb25zIiwicmVzdWx0SW5zZXJ0ZWQiLCJmaWx0ZXJlZFNlY3Rpb25zIiwiU2VjdGlvbkl0ZXIiLCJhZGRTZWN0aW9uIiwib2ZmIiwiYWRkSW5zZXJ0IiwiY2hhbmdlcyIsImZpbHRlcmVkIiwidG90YWwiLCJmb3JjZSIsInNldCIsInByb2Nlc3MiLCJzcGVjIiwic3ViIiwiaW5zZXJ0IiwiaW5zVGV4dCIsImluc0xlbiIsImUiLCJjcmVhdGVTZXQiLCJmb3JjZUpvaW4iLCJ2YWx1ZXMiLCJlbmRCIiwic2V0QSIsInNldEIiLCJta1NldCIsInBpZWNlIiwibGVmdCIsIkVycm9yIiwibGVuMiIsInNlY3Rpb25MZW4iLCJpbnNCIiwidGV4dEJpdCIsImZvcndhcmQyIiwidW5kZWZpbmVkIiwiU2VsZWN0aW9uUmFuZ2UiLCJmbGFncyIsImFuY2hvciIsImhlYWQiLCJiaWRpTGV2ZWwiLCJsZXZlbCIsImdvYWxDb2x1bW4iLCJjaGFuZ2UiLCJFZGl0b3JTZWxlY3Rpb24iLCJyYW5nZSIsImFicyIsImluY2x1ZGVBc3NvYyIsIm1haW5JbmRleCIsInIiLCJtYWluIiwiYXNTaW5nbGUiLCJhZGRSYW5nZSIsInJlcGxhY2VSYW5nZSIsIndoaWNoIiwic2luZ2xlIiwibm9ybWFsaXplZCIsInNvcnQiLCJpbmRleE9mIiwic3BsaWNlIiwiY2hlY2tTZWxlY3Rpb24iLCJzZWxlY3Rpb24iLCJkb2NMZW5ndGgiLCJuZXh0SUQiLCJGYWNldCIsImNvbWJpbmUiLCJjb21wYXJlSW5wdXQiLCJjb21wYXJlIiwiaXNTdGF0aWMiLCJlbmFibGVzIiwiaWQiLCJkZWZhdWx0IiwiZXh0ZW5zaW9ucyIsInJlYWRlciIsImRlZmluZSIsImNvbmZpZyIsInNhbWVBcnJheSIsInN0YXRpYyIsIkZhY2V0UHJvdmlkZXIiLCJjb21wdXRlIiwiZGVwcyIsImdldCIsImNvbXB1dGVOIiwiZmllbGQiLCJ4Iiwic3RhdGUiLCJldmVyeSIsImRlcGVuZGVuY2llcyIsImZhY2V0IiwidHlwZSIsImR5bmFtaWNTbG90IiwiYWRkcmVzc2VzIiwiX2EiLCJnZXR0ZXIiLCJpZHgiLCJtdWx0aSIsImRlcERvYyIsImRlcFNlbCIsImRlcEFkZHJzIiwiZGVwIiwidXBkYXRlIiwidHIiLCJkb2NDaGFuZ2VkIiwiZW5zdXJlQWxsIiwibmV3VmFsIiwiY29tcGFyZUFycmF5IiwicmVjb25maWd1cmUiLCJvbGRTdGF0ZSIsIm9sZEFkZHIiLCJhZGRyZXNzIiwib2xkVmFsIiwiZ2V0QWRkciIsIlN0YXRlRmllbGQiLCJhZGRycyIsImNoYW5nZWQiLCJhZGRyIiwiZW5zdXJlQWRkciIsImR5bmFtaWNGYWNldFNsb3QiLCJwcm92aWRlcnMiLCJwcm92aWRlckFkZHJzIiwicCIsInByb3ZpZGVyVHlwZXMiLCJkeW5hbWljIiwidmFsIiwiZGVwQ2hhbmdlZCIsIm9sZFByb3ZpZGVycyIsImZhY2V0cyIsIm9sZFZhbHVlIiwiaW5pdEZpZWxkIiwiY3JlYXRlRiIsInVwZGF0ZUYiLCJjb21wYXJlRiIsInByb3ZpZGVzIiwicHJvdmlkZSIsImluaXQiLCJmaW5kIiwic2xvdCIsImV4dGVuc2lvbiIsIlByZWNfIiwibG93ZXN0IiwibG93IiwiaGlnaCIsImhpZ2hlc3QiLCJwcmVjIiwiZXh0IiwiUHJlY0V4dGVuc2lvbiIsIlByZWMiLCJDb21wYXJ0bWVudCIsIkNvbXBhcnRtZW50SW5zdGFuY2UiLCJjb250ZW50IiwiY29tcGFydG1lbnQiLCJjb21wYXJ0bWVudHMiLCJDb25maWd1cmF0aW9uIiwiYmFzZSIsImR5bmFtaWNTbG90cyIsInN0YXRpY1ZhbHVlcyIsInN0YXR1c1RlbXBsYXRlIiwic3RhdGljRmFjZXQiLCJyZXNvbHZlIiwiZmllbGRzIiwiT2JqZWN0IiwibmV3Q29tcGFydG1lbnRzIiwiTWFwIiwib2xkRmFjZXRzIiwic2VlbiIsImtub3duIiwiZGVsZXRlIiwiaGFzIiwic3RhdHVzIiwiY29tcHV0ZVNsb3QiLCJsYW5ndWFnZURhdGEiLCJhbGxvd011bHRpcGxlU2VsZWN0aW9ucyIsInYiLCJsaW5lU2VwYXJhdG9yIiwiY2hhbmdlRmlsdGVyIiwidHJhbnNhY3Rpb25GaWx0ZXIiLCJ0cmFuc2FjdGlvbkV4dGVuZGVyIiwicmVhZE9ubHkiLCJBbm5vdGF0aW9uIiwiQW5ub3RhdGlvblR5cGUiLCJTdGF0ZUVmZmVjdFR5cGUiLCJTdGF0ZUVmZmVjdCIsIm1hcHBpbmciLCJtYXBwZWQiLCJpcyIsIm1hcEVmZmVjdHMiLCJlZmZlY3RzIiwiZWZmZWN0IiwiYXBwZW5kQ29uZmlnIiwiVHJhbnNhY3Rpb24iLCJzdGFydFN0YXRlIiwiYW5ub3RhdGlvbnMiLCJzY3JvbGxJbnRvVmlldyIsIl9kb2MiLCJfc3RhdGUiLCJ0aW1lIiwiRGF0ZSIsIm5vdyIsIm5ld0RvYyIsIm5ld1NlbGVjdGlvbiIsImFwcGx5VHJhbnNhY3Rpb24iLCJhbm5vdGF0aW9uIiwiYW5uIiwicmVjb25maWd1cmVkIiwiaXNVc2VyRXZlbnQiLCJldmVudCIsInVzZXJFdmVudCIsImFkZFRvSGlzdG9yeSIsInJlbW90ZSIsImpvaW5SYW5nZXMiLCJtZXJnZVRyYW5zYWN0aW9uIiwic2VxdWVudGlhbCIsIm1hcEZvckEiLCJtYXBGb3JCIiwicmVzb2x2ZVRyYW5zYWN0aW9uSW5uZXIiLCJkb2NTaXplIiwic2VsIiwiYXNBcnJheSIsInJlc29sdmVUcmFuc2FjdGlvbiIsInNwZWNzIiwic2VxIiwiZXh0ZW5kVHJhbnNhY3Rpb24iLCJmaWx0ZXJUcmFuc2FjdGlvbiIsImJhY2siLCJmaWx0ZXJzIiwiZXh0ZW5kZXJzIiwia2V5cyIsIm5vbmUiLCJDaGFyQ2F0ZWdvcnkiLCJub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhciIsIndvcmRDaGFyIiwiUmVnRXhwIiwiXyIsImhhc1dvcmRDaGFyIiwidGVzdCIsInRvVXBwZXJDYXNlIiwidG9Mb3dlckNhc2UiLCJtYWtlQ2F0ZWdvcml6ZXIiLCJ3b3JkQ2hhcnMiLCJjaGFyIiwiU3BhY2UiLCJXb3JkIiwiT3RoZXIiLCJFZGl0b3JTdGF0ZSIsInJlcXVpcmUiLCJjb25mIiwiZm9yRWFjaCIsImtleSIsInN0YXJ0VmFsdWVzIiwiaW50ZXJtZWRpYXRlU3RhdGUiLCJyZXBsYWNlU2VsZWN0aW9uIiwidG9UZXh0IiwiY2hhbmdlQnlSYW5nZSIsInJlc3VsdDEiLCJuZXdDaGFuZ2VzIiwibmV3TWFwcGVkIiwiaiIsIm1hcEJ5Iiwic2xpY2VEb2MiLCJwcm9wIiwiZmllbGRJbml0IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiY29uZmlndXJhdGlvbiIsInRhYlNpemUiLCJwaHJhc2UiLCJwaHJhc2VzIiwibSIsImxhbmd1YWdlRGF0YUF0IiwibmFtZSIsInNpZGUiLCJwcm92aWRlciIsImNoYXJDYXRlZ29yaXplciIsImF0Iiwiam9pbiIsIndvcmRBdCIsImNhdCIsImtBIiwia0IiLCJrIiwiY29tYmluZUNvbmZpZyIsImNvbmZpZ3MiLCJkZWZhdWx0cyIsImN1cnJlbnQiLCJSYW5nZVZhbHVlIiwiUmFuZ2UiLCJzdGFydFNpZGUiLCJlbmRTaWRlIiwicG9pbnQiLCJtYXBNb2RlIiwiY21wUmFuZ2UiLCJDaHVuayIsIm1heFBvaW50IiwiZmluZEluZGV4Iiwic3RhcnRBdCIsImFyciIsImxvIiwiaGkiLCJkaWZmIiwiYmV0d2VlbiIsIm5ld1BvcyIsImN1ckZyb20iLCJjdXJUbyIsIm5ld0Zyb20iLCJuZXdUbyIsIlJhbmdlU2V0IiwiY2h1bmtQb3MiLCJuZXh0TGF5ZXIiLCJjaHVua0VuZCIsImlzRW1wdHkiLCJ1cGRhdGVTcGVjIiwiZmlsdGVyRnJvbSIsImZpbHRlclRvIiwiY3VyIiwiTGF5ZXJDdXJzb3IiLCJnb3RvIiwic3BpbGwiLCJidWlsZGVyIiwiUmFuZ2VTZXRCdWlsZGVyIiwiYWRkSW5uZXIiLCJyYW5nZUluZGV4IiwiY2h1bmtJbmRleCIsImFkZENodW5rIiwibmV4dENodW5rIiwiZmluaXNoSW5uZXIiLCJjaHVua3MiLCJ0b3VjaCIsIkhlYXBDdXJzb3IiLCJzZXRzIiwib2xkU2V0cyIsIm5ld1NldHMiLCJ0ZXh0RGlmZiIsImNvbXBhcmF0b3IiLCJtaW5Qb2ludFNpemUiLCJzaGFyZWRDaHVua3MiLCJmaW5kU2hhcmVkQ2h1bmtzIiwic2lkZUEiLCJTcGFuQ3Vyc29yIiwic2lkZUIiLCJzYW1lVmFsdWVzIiwiYWN0aXZlIiwic3BhbnMiLCJvcGVuUmFuZ2VzIiwib3BlblN0YXJ0IiwiYWN0aXZlRm9yUG9pbnQiLCJvcGVuQ291bnQiLCJwb2ludEZyb20iLCJwb2ludFJhbmsiLCJvcGVuRW5kIiwic3BhbiIsImJ1aWxkIiwibGF6eVNvcnQiLCJmaW5pc2giLCJsYXllciIsImZpbmlzaENodW5rIiwibmV3QXJyYXlzIiwiY2h1bmtTdGFydCIsInNldE1heFBvaW50IiwibGFzdEZyb20iLCJsYXN0VG8iLCJpbkEiLCJzaGFyZWQiLCJTZXQiLCJtaW5Qb2ludCIsInJhbmsiLCJnb3RvSW5uZXIiLCJzZXRSYW5nZUluZGV4IiwiaGVhcCIsImhlYXBCdWJibGUiLCJjaGlsZEluZGV4IiwiYWN0aXZlVG8iLCJhY3RpdmVSYW5rIiwibWluQWN0aXZlIiwicmVtb3ZlQWN0aXZlIiwicmVtb3ZlIiwiZmluZE1pbkluZGV4IiwiYWRkQWN0aXZlIiwidHJhY2tPcGVuIiwid2FzUG9pbnQiLCJuZXh0VmFsIiwicmV2ZXJzZSIsInN0YXJ0QSIsInN0YXJ0QiIsImRQb3MiLCJjbGlwRW5kIiwiY29tcGFyZVBvaW50IiwiY29tcGFyZVJhbmdlIiwiYXJyYXkiLCJmb3VuZFBvcyIsImNvdW50Q29sdW1uIiwiZmluZENvbHVtbiIsImNvbCIsInN0cmljdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/state/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/theme-one-dark/dist/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@codemirror/theme-one-dark/dist/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   color: () => (/* binding */ color),\n/* harmony export */   oneDark: () => (/* binding */ oneDark),\n/* harmony export */   oneDarkHighlightStyle: () => (/* binding */ oneDarkHighlightStyle),\n/* harmony export */   oneDarkTheme: () => (/* binding */ oneDarkTheme)\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/language */ \"(ssr)/./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/highlight */ \"(ssr)/./node_modules/@lezer/highlight/dist/index.js\");\n\n\n\n// Using https://github.com/one-dark/vscode-one-dark-theme/ as reference for the colors\nconst chalky = \"#e5c07b\", coral = \"#e06c75\", cyan = \"#56b6c2\", invalid = \"#ffffff\", ivory = \"#abb2bf\", stone = \"#7d8799\", malibu = \"#61afef\", sage = \"#98c379\", whiskey = \"#d19a66\", violet = \"#c678dd\", darkBackground = \"#21252b\", highlightBackground = \"#2c313a\", background = \"#282c34\", tooltipBackground = \"#353a42\", selection = \"#3E4451\", cursor = \"#528bff\";\n/**\nThe colors used in the theme, as CSS color strings.\n*/ const color = {\n    chalky,\n    coral,\n    cyan,\n    invalid,\n    ivory,\n    stone,\n    malibu,\n    sage,\n    whiskey,\n    violet,\n    darkBackground,\n    highlightBackground,\n    background,\n    tooltipBackground,\n    selection,\n    cursor\n};\n/**\nThe editor theme styles for One Dark.\n*/ const oneDarkTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.theme({\n    \"&\": {\n        color: ivory,\n        backgroundColor: background\n    },\n    \".cm-content\": {\n        caretColor: cursor\n    },\n    \".cm-cursor, .cm-dropCursor\": {\n        borderLeftColor: cursor\n    },\n    \"&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection\": {\n        backgroundColor: selection\n    },\n    \".cm-panels\": {\n        backgroundColor: darkBackground,\n        color: ivory\n    },\n    \".cm-panels.cm-panels-top\": {\n        borderBottom: \"2px solid black\"\n    },\n    \".cm-panels.cm-panels-bottom\": {\n        borderTop: \"2px solid black\"\n    },\n    \".cm-searchMatch\": {\n        backgroundColor: \"#72a1ff59\",\n        outline: \"1px solid #457dff\"\n    },\n    \".cm-searchMatch.cm-searchMatch-selected\": {\n        backgroundColor: \"#6199ff2f\"\n    },\n    \".cm-activeLine\": {\n        backgroundColor: \"#6699ff0b\"\n    },\n    \".cm-selectionMatch\": {\n        backgroundColor: \"#aafe661a\"\n    },\n    \"&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket\": {\n        backgroundColor: \"#bad0f847\"\n    },\n    \".cm-gutters\": {\n        backgroundColor: background,\n        color: stone,\n        border: \"none\"\n    },\n    \".cm-activeLineGutter\": {\n        backgroundColor: highlightBackground\n    },\n    \".cm-foldPlaceholder\": {\n        backgroundColor: \"transparent\",\n        border: \"none\",\n        color: \"#ddd\"\n    },\n    \".cm-tooltip\": {\n        border: \"none\",\n        backgroundColor: tooltipBackground\n    },\n    \".cm-tooltip .cm-tooltip-arrow:before\": {\n        borderTopColor: \"transparent\",\n        borderBottomColor: \"transparent\"\n    },\n    \".cm-tooltip .cm-tooltip-arrow:after\": {\n        borderTopColor: tooltipBackground,\n        borderBottomColor: tooltipBackground\n    },\n    \".cm-tooltip-autocomplete\": {\n        \"& > ul > li[aria-selected]\": {\n            backgroundColor: highlightBackground,\n            color: ivory\n        }\n    }\n}, {\n    dark: true\n});\n/**\nThe highlighting style for code in the One Dark theme.\n*/ const oneDarkHighlightStyle = /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.HighlightStyle.define([\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.keyword,\n        color: violet\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.name,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.deleted,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.character,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.propertyName,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.macroName\n        ],\n        color: coral\n    },\n    {\n        tag: [\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.variableName),\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.labelName\n        ],\n        color: malibu\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.color,\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.constant(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.name),\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.standard(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.name)\n        ],\n        color: whiskey\n    },\n    {\n        tag: [\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.name),\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.separator\n        ],\n        color: ivory\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.typeName,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.className,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.number,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.changed,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.annotation,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.modifier,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.self,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.namespace\n        ],\n        color: chalky\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.operator,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.operatorKeyword,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.url,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.escape,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.regexp,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.link,\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.string)\n        ],\n        color: cyan\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.meta,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.comment\n        ],\n        color: stone\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.strong,\n        fontWeight: \"bold\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.emphasis,\n        fontStyle: \"italic\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.strikethrough,\n        textDecoration: \"line-through\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.link,\n        color: stone,\n        textDecoration: \"underline\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.heading,\n        fontWeight: \"bold\",\n        color: coral\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.atom,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.bool,\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.variableName)\n        ],\n        color: whiskey\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.processingInstruction,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.string,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.inserted\n        ],\n        color: sage\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.invalid,\n        color: invalid\n    }\n]);\n/**\nExtension to enable the One Dark theme (both the editor theme and\nthe highlight style).\n*/ const oneDark = [\n    oneDarkTheme,\n    /*@__PURE__*/ (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.syntaxHighlighting)(oneDarkHighlightStyle)\n];\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvdGhlbWUtb25lLWRhcmsvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQThDO0FBQzRCO0FBQ2xDO0FBRXhDLHVGQUF1RjtBQUN2RixNQUFNSSxTQUFTLFdBQVdDLFFBQVEsV0FBV0MsT0FBTyxXQUFXQyxVQUFVLFdBQVdDLFFBQVEsV0FBV0MsUUFBUSxXQUMvR0MsU0FBUyxXQUFXQyxPQUFPLFdBQVdDLFVBQVUsV0FBV0MsU0FBUyxXQUFXQyxpQkFBaUIsV0FBV0Msc0JBQXNCLFdBQVdDLGFBQWEsV0FBV0Msb0JBQW9CLFdBQVdDLFlBQVksV0FBV0MsU0FBUztBQUNuTzs7QUFFQSxHQUNBLE1BQU1DLFFBQVE7SUFDVmhCO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0FBQ0o7QUFDQTs7QUFFQSxHQUNBLE1BQU1FLGVBQWUsV0FBVyxHQUFFckIsd0RBQVVBLENBQUNzQixLQUFLLENBQUM7SUFDL0MsS0FBSztRQUNERixPQUFPWjtRQUNQZSxpQkFBaUJQO0lBQ3JCO0lBQ0EsZUFBZTtRQUNYUSxZQUFZTDtJQUNoQjtJQUNBLDhCQUE4QjtRQUFFTSxpQkFBaUJOO0lBQU87SUFDeEQsOEhBQThIO1FBQUVJLGlCQUFpQkw7SUFBVTtJQUMzSixjQUFjO1FBQUVLLGlCQUFpQlQ7UUFBZ0JNLE9BQU9aO0lBQU07SUFDOUQsNEJBQTRCO1FBQUVrQixjQUFjO0lBQWtCO0lBQzlELCtCQUErQjtRQUFFQyxXQUFXO0lBQWtCO0lBQzlELG1CQUFtQjtRQUNmSixpQkFBaUI7UUFDakJLLFNBQVM7SUFDYjtJQUNBLDJDQUEyQztRQUN2Q0wsaUJBQWlCO0lBQ3JCO0lBQ0Esa0JBQWtCO1FBQUVBLGlCQUFpQjtJQUFZO0lBQ2pELHNCQUFzQjtRQUFFQSxpQkFBaUI7SUFBWTtJQUNyRCx5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Q3ZCO1FBQUVqQyxLQUFLaEMsa0RBQUlBLENBQUNrRSxRQUFRO1FBQ2hCQyxXQUFXO0lBQVM7SUFDeEI7UUFBRW5DLEtBQUtoQyxrREFBSUEsQ0FBQ29FLGFBQWE7UUFDckJDLGdCQUFnQjtJQUFlO0lBQ25DO1FBQUVyQyxLQUFLaEMsa0RBQUlBLENBQUMyRCxJQUFJO1FBQ1oxQyxPQUFPWDtRQUNQK0QsZ0JBQWdCO0lBQVk7SUFDaEM7UUFBRXJDLEtBQUtoQyxrREFBSUEsQ0FBQ3NFLE9BQU87UUFDZkwsWUFBWTtRQUNaaEQsT0FBT2Y7SUFBTTtJQUNqQjtRQUFFOEIsS0FBSztZQUFDaEMsa0RBQUlBLENBQUN1RSxJQUFJO1lBQUV2RSxrREFBSUEsQ0FBQ3dFLElBQUk7WUFBRSxXQUFXLEdBQUV4RSxrREFBSUEsQ0FBQzRELE9BQU8sQ0FBQzVELGtEQUFJQSxDQUFDd0MsWUFBWTtTQUFFO1FBQ3ZFdkIsT0FBT1I7SUFBUTtJQUNuQjtRQUFFdUIsS0FBSztZQUFDaEMsa0RBQUlBLENBQUN5RSxxQkFBcUI7WUFBRXpFLGtEQUFJQSxDQUFDNkQsTUFBTTtZQUFFN0Qsa0RBQUlBLENBQUMwRSxRQUFRO1NBQUM7UUFDM0R6RCxPQUFPVDtJQUFLO0lBQ2hCO1FBQUV3QixLQUFLaEMsa0RBQUlBLENBQUNJLE9BQU87UUFDZmEsT0FBT2I7SUFBUTtDQUN0QjtBQUNEOzs7QUFHQSxHQUNBLE1BQU11RSxVQUFVO0lBQUN6RDtJQUFjLFdBQVcsR0FBRW5CLHdFQUFrQkEsQ0FBQytCO0NBQXVCO0FBRXZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWJjLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3RoZW1lLW9uZS1kYXJrL2Rpc3QvaW5kZXguanM/Yjc4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFZGl0b3JWaWV3IH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQgeyBIaWdobGlnaHRTdHlsZSwgc3ludGF4SGlnaGxpZ2h0aW5nIH0gZnJvbSAnQGNvZGVtaXJyb3IvbGFuZ3VhZ2UnO1xuaW1wb3J0IHsgdGFncyB9IGZyb20gJ0BsZXplci9oaWdobGlnaHQnO1xuXG4vLyBVc2luZyBodHRwczovL2dpdGh1Yi5jb20vb25lLWRhcmsvdnNjb2RlLW9uZS1kYXJrLXRoZW1lLyBhcyByZWZlcmVuY2UgZm9yIHRoZSBjb2xvcnNcbmNvbnN0IGNoYWxreSA9IFwiI2U1YzA3YlwiLCBjb3JhbCA9IFwiI2UwNmM3NVwiLCBjeWFuID0gXCIjNTZiNmMyXCIsIGludmFsaWQgPSBcIiNmZmZmZmZcIiwgaXZvcnkgPSBcIiNhYmIyYmZcIiwgc3RvbmUgPSBcIiM3ZDg3OTlcIiwgLy8gQnJpZ2h0ZW5lZCBjb21wYXJlZCB0byBvcmlnaW5hbCB0byBpbmNyZWFzZSBjb250cmFzdFxubWFsaWJ1ID0gXCIjNjFhZmVmXCIsIHNhZ2UgPSBcIiM5OGMzNzlcIiwgd2hpc2tleSA9IFwiI2QxOWE2NlwiLCB2aW9sZXQgPSBcIiNjNjc4ZGRcIiwgZGFya0JhY2tncm91bmQgPSBcIiMyMTI1MmJcIiwgaGlnaGxpZ2h0QmFja2dyb3VuZCA9IFwiIzJjMzEzYVwiLCBiYWNrZ3JvdW5kID0gXCIjMjgyYzM0XCIsIHRvb2x0aXBCYWNrZ3JvdW5kID0gXCIjMzUzYTQyXCIsIHNlbGVjdGlvbiA9IFwiIzNFNDQ1MVwiLCBjdXJzb3IgPSBcIiM1MjhiZmZcIjtcbi8qKlxuVGhlIGNvbG9ycyB1c2VkIGluIHRoZSB0aGVtZSwgYXMgQ1NTIGNvbG9yIHN0cmluZ3MuXG4qL1xuY29uc3QgY29sb3IgPSB7XG4gICAgY2hhbGt5LFxuICAgIGNvcmFsLFxuICAgIGN5YW4sXG4gICAgaW52YWxpZCxcbiAgICBpdm9yeSxcbiAgICBzdG9uZSxcbiAgICBtYWxpYnUsXG4gICAgc2FnZSxcbiAgICB3aGlza2V5LFxuICAgIHZpb2xldCxcbiAgICBkYXJrQmFja2dyb3VuZCxcbiAgICBoaWdobGlnaHRCYWNrZ3JvdW5kLFxuICAgIGJhY2tncm91bmQsXG4gICAgdG9vbHRpcEJhY2tncm91bmQsXG4gICAgc2VsZWN0aW9uLFxuICAgIGN1cnNvclxufTtcbi8qKlxuVGhlIGVkaXRvciB0aGVtZSBzdHlsZXMgZm9yIE9uZSBEYXJrLlxuKi9cbmNvbnN0IG9uZURhcmtUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LnRoZW1lKHtcbiAgICBcIiZcIjoge1xuICAgICAgICBjb2xvcjogaXZvcnksXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZFxuICAgIH0sXG4gICAgXCIuY20tY29udGVudFwiOiB7XG4gICAgICAgIGNhcmV0Q29sb3I6IGN1cnNvclxuICAgIH0sXG4gICAgXCIuY20tY3Vyc29yLCAuY20tZHJvcEN1cnNvclwiOiB7IGJvcmRlckxlZnRDb2xvcjogY3Vyc29yIH0sXG4gICAgXCImLmNtLWZvY3VzZWQgPiAuY20tc2Nyb2xsZXIgPiAuY20tc2VsZWN0aW9uTGF5ZXIgLmNtLXNlbGVjdGlvbkJhY2tncm91bmQsIC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kLCAuY20tY29udGVudCA6OnNlbGVjdGlvblwiOiB7IGJhY2tncm91bmRDb2xvcjogc2VsZWN0aW9uIH0sXG4gICAgXCIuY20tcGFuZWxzXCI6IHsgYmFja2dyb3VuZENvbG9yOiBkYXJrQmFja2dyb3VuZCwgY29sb3I6IGl2b3J5IH0sXG4gICAgXCIuY20tcGFuZWxzLmNtLXBhbmVscy10b3BcIjogeyBib3JkZXJCb3R0b206IFwiMnB4IHNvbGlkIGJsYWNrXCIgfSxcbiAgICBcIi5jbS1wYW5lbHMuY20tcGFuZWxzLWJvdHRvbVwiOiB7IGJvcmRlclRvcDogXCIycHggc29saWQgYmxhY2tcIiB9LFxuICAgIFwiLmNtLXNlYXJjaE1hdGNoXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiM3MmExZmY1OVwiLFxuICAgICAgICBvdXRsaW5lOiBcIjFweCBzb2xpZCAjNDU3ZGZmXCJcbiAgICB9LFxuICAgIFwiLmNtLXNlYXJjaE1hdGNoLmNtLXNlYXJjaE1hdGNoLXNlbGVjdGVkXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiM2MTk5ZmYyZlwiXG4gICAgfSxcbiAgICBcIi5jbS1hY3RpdmVMaW5lXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiM2Njk5ZmYwYlwiIH0sXG4gICAgXCIuY20tc2VsZWN0aW9uTWF0Y2hcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2FhZmU2NjFhXCIgfSxcbiAgICBcIiYuY20tZm9jdXNlZCAuY20tbWF0Y2hpbmdCcmFja2V0LCAmLmNtLWZvY3VzZWQgLmNtLW5vbm1hdGNoaW5nQnJhY2tldFwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjYmFkMGY4NDdcIlxuICAgIH0sXG4gICAgXCIuY20tZ3V0dGVyc1wiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZCxcbiAgICAgICAgY29sb3I6IHN0b25lLFxuICAgICAgICBib3JkZXI6IFwibm9uZVwiXG4gICAgfSxcbiAgICBcIi5jbS1hY3RpdmVMaW5lR3V0dGVyXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBoaWdobGlnaHRCYWNrZ3JvdW5kXG4gICAgfSxcbiAgICBcIi5jbS1mb2xkUGxhY2Vob2xkZXJcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnRcIixcbiAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgY29sb3I6IFwiI2RkZFwiXG4gICAgfSxcbiAgICBcIi5jbS10b29sdGlwXCI6IHtcbiAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0b29sdGlwQmFja2dyb3VuZFxuICAgIH0sXG4gICAgXCIuY20tdG9vbHRpcCAuY20tdG9vbHRpcC1hcnJvdzpiZWZvcmVcIjoge1xuICAgICAgICBib3JkZXJUb3BDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxuICAgICAgICBib3JkZXJCb3R0b21Db2xvcjogXCJ0cmFuc3BhcmVudFwiXG4gICAgfSxcbiAgICBcIi5jbS10b29sdGlwIC5jbS10b29sdGlwLWFycm93OmFmdGVyXCI6IHtcbiAgICAgICAgYm9yZGVyVG9wQ29sb3I6IHRvb2x0aXBCYWNrZ3JvdW5kLFxuICAgICAgICBib3JkZXJCb3R0b21Db2xvcjogdG9vbHRpcEJhY2tncm91bmRcbiAgICB9LFxuICAgIFwiLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlXCI6IHtcbiAgICAgICAgXCImID4gdWwgPiBsaVthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGhpZ2hsaWdodEJhY2tncm91bmQsXG4gICAgICAgICAgICBjb2xvcjogaXZvcnlcbiAgICAgICAgfVxuICAgIH1cbn0sIHsgZGFyazogdHJ1ZSB9KTtcbi8qKlxuVGhlIGhpZ2hsaWdodGluZyBzdHlsZSBmb3IgY29kZSBpbiB0aGUgT25lIERhcmsgdGhlbWUuXG4qL1xuY29uc3Qgb25lRGFya0hpZ2hsaWdodFN0eWxlID0gLypAX19QVVJFX18qL0hpZ2hsaWdodFN0eWxlLmRlZmluZShbXG4gICAgeyB0YWc6IHRhZ3Mua2V5d29yZCxcbiAgICAgICAgY29sb3I6IHZpb2xldCB9LFxuICAgIHsgdGFnOiBbdGFncy5uYW1lLCB0YWdzLmRlbGV0ZWQsIHRhZ3MuY2hhcmFjdGVyLCB0YWdzLnByb3BlcnR5TmFtZSwgdGFncy5tYWNyb05hbWVdLFxuICAgICAgICBjb2xvcjogY29yYWwgfSxcbiAgICB7IHRhZzogWy8qQF9fUFVSRV9fKi90YWdzLmZ1bmN0aW9uKHRhZ3MudmFyaWFibGVOYW1lKSwgdGFncy5sYWJlbE5hbWVdLFxuICAgICAgICBjb2xvcjogbWFsaWJ1IH0sXG4gICAgeyB0YWc6IFt0YWdzLmNvbG9yLCAvKkBfX1BVUkVfXyovdGFncy5jb25zdGFudCh0YWdzLm5hbWUpLCAvKkBfX1BVUkVfXyovdGFncy5zdGFuZGFyZCh0YWdzLm5hbWUpXSxcbiAgICAgICAgY29sb3I6IHdoaXNrZXkgfSxcbiAgICB7IHRhZzogWy8qQF9fUFVSRV9fKi90YWdzLmRlZmluaXRpb24odGFncy5uYW1lKSwgdGFncy5zZXBhcmF0b3JdLFxuICAgICAgICBjb2xvcjogaXZvcnkgfSxcbiAgICB7IHRhZzogW3RhZ3MudHlwZU5hbWUsIHRhZ3MuY2xhc3NOYW1lLCB0YWdzLm51bWJlciwgdGFncy5jaGFuZ2VkLCB0YWdzLmFubm90YXRpb24sIHRhZ3MubW9kaWZpZXIsIHRhZ3Muc2VsZiwgdGFncy5uYW1lc3BhY2VdLFxuICAgICAgICBjb2xvcjogY2hhbGt5IH0sXG4gICAgeyB0YWc6IFt0YWdzLm9wZXJhdG9yLCB0YWdzLm9wZXJhdG9yS2V5d29yZCwgdGFncy51cmwsIHRhZ3MuZXNjYXBlLCB0YWdzLnJlZ2V4cCwgdGFncy5saW5rLCAvKkBfX1BVUkVfXyovdGFncy5zcGVjaWFsKHRhZ3Muc3RyaW5nKV0sXG4gICAgICAgIGNvbG9yOiBjeWFuIH0sXG4gICAgeyB0YWc6IFt0YWdzLm1ldGEsIHRhZ3MuY29tbWVudF0sXG4gICAgICAgIGNvbG9yOiBzdG9uZSB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cm9uZyxcbiAgICAgICAgZm9udFdlaWdodDogXCJib2xkXCIgfSxcbiAgICB7IHRhZzogdGFncy5lbXBoYXNpcyxcbiAgICAgICAgZm9udFN0eWxlOiBcIml0YWxpY1wiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3RyaWtldGhyb3VnaCxcbiAgICAgICAgdGV4dERlY29yYXRpb246IFwibGluZS10aHJvdWdoXCIgfSxcbiAgICB7IHRhZzogdGFncy5saW5rLFxuICAgICAgICBjb2xvcjogc3RvbmUsXG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaGVhZGluZyxcbiAgICAgICAgZm9udFdlaWdodDogXCJib2xkXCIsXG4gICAgICAgIGNvbG9yOiBjb3JhbCB9LFxuICAgIHsgdGFnOiBbdGFncy5hdG9tLCB0YWdzLmJvb2wsIC8qQF9fUFVSRV9fKi90YWdzLnNwZWNpYWwodGFncy52YXJpYWJsZU5hbWUpXSxcbiAgICAgICAgY29sb3I6IHdoaXNrZXkgfSxcbiAgICB7IHRhZzogW3RhZ3MucHJvY2Vzc2luZ0luc3RydWN0aW9uLCB0YWdzLnN0cmluZywgdGFncy5pbnNlcnRlZF0sXG4gICAgICAgIGNvbG9yOiBzYWdlIH0sXG4gICAgeyB0YWc6IHRhZ3MuaW52YWxpZCxcbiAgICAgICAgY29sb3I6IGludmFsaWQgfSxcbl0pO1xuLyoqXG5FeHRlbnNpb24gdG8gZW5hYmxlIHRoZSBPbmUgRGFyayB0aGVtZSAoYm90aCB0aGUgZWRpdG9yIHRoZW1lIGFuZFxudGhlIGhpZ2hsaWdodCBzdHlsZSkuXG4qL1xuY29uc3Qgb25lRGFyayA9IFtvbmVEYXJrVGhlbWUsIC8qQF9fUFVSRV9fKi9zeW50YXhIaWdobGlnaHRpbmcob25lRGFya0hpZ2hsaWdodFN0eWxlKV07XG5cbmV4cG9ydCB7IGNvbG9yLCBvbmVEYXJrLCBvbmVEYXJrSGlnaGxpZ2h0U3R5bGUsIG9uZURhcmtUaGVtZSB9O1xuIl0sIm5hbWVzIjpbIkVkaXRvclZpZXciLCJIaWdobGlnaHRTdHlsZSIsInN5bnRheEhpZ2hsaWdodGluZyIsInRhZ3MiLCJjaGFsa3kiLCJjb3JhbCIsImN5YW4iLCJpbnZhbGlkIiwiaXZvcnkiLCJzdG9uZSIsIm1hbGlidSIsInNhZ2UiLCJ3aGlza2V5IiwidmlvbGV0IiwiZGFya0JhY2tncm91bmQiLCJoaWdobGlnaHRCYWNrZ3JvdW5kIiwiYmFja2dyb3VuZCIsInRvb2x0aXBCYWNrZ3JvdW5kIiwic2VsZWN0aW9uIiwiY3Vyc29yIiwiY29sb3IiLCJvbmVEYXJrVGhlbWUiLCJ0aGVtZSIsImJhY2tncm91bmRDb2xvciIsImNhcmV0Q29sb3IiLCJib3JkZXJMZWZ0Q29sb3IiLCJib3JkZXJCb3R0b20iLCJib3JkZXJUb3AiLCJvdXRsaW5lIiwiYm9yZGVyIiwiYm9yZGVyVG9wQ29sb3IiLCJib3JkZXJCb3R0b21Db2xvciIsImRhcmsiLCJvbmVEYXJrSGlnaGxpZ2h0U3R5bGUiLCJkZWZpbmUiLCJ0YWciLCJrZXl3b3JkIiwibmFtZSIsImRlbGV0ZWQiLCJjaGFyYWN0ZXIiLCJwcm9wZXJ0eU5hbWUiLCJtYWNyb05hbWUiLCJmdW5jdGlvbiIsInZhcmlhYmxlTmFtZSIsImxhYmVsTmFtZSIsImNvbnN0YW50Iiwic3RhbmRhcmQiLCJkZWZpbml0aW9uIiwic2VwYXJhdG9yIiwidHlwZU5hbWUiLCJjbGFzc05hbWUiLCJudW1iZXIiLCJjaGFuZ2VkIiwiYW5ub3RhdGlvbiIsIm1vZGlmaWVyIiwic2VsZiIsIm5hbWVzcGFjZSIsIm9wZXJhdG9yIiwib3BlcmF0b3JLZXl3b3JkIiwidXJsIiwiZXNjYXBlIiwicmVnZXhwIiwibGluayIsInNwZWNpYWwiLCJzdHJpbmciLCJtZXRhIiwiY29tbWVudCIsInN0cm9uZyIsImZvbnRXZWlnaHQiLCJlbXBoYXNpcyIsImZvbnRTdHlsZSIsInN0cmlrZXRocm91Z2giLCJ0ZXh0RGVjb3JhdGlvbiIsImhlYWRpbmciLCJhdG9tIiwiYm9vbCIsInByb2Nlc3NpbmdJbnN0cnVjdGlvbiIsImluc2VydGVkIiwib25lRGFyayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/theme-one-dark/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/view/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@codemirror/view/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BidiSpan: () => (/* binding */ BidiSpan),\n/* harmony export */   BlockInfo: () => (/* binding */ BlockInfo),\n/* harmony export */   BlockType: () => (/* binding */ BlockType),\n/* harmony export */   Decoration: () => (/* binding */ Decoration),\n/* harmony export */   Direction: () => (/* binding */ Direction),\n/* harmony export */   EditorView: () => (/* binding */ EditorView),\n/* harmony export */   GutterMarker: () => (/* binding */ GutterMarker),\n/* harmony export */   MatchDecorator: () => (/* binding */ MatchDecorator),\n/* harmony export */   RectangleMarker: () => (/* binding */ RectangleMarker),\n/* harmony export */   ViewPlugin: () => (/* binding */ ViewPlugin),\n/* harmony export */   ViewUpdate: () => (/* binding */ ViewUpdate),\n/* harmony export */   WidgetType: () => (/* binding */ WidgetType),\n/* harmony export */   __test: () => (/* binding */ __test),\n/* harmony export */   closeHoverTooltips: () => (/* binding */ closeHoverTooltips),\n/* harmony export */   crosshairCursor: () => (/* binding */ crosshairCursor),\n/* harmony export */   drawSelection: () => (/* binding */ drawSelection),\n/* harmony export */   dropCursor: () => (/* binding */ dropCursor),\n/* harmony export */   getDrawSelectionConfig: () => (/* binding */ getDrawSelectionConfig),\n/* harmony export */   getPanel: () => (/* binding */ getPanel),\n/* harmony export */   getTooltip: () => (/* binding */ getTooltip),\n/* harmony export */   gutter: () => (/* binding */ gutter),\n/* harmony export */   gutterLineClass: () => (/* binding */ gutterLineClass),\n/* harmony export */   gutters: () => (/* binding */ gutters),\n/* harmony export */   hasHoverTooltips: () => (/* binding */ hasHoverTooltips),\n/* harmony export */   highlightActiveLine: () => (/* binding */ highlightActiveLine),\n/* harmony export */   highlightActiveLineGutter: () => (/* binding */ highlightActiveLineGutter),\n/* harmony export */   highlightSpecialChars: () => (/* binding */ highlightSpecialChars),\n/* harmony export */   highlightTrailingWhitespace: () => (/* binding */ highlightTrailingWhitespace),\n/* harmony export */   highlightWhitespace: () => (/* binding */ highlightWhitespace),\n/* harmony export */   hoverTooltip: () => (/* binding */ hoverTooltip),\n/* harmony export */   keymap: () => (/* binding */ keymap),\n/* harmony export */   layer: () => (/* binding */ layer),\n/* harmony export */   lineNumberMarkers: () => (/* binding */ lineNumberMarkers),\n/* harmony export */   lineNumbers: () => (/* binding */ lineNumbers),\n/* harmony export */   logException: () => (/* binding */ logException),\n/* harmony export */   panels: () => (/* binding */ panels),\n/* harmony export */   placeholder: () => (/* binding */ placeholder),\n/* harmony export */   rectangularSelection: () => (/* binding */ rectangularSelection),\n/* harmony export */   repositionTooltips: () => (/* binding */ repositionTooltips),\n/* harmony export */   runScopeHandlers: () => (/* binding */ runScopeHandlers),\n/* harmony export */   scrollPastEnd: () => (/* binding */ scrollPastEnd),\n/* harmony export */   showPanel: () => (/* binding */ showPanel),\n/* harmony export */   showTooltip: () => (/* binding */ showTooltip),\n/* harmony export */   tooltips: () => (/* binding */ tooltips)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! style-mod */ \"(ssr)/./node_modules/style-mod/src/style-mod.js\");\n/* harmony import */ var w3c_keyname__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! w3c-keyname */ \"(ssr)/./node_modules/w3c-keyname/index.js\");\n\n\n\nfunction getSelection(root) {\n    let target;\n    // Browsers differ on whether shadow roots have a getSelection\n    // method. If it exists, use that, otherwise, call it on the\n    // document.\n    if (root.nodeType == 11) {\n        target = root.getSelection ? root : root.ownerDocument;\n    } else {\n        target = root;\n    }\n    return target.getSelection();\n}\nfunction contains(dom, node) {\n    return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;\n}\nfunction deepActiveElement(doc) {\n    let elt = doc.activeElement;\n    while(elt && elt.shadowRoot)elt = elt.shadowRoot.activeElement;\n    return elt;\n}\nfunction hasSelection(dom, selection) {\n    if (!selection.anchorNode) return false;\n    try {\n        // Firefox will raise 'permission denied' errors when accessing\n        // properties of `sel.anchorNode` when it's in a generated CSS\n        // element.\n        return contains(dom, selection.anchorNode);\n    } catch (_) {\n        return false;\n    }\n}\nfunction clientRectsFor(dom) {\n    if (dom.nodeType == 3) return textRange(dom, 0, dom.nodeValue.length).getClientRects();\n    else if (dom.nodeType == 1) return dom.getClientRects();\n    else return [];\n}\n// Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\nfunction isEquivalentPosition(node, off, targetNode, targetOff) {\n    return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;\n}\nfunction domIndex(node) {\n    for(var index = 0;; index++){\n        node = node.previousSibling;\n        if (!node) return index;\n    }\n}\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n    for(;;){\n        if (node == targetNode && off == targetOff) return true;\n        if (off == (dir < 0 ? 0 : maxOffset(node))) {\n            if (node.nodeName == \"DIV\") return false;\n            let parent = node.parentNode;\n            if (!parent || parent.nodeType != 1) return false;\n            off = domIndex(node) + (dir < 0 ? 0 : 1);\n            node = parent;\n        } else if (node.nodeType == 1) {\n            node = node.childNodes[off + (dir < 0 ? -1 : 0)];\n            if (node.nodeType == 1 && node.contentEditable == \"false\") return false;\n            off = dir < 0 ? maxOffset(node) : 0;\n        } else {\n            return false;\n        }\n    }\n}\nfunction maxOffset(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction flattenRect(rect, left) {\n    let x = left ? rect.left : rect.right;\n    return {\n        left: x,\n        right: x,\n        top: rect.top,\n        bottom: rect.bottom\n    };\n}\nfunction windowRect(win) {\n    return {\n        left: 0,\n        right: win.innerWidth,\n        top: 0,\n        bottom: win.innerHeight\n    };\n}\nfunction getScale(elt, rect) {\n    let scaleX = rect.width / elt.offsetWidth;\n    let scaleY = rect.height / elt.offsetHeight;\n    if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(rect.width - elt.offsetWidth) < 1) scaleX = 1;\n    if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(rect.height - elt.offsetHeight) < 1) scaleY = 1;\n    return {\n        scaleX,\n        scaleY\n    };\n}\nfunction scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {\n    let doc = dom.ownerDocument, win = doc.defaultView || window;\n    for(let cur = dom, stop = false; cur && !stop;){\n        if (cur.nodeType == 1) {\n            let bounding, top = cur == doc.body;\n            let scaleX = 1, scaleY = 1;\n            if (top) {\n                bounding = windowRect(win);\n            } else {\n                if (/^(fixed|sticky)$/.test(getComputedStyle(cur).position)) stop = true;\n                if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {\n                    cur = cur.assignedSlot || cur.parentNode;\n                    continue;\n                }\n                let rect = cur.getBoundingClientRect();\n                ({ scaleX, scaleY } = getScale(cur, rect));\n                // Make sure scrollbar width isn't included in the rectangle\n                bounding = {\n                    left: rect.left,\n                    right: rect.left + cur.clientWidth * scaleX,\n                    top: rect.top,\n                    bottom: rect.top + cur.clientHeight * scaleY\n                };\n            }\n            let moveX = 0, moveY = 0;\n            if (y == \"nearest\") {\n                if (rect.top < bounding.top) {\n                    moveY = -(bounding.top - rect.top + yMargin);\n                    if (side > 0 && rect.bottom > bounding.bottom + moveY) moveY = rect.bottom - bounding.bottom + moveY + yMargin;\n                } else if (rect.bottom > bounding.bottom) {\n                    moveY = rect.bottom - bounding.bottom + yMargin;\n                    if (side < 0 && rect.top - moveY < bounding.top) moveY = -(bounding.top + moveY - rect.top + yMargin);\n                }\n            } else {\n                let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;\n                let targetTop = y == \"center\" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y == \"start\" || y == \"center\" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;\n                moveY = targetTop - bounding.top;\n            }\n            if (x == \"nearest\") {\n                if (rect.left < bounding.left) {\n                    moveX = -(bounding.left - rect.left + xMargin);\n                    if (side > 0 && rect.right > bounding.right + moveX) moveX = rect.right - bounding.right + moveX + xMargin;\n                } else if (rect.right > bounding.right) {\n                    moveX = rect.right - bounding.right + xMargin;\n                    if (side < 0 && rect.left < bounding.left + moveX) moveX = -(bounding.left + moveX - rect.left + xMargin);\n                }\n            } else {\n                let targetLeft = x == \"center\" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x == \"start\" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;\n                moveX = targetLeft - bounding.left;\n            }\n            if (moveX || moveY) {\n                if (top) {\n                    win.scrollBy(moveX, moveY);\n                } else {\n                    let movedX = 0, movedY = 0;\n                    if (moveY) {\n                        let start = cur.scrollTop;\n                        cur.scrollTop += moveY / scaleY;\n                        movedY = (cur.scrollTop - start) * scaleY;\n                    }\n                    if (moveX) {\n                        let start = cur.scrollLeft;\n                        cur.scrollLeft += moveX / scaleX;\n                        movedX = (cur.scrollLeft - start) * scaleX;\n                    }\n                    rect = {\n                        left: rect.left - movedX,\n                        top: rect.top - movedY,\n                        right: rect.right - movedX,\n                        bottom: rect.bottom - movedY\n                    };\n                    if (movedX && Math.abs(movedX - moveX) < 1) x = \"nearest\";\n                    if (movedY && Math.abs(movedY - moveY) < 1) y = \"nearest\";\n                }\n            }\n            if (top) break;\n            cur = cur.assignedSlot || cur.parentNode;\n        } else if (cur.nodeType == 11) {\n            cur = cur.host;\n        } else {\n            break;\n        }\n    }\n}\nfunction scrollableParent(dom) {\n    let doc = dom.ownerDocument;\n    for(let cur = dom.parentNode; cur;){\n        if (cur == doc.body) {\n            break;\n        } else if (cur.nodeType == 1) {\n            if (cur.scrollHeight > cur.clientHeight || cur.scrollWidth > cur.clientWidth) return cur;\n            cur = cur.assignedSlot || cur.parentNode;\n        } else if (cur.nodeType == 11) {\n            cur = cur.host;\n        } else {\n            break;\n        }\n    }\n    return null;\n}\nclass DOMSelectionState {\n    constructor(){\n        this.anchorNode = null;\n        this.anchorOffset = 0;\n        this.focusNode = null;\n        this.focusOffset = 0;\n    }\n    eq(domSel) {\n        return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;\n    }\n    setRange(range) {\n        let { anchorNode, focusNode } = range;\n        // Clip offsets to node size to avoid crashes when Safari reports bogus offsets (#1152)\n        this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));\n    }\n    set(anchorNode, anchorOffset, focusNode, focusOffset) {\n        this.anchorNode = anchorNode;\n        this.anchorOffset = anchorOffset;\n        this.focusNode = focusNode;\n        this.focusOffset = focusOffset;\n    }\n}\nlet preventScrollSupported = null;\n// Feature-detects support for .focus({preventScroll: true}), and uses\n// a fallback kludge when not supported.\nfunction focusPreventScroll(dom) {\n    if (dom.setActive) return dom.setActive(); // in IE\n    if (preventScrollSupported) return dom.focus(preventScrollSupported);\n    let stack = [];\n    for(let cur = dom; cur; cur = cur.parentNode){\n        stack.push(cur, cur.scrollTop, cur.scrollLeft);\n        if (cur == cur.ownerDocument) break;\n    }\n    dom.focus(preventScrollSupported == null ? {\n        get preventScroll () {\n            preventScrollSupported = {\n                preventScroll: true\n            };\n            return true;\n        }\n    } : undefined);\n    if (!preventScrollSupported) {\n        preventScrollSupported = false;\n        for(let i = 0; i < stack.length;){\n            let elt = stack[i++], top = stack[i++], left = stack[i++];\n            if (elt.scrollTop != top) elt.scrollTop = top;\n            if (elt.scrollLeft != left) elt.scrollLeft = left;\n        }\n    }\n}\nlet scratchRange;\nfunction textRange(node, from, to = from) {\n    let range = scratchRange || (scratchRange = document.createRange());\n    range.setEnd(node, to);\n    range.setStart(node, from);\n    return range;\n}\nfunction dispatchKey(elt, name, code) {\n    let options = {\n        key: name,\n        code: name,\n        keyCode: code,\n        which: code,\n        cancelable: true\n    };\n    let down = new KeyboardEvent(\"keydown\", options);\n    down.synthetic = true;\n    elt.dispatchEvent(down);\n    let up = new KeyboardEvent(\"keyup\", options);\n    up.synthetic = true;\n    elt.dispatchEvent(up);\n    return down.defaultPrevented || up.defaultPrevented;\n}\nfunction getRoot(node) {\n    while(node){\n        if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host)) return node;\n        node = node.assignedSlot || node.parentNode;\n    }\n    return null;\n}\nfunction clearAttributes(node) {\n    while(node.attributes.length)node.removeAttributeNode(node.attributes[0]);\n}\nfunction atElementStart(doc, selection) {\n    let node = selection.focusNode, offset = selection.focusOffset;\n    if (!node || selection.anchorNode != node || selection.anchorOffset != offset) return false;\n    // Safari can report bogus offsets (#1152)\n    offset = Math.min(offset, maxOffset(node));\n    for(;;){\n        if (offset) {\n            if (node.nodeType != 1) return false;\n            let prev = node.childNodes[offset - 1];\n            if (prev.contentEditable == \"false\") offset--;\n            else {\n                node = prev;\n                offset = maxOffset(node);\n            }\n        } else if (node == doc) {\n            return true;\n        } else {\n            offset = domIndex(node);\n            node = node.parentNode;\n        }\n    }\n}\nfunction isScrolledToBottom(elt) {\n    return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);\n}\nclass DOMPos {\n    constructor(node, offset, precise = true){\n        this.node = node;\n        this.offset = offset;\n        this.precise = precise;\n    }\n    static before(dom, precise) {\n        return new DOMPos(dom.parentNode, domIndex(dom), precise);\n    }\n    static after(dom, precise) {\n        return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);\n    }\n}\nconst noChildren = [];\nclass ContentView {\n    constructor(){\n        this.parent = null;\n        this.dom = null;\n        this.flags = 2 /* ViewFlag.NodeDirty */ ;\n    }\n    get overrideDOMText() {\n        return null;\n    }\n    get posAtStart() {\n        return this.parent ? this.parent.posBefore(this) : 0;\n    }\n    get posAtEnd() {\n        return this.posAtStart + this.length;\n    }\n    posBefore(view) {\n        let pos = this.posAtStart;\n        for (let child of this.children){\n            if (child == view) return pos;\n            pos += child.length + child.breakAfter;\n        }\n        throw new RangeError(\"Invalid child in posBefore\");\n    }\n    posAfter(view) {\n        return this.posBefore(view) + view.length;\n    }\n    sync(view, track) {\n        if (this.flags & 2 /* ViewFlag.NodeDirty */ ) {\n            let parent = this.dom;\n            let prev = null, next;\n            for (let child of this.children){\n                if (child.flags & 7 /* ViewFlag.Dirty */ ) {\n                    if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {\n                        let contentView = ContentView.get(next);\n                        if (!contentView || !contentView.parent && contentView.canReuseDOM(child)) child.reuseDOM(next);\n                    }\n                    child.sync(view, track);\n                    child.flags &= ~7 /* ViewFlag.Dirty */ ;\n                }\n                next = prev ? prev.nextSibling : parent.firstChild;\n                if (track && !track.written && track.node == parent && next != child.dom) track.written = true;\n                if (child.dom.parentNode == parent) {\n                    while(next && next != child.dom)next = rm$1(next);\n                } else {\n                    parent.insertBefore(child.dom, next);\n                }\n                prev = child.dom;\n            }\n            next = prev ? prev.nextSibling : parent.firstChild;\n            if (next && track && track.node == parent) track.written = true;\n            while(next)next = rm$1(next);\n        } else if (this.flags & 1 /* ViewFlag.ChildDirty */ ) {\n            for (let child of this.children)if (child.flags & 7 /* ViewFlag.Dirty */ ) {\n                child.sync(view, track);\n                child.flags &= ~7 /* ViewFlag.Dirty */ ;\n            }\n        }\n    }\n    reuseDOM(_dom) {}\n    localPosFromDOM(node, offset) {\n        let after;\n        if (node == this.dom) {\n            after = this.dom.childNodes[offset];\n        } else {\n            let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;\n            for(;;){\n                let parent = node.parentNode;\n                if (parent == this.dom) break;\n                if (bias == 0 && parent.firstChild != parent.lastChild) {\n                    if (node == parent.firstChild) bias = -1;\n                    else bias = 1;\n                }\n                node = parent;\n            }\n            if (bias < 0) after = node;\n            else after = node.nextSibling;\n        }\n        if (after == this.dom.firstChild) return 0;\n        while(after && !ContentView.get(after))after = after.nextSibling;\n        if (!after) return this.length;\n        for(let i = 0, pos = 0;; i++){\n            let child = this.children[i];\n            if (child.dom == after) return pos;\n            pos += child.length + child.breakAfter;\n        }\n    }\n    domBoundsAround(from, to, offset = 0) {\n        let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;\n        for(let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++){\n            let child = this.children[i], end = pos + child.length;\n            if (pos < from && end > to) return child.domBoundsAround(from, to, pos);\n            if (end >= from && fromI == -1) {\n                fromI = i;\n                fromStart = pos;\n            }\n            if (pos > to && child.dom.parentNode == this.dom) {\n                toI = i;\n                toEnd = prevEnd;\n                break;\n            }\n            prevEnd = end;\n            pos = end + child.breakAfter;\n        }\n        return {\n            from: fromStart,\n            to: toEnd < 0 ? offset + this.length : toEnd,\n            startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,\n            endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null\n        };\n    }\n    markDirty(andParent = false) {\n        this.flags |= 2 /* ViewFlag.NodeDirty */ ;\n        this.markParentsDirty(andParent);\n    }\n    markParentsDirty(childList) {\n        for(let parent = this.parent; parent; parent = parent.parent){\n            if (childList) parent.flags |= 2 /* ViewFlag.NodeDirty */ ;\n            if (parent.flags & 1 /* ViewFlag.ChildDirty */ ) return;\n            parent.flags |= 1 /* ViewFlag.ChildDirty */ ;\n            childList = false;\n        }\n    }\n    setParent(parent) {\n        if (this.parent != parent) {\n            this.parent = parent;\n            if (this.flags & 7 /* ViewFlag.Dirty */ ) this.markParentsDirty(true);\n        }\n    }\n    setDOM(dom) {\n        if (this.dom == dom) return;\n        if (this.dom) this.dom.cmView = null;\n        this.dom = dom;\n        dom.cmView = this;\n    }\n    get rootView() {\n        for(let v = this;;){\n            let parent = v.parent;\n            if (!parent) return v;\n            v = parent;\n        }\n    }\n    replaceChildren(from, to, children = noChildren) {\n        this.markDirty();\n        for(let i = from; i < to; i++){\n            let child = this.children[i];\n            if (child.parent == this && children.indexOf(child) < 0) child.destroy();\n        }\n        this.children.splice(from, to - from, ...children);\n        for(let i = 0; i < children.length; i++)children[i].setParent(this);\n    }\n    ignoreMutation(_rec) {\n        return false;\n    }\n    ignoreEvent(_event) {\n        return false;\n    }\n    childCursor(pos = this.length) {\n        return new ChildCursor(this.children, pos, this.children.length);\n    }\n    childPos(pos, bias = 1) {\n        return this.childCursor().findPos(pos, bias);\n    }\n    toString() {\n        let name = this.constructor.name.replace(\"View\", \"\");\n        return name + (this.children.length ? \"(\" + this.children.join() + \")\" : this.length ? \"[\" + (name == \"Text\" ? this.text : this.length) + \"]\" : \"\") + (this.breakAfter ? \"#\" : \"\");\n    }\n    static get(node) {\n        return node.cmView;\n    }\n    get isEditable() {\n        return true;\n    }\n    get isWidget() {\n        return false;\n    }\n    get isHidden() {\n        return false;\n    }\n    merge(from, to, source, hasStart, openStart, openEnd) {\n        return false;\n    }\n    become(other) {\n        return false;\n    }\n    canReuseDOM(other) {\n        return other.constructor == this.constructor && !((this.flags | other.flags) & 8 /* ViewFlag.Composition */ );\n    }\n    // When this is a zero-length view with a side, this should return a\n    // number <= 0 to indicate it is before its position, or a\n    // number > 0 when after its position.\n    getSide() {\n        return 0;\n    }\n    destroy() {\n        for (let child of this.children)if (child.parent == this) child.destroy();\n        this.parent = null;\n    }\n}\nContentView.prototype.breakAfter = 0;\n// Remove a DOM node and return its next sibling.\nfunction rm$1(dom) {\n    let next = dom.nextSibling;\n    dom.parentNode.removeChild(dom);\n    return next;\n}\nclass ChildCursor {\n    constructor(children, pos, i){\n        this.children = children;\n        this.pos = pos;\n        this.i = i;\n        this.off = 0;\n    }\n    findPos(pos, bias = 1) {\n        for(;;){\n            if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {\n                this.off = pos - this.pos;\n                return this;\n            }\n            let next = this.children[--this.i];\n            this.pos -= next.length + next.breakAfter;\n        }\n    }\n}\nfunction replaceRange(parent, fromI, fromOff, toI, toOff, insert, breakAtStart, openStart, openEnd) {\n    let { children } = parent;\n    let before = children.length ? children[fromI] : null;\n    let last = insert.length ? insert[insert.length - 1] : null;\n    let breakAtEnd = last ? last.breakAfter : breakAtStart;\n    // Change within a single child\n    if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert.length < 2 && before.merge(fromOff, toOff, insert.length ? last : null, fromOff == 0, openStart, openEnd)) return;\n    if (toI < children.length) {\n        let after = children[toI];\n        // Make sure the end of the child after the update is preserved in `after`\n        if (after && (toOff < after.length || after.breakAfter && (last === null || last === void 0 ? void 0 : last.breakAfter))) {\n            // If we're splitting a child, separate part of it to avoid that\n            // being mangled when updating the child before the update.\n            if (fromI == toI) {\n                after = after.split(toOff);\n                toOff = 0;\n            }\n            // If the element after the replacement should be merged with\n            // the last replacing element, update `content`\n            if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {\n                insert[insert.length - 1] = after;\n            } else {\n                // Remove the start of the after element, if necessary, and\n                // add it to `content`.\n                if (toOff || after.children.length && !after.children[0].length) after.merge(0, toOff, null, false, 0, openEnd);\n                insert.push(after);\n            }\n        } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {\n            // The element at `toI` is entirely covered by this range.\n            // Preserve its line break, if any.\n            if (last) last.breakAfter = 1;\n            else breakAtStart = 1;\n        }\n        // Since we've handled the next element from the current elements\n        // now, make sure `toI` points after that.\n        toI++;\n    }\n    if (before) {\n        before.breakAfter = breakAtStart;\n        if (fromOff > 0) {\n            if (!breakAtStart && insert.length && before.merge(fromOff, before.length, insert[0], false, openStart, 0)) {\n                before.breakAfter = insert.shift().breakAfter;\n            } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {\n                before.merge(fromOff, before.length, null, false, openStart, 0);\n            }\n            fromI++;\n        }\n    }\n    // Try to merge widgets on the boundaries of the replacement\n    while(fromI < toI && insert.length){\n        if (children[toI - 1].become(insert[insert.length - 1])) {\n            toI--;\n            insert.pop();\n            openEnd = insert.length ? 0 : openStart;\n        } else if (children[fromI].become(insert[0])) {\n            fromI++;\n            insert.shift();\n            openStart = insert.length ? 0 : openEnd;\n        } else {\n            break;\n        }\n    }\n    if (!insert.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd)) fromI--;\n    if (fromI < toI || insert.length) parent.replaceChildren(fromI, toI, insert);\n}\nfunction mergeChildrenInto(parent, from, to, insert, openStart, openEnd) {\n    let cur = parent.childCursor();\n    let { i: toI, off: toOff } = cur.findPos(to, 1);\n    let { i: fromI, off: fromOff } = cur.findPos(from, -1);\n    let dLen = from - to;\n    for (let view of insert)dLen += view.length;\n    parent.length += dLen;\n    replaceRange(parent, fromI, fromOff, toI, toOff, insert, 0, openStart, openEnd);\n}\nlet nav = typeof navigator != \"undefined\" ? navigator : {\n    userAgent: \"\",\n    vendor: \"\",\n    platform: \"\"\n};\nlet doc = typeof document != \"undefined\" ? document : {\n    documentElement: {\n        style: {}\n    }\n};\nconst ie_edge = /*@__PURE__*/ /Edge\\/(\\d+)/.exec(nav.userAgent);\nconst ie_upto10 = /*@__PURE__*/ /MSIE \\d/.test(nav.userAgent);\nconst ie_11up = /*@__PURE__*/ /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(nav.userAgent);\nconst ie = !!(ie_upto10 || ie_11up || ie_edge);\nconst gecko = !ie && /*@__PURE__*/ /gecko\\/(\\d+)/i.test(nav.userAgent);\nconst chrome = !ie && /*@__PURE__*/ /Chrome\\/(\\d+)/.exec(nav.userAgent);\nconst webkit = \"webkitFontSmoothing\" in doc.documentElement.style;\nconst safari = !ie && /*@__PURE__*/ /Apple Computer/.test(nav.vendor);\nconst ios = safari && /*@__PURE__*/ (/Mobile\\/\\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);\nvar browser = {\n    mac: ios || /*@__PURE__*/ /Mac/.test(nav.platform),\n    windows: /*@__PURE__*/ /Win/.test(nav.platform),\n    linux: /*@__PURE__*/ /Linux|X11/.test(nav.platform),\n    ie,\n    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,\n    gecko,\n    gecko_version: gecko ? +/*@__PURE__*/ (/Firefox\\/(\\d+)/.exec(nav.userAgent) || [\n        0,\n        0\n    ])[1] : 0,\n    chrome: !!chrome,\n    chrome_version: chrome ? +chrome[1] : 0,\n    ios,\n    android: /*@__PURE__*/ /Android\\b/.test(nav.userAgent),\n    webkit,\n    safari,\n    webkit_version: webkit ? +/*@__PURE__*/ (/\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [\n        0,\n        0\n    ])[1] : 0,\n    tabSize: doc.documentElement.style.tabSize != null ? \"tab-size\" : \"-moz-tab-size\"\n};\nconst MaxJoinLen = 256;\nclass TextView extends ContentView {\n    constructor(text){\n        super();\n        this.text = text;\n    }\n    get length() {\n        return this.text.length;\n    }\n    createDOM(textDOM) {\n        this.setDOM(textDOM || document.createTextNode(this.text));\n    }\n    sync(view, track) {\n        if (!this.dom) this.createDOM();\n        if (this.dom.nodeValue != this.text) {\n            if (track && track.node == this.dom) track.written = true;\n            this.dom.nodeValue = this.text;\n        }\n    }\n    reuseDOM(dom) {\n        if (dom.nodeType == 3) this.createDOM(dom);\n    }\n    merge(from, to, source) {\n        if (this.flags & 8 /* ViewFlag.Composition */  || source && (!(source instanceof TextView) || this.length - (to - from) + source.length > MaxJoinLen || source.flags & 8 /* ViewFlag.Composition */ )) return false;\n        this.text = this.text.slice(0, from) + (source ? source.text : \"\") + this.text.slice(to);\n        this.markDirty();\n        return true;\n    }\n    split(from) {\n        let result = new TextView(this.text.slice(from));\n        this.text = this.text.slice(0, from);\n        this.markDirty();\n        result.flags |= this.flags & 8 /* ViewFlag.Composition */ ;\n        return result;\n    }\n    localPosFromDOM(node, offset) {\n        return node == this.dom ? offset : offset ? this.text.length : 0;\n    }\n    domAtPos(pos) {\n        return new DOMPos(this.dom, pos);\n    }\n    domBoundsAround(_from, _to, offset) {\n        return {\n            from: offset,\n            to: offset + this.length,\n            startDOM: this.dom,\n            endDOM: this.dom.nextSibling\n        };\n    }\n    coordsAt(pos, side) {\n        return textCoords(this.dom, pos, side);\n    }\n}\nclass MarkView extends ContentView {\n    constructor(mark, children = [], length = 0){\n        super();\n        this.mark = mark;\n        this.children = children;\n        this.length = length;\n        for (let ch of children)ch.setParent(this);\n    }\n    setAttrs(dom) {\n        clearAttributes(dom);\n        if (this.mark.class) dom.className = this.mark.class;\n        if (this.mark.attrs) for(let name in this.mark.attrs)dom.setAttribute(name, this.mark.attrs[name]);\n        return dom;\n    }\n    canReuseDOM(other) {\n        return super.canReuseDOM(other) && !((this.flags | other.flags) & 8 /* ViewFlag.Composition */ );\n    }\n    reuseDOM(node) {\n        if (node.nodeName == this.mark.tagName.toUpperCase()) {\n            this.setDOM(node);\n            this.flags |= 4 /* ViewFlag.AttrsDirty */  | 2 /* ViewFlag.NodeDirty */ ;\n        }\n    }\n    sync(view, track) {\n        if (!this.dom) this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));\n        else if (this.flags & 4 /* ViewFlag.AttrsDirty */ ) this.setAttrs(this.dom);\n        super.sync(view, track);\n    }\n    merge(from, to, source, _hasStart, openStart, openEnd) {\n        if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to < this.length && openEnd <= 0)) return false;\n        mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart - 1, openEnd - 1);\n        this.markDirty();\n        return true;\n    }\n    split(from) {\n        let result = [], off = 0, detachFrom = -1, i = 0;\n        for (let elt of this.children){\n            let end = off + elt.length;\n            if (end > from) result.push(off < from ? elt.split(from - off) : elt);\n            if (detachFrom < 0 && off >= from) detachFrom = i;\n            off = end;\n            i++;\n        }\n        let length = this.length - from;\n        this.length = from;\n        if (detachFrom > -1) {\n            this.children.length = detachFrom;\n            this.markDirty();\n        }\n        return new MarkView(this.mark, result, length);\n    }\n    domAtPos(pos) {\n        return inlineDOMAtPos(this, pos);\n    }\n    coordsAt(pos, side) {\n        return coordsInChildren(this, pos, side);\n    }\n}\nfunction textCoords(text, pos, side) {\n    let length = text.nodeValue.length;\n    if (pos > length) pos = length;\n    let from = pos, to = pos, flatten = 0;\n    if (pos == 0 && side < 0 || pos == length && side >= 0) {\n        if (!(browser.chrome || browser.gecko)) {\n            if (pos) {\n                from--;\n                flatten = 1;\n            } else if (to < length) {\n                to++;\n                flatten = -1;\n            }\n        }\n    } else {\n        if (side < 0) from--;\n        else if (to < length) to++;\n    }\n    let rects = textRange(text, from, to).getClientRects();\n    if (!rects.length) return null;\n    let rect = rects[(flatten ? flatten < 0 : side >= 0) ? 0 : rects.length - 1];\n    if (browser.safari && !flatten && rect.width == 0) rect = Array.prototype.find.call(rects, (r)=>r.width) || rect;\n    return flatten ? flattenRect(rect, flatten < 0) : rect || null;\n}\n// Also used for collapsed ranges that don't have a placeholder widget!\nclass WidgetView extends ContentView {\n    static create(widget, length, side) {\n        return new WidgetView(widget, length, side);\n    }\n    constructor(widget, length, side){\n        super();\n        this.widget = widget;\n        this.length = length;\n        this.side = side;\n        this.prevWidget = null;\n    }\n    split(from) {\n        let result = WidgetView.create(this.widget, this.length - from, this.side);\n        this.length -= from;\n        return result;\n    }\n    sync(view) {\n        if (!this.dom || !this.widget.updateDOM(this.dom, view)) {\n            if (this.dom && this.prevWidget) this.prevWidget.destroy(this.dom);\n            this.prevWidget = null;\n            this.setDOM(this.widget.toDOM(view));\n            if (!this.widget.editable) this.dom.contentEditable = \"false\";\n        }\n    }\n    getSide() {\n        return this.side;\n    }\n    merge(from, to, source, hasStart, openStart, openEnd) {\n        if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0)) return false;\n        this.length = from + (source ? source.length : 0) + (this.length - to);\n        return true;\n    }\n    become(other) {\n        if (other instanceof WidgetView && other.side == this.side && this.widget.constructor == other.widget.constructor) {\n            if (!this.widget.compare(other.widget)) this.markDirty(true);\n            if (this.dom && !this.prevWidget) this.prevWidget = this.widget;\n            this.widget = other.widget;\n            this.length = other.length;\n            return true;\n        }\n        return false;\n    }\n    ignoreMutation() {\n        return true;\n    }\n    ignoreEvent(event) {\n        return this.widget.ignoreEvent(event);\n    }\n    get overrideDOMText() {\n        if (this.length == 0) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n        let top = this;\n        while(top.parent)top = top.parent;\n        let { view } = top, text = view && view.state.doc, start = this.posAtStart;\n        return text ? text.slice(start, start + this.length) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n    }\n    domAtPos(pos) {\n        return (this.length ? pos == 0 : this.side > 0) ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n    }\n    domBoundsAround() {\n        return null;\n    }\n    coordsAt(pos, side) {\n        let custom = this.widget.coordsAt(this.dom, pos, side);\n        if (custom) return custom;\n        let rects = this.dom.getClientRects(), rect = null;\n        if (!rects.length) return null;\n        let fromBack = this.side ? this.side < 0 : pos > 0;\n        for(let i = fromBack ? rects.length - 1 : 0;; i += fromBack ? -1 : 1){\n            rect = rects[i];\n            if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom) break;\n        }\n        return flattenRect(rect, !fromBack);\n    }\n    get isEditable() {\n        return false;\n    }\n    get isWidget() {\n        return true;\n    }\n    get isHidden() {\n        return this.widget.isHidden;\n    }\n    destroy() {\n        super.destroy();\n        if (this.dom) this.widget.destroy(this.dom);\n    }\n}\n// These are drawn around uneditable widgets to avoid a number of\n// browser bugs that show up when the cursor is directly next to\n// uneditable inline content.\nclass WidgetBufferView extends ContentView {\n    constructor(side){\n        super();\n        this.side = side;\n    }\n    get length() {\n        return 0;\n    }\n    merge() {\n        return false;\n    }\n    become(other) {\n        return other instanceof WidgetBufferView && other.side == this.side;\n    }\n    split() {\n        return new WidgetBufferView(this.side);\n    }\n    sync() {\n        if (!this.dom) {\n            let dom = document.createElement(\"img\");\n            dom.className = \"cm-widgetBuffer\";\n            dom.setAttribute(\"aria-hidden\", \"true\");\n            this.setDOM(dom);\n        }\n    }\n    getSide() {\n        return this.side;\n    }\n    domAtPos(pos) {\n        return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom);\n    }\n    localPosFromDOM() {\n        return 0;\n    }\n    domBoundsAround() {\n        return null;\n    }\n    coordsAt(pos) {\n        return this.dom.getBoundingClientRect();\n    }\n    get overrideDOMText() {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n    }\n    get isHidden() {\n        return true;\n    }\n}\nTextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;\nfunction inlineDOMAtPos(parent, pos) {\n    let dom = parent.dom, { children } = parent, i = 0;\n    for(let off = 0; i < children.length; i++){\n        let child = children[i], end = off + child.length;\n        if (end == off && child.getSide() <= 0) continue;\n        if (pos > off && pos < end && child.dom.parentNode == dom) return child.domAtPos(pos - off);\n        if (pos <= off) break;\n        off = end;\n    }\n    for(let j = i; j > 0; j--){\n        let prev = children[j - 1];\n        if (prev.dom.parentNode == dom) return prev.domAtPos(prev.length);\n    }\n    for(let j = i; j < children.length; j++){\n        let next = children[j];\n        if (next.dom.parentNode == dom) return next.domAtPos(0);\n    }\n    return new DOMPos(dom, 0);\n}\n// Assumes `view`, if a mark view, has precisely 1 child.\nfunction joinInlineInto(parent, view, open) {\n    let last, { children } = parent;\n    if (open > 0 && view instanceof MarkView && children.length && (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {\n        joinInlineInto(last, view.children[0], open - 1);\n    } else {\n        children.push(view);\n        view.setParent(parent);\n    }\n    parent.length += view.length;\n}\nfunction coordsInChildren(view, pos, side) {\n    let before = null, beforePos = -1, after = null, afterPos = -1;\n    function scan(view, pos) {\n        for(let i = 0, off = 0; i < view.children.length && off <= pos; i++){\n            let child = view.children[i], end = off + child.length;\n            if (end >= pos) {\n                if (child.children.length) {\n                    scan(child, pos - off);\n                } else if ((!after || after.isHidden && side > 0) && (end > pos || off == end && child.getSide() > 0)) {\n                    after = child;\n                    afterPos = pos - off;\n                } else if (off < pos || off == end && child.getSide() < 0 && !child.isHidden) {\n                    before = child;\n                    beforePos = pos - off;\n                }\n            }\n            off = end;\n        }\n    }\n    scan(view, pos);\n    let target = (side < 0 ? before : after) || before || after;\n    if (target) return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);\n    return fallbackRect(view);\n}\nfunction fallbackRect(view) {\n    let last = view.dom.lastChild;\n    if (!last) return view.dom.getBoundingClientRect();\n    let rects = clientRectsFor(last);\n    return rects[rects.length - 1] || null;\n}\nfunction combineAttrs(source, target) {\n    for(let name in source){\n        if (name == \"class\" && target.class) target.class += \" \" + source.class;\n        else if (name == \"style\" && target.style) target.style += \";\" + source.style;\n        else target[name] = source[name];\n    }\n    return target;\n}\nconst noAttrs = /*@__PURE__*/ Object.create(null);\nfunction attrsEq(a, b, ignore) {\n    if (a == b) return true;\n    if (!a) a = noAttrs;\n    if (!b) b = noAttrs;\n    let keysA = Object.keys(a), keysB = Object.keys(b);\n    if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) != keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0)) return false;\n    for (let key of keysA){\n        if (key != ignore && (keysB.indexOf(key) == -1 || a[key] !== b[key])) return false;\n    }\n    return true;\n}\nfunction updateAttrs(dom, prev, attrs) {\n    let changed = false;\n    if (prev) {\n        for(let name in prev)if (!(attrs && name in attrs)) {\n            changed = true;\n            if (name == \"style\") dom.style.cssText = \"\";\n            else dom.removeAttribute(name);\n        }\n    }\n    if (attrs) {\n        for(let name in attrs)if (!(prev && prev[name] == attrs[name])) {\n            changed = true;\n            if (name == \"style\") dom.style.cssText = attrs[name];\n            else dom.setAttribute(name, attrs[name]);\n        }\n    }\n    return changed;\n}\nfunction getAttrs(dom) {\n    let attrs = Object.create(null);\n    for(let i = 0; i < dom.attributes.length; i++){\n        let attr = dom.attributes[i];\n        attrs[attr.name] = attr.value;\n    }\n    return attrs;\n}\nclass LineView extends ContentView {\n    constructor(){\n        super(...arguments);\n        this.children = [];\n        this.length = 0;\n        this.prevAttrs = undefined;\n        this.attrs = null;\n        this.breakAfter = 0;\n    }\n    // Consumes source\n    merge(from, to, source, hasStart, openStart, openEnd) {\n        if (source) {\n            if (!(source instanceof LineView)) return false;\n            if (!this.dom) source.transferDOM(this); // Reuse source.dom when appropriate\n        }\n        if (hasStart) this.setDeco(source ? source.attrs : null);\n        mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart, openEnd);\n        return true;\n    }\n    split(at) {\n        let end = new LineView;\n        end.breakAfter = this.breakAfter;\n        if (this.length == 0) return end;\n        let { i, off } = this.childPos(at);\n        if (off) {\n            end.append(this.children[i].split(off), 0);\n            this.children[i].merge(off, this.children[i].length, null, false, 0, 0);\n            i++;\n        }\n        for(let j = i; j < this.children.length; j++)end.append(this.children[j], 0);\n        while(i > 0 && this.children[i - 1].length == 0)this.children[--i].destroy();\n        this.children.length = i;\n        this.markDirty();\n        this.length = at;\n        return end;\n    }\n    transferDOM(other) {\n        if (!this.dom) return;\n        this.markDirty();\n        other.setDOM(this.dom);\n        other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;\n        this.prevAttrs = undefined;\n        this.dom = null;\n    }\n    setDeco(attrs) {\n        if (!attrsEq(this.attrs, attrs)) {\n            if (this.dom) {\n                this.prevAttrs = this.attrs;\n                this.markDirty();\n            }\n            this.attrs = attrs;\n        }\n    }\n    append(child, openStart) {\n        joinInlineInto(this, child, openStart);\n    }\n    // Only called when building a line view in ContentBuilder\n    addLineDeco(deco) {\n        let attrs = deco.spec.attributes, cls = deco.spec.class;\n        if (attrs) this.attrs = combineAttrs(attrs, this.attrs || {});\n        if (cls) this.attrs = combineAttrs({\n            class: cls\n        }, this.attrs || {});\n    }\n    domAtPos(pos) {\n        return inlineDOMAtPos(this, pos);\n    }\n    reuseDOM(node) {\n        if (node.nodeName == \"DIV\") {\n            this.setDOM(node);\n            this.flags |= 4 /* ViewFlag.AttrsDirty */  | 2 /* ViewFlag.NodeDirty */ ;\n        }\n    }\n    sync(view, track) {\n        var _a;\n        if (!this.dom) {\n            this.setDOM(document.createElement(\"div\"));\n            this.dom.className = \"cm-line\";\n            this.prevAttrs = this.attrs ? null : undefined;\n        } else if (this.flags & 4 /* ViewFlag.AttrsDirty */ ) {\n            clearAttributes(this.dom);\n            this.dom.className = \"cm-line\";\n            this.prevAttrs = this.attrs ? null : undefined;\n        }\n        if (this.prevAttrs !== undefined) {\n            updateAttrs(this.dom, this.prevAttrs, this.attrs);\n            this.dom.classList.add(\"cm-line\");\n            this.prevAttrs = undefined;\n        }\n        super.sync(view, track);\n        let last = this.dom.lastChild;\n        while(last && ContentView.get(last) instanceof MarkView)last = last.lastChild;\n        if (!last || !this.length || last.nodeName != \"BR\" && ((_a = ContentView.get(last)) === null || _a === void 0 ? void 0 : _a.isEditable) == false && (!browser.ios || !this.children.some((ch)=>ch instanceof TextView))) {\n            let hack = document.createElement(\"BR\");\n            hack.cmIgnore = true;\n            this.dom.appendChild(hack);\n        }\n    }\n    measureTextSize() {\n        if (this.children.length == 0 || this.length > 20) return null;\n        let totalWidth = 0, textHeight;\n        for (let child of this.children){\n            if (!(child instanceof TextView) || /[^ -~]/.test(child.text)) return null;\n            let rects = clientRectsFor(child.dom);\n            if (rects.length != 1) return null;\n            totalWidth += rects[0].width;\n            textHeight = rects[0].height;\n        }\n        return !totalWidth ? null : {\n            lineHeight: this.dom.getBoundingClientRect().height,\n            charWidth: totalWidth / this.length,\n            textHeight\n        };\n    }\n    coordsAt(pos, side) {\n        let rect = coordsInChildren(this, pos, side);\n        // Correct rectangle height for empty lines when the returned\n        // height is larger than the text height.\n        if (!this.children.length && rect && this.parent) {\n            let { heightOracle } = this.parent.view.viewState, height = rect.bottom - rect.top;\n            if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {\n                let dist = (height - heightOracle.textHeight) / 2;\n                return {\n                    top: rect.top + dist,\n                    bottom: rect.bottom - dist,\n                    left: rect.left,\n                    right: rect.left\n                };\n            }\n        }\n        return rect;\n    }\n    become(_other) {\n        return false;\n    }\n    covers() {\n        return true;\n    }\n    static find(docView, pos) {\n        for(let i = 0, off = 0; i < docView.children.length; i++){\n            let block = docView.children[i], end = off + block.length;\n            if (end >= pos) {\n                if (block instanceof LineView) return block;\n                if (end > pos) break;\n            }\n            off = end + block.breakAfter;\n        }\n        return null;\n    }\n}\nclass BlockWidgetView extends ContentView {\n    constructor(widget, length, deco){\n        super();\n        this.widget = widget;\n        this.length = length;\n        this.deco = deco;\n        this.breakAfter = 0;\n        this.prevWidget = null;\n    }\n    merge(from, to, source, _takeDeco, openStart, openEnd) {\n        if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0)) return false;\n        this.length = from + (source ? source.length : 0) + (this.length - to);\n        return true;\n    }\n    domAtPos(pos) {\n        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n    }\n    split(at) {\n        let len = this.length - at;\n        this.length = at;\n        let end = new BlockWidgetView(this.widget, len, this.deco);\n        end.breakAfter = this.breakAfter;\n        return end;\n    }\n    get children() {\n        return noChildren;\n    }\n    sync(view) {\n        if (!this.dom || !this.widget.updateDOM(this.dom, view)) {\n            if (this.dom && this.prevWidget) this.prevWidget.destroy(this.dom);\n            this.prevWidget = null;\n            this.setDOM(this.widget.toDOM(view));\n            if (!this.widget.editable) this.dom.contentEditable = \"false\";\n        }\n    }\n    get overrideDOMText() {\n        return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n    }\n    domBoundsAround() {\n        return null;\n    }\n    become(other) {\n        if (other instanceof BlockWidgetView && other.widget.constructor == this.widget.constructor) {\n            if (!other.widget.compare(this.widget)) this.markDirty(true);\n            if (this.dom && !this.prevWidget) this.prevWidget = this.widget;\n            this.widget = other.widget;\n            this.length = other.length;\n            this.deco = other.deco;\n            this.breakAfter = other.breakAfter;\n            return true;\n        }\n        return false;\n    }\n    ignoreMutation() {\n        return true;\n    }\n    ignoreEvent(event) {\n        return this.widget.ignoreEvent(event);\n    }\n    get isEditable() {\n        return false;\n    }\n    get isWidget() {\n        return true;\n    }\n    coordsAt(pos, side) {\n        return this.widget.coordsAt(this.dom, pos, side);\n    }\n    destroy() {\n        super.destroy();\n        if (this.dom) this.widget.destroy(this.dom);\n    }\n    covers(side) {\n        let { startSide, endSide } = this.deco;\n        return startSide == endSide ? false : side < 0 ? startSide < 0 : endSide > 0;\n    }\n}\n/**\nWidgets added to the content are described by subclasses of this\nclass. Using a description object like that makes it possible to\ndelay creating of the DOM structure for a widget until it is\nneeded, and to avoid redrawing widgets even if the decorations\nthat define them are recreated.\n*/ class WidgetType {\n    /**\n    Compare this instance to another instance of the same type.\n    (TypeScript can't express this, but only instances of the same\n    specific class will be passed to this method.) This is used to\n    avoid redrawing widgets when they are replaced by a new\n    decoration of the same type. The default implementation just\n    returns `false`, which will cause new instances of the widget to\n    always be redrawn.\n    */ eq(widget) {\n        return false;\n    }\n    /**\n    Update a DOM element created by a widget of the same type (but\n    different, non-`eq` content) to reflect this widget. May return\n    true to indicate that it could update, false to indicate it\n    couldn't (in which case the widget will be redrawn). The default\n    implementation just returns false.\n    */ updateDOM(dom, view) {\n        return false;\n    }\n    /**\n    @internal\n    */ compare(other) {\n        return this == other || this.constructor == other.constructor && this.eq(other);\n    }\n    /**\n    The estimated height this widget will have, to be used when\n    estimating the height of content that hasn't been drawn. May\n    return -1 to indicate you don't know. The default implementation\n    returns -1.\n    */ get estimatedHeight() {\n        return -1;\n    }\n    /**\n    For inline widgets that are displayed inline (as opposed to\n    `inline-block`) and introduce line breaks (through `<br>` tags\n    or textual newlines), this must indicate the amount of line\n    breaks they introduce. Defaults to 0.\n    */ get lineBreaks() {\n        return 0;\n    }\n    /**\n    Can be used to configure which kinds of events inside the widget\n    should be ignored by the editor. The default is to ignore all\n    events.\n    */ ignoreEvent(event) {\n        return true;\n    }\n    /**\n    Override the way screen coordinates for positions at/in the\n    widget are found. `pos` will be the offset into the widget, and\n    `side` the side of the position that is being queried—less than\n    zero for before, greater than zero for after, and zero for\n    directly at that position.\n    */ coordsAt(dom, pos, side) {\n        return null;\n    }\n    /**\n    @internal\n    */ get isHidden() {\n        return false;\n    }\n    /**\n    @internal\n    */ get editable() {\n        return false;\n    }\n    /**\n    This is called when the an instance of the widget is removed\n    from the editor view.\n    */ destroy(dom) {}\n}\n/**\nThe different types of blocks that can occur in an editor view.\n*/ var BlockType = /*@__PURE__*/ function(BlockType) {\n    /**\n    A line of text.\n    */ BlockType[BlockType[\"Text\"] = 0] = \"Text\";\n    /**\n    A block widget associated with the position after it.\n    */ BlockType[BlockType[\"WidgetBefore\"] = 1] = \"WidgetBefore\";\n    /**\n    A block widget associated with the position before it.\n    */ BlockType[BlockType[\"WidgetAfter\"] = 2] = \"WidgetAfter\";\n    /**\n    A block widget [replacing](https://codemirror.net/6/docs/ref/#view.Decoration^replace) a range of content.\n    */ BlockType[BlockType[\"WidgetRange\"] = 3] = \"WidgetRange\";\n    return BlockType;\n}(BlockType || (BlockType = {}));\n/**\nA decoration provides information on how to draw or style a piece\nof content. You'll usually use it wrapped in a\n[`Range`](https://codemirror.net/6/docs/ref/#state.Range), which adds a start and end position.\n@nonabstract\n*/ class Decoration extends _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeValue {\n    constructor(/**\n    @internal\n    */ startSide, /**\n    @internal\n    */ endSide, /**\n    @internal\n    */ widget, /**\n    The config object used to create this decoration. You can\n    include additional properties in there to store metadata about\n    your decoration.\n    */ spec){\n        super();\n        this.startSide = startSide;\n        this.endSide = endSide;\n        this.widget = widget;\n        this.spec = spec;\n    }\n    /**\n    @internal\n    */ get heightRelevant() {\n        return false;\n    }\n    /**\n    Create a mark decoration, which influences the styling of the\n    content in its range. Nested mark decorations will cause nested\n    DOM elements to be created. Nesting order is determined by\n    precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with\n    the higher-precedence decorations creating the inner DOM nodes.\n    Such elements are split on line boundaries and on the boundaries\n    of lower-precedence decorations.\n    */ static mark(spec) {\n        return new MarkDecoration(spec);\n    }\n    /**\n    Create a widget decoration, which displays a DOM element at the\n    given position.\n    */ static widget(spec) {\n        let side = Math.max(-10000, Math.min(10000, spec.side || 0)), block = !!spec.block;\n        side += block && !spec.inlineOrder ? side > 0 ? 300000000 /* Side.BlockAfter */  : -400000000 /* Side.BlockBefore */  : side > 0 ? 100000000 /* Side.InlineAfter */  : -100000000 /* Side.InlineBefore */ ;\n        return new PointDecoration(spec, side, side, block, spec.widget || null, false);\n    }\n    /**\n    Create a replace decoration which replaces the given range with\n    a widget, or simply hides it.\n    */ static replace(spec) {\n        let block = !!spec.block, startSide, endSide;\n        if (spec.isBlockGap) {\n            startSide = -500000000 /* Side.GapStart */ ;\n            endSide = 400000000 /* Side.GapEnd */ ;\n        } else {\n            let { start, end } = getInclusive(spec, block);\n            startSide = (start ? block ? -300000000 /* Side.BlockIncStart */  : -1 /* Side.InlineIncStart */  : 500000000 /* Side.NonIncStart */ ) - 1;\n            endSide = (end ? block ? 200000000 /* Side.BlockIncEnd */  : 1 /* Side.InlineIncEnd */  : -600000000 /* Side.NonIncEnd */ ) + 1;\n        }\n        return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);\n    }\n    /**\n    Create a line decoration, which can add DOM attributes to the\n    line starting at the given position.\n    */ static line(spec) {\n        return new LineDecoration(spec);\n    }\n    /**\n    Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given\n    decorated range or ranges. If the ranges aren't already sorted,\n    pass `true` for `sort` to make the library sort them for you.\n    */ static set(of, sort = false) {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.of(of, sort);\n    }\n    /**\n    @internal\n    */ hasHeight() {\n        return this.widget ? this.widget.estimatedHeight > -1 : false;\n    }\n}\n/**\nThe empty set of decorations.\n*/ Decoration.none = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.empty;\nclass MarkDecoration extends Decoration {\n    constructor(spec){\n        let { start, end } = getInclusive(spec);\n        super(start ? -1 /* Side.InlineIncStart */  : 500000000 /* Side.NonIncStart */ , end ? 1 /* Side.InlineIncEnd */  : -600000000 /* Side.NonIncEnd */ , null, spec);\n        this.tagName = spec.tagName || \"span\";\n        this.class = spec.class || \"\";\n        this.attrs = spec.attributes || null;\n    }\n    eq(other) {\n        var _a, _b;\n        return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && (this.class || ((_a = this.attrs) === null || _a === void 0 ? void 0 : _a.class)) == (other.class || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b.class)) && attrsEq(this.attrs, other.attrs, \"class\");\n    }\n    range(from, to = from) {\n        if (from >= to) throw new RangeError(\"Mark decorations may not be empty\");\n        return super.range(from, to);\n    }\n}\nMarkDecoration.prototype.point = false;\nclass LineDecoration extends Decoration {\n    constructor(spec){\n        super(-200000000 /* Side.Line */ , -200000000 /* Side.Line */ , null, spec);\n    }\n    eq(other) {\n        return other instanceof LineDecoration && this.spec.class == other.spec.class && attrsEq(this.spec.attributes, other.spec.attributes);\n    }\n    range(from, to = from) {\n        if (to != from) throw new RangeError(\"Line decoration ranges must be zero-length\");\n        return super.range(from, to);\n    }\n}\nLineDecoration.prototype.mapMode = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackBefore;\nLineDecoration.prototype.point = true;\nclass PointDecoration extends Decoration {\n    constructor(spec, startSide, endSide, block, widget, isReplace){\n        super(startSide, endSide, widget, spec);\n        this.block = block;\n        this.isReplace = isReplace;\n        this.mapMode = !block ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackDel : startSide <= 0 ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackBefore : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackAfter;\n    }\n    // Only relevant when this.block == true\n    get type() {\n        return this.startSide != this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;\n    }\n    get heightRelevant() {\n        return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);\n    }\n    eq(other) {\n        return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;\n    }\n    range(from, to = from) {\n        if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide <= 0)) throw new RangeError(\"Invalid range for replacement decoration\");\n        if (!this.isReplace && to != from) throw new RangeError(\"Widget decorations can only have zero-length ranges\");\n        return super.range(from, to);\n    }\n}\nPointDecoration.prototype.point = true;\nfunction getInclusive(spec, block = false) {\n    let { inclusiveStart: start, inclusiveEnd: end } = spec;\n    if (start == null) start = spec.inclusive;\n    if (end == null) end = spec.inclusive;\n    return {\n        start: start !== null && start !== void 0 ? start : block,\n        end: end !== null && end !== void 0 ? end : block\n    };\n}\nfunction widgetsEq(a, b) {\n    return a == b || !!(a && b && a.compare(b));\n}\nfunction addRange(from, to, ranges, margin = 0) {\n    let last = ranges.length - 1;\n    if (last >= 0 && ranges[last] + margin >= from) ranges[last] = Math.max(ranges[last], to);\n    else ranges.push(from, to);\n}\nclass ContentBuilder {\n    constructor(doc, pos, end, disallowBlockEffectsFor){\n        this.doc = doc;\n        this.pos = pos;\n        this.end = end;\n        this.disallowBlockEffectsFor = disallowBlockEffectsFor;\n        this.content = [];\n        this.curLine = null;\n        this.breakAtStart = 0;\n        this.pendingBuffer = 0 /* Buf.No */ ;\n        this.bufferMarks = [];\n        // Set to false directly after a widget that covers the position after it\n        this.atCursorPos = true;\n        this.openStart = -1;\n        this.openEnd = -1;\n        this.text = \"\";\n        this.textOff = 0;\n        this.cursor = doc.iter();\n        this.skip = pos;\n    }\n    posCovered() {\n        if (this.content.length == 0) return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;\n        let last = this.content[this.content.length - 1];\n        return !(last.breakAfter || last instanceof BlockWidgetView && last.deco.endSide < 0);\n    }\n    getLine() {\n        if (!this.curLine) {\n            this.content.push(this.curLine = new LineView);\n            this.atCursorPos = true;\n        }\n        return this.curLine;\n    }\n    flushBuffer(active = this.bufferMarks) {\n        if (this.pendingBuffer) {\n            this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);\n            this.pendingBuffer = 0 /* Buf.No */ ;\n        }\n    }\n    addBlockWidget(view) {\n        this.flushBuffer();\n        this.curLine = null;\n        this.content.push(view);\n    }\n    finish(openEnd) {\n        if (this.pendingBuffer && openEnd <= this.bufferMarks.length) this.flushBuffer();\n        else this.pendingBuffer = 0 /* Buf.No */ ;\n        if (!this.posCovered() && !(openEnd && this.content.length && this.content[this.content.length - 1] instanceof BlockWidgetView)) this.getLine();\n    }\n    buildText(length, active, openStart) {\n        while(length > 0){\n            if (this.textOff == this.text.length) {\n                let { value, lineBreak, done } = this.cursor.next(this.skip);\n                this.skip = 0;\n                if (done) throw new Error(\"Ran out of text content when drawing inline views\");\n                if (lineBreak) {\n                    if (!this.posCovered()) this.getLine();\n                    if (this.content.length) this.content[this.content.length - 1].breakAfter = 1;\n                    else this.breakAtStart = 1;\n                    this.flushBuffer();\n                    this.curLine = null;\n                    this.atCursorPos = true;\n                    length--;\n                    continue;\n                } else {\n                    this.text = value;\n                    this.textOff = 0;\n                }\n            }\n            let take = Math.min(this.text.length - this.textOff, length, 512 /* T.Chunk */ );\n            this.flushBuffer(active.slice(active.length - openStart));\n            this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);\n            this.atCursorPos = true;\n            this.textOff += take;\n            length -= take;\n            openStart = 0;\n        }\n    }\n    span(from, to, active, openStart) {\n        this.buildText(to - from, active, openStart);\n        this.pos = to;\n        if (this.openStart < 0) this.openStart = openStart;\n    }\n    point(from, to, deco, active, openStart, index) {\n        if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {\n            if (deco.block) throw new RangeError(\"Block decorations may not be specified via plugins\");\n            if (to > this.doc.lineAt(this.pos).to) throw new RangeError(\"Decorations that replace line breaks may not be specified via plugins\");\n        }\n        let len = to - from;\n        if (deco instanceof PointDecoration) {\n            if (deco.block) {\n                if (deco.startSide > 0 && !this.posCovered()) this.getLine();\n                this.addBlockWidget(new BlockWidgetView(deco.widget || new NullWidget(\"div\"), len, deco));\n            } else {\n                let view = WidgetView.create(deco.widget || new NullWidget(\"span\"), len, len ? 0 : deco.startSide);\n                let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to || deco.startSide > 0);\n                let cursorAfter = !view.isEditable && (from < to || openStart > active.length || deco.startSide <= 0);\n                let line = this.getLine();\n                if (this.pendingBuffer == 2 /* Buf.IfCursor */  && !cursorBefore && !view.isEditable) this.pendingBuffer = 0 /* Buf.No */ ;\n                this.flushBuffer(active);\n                if (cursorBefore) {\n                    line.append(wrapMarks(new WidgetBufferView(1), active), openStart);\n                    openStart = active.length + Math.max(0, openStart - active.length);\n                }\n                line.append(wrapMarks(view, active), openStart);\n                this.atCursorPos = cursorAfter;\n                this.pendingBuffer = !cursorAfter ? 0 /* Buf.No */  : from < to || openStart > active.length ? 1 /* Buf.Yes */  : 2 /* Buf.IfCursor */ ;\n                if (this.pendingBuffer) this.bufferMarks = active.slice();\n            }\n        } else if (this.doc.lineAt(this.pos).from == this.pos) {\n            this.getLine().addLineDeco(deco);\n        }\n        if (len) {\n            // Advance the iterator past the replaced content\n            if (this.textOff + len <= this.text.length) {\n                this.textOff += len;\n            } else {\n                this.skip += len - (this.text.length - this.textOff);\n                this.text = \"\";\n                this.textOff = 0;\n            }\n            this.pos = to;\n        }\n        if (this.openStart < 0) this.openStart = openStart;\n    }\n    static build(text, from, to, decorations, dynamicDecorationMap) {\n        let builder = new ContentBuilder(text, from, to, dynamicDecorationMap);\n        builder.openEnd = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(decorations, from, to, builder);\n        if (builder.openStart < 0) builder.openStart = builder.openEnd;\n        builder.finish(builder.openEnd);\n        return builder;\n    }\n}\nfunction wrapMarks(view, active) {\n    for (let mark of active)view = new MarkView(mark, [\n        view\n    ], view.length);\n    return view;\n}\nclass NullWidget extends WidgetType {\n    constructor(tag){\n        super();\n        this.tag = tag;\n    }\n    eq(other) {\n        return other.tag == this.tag;\n    }\n    toDOM() {\n        return document.createElement(this.tag);\n    }\n    updateDOM(elt) {\n        return elt.nodeName.toLowerCase() == this.tag;\n    }\n    get isHidden() {\n        return true;\n    }\n}\n/**\nUsed to indicate [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).\n*/ var Direction = /*@__PURE__*/ function(Direction) {\n    // (These are chosen to match the base levels, in bidi algorithm\n    // terms, of spans in that direction.)\n    /**\n    Left-to-right.\n    */ Direction[Direction[\"LTR\"] = 0] = \"LTR\";\n    /**\n    Right-to-left.\n    */ Direction[Direction[\"RTL\"] = 1] = \"RTL\";\n    return Direction;\n}(Direction || (Direction = {}));\nconst LTR = Direction.LTR, RTL = Direction.RTL;\n// Decode a string with each type encoded as log2(type)\nfunction dec(str) {\n    let result = [];\n    for(let i = 0; i < str.length; i++)result.push(1 << +str[i]);\n    return result;\n}\n// Character types for codepoints 0 to 0xf8\nconst LowTypes = /*@__PURE__*/ dec(\"88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008\");\n// Character types for codepoints 0x600 to 0x6f9\nconst ArabicTypes = /*@__PURE__*/ dec(\"4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333\");\nconst Brackets = /*@__PURE__*/ Object.create(null), BracketStack = [];\n// There's a lot more in\n// https://www.unicode.org/Public/UCD/latest/ucd/BidiBrackets.txt,\n// which are left out to keep code size down.\nfor (let p of [\n    \"()\",\n    \"[]\",\n    \"{}\"\n]){\n    let l = /*@__PURE__*/ p.charCodeAt(0), r = /*@__PURE__*/ p.charCodeAt(1);\n    Brackets[l] = r;\n    Brackets[r] = -l;\n}\nfunction charType(ch) {\n    return ch <= 0xf7 ? LowTypes[ch] : 0x590 <= ch && ch <= 0x5f4 ? 2 /* T.R */  : 0x600 <= ch && ch <= 0x6f9 ? ArabicTypes[ch - 0x600] : 0x6ee <= ch && ch <= 0x8ac ? 4 /* T.AL */  : 0x2000 <= ch && ch <= 0x200c ? 256 /* T.NI */  : 0xfb50 <= ch && ch <= 0xfdff ? 4 /* T.AL */  : 1 /* T.L */ ;\n}\nconst BidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac\\ufb50-\\ufdff]/;\n/**\nRepresents a contiguous range of text that has a single direction\n(as in left-to-right or right-to-left).\n*/ class BidiSpan {\n    /**\n    The direction of this span.\n    */ get dir() {\n        return this.level % 2 ? RTL : LTR;\n    }\n    /**\n    @internal\n    */ constructor(/**\n    The start of the span (relative to the start of the line).\n    */ from, /**\n    The end of the span.\n    */ to, /**\n    The [\"bidi\n    level\"](https://unicode.org/reports/tr9/#Basic_Display_Algorithm)\n    of the span (in this context, 0 means\n    left-to-right, 1 means right-to-left, 2 means left-to-right\n    number inside right-to-left text).\n    */ level){\n        this.from = from;\n        this.to = to;\n        this.level = level;\n    }\n    /**\n    @internal\n    */ side(end, dir) {\n        return this.dir == dir == end ? this.to : this.from;\n    }\n    /**\n    @internal\n    */ forward(forward, dir) {\n        return forward == (this.dir == dir);\n    }\n    /**\n    @internal\n    */ static find(order, index, level, assoc) {\n        let maybe = -1;\n        for(let i = 0; i < order.length; i++){\n            let span = order[i];\n            if (span.from <= index && span.to >= index) {\n                if (span.level == level) return i;\n                // When multiple spans match, if assoc != 0, take the one that\n                // covers that side, otherwise take the one with the minimum\n                // level.\n                if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index : span.to > index : order[maybe].level > span.level)) maybe = i;\n            }\n        }\n        if (maybe < 0) throw new RangeError(\"Index out of range\");\n        return maybe;\n    }\n}\nfunction isolatesEq(a, b) {\n    if (a.length != b.length) return false;\n    for(let i = 0; i < a.length; i++){\n        let iA = a[i], iB = b[i];\n        if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner)) return false;\n    }\n    return true;\n}\n// Reused array of character types\nconst types = [];\n// Fill in the character types (in `types`) from `from` to `to` and\n// apply W normalization rules.\nfunction computeCharTypes(line, rFrom, rTo, isolates, outerType) {\n    for(let iI = 0; iI <= isolates.length; iI++){\n        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;\n        let prevType = iI ? 256 /* T.NI */  : outerType;\n        // W1. Examine each non-spacing mark (NSM) in the level run, and\n        // change the type of the NSM to the type of the previous\n        // character. If the NSM is at the start of the level run, it will\n        // get the type of sor.\n        // W2. Search backwards from each instance of a European number\n        // until the first strong type (R, L, AL, or sor) is found. If an\n        // AL is found, change the type of the European number to Arabic\n        // number.\n        // W3. Change all ALs to R.\n        // (Left after this: L, R, EN, AN, ET, CS, NI)\n        for(let i = from, prev = prevType, prevStrong = prevType; i < to; i++){\n            let type = charType(line.charCodeAt(i));\n            if (type == 512 /* T.NSM */ ) type = prev;\n            else if (type == 8 /* T.EN */  && prevStrong == 4 /* T.AL */ ) type = 16 /* T.AN */ ;\n            types[i] = type == 4 /* T.AL */  ? 2 /* T.R */  : type;\n            if (type & 7 /* T.Strong */ ) prevStrong = type;\n            prev = type;\n        }\n        // W5. A sequence of European terminators adjacent to European\n        // numbers changes to all European numbers.\n        // W6. Otherwise, separators and terminators change to Other\n        // Neutral.\n        // W7. Search backwards from each instance of a European number\n        // until the first strong type (R, L, or sor) is found. If an L is\n        // found, then change the type of the European number to L.\n        // (Left after this: L, R, EN+AN, NI)\n        for(let i = from, prev = prevType, prevStrong = prevType; i < to; i++){\n            let type = types[i];\n            if (type == 128 /* T.CS */ ) {\n                if (i < to - 1 && prev == types[i + 1] && prev & 24 /* T.Num */ ) type = types[i] = prev;\n                else types[i] = 256 /* T.NI */ ;\n            } else if (type == 64 /* T.ET */ ) {\n                let end = i + 1;\n                while(end < to && types[end] == 64 /* T.ET */ )end++;\n                let replace = i && prev == 8 /* T.EN */  || end < rTo && types[end] == 8 /* T.EN */  ? prevStrong == 1 /* T.L */  ? 1 /* T.L */  : 8 /* T.EN */  : 256 /* T.NI */ ;\n                for(let j = i; j < end; j++)types[j] = replace;\n                i = end - 1;\n            } else if (type == 8 /* T.EN */  && prevStrong == 1 /* T.L */ ) {\n                types[i] = 1 /* T.L */ ;\n            }\n            prev = type;\n            if (type & 7 /* T.Strong */ ) prevStrong = type;\n        }\n    }\n}\n// Process brackets throughout a run sequence.\nfunction processBracketPairs(line, rFrom, rTo, isolates, outerType) {\n    let oppositeType = outerType == 1 /* T.L */  ? 2 /* T.R */  : 1 /* T.L */ ;\n    for(let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++){\n        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;\n        // N0. Process bracket pairs in an isolating run sequence\n        // sequentially in the logical order of the text positions of the\n        // opening paired brackets using the logic given below. Within this\n        // scope, bidirectional types EN and AN are treated as R.\n        for(let i = from, ch, br, type; i < to; i++){\n            // Keeps [startIndex, type, strongSeen] triples for each open\n            // bracket on BracketStack.\n            if (br = Brackets[ch = line.charCodeAt(i)]) {\n                if (br < 0) {\n                    for(let sJ = sI - 3; sJ >= 0; sJ -= 3){\n                        if (BracketStack[sJ + 1] == -br) {\n                            let flags = BracketStack[sJ + 2];\n                            let type = flags & 2 /* Bracketed.EmbedInside */  ? outerType : !(flags & 4 /* Bracketed.OppositeInside */ ) ? 0 : flags & 1 /* Bracketed.OppositeBefore */  ? oppositeType : outerType;\n                            if (type) types[i] = types[BracketStack[sJ]] = type;\n                            sI = sJ;\n                            break;\n                        }\n                    }\n                } else if (BracketStack.length == 189 /* Bracketed.MaxDepth */ ) {\n                    break;\n                } else {\n                    BracketStack[sI++] = i;\n                    BracketStack[sI++] = ch;\n                    BracketStack[sI++] = context;\n                }\n            } else if ((type = types[i]) == 2 /* T.R */  || type == 1 /* T.L */ ) {\n                let embed = type == outerType;\n                context = embed ? 0 : 1 /* Bracketed.OppositeBefore */ ;\n                for(let sJ = sI - 3; sJ >= 0; sJ -= 3){\n                    let cur = BracketStack[sJ + 2];\n                    if (cur & 2 /* Bracketed.EmbedInside */ ) break;\n                    if (embed) {\n                        BracketStack[sJ + 2] |= 2 /* Bracketed.EmbedInside */ ;\n                    } else {\n                        if (cur & 4 /* Bracketed.OppositeInside */ ) break;\n                        BracketStack[sJ + 2] |= 4 /* Bracketed.OppositeInside */ ;\n                    }\n                }\n            }\n        }\n    }\n}\nfunction processNeutrals(rFrom, rTo, isolates, outerType) {\n    for(let iI = 0, prev = outerType; iI <= isolates.length; iI++){\n        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;\n        // N1. A sequence of neutrals takes the direction of the\n        // surrounding strong text if the text on both sides has the same\n        // direction. European and Arabic numbers act as if they were R in\n        // terms of their influence on neutrals. Start-of-level-run (sor)\n        // and end-of-level-run (eor) are used at level run boundaries.\n        // N2. Any remaining neutrals take the embedding direction.\n        // (Left after this: L, R, EN+AN)\n        for(let i = from; i < to;){\n            let type = types[i];\n            if (type == 256 /* T.NI */ ) {\n                let end = i + 1;\n                for(;;){\n                    if (end == to) {\n                        if (iI == isolates.length) break;\n                        end = isolates[iI++].to;\n                        to = iI < isolates.length ? isolates[iI].from : rTo;\n                    } else if (types[end] == 256 /* T.NI */ ) {\n                        end++;\n                    } else {\n                        break;\n                    }\n                }\n                let beforeL = prev == 1 /* T.L */ ;\n                let afterL = (end < rTo ? types[end] : outerType) == 1 /* T.L */ ;\n                let replace = beforeL == afterL ? beforeL ? 1 /* T.L */  : 2 /* T.R */  : outerType;\n                for(let j = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j > i;){\n                    if (j == fromJ) {\n                        j = isolates[--jI].from;\n                        fromJ = jI ? isolates[jI - 1].to : rFrom;\n                    }\n                    types[--j] = replace;\n                }\n                i = end;\n            } else {\n                prev = type;\n                i++;\n            }\n        }\n    }\n}\n// Find the contiguous ranges of character types in a given range, and\n// emit spans for them. Flip the order of the spans as appropriate\n// based on the level, and call through to compute the spans for\n// isolates at the proper point.\nfunction emitSpans(line, from, to, level, baseLevel, isolates, order) {\n    let ourType = level % 2 ? 2 /* T.R */  : 1 /* T.L */ ;\n    if (level % 2 == baseLevel % 2) {\n        for(let iCh = from, iI = 0; iCh < to;){\n            // Scan a section of characters in direction ourType, unless\n            // there's another type of char right after iCh, in which case\n            // we scan a section of other characters (which, if ourType ==\n            // T.L, may contain both T.R and T.AN chars).\n            let sameDir = true, isNum = false;\n            if (iI == isolates.length || iCh < isolates[iI].from) {\n                let next = types[iCh];\n                if (next != ourType) {\n                    sameDir = false;\n                    isNum = next == 16 /* T.AN */ ;\n                }\n            }\n            // Holds an array of isolates to pass to a recursive call if we\n            // must recurse (to distinguish T.AN inside an RTL section in\n            // LTR text), null if we can emit directly\n            let recurse = !sameDir && ourType == 1 /* T.L */  ? [] : null;\n            let localLevel = sameDir ? level : level + 1;\n            let iScan = iCh;\n            run: for(;;){\n                if (iI < isolates.length && iScan == isolates[iI].from) {\n                    if (isNum) break run;\n                    let iso = isolates[iI];\n                    // Scan ahead to verify that there is another char in this dir after the isolate(s)\n                    if (!sameDir) for(let upto = iso.to, jI = iI + 1;;){\n                        if (upto == to) break run;\n                        if (jI < isolates.length && isolates[jI].from == upto) upto = isolates[jI++].to;\n                        else if (types[upto] == ourType) break run;\n                        else break;\n                    }\n                    iI++;\n                    if (recurse) {\n                        recurse.push(iso);\n                    } else {\n                        if (iso.from > iCh) order.push(new BidiSpan(iCh, iso.from, localLevel));\n                        let dirSwap = iso.direction == LTR != !(localLevel % 2);\n                        computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);\n                        iCh = iso.to;\n                    }\n                    iScan = iso.to;\n                } else if (iScan == to || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {\n                    break;\n                } else {\n                    iScan++;\n                }\n            }\n            if (recurse) emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);\n            else if (iCh < iScan) order.push(new BidiSpan(iCh, iScan, localLevel));\n            iCh = iScan;\n        }\n    } else {\n        // Iterate in reverse to flip the span order. Same code again, but\n        // going from the back of the section to the front\n        for(let iCh = to, iI = isolates.length; iCh > from;){\n            let sameDir = true, isNum = false;\n            if (!iI || iCh > isolates[iI - 1].to) {\n                let next = types[iCh - 1];\n                if (next != ourType) {\n                    sameDir = false;\n                    isNum = next == 16 /* T.AN */ ;\n                }\n            }\n            let recurse = !sameDir && ourType == 1 /* T.L */  ? [] : null;\n            let localLevel = sameDir ? level : level + 1;\n            let iScan = iCh;\n            run: for(;;){\n                if (iI && iScan == isolates[iI - 1].to) {\n                    if (isNum) break run;\n                    let iso = isolates[--iI];\n                    // Scan ahead to verify that there is another char in this dir after the isolate(s)\n                    if (!sameDir) for(let upto = iso.from, jI = iI;;){\n                        if (upto == from) break run;\n                        if (jI && isolates[jI - 1].to == upto) upto = isolates[--jI].from;\n                        else if (types[upto - 1] == ourType) break run;\n                        else break;\n                    }\n                    if (recurse) {\n                        recurse.push(iso);\n                    } else {\n                        if (iso.to < iCh) order.push(new BidiSpan(iso.to, iCh, localLevel));\n                        let dirSwap = iso.direction == LTR != !(localLevel % 2);\n                        computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);\n                        iCh = iso.from;\n                    }\n                    iScan = iso.from;\n                } else if (iScan == from || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {\n                    break;\n                } else {\n                    iScan--;\n                }\n            }\n            if (recurse) emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order);\n            else if (iScan < iCh) order.push(new BidiSpan(iScan, iCh, localLevel));\n            iCh = iScan;\n        }\n    }\n}\nfunction computeSectionOrder(line, level, baseLevel, isolates, from, to, order) {\n    let outerType = level % 2 ? 2 /* T.R */  : 1 /* T.L */ ;\n    computeCharTypes(line, from, to, isolates, outerType);\n    processBracketPairs(line, from, to, isolates, outerType);\n    processNeutrals(from, to, isolates, outerType);\n    emitSpans(line, from, to, level, baseLevel, isolates, order);\n}\nfunction computeOrder(line, direction, isolates) {\n    if (!line) return [\n        new BidiSpan(0, 0, direction == RTL ? 1 : 0)\n    ];\n    if (direction == LTR && !isolates.length && !BidiRE.test(line)) return trivialOrder(line.length);\n    if (isolates.length) while(line.length > types.length)types[types.length] = 256 /* T.NI */ ; // Make sure types array has no gaps\n    let order = [], level = direction == LTR ? 0 : 1;\n    computeSectionOrder(line, level, level, isolates, 0, line.length, order);\n    return order;\n}\nfunction trivialOrder(length) {\n    return [\n        new BidiSpan(0, length, 0)\n    ];\n}\nlet movedOver = \"\";\n// This implementation moves strictly visually, without concern for a\n// traversal visiting every logical position in the string. It will\n// still do so for simple input, but situations like multiple isolates\n// with the same level next to each other, or text going against the\n// main dir at the end of the line, will make some positions\n// unreachable with this motion. Each visible cursor position will\n// correspond to the lower-level bidi span that touches it.\n//\n// The alternative would be to solve an order globally for a given\n// line, making sure that it includes every position, but that would\n// require associating non-canonical (higher bidi span level)\n// positions with a given visual position, which is likely to confuse\n// people. (And would generally be a lot more complicated.)\nfunction moveVisually(line, order, dir, start, forward) {\n    var _a;\n    let startIndex = start.head - line.from;\n    let spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);\n    let span = order[spanI], spanEnd = span.side(forward, dir);\n    // End of span\n    if (startIndex == spanEnd) {\n        let nextI = spanI += forward ? 1 : -1;\n        if (nextI < 0 || nextI >= order.length) return null;\n        span = order[spanI = nextI];\n        startIndex = span.side(!forward, dir);\n        spanEnd = span.side(forward, dir);\n    }\n    let nextIndex = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, startIndex, span.forward(forward, dir));\n    if (nextIndex < span.from || nextIndex > span.to) nextIndex = spanEnd;\n    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));\n    let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];\n    if (nextSpan && nextIndex == spanEnd && nextSpan.level + (forward ? 0 : 1) < span.level) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, nextSpan.forward(forward, dir) ? 1 : -1, nextSpan.level);\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(nextIndex + line.from, span.forward(forward, dir) ? -1 : 1, span.level);\n}\nfunction autoDirection(text, from, to) {\n    for(let i = from; i < to; i++){\n        let type = charType(text.charCodeAt(i));\n        if (type == 1 /* T.L */ ) return LTR;\n        if (type == 2 /* T.R */  || type == 4 /* T.AL */ ) return RTL;\n    }\n    return LTR;\n}\nconst clickAddsSelectionRange = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst dragMovesSelection$1 = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst mouseSelectionStyle = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst exceptionSink = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst updateListener = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst inputHandler = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst focusChangeEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst perLineTextDirection = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (values)=>values.some((x)=>x)\n});\nconst nativeSelectionHidden = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (values)=>values.some((x)=>x)\n});\nclass ScrollTarget {\n    constructor(range, y = \"nearest\", x = \"nearest\", yMargin = 5, xMargin = 5, // This data structure is abused to also store precise scroll\n    // snapshots, instead of a `scrollIntoView` request. When this\n    // flag is `true`, `range` points at a position in the reference\n    // line, `yMargin` holds the difference between the top of that\n    // line and the top of the editor, and `xMargin` holds the\n    // editor's `scrollLeft`.\n    isSnapshot = false){\n        this.range = range;\n        this.y = y;\n        this.x = x;\n        this.yMargin = yMargin;\n        this.xMargin = xMargin;\n        this.isSnapshot = isSnapshot;\n    }\n    map(changes) {\n        return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);\n    }\n    clip(state) {\n        return this.range.to <= state.doc.length ? this : new ScrollTarget(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(state.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);\n    }\n}\nconst scrollIntoView = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define({\n    map: (t, ch)=>t.map(ch)\n});\n/**\nLog or report an unhandled exception in client code. Should\nprobably only be used by extension code that allows client code to\nprovide functions, and calls those functions in a context where an\nexception can't be propagated to calling code in a reasonable way\n(for example when in an event handler).\n\nEither calls a handler registered with\n[`EditorView.exceptionSink`](https://codemirror.net/6/docs/ref/#view.EditorView^exceptionSink),\n`window.onerror`, if defined, or `console.error` (in which case\nit'll pass `context`, when given, as first argument).\n*/ function logException(state, exception, context) {\n    let handler = state.facet(exceptionSink);\n    if (handler.length) handler[0](exception);\n    else if (window.onerror) window.onerror(String(exception), context, undefined, undefined, exception);\n    else if (context) console.error(context + \":\", exception);\n    else console.error(exception);\n}\nconst editable = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (values)=>values.length ? values[0] : true\n});\nlet nextPluginID = 0;\nconst viewPlugin = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\n/**\nView plugins associate stateful values with a view. They can\ninfluence the way the content is drawn, and are notified of things\nthat happen in the view.\n*/ class ViewPlugin {\n    constructor(/**\n    @internal\n    */ id, /**\n    @internal\n    */ create, /**\n    @internal\n    */ domEventHandlers, /**\n    @internal\n    */ domEventObservers, buildExtensions){\n        this.id = id;\n        this.create = create;\n        this.domEventHandlers = domEventHandlers;\n        this.domEventObservers = domEventObservers;\n        this.extension = buildExtensions(this);\n    }\n    /**\n    Define a plugin from a constructor function that creates the\n    plugin's value, given an editor view.\n    */ static define(create, spec) {\n        const { eventHandlers, eventObservers, provide, decorations: deco } = spec || {};\n        return new ViewPlugin(nextPluginID++, create, eventHandlers, eventObservers, (plugin)=>{\n            let ext = [\n                viewPlugin.of(plugin)\n            ];\n            if (deco) ext.push(decorations.of((view)=>{\n                let pluginInst = view.plugin(plugin);\n                return pluginInst ? deco(pluginInst) : Decoration.none;\n            }));\n            if (provide) ext.push(provide(plugin));\n            return ext;\n        });\n    }\n    /**\n    Create a plugin for a class whose constructor takes a single\n    editor view as argument.\n    */ static fromClass(cls, spec) {\n        return ViewPlugin.define((view)=>new cls(view), spec);\n    }\n}\nclass PluginInstance {\n    constructor(spec){\n        this.spec = spec;\n        // When starting an update, all plugins have this field set to the\n        // update object, indicating they need to be updated. When finished\n        // updating, it is set to `false`. Retrieving a plugin that needs to\n        // be updated with `view.plugin` forces an eager update.\n        this.mustUpdate = null;\n        // This is null when the plugin is initially created, but\n        // initialized on the first update.\n        this.value = null;\n    }\n    update(view) {\n        if (!this.value) {\n            if (this.spec) {\n                try {\n                    this.value = this.spec.create(view);\n                } catch (e) {\n                    logException(view.state, e, \"CodeMirror plugin crashed\");\n                    this.deactivate();\n                }\n            }\n        } else if (this.mustUpdate) {\n            let update = this.mustUpdate;\n            this.mustUpdate = null;\n            if (this.value.update) {\n                try {\n                    this.value.update(update);\n                } catch (e) {\n                    logException(update.state, e, \"CodeMirror plugin crashed\");\n                    if (this.value.destroy) try {\n                        this.value.destroy();\n                    } catch (_) {}\n                    this.deactivate();\n                }\n            }\n        }\n        return this;\n    }\n    destroy(view) {\n        var _a;\n        if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {\n            try {\n                this.value.destroy();\n            } catch (e) {\n                logException(view.state, e, \"CodeMirror plugin crashed\");\n            }\n        }\n    }\n    deactivate() {\n        this.spec = this.value = null;\n    }\n}\nconst editorAttributes = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst contentAttributes = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\n// Provide decorations\nconst decorations = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst outerDecorations = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst atomicRanges = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst bidiIsolatedRanges = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nfunction getIsolatedRanges(view, line) {\n    let isolates = view.state.facet(bidiIsolatedRanges);\n    if (!isolates.length) return isolates;\n    let sets = isolates.map((i)=>i instanceof Function ? i(view) : i);\n    let result = [];\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(sets, line.from, line.to, {\n        point () {},\n        span (fromDoc, toDoc, active, open) {\n            let from = fromDoc - line.from, to = toDoc - line.from;\n            let level = result;\n            for(let i = active.length - 1; i >= 0; i--, open--){\n                let direction = active[i].spec.bidiIsolate, update;\n                if (direction == null) direction = autoDirection(line.text, from, to);\n                if (open > 0 && level.length && (update = level[level.length - 1]).to == from && update.direction == direction) {\n                    update.to = to;\n                    level = update.inner;\n                } else {\n                    let add = {\n                        from,\n                        to,\n                        direction,\n                        inner: []\n                    };\n                    level.push(add);\n                    level = add.inner;\n                }\n            }\n        }\n    });\n    return result;\n}\nconst scrollMargins = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nfunction getScrollMargins(view) {\n    let left = 0, right = 0, top = 0, bottom = 0;\n    for (let source of view.state.facet(scrollMargins)){\n        let m = source(view);\n        if (m) {\n            if (m.left != null) left = Math.max(left, m.left);\n            if (m.right != null) right = Math.max(right, m.right);\n            if (m.top != null) top = Math.max(top, m.top);\n            if (m.bottom != null) bottom = Math.max(bottom, m.bottom);\n        }\n    }\n    return {\n        left,\n        right,\n        top,\n        bottom\n    };\n}\nconst styleModule = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nclass ChangedRange {\n    constructor(fromA, toA, fromB, toB){\n        this.fromA = fromA;\n        this.toA = toA;\n        this.fromB = fromB;\n        this.toB = toB;\n    }\n    join(other) {\n        return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));\n    }\n    addToSet(set) {\n        let i = set.length, me = this;\n        for(; i > 0; i--){\n            let range = set[i - 1];\n            if (range.fromA > me.toA) continue;\n            if (range.toA < me.fromA) break;\n            me = me.join(range);\n            set.splice(i - 1, 1);\n        }\n        set.splice(i, 0, me);\n        return set;\n    }\n    static extendWithRanges(diff, ranges) {\n        if (ranges.length == 0) return diff;\n        let result = [];\n        for(let dI = 0, rI = 0, posA = 0, posB = 0;; dI++){\n            let next = dI == diff.length ? null : diff[dI], off = posA - posB;\n            let end = next ? next.fromB : 1e9;\n            while(rI < ranges.length && ranges[rI] < end){\n                let from = ranges[rI], to = ranges[rI + 1];\n                let fromB = Math.max(posB, from), toB = Math.min(end, to);\n                if (fromB <= toB) new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);\n                if (to > end) break;\n                else rI += 2;\n            }\n            if (!next) return result;\n            new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);\n            posA = next.toA;\n            posB = next.toB;\n        }\n    }\n}\n/**\nView [plugins](https://codemirror.net/6/docs/ref/#view.ViewPlugin) are given instances of this\nclass, which describe what happened, whenever the view is updated.\n*/ class ViewUpdate {\n    constructor(/**\n    The editor view that the update is associated with.\n    */ view, /**\n    The new editor state.\n    */ state, /**\n    The transactions involved in the update. May be empty.\n    */ transactions){\n        this.view = view;\n        this.state = state;\n        this.transactions = transactions;\n        /**\n        @internal\n        */ this.flags = 0;\n        this.startState = view.state;\n        this.changes = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.ChangeSet.empty(this.startState.doc.length);\n        for (let tr of transactions)this.changes = this.changes.compose(tr.changes);\n        let changedRanges = [];\n        this.changes.iterChangedRanges((fromA, toA, fromB, toB)=>changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));\n        this.changedRanges = changedRanges;\n    }\n    /**\n    @internal\n    */ static create(view, state, transactions) {\n        return new ViewUpdate(view, state, transactions);\n    }\n    /**\n    Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or\n    [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this\n    update.\n    */ get viewportChanged() {\n        return (this.flags & 4 /* UpdateFlag.Viewport */ ) > 0;\n    }\n    /**\n    Indicates whether the height of a block element in the editor\n    changed in this update.\n    */ get heightChanged() {\n        return (this.flags & 2 /* UpdateFlag.Height */ ) > 0;\n    }\n    /**\n    Returns true when the document was modified or the size of the\n    editor, or elements within the editor, changed.\n    */ get geometryChanged() {\n        return this.docChanged || (this.flags & (8 /* UpdateFlag.Geometry */  | 2 /* UpdateFlag.Height */ )) > 0;\n    }\n    /**\n    True when this update indicates a focus change.\n    */ get focusChanged() {\n        return (this.flags & 1 /* UpdateFlag.Focus */ ) > 0;\n    }\n    /**\n    Whether the document changed in this update.\n    */ get docChanged() {\n        return !this.changes.empty;\n    }\n    /**\n    Whether the selection was explicitly set in this update.\n    */ get selectionSet() {\n        return this.transactions.some((tr)=>tr.selection);\n    }\n    /**\n    @internal\n    */ get empty() {\n        return this.flags == 0 && this.transactions.length == 0;\n    }\n}\nclass DocView extends ContentView {\n    get length() {\n        return this.view.state.doc.length;\n    }\n    constructor(view){\n        super();\n        this.view = view;\n        this.decorations = [];\n        this.dynamicDecorationMap = [];\n        this.domChanged = null;\n        this.hasComposition = null;\n        this.markedForComposition = new Set;\n        // Track a minimum width for the editor. When measuring sizes in\n        // measureVisibleLineHeights, this is updated to point at the width\n        // of a given element and its extent in the document. When a change\n        // happens in that range, these are reset. That way, once we've seen\n        // a line/element of a given length, we keep the editor wide enough\n        // to fit at least that element, until it is changed, at which point\n        // we forget it again.\n        this.minWidth = 0;\n        this.minWidthFrom = 0;\n        this.minWidthTo = 0;\n        // Track whether the DOM selection was set in a lossy way, so that\n        // we don't mess it up when reading it back it\n        this.impreciseAnchor = null;\n        this.impreciseHead = null;\n        this.forceSelection = false;\n        // Used by the resize observer to ignore resizes that we caused\n        // ourselves\n        this.lastUpdate = Date.now();\n        this.setDOM(view.contentDOM);\n        this.children = [\n            new LineView\n        ];\n        this.children[0].setParent(this);\n        this.updateDeco();\n        this.updateInner([\n            new ChangedRange(0, 0, 0, view.state.doc.length)\n        ], 0, null);\n    }\n    // Update the document view to a given state.\n    update(update) {\n        var _a;\n        let changedRanges = update.changedRanges;\n        if (this.minWidth > 0 && changedRanges.length) {\n            if (!changedRanges.every(({ fromA, toA })=>toA < this.minWidthFrom || fromA > this.minWidthTo)) {\n                this.minWidth = this.minWidthFrom = this.minWidthTo = 0;\n            } else {\n                this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);\n                this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);\n            }\n        }\n        let readCompositionAt = -1;\n        if (this.view.inputState.composing >= 0) {\n            if ((_a = this.domChanged) === null || _a === void 0 ? void 0 : _a.newSel) readCompositionAt = this.domChanged.newSel.head;\n            else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet) readCompositionAt = update.state.selection.main.head;\n        }\n        let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;\n        this.domChanged = null;\n        if (this.hasComposition) {\n            this.markedForComposition.clear();\n            let { from, to } = this.hasComposition;\n            changedRanges = new ChangedRange(from, to, update.changes.mapPos(from, -1), update.changes.mapPos(to, 1)).addToSet(changedRanges.slice());\n        }\n        this.hasComposition = composition ? {\n            from: composition.range.fromB,\n            to: composition.range.toB\n        } : null;\n        // When the DOM nodes around the selection are moved to another\n        // parent, Chrome sometimes reports a different selection through\n        // getSelection than the one that it actually shows to the user.\n        // This forces a selection update when lines are joined to work\n        // around that. Issue #54\n        if ((browser.ie || browser.chrome) && !composition && update && update.state.doc.lines != update.startState.doc.lines) this.forceSelection = true;\n        let prevDeco = this.decorations, deco = this.updateDeco();\n        let decoDiff = findChangedDeco(prevDeco, deco, update.changes);\n        changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);\n        if (!(this.flags & 7 /* ViewFlag.Dirty */ ) && changedRanges.length == 0) {\n            return false;\n        } else {\n            this.updateInner(changedRanges, update.startState.doc.length, composition);\n            if (update.transactions.length) this.lastUpdate = Date.now();\n            return true;\n        }\n    }\n    // Used by update and the constructor do perform the actual DOM\n    // update\n    updateInner(changes, oldLength, composition) {\n        this.view.viewState.mustMeasureContent = true;\n        this.updateChildren(changes, oldLength, composition);\n        let { observer } = this.view;\n        observer.ignore(()=>{\n            // Lock the height during redrawing, since Chrome sometimes\n            // messes with the scroll position during DOM mutation (though\n            // no relayout is triggered and I cannot imagine how it can\n            // recompute the scroll position without a layout)\n            this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + \"px\";\n            this.dom.style.flexBasis = this.minWidth ? this.minWidth + \"px\" : \"\";\n            // Chrome will sometimes, when DOM mutations occur directly\n            // around the selection, get confused and report a different\n            // selection from the one it displays (issue #218). This tries\n            // to detect that situation.\n            let track = browser.chrome || browser.ios ? {\n                node: observer.selectionRange.focusNode,\n                written: false\n            } : undefined;\n            this.sync(this.view, track);\n            this.flags &= ~7 /* ViewFlag.Dirty */ ;\n            if (track && (track.written || observer.selectionRange.focusNode != track.node)) this.forceSelection = true;\n            this.dom.style.height = \"\";\n        });\n        this.markedForComposition.forEach((cView)=>cView.flags &= ~8 /* ViewFlag.Composition */ );\n        let gaps = [];\n        if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {\n            for (let child of this.children)if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget) gaps.push(child.dom);\n        }\n        observer.updateGaps(gaps);\n    }\n    updateChildren(changes, oldLength, composition) {\n        let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;\n        let cursor = this.childCursor(oldLength);\n        for(let i = ranges.length - 1;; i--){\n            let next = i >= 0 ? ranges[i] : null;\n            if (!next) break;\n            let { fromA, toA, fromB, toB } = next, content, breakAtStart, openStart, openEnd;\n            if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {\n                let before = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);\n                let after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);\n                breakAtStart = before.breakAtStart;\n                openStart = before.openStart;\n                openEnd = after.openEnd;\n                let compLine = this.compositionView(composition);\n                if (after.breakAtStart) {\n                    compLine.breakAfter = 1;\n                } else if (after.content.length && compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {\n                    compLine.breakAfter = after.content[0].breakAfter;\n                    after.content.shift();\n                }\n                if (before.content.length && compLine.merge(0, 0, before.content[before.content.length - 1], true, 0, before.openEnd)) {\n                    before.content.pop();\n                }\n                content = before.content.concat(compLine).concat(after.content);\n            } else {\n                ({ content, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));\n            }\n            let { i: toI, off: toOff } = cursor.findPos(toA, 1);\n            let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);\n            replaceRange(this, fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd);\n        }\n        if (composition) this.fixCompositionDOM(composition);\n    }\n    compositionView(composition) {\n        let cur = new TextView(composition.text.nodeValue);\n        cur.flags |= 8 /* ViewFlag.Composition */ ;\n        for (let { deco } of composition.marks)cur = new MarkView(deco, [\n            cur\n        ], cur.length);\n        let line = new LineView;\n        line.append(cur, 0);\n        return line;\n    }\n    fixCompositionDOM(composition) {\n        let fix = (dom, cView)=>{\n            cView.flags |= 8 /* ViewFlag.Composition */  | (cView.children.some((c)=>c.flags & 7 /* ViewFlag.Dirty */ ) ? 1 /* ViewFlag.ChildDirty */  : 0);\n            this.markedForComposition.add(cView);\n            let prev = ContentView.get(dom);\n            if (prev && prev != cView) prev.dom = null;\n            cView.setDOM(dom);\n        };\n        let pos = this.childPos(composition.range.fromB, 1);\n        let cView = this.children[pos.i];\n        fix(composition.line, cView);\n        for(let i = composition.marks.length - 1; i >= -1; i--){\n            pos = cView.childPos(pos.off, 1);\n            cView = cView.children[pos.i];\n            fix(i >= 0 ? composition.marks[i].node : composition.text, cView);\n        }\n    }\n    // Sync the DOM selection to this.state.selection\n    updateSelection(mustRead = false, fromPointer = false) {\n        if (mustRead || !this.view.observer.selectionRange.focusNode) this.view.observer.readSelectionRange();\n        let activeElt = this.view.root.activeElement, focused = activeElt == this.dom;\n        let selectionNotFocus = !focused && hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));\n        if (!(focused || fromPointer || selectionNotFocus)) return;\n        let force = this.forceSelection;\n        this.forceSelection = false;\n        let main = this.view.state.selection.main;\n        let anchor = this.moveToLine(this.domAtPos(main.anchor));\n        let head = main.empty ? anchor : this.moveToLine(this.domAtPos(main.head));\n        // Always reset on Firefox when next to an uneditable node to\n        // avoid invisible cursor bugs (#111)\n        if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {\n            let dummy = document.createTextNode(\"\");\n            this.view.observer.ignore(()=>anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));\n            anchor = head = new DOMPos(dummy, 0);\n            force = true;\n        }\n        let domSel = this.view.observer.selectionRange;\n        // If the selection is already here, or in an equivalent position, don't touch it\n        if (force || !domSel.focusNode || (!isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) && !this.suppressWidgetCursorChange(domSel, main)) {\n            this.view.observer.ignore(()=>{\n                // Chrome Android will hide the virtual keyboard when tapping\n                // inside an uneditable node, and not bring it back when we\n                // move the cursor to its proper position. This tries to\n                // restore the keyboard by cycling focus.\n                if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {\n                    this.dom.blur();\n                    this.dom.focus({\n                        preventScroll: true\n                    });\n                }\n                let rawSel = getSelection(this.view.root);\n                if (!rawSel) ;\n                else if (main.empty) {\n                    // Work around https://bugzilla.mozilla.org/show_bug.cgi?id=1612076\n                    if (browser.gecko) {\n                        let nextTo = nextToUneditable(anchor.node, anchor.offset);\n                        if (nextTo && nextTo != (1 /* NextTo.Before */  | 2 /* NextTo.After */ )) {\n                            let text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 /* NextTo.Before */  ? 1 : -1);\n                            if (text) anchor = new DOMPos(text.node, text.offset);\n                        }\n                    }\n                    rawSel.collapse(anchor.node, anchor.offset);\n                    if (main.bidiLevel != null && rawSel.caretBidiLevel !== undefined) rawSel.caretBidiLevel = main.bidiLevel;\n                } else if (rawSel.extend) {\n                    // Selection.extend can be used to create an 'inverted' selection\n                    // (one where the focus is before the anchor), but not all\n                    // browsers support it yet.\n                    rawSel.collapse(anchor.node, anchor.offset);\n                    // Safari will ignore the call above when the editor is\n                    // hidden, and then raise an error on the call to extend\n                    // (#940).\n                    try {\n                        rawSel.extend(head.node, head.offset);\n                    } catch (_) {}\n                } else {\n                    // Primitive (IE) way\n                    let range = document.createRange();\n                    if (main.anchor > main.head) [anchor, head] = [\n                        head,\n                        anchor\n                    ];\n                    range.setEnd(head.node, head.offset);\n                    range.setStart(anchor.node, anchor.offset);\n                    rawSel.removeAllRanges();\n                    rawSel.addRange(range);\n                }\n                if (selectionNotFocus && this.view.root.activeElement == this.dom) {\n                    this.dom.blur();\n                    if (activeElt) activeElt.focus();\n                }\n            });\n            this.view.observer.setSelectionRange(anchor, head);\n        }\n        this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);\n        this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);\n    }\n    // If a zero-length widget is inserted next to the cursor during\n    // composition, avoid moving it across it and disrupting the\n    // composition.\n    suppressWidgetCursorChange(sel, cursor) {\n        return this.hasComposition && cursor.empty && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) && this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor.head;\n    }\n    enforceCursorAssoc() {\n        if (this.hasComposition) return;\n        let { view } = this, cursor = view.state.selection.main;\n        let sel = getSelection(view.root);\n        let { anchorNode, anchorOffset } = view.observer.selectionRange;\n        if (!sel || !cursor.empty || !cursor.assoc || !sel.modify) return;\n        let line = LineView.find(this, cursor.head);\n        if (!line) return;\n        let lineStart = line.posAtStart;\n        if (cursor.head == lineStart || cursor.head == lineStart + line.length) return;\n        let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);\n        if (!before || !after || before.bottom > after.top) return;\n        let dom = this.domAtPos(cursor.head + cursor.assoc);\n        sel.collapse(dom.node, dom.offset);\n        sel.modify(\"move\", cursor.assoc < 0 ? \"forward\" : \"backward\", \"lineboundary\");\n        // This can go wrong in corner cases like single-character lines,\n        // so check and reset if necessary.\n        view.observer.readSelectionRange();\n        let newRange = view.observer.selectionRange;\n        if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from) sel.collapse(anchorNode, anchorOffset);\n    }\n    // If a position is in/near a block widget, move it to a nearby text\n    // line, since we don't want the cursor inside a block widget.\n    moveToLine(pos) {\n        // Block widgets will return positions before/after them, which\n        // are thus directly in the document DOM element.\n        let dom = this.dom, newPos;\n        if (pos.node != dom) return pos;\n        for(let i = pos.offset; !newPos && i < dom.childNodes.length; i++){\n            let view = ContentView.get(dom.childNodes[i]);\n            if (view instanceof LineView) newPos = view.domAtPos(0);\n        }\n        for(let i = pos.offset - 1; !newPos && i >= 0; i--){\n            let view = ContentView.get(dom.childNodes[i]);\n            if (view instanceof LineView) newPos = view.domAtPos(view.length);\n        }\n        return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;\n    }\n    nearest(dom) {\n        for(let cur = dom; cur;){\n            let domView = ContentView.get(cur);\n            if (domView && domView.rootView == this) return domView;\n            cur = cur.parentNode;\n        }\n        return null;\n    }\n    posFromDOM(node, offset) {\n        let view = this.nearest(node);\n        if (!view) throw new RangeError(\"Trying to find position for a DOM position outside of the document\");\n        return view.localPosFromDOM(node, offset) + view.posAtStart;\n    }\n    domAtPos(pos) {\n        let { i, off } = this.childCursor().findPos(pos, -1);\n        for(; i < this.children.length - 1;){\n            let child = this.children[i];\n            if (off < child.length || child instanceof LineView) break;\n            i++;\n            off = 0;\n        }\n        return this.children[i].domAtPos(off);\n    }\n    coordsAt(pos, side) {\n        let best = null, bestPos = 0;\n        for(let off = this.length, i = this.children.length - 1; i >= 0; i--){\n            let child = this.children[i], end = off - child.breakAfter, start = end - child.length;\n            if (end < pos) break;\n            if (start <= pos && (start < pos || child.covers(-1)) && (end > pos || child.covers(1)) && (!best || child instanceof LineView && !(best instanceof LineView && side >= 0))) {\n                best = child;\n                bestPos = start;\n            }\n            off = start;\n        }\n        return best ? best.coordsAt(pos - bestPos, side) : null;\n    }\n    coordsForChar(pos) {\n        let { i, off } = this.childPos(pos, 1), child = this.children[i];\n        if (!(child instanceof LineView)) return null;\n        while(child.children.length){\n            let { i, off: childOff } = child.childPos(off, 1);\n            for(;; i++){\n                if (i == child.children.length) return null;\n                if ((child = child.children[i]).length) break;\n            }\n            off = childOff;\n        }\n        if (!(child instanceof TextView)) return null;\n        let end = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(child.text, off);\n        if (end == off) return null;\n        let rects = textRange(child.dom, off, end).getClientRects();\n        for(let i = 0; i < rects.length; i++){\n            let rect = rects[i];\n            if (i == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right) return rect;\n        }\n        return null;\n    }\n    measureVisibleLineHeights(viewport) {\n        let result = [], { from, to } = viewport;\n        let contentWidth = this.view.contentDOM.clientWidth;\n        let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;\n        let widest = -1, ltr = this.view.textDirection == Direction.LTR;\n        for(let pos = 0, i = 0; i < this.children.length; i++){\n            let child = this.children[i], end = pos + child.length;\n            if (end > to) break;\n            if (pos >= from) {\n                let childRect = child.dom.getBoundingClientRect();\n                result.push(childRect.height);\n                if (isWider) {\n                    let last = child.dom.lastChild;\n                    let rects = last ? clientRectsFor(last) : [];\n                    if (rects.length) {\n                        let rect = rects[rects.length - 1];\n                        let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;\n                        if (width > widest) {\n                            widest = width;\n                            this.minWidth = contentWidth;\n                            this.minWidthFrom = pos;\n                            this.minWidthTo = end;\n                        }\n                    }\n                }\n            }\n            pos = end + child.breakAfter;\n        }\n        return result;\n    }\n    textDirectionAt(pos) {\n        let { i } = this.childPos(pos, 1);\n        return getComputedStyle(this.children[i].dom).direction == \"rtl\" ? Direction.RTL : Direction.LTR;\n    }\n    measureTextSize() {\n        for (let child of this.children){\n            if (child instanceof LineView) {\n                let measure = child.measureTextSize();\n                if (measure) return measure;\n            }\n        }\n        // If no workable line exists, force a layout of a measurable element\n        let dummy = document.createElement(\"div\"), lineHeight, charWidth, textHeight;\n        dummy.className = \"cm-line\";\n        dummy.style.width = \"99999px\";\n        dummy.style.position = \"absolute\";\n        dummy.textContent = \"abc def ghi jkl mno pqr stu\";\n        this.view.observer.ignore(()=>{\n            this.dom.appendChild(dummy);\n            let rect = clientRectsFor(dummy.firstChild)[0];\n            lineHeight = dummy.getBoundingClientRect().height;\n            charWidth = rect ? rect.width / 27 : 7;\n            textHeight = rect ? rect.height : lineHeight;\n            dummy.remove();\n        });\n        return {\n            lineHeight,\n            charWidth,\n            textHeight\n        };\n    }\n    childCursor(pos = this.length) {\n        // Move back to start of last element when possible, so that\n        // `ChildCursor.findPos` doesn't have to deal with the edge case\n        // of being after the last element.\n        let i = this.children.length;\n        if (i) pos -= this.children[--i].length;\n        return new ChildCursor(this.children, pos, i);\n    }\n    computeBlockGapDeco() {\n        let deco = [], vs = this.view.viewState;\n        for(let pos = 0, i = 0;; i++){\n            let next = i == vs.viewports.length ? null : vs.viewports[i];\n            let end = next ? next.from - 1 : this.length;\n            if (end > pos) {\n                let height = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY;\n                deco.push(Decoration.replace({\n                    widget: new BlockGapWidget(height),\n                    block: true,\n                    inclusive: true,\n                    isBlockGap: true\n                }).range(pos, end));\n            }\n            if (!next) break;\n            pos = next.to + 1;\n        }\n        return Decoration.set(deco);\n    }\n    updateDeco() {\n        let allDeco = this.view.state.facet(decorations).map((d, i)=>{\n            let dynamic = this.dynamicDecorationMap[i] = typeof d == \"function\";\n            return dynamic ? d(this.view) : d;\n        });\n        let dynamicOuter = false, outerDeco = this.view.state.facet(outerDecorations).map((d, i)=>{\n            let dynamic = typeof d == \"function\";\n            if (dynamic) dynamicOuter = true;\n            return dynamic ? d(this.view) : d;\n        });\n        if (outerDeco.length) {\n            this.dynamicDecorationMap[allDeco.length] = dynamicOuter;\n            allDeco.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.join(outerDeco));\n        }\n        for(let i = allDeco.length; i < allDeco.length + 3; i++)this.dynamicDecorationMap[i] = false;\n        return this.decorations = [\n            ...allDeco,\n            this.computeBlockGapDeco(),\n            this.view.viewState.lineGapDeco\n        ];\n    }\n    scrollIntoView(target) {\n        if (target.isSnapshot) {\n            let ref = this.view.viewState.lineBlockAt(target.range.head);\n            this.view.scrollDOM.scrollTop = ref.top - target.yMargin;\n            this.view.scrollDOM.scrollLeft = target.xMargin;\n            return;\n        }\n        let { range } = target;\n        let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;\n        if (!rect) return;\n        if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1))) rect = {\n            left: Math.min(rect.left, other.left),\n            top: Math.min(rect.top, other.top),\n            right: Math.max(rect.right, other.right),\n            bottom: Math.max(rect.bottom, other.bottom)\n        };\n        let margins = getScrollMargins(this.view);\n        let targetRect = {\n            left: rect.left - margins.left,\n            top: rect.top - margins.top,\n            right: rect.right + margins.right,\n            bottom: rect.bottom + margins.bottom\n        };\n        let { offsetWidth, offsetHeight } = this.view.scrollDOM;\n        scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == Direction.LTR);\n    }\n}\nfunction betweenUneditable(pos) {\n    return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == \"false\") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == \"false\");\n}\nclass BlockGapWidget extends WidgetType {\n    constructor(height){\n        super();\n        this.height = height;\n    }\n    toDOM() {\n        let elt = document.createElement(\"div\");\n        elt.className = \"cm-gap\";\n        this.updateDOM(elt);\n        return elt;\n    }\n    eq(other) {\n        return other.height == this.height;\n    }\n    updateDOM(elt) {\n        elt.style.height = this.height + \"px\";\n        return true;\n    }\n    get editable() {\n        return true;\n    }\n    get estimatedHeight() {\n        return this.height;\n    }\n}\nfunction findCompositionNode(view, headPos) {\n    let sel = view.observer.selectionRange;\n    let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);\n    if (!textNode) return null;\n    let from = headPos - textNode.offset;\n    return {\n        from,\n        to: from + textNode.node.nodeValue.length,\n        node: textNode.node\n    };\n}\nfunction findCompositionRange(view, changes, headPos) {\n    let found = findCompositionNode(view, headPos);\n    if (!found) return null;\n    let { node: textNode, from, to } = found, text = textNode.nodeValue;\n    // Don't try to preserve multi-line compositions\n    if (/[\\n\\r]/.test(text)) return null;\n    if (view.state.doc.sliceString(found.from, found.to) != text) return null;\n    let inv = changes.invertedDesc;\n    let range = new ChangedRange(inv.mapPos(from), inv.mapPos(to), from, to);\n    let marks = [];\n    for(let parent = textNode.parentNode;; parent = parent.parentNode){\n        let parentView = ContentView.get(parent);\n        if (parentView instanceof MarkView) marks.push({\n            node: parent,\n            deco: parentView.mark\n        });\n        else if (parentView instanceof LineView || parent.nodeName == \"DIV\" && parent.parentNode == view.contentDOM) return {\n            range,\n            text: textNode,\n            marks,\n            line: parent\n        };\n        else if (parent != view.contentDOM) marks.push({\n            node: parent,\n            deco: new MarkDecoration({\n                inclusive: true,\n                attributes: getAttrs(parent),\n                tagName: parent.tagName.toLowerCase()\n            })\n        });\n        else return null;\n    }\n}\nfunction nearbyTextNode(startNode, startOffset, side) {\n    if (side <= 0) for(let node = startNode, offset = startOffset;;){\n        if (node.nodeType == 3) return {\n            node: node,\n            offset: offset\n        };\n        if (node.nodeType == 1 && offset > 0) {\n            node = node.childNodes[offset - 1];\n            offset = maxOffset(node);\n        } else {\n            break;\n        }\n    }\n    if (side >= 0) for(let node = startNode, offset = startOffset;;){\n        if (node.nodeType == 3) return {\n            node: node,\n            offset: offset\n        };\n        if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {\n            node = node.childNodes[offset];\n            offset = 0;\n        } else {\n            break;\n        }\n    }\n    return null;\n}\nfunction nextToUneditable(node, offset) {\n    if (node.nodeType != 1) return 0;\n    return (offset && node.childNodes[offset - 1].contentEditable == \"false\" ? 1 /* NextTo.Before */  : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == \"false\" ? 2 /* NextTo.After */  : 0);\n}\nlet DecorationComparator$1 = class DecorationComparator {\n    constructor(){\n        this.changes = [];\n    }\n    compareRange(from, to) {\n        addRange(from, to, this.changes);\n    }\n    comparePoint(from, to) {\n        addRange(from, to, this.changes);\n    }\n};\nfunction findChangedDeco(a, b, diff) {\n    let comp = new DecorationComparator$1;\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.compare(a, b, diff, comp);\n    return comp.changes;\n}\nfunction inUneditable(node, inside) {\n    for(let cur = node; cur && cur != inside; cur = cur.assignedSlot || cur.parentNode){\n        if (cur.nodeType == 1 && cur.contentEditable == \"false\") {\n            return true;\n        }\n    }\n    return false;\n}\nfunction touchesComposition(changes, composition) {\n    let touched = false;\n    if (composition) changes.iterChangedRanges((from, to)=>{\n        if (from < composition.to && to > composition.from) touched = true;\n    });\n    return touched;\n}\nfunction groupAt(state, pos, bias = 1) {\n    let categorize = state.charCategorizer(pos);\n    let line = state.doc.lineAt(pos), linePos = pos - line.from;\n    if (line.length == 0) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos);\n    if (linePos == 0) bias = 1;\n    else if (linePos == line.length) bias = -1;\n    let from = linePos, to = linePos;\n    if (bias < 0) from = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, linePos, false);\n    else to = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, linePos);\n    let cat = categorize(line.text.slice(from, to));\n    while(from > 0){\n        let prev = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, from, false);\n        if (categorize(line.text.slice(prev, from)) != cat) break;\n        from = prev;\n    }\n    while(to < line.length){\n        let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, to);\n        if (categorize(line.text.slice(to, next)) != cat) break;\n        to = next;\n    }\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(from + line.from, to + line.from);\n}\n// Search the DOM for the {node, offset} position closest to the given\n// coordinates. Very inefficient and crude, but can usually be avoided\n// by calling caret(Position|Range)FromPoint instead.\nfunction getdx(x, rect) {\n    return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);\n}\nfunction getdy(y, rect) {\n    return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);\n}\nfunction yOverlap(a, b) {\n    return a.top < b.bottom - 1 && a.bottom > b.top + 1;\n}\nfunction upTop(rect, top) {\n    return top < rect.top ? {\n        top,\n        left: rect.left,\n        right: rect.right,\n        bottom: rect.bottom\n    } : rect;\n}\nfunction upBot(rect, bottom) {\n    return bottom > rect.bottom ? {\n        top: rect.top,\n        left: rect.left,\n        right: rect.right,\n        bottom\n    } : rect;\n}\nfunction domPosAtCoords(parent, x, y) {\n    let closest, closestRect, closestX, closestY, closestOverlap = false;\n    let above, below, aboveRect, belowRect;\n    for(let child = parent.firstChild; child; child = child.nextSibling){\n        let rects = clientRectsFor(child);\n        for(let i = 0; i < rects.length; i++){\n            let rect = rects[i];\n            if (closestRect && yOverlap(closestRect, rect)) rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);\n            let dx = getdx(x, rect), dy = getdy(y, rect);\n            if (dx == 0 && dy == 0) return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);\n            if (!closest || closestY > dy || closestY == dy && closestX > dx) {\n                closest = child;\n                closestRect = rect;\n                closestX = dx;\n                closestY = dy;\n                let side = dy ? y < rect.top ? -1 : 1 : dx ? x < rect.left ? -1 : 1 : 0;\n                closestOverlap = !side || (side > 0 ? i < rects.length - 1 : i > 0);\n            }\n            if (dx == 0) {\n                if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {\n                    above = child;\n                    aboveRect = rect;\n                } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {\n                    below = child;\n                    belowRect = rect;\n                }\n            } else if (aboveRect && yOverlap(aboveRect, rect)) {\n                aboveRect = upBot(aboveRect, rect.bottom);\n            } else if (belowRect && yOverlap(belowRect, rect)) {\n                belowRect = upTop(belowRect, rect.top);\n            }\n        }\n    }\n    if (aboveRect && aboveRect.bottom >= y) {\n        closest = above;\n        closestRect = aboveRect;\n    } else if (belowRect && belowRect.top <= y) {\n        closest = below;\n        closestRect = belowRect;\n    }\n    if (!closest) return {\n        node: parent,\n        offset: 0\n    };\n    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));\n    if (closest.nodeType == 3) return domPosInText(closest, clipX, y);\n    if (closestOverlap && closest.contentEditable != \"false\") return domPosAtCoords(closest, clipX, y);\n    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);\n    return {\n        node: parent,\n        offset\n    };\n}\nfunction domPosInText(node, x, y) {\n    let len = node.nodeValue.length;\n    let closestOffset = -1, closestDY = 1e9, generalSide = 0;\n    for(let i = 0; i < len; i++){\n        let rects = textRange(node, i, i + 1).getClientRects();\n        for(let j = 0; j < rects.length; j++){\n            let rect = rects[j];\n            if (rect.top == rect.bottom) continue;\n            if (!generalSide) generalSide = x - rect.left;\n            let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;\n            if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {\n                let right = x >= (rect.left + rect.right) / 2, after = right;\n                if (browser.chrome || browser.gecko) {\n                    // Check for RTL on browsers that support getting client\n                    // rects for empty ranges.\n                    let rectBefore = textRange(node, i).getBoundingClientRect();\n                    if (rectBefore.left == rect.right) after = !right;\n                }\n                if (dy <= 0) return {\n                    node,\n                    offset: i + (after ? 1 : 0)\n                };\n                closestOffset = i + (after ? 1 : 0);\n                closestDY = dy;\n            }\n        }\n    }\n    return {\n        node,\n        offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0\n    };\n}\nfunction posAtCoords(view, coords, precise, bias = -1) {\n    var _a, _b;\n    let content = view.contentDOM.getBoundingClientRect(), docTop = content.top + view.viewState.paddingTop;\n    let block, { docHeight } = view.viewState;\n    let { x, y } = coords, yOffset = y - docTop;\n    if (yOffset < 0) return 0;\n    if (yOffset > docHeight) return view.state.doc.length;\n    // Scan for a text block near the queried y position\n    for(let halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false;;){\n        block = view.elementAtHeight(yOffset);\n        if (block.type == BlockType.Text) break;\n        for(;;){\n            // Move the y position out of this block\n            yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;\n            if (yOffset >= 0 && yOffset <= docHeight) break;\n            // If the document consists entirely of replaced widgets, we\n            // won't find a text block, so return 0\n            if (bounced) return precise ? null : 0;\n            bounced = true;\n            bias = -bias;\n        }\n    }\n    y = docTop + yOffset;\n    let lineStart = block.from;\n    // If this is outside of the rendered viewport, we can't determine a position\n    if (lineStart < view.viewport.from) return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content, block, x, y);\n    if (lineStart > view.viewport.to) return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content, block, x, y);\n    // Prefer ShadowRootOrDocument.elementFromPoint if present, fall back to document if not\n    let doc = view.dom.ownerDocument;\n    let root = view.root.elementFromPoint ? view.root : doc;\n    let element = root.elementFromPoint(x, y);\n    if (element && !view.contentDOM.contains(element)) element = null;\n    // If the element is unexpected, clip x at the sides of the content area and try again\n    if (!element) {\n        x = Math.max(content.left + 1, Math.min(content.right - 1, x));\n        element = root.elementFromPoint(x, y);\n        if (element && !view.contentDOM.contains(element)) element = null;\n    }\n    // There's visible editor content under the point, so we can try\n    // using caret(Position|Range)FromPoint as a shortcut\n    let node, offset = -1;\n    if (element && ((_a = view.docView.nearest(element)) === null || _a === void 0 ? void 0 : _a.isEditable) != false) {\n        if (doc.caretPositionFromPoint) {\n            let pos = doc.caretPositionFromPoint(x, y);\n            if (pos) ({ offsetNode: node, offset } = pos);\n        } else if (doc.caretRangeFromPoint) {\n            let range = doc.caretRangeFromPoint(x, y);\n            if (range) {\n                ({ startContainer: node, startOffset: offset } = range);\n                if (!view.contentDOM.contains(node) || browser.safari && isSuspiciousSafariCaretResult(node, offset, x) || browser.chrome && isSuspiciousChromeCaretResult(node, offset, x)) node = undefined;\n            }\n        }\n    }\n    // No luck, do our own (potentially expensive) search\n    if (!node || !view.docView.dom.contains(node)) {\n        let line = LineView.find(view.docView, lineStart);\n        if (!line) return yOffset > block.top + block.height / 2 ? block.to : block.from;\n        ({ node, offset } = domPosAtCoords(line.dom, x, y));\n    }\n    let nearest = view.docView.nearest(node);\n    if (!nearest) return null;\n    if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {\n        let rect = nearest.dom.getBoundingClientRect();\n        return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2 ? nearest.posAtStart : nearest.posAtEnd;\n    } else {\n        return nearest.localPosFromDOM(node, offset) + nearest.posAtStart;\n    }\n}\nfunction posAtCoordsImprecise(view, contentRect, block, x, y) {\n    let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);\n    if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {\n        let textHeight = view.viewState.heightOracle.textHeight;\n        let line = Math.floor((y - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);\n        into += line * view.viewState.heightOracle.lineLength;\n    }\n    let content = view.state.sliceDoc(block.from, block.to);\n    return block.from + (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findColumn)(content, into, view.state.tabSize);\n}\n// In case of a high line height, Safari's caretRangeFromPoint treats\n// the space between lines as belonging to the last character of the\n// line before. This is used to detect such a result so that it can be\n// ignored (issue #401).\nfunction isSuspiciousSafariCaretResult(node, offset, x) {\n    let len;\n    if (node.nodeType != 3 || offset != (len = node.nodeValue.length)) return false;\n    for(let next = node.nextSibling; next; next = next.nextSibling)if (next.nodeType != 1 || next.nodeName != \"BR\") return false;\n    return textRange(node, len - 1, len).getBoundingClientRect().left > x;\n}\n// Chrome will move positions between lines to the start of the next line\nfunction isSuspiciousChromeCaretResult(node, offset, x) {\n    if (offset != 0) return false;\n    for(let cur = node;;){\n        let parent = cur.parentNode;\n        if (!parent || parent.nodeType != 1 || parent.firstChild != cur) return false;\n        if (parent.classList.contains(\"cm-line\")) break;\n        cur = parent;\n    }\n    let rect = node.nodeType == 1 ? node.getBoundingClientRect() : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();\n    return x - rect.left > 5;\n}\nfunction blockAt(view, pos) {\n    let line = view.lineBlockAt(pos);\n    if (Array.isArray(line.type)) for (let l of line.type){\n        if (l.to > pos || l.to == pos && (l.to == line.to || l.type == BlockType.Text)) return l;\n    }\n    return line;\n}\nfunction moveToLineBoundary(view, start, forward, includeWrap) {\n    let line = blockAt(view, start.head);\n    let coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);\n    if (coords) {\n        let editorRect = view.dom.getBoundingClientRect();\n        let direction = view.textDirectionAt(line.from);\n        let pos = view.posAtCoords({\n            x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,\n            y: (coords.top + coords.bottom) / 2\n        });\n        if (pos != null) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos, forward ? -1 : 1);\n    }\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1);\n}\nfunction moveByChar(view, start, forward, by) {\n    let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);\n    let direction = view.textDirectionAt(line.from);\n    for(let cur = start, check = null;;){\n        let next = moveVisually(line, spans, direction, cur, forward), char = movedOver;\n        if (!next) {\n            if (line.number == (forward ? view.state.doc.lines : 1)) return cur;\n            char = \"\\n\";\n            line = view.state.doc.line(line.number + (forward ? 1 : -1));\n            spans = view.bidiSpans(line);\n            next = view.visualLineSide(line, !forward);\n        }\n        if (!check) {\n            if (!by) return next;\n            check = by(char);\n        } else if (!check(char)) {\n            return cur;\n        }\n        cur = next;\n    }\n}\nfunction byGroup(view, pos, start) {\n    let categorize = view.state.charCategorizer(pos);\n    let cat = categorize(start);\n    return (next)=>{\n        let nextCat = categorize(next);\n        if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.CharCategory.Space) cat = nextCat;\n        return cat == nextCat;\n    };\n}\nfunction moveVertically(view, start, forward, distance) {\n    let startPos = start.head, dir = forward ? 1 : -1;\n    if (startPos == (forward ? view.state.doc.length : 0)) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(startPos, start.assoc);\n    let goal = start.goalColumn, startY;\n    let rect = view.contentDOM.getBoundingClientRect();\n    let startCoords = view.coordsAtPos(startPos, start.assoc || -1), docTop = view.documentTop;\n    if (startCoords) {\n        if (goal == null) goal = startCoords.left - rect.left;\n        startY = dir < 0 ? startCoords.top : startCoords.bottom;\n    } else {\n        let line = view.viewState.lineBlockAt(startPos);\n        if (goal == null) goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));\n        startY = (dir < 0 ? line.top : line.bottom) + docTop;\n    }\n    let resolvedGoal = rect.left + goal;\n    let dist = distance !== null && distance !== void 0 ? distance : view.viewState.heightOracle.textHeight >> 1;\n    for(let extra = 0;; extra += 10){\n        let curY = startY + (dist + extra) * dir;\n        let pos = posAtCoords(view, {\n            x: resolvedGoal,\n            y: curY\n        }, false, dir);\n        if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) {\n            let charRect = view.docView.coordsForChar(pos);\n            let assoc = !charRect || curY < charRect.top ? -1 : 1;\n            return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos, assoc, undefined, goal);\n        }\n    }\n}\nfunction skipAtomicRanges(atoms, pos, bias) {\n    for(;;){\n        let moved = 0;\n        for (let set of atoms){\n            set.between(pos - 1, pos + 1, (from, to, value)=>{\n                if (pos > from && pos < to) {\n                    let side = moved || bias || (pos - from < to - pos ? -1 : 1);\n                    pos = side < 0 ? from : to;\n                    moved = side;\n                }\n            });\n        }\n        if (!moved) return pos;\n    }\n}\nfunction skipAtoms(view, oldPos, pos) {\n    let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map((f)=>f(view)), pos.from, oldPos.head > pos.from ? -1 : 1);\n    return newPos == pos.from ? pos : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);\n}\n// This will also be where dragging info and such goes\nclass InputState {\n    setSelectionOrigin(origin) {\n        this.lastSelectionOrigin = origin;\n        this.lastSelectionTime = Date.now();\n    }\n    constructor(view){\n        this.view = view;\n        this.lastKeyCode = 0;\n        this.lastKeyTime = 0;\n        this.lastTouchTime = 0;\n        this.lastFocusTime = 0;\n        this.lastScrollTop = 0;\n        this.lastScrollLeft = 0;\n        // On iOS, some keys need to have their default behavior happen\n        // (after which we retroactively handle them and reset the DOM) to\n        // avoid messing up the virtual keyboard state.\n        this.pendingIOSKey = undefined;\n        this.lastSelectionOrigin = null;\n        this.lastSelectionTime = 0;\n        this.lastEscPress = 0;\n        this.lastContextMenu = 0;\n        this.scrollHandlers = [];\n        this.handlers = Object.create(null);\n        // -1 means not in a composition. Otherwise, this counts the number\n        // of changes made during the composition. The count is used to\n        // avoid treating the start state of the composition, before any\n        // changes have been made, as part of the composition.\n        this.composing = -1;\n        // Tracks whether the next change should be marked as starting the\n        // composition (null means no composition, true means next is the\n        // first, false means first has already been marked for this\n        // composition)\n        this.compositionFirstChange = null;\n        // End time of the previous composition\n        this.compositionEndedAt = 0;\n        // Used in a kludge to detect when an Enter keypress should be\n        // considered part of the composition on Safari, which fires events\n        // in the wrong order\n        this.compositionPendingKey = false;\n        // Used to categorize changes as part of a composition, even when\n        // the mutation events fire shortly after the compositionend event\n        this.compositionPendingChange = false;\n        this.mouseSelection = null;\n        // When a drag from the editor is active, this points at the range\n        // being dragged.\n        this.draggedContent = null;\n        this.handleEvent = this.handleEvent.bind(this);\n        this.notifiedFocused = view.hasFocus;\n        // On Safari adding an input event handler somehow prevents an\n        // issue where the composition vanishes when you press enter.\n        if (browser.safari) view.contentDOM.addEventListener(\"input\", ()=>null);\n        if (browser.gecko) firefoxCopyCutHack(view.contentDOM.ownerDocument);\n    }\n    handleEvent(event) {\n        if (!eventBelongsToEditor(this.view, event) || this.ignoreDuringComposition(event)) return;\n        if (event.type == \"keydown\" && this.keydown(event)) return;\n        this.runHandlers(event.type, event);\n    }\n    runHandlers(type, event) {\n        let handlers = this.handlers[type];\n        if (handlers) {\n            for (let observer of handlers.observers)observer(this.view, event);\n            for (let handler of handlers.handlers){\n                if (event.defaultPrevented) break;\n                if (handler(this.view, event)) {\n                    event.preventDefault();\n                    break;\n                }\n            }\n        }\n    }\n    ensureHandlers(plugins) {\n        let handlers = computeHandlers(plugins), prev = this.handlers, dom = this.view.contentDOM;\n        for(let type in handlers)if (type != \"scroll\") {\n            let passive = !handlers[type].handlers.length;\n            let exists = prev[type];\n            if (exists && passive != !exists.handlers.length) {\n                dom.removeEventListener(type, this.handleEvent);\n                exists = null;\n            }\n            if (!exists) dom.addEventListener(type, this.handleEvent, {\n                passive\n            });\n        }\n        for(let type in prev)if (type != \"scroll\" && !handlers[type]) dom.removeEventListener(type, this.handleEvent);\n        this.handlers = handlers;\n    }\n    keydown(event) {\n        // Must always run, even if a custom handler handled the event\n        this.lastKeyCode = event.keyCode;\n        this.lastKeyTime = Date.now();\n        if (event.keyCode == 9 && Date.now() < this.lastEscPress + 2000) return true;\n        if (event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0) this.view.inputState.lastEscPress = 0;\n        // Chrome for Android usually doesn't fire proper key events, but\n        // occasionally does, usually surrounded by a bunch of complicated\n        // composition changes. When an enter or backspace key event is\n        // seen, hold off on handling DOM events for a bit, and then\n        // dispatch it.\n        if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {\n            this.view.observer.delayAndroidKey(event.key, event.keyCode);\n            return true;\n        }\n        // Preventing the default behavior of Enter on iOS makes the\n        // virtual keyboard get stuck in the wrong (lowercase)\n        // state. So we let it go through, and then, in\n        // applyDOMChange, notify key handlers of it and reset to\n        // the state they produce.\n        let pending;\n        if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey && ((pending = PendingKeys.find((key)=>key.keyCode == event.keyCode)) && !event.ctrlKey || EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {\n            this.pendingIOSKey = pending || event;\n            setTimeout(()=>this.flushIOSKey(), 250);\n            return true;\n        }\n        if (event.keyCode != 229) this.view.observer.forceFlush();\n        return false;\n    }\n    flushIOSKey() {\n        let key = this.pendingIOSKey;\n        if (!key) return false;\n        this.pendingIOSKey = undefined;\n        return dispatchKey(this.view.contentDOM, key.key, key.keyCode);\n    }\n    ignoreDuringComposition(event) {\n        if (!/^key/.test(event.type)) return false;\n        if (this.composing > 0) return true;\n        // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.\n        // On some input method editors (IMEs), the Enter key is used to\n        // confirm character selection. On Safari, when Enter is pressed,\n        // compositionend and keydown events are sometimes emitted in the\n        // wrong order. The key event should still be ignored, even when\n        // it happens after the compositionend event.\n        if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {\n            this.compositionPendingKey = false;\n            return true;\n        }\n        return false;\n    }\n    startMouseSelection(mouseSelection) {\n        if (this.mouseSelection) this.mouseSelection.destroy();\n        this.mouseSelection = mouseSelection;\n    }\n    update(update) {\n        if (this.mouseSelection) this.mouseSelection.update(update);\n        if (this.draggedContent && update.docChanged) this.draggedContent = this.draggedContent.map(update.changes);\n        if (update.transactions.length) this.lastKeyCode = this.lastSelectionTime = 0;\n    }\n    destroy() {\n        if (this.mouseSelection) this.mouseSelection.destroy();\n    }\n}\nfunction bindHandler(plugin, handler) {\n    return (view, event)=>{\n        try {\n            return handler.call(plugin, event, view);\n        } catch (e) {\n            logException(view.state, e);\n        }\n    };\n}\nfunction computeHandlers(plugins) {\n    let result = Object.create(null);\n    function record(type) {\n        return result[type] || (result[type] = {\n            observers: [],\n            handlers: []\n        });\n    }\n    for (let plugin of plugins){\n        let spec = plugin.spec;\n        if (spec && spec.domEventHandlers) for(let type in spec.domEventHandlers){\n            let f = spec.domEventHandlers[type];\n            if (f) record(type).handlers.push(bindHandler(plugin.value, f));\n        }\n        if (spec && spec.domEventObservers) for(let type in spec.domEventObservers){\n            let f = spec.domEventObservers[type];\n            if (f) record(type).observers.push(bindHandler(plugin.value, f));\n        }\n    }\n    for(let type in handlers)record(type).handlers.push(handlers[type]);\n    for(let type in observers)record(type).observers.push(observers[type]);\n    return result;\n}\nconst PendingKeys = [\n    {\n        key: \"Backspace\",\n        keyCode: 8,\n        inputType: \"deleteContentBackward\"\n    },\n    {\n        key: \"Enter\",\n        keyCode: 13,\n        inputType: \"insertParagraph\"\n    },\n    {\n        key: \"Enter\",\n        keyCode: 13,\n        inputType: \"insertLineBreak\"\n    },\n    {\n        key: \"Delete\",\n        keyCode: 46,\n        inputType: \"deleteContentForward\"\n    }\n];\nconst EmacsyPendingKeys = \"dthko\";\n// Key codes for modifier keys\nconst modifierCodes = [\n    16,\n    17,\n    18,\n    20,\n    91,\n    92,\n    224,\n    225\n];\nconst dragScrollMargin = 6;\nfunction dragScrollSpeed(dist) {\n    return Math.max(0, dist) * 0.7 + 8;\n}\nfunction dist(a, b) {\n    return Math.max(Math.abs(a.clientX - b.clientX), Math.abs(a.clientY - b.clientY));\n}\nclass MouseSelection {\n    constructor(view, startEvent, style, mustSelect){\n        this.view = view;\n        this.startEvent = startEvent;\n        this.style = style;\n        this.mustSelect = mustSelect;\n        this.scrollSpeed = {\n            x: 0,\n            y: 0\n        };\n        this.scrolling = -1;\n        this.lastEvent = startEvent;\n        this.scrollParent = scrollableParent(view.contentDOM);\n        this.atoms = view.state.facet(atomicRanges).map((f)=>f(view));\n        let doc = view.contentDOM.ownerDocument;\n        doc.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n        doc.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n        this.extend = startEvent.shiftKey;\n        this.multiple = view.state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);\n        this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;\n    }\n    start(event) {\n        // When clicking outside of the selection, immediately apply the\n        // effect of starting the selection\n        if (this.dragging === false) this.select(event);\n    }\n    move(event) {\n        var _a;\n        if (event.buttons == 0) return this.destroy();\n        if (this.dragging || this.dragging == null && dist(this.startEvent, event) < 10) return;\n        this.select(this.lastEvent = event);\n        let sx = 0, sy = 0;\n        let rect = ((_a = this.scrollParent) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) || {\n            left: 0,\n            top: 0,\n            right: this.view.win.innerWidth,\n            bottom: this.view.win.innerHeight\n        };\n        let margins = getScrollMargins(this.view);\n        if (event.clientX - margins.left <= rect.left + dragScrollMargin) sx = -dragScrollSpeed(rect.left - event.clientX);\n        else if (event.clientX + margins.right >= rect.right - dragScrollMargin) sx = dragScrollSpeed(event.clientX - rect.right);\n        if (event.clientY - margins.top <= rect.top + dragScrollMargin) sy = -dragScrollSpeed(rect.top - event.clientY);\n        else if (event.clientY + margins.bottom >= rect.bottom - dragScrollMargin) sy = dragScrollSpeed(event.clientY - rect.bottom);\n        this.setScrollSpeed(sx, sy);\n    }\n    up(event) {\n        if (this.dragging == null) this.select(this.lastEvent);\n        if (!this.dragging) event.preventDefault();\n        this.destroy();\n    }\n    destroy() {\n        this.setScrollSpeed(0, 0);\n        let doc = this.view.contentDOM.ownerDocument;\n        doc.removeEventListener(\"mousemove\", this.move);\n        doc.removeEventListener(\"mouseup\", this.up);\n        this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;\n    }\n    setScrollSpeed(sx, sy) {\n        this.scrollSpeed = {\n            x: sx,\n            y: sy\n        };\n        if (sx || sy) {\n            if (this.scrolling < 0) this.scrolling = setInterval(()=>this.scroll(), 50);\n        } else if (this.scrolling > -1) {\n            clearInterval(this.scrolling);\n            this.scrolling = -1;\n        }\n    }\n    scroll() {\n        if (this.scrollParent) {\n            this.scrollParent.scrollLeft += this.scrollSpeed.x;\n            this.scrollParent.scrollTop += this.scrollSpeed.y;\n        } else {\n            this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y);\n        }\n        if (this.dragging === false) this.select(this.lastEvent);\n    }\n    skipAtoms(sel) {\n        let ranges = null;\n        for(let i = 0; i < sel.ranges.length; i++){\n            let range = sel.ranges[i], updated = null;\n            if (range.empty) {\n                let pos = skipAtomicRanges(this.atoms, range.from, 0);\n                if (pos != range.from) updated = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos, -1);\n            } else {\n                let from = skipAtomicRanges(this.atoms, range.from, -1);\n                let to = skipAtomicRanges(this.atoms, range.to, 1);\n                if (from != range.from || to != range.to) updated = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(range.from == range.anchor ? from : to, range.from == range.head ? from : to);\n            }\n            if (updated) {\n                if (!ranges) ranges = sel.ranges.slice();\n                ranges[i] = updated;\n            }\n        }\n        return ranges ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(ranges, sel.mainIndex) : sel;\n    }\n    select(event) {\n        let { view } = this, selection = this.skipAtoms(this.style.get(event, this.extend, this.multiple));\n        if (this.mustSelect || !selection.eq(view.state.selection, this.dragging === false)) this.view.dispatch({\n            selection,\n            userEvent: \"select.pointer\"\n        });\n        this.mustSelect = false;\n    }\n    update(update) {\n        if (this.style.update(update)) setTimeout(()=>this.select(this.lastEvent), 20);\n    }\n}\nfunction addsSelectionRange(view, event) {\n    let facet = view.state.facet(clickAddsSelectionRange);\n    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;\n}\nfunction dragMovesSelection(view, event) {\n    let facet = view.state.facet(dragMovesSelection$1);\n    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;\n}\nfunction isInPrimarySelection(view, event) {\n    let { main } = view.state.selection;\n    if (main.empty) return false;\n    // On boundary clicks, check whether the coordinates are inside the\n    // selection's client rectangles\n    let sel = getSelection(view.root);\n    if (!sel || sel.rangeCount == 0) return true;\n    let rects = sel.getRangeAt(0).getClientRects();\n    for(let i = 0; i < rects.length; i++){\n        let rect = rects[i];\n        if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY) return true;\n    }\n    return false;\n}\nfunction eventBelongsToEditor(view, event) {\n    if (!event.bubbles) return true;\n    if (event.defaultPrevented) return false;\n    for(let node = event.target, cView; node != view.contentDOM; node = node.parentNode)if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event)) return false;\n    return true;\n}\nconst handlers = /*@__PURE__*/ Object.create(null);\nconst observers = /*@__PURE__*/ Object.create(null);\n// This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard API—all the objects and methods are\n// there, they just don't work, and they are hard to test.\nconst brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;\nfunction capturePaste(view) {\n    let parent = view.dom.parentNode;\n    if (!parent) return;\n    let target = parent.appendChild(document.createElement(\"textarea\"));\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.focus();\n    setTimeout(()=>{\n        view.focus();\n        target.remove();\n        doPaste(view, target.value);\n    }, 50);\n}\nfunction doPaste(view, input) {\n    let { state } = view, changes, i = 1, text = state.toText(input);\n    let byLine = text.lines == state.selection.ranges.length;\n    let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r)=>r.empty) && lastLinewiseCopy == text.toString();\n    if (linewise) {\n        let lastLine = -1;\n        changes = state.changeByRange((range)=>{\n            let line = state.doc.lineAt(range.from);\n            if (line.from == lastLine) return {\n                range\n            };\n            lastLine = line.from;\n            let insert = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);\n            return {\n                changes: {\n                    from: line.from,\n                    insert\n                },\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(range.from + insert.length)\n            };\n        });\n    } else if (byLine) {\n        changes = state.changeByRange((range)=>{\n            let line = text.line(i++);\n            return {\n                changes: {\n                    from: range.from,\n                    to: range.to,\n                    insert: line.text\n                },\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(range.from + line.length)\n            };\n        });\n    } else {\n        changes = state.replaceSelection(text);\n    }\n    view.dispatch(changes, {\n        userEvent: \"input.paste\",\n        scrollIntoView: true\n    });\n}\nobservers.scroll = (view)=>{\n    view.inputState.lastScrollTop = view.scrollDOM.scrollTop;\n    view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;\n};\nhandlers.keydown = (view, event)=>{\n    view.inputState.setSelectionOrigin(\"select\");\n    if (event.keyCode == 27) view.inputState.lastEscPress = Date.now();\n    return false;\n};\nobservers.touchstart = (view, e)=>{\n    view.inputState.lastTouchTime = Date.now();\n    view.inputState.setSelectionOrigin(\"select.pointer\");\n};\nobservers.touchmove = (view)=>{\n    view.inputState.setSelectionOrigin(\"select.pointer\");\n};\nhandlers.mousedown = (view, event)=>{\n    view.observer.flush();\n    if (view.inputState.lastTouchTime > Date.now() - 2000) return false; // Ignore touch interaction\n    let style = null;\n    for (let makeStyle of view.state.facet(mouseSelectionStyle)){\n        style = makeStyle(view, event);\n        if (style) break;\n    }\n    if (!style && event.button == 0) style = basicMouseSelection(view, event);\n    if (style) {\n        let mustFocus = !view.hasFocus;\n        view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));\n        if (mustFocus) view.observer.ignore(()=>focusPreventScroll(view.contentDOM));\n        let mouseSel = view.inputState.mouseSelection;\n        if (mouseSel) {\n            mouseSel.start(event);\n            return mouseSel.dragging === false;\n        }\n    }\n    return false;\n};\nfunction rangeForClick(view, pos, bias, type) {\n    if (type == 1) {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos, bias);\n    } else if (type == 2) {\n        return groupAt(view.state, pos, bias);\n    } else {\n        let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);\n        let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;\n        if (to < view.state.doc.length && to == line.to) to++;\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(from, to);\n    }\n}\nlet insideY = (y, rect)=>y >= rect.top && y <= rect.bottom;\nlet inside = (x, y, rect)=>insideY(y, rect) && x >= rect.left && x <= rect.right;\n// Try to determine, for the given coordinates, associated with the\n// given position, whether they are related to the element before or\n// the element after the position.\nfunction findPositionSide(view, pos, x, y) {\n    let line = LineView.find(view.docView, pos);\n    if (!line) return 1;\n    let off = pos - line.posAtStart;\n    // Line boundaries point into the line\n    if (off == 0) return 1;\n    if (off == line.length) return -1;\n    // Positions on top of an element point at that element\n    let before = line.coordsAt(off, -1);\n    if (before && inside(x, y, before)) return -1;\n    let after = line.coordsAt(off, 1);\n    if (after && inside(x, y, after)) return 1;\n    // This is probably a line wrap point. Pick before if the point is\n    // beside it.\n    return before && insideY(y, before) ? -1 : 1;\n}\nfunction queryPos(view, event) {\n    let pos = view.posAtCoords({\n        x: event.clientX,\n        y: event.clientY\n    }, false);\n    return {\n        pos,\n        bias: findPositionSide(view, pos, event.clientX, event.clientY)\n    };\n}\nconst BadMouseDetail = browser.ie && browser.ie_version <= 11;\nlet lastMouseDown = null, lastMouseDownCount = 0, lastMouseDownTime = 0;\nfunction getClickType(event) {\n    if (!BadMouseDetail) return event.detail;\n    let last = lastMouseDown, lastTime = lastMouseDownTime;\n    lastMouseDown = event;\n    lastMouseDownTime = Date.now();\n    return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;\n}\nfunction basicMouseSelection(view, event) {\n    let start = queryPos(view, event), type = getClickType(event);\n    let startSel = view.state.selection;\n    return {\n        update (update) {\n            if (update.docChanged) {\n                start.pos = update.changes.mapPos(start.pos);\n                startSel = startSel.map(update.changes);\n            }\n        },\n        get (event, extend, multiple) {\n            let cur = queryPos(view, event), removed;\n            let range = rangeForClick(view, cur.pos, cur.bias, type);\n            if (start.pos != cur.pos && !extend) {\n                let startRange = rangeForClick(view, start.pos, start.bias, type);\n                let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);\n                range = from < range.from ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(from, to) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(to, from);\n            }\n            if (extend) return startSel.replaceRange(startSel.main.extend(range.from, range.to));\n            else if (multiple && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur.pos))) return removed;\n            else if (multiple) return startSel.addRange(range);\n            else return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create([\n                range\n            ]);\n        }\n    };\n}\nfunction removeRangeAround(sel, pos) {\n    for(let i = 0; i < sel.ranges.length; i++){\n        let { from, to } = sel.ranges[i];\n        if (from <= pos && to >= pos) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));\n    }\n    return null;\n}\nhandlers.dragstart = (view, event)=>{\n    let { selection: { main: range } } = view.state;\n    if (event.target.draggable) {\n        let cView = view.docView.nearest(event.target);\n        if (cView && cView.isWidget) {\n            let from = cView.posAtStart, to = from + cView.length;\n            if (from >= range.to || to <= range.from) range = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(from, to);\n        }\n    }\n    let { inputState } = view;\n    if (inputState.mouseSelection) inputState.mouseSelection.dragging = true;\n    inputState.draggedContent = range;\n    if (event.dataTransfer) {\n        event.dataTransfer.setData(\"Text\", view.state.sliceDoc(range.from, range.to));\n        event.dataTransfer.effectAllowed = \"copyMove\";\n    }\n    return false;\n};\nhandlers.dragend = (view)=>{\n    view.inputState.draggedContent = null;\n    return false;\n};\nfunction dropText(view, event, text, direct) {\n    if (!text) return;\n    let dropPos = view.posAtCoords({\n        x: event.clientX,\n        y: event.clientY\n    }, false);\n    let { draggedContent } = view.inputState;\n    let del = direct && draggedContent && dragMovesSelection(view, event) ? {\n        from: draggedContent.from,\n        to: draggedContent.to\n    } : null;\n    let ins = {\n        from: dropPos,\n        insert: text\n    };\n    let changes = view.state.changes(del ? [\n        del,\n        ins\n    ] : ins);\n    view.focus();\n    view.dispatch({\n        changes,\n        selection: {\n            anchor: changes.mapPos(dropPos, -1),\n            head: changes.mapPos(dropPos, 1)\n        },\n        userEvent: del ? \"move.drop\" : \"input.drop\"\n    });\n    view.inputState.draggedContent = null;\n}\nhandlers.drop = (view, event)=>{\n    if (!event.dataTransfer) return false;\n    if (view.state.readOnly) return true;\n    let files = event.dataTransfer.files;\n    if (files && files.length) {\n        let text = Array(files.length), read = 0;\n        let finishFile = ()=>{\n            if (++read == files.length) dropText(view, event, text.filter((s)=>s != null).join(view.state.lineBreak), false);\n        };\n        for(let i = 0; i < files.length; i++){\n            let reader = new FileReader;\n            reader.onerror = finishFile;\n            reader.onload = ()=>{\n                if (!/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(reader.result)) text[i] = reader.result;\n                finishFile();\n            };\n            reader.readAsText(files[i]);\n        }\n        return true;\n    } else {\n        let text = event.dataTransfer.getData(\"Text\");\n        if (text) {\n            dropText(view, event, text, true);\n            return true;\n        }\n    }\n    return false;\n};\nhandlers.paste = (view, event)=>{\n    if (view.state.readOnly) return true;\n    view.observer.flush();\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    if (data) {\n        doPaste(view, data.getData(\"text/plain\") || data.getData(\"text/uri-text\"));\n        return true;\n    } else {\n        capturePaste(view);\n        return false;\n    }\n};\nfunction captureCopy(view, text) {\n    // The extra wrapper is somehow necessary on IE/Edge to prevent the\n    // content from being mangled when it is put onto the clipboard\n    let parent = view.dom.parentNode;\n    if (!parent) return;\n    let target = parent.appendChild(document.createElement(\"textarea\"));\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.value = text;\n    target.focus();\n    target.selectionEnd = text.length;\n    target.selectionStart = 0;\n    setTimeout(()=>{\n        target.remove();\n        view.focus();\n    }, 50);\n}\nfunction copiedRange(state) {\n    let content = [], ranges = [], linewise = false;\n    for (let range of state.selection.ranges)if (!range.empty) {\n        content.push(state.sliceDoc(range.from, range.to));\n        ranges.push(range);\n    }\n    if (!content.length) {\n        // Nothing selected, do a line-wise copy\n        let upto = -1;\n        for (let { from } of state.selection.ranges){\n            let line = state.doc.lineAt(from);\n            if (line.number > upto) {\n                content.push(line.text);\n                ranges.push({\n                    from: line.from,\n                    to: Math.min(state.doc.length, line.to + 1)\n                });\n            }\n            upto = line.number;\n        }\n        linewise = true;\n    }\n    return {\n        text: content.join(state.lineBreak),\n        ranges,\n        linewise\n    };\n}\nlet lastLinewiseCopy = null;\nhandlers.copy = handlers.cut = (view, event)=>{\n    let { text, ranges, linewise } = copiedRange(view.state);\n    if (!text && !linewise) return false;\n    lastLinewiseCopy = linewise ? text : null;\n    if (event.type == \"cut\" && !view.state.readOnly) view.dispatch({\n        changes: ranges,\n        scrollIntoView: true,\n        userEvent: \"delete.cut\"\n    });\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    if (data) {\n        data.clearData();\n        data.setData(\"text/plain\", text);\n        return true;\n    } else {\n        captureCopy(view, text);\n        return false;\n    }\n};\nconst isFocusChange = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Annotation.define();\nfunction focusChangeTransaction(state, focus) {\n    let effects = [];\n    for (let getEffect of state.facet(focusChangeEffect)){\n        let effect = getEffect(state, focus);\n        if (effect) effects.push(effect);\n    }\n    return effects ? state.update({\n        effects,\n        annotations: isFocusChange.of(true)\n    }) : null;\n}\nfunction updateForFocusChange(view) {\n    setTimeout(()=>{\n        let focus = view.hasFocus;\n        if (focus != view.inputState.notifiedFocused) {\n            let tr = focusChangeTransaction(view.state, focus);\n            if (tr) view.dispatch(tr);\n            else view.update([]);\n        }\n    }, 10);\n}\nobservers.focus = (view)=>{\n    view.inputState.lastFocusTime = Date.now();\n    // When focusing reset the scroll position, move it back to where it was\n    if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {\n        view.scrollDOM.scrollTop = view.inputState.lastScrollTop;\n        view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;\n    }\n    updateForFocusChange(view);\n};\nobservers.blur = (view)=>{\n    view.observer.clearSelectionRange();\n    updateForFocusChange(view);\n};\nobservers.compositionstart = observers.compositionupdate = (view)=>{\n    if (view.inputState.compositionFirstChange == null) view.inputState.compositionFirstChange = true;\n    if (view.inputState.composing < 0) {\n        // FIXME possibly set a timeout to clear it again on Android\n        view.inputState.composing = 0;\n    }\n};\nobservers.compositionend = (view)=>{\n    view.inputState.composing = -1;\n    view.inputState.compositionEndedAt = Date.now();\n    view.inputState.compositionPendingKey = true;\n    view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;\n    view.inputState.compositionFirstChange = null;\n    if (browser.chrome && browser.android) {\n        // Delay flushing for a bit on Android because it'll often fire a\n        // bunch of contradictory changes in a row at end of compositon\n        view.observer.flushSoon();\n    } else if (view.inputState.compositionPendingChange) {\n        // If we found pending records, schedule a flush.\n        Promise.resolve().then(()=>view.observer.flush());\n    } else {\n        // Otherwise, make sure that, if no changes come in soon, the\n        // composition view is cleared.\n        setTimeout(()=>{\n            if (view.inputState.composing < 0 && view.docView.hasComposition) view.update([]);\n        }, 50);\n    }\n};\nobservers.contextmenu = (view)=>{\n    view.inputState.lastContextMenu = Date.now();\n};\nhandlers.beforeinput = (view, event)=>{\n    var _a;\n    // Because Chrome Android doesn't fire useful key events, use\n    // beforeinput to detect backspace (and possibly enter and delete,\n    // but those usually don't even seem to fire beforeinput events at\n    // the moment) and fake a key event for it.\n    //\n    // (preventDefault on beforeinput, though supported in the spec,\n    // seems to do nothing at all on Chrome).\n    let pending;\n    if (browser.chrome && browser.android && (pending = PendingKeys.find((key)=>key.inputType == event.inputType))) {\n        view.observer.delayAndroidKey(pending.key, pending.keyCode);\n        if (pending.key == \"Backspace\" || pending.key == \"Delete\") {\n            let startViewHeight = ((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0;\n            setTimeout(()=>{\n                var _a;\n                // Backspacing near uneditable nodes on Chrome Android sometimes\n                // closes the virtual keyboard. This tries to crudely detect\n                // that and refocus to get it back.\n                if ((((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0) > startViewHeight + 10 && view.hasFocus) {\n                    view.contentDOM.blur();\n                    view.focus();\n                }\n            }, 100);\n        }\n    }\n    return false;\n};\nconst appliedFirefoxHack = /*@__PURE__*/ new Set;\n// In Firefox, when cut/copy handlers are added to the document, that\n// somehow avoids a bug where those events aren't fired when the\n// selection is empty. See https://github.com/codemirror/dev/issues/1082\n// and https://bugzilla.mozilla.org/show_bug.cgi?id=995961\nfunction firefoxCopyCutHack(doc) {\n    if (!appliedFirefoxHack.has(doc)) {\n        appliedFirefoxHack.add(doc);\n        doc.addEventListener(\"copy\", ()=>{});\n        doc.addEventListener(\"cut\", ()=>{});\n    }\n}\nconst wrappingWhiteSpace = [\n    \"pre-wrap\",\n    \"normal\",\n    \"pre-line\",\n    \"break-spaces\"\n];\nclass HeightOracle {\n    constructor(lineWrapping){\n        this.lineWrapping = lineWrapping;\n        this.doc = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n        this.heightSamples = {};\n        this.lineHeight = 14; // The height of an entire line (line-height)\n        this.charWidth = 7;\n        this.textHeight = 14; // The height of the actual font (font-size)\n        this.lineLength = 30;\n        // Used to track, during updateHeight, if any actual heights changed\n        this.heightChanged = false;\n    }\n    heightForGap(from, to) {\n        let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;\n        if (this.lineWrapping) lines += Math.max(0, Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength));\n        return this.lineHeight * lines;\n    }\n    heightForLine(length) {\n        if (!this.lineWrapping) return this.lineHeight;\n        let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));\n        return lines * this.lineHeight;\n    }\n    setDoc(doc) {\n        this.doc = doc;\n        return this;\n    }\n    mustRefreshForWrapping(whiteSpace) {\n        return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;\n    }\n    mustRefreshForHeights(lineHeights) {\n        let newHeight = false;\n        for(let i = 0; i < lineHeights.length; i++){\n            let h = lineHeights[i];\n            if (h < 0) {\n                i++;\n            } else if (!this.heightSamples[Math.floor(h * 10)]) {\n                newHeight = true;\n                this.heightSamples[Math.floor(h * 10)] = true;\n            }\n        }\n        return newHeight;\n    }\n    refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {\n        let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;\n        let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;\n        this.lineWrapping = lineWrapping;\n        this.lineHeight = lineHeight;\n        this.charWidth = charWidth;\n        this.textHeight = textHeight;\n        this.lineLength = lineLength;\n        if (changed) {\n            this.heightSamples = {};\n            for(let i = 0; i < knownHeights.length; i++){\n                let h = knownHeights[i];\n                if (h < 0) i++;\n                else this.heightSamples[Math.floor(h * 10)] = true;\n            }\n        }\n        return changed;\n    }\n}\n// This object is used by `updateHeight` to make DOM measurements\n// arrive at the right nides. The `heights` array is a sequence of\n// block heights, starting from position `from`.\nclass MeasuredHeights {\n    constructor(from, heights){\n        this.from = from;\n        this.heights = heights;\n        this.index = 0;\n    }\n    get more() {\n        return this.index < this.heights.length;\n    }\n}\n/**\nRecord used to represent information about a block-level element\nin the editor view.\n*/ class BlockInfo {\n    /**\n    @internal\n    */ constructor(/**\n    The start of the element in the document.\n    */ from, /**\n    The length of the element.\n    */ length, /**\n    The top position of the element (relative to the top of the\n    document).\n    */ top, /**\n    Its height.\n    */ height, /**\n    @internal Weird packed field that holds an array of children\n    for composite blocks, a decoration for block widgets, and a\n    number indicating the amount of widget-create line breaks for\n    text blocks.\n    */ _content){\n        this.from = from;\n        this.length = length;\n        this.top = top;\n        this.height = height;\n        this._content = _content;\n    }\n    /**\n    The type of element this is. When querying lines, this may be\n    an array of all the blocks that make up the line.\n    */ get type() {\n        return typeof this._content == \"number\" ? BlockType.Text : Array.isArray(this._content) ? this._content : this._content.type;\n    }\n    /**\n    The end of the element as a document position.\n    */ get to() {\n        return this.from + this.length;\n    }\n    /**\n    The bottom position of the element.\n    */ get bottom() {\n        return this.top + this.height;\n    }\n    /**\n    If this is a widget block, this will return the widget\n    associated with it.\n    */ get widget() {\n        return this._content instanceof PointDecoration ? this._content.widget : null;\n    }\n    /**\n    If this is a textblock, this holds the number of line breaks\n    that appear in widgets inside the block.\n    */ get widgetLineBreaks() {\n        return typeof this._content == \"number\" ? this._content : 0;\n    }\n    /**\n    @internal\n    */ join(other) {\n        let content = (Array.isArray(this._content) ? this._content : [\n            this\n        ]).concat(Array.isArray(other._content) ? other._content : [\n            other\n        ]);\n        return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content);\n    }\n}\nvar QueryType = /*@__PURE__*/ function(QueryType) {\n    QueryType[QueryType[\"ByPos\"] = 0] = \"ByPos\";\n    QueryType[QueryType[\"ByHeight\"] = 1] = \"ByHeight\";\n    QueryType[QueryType[\"ByPosNoHeight\"] = 2] = \"ByPosNoHeight\";\n    return QueryType;\n}(QueryType || (QueryType = {}));\nconst Epsilon = 1e-3;\nclass HeightMap {\n    constructor(length, height, flags = 2 /* Flag.Outdated */ ){\n        this.length = length;\n        this.height = height;\n        this.flags = flags;\n    }\n    get outdated() {\n        return (this.flags & 2 /* Flag.Outdated */ ) > 0;\n    }\n    set outdated(value) {\n        this.flags = (value ? 2 /* Flag.Outdated */  : 0) | this.flags & ~2 /* Flag.Outdated */ ;\n    }\n    setHeight(oracle, height) {\n        if (this.height != height) {\n            if (Math.abs(this.height - height) > Epsilon) oracle.heightChanged = true;\n            this.height = height;\n        }\n    }\n    // Base case is to replace a leaf node, which simply builds a tree\n    // from the new nodes and returns that (HeightMapBranch and\n    // HeightMapGap override this to actually use from/to)\n    replace(_from, _to, nodes) {\n        return HeightMap.of(nodes);\n    }\n    // Again, these are base cases, and are overridden for branch and gap nodes.\n    decomposeLeft(_to, result) {\n        result.push(this);\n    }\n    decomposeRight(_from, result) {\n        result.push(this);\n    }\n    applyChanges(decorations, oldDoc, oracle, changes) {\n        let me = this, doc = oracle.doc;\n        for(let i = changes.length - 1; i >= 0; i--){\n            let { fromA, toA, fromB, toB } = changes[i];\n            let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);\n            let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);\n            toB += end.to - toA;\n            toA = end.to;\n            while(i > 0 && start.from <= changes[i - 1].toA){\n                fromA = changes[i - 1].fromA;\n                fromB = changes[i - 1].fromB;\n                i--;\n                if (fromA < start.from) start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);\n            }\n            fromB += start.from - fromA;\n            fromA = start.from;\n            let nodes = NodeBuilder.build(oracle.setDoc(doc), decorations, fromB, toB);\n            me = me.replace(fromA, toA, nodes);\n        }\n        return me.updateHeight(oracle, 0);\n    }\n    static empty() {\n        return new HeightMapText(0, 0);\n    }\n    // nodes uses null values to indicate the position of line breaks.\n    // There are never line breaks at the start or end of the array, or\n    // two line breaks next to each other, and the array isn't allowed\n    // to be empty (same restrictions as return value from the builder).\n    static of(nodes) {\n        if (nodes.length == 1) return nodes[0];\n        let i = 0, j = nodes.length, before = 0, after = 0;\n        for(;;){\n            if (i == j) {\n                if (before > after * 2) {\n                    let split = nodes[i - 1];\n                    if (split.break) nodes.splice(--i, 1, split.left, null, split.right);\n                    else nodes.splice(--i, 1, split.left, split.right);\n                    j += 1 + split.break;\n                    before -= split.size;\n                } else if (after > before * 2) {\n                    let split = nodes[j];\n                    if (split.break) nodes.splice(j, 1, split.left, null, split.right);\n                    else nodes.splice(j, 1, split.left, split.right);\n                    j += 2 + split.break;\n                    after -= split.size;\n                } else {\n                    break;\n                }\n            } else if (before < after) {\n                let next = nodes[i++];\n                if (next) before += next.size;\n            } else {\n                let next = nodes[--j];\n                if (next) after += next.size;\n            }\n        }\n        let brk = 0;\n        if (nodes[i - 1] == null) {\n            brk = 1;\n            i--;\n        } else if (nodes[i] == null) {\n            brk = 1;\n            j++;\n        }\n        return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));\n    }\n}\nHeightMap.prototype.size = 1;\nclass HeightMapBlock extends HeightMap {\n    constructor(length, height, deco){\n        super(length, height);\n        this.deco = deco;\n    }\n    blockAt(_height, _oracle, top, offset) {\n        return new BlockInfo(offset, this.length, top, this.height, this.deco || 0);\n    }\n    lineAt(_value, _type, oracle, top, offset) {\n        return this.blockAt(0, oracle, top, offset);\n    }\n    forEachLine(from, to, oracle, top, offset, f) {\n        if (from <= offset + this.length && to >= offset) f(this.blockAt(0, oracle, top, offset));\n    }\n    updateHeight(oracle, offset = 0, _force = false, measured) {\n        if (measured && measured.from <= offset && measured.more) this.setHeight(oracle, measured.heights[measured.index++]);\n        this.outdated = false;\n        return this;\n    }\n    toString() {\n        return `block(${this.length})`;\n    }\n}\nclass HeightMapText extends HeightMapBlock {\n    constructor(length, height){\n        super(length, height, null);\n        this.collapsed = 0; // Amount of collapsed content in the line\n        this.widgetHeight = 0; // Maximum inline widget height\n        this.breaks = 0; // Number of widget-introduced line breaks on the line\n    }\n    blockAt(_height, _oracle, top, offset) {\n        return new BlockInfo(offset, this.length, top, this.height, this.breaks);\n    }\n    replace(_from, _to, nodes) {\n        let node = nodes[0];\n        if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & 4 /* Flag.SingleLine */ ) && Math.abs(this.length - node.length) < 10) {\n            if (node instanceof HeightMapGap) node = new HeightMapText(node.length, this.height);\n            else node.height = this.height;\n            if (!this.outdated) node.outdated = false;\n            return node;\n        } else {\n            return HeightMap.of(nodes);\n        }\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        if (measured && measured.from <= offset && measured.more) this.setHeight(oracle, measured.heights[measured.index++]);\n        else if (force || this.outdated) this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) + this.breaks * oracle.lineHeight);\n        this.outdated = false;\n        return this;\n    }\n    toString() {\n        return `line(${this.length}${this.collapsed ? -this.collapsed : \"\"}${this.widgetHeight ? \":\" + this.widgetHeight : \"\"})`;\n    }\n}\nclass HeightMapGap extends HeightMap {\n    constructor(length){\n        super(length, 0);\n    }\n    heightMetrics(oracle, offset) {\n        let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;\n        let lines = lastLine - firstLine + 1;\n        let perLine, perChar = 0;\n        if (oracle.lineWrapping) {\n            let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);\n            perLine = totalPerLine / lines;\n            if (this.length > lines + 1) perChar = (this.height - totalPerLine) / (this.length - lines - 1);\n        } else {\n            perLine = this.height / lines;\n        }\n        return {\n            firstLine,\n            lastLine,\n            perLine,\n            perChar\n        };\n    }\n    blockAt(height, oracle, top, offset) {\n        let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset);\n        if (oracle.lineWrapping) {\n            let guess = offset + Math.round(Math.max(0, Math.min(1, (height - top) / this.height)) * this.length);\n            let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;\n            let lineTop = Math.max(top, height - lineHeight / 2);\n            return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);\n        } else {\n            let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / perLine)));\n            let { from, length } = oracle.doc.line(firstLine + line);\n            return new BlockInfo(from, length, top + perLine * line, perLine, 0);\n        }\n    }\n    lineAt(value, type, oracle, top, offset) {\n        if (type == QueryType.ByHeight) return this.blockAt(value, oracle, top, offset);\n        if (type == QueryType.ByPosNoHeight) {\n            let { from, to } = oracle.doc.lineAt(value);\n            return new BlockInfo(from, to - from, 0, 0, 0);\n        }\n        let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);\n        let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;\n        let linesAbove = line.number - firstLine;\n        let lineTop = top + perLine * linesAbove + perChar * (line.from - offset - linesAbove);\n        return new BlockInfo(line.from, line.length, Math.max(top, Math.min(lineTop, top + this.height - lineHeight)), lineHeight, 0);\n    }\n    forEachLine(from, to, oracle, top, offset, f) {\n        from = Math.max(from, offset);\n        to = Math.min(to, offset + this.length);\n        let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);\n        for(let pos = from, lineTop = top; pos <= to;){\n            let line = oracle.doc.lineAt(pos);\n            if (pos == from) {\n                let linesAbove = line.number - firstLine;\n                lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove);\n            }\n            let lineHeight = perLine + perChar * line.length;\n            f(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));\n            lineTop += lineHeight;\n            pos = line.to + 1;\n        }\n    }\n    replace(from, to, nodes) {\n        let after = this.length - to;\n        if (after > 0) {\n            let last = nodes[nodes.length - 1];\n            if (last instanceof HeightMapGap) nodes[nodes.length - 1] = new HeightMapGap(last.length + after);\n            else nodes.push(null, new HeightMapGap(after - 1));\n        }\n        if (from > 0) {\n            let first = nodes[0];\n            if (first instanceof HeightMapGap) nodes[0] = new HeightMapGap(from + first.length);\n            else nodes.unshift(new HeightMapGap(from - 1), null);\n        }\n        return HeightMap.of(nodes);\n    }\n    decomposeLeft(to, result) {\n        result.push(new HeightMapGap(to - 1), null);\n    }\n    decomposeRight(from, result) {\n        result.push(null, new HeightMapGap(this.length - from - 1));\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        let end = offset + this.length;\n        if (measured && measured.from <= offset + this.length && measured.more) {\n            // Fill in part of this gap with measured lines. We know there\n            // can't be widgets or collapsed ranges in those lines, because\n            // they would already have been added to the heightmap (gaps\n            // only contain plain text).\n            let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;\n            if (measured.from > offset) nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));\n            while(pos <= end && measured.more){\n                let len = oracle.doc.lineAt(pos).length;\n                if (nodes.length) nodes.push(null);\n                let height = measured.heights[measured.index++];\n                if (singleHeight == -1) singleHeight = height;\n                else if (Math.abs(height - singleHeight) >= Epsilon) singleHeight = -2;\n                let line = new HeightMapText(len, height);\n                line.outdated = false;\n                nodes.push(line);\n                pos += len + 1;\n            }\n            if (pos <= end) nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));\n            let result = HeightMap.of(nodes);\n            if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon) oracle.heightChanged = true;\n            return result;\n        } else if (force || this.outdated) {\n            this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));\n            this.outdated = false;\n        }\n        return this;\n    }\n    toString() {\n        return `gap(${this.length})`;\n    }\n}\nclass HeightMapBranch extends HeightMap {\n    constructor(left, brk, right){\n        super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 /* Flag.Outdated */  : 0));\n        this.left = left;\n        this.right = right;\n        this.size = left.size + right.size;\n    }\n    get break() {\n        return this.flags & 1 /* Flag.Break */ ;\n    }\n    blockAt(height, oracle, top, offset) {\n        let mid = top + this.left.height;\n        return height < mid ? this.left.blockAt(height, oracle, top, offset) : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);\n    }\n    lineAt(value, type, oracle, top, offset) {\n        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;\n        let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;\n        let base = left ? this.left.lineAt(value, type, oracle, top, offset) : this.right.lineAt(value, type, oracle, rightTop, rightOffset);\n        if (this.break || (left ? base.to < rightOffset : base.from > rightOffset)) return base;\n        let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;\n        if (left) return base.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));\n        else return this.left.lineAt(rightOffset, subQuery, oracle, top, offset).join(base);\n    }\n    forEachLine(from, to, oracle, top, offset, f) {\n        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;\n        if (this.break) {\n            if (from < rightOffset) this.left.forEachLine(from, to, oracle, top, offset, f);\n            if (to >= rightOffset) this.right.forEachLine(from, to, oracle, rightTop, rightOffset, f);\n        } else {\n            let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top, offset);\n            if (from < mid.from) this.left.forEachLine(from, mid.from - 1, oracle, top, offset, f);\n            if (mid.to >= from && mid.from <= to) f(mid);\n            if (to > mid.to) this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f);\n        }\n    }\n    replace(from, to, nodes) {\n        let rightStart = this.left.length + this.break;\n        if (to < rightStart) return this.balanced(this.left.replace(from, to, nodes), this.right);\n        if (from > this.left.length) return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));\n        let result = [];\n        if (from > 0) this.decomposeLeft(from, result);\n        let left = result.length;\n        for (let node of nodes)result.push(node);\n        if (from > 0) mergeGaps(result, left - 1);\n        if (to < this.length) {\n            let right = result.length;\n            this.decomposeRight(to, result);\n            mergeGaps(result, right);\n        }\n        return HeightMap.of(result);\n    }\n    decomposeLeft(to, result) {\n        let left = this.left.length;\n        if (to <= left) return this.left.decomposeLeft(to, result);\n        result.push(this.left);\n        if (this.break) {\n            left++;\n            if (to >= left) result.push(null);\n        }\n        if (to > left) this.right.decomposeLeft(to - left, result);\n    }\n    decomposeRight(from, result) {\n        let left = this.left.length, right = left + this.break;\n        if (from >= right) return this.right.decomposeRight(from - right, result);\n        if (from < left) this.left.decomposeRight(from, result);\n        if (this.break && from < right) result.push(null);\n        result.push(this.right);\n    }\n    balanced(left, right) {\n        if (left.size > 2 * right.size || right.size > 2 * left.size) return HeightMap.of(this.break ? [\n            left,\n            null,\n            right\n        ] : [\n            left,\n            right\n        ]);\n        this.left = left;\n        this.right = right;\n        this.height = left.height + right.height;\n        this.outdated = left.outdated || right.outdated;\n        this.size = left.size + right.size;\n        this.length = left.length + this.break + right.length;\n        return this;\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;\n        if (measured && measured.from <= offset + left.length && measured.more) rebalance = left = left.updateHeight(oracle, offset, force, measured);\n        else left.updateHeight(oracle, offset, force);\n        if (measured && measured.from <= rightStart + right.length && measured.more) rebalance = right = right.updateHeight(oracle, rightStart, force, measured);\n        else right.updateHeight(oracle, rightStart, force);\n        if (rebalance) return this.balanced(left, right);\n        this.height = this.left.height + this.right.height;\n        this.outdated = false;\n        return this;\n    }\n    toString() {\n        return this.left + (this.break ? \" \" : \"-\") + this.right;\n    }\n}\nfunction mergeGaps(nodes, around) {\n    let before, after;\n    if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap) nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));\n}\nconst relevantWidgetHeight = 5;\nclass NodeBuilder {\n    constructor(pos, oracle){\n        this.pos = pos;\n        this.oracle = oracle;\n        this.nodes = [];\n        this.lineStart = -1;\n        this.lineEnd = -1;\n        this.covering = null;\n        this.writtenTo = pos;\n    }\n    get isCovered() {\n        return this.covering && this.nodes[this.nodes.length - 1] == this.covering;\n    }\n    span(_from, to) {\n        if (this.lineStart > -1) {\n            let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];\n            if (last instanceof HeightMapText) last.length += end - this.pos;\n            else if (end > this.pos || !this.isCovered) this.nodes.push(new HeightMapText(end - this.pos, -1));\n            this.writtenTo = end;\n            if (to > end) {\n                this.nodes.push(null);\n                this.writtenTo++;\n                this.lineStart = -1;\n            }\n        }\n        this.pos = to;\n    }\n    point(from, to, deco) {\n        if (from < to || deco.heightRelevant) {\n            let height = deco.widget ? deco.widget.estimatedHeight : 0;\n            let breaks = deco.widget ? deco.widget.lineBreaks : 0;\n            if (height < 0) height = this.oracle.lineHeight;\n            let len = to - from;\n            if (deco.block) {\n                this.addBlock(new HeightMapBlock(len, height, deco));\n            } else if (len || breaks || height >= relevantWidgetHeight) {\n                this.addLineDeco(height, breaks, len);\n            }\n        } else if (to > from) {\n            this.span(from, to);\n        }\n        if (this.lineEnd > -1 && this.lineEnd < this.pos) this.lineEnd = this.oracle.doc.lineAt(this.pos).to;\n    }\n    enterLine() {\n        if (this.lineStart > -1) return;\n        let { from, to } = this.oracle.doc.lineAt(this.pos);\n        this.lineStart = from;\n        this.lineEnd = to;\n        if (this.writtenTo < from) {\n            if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null) this.nodes.push(this.blankContent(this.writtenTo, from - 1));\n            this.nodes.push(null);\n        }\n        if (this.pos > from) this.nodes.push(new HeightMapText(this.pos - from, -1));\n        this.writtenTo = this.pos;\n    }\n    blankContent(from, to) {\n        let gap = new HeightMapGap(to - from);\n        if (this.oracle.doc.lineAt(from).to == to) gap.flags |= 4 /* Flag.SingleLine */ ;\n        return gap;\n    }\n    ensureLine() {\n        this.enterLine();\n        let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;\n        if (last instanceof HeightMapText) return last;\n        let line = new HeightMapText(0, -1);\n        this.nodes.push(line);\n        return line;\n    }\n    addBlock(block) {\n        this.enterLine();\n        let deco = block.deco;\n        if (deco && deco.startSide > 0 && !this.isCovered) this.ensureLine();\n        this.nodes.push(block);\n        this.writtenTo = this.pos = this.pos + block.length;\n        if (deco && deco.endSide > 0) this.covering = block;\n    }\n    addLineDeco(height, breaks, length) {\n        let line = this.ensureLine();\n        line.length += length;\n        line.collapsed += length;\n        line.widgetHeight = Math.max(line.widgetHeight, height);\n        line.breaks += breaks;\n        this.writtenTo = this.pos = this.pos + length;\n    }\n    finish(from) {\n        let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];\n        if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered) this.nodes.push(new HeightMapText(0, -1));\n        else if (this.writtenTo < this.pos || last == null) this.nodes.push(this.blankContent(this.writtenTo, this.pos));\n        let pos = from;\n        for (let node of this.nodes){\n            if (node instanceof HeightMapText) node.updateHeight(this.oracle, pos);\n            pos += node ? node.length : 1;\n        }\n        return this.nodes;\n    }\n    // Always called with a region that on both sides either stretches\n    // to a line break or the end of the document.\n    // The returned array uses null to indicate line breaks, but never\n    // starts or ends in a line break, or has multiple line breaks next\n    // to each other.\n    static build(oracle, decorations, from, to) {\n        let builder = new NodeBuilder(from, oracle);\n        _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(decorations, from, to, builder, 0);\n        return builder.finish(from);\n    }\n}\nfunction heightRelevantDecoChanges(a, b, diff) {\n    let comp = new DecorationComparator;\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.compare(a, b, diff, comp, 0);\n    return comp.changes;\n}\nclass DecorationComparator {\n    constructor(){\n        this.changes = [];\n    }\n    compareRange() {}\n    comparePoint(from, to, a, b) {\n        if (from < to || a && a.heightRelevant || b && b.heightRelevant) addRange(from, to, this.changes, 5);\n    }\n}\nfunction visiblePixelRange(dom, paddingTop) {\n    let rect = dom.getBoundingClientRect();\n    let doc = dom.ownerDocument, win = doc.defaultView || window;\n    let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);\n    let top = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);\n    for(let parent = dom.parentNode; parent && parent != doc.body;){\n        if (parent.nodeType == 1) {\n            let elt = parent;\n            let style = window.getComputedStyle(elt);\n            if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != \"visible\") {\n                let parentRect = elt.getBoundingClientRect();\n                left = Math.max(left, parentRect.left);\n                right = Math.min(right, parentRect.right);\n                top = Math.max(top, parentRect.top);\n                bottom = parent == dom.parentNode ? parentRect.bottom : Math.min(bottom, parentRect.bottom);\n            }\n            parent = style.position == \"absolute\" || style.position == \"fixed\" ? elt.offsetParent : elt.parentNode;\n        } else if (parent.nodeType == 11) {\n            parent = parent.host;\n        } else {\n            break;\n        }\n    }\n    return {\n        left: left - rect.left,\n        right: Math.max(left, right) - rect.left,\n        top: top - (rect.top + paddingTop),\n        bottom: Math.max(top, bottom) - (rect.top + paddingTop)\n    };\n}\nfunction fullPixelRange(dom, paddingTop) {\n    let rect = dom.getBoundingClientRect();\n    return {\n        left: 0,\n        right: rect.right - rect.left,\n        top: paddingTop,\n        bottom: rect.bottom - (rect.top + paddingTop)\n    };\n}\n// Line gaps are placeholder widgets used to hide pieces of overlong\n// lines within the viewport, as a kludge to keep the editor\n// responsive when a ridiculously long line is loaded into it.\nclass LineGap {\n    constructor(from, to, size){\n        this.from = from;\n        this.to = to;\n        this.size = size;\n    }\n    static same(a, b) {\n        if (a.length != b.length) return false;\n        for(let i = 0; i < a.length; i++){\n            let gA = a[i], gB = b[i];\n            if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size) return false;\n        }\n        return true;\n    }\n    draw(viewState, wrapping) {\n        return Decoration.replace({\n            widget: new LineGapWidget(this.size * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)\n        }).range(this.from, this.to);\n    }\n}\nclass LineGapWidget extends WidgetType {\n    constructor(size, vertical){\n        super();\n        this.size = size;\n        this.vertical = vertical;\n    }\n    eq(other) {\n        return other.size == this.size && other.vertical == this.vertical;\n    }\n    toDOM() {\n        let elt = document.createElement(\"div\");\n        if (this.vertical) {\n            elt.style.height = this.size + \"px\";\n        } else {\n            elt.style.width = this.size + \"px\";\n            elt.style.height = \"2px\";\n            elt.style.display = \"inline-block\";\n        }\n        return elt;\n    }\n    get estimatedHeight() {\n        return this.vertical ? this.size : -1;\n    }\n}\nclass ViewState {\n    constructor(state){\n        this.state = state;\n        // These are contentDOM-local coordinates\n        this.pixelViewport = {\n            left: 0,\n            right: window.innerWidth,\n            top: 0,\n            bottom: 0\n        };\n        this.inView = true;\n        this.paddingTop = 0; // Padding above the document, scaled\n        this.paddingBottom = 0; // Padding below the document, scaled\n        this.contentDOMWidth = 0; // contentDOM.getBoundingClientRect().width\n        this.contentDOMHeight = 0; // contentDOM.getBoundingClientRect().height\n        this.editorHeight = 0; // scrollDOM.clientHeight, unscaled\n        this.editorWidth = 0; // scrollDOM.clientWidth, unscaled\n        this.scrollTop = 0; // Last seen scrollDOM.scrollTop, scaled\n        this.scrolledToBottom = true;\n        // The CSS-transformation scale of the editor (transformed size /\n        // concrete size)\n        this.scaleX = 1;\n        this.scaleY = 1;\n        // The vertical position (document-relative) to which to anchor the\n        // scroll position. -1 means anchor to the end of the document.\n        this.scrollAnchorPos = 0;\n        // The height at the anchor position. Set by the DOM update phase.\n        // -1 means no height available.\n        this.scrollAnchorHeight = -1;\n        // See VP.MaxDOMHeight\n        this.scaler = IdScaler;\n        this.scrollTarget = null;\n        // Briefly set to true when printing, to disable viewport limiting\n        this.printing = false;\n        // Flag set when editor content was redrawn, so that the next\n        // measure stage knows it must read DOM layout\n        this.mustMeasureContent = true;\n        this.defaultTextDirection = Direction.LTR;\n        this.visibleRanges = [];\n        // Cursor 'assoc' is only significant when the cursor is on a line\n        // wrap point, where it must stick to the character that it is\n        // associated with. Since browsers don't provide a reasonable\n        // interface to set or query this, when a selection is set that\n        // might cause this to be significant, this flag is set. The next\n        // measure phase will check whether the cursor is on a line-wrapping\n        // boundary and, if so, reset it to make sure it is positioned in\n        // the right place.\n        this.mustEnforceCursorAssoc = false;\n        let guessWrapping = state.facet(contentAttributes).some((v)=>typeof v != \"function\" && v.class == \"cm-lineWrapping\");\n        this.heightOracle = new HeightOracle(guessWrapping);\n        this.stateDeco = state.facet(decorations).filter((d)=>typeof d != \"function\");\n        this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty, this.heightOracle.setDoc(state.doc), [\n            new ChangedRange(0, 0, 0, state.doc.length)\n        ]);\n        this.viewport = this.getViewport(0, null);\n        this.updateViewportLines();\n        this.updateForViewport();\n        this.lineGaps = this.ensureLineGaps([]);\n        this.lineGapDeco = Decoration.set(this.lineGaps.map((gap)=>gap.draw(this, false)));\n        this.computeVisibleRanges();\n    }\n    updateForViewport() {\n        let viewports = [\n            this.viewport\n        ], { main } = this.state.selection;\n        for(let i = 0; i <= 1; i++){\n            let pos = i ? main.head : main.anchor;\n            if (!viewports.some(({ from, to })=>pos >= from && pos <= to)) {\n                let { from, to } = this.lineBlockAt(pos);\n                viewports.push(new Viewport(from, to));\n            }\n        }\n        this.viewports = viewports.sort((a, b)=>a.from - b.from);\n        this.scaler = this.heightMap.height <= 7000000 /* VP.MaxDOMHeight */  ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports);\n    }\n    updateViewportLines() {\n        this.viewportLines = [];\n        this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (block)=>{\n            this.viewportLines.push(this.scaler.scale == 1 ? block : scaleBlock(block, this.scaler));\n        });\n    }\n    update(update, scrollTarget = null) {\n        this.state = update.state;\n        let prevDeco = this.stateDeco;\n        this.stateDeco = this.state.facet(decorations).filter((d)=>typeof d != \"function\");\n        let contentChanges = update.changedRanges;\n        let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.ChangeSet.empty(this.state.doc.length)));\n        let prevHeight = this.heightMap.height;\n        let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);\n        this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);\n        if (this.heightMap.height != prevHeight) update.flags |= 2 /* UpdateFlag.Height */ ;\n        if (scrollAnchor) {\n            this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);\n            this.scrollAnchorHeight = scrollAnchor.top;\n        } else {\n            this.scrollAnchorPos = -1;\n            this.scrollAnchorHeight = this.heightMap.height;\n        }\n        let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;\n        if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport)) viewport = this.getViewport(0, scrollTarget);\n        let updateLines = !update.changes.empty || update.flags & 2 /* UpdateFlag.Height */  || viewport.from != this.viewport.from || viewport.to != this.viewport.to;\n        this.viewport = viewport;\n        this.updateForViewport();\n        if (updateLines) this.updateViewportLines();\n        if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2000 /* LG.Margin */  << 1) this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));\n        update.flags |= this.computeVisibleRanges();\n        if (scrollTarget) this.scrollTarget = scrollTarget;\n        if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc && !update.state.facet(nativeSelectionHidden)) this.mustEnforceCursorAssoc = true;\n    }\n    measure(view) {\n        let dom = view.contentDOM, style = window.getComputedStyle(dom);\n        let oracle = this.heightOracle;\n        let whiteSpace = style.whiteSpace;\n        this.defaultTextDirection = style.direction == \"rtl\" ? Direction.RTL : Direction.LTR;\n        let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);\n        let domRect = dom.getBoundingClientRect();\n        let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;\n        this.contentDOMHeight = domRect.height;\n        this.mustMeasureContent = false;\n        let result = 0, bias = 0;\n        if (domRect.width && domRect.height) {\n            let { scaleX, scaleY } = getScale(dom, domRect);\n            if (this.scaleX != scaleX || this.scaleY != scaleY) {\n                this.scaleX = scaleX;\n                this.scaleY = scaleY;\n                result |= 8 /* UpdateFlag.Geometry */ ;\n                refresh = measureContent = true;\n            }\n        }\n        // Vertical padding\n        let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;\n        let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;\n        if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {\n            this.paddingTop = paddingTop;\n            this.paddingBottom = paddingBottom;\n            result |= 8 /* UpdateFlag.Geometry */  | 2 /* UpdateFlag.Height */ ;\n        }\n        if (this.editorWidth != view.scrollDOM.clientWidth) {\n            if (oracle.lineWrapping) measureContent = true;\n            this.editorWidth = view.scrollDOM.clientWidth;\n            result |= 8 /* UpdateFlag.Geometry */ ;\n        }\n        let scrollTop = view.scrollDOM.scrollTop * this.scaleY;\n        if (this.scrollTop != scrollTop) {\n            this.scrollAnchorHeight = -1;\n            this.scrollTop = scrollTop;\n        }\n        this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);\n        // Pixel viewport\n        let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);\n        let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;\n        this.pixelViewport = pixelViewport;\n        let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;\n        if (inView != this.inView) {\n            this.inView = inView;\n            if (inView) measureContent = true;\n        }\n        if (!this.inView && !this.scrollTarget) return 0;\n        let contentWidth = domRect.width;\n        if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {\n            this.contentDOMWidth = domRect.width;\n            this.editorHeight = view.scrollDOM.clientHeight;\n            result |= 8 /* UpdateFlag.Geometry */ ;\n        }\n        if (measureContent) {\n            let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);\n            if (oracle.mustRefreshForHeights(lineHeights)) refresh = true;\n            if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {\n                let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize();\n                refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, contentWidth / charWidth, lineHeights);\n                if (refresh) {\n                    view.docView.minWidth = 0;\n                    result |= 8 /* UpdateFlag.Geometry */ ;\n                }\n            }\n            if (dTop > 0 && dBottom > 0) bias = Math.max(dTop, dBottom);\n            else if (dTop < 0 && dBottom < 0) bias = Math.min(dTop, dBottom);\n            oracle.heightChanged = false;\n            for (let vp of this.viewports){\n                let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);\n                this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty, this.heightOracle, [\n                    new ChangedRange(0, 0, 0, view.state.doc.length)\n                ]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));\n            }\n            if (oracle.heightChanged) result |= 2 /* UpdateFlag.Height */ ;\n        }\n        let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);\n        if (viewportChange) this.viewport = this.getViewport(bias, this.scrollTarget);\n        this.updateForViewport();\n        if (result & 2 /* UpdateFlag.Height */  || viewportChange) this.updateViewportLines();\n        if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2000 /* LG.Margin */  << 1) this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));\n        result |= this.computeVisibleRanges();\n        if (this.mustEnforceCursorAssoc) {\n            this.mustEnforceCursorAssoc = false;\n            // This is done in the read stage, because moving the selection\n            // to a line end is going to trigger a layout anyway, so it\n            // can't be a pure write. It should be rare that it does any\n            // writing.\n            view.docView.enforceCursorAssoc();\n        }\n        return result;\n    }\n    get visibleTop() {\n        return this.scaler.fromDOM(this.pixelViewport.top);\n    }\n    get visibleBottom() {\n        return this.scaler.fromDOM(this.pixelViewport.bottom);\n    }\n    getViewport(bias, scrollTarget) {\n        // This will divide VP.Margin between the top and the\n        // bottom, depending on the bias (the change in viewport position\n        // since the last update). It'll hold a number between 0 and 1\n        let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000 /* VP.Margin */  / 2));\n        let map = this.heightMap, oracle = this.heightOracle;\n        let { visibleTop, visibleBottom } = this;\n        let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1000 /* VP.Margin */ , QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1000 /* VP.Margin */ , QueryType.ByHeight, oracle, 0, 0).to);\n        // If scrollTarget is given, make sure the viewport includes that position\n        if (scrollTarget) {\n            let { head } = scrollTarget.range;\n            if (head < viewport.from || head > viewport.to) {\n                let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);\n                let block = map.lineAt(head, QueryType.ByPos, oracle, 0, 0), topPos;\n                if (scrollTarget.y == \"center\") topPos = (block.top + block.bottom) / 2 - viewHeight / 2;\n                else if (scrollTarget.y == \"start\" || scrollTarget.y == \"nearest\" && head < viewport.from) topPos = block.top;\n                else topPos = block.bottom - viewHeight;\n                viewport = new Viewport(map.lineAt(topPos - 1000 /* VP.Margin */  / 2, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(topPos + viewHeight + 1000 /* VP.Margin */  / 2, QueryType.ByHeight, oracle, 0, 0).to);\n            }\n        }\n        return viewport;\n    }\n    mapViewport(viewport, changes) {\n        let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);\n        return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0).to);\n    }\n    // Checks if a given viewport covers the visible part of the\n    // document and not too much beyond that.\n    viewportIsAppropriate({ from, to }, bias = 0) {\n        if (!this.inView) return true;\n        let { top } = this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0);\n        let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0);\n        let { visibleTop, visibleBottom } = this;\n        return (from == 0 || top <= visibleTop - Math.max(10 /* VP.MinCoverMargin */ , Math.min(-bias, 250 /* VP.MaxCoverMargin */ ))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10 /* VP.MinCoverMargin */ , Math.min(bias, 250 /* VP.MaxCoverMargin */ ))) && top > visibleTop - 2 * 1000 /* VP.Margin */  && bottom < visibleBottom + 2 * 1000 /* VP.Margin */ ;\n    }\n    mapLineGaps(gaps, changes) {\n        if (!gaps.length || changes.empty) return gaps;\n        let mapped = [];\n        for (let gap of gaps)if (!changes.touchesRange(gap.from, gap.to)) mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));\n        return mapped;\n    }\n    // Computes positions in the viewport where the start or end of a\n    // line should be hidden, trying to reuse existing line gaps when\n    // appropriate to avoid unneccesary redraws.\n    // Uses crude character-counting for the positioning and sizing,\n    // since actual DOM coordinates aren't always available and\n    // predictable. Relies on generous margins (see LG.Margin) to hide\n    // the artifacts this might produce from the user.\n    ensureLineGaps(current, mayMeasure) {\n        let wrapping = this.heightOracle.lineWrapping;\n        let margin = wrapping ? 10000 /* LG.MarginWrap */  : 2000 /* LG.Margin */ , halfMargin = margin >> 1, doubleMargin = margin << 1;\n        // The non-wrapping logic won't work at all in predominantly right-to-left text.\n        if (this.defaultTextDirection != Direction.LTR && !wrapping) return [];\n        let gaps = [];\n        let addGap = (from, to, line, structure)=>{\n            if (to - from < halfMargin) return;\n            let sel = this.state.selection.main, avoid = [\n                sel.from\n            ];\n            if (!sel.empty) avoid.push(sel.to);\n            for (let pos of avoid){\n                if (pos > from && pos < to) {\n                    addGap(from, pos - 10 /* LG.SelectionMargin */ , line, structure);\n                    addGap(pos + 10 /* LG.SelectionMargin */ , to, line, structure);\n                    return;\n                }\n            }\n            let gap = find(current, (gap)=>gap.from >= line.from && gap.to <= line.to && Math.abs(gap.from - from) < halfMargin && Math.abs(gap.to - to) < halfMargin && !avoid.some((pos)=>gap.from < pos && gap.to > pos));\n            if (!gap) {\n                // When scrolling down, snap gap ends to line starts to avoid shifts in wrapping\n                if (to < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r)=>r.from <= to && r.to >= to)) {\n                    let lineStart = mayMeasure.moveToLineBoundary(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(to), false, true).head;\n                    if (lineStart > from) to = lineStart;\n                }\n                gap = new LineGap(from, to, this.gapSize(line, from, to, structure));\n            }\n            gaps.push(gap);\n        };\n        for (let line of this.viewportLines){\n            if (line.length < doubleMargin) continue;\n            let structure = lineStructure(line.from, line.to, this.stateDeco);\n            if (structure.total < doubleMargin) continue;\n            let target = this.scrollTarget ? this.scrollTarget.range.head : null;\n            let viewFrom, viewTo;\n            if (wrapping) {\n                let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;\n                let top, bot;\n                if (target != null) {\n                    let targetFrac = findFraction(structure, target);\n                    let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;\n                    top = targetFrac - spaceFrac;\n                    bot = targetFrac + spaceFrac;\n                } else {\n                    top = (this.visibleTop - line.top - marginHeight) / line.height;\n                    bot = (this.visibleBottom - line.top + marginHeight) / line.height;\n                }\n                viewFrom = findPosition(structure, top);\n                viewTo = findPosition(structure, bot);\n            } else {\n                let totalWidth = structure.total * this.heightOracle.charWidth;\n                let marginWidth = margin * this.heightOracle.charWidth;\n                let left, right;\n                if (target != null) {\n                    let targetFrac = findFraction(structure, target);\n                    let spaceFrac = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + marginWidth) / totalWidth;\n                    left = targetFrac - spaceFrac;\n                    right = targetFrac + spaceFrac;\n                } else {\n                    left = (this.pixelViewport.left - marginWidth) / totalWidth;\n                    right = (this.pixelViewport.right + marginWidth) / totalWidth;\n                }\n                viewFrom = findPosition(structure, left);\n                viewTo = findPosition(structure, right);\n            }\n            if (viewFrom > line.from) addGap(line.from, viewFrom, line, structure);\n            if (viewTo < line.to) addGap(viewTo, line.to, line, structure);\n        }\n        return gaps;\n    }\n    gapSize(line, from, to, structure) {\n        let fraction = findFraction(structure, to) - findFraction(structure, from);\n        if (this.heightOracle.lineWrapping) {\n            return line.height * fraction;\n        } else {\n            return structure.total * this.heightOracle.charWidth * fraction;\n        }\n    }\n    updateLineGaps(gaps) {\n        if (!LineGap.same(gaps, this.lineGaps)) {\n            this.lineGaps = gaps;\n            this.lineGapDeco = Decoration.set(gaps.map((gap)=>gap.draw(this, this.heightOracle.lineWrapping)));\n        }\n    }\n    computeVisibleRanges() {\n        let deco = this.stateDeco;\n        if (this.lineGaps.length) deco = deco.concat(this.lineGapDeco);\n        let ranges = [];\n        _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(deco, this.viewport.from, this.viewport.to, {\n            span (from, to) {\n                ranges.push({\n                    from,\n                    to\n                });\n            },\n            point () {}\n        }, 20);\n        let changed = ranges.length != this.visibleRanges.length || this.visibleRanges.some((r, i)=>r.from != ranges[i].from || r.to != ranges[i].to);\n        this.visibleRanges = ranges;\n        return changed ? 4 /* UpdateFlag.Viewport */  : 0;\n    }\n    lineBlockAt(pos) {\n        return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b)=>b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);\n    }\n    lineBlockAtHeight(height) {\n        return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);\n    }\n    scrollAnchorAt(scrollTop) {\n        let block = this.lineBlockAtHeight(scrollTop + 8);\n        return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];\n    }\n    elementAtHeight(height) {\n        return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);\n    }\n    get docHeight() {\n        return this.scaler.toDOM(this.heightMap.height);\n    }\n    get contentHeight() {\n        return this.docHeight + this.paddingTop + this.paddingBottom;\n    }\n}\nclass Viewport {\n    constructor(from, to){\n        this.from = from;\n        this.to = to;\n    }\n}\nfunction lineStructure(from, to, stateDeco) {\n    let ranges = [], pos = from, total = 0;\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(stateDeco, from, to, {\n        span () {},\n        point (from, to) {\n            if (from > pos) {\n                ranges.push({\n                    from: pos,\n                    to: from\n                });\n                total += from - pos;\n            }\n            pos = to;\n        }\n    }, 20); // We're only interested in collapsed ranges of a significant size\n    if (pos < to) {\n        ranges.push({\n            from: pos,\n            to\n        });\n        total += to - pos;\n    }\n    return {\n        total,\n        ranges\n    };\n}\nfunction findPosition({ total, ranges }, ratio) {\n    if (ratio <= 0) return ranges[0].from;\n    if (ratio >= 1) return ranges[ranges.length - 1].to;\n    let dist = Math.floor(total * ratio);\n    for(let i = 0;; i++){\n        let { from, to } = ranges[i], size = to - from;\n        if (dist <= size) return from + dist;\n        dist -= size;\n    }\n}\nfunction findFraction(structure, pos) {\n    let counted = 0;\n    for (let { from, to } of structure.ranges){\n        if (pos <= to) {\n            counted += pos - from;\n            break;\n        }\n        counted += to - from;\n    }\n    return counted / structure.total;\n}\nfunction find(array, f) {\n    for (let val of array)if (f(val)) return val;\n    return undefined;\n}\n// Don't scale when the document height is within the range of what\n// the DOM can handle.\nconst IdScaler = {\n    toDOM (n) {\n        return n;\n    },\n    fromDOM (n) {\n        return n;\n    },\n    scale: 1\n};\n// When the height is too big (> VP.MaxDOMHeight), scale down the\n// regions outside the viewports so that the total height is\n// VP.MaxDOMHeight.\nclass BigScaler {\n    constructor(oracle, heightMap, viewports){\n        let vpHeight = 0, base = 0, domBase = 0;\n        this.viewports = viewports.map(({ from, to })=>{\n            let top = heightMap.lineAt(from, QueryType.ByPos, oracle, 0, 0).top;\n            let bottom = heightMap.lineAt(to, QueryType.ByPos, oracle, 0, 0).bottom;\n            vpHeight += bottom - top;\n            return {\n                from,\n                to,\n                top,\n                bottom,\n                domTop: 0,\n                domBottom: 0\n            };\n        });\n        this.scale = (7000000 /* VP.MaxDOMHeight */  - vpHeight) / (heightMap.height - vpHeight);\n        for (let obj of this.viewports){\n            obj.domTop = domBase + (obj.top - base) * this.scale;\n            domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);\n            base = obj.bottom;\n        }\n    }\n    toDOM(n) {\n        for(let i = 0, base = 0, domBase = 0;; i++){\n            let vp = i < this.viewports.length ? this.viewports[i] : null;\n            if (!vp || n < vp.top) return domBase + (n - base) * this.scale;\n            if (n <= vp.bottom) return vp.domTop + (n - vp.top);\n            base = vp.bottom;\n            domBase = vp.domBottom;\n        }\n    }\n    fromDOM(n) {\n        for(let i = 0, base = 0, domBase = 0;; i++){\n            let vp = i < this.viewports.length ? this.viewports[i] : null;\n            if (!vp || n < vp.domTop) return base + (n - domBase) / this.scale;\n            if (n <= vp.domBottom) return vp.top + (n - vp.domTop);\n            base = vp.bottom;\n            domBase = vp.domBottom;\n        }\n    }\n}\nfunction scaleBlock(block, scaler) {\n    if (scaler.scale == 1) return block;\n    let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);\n    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map((b)=>scaleBlock(b, scaler)) : block._content);\n}\nconst theme = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (strs)=>strs.join(\" \")\n});\nconst darkTheme = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (values)=>values.indexOf(true) > -1\n});\nconst baseThemeID = /*@__PURE__*/ style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName(), baseLightID = /*@__PURE__*/ style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName(), baseDarkID = /*@__PURE__*/ style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName();\nconst lightDarkIDs = {\n    \"&light\": \".\" + baseLightID,\n    \"&dark\": \".\" + baseDarkID\n};\nfunction buildTheme(main, spec, scopes) {\n    return new style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule(spec, {\n        finish (sel) {\n            return /&/.test(sel) ? sel.replace(/&\\w*/, (m)=>{\n                if (m == \"&\") return main;\n                if (!scopes || !scopes[m]) throw new RangeError(`Unsupported selector: ${m}`);\n                return scopes[m];\n            }) : main + \" \" + sel;\n        }\n    });\n}\nconst baseTheme$1 = /*@__PURE__*/ buildTheme(\".\" + baseThemeID, {\n    \"&\": {\n        position: \"relative !important\",\n        boxSizing: \"border-box\",\n        \"&.cm-focused\": {\n            // Provide a simple default outline to make sure a focused\n            // editor is visually distinct. Can't leave the default behavior\n            // because that will apply to the content element, which is\n            // inside the scrollable container and doesn't include the\n            // gutters. We also can't use an 'auto' outline, since those\n            // are, for some reason, drawn behind the element content, which\n            // will cause things like the active line background to cover\n            // the outline (#297).\n            outline: \"1px dotted #212121\"\n        },\n        display: \"flex !important\",\n        flexDirection: \"column\"\n    },\n    \".cm-scroller\": {\n        display: \"flex !important\",\n        alignItems: \"flex-start !important\",\n        fontFamily: \"monospace\",\n        lineHeight: 1.4,\n        height: \"100%\",\n        overflowX: \"auto\",\n        position: \"relative\",\n        zIndex: 0\n    },\n    \".cm-content\": {\n        margin: 0,\n        flexGrow: 2,\n        flexShrink: 0,\n        display: \"block\",\n        whiteSpace: \"pre\",\n        wordWrap: \"normal\",\n        boxSizing: \"border-box\",\n        minHeight: \"100%\",\n        padding: \"4px 0\",\n        outline: \"none\",\n        \"&[contenteditable=true]\": {\n            WebkitUserModify: \"read-write-plaintext-only\"\n        }\n    },\n    \".cm-lineWrapping\": {\n        whiteSpace_fallback: \"pre-wrap\",\n        whiteSpace: \"break-spaces\",\n        wordBreak: \"break-word\",\n        overflowWrap: \"anywhere\",\n        flexShrink: 1\n    },\n    \"&light .cm-content\": {\n        caretColor: \"black\"\n    },\n    \"&dark .cm-content\": {\n        caretColor: \"white\"\n    },\n    \".cm-line\": {\n        display: \"block\",\n        padding: \"0 2px 0 6px\"\n    },\n    \".cm-layer\": {\n        position: \"absolute\",\n        left: 0,\n        top: 0,\n        contain: \"size style\",\n        \"& > *\": {\n            position: \"absolute\"\n        }\n    },\n    \"&light .cm-selectionBackground\": {\n        background: \"#d9d9d9\"\n    },\n    \"&dark .cm-selectionBackground\": {\n        background: \"#222\"\n    },\n    \"&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground\": {\n        background: \"#d7d4f0\"\n    },\n    \"&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground\": {\n        background: \"#233\"\n    },\n    \".cm-cursorLayer\": {\n        pointerEvents: \"none\"\n    },\n    \"&.cm-focused > .cm-scroller > .cm-cursorLayer\": {\n        animation: \"steps(1) cm-blink 1.2s infinite\"\n    },\n    // Two animations defined so that we can switch between them to\n    // restart the animation without forcing another style\n    // recomputation.\n    \"@keyframes cm-blink\": {\n        \"0%\": {},\n        \"50%\": {\n            opacity: 0\n        },\n        \"100%\": {}\n    },\n    \"@keyframes cm-blink2\": {\n        \"0%\": {},\n        \"50%\": {\n            opacity: 0\n        },\n        \"100%\": {}\n    },\n    \".cm-cursor, .cm-dropCursor\": {\n        borderLeft: \"1.2px solid black\",\n        marginLeft: \"-0.6px\",\n        pointerEvents: \"none\"\n    },\n    \".cm-cursor\": {\n        display: \"none\"\n    },\n    \"&dark .cm-cursor\": {\n        borderLeftColor: \"#444\"\n    },\n    \".cm-dropCursor\": {\n        position: \"absolute\"\n    },\n    \"&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor\": {\n        display: \"block\"\n    },\n    \".cm-iso\": {\n        unicodeBidi: \"isolate\"\n    },\n    \".cm-announced\": {\n        position: \"fixed\",\n        top: \"-10000px\"\n    },\n    \"@media print\": {\n        \".cm-announced\": {\n            display: \"none\"\n        }\n    },\n    \"&light .cm-activeLine\": {\n        backgroundColor: \"#cceeff44\"\n    },\n    \"&dark .cm-activeLine\": {\n        backgroundColor: \"#99eeff33\"\n    },\n    \"&light .cm-specialChar\": {\n        color: \"red\"\n    },\n    \"&dark .cm-specialChar\": {\n        color: \"#f78\"\n    },\n    \".cm-gutters\": {\n        flexShrink: 0,\n        display: \"flex\",\n        height: \"100%\",\n        boxSizing: \"border-box\",\n        insetInlineStart: 0,\n        zIndex: 200\n    },\n    \"&light .cm-gutters\": {\n        backgroundColor: \"#f5f5f5\",\n        color: \"#6c6c6c\",\n        borderRight: \"1px solid #ddd\"\n    },\n    \"&dark .cm-gutters\": {\n        backgroundColor: \"#333338\",\n        color: \"#ccc\"\n    },\n    \".cm-gutter\": {\n        display: \"flex !important\",\n        flexDirection: \"column\",\n        flexShrink: 0,\n        boxSizing: \"border-box\",\n        minHeight: \"100%\",\n        overflow: \"hidden\"\n    },\n    \".cm-gutterElement\": {\n        boxSizing: \"border-box\"\n    },\n    \".cm-lineNumbers .cm-gutterElement\": {\n        padding: \"0 3px 0 5px\",\n        minWidth: \"20px\",\n        textAlign: \"right\",\n        whiteSpace: \"nowrap\"\n    },\n    \"&light .cm-activeLineGutter\": {\n        backgroundColor: \"#e2f2ff\"\n    },\n    \"&dark .cm-activeLineGutter\": {\n        backgroundColor: \"#222227\"\n    },\n    \".cm-panels\": {\n        boxSizing: \"border-box\",\n        position: \"sticky\",\n        left: 0,\n        right: 0\n    },\n    \"&light .cm-panels\": {\n        backgroundColor: \"#f5f5f5\",\n        color: \"black\"\n    },\n    \"&light .cm-panels-top\": {\n        borderBottom: \"1px solid #ddd\"\n    },\n    \"&light .cm-panels-bottom\": {\n        borderTop: \"1px solid #ddd\"\n    },\n    \"&dark .cm-panels\": {\n        backgroundColor: \"#333338\",\n        color: \"white\"\n    },\n    \".cm-tab\": {\n        display: \"inline-block\",\n        overflow: \"hidden\",\n        verticalAlign: \"bottom\"\n    },\n    \".cm-widgetBuffer\": {\n        verticalAlign: \"text-top\",\n        height: \"1em\",\n        width: 0,\n        display: \"inline\"\n    },\n    \".cm-placeholder\": {\n        color: \"#888\",\n        display: \"inline-block\",\n        verticalAlign: \"top\"\n    },\n    \".cm-highlightSpace:before\": {\n        content: \"attr(data-display)\",\n        position: \"absolute\",\n        pointerEvents: \"none\",\n        color: \"#888\"\n    },\n    \".cm-highlightTab\": {\n        backgroundImage: `url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"200\" height=\"20\"><path stroke=\"%23888\" stroke-width=\"1\" fill=\"none\" d=\"M1 10H196L190 5M190 15L196 10M197 4L197 16\"/></svg>')`,\n        backgroundSize: \"auto 100%\",\n        backgroundPosition: \"right 90%\",\n        backgroundRepeat: \"no-repeat\"\n    },\n    \".cm-trailingSpace\": {\n        backgroundColor: \"#ff332255\"\n    },\n    \".cm-button\": {\n        verticalAlign: \"middle\",\n        color: \"inherit\",\n        fontSize: \"70%\",\n        padding: \".2em 1em\",\n        borderRadius: \"1px\"\n    },\n    \"&light .cm-button\": {\n        backgroundImage: \"linear-gradient(#eff1f5, #d9d9df)\",\n        border: \"1px solid #888\",\n        \"&:active\": {\n            backgroundImage: \"linear-gradient(#b4b4b4, #d0d3d6)\"\n        }\n    },\n    \"&dark .cm-button\": {\n        backgroundImage: \"linear-gradient(#393939, #111)\",\n        border: \"1px solid #888\",\n        \"&:active\": {\n            backgroundImage: \"linear-gradient(#111, #333)\"\n        }\n    },\n    \".cm-textfield\": {\n        verticalAlign: \"middle\",\n        color: \"inherit\",\n        fontSize: \"70%\",\n        border: \"1px solid silver\",\n        padding: \".2em .5em\"\n    },\n    \"&light .cm-textfield\": {\n        backgroundColor: \"white\"\n    },\n    \"&dark .cm-textfield\": {\n        border: \"1px solid #555\",\n        backgroundColor: \"inherit\"\n    }\n}, lightDarkIDs);\nconst LineBreakPlaceholder = \"￿\";\nclass DOMReader {\n    constructor(points, state){\n        this.points = points;\n        this.text = \"\";\n        this.lineSeparator = state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.lineSeparator);\n    }\n    append(text) {\n        this.text += text;\n    }\n    lineBreak() {\n        this.text += LineBreakPlaceholder;\n    }\n    readRange(start, end) {\n        if (!start) return this;\n        let parent = start.parentNode;\n        for(let cur = start;;){\n            this.findPointBefore(parent, cur);\n            let oldLen = this.text.length;\n            this.readNode(cur);\n            let next = cur.nextSibling;\n            if (next == end) break;\n            let view = ContentView.get(cur), nextView = ContentView.get(next);\n            if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur)) || isBlockElement(next) && (cur.nodeName != \"BR\" || cur.cmIgnore) && this.text.length > oldLen) this.lineBreak();\n            cur = next;\n        }\n        this.findPointBefore(parent, end);\n        return this;\n    }\n    readTextNode(node) {\n        let text = node.nodeValue;\n        for (let point of this.points)if (point.node == node) point.pos = this.text.length + Math.min(point.offset, text.length);\n        for(let off = 0, re = this.lineSeparator ? null : /\\r\\n?|\\n/g;;){\n            let nextBreak = -1, breakSize = 1, m;\n            if (this.lineSeparator) {\n                nextBreak = text.indexOf(this.lineSeparator, off);\n                breakSize = this.lineSeparator.length;\n            } else if (m = re.exec(text)) {\n                nextBreak = m.index;\n                breakSize = m[0].length;\n            }\n            this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));\n            if (nextBreak < 0) break;\n            this.lineBreak();\n            if (breakSize > 1) {\n                for (let point of this.points)if (point.node == node && point.pos > this.text.length) point.pos -= breakSize - 1;\n            }\n            off = nextBreak + breakSize;\n        }\n    }\n    readNode(node) {\n        if (node.cmIgnore) return;\n        let view = ContentView.get(node);\n        let fromView = view && view.overrideDOMText;\n        if (fromView != null) {\n            this.findPointInside(node, fromView.length);\n            for(let i = fromView.iter(); !i.next().done;){\n                if (i.lineBreak) this.lineBreak();\n                else this.append(i.value);\n            }\n        } else if (node.nodeType == 3) {\n            this.readTextNode(node);\n        } else if (node.nodeName == \"BR\") {\n            if (node.nextSibling) this.lineBreak();\n        } else if (node.nodeType == 1) {\n            this.readRange(node.firstChild, null);\n        }\n    }\n    findPointBefore(node, next) {\n        for (let point of this.points)if (point.node == node && node.childNodes[point.offset] == next) point.pos = this.text.length;\n    }\n    findPointInside(node, length) {\n        for (let point of this.points)if (node.nodeType == 3 ? point.node == node : node.contains(point.node)) point.pos = this.text.length + (isAtEnd(node, point.node, point.offset) ? length : 0);\n    }\n}\nfunction isAtEnd(parent, node, offset) {\n    for(;;){\n        if (!node || offset < maxOffset(node)) return false;\n        if (node == parent) return true;\n        offset = domIndex(node) + 1;\n        node = node.parentNode;\n    }\n}\nfunction isBlockElement(node) {\n    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\\d|SECTION|PRE)$/.test(node.nodeName);\n}\nclass DOMPoint {\n    constructor(node, offset){\n        this.node = node;\n        this.offset = offset;\n        this.pos = -1;\n    }\n}\nclass DOMChange {\n    constructor(view, start, end, typeOver){\n        this.typeOver = typeOver;\n        this.bounds = null;\n        this.text = \"\";\n        let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;\n        if (view.state.readOnly && start > -1) {\n            // Ignore changes when the editor is read-only\n            this.newSel = null;\n        } else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {\n            let selPoints = iHead || iAnchor ? [] : selectionPoints(view);\n            let reader = new DOMReader(selPoints, view.state);\n            reader.readRange(this.bounds.startDOM, this.bounds.endDOM);\n            this.text = reader.text;\n            this.newSel = selectionFromPoints(selPoints, this.bounds.from);\n        } else {\n            let domSel = view.observer.selectionRange;\n            let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);\n            let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);\n            // iOS will refuse to select the block gaps when doing select-all\n            let vp = view.viewport;\n            if (browser.ios && view.state.selection.main.empty && head != anchor && (vp.from > 0 || vp.to < view.state.doc.length)) {\n                let offFrom = vp.from - Math.min(head, anchor), offTo = vp.to - Math.max(head, anchor);\n                if ((offFrom == 0 || offFrom == 1) && (offTo == 0 || offTo == -1)) {\n                    head = 0;\n                    anchor = view.state.doc.length;\n                }\n            }\n            this.newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(anchor, head);\n        }\n    }\n}\nfunction applyDOMChange(view, domChange) {\n    let change;\n    let { newSel } = domChange, sel = view.state.selection.main;\n    let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;\n    if (domChange.bounds) {\n        let { from, to } = domChange.bounds;\n        let preferredPos = sel.from, preferredSide = null;\n        // Prefer anchoring to end when Backspace is pressed (or, on\n        // Android, when something was deleted)\n        if (lastKey === 8 || browser.android && domChange.text.length < to - from) {\n            preferredPos = sel.to;\n            preferredSide = \"end\";\n        }\n        let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);\n        if (diff) {\n            // Chrome inserts two newlines when pressing shift-enter at the\n            // end of a line. DomChange drops one of those.\n            if (browser.chrome && lastKey == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder) diff.toB--;\n            change = {\n                from: from + diff.from,\n                to: from + diff.toA,\n                insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))\n            };\n        }\n    } else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {\n        newSel = null;\n    }\n    if (!change && !newSel) return false;\n    if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {\n        // Heuristic to notice typing over a selected character\n        change = {\n            from: sel.from,\n            to: sel.to,\n            insert: view.state.doc.slice(sel.from, sel.to)\n        };\n    } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {\n        // If the change is inside the selection and covers most of it,\n        // assume it is a selection replace (with identical characters at\n        // the start/end not included in the diff)\n        change = {\n            from: sel.from,\n            to: sel.to,\n            insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))\n        };\n    } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute(\"autocorrect\") == \"off\") {\n        // Detect insert-period-on-double-space Mac and Android behavior,\n        // and transform it into a regular space insert.\n        if (newSel && change.insert.length == 2) newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);\n        change = {\n            from: sel.from,\n            to: sel.to,\n            insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.of([\n                \" \"\n            ])\n        };\n    } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == \"\\n \" && view.lineWrapping) {\n        // In Chrome, if you insert a space at the start of a wrapped\n        // line, it will actually insert a newline and a space, causing a\n        // bogus new line to be created in CodeMirror (#968)\n        if (newSel) newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);\n        change = {\n            from: sel.from,\n            to: sel.to,\n            insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.of([\n                \" \"\n            ])\n        };\n    }\n    if (change) {\n        if (browser.ios && view.inputState.flushIOSKey()) return true;\n        // Android browsers don't fire reasonable key events for enter,\n        // backspace, or delete. So this detects changes that look like\n        // they're caused by those keys, and reinterprets them as key\n        // events. (Some of these keys are also handled by beforeinput\n        // events and the pendingAndroidKey mechanism, but that's not\n        // reliable in all situations.)\n        if (browser.android && (change.from == sel.from && change.to == sel.to && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, \"Enter\", 13) || (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 || lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) && dispatchKey(view.contentDOM, \"Backspace\", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, \"Delete\", 46))) return true;\n        let text = change.insert.toString();\n        if (view.inputState.composing >= 0) view.inputState.composing++;\n        let defaultTr;\n        let defaultInsert = ()=>defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));\n        if (!view.state.facet(inputHandler).some((h)=>h(view, change.from, change.to, text, defaultInsert))) view.dispatch(defaultInsert());\n        return true;\n    } else if (newSel && !newSel.main.eq(sel)) {\n        let scrollIntoView = false, userEvent = \"select\";\n        if (view.inputState.lastSelectionTime > Date.now() - 50) {\n            if (view.inputState.lastSelectionOrigin == \"select\") scrollIntoView = true;\n            userEvent = view.inputState.lastSelectionOrigin;\n        }\n        view.dispatch({\n            selection: newSel,\n            scrollIntoView,\n            userEvent\n        });\n        return true;\n    } else {\n        return false;\n    }\n}\nfunction applyDefaultInsert(view, change, newSel) {\n    let tr, startState = view.state, sel = startState.selection.main;\n    if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {\n        let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : \"\";\n        let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : \"\";\n        tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, undefined, view.state.lineBreak) + after));\n    } else {\n        let changes = startState.changes(change);\n        let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : undefined;\n        // Try to apply a composition change to all cursors\n        if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {\n            let replaced = view.state.sliceDoc(change.from, change.to);\n            let compositionRange, composition = newSel && findCompositionNode(view, newSel.main.head);\n            if (composition) {\n                let dLen = change.insert.length - (change.to - change.from);\n                compositionRange = {\n                    from: composition.from,\n                    to: composition.to - dLen\n                };\n            } else {\n                compositionRange = view.state.doc.lineAt(sel.head);\n            }\n            let offset = sel.to - change.to, size = sel.to - sel.from;\n            tr = startState.changeByRange((range)=>{\n                if (range.from == sel.from && range.to == sel.to) return {\n                    changes,\n                    range: mainSel || range.map(changes)\n                };\n                let to = range.to - offset, from = to - replaced.length;\n                if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced || // Unfortunately, there's no way to make multiple\n                // changes in the same node work without aborting\n                // composition, so cursors in the composition range are\n                // ignored.\n                range.to >= compositionRange.from && range.from <= compositionRange.to) return {\n                    range\n                };\n                let rangeChanges = startState.changes({\n                    from,\n                    to,\n                    insert: change.insert\n                }), selOff = range.to - sel.to;\n                return {\n                    changes: rangeChanges,\n                    range: !mainSel ? range.map(rangeChanges) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))\n                };\n            });\n        } else {\n            tr = {\n                changes,\n                selection: mainSel && startState.selection.replaceRange(mainSel)\n            };\n        }\n    }\n    let userEvent = \"input.type\";\n    if (view.composing || view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {\n        view.inputState.compositionPendingChange = false;\n        userEvent += \".compose\";\n        if (view.inputState.compositionFirstChange) {\n            userEvent += \".start\";\n            view.inputState.compositionFirstChange = false;\n        }\n    }\n    return startState.update(tr, {\n        userEvent,\n        scrollIntoView: true\n    });\n}\nfunction findDiff(a, b, preferredPos, preferredSide) {\n    let minLen = Math.min(a.length, b.length);\n    let from = 0;\n    while(from < minLen && a.charCodeAt(from) == b.charCodeAt(from))from++;\n    if (from == minLen && a.length == b.length) return null;\n    let toA = a.length, toB = b.length;\n    while(toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)){\n        toA--;\n        toB--;\n    }\n    if (preferredSide == \"end\") {\n        let adjust = Math.max(0, from - Math.min(toA, toB));\n        preferredPos -= toA + adjust - from;\n    }\n    if (toA < from && a.length < b.length) {\n        let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;\n        from -= move;\n        toB = from + (toB - toA);\n        toA = from;\n    } else if (toB < from) {\n        let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;\n        from -= move;\n        toA = from + (toA - toB);\n        toB = from;\n    }\n    return {\n        from,\n        toA,\n        toB\n    };\n}\nfunction selectionPoints(view) {\n    let result = [];\n    if (view.root.activeElement != view.contentDOM) return result;\n    let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;\n    if (anchorNode) {\n        result.push(new DOMPoint(anchorNode, anchorOffset));\n        if (focusNode != anchorNode || focusOffset != anchorOffset) result.push(new DOMPoint(focusNode, focusOffset));\n    }\n    return result;\n}\nfunction selectionFromPoints(points, base) {\n    if (points.length == 0) return null;\n    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;\n    return anchor > -1 && head > -1 ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(anchor + base, head + base) : null;\n}\nconst observeOptions = {\n    childList: true,\n    characterData: true,\n    subtree: true,\n    attributes: true,\n    characterDataOldValue: true\n};\n// IE11 has very broken mutation observers, so we also listen to\n// DOMCharacterDataModified there\nconst useCharData = browser.ie && browser.ie_version <= 11;\nclass DOMObserver {\n    constructor(view){\n        this.view = view;\n        this.active = false;\n        // The known selection. Kept in our own object, as opposed to just\n        // directly accessing the selection because:\n        //  - Safari doesn't report the right selection in shadow DOM\n        //  - Reading from the selection forces a DOM layout\n        //  - This way, we can ignore selectionchange events if we have\n        //    already seen the 'new' selection\n        this.selectionRange = new DOMSelectionState;\n        // Set when a selection change is detected, cleared on flush\n        this.selectionChanged = false;\n        this.delayedFlush = -1;\n        this.resizeTimeout = -1;\n        this.queue = [];\n        this.delayedAndroidKey = null;\n        this.flushingAndroidKey = -1;\n        this.lastChange = 0;\n        this.scrollTargets = [];\n        this.intersection = null;\n        this.resizeScroll = null;\n        this.intersecting = false;\n        this.gapIntersection = null;\n        this.gaps = [];\n        // Timeout for scheduling check of the parents that need scroll handlers\n        this.parentCheck = -1;\n        this.dom = view.contentDOM;\n        this.observer = new MutationObserver((mutations)=>{\n            for (let mut of mutations)this.queue.push(mut);\n            // IE11 will sometimes (on typing over a selection or\n            // backspacing out a single character text node) call the\n            // observer callback before actually updating the DOM.\n            //\n            // Unrelatedly, iOS Safari will, when ending a composition,\n            // sometimes first clear it, deliver the mutations, and then\n            // reinsert the finished text. CodeMirror's handling of the\n            // deletion will prevent the reinsertion from happening,\n            // breaking composition.\n            if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m)=>m.type == \"childList\" && m.removedNodes.length || m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length)) this.flushSoon();\n            else this.flush();\n        });\n        if (useCharData) this.onCharData = (event)=>{\n            this.queue.push({\n                target: event.target,\n                type: \"characterData\",\n                oldValue: event.prevValue\n            });\n            this.flushSoon();\n        };\n        this.onSelectionChange = this.onSelectionChange.bind(this);\n        this.onResize = this.onResize.bind(this);\n        this.onPrint = this.onPrint.bind(this);\n        this.onScroll = this.onScroll.bind(this);\n        if (typeof ResizeObserver == \"function\") {\n            this.resizeScroll = new ResizeObserver(()=>{\n                var _a;\n                if (((_a = this.view.docView) === null || _a === void 0 ? void 0 : _a.lastUpdate) < Date.now() - 75) this.onResize();\n            });\n            this.resizeScroll.observe(view.scrollDOM);\n        }\n        this.addWindowListeners(this.win = view.win);\n        this.start();\n        if (typeof IntersectionObserver == \"function\") {\n            this.intersection = new IntersectionObserver((entries)=>{\n                if (this.parentCheck < 0) this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1000);\n                if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {\n                    this.intersecting = !this.intersecting;\n                    if (this.intersecting != this.view.inView) this.onScrollChanged(document.createEvent(\"Event\"));\n                }\n            }, {\n                threshold: [\n                    0,\n                    .001\n                ]\n            });\n            this.intersection.observe(this.dom);\n            this.gapIntersection = new IntersectionObserver((entries)=>{\n                if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0) this.onScrollChanged(document.createEvent(\"Event\"));\n            }, {});\n        }\n        this.listenForScroll();\n        this.readSelectionRange();\n    }\n    onScrollChanged(e) {\n        this.view.inputState.runHandlers(\"scroll\", e);\n        if (this.intersecting) this.view.measure();\n    }\n    onScroll(e) {\n        if (this.intersecting) this.flush(false);\n        this.onScrollChanged(e);\n    }\n    onResize() {\n        if (this.resizeTimeout < 0) this.resizeTimeout = setTimeout(()=>{\n            this.resizeTimeout = -1;\n            this.view.requestMeasure();\n        }, 50);\n    }\n    onPrint() {\n        this.view.viewState.printing = true;\n        this.view.measure();\n        setTimeout(()=>{\n            this.view.viewState.printing = false;\n            this.view.requestMeasure();\n        }, 500);\n    }\n    updateGaps(gaps) {\n        if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i)=>g != gaps[i]))) {\n            this.gapIntersection.disconnect();\n            for (let gap of gaps)this.gapIntersection.observe(gap);\n            this.gaps = gaps;\n        }\n    }\n    onSelectionChange(event) {\n        let wasChanged = this.selectionChanged;\n        if (!this.readSelectionRange() || this.delayedAndroidKey) return;\n        let { view } = this, sel = this.selectionRange;\n        if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel)) return;\n        let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);\n        if (context && context.ignoreEvent(event)) {\n            if (!wasChanged) this.selectionChanged = false;\n            return;\n        }\n        // Deletions on IE11 fire their events in the wrong order, giving\n        // us a selection change event before the DOM changes are\n        // reported.\n        // Chrome Android has a similar issue when backspacing out a\n        // selection (#645).\n        if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)\n        sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) this.flushSoon();\n        else this.flush(false);\n    }\n    readSelectionRange() {\n        let { view } = this;\n        // The Selection object is broken in shadow roots in Safari. See\n        // https://github.com/codemirror/dev/issues/414\n        let range = browser.safari && view.root.nodeType == 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariSelectionRangeHack(this.view) || getSelection(view.root);\n        if (!range || this.selectionRange.eq(range)) return false;\n        let local = hasSelection(this.dom, range);\n        // Detect the situation where the browser has, on focus, moved the\n        // selection to the start of the content element. Reset it to the\n        // position from the editor state.\n        if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {\n            this.view.inputState.lastFocusTime = 0;\n            view.docView.updateSelection();\n            return false;\n        }\n        this.selectionRange.setRange(range);\n        if (local) this.selectionChanged = true;\n        return true;\n    }\n    setSelectionRange(anchor, head) {\n        this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);\n        this.selectionChanged = false;\n    }\n    clearSelectionRange() {\n        this.selectionRange.set(null, 0, null, 0);\n    }\n    listenForScroll() {\n        this.parentCheck = -1;\n        let i = 0, changed = null;\n        for(let dom = this.dom; dom;){\n            if (dom.nodeType == 1) {\n                if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom) i++;\n                else if (!changed) changed = this.scrollTargets.slice(0, i);\n                if (changed) changed.push(dom);\n                dom = dom.assignedSlot || dom.parentNode;\n            } else if (dom.nodeType == 11) {\n                dom = dom.host;\n            } else {\n                break;\n            }\n        }\n        if (i < this.scrollTargets.length && !changed) changed = this.scrollTargets.slice(0, i);\n        if (changed) {\n            for (let dom of this.scrollTargets)dom.removeEventListener(\"scroll\", this.onScroll);\n            for (let dom of this.scrollTargets = changed)dom.addEventListener(\"scroll\", this.onScroll);\n        }\n    }\n    ignore(f) {\n        if (!this.active) return f();\n        try {\n            this.stop();\n            return f();\n        } finally{\n            this.start();\n            this.clear();\n        }\n    }\n    start() {\n        if (this.active) return;\n        this.observer.observe(this.dom, observeOptions);\n        if (useCharData) this.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\n        this.active = true;\n    }\n    stop() {\n        if (!this.active) return;\n        this.active = false;\n        this.observer.disconnect();\n        if (useCharData) this.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\n    }\n    // Throw away any pending changes\n    clear() {\n        this.processRecords();\n        this.queue.length = 0;\n        this.selectionChanged = false;\n    }\n    // Chrome Android, especially in combination with GBoard, not only\n    // doesn't reliably fire regular key events, but also often\n    // surrounds the effect of enter or backspace with a bunch of\n    // composition events that, when interrupted, cause text duplication\n    // or other kinds of corruption. This hack makes the editor back off\n    // from handling DOM changes for a moment when such a key is\n    // detected (via beforeinput or keydown), and then tries to flush\n    // them or, if that has no effect, dispatches the given key.\n    delayAndroidKey(key, keyCode) {\n        var _a;\n        if (!this.delayedAndroidKey) {\n            let flush = ()=>{\n                let key = this.delayedAndroidKey;\n                if (key) {\n                    this.clearDelayedAndroidKey();\n                    this.view.inputState.lastKeyCode = key.keyCode;\n                    this.view.inputState.lastKeyTime = Date.now();\n                    let flushed = this.flush();\n                    if (!flushed && key.force) dispatchKey(this.dom, key.key, key.keyCode);\n                }\n            };\n            this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);\n        }\n        // Since backspace beforeinput is sometimes signalled spuriously,\n        // Enter always takes precedence.\n        if (!this.delayedAndroidKey || key == \"Enter\") this.delayedAndroidKey = {\n            key,\n            keyCode,\n            // Only run the key handler when no changes are detected if\n            // this isn't coming right after another change, in which case\n            // it is probably part of a weird chain of updates, and should\n            // be ignored if it returns the DOM to its previous state.\n            force: this.lastChange < Date.now() - 50 || !!((_a = this.delayedAndroidKey) === null || _a === void 0 ? void 0 : _a.force)\n        };\n    }\n    clearDelayedAndroidKey() {\n        this.win.cancelAnimationFrame(this.flushingAndroidKey);\n        this.delayedAndroidKey = null;\n        this.flushingAndroidKey = -1;\n    }\n    flushSoon() {\n        if (this.delayedFlush < 0) this.delayedFlush = this.view.win.requestAnimationFrame(()=>{\n            this.delayedFlush = -1;\n            this.flush();\n        });\n    }\n    forceFlush() {\n        if (this.delayedFlush >= 0) {\n            this.view.win.cancelAnimationFrame(this.delayedFlush);\n            this.delayedFlush = -1;\n        }\n        this.flush();\n    }\n    pendingRecords() {\n        for (let mut of this.observer.takeRecords())this.queue.push(mut);\n        return this.queue;\n    }\n    processRecords() {\n        let records = this.pendingRecords();\n        if (records.length) this.queue = [];\n        let from = -1, to = -1, typeOver = false;\n        for (let record of records){\n            let range = this.readMutation(record);\n            if (!range) continue;\n            if (range.typeOver) typeOver = true;\n            if (from == -1) {\n                ({ from, to } = range);\n            } else {\n                from = Math.min(range.from, from);\n                to = Math.max(range.to, to);\n            }\n        }\n        return {\n            from,\n            to,\n            typeOver\n        };\n    }\n    readChange() {\n        let { from, to, typeOver } = this.processRecords();\n        let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);\n        if (from < 0 && !newSel) return null;\n        if (from > -1) this.lastChange = Date.now();\n        this.view.inputState.lastFocusTime = 0;\n        this.selectionChanged = false;\n        let change = new DOMChange(this.view, from, to, typeOver);\n        this.view.docView.domChanged = {\n            newSel: change.newSel ? change.newSel.main : null\n        };\n        return change;\n    }\n    // Apply pending changes, if any\n    flush(readSelection = true) {\n        // Completely hold off flushing when pending keys are set—the code\n        // managing those will make sure processRecords is called and the\n        // view is resynchronized after\n        if (this.delayedFlush >= 0 || this.delayedAndroidKey) return false;\n        if (readSelection) this.readSelectionRange();\n        let domChange = this.readChange();\n        if (!domChange) {\n            this.view.requestMeasure();\n            return false;\n        }\n        let startState = this.view.state;\n        let handled = applyDOMChange(this.view, domChange);\n        // The view wasn't updated\n        if (this.view.state == startState) this.view.update([]);\n        return handled;\n    }\n    readMutation(rec) {\n        let cView = this.view.docView.nearest(rec.target);\n        if (!cView || cView.ignoreMutation(rec)) return null;\n        cView.markDirty(rec.type == \"attributes\");\n        if (rec.type == \"attributes\") cView.flags |= 4 /* ViewFlag.AttrsDirty */ ;\n        if (rec.type == \"childList\") {\n            let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);\n            let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);\n            return {\n                from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,\n                to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,\n                typeOver: false\n            };\n        } else if (rec.type == \"characterData\") {\n            return {\n                from: cView.posAtStart,\n                to: cView.posAtEnd,\n                typeOver: rec.target.nodeValue == rec.oldValue\n            };\n        } else {\n            return null;\n        }\n    }\n    setWindow(win) {\n        if (win != this.win) {\n            this.removeWindowListeners(this.win);\n            this.win = win;\n            this.addWindowListeners(this.win);\n        }\n    }\n    addWindowListeners(win) {\n        win.addEventListener(\"resize\", this.onResize);\n        win.addEventListener(\"beforeprint\", this.onPrint);\n        win.addEventListener(\"scroll\", this.onScroll);\n        win.document.addEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    removeWindowListeners(win) {\n        win.removeEventListener(\"scroll\", this.onScroll);\n        win.removeEventListener(\"resize\", this.onResize);\n        win.removeEventListener(\"beforeprint\", this.onPrint);\n        win.document.removeEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    destroy() {\n        var _a, _b, _c;\n        this.stop();\n        (_a = this.intersection) === null || _a === void 0 ? void 0 : _a.disconnect();\n        (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();\n        (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();\n        for (let dom of this.scrollTargets)dom.removeEventListener(\"scroll\", this.onScroll);\n        this.removeWindowListeners(this.win);\n        clearTimeout(this.parentCheck);\n        clearTimeout(this.resizeTimeout);\n        this.win.cancelAnimationFrame(this.delayedFlush);\n        this.win.cancelAnimationFrame(this.flushingAndroidKey);\n    }\n}\nfunction findChild(cView, dom, dir) {\n    while(dom){\n        let curView = ContentView.get(dom);\n        if (curView && curView.parent == cView) return curView;\n        let parent = dom.parentNode;\n        dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;\n    }\n    return null;\n}\n// Used to work around a Safari Selection/shadow DOM bug (#414)\nfunction safariSelectionRangeHack(view) {\n    let found = null;\n    // Because Safari (at least in 2018-2021) doesn't provide regular\n    // access to the selection inside a shadowroot, we have to perform a\n    // ridiculous hack to get at it—using `execCommand` to trigger a\n    // `beforeInput` event so that we can read the target range from the\n    // event.\n    function read(event) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        found = event.getTargetRanges()[0];\n    }\n    view.contentDOM.addEventListener(\"beforeinput\", read, true);\n    view.dom.ownerDocument.execCommand(\"indent\");\n    view.contentDOM.removeEventListener(\"beforeinput\", read, true);\n    if (!found) return null;\n    let anchorNode = found.startContainer, anchorOffset = found.startOffset;\n    let focusNode = found.endContainer, focusOffset = found.endOffset;\n    let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);\n    // Since such a range doesn't distinguish between anchor and head,\n    // use a heuristic that flips it around if its end matches the\n    // current anchor.\n    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset)) [anchorNode, anchorOffset, focusNode, focusOffset] = [\n        focusNode,\n        focusOffset,\n        anchorNode,\n        anchorOffset\n    ];\n    return {\n        anchorNode,\n        anchorOffset,\n        focusNode,\n        focusOffset\n    };\n}\n// The editor's update state machine looks something like this:\n//\n//     Idle → Updating ⇆ Idle (unchecked) → Measuring → Idle\n//                                         ↑      ↓\n//                                         Updating (measure)\n//\n// The difference between 'Idle' and 'Idle (unchecked)' lies in\n// whether a layout check has been scheduled. A regular update through\n// the `update` method updates the DOM in a write-only fashion, and\n// relies on a check (scheduled with `requestAnimationFrame`) to make\n// sure everything is where it should be and the viewport covers the\n// visible code. That check continues to measure and then optionally\n// update until it reaches a coherent state.\n/**\nAn editor view represents the editor's user interface. It holds\nthe editable DOM surface, and possibly other elements such as the\nline number gutter. It handles events and dispatches state\ntransactions for editing actions.\n*/ class EditorView {\n    /**\n    The current editor state.\n    */ get state() {\n        return this.viewState.state;\n    }\n    /**\n    To be able to display large documents without consuming too much\n    memory or overloading the browser, CodeMirror only draws the\n    code that is visible (plus a margin around it) to the DOM. This\n    property tells you the extent of the current drawn viewport, in\n    document positions.\n    */ get viewport() {\n        return this.viewState.viewport;\n    }\n    /**\n    When there are, for example, large collapsed ranges in the\n    viewport, its size can be a lot bigger than the actual visible\n    content. Thus, if you are doing something like styling the\n    content in the viewport, it is preferable to only do so for\n    these ranges, which are the subset of the viewport that is\n    actually drawn.\n    */ get visibleRanges() {\n        return this.viewState.visibleRanges;\n    }\n    /**\n    Returns false when the editor is entirely scrolled out of view\n    or otherwise hidden.\n    */ get inView() {\n        return this.viewState.inView;\n    }\n    /**\n    Indicates whether the user is currently composing text via\n    [IME](https://en.wikipedia.org/wiki/Input_method), and at least\n    one change has been made in the current composition.\n    */ get composing() {\n        return this.inputState.composing > 0;\n    }\n    /**\n    Indicates whether the user is currently in composing state. Note\n    that on some platforms, like Android, this will be the case a\n    lot, since just putting the cursor on a word starts a\n    composition there.\n    */ get compositionStarted() {\n        return this.inputState.composing >= 0;\n    }\n    /**\n    The document or shadow root that the view lives in.\n    */ get root() {\n        return this._root;\n    }\n    /**\n    @internal\n    */ get win() {\n        return this.dom.ownerDocument.defaultView || window;\n    }\n    /**\n    Construct a new view. You'll want to either provide a `parent`\n    option, or put `view.dom` into your document after creating a\n    view, so that the user can see the editor.\n    */ constructor(config = {}){\n        this.plugins = [];\n        this.pluginMap = new Map;\n        this.editorAttrs = {};\n        this.contentAttrs = {};\n        this.bidiCache = [];\n        this.destroyed = false;\n        /**\n        @internal\n        */ this.updateState = 2 /* UpdateState.Updating */ ;\n        /**\n        @internal\n        */ this.measureScheduled = -1;\n        /**\n        @internal\n        */ this.measureRequests = [];\n        this.contentDOM = document.createElement(\"div\");\n        this.scrollDOM = document.createElement(\"div\");\n        this.scrollDOM.tabIndex = -1;\n        this.scrollDOM.className = \"cm-scroller\";\n        this.scrollDOM.appendChild(this.contentDOM);\n        this.announceDOM = document.createElement(\"div\");\n        this.announceDOM.className = \"cm-announced\";\n        this.announceDOM.setAttribute(\"aria-live\", \"polite\");\n        this.dom = document.createElement(\"div\");\n        this.dom.appendChild(this.announceDOM);\n        this.dom.appendChild(this.scrollDOM);\n        if (config.parent) config.parent.appendChild(this.dom);\n        let { dispatch } = config;\n        this.dispatchTransactions = config.dispatchTransactions || dispatch && ((trs)=>trs.forEach((tr)=>dispatch(tr, this))) || ((trs)=>this.update(trs));\n        this.dispatch = this.dispatch.bind(this);\n        this._root = config.root || getRoot(config.parent) || document;\n        this.viewState = new ViewState(config.state || _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.create(config));\n        if (config.scrollTo && config.scrollTo.is(scrollIntoView)) this.viewState.scrollTarget = config.scrollTo.value.clip(this.viewState.state);\n        this.plugins = this.state.facet(viewPlugin).map((spec)=>new PluginInstance(spec));\n        for (let plugin of this.plugins)plugin.update(this);\n        this.observer = new DOMObserver(this);\n        this.inputState = new InputState(this);\n        this.inputState.ensureHandlers(this.plugins);\n        this.docView = new DocView(this);\n        this.mountStyles();\n        this.updateAttrs();\n        this.updateState = 0 /* UpdateState.Idle */ ;\n        this.requestMeasure();\n    }\n    dispatch(...input) {\n        let trs = input.length == 1 && input[0] instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Transaction ? input : input.length == 1 && Array.isArray(input[0]) ? input[0] : [\n            this.state.update(...input)\n        ];\n        this.dispatchTransactions(trs, this);\n    }\n    /**\n    Update the view for the given array of transactions. This will\n    update the visible document and selection to match the state\n    produced by the transactions, and notify view plugins of the\n    change. You should usually call\n    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this\n    as a primitive.\n    */ update(transactions) {\n        if (this.updateState != 0 /* UpdateState.Idle */ ) throw new Error(\"Calls to EditorView.update are not allowed while an update is in progress\");\n        let redrawn = false, attrsChanged = false, update;\n        let state = this.state;\n        for (let tr of transactions){\n            if (tr.startState != state) throw new RangeError(\"Trying to update state with a transaction that doesn't start from the previous state.\");\n            state = tr.state;\n        }\n        if (this.destroyed) {\n            this.viewState.state = state;\n            return;\n        }\n        let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;\n        if (transactions.some((tr)=>tr.annotation(isFocusChange))) {\n            this.inputState.notifiedFocused = focus;\n            // If a focus-change transaction is being dispatched, set this update flag.\n            focusFlag = 1 /* UpdateFlag.Focus */ ;\n        } else if (focus != this.inputState.notifiedFocused) {\n            this.inputState.notifiedFocused = focus;\n            // Schedule a separate focus transaction if necessary, otherwise\n            // add a flag to this update\n            dispatchFocus = focusChangeTransaction(state, focus);\n            if (!dispatchFocus) focusFlag = 1 /* UpdateFlag.Focus */ ;\n        }\n        // If there was a pending DOM change, eagerly read it and try to\n        // apply it after the given transactions.\n        let pendingKey = this.observer.delayedAndroidKey, domChange = null;\n        if (pendingKey) {\n            this.observer.clearDelayedAndroidKey();\n            domChange = this.observer.readChange();\n            // Only try to apply DOM changes if the transactions didn't\n            // change the doc or selection.\n            if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection)) domChange = null;\n        } else {\n            this.observer.clear();\n        }\n        // When the phrases change, redraw the editor\n        if (state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.phrases) != this.state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.phrases)) return this.setState(state);\n        update = ViewUpdate.create(this, state, transactions);\n        update.flags |= focusFlag;\n        let scrollTarget = this.viewState.scrollTarget;\n        try {\n            this.updateState = 2 /* UpdateState.Updating */ ;\n            for (let tr of transactions){\n                if (scrollTarget) scrollTarget = scrollTarget.map(tr.changes);\n                if (tr.scrollIntoView) {\n                    let { main } = tr.state.selection;\n                    scrollTarget = new ScrollTarget(main.empty ? main : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));\n                }\n                for (let e of tr.effects)if (e.is(scrollIntoView)) scrollTarget = e.value.clip(this.state);\n            }\n            this.viewState.update(update, scrollTarget);\n            this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);\n            if (!update.empty) {\n                this.updatePlugins(update);\n                this.inputState.update(update);\n            }\n            redrawn = this.docView.update(update);\n            if (this.state.facet(styleModule) != this.styleModules) this.mountStyles();\n            attrsChanged = this.updateAttrs();\n            this.showAnnouncements(transactions);\n            this.docView.updateSelection(redrawn, transactions.some((tr)=>tr.isUserEvent(\"select.pointer\")));\n        } finally{\n            this.updateState = 0 /* UpdateState.Idle */ ;\n        }\n        if (update.startState.facet(theme) != update.state.facet(theme)) this.viewState.mustMeasureContent = true;\n        if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) this.requestMeasure();\n        if (!update.empty) for (let listener of this.state.facet(updateListener)){\n            try {\n                listener(update);\n            } catch (e) {\n                logException(this.state, e, \"update listener\");\n            }\n        }\n        if (dispatchFocus || domChange) Promise.resolve().then(()=>{\n            if (dispatchFocus && this.state == dispatchFocus.startState) this.dispatch(dispatchFocus);\n            if (domChange) {\n                if (!applyDOMChange(this, domChange) && pendingKey.force) dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);\n            }\n        });\n    }\n    /**\n    Reset the view to the given state. (This will cause the entire\n    document to be redrawn and all view plugins to be reinitialized,\n    so you should probably only use it when the new state isn't\n    derived from the old state. Otherwise, use\n    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)\n    */ setState(newState) {\n        if (this.updateState != 0 /* UpdateState.Idle */ ) throw new Error(\"Calls to EditorView.setState are not allowed while an update is in progress\");\n        if (this.destroyed) {\n            this.viewState.state = newState;\n            return;\n        }\n        this.updateState = 2 /* UpdateState.Updating */ ;\n        let hadFocus = this.hasFocus;\n        try {\n            for (let plugin of this.plugins)plugin.destroy(this);\n            this.viewState = new ViewState(newState);\n            this.plugins = newState.facet(viewPlugin).map((spec)=>new PluginInstance(spec));\n            this.pluginMap.clear();\n            for (let plugin of this.plugins)plugin.update(this);\n            this.docView.destroy();\n            this.docView = new DocView(this);\n            this.inputState.ensureHandlers(this.plugins);\n            this.mountStyles();\n            this.updateAttrs();\n            this.bidiCache = [];\n        } finally{\n            this.updateState = 0 /* UpdateState.Idle */ ;\n        }\n        if (hadFocus) this.focus();\n        this.requestMeasure();\n    }\n    updatePlugins(update) {\n        let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);\n        if (prevSpecs != specs) {\n            let newPlugins = [];\n            for (let spec of specs){\n                let found = prevSpecs.indexOf(spec);\n                if (found < 0) {\n                    newPlugins.push(new PluginInstance(spec));\n                } else {\n                    let plugin = this.plugins[found];\n                    plugin.mustUpdate = update;\n                    newPlugins.push(plugin);\n                }\n            }\n            for (let plugin of this.plugins)if (plugin.mustUpdate != update) plugin.destroy(this);\n            this.plugins = newPlugins;\n            this.pluginMap.clear();\n        } else {\n            for (let p of this.plugins)p.mustUpdate = update;\n        }\n        for(let i = 0; i < this.plugins.length; i++)this.plugins[i].update(this);\n        if (prevSpecs != specs) this.inputState.ensureHandlers(this.plugins);\n    }\n    /**\n    @internal\n    */ measure(flush = true) {\n        if (this.destroyed) return;\n        if (this.measureScheduled > -1) this.win.cancelAnimationFrame(this.measureScheduled);\n        if (this.observer.delayedAndroidKey) {\n            this.measureScheduled = -1;\n            this.requestMeasure();\n            return;\n        }\n        this.measureScheduled = 0; // Prevent requestMeasure calls from scheduling another animation frame\n        if (flush) this.observer.forceFlush();\n        let updated = null;\n        let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;\n        let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;\n        if (Math.abs(scrollTop - this.viewState.scrollTop) > 1) scrollAnchorHeight = -1;\n        this.viewState.scrollAnchorHeight = -1;\n        try {\n            for(let i = 0;; i++){\n                if (scrollAnchorHeight < 0) {\n                    if (isScrolledToBottom(sDOM)) {\n                        scrollAnchorPos = -1;\n                        scrollAnchorHeight = this.viewState.heightMap.height;\n                    } else {\n                        let block = this.viewState.scrollAnchorAt(scrollTop);\n                        scrollAnchorPos = block.from;\n                        scrollAnchorHeight = block.top;\n                    }\n                }\n                this.updateState = 1 /* UpdateState.Measuring */ ;\n                let changed = this.viewState.measure(this);\n                if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null) break;\n                if (i > 5) {\n                    console.warn(this.measureRequests.length ? \"Measure loop restarted more than 5 times\" : \"Viewport failed to stabilize\");\n                    break;\n                }\n                let measuring = [];\n                // Only run measure requests in this cycle when the viewport didn't change\n                if (!(changed & 4 /* UpdateFlag.Viewport */ )) [this.measureRequests, measuring] = [\n                    measuring,\n                    this.measureRequests\n                ];\n                let measured = measuring.map((m)=>{\n                    try {\n                        return m.read(this);\n                    } catch (e) {\n                        logException(this.state, e);\n                        return BadMeasure;\n                    }\n                });\n                let update = ViewUpdate.create(this, this.state, []), redrawn = false;\n                update.flags |= changed;\n                if (!updated) updated = update;\n                else updated.flags |= changed;\n                this.updateState = 2 /* UpdateState.Updating */ ;\n                if (!update.empty) {\n                    this.updatePlugins(update);\n                    this.inputState.update(update);\n                    this.updateAttrs();\n                    redrawn = this.docView.update(update);\n                }\n                for(let i = 0; i < measuring.length; i++)if (measured[i] != BadMeasure) {\n                    try {\n                        let m = measuring[i];\n                        if (m.write) m.write(measured[i], this);\n                    } catch (e) {\n                        logException(this.state, e);\n                    }\n                }\n                if (redrawn) this.docView.updateSelection(true);\n                if (!update.viewportChanged && this.measureRequests.length == 0) {\n                    if (this.viewState.editorHeight) {\n                        if (this.viewState.scrollTarget) {\n                            this.docView.scrollIntoView(this.viewState.scrollTarget);\n                            this.viewState.scrollTarget = null;\n                            scrollAnchorHeight = -1;\n                            continue;\n                        } else {\n                            let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(scrollAnchorPos).top;\n                            let diff = newAnchorHeight - scrollAnchorHeight;\n                            if (diff > 1 || diff < -1) {\n                                scrollTop = scrollTop + diff;\n                                sDOM.scrollTop = scrollTop / this.scaleY;\n                                scrollAnchorHeight = -1;\n                                continue;\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n        } finally{\n            this.updateState = 0 /* UpdateState.Idle */ ;\n            this.measureScheduled = -1;\n        }\n        if (updated && !updated.empty) for (let listener of this.state.facet(updateListener))listener(updated);\n    }\n    /**\n    Get the CSS classes for the currently active editor themes.\n    */ get themeClasses() {\n        return baseThemeID + \" \" + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + \" \" + this.state.facet(theme);\n    }\n    updateAttrs() {\n        let editorAttrs = attrsFromFacet(this, editorAttributes, {\n            class: \"cm-editor\" + (this.hasFocus ? \" cm-focused \" : \" \") + this.themeClasses\n        });\n        let contentAttrs = {\n            spellcheck: \"false\",\n            autocorrect: \"off\",\n            autocapitalize: \"off\",\n            translate: \"no\",\n            contenteditable: !this.state.facet(editable) ? \"false\" : \"true\",\n            class: \"cm-content\",\n            style: `${browser.tabSize}: ${this.state.tabSize}`,\n            role: \"textbox\",\n            \"aria-multiline\": \"true\"\n        };\n        if (this.state.readOnly) contentAttrs[\"aria-readonly\"] = \"true\";\n        attrsFromFacet(this, contentAttributes, contentAttrs);\n        let changed = this.observer.ignore(()=>{\n            let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);\n            let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);\n            return changedContent || changedEditor;\n        });\n        this.editorAttrs = editorAttrs;\n        this.contentAttrs = contentAttrs;\n        return changed;\n    }\n    showAnnouncements(trs) {\n        let first = true;\n        for (let tr of trs)for (let effect of tr.effects)if (effect.is(EditorView.announce)) {\n            if (first) this.announceDOM.textContent = \"\";\n            first = false;\n            let div = this.announceDOM.appendChild(document.createElement(\"div\"));\n            div.textContent = effect.value;\n        }\n    }\n    mountStyles() {\n        this.styleModules = this.state.facet(styleModule);\n        let nonce = this.state.facet(EditorView.cspNonce);\n        style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? {\n            nonce\n        } : undefined);\n    }\n    readMeasured() {\n        if (this.updateState == 2 /* UpdateState.Updating */ ) throw new Error(\"Reading the editor layout isn't allowed during an update\");\n        if (this.updateState == 0 /* UpdateState.Idle */  && this.measureScheduled > -1) this.measure(false);\n    }\n    /**\n    Schedule a layout measurement, optionally providing callbacks to\n    do custom DOM measuring followed by a DOM write phase. Using\n    this is preferable reading DOM layout directly from, for\n    example, an event handler, because it'll make sure measuring and\n    drawing done by other components is synchronized, avoiding\n    unnecessary DOM layout computations.\n    */ requestMeasure(request) {\n        if (this.measureScheduled < 0) this.measureScheduled = this.win.requestAnimationFrame(()=>this.measure());\n        if (request) {\n            if (this.measureRequests.indexOf(request) > -1) return;\n            if (request.key != null) for(let i = 0; i < this.measureRequests.length; i++){\n                if (this.measureRequests[i].key === request.key) {\n                    this.measureRequests[i] = request;\n                    return;\n                }\n            }\n            this.measureRequests.push(request);\n        }\n    }\n    /**\n    Get the value of a specific plugin, if present. Note that\n    plugins that crash can be dropped from a view, so even when you\n    know you registered a given plugin, it is recommended to check\n    the return value of this method.\n    */ plugin(plugin) {\n        let known = this.pluginMap.get(plugin);\n        if (known === undefined || known && known.spec != plugin) this.pluginMap.set(plugin, known = this.plugins.find((p)=>p.spec == plugin) || null);\n        return known && known.update(this).value;\n    }\n    /**\n    The top position of the document, in screen coordinates. This\n    may be negative when the editor is scrolled down. Points\n    directly to the top of the first line, not above the padding.\n    */ get documentTop() {\n        return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;\n    }\n    /**\n    Reports the padding above and below the document.\n    */ get documentPadding() {\n        return {\n            top: this.viewState.paddingTop,\n            bottom: this.viewState.paddingBottom\n        };\n    }\n    /**\n    If the editor is transformed with CSS, this provides the scale\n    along the X axis. Otherwise, it will just be 1. Note that\n    transforms other than translation and scaling are not supported.\n    */ get scaleX() {\n        return this.viewState.scaleX;\n    }\n    /**\n    Provide the CSS transformed scale along the Y axis.\n    */ get scaleY() {\n        return this.viewState.scaleY;\n    }\n    /**\n    Find the text line or block widget at the given vertical\n    position (which is interpreted as relative to the [top of the\n    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).\n    */ elementAtHeight(height) {\n        this.readMeasured();\n        return this.viewState.elementAtHeight(height);\n    }\n    /**\n    Find the line block (see\n    [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given\n    height, again interpreted relative to the [top of the\n    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).\n    */ lineBlockAtHeight(height) {\n        this.readMeasured();\n        return this.viewState.lineBlockAtHeight(height);\n    }\n    /**\n    Get the extent and vertical position of all [line\n    blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions\n    are relative to the [top of the\n    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);\n    */ get viewportLineBlocks() {\n        return this.viewState.viewportLines;\n    }\n    /**\n    Find the line block around the given document position. A line\n    block is a range delimited on both sides by either a\n    non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the\n    start/end of the document. It will usually just hold a line of\n    text, but may be broken into multiple textblocks by block\n    widgets.\n    */ lineBlockAt(pos) {\n        return this.viewState.lineBlockAt(pos);\n    }\n    /**\n    The editor's total content height.\n    */ get contentHeight() {\n        return this.viewState.contentHeight;\n    }\n    /**\n    Move a cursor position by [grapheme\n    cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether\n    the motion is away from the line start, or towards it. In\n    bidirectional text, the line is traversed in visual order, using\n    the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).\n    When the start position was the last one on the line, the\n    returned position will be across the line break. If there is no\n    further line, the original position is returned.\n    \n    By default, this method moves over a single cluster. The\n    optional `by` argument can be used to move across more. It will\n    be called with the first cluster as argument, and should return\n    a predicate that determines, for each subsequent cluster,\n    whether it should also be moved over.\n    */ moveByChar(start, forward, by) {\n        return skipAtoms(this, start, moveByChar(this, start, forward, by));\n    }\n    /**\n    Move a cursor position across the next group of either\n    [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter\n    non-whitespace characters.\n    */ moveByGroup(start, forward) {\n        return skipAtoms(this, start, moveByChar(this, start, forward, (initial)=>byGroup(this, start.head, initial)));\n    }\n    /**\n    Get the cursor position visually at the start or end of a line.\n    Note that this may differ from the _logical_ position at its\n    start or end (which is simply at `line.from`/`line.to`) if text\n    at the start or end goes against the line's base text direction.\n    */ visualLineSide(line, end) {\n        let order = this.bidiSpans(line), dir = this.textDirectionAt(line.from);\n        let span = order[end ? order.length - 1 : 0];\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(span.side(end, dir) + line.from, span.forward(!end, dir) ? 1 : -1);\n    }\n    /**\n    Move to the next line boundary in the given direction. If\n    `includeWrap` is true, line wrapping is on, and there is a\n    further wrap point on the current line, the wrap point will be\n    returned. Otherwise this function will return the start or end\n    of the line.\n    */ moveToLineBoundary(start, forward, includeWrap = true) {\n        return moveToLineBoundary(this, start, forward, includeWrap);\n    }\n    /**\n    Move a cursor position vertically. When `distance` isn't given,\n    it defaults to moving to the next line (including wrapped\n    lines). Otherwise, `distance` should provide a positive distance\n    in pixels.\n    \n    When `start` has a\n    [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical\n    motion will use that as a target horizontal position. Otherwise,\n    the cursor's own horizontal position is used. The returned\n    cursor will have its goal column set to whichever column was\n    used.\n    */ moveVertically(start, forward, distance) {\n        return skipAtoms(this, start, moveVertically(this, start, forward, distance));\n    }\n    /**\n    Find the DOM parent node and offset (child offset if `node` is\n    an element, character offset when it is a text node) at the\n    given document position.\n    \n    Note that for positions that aren't currently in\n    `visibleRanges`, the resulting DOM position isn't necessarily\n    meaningful (it may just point before or after a placeholder\n    element).\n    */ domAtPos(pos) {\n        return this.docView.domAtPos(pos);\n    }\n    /**\n    Find the document position at the given DOM node. Can be useful\n    for associating positions with DOM events. Will raise an error\n    when `node` isn't part of the editor content.\n    */ posAtDOM(node, offset = 0) {\n        return this.docView.posFromDOM(node, offset);\n    }\n    posAtCoords(coords, precise = true) {\n        this.readMeasured();\n        return posAtCoords(this, coords, precise);\n    }\n    /**\n    Get the screen coordinates at the given document position.\n    `side` determines whether the coordinates are based on the\n    element before (-1) or after (1) the position (if no element is\n    available on the given side, the method will transparently use\n    another strategy to get reasonable coordinates).\n    */ coordsAtPos(pos, side = 1) {\n        this.readMeasured();\n        let rect = this.docView.coordsAt(pos, side);\n        if (!rect || rect.left == rect.right) return rect;\n        let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);\n        let span = order[BidiSpan.find(order, pos - line.from, -1, side)];\n        return flattenRect(rect, span.dir == Direction.LTR == side > 0);\n    }\n    /**\n    Return the rectangle around a given character. If `pos` does not\n    point in front of a character that is in the viewport and\n    rendered (i.e. not replaced, not a line break), this will return\n    null. For space characters that are a line wrap point, this will\n    return the position before the line break.\n    */ coordsForChar(pos) {\n        this.readMeasured();\n        return this.docView.coordsForChar(pos);\n    }\n    /**\n    The default width of a character in the editor. May not\n    accurately reflect the width of all characters (given variable\n    width fonts or styling of invididual ranges).\n    */ get defaultCharacterWidth() {\n        return this.viewState.heightOracle.charWidth;\n    }\n    /**\n    The default height of a line in the editor. May not be accurate\n    for all lines.\n    */ get defaultLineHeight() {\n        return this.viewState.heightOracle.lineHeight;\n    }\n    /**\n    The text direction\n    ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)\n    CSS property) of the editor's content element.\n    */ get textDirection() {\n        return this.viewState.defaultTextDirection;\n    }\n    /**\n    Find the text direction of the block at the given position, as\n    assigned by CSS. If\n    [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)\n    isn't enabled, or the given position is outside of the viewport,\n    this will always return the same as\n    [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that\n    this may trigger a DOM layout.\n    */ textDirectionAt(pos) {\n        let perLine = this.state.facet(perLineTextDirection);\n        if (!perLine || pos < this.viewport.from || pos > this.viewport.to) return this.textDirection;\n        this.readMeasured();\n        return this.docView.textDirectionAt(pos);\n    }\n    /**\n    Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)\n    (as determined by the\n    [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)\n    CSS property of its content element).\n    */ get lineWrapping() {\n        return this.viewState.heightOracle.lineWrapping;\n    }\n    /**\n    Returns the bidirectional text structure of the given line\n    (which should be in the current document) as an array of span\n    objects. The order of these spans matches the [text\n    direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is\n    left-to-right, the leftmost spans come first, otherwise the\n    rightmost spans come first.\n    */ bidiSpans(line) {\n        if (line.length > MaxBidiLine) return trivialOrder(line.length);\n        let dir = this.textDirectionAt(line.from), isolates;\n        for (let entry of this.bidiCache){\n            if (entry.from == line.from && entry.dir == dir && (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line)))) return entry.order;\n        }\n        if (!isolates) isolates = getIsolatedRanges(this, line);\n        let order = computeOrder(line.text, dir, isolates);\n        this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));\n        return order;\n    }\n    /**\n    Check whether the editor has focus.\n    */ get hasFocus() {\n        var _a;\n        // Safari return false for hasFocus when the context menu is open\n        // or closing, which leads us to ignore selection changes from the\n        // context menu because it looks like the editor isn't focused.\n        // This kludges around that.\n        return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a = this.inputState) === null || _a === void 0 ? void 0 : _a.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;\n    }\n    /**\n    Put focus on the editor.\n    */ focus() {\n        this.observer.ignore(()=>{\n            focusPreventScroll(this.contentDOM);\n            this.docView.updateSelection();\n        });\n    }\n    /**\n    Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only\n    necessary when moving the editor's existing DOM to a new window or shadow root.\n    */ setRoot(root) {\n        if (this._root != root) {\n            this._root = root;\n            this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);\n            this.mountStyles();\n        }\n    }\n    /**\n    Clean up this editor view, removing its element from the\n    document, unregistering event handlers, and notifying\n    plugins. The view instance can no longer be used after\n    calling this.\n    */ destroy() {\n        for (let plugin of this.plugins)plugin.destroy(this);\n        this.plugins = [];\n        this.inputState.destroy();\n        this.docView.destroy();\n        this.dom.remove();\n        this.observer.destroy();\n        if (this.measureScheduled > -1) this.win.cancelAnimationFrame(this.measureScheduled);\n        this.destroyed = true;\n    }\n    /**\n    Returns an effect that can be\n    [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to\n    cause it to scroll the given position or range into view.\n    */ static scrollIntoView(pos, options = {}) {\n        return scrollIntoView.of(new ScrollTarget(typeof pos == \"number\" ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));\n    }\n    /**\n    Return an effect that resets the editor to its current (at the\n    time this method was called) scroll position. Note that this\n    only affects the editor's own scrollable element, not parents.\n    See also\n    [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).\n    \n    The effect should be used with a document identical to the one\n    it was created for. Failing to do so is not an error, but may\n    not scroll to the expected position. You can\n    [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.\n    */ scrollSnapshot() {\n        let { scrollTop, scrollLeft } = this.scrollDOM;\n        let ref = this.viewState.scrollAnchorAt(scrollTop);\n        return scrollIntoView.of(new ScrollTarget(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(ref.from), \"start\", \"start\", ref.top - scrollTop, scrollLeft, true));\n    }\n    /**\n    Returns an extension that can be used to add DOM event handlers.\n    The value should be an object mapping event names to handler\n    functions. For any given event, such functions are ordered by\n    extension precedence, and the first handler to return true will\n    be assumed to have handled that event, and no other handlers or\n    built-in behavior will be activated for it. These are registered\n    on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except\n    for `scroll` handlers, which will be called any time the\n    editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of\n    its parent nodes is scrolled.\n    */ static domEventHandlers(handlers) {\n        return ViewPlugin.define(()=>({}), {\n            eventHandlers: handlers\n        });\n    }\n    /**\n    Create an extension that registers DOM event observers. Contrary\n    to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),\n    observers can't be prevented from running by a higher-precedence\n    handler returning true. They also don't prevent other handlers\n    and observers from running when they return true, and should not\n    call `preventDefault`.\n    */ static domEventObservers(observers) {\n        return ViewPlugin.define(()=>({}), {\n            eventObservers: observers\n        });\n    }\n    /**\n    Create a theme extension. The first argument can be a\n    [`style-mod`](https://github.com/marijnh/style-mod#documentation)\n    style spec providing the styles for the theme. These will be\n    prefixed with a generated class for the style.\n    \n    Because the selectors will be prefixed with a scope class, rule\n    that directly match the editor's [wrapper\n    element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be\n    added—need to be explicitly differentiated by adding an `&` to\n    the selector for that element—for example\n    `&.cm-focused`.\n    \n    When `dark` is set to true, the theme will be marked as dark,\n    which will cause the `&dark` rules from [base\n    themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to\n    `&light` when a light theme is active).\n    */ static theme(spec, options) {\n        let prefix = style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName();\n        let result = [\n            theme.of(prefix),\n            styleModule.of(buildTheme(`.${prefix}`, spec))\n        ];\n        if (options && options.dark) result.push(darkTheme.of(true));\n        return result;\n    }\n    /**\n    Create an extension that adds styles to the base theme. Like\n    with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the\n    place of the editor wrapper element when directly targeting\n    that. You can also use `&dark` or `&light` instead to only\n    target editors with a dark or light theme.\n    */ static baseTheme(spec) {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec.lowest(styleModule.of(buildTheme(\".\" + baseThemeID, spec, lightDarkIDs)));\n    }\n    /**\n    Retrieve an editor view instance from the view's DOM\n    representation.\n    */ static findFromDOM(dom) {\n        var _a;\n        let content = dom.querySelector(\".cm-content\");\n        let cView = content && ContentView.get(content) || ContentView.get(dom);\n        return ((_a = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a === void 0 ? void 0 : _a.view) || null;\n    }\n}\n/**\nFacet to add a [style\nmodule](https://github.com/marijnh/style-mod#documentation) to\nan editor view. The view will ensure that the module is\nmounted in its [document\nroot](https://codemirror.net/6/docs/ref/#view.EditorView.constructor^config.root).\n*/ EditorView.styleModule = styleModule;\n/**\nAn input handler can override the way changes to the editable\nDOM content are handled. Handlers are passed the document\npositions between which the change was found, and the new\ncontent. When one returns true, no further input handlers are\ncalled and the default behavior is prevented.\n\nThe `insert` argument can be used to get the default transaction\nthat would be applied for this input. This can be useful when\ndispatching the custom behavior as a separate transaction.\n*/ EditorView.inputHandler = inputHandler;\n/**\nThis facet can be used to provide functions that create effects\nto be dispatched when the editor's focus state changes.\n*/ EditorView.focusChangeEffect = focusChangeEffect;\n/**\nBy default, the editor assumes all its content has the same\n[text direction](https://codemirror.net/6/docs/ref/#view.Direction). Configure this with a `true`\nvalue to make it read the text direction of every (rendered)\nline separately.\n*/ EditorView.perLineTextDirection = perLineTextDirection;\n/**\nAllows you to provide a function that should be called when the\nlibrary catches an exception from an extension (mostly from view\nplugins, but may be used by other extensions to route exceptions\nfrom user-code-provided callbacks). This is mostly useful for\ndebugging and logging. See [`logException`](https://codemirror.net/6/docs/ref/#view.logException).\n*/ EditorView.exceptionSink = exceptionSink;\n/**\nA facet that can be used to register a function to be called\nevery time the view updates.\n*/ EditorView.updateListener = updateListener;\n/**\nFacet that controls whether the editor content DOM is editable.\nWhen its highest-precedence value is `false`, the element will\nnot have its `contenteditable` attribute set. (Note that this\ndoesn't affect API calls that change the editor content, even\nwhen those are bound to keys or buttons. See the\n[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) facet for that.)\n*/ EditorView.editable = editable;\n/**\nAllows you to influence the way mouse selection happens. The\nfunctions in this facet will be called for a `mousedown` event\non the editor, and can return an object that overrides the way a\nselection is computed from that mouse click or drag.\n*/ EditorView.mouseSelectionStyle = mouseSelectionStyle;\n/**\nFacet used to configure whether a given selection drag event\nshould move or copy the selection. The given predicate will be\ncalled with the `mousedown` event, and can return `true` when\nthe drag should move the content.\n*/ EditorView.dragMovesSelection = dragMovesSelection$1;\n/**\nFacet used to configure whether a given selecting click adds a\nnew range to the existing selection or replaces it entirely. The\ndefault behavior is to check `event.metaKey` on macOS, and\n`event.ctrlKey` elsewhere.\n*/ EditorView.clickAddsSelectionRange = clickAddsSelectionRange;\n/**\nA facet that determines which [decorations](https://codemirror.net/6/docs/ref/#view.Decoration)\nare shown in the view. Decorations can be provided in two\nways—directly, or via a function that takes an editor view.\n\nOnly decoration sets provided directly are allowed to influence\nthe editor's vertical layout structure. The ones provided as\nfunctions are called _after_ the new viewport has been computed,\nand thus **must not** introduce block widgets or replacing\ndecorations that cover line breaks.\n\nIf you want decorated ranges to behave like atomic units for\ncursor motion and deletion purposes, also provide the range set\ncontaining the decorations to\n[`EditorView.atomicRanges`](https://codemirror.net/6/docs/ref/#view.EditorView^atomicRanges).\n*/ EditorView.decorations = decorations;\n/**\nFacet that works much like\n[`decorations`](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), but puts its\ninputs at the very bottom of the precedence stack, meaning mark\ndecorations provided here will only be split by other, partially\noverlapping \\`outerDecorations\\` ranges, and wrap around all\nregular decorations. Use this for mark elements that should, as\nmuch as possible, remain in one piece.\n*/ EditorView.outerDecorations = outerDecorations;\n/**\nUsed to provide ranges that should be treated as atoms as far as\ncursor motion is concerned. This causes methods like\n[`moveByChar`](https://codemirror.net/6/docs/ref/#view.EditorView.moveByChar) and\n[`moveVertically`](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) (and the\ncommands built on top of them) to skip across such regions when\na selection endpoint would enter them. This does _not_ prevent\ndirect programmatic [selection\nupdates](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) from moving into such\nregions.\n*/ EditorView.atomicRanges = atomicRanges;\n/**\nWhen range decorations add a `unicode-bidi: isolate` style, they\nshould also include a\n[`bidiIsolate`](https://codemirror.net/6/docs/ref/#view.MarkDecorationSpec.bidiIsolate) property\nin their decoration spec, and be exposed through this facet, so\nthat the editor can compute the proper text order. (Other values\nfor `unicode-bidi`, except of course `normal`, are not\nsupported.)\n*/ EditorView.bidiIsolatedRanges = bidiIsolatedRanges;\n/**\nFacet that allows extensions to provide additional scroll\nmargins (space around the sides of the scrolling element that\nshould be considered invisible). This can be useful when the\nplugin introduces elements that cover part of that element (for\nexample a horizontally fixed gutter).\n*/ EditorView.scrollMargins = scrollMargins;\n/**\nThis facet records whether a dark theme is active. The extension\nreturned by [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme) automatically\nincludes an instance of this when the `dark` option is set to\ntrue.\n*/ EditorView.darkTheme = darkTheme;\n/**\nProvides a Content Security Policy nonce to use when creating\nthe style sheets for the editor. Holds the empty string when no\nnonce has been provided.\n*/ EditorView.cspNonce = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (values)=>values.length ? values[0] : \"\"\n});\n/**\nFacet that provides additional DOM attributes for the editor's\neditable DOM element.\n*/ EditorView.contentAttributes = contentAttributes;\n/**\nFacet that provides DOM attributes for the editor's outer\nelement.\n*/ EditorView.editorAttributes = editorAttributes;\n/**\nAn extension that enables line wrapping in the editor (by\nsetting CSS `white-space` to `pre-wrap` in the content).\n*/ EditorView.lineWrapping = /*@__PURE__*/ EditorView.contentAttributes.of({\n    \"class\": \"cm-lineWrapping\"\n});\n/**\nState effect used to include screen reader announcements in a\ntransaction. These will be added to the DOM in a visually hidden\nelement with `aria-live=\"polite\"` set, and should be used to\ndescribe effects that are visually obvious but may not be\nnoticed by screen reader users (such as moving to the next\nsearch match).\n*/ EditorView.announce = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\n// Maximum line length for which we compute accurate bidi info\nconst MaxBidiLine = 4096;\nconst BadMeasure = {};\nclass CachedOrder {\n    constructor(from, to, dir, isolates, fresh, order){\n        this.from = from;\n        this.to = to;\n        this.dir = dir;\n        this.isolates = isolates;\n        this.fresh = fresh;\n        this.order = order;\n    }\n    static update(cache, changes) {\n        if (changes.empty && !cache.some((c)=>c.fresh)) return cache;\n        let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;\n        for(let i = Math.max(0, cache.length - 10); i < cache.length; i++){\n            let entry = cache[i];\n            if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to)) result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));\n        }\n        return result;\n    }\n}\nfunction attrsFromFacet(view, facet, base) {\n    for(let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--){\n        let source = sources[i], value = typeof source == \"function\" ? source(view) : source;\n        if (value) combineAttrs(value, base);\n    }\n    return base;\n}\nconst currentPlatform = browser.mac ? \"mac\" : browser.windows ? \"win\" : browser.linux ? \"linux\" : \"key\";\nfunction normalizeKeyName(name, platform) {\n    const parts = name.split(/-(?!$)/);\n    let result = parts[parts.length - 1];\n    if (result == \"Space\") result = \" \";\n    let alt, ctrl, shift, meta;\n    for(let i = 0; i < parts.length - 1; ++i){\n        const mod = parts[i];\n        if (/^(cmd|meta|m)$/i.test(mod)) meta = true;\n        else if (/^a(lt)?$/i.test(mod)) alt = true;\n        else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;\n        else if (/^s(hift)?$/i.test(mod)) shift = true;\n        else if (/^mod$/i.test(mod)) {\n            if (platform == \"mac\") meta = true;\n            else ctrl = true;\n        } else throw new Error(\"Unrecognized modifier name: \" + mod);\n    }\n    if (alt) result = \"Alt-\" + result;\n    if (ctrl) result = \"Ctrl-\" + result;\n    if (meta) result = \"Meta-\" + result;\n    if (shift) result = \"Shift-\" + result;\n    return result;\n}\nfunction modifiers(name, event, shift) {\n    if (event.altKey) name = \"Alt-\" + name;\n    if (event.ctrlKey) name = \"Ctrl-\" + name;\n    if (event.metaKey) name = \"Meta-\" + name;\n    if (shift !== false && event.shiftKey) name = \"Shift-\" + name;\n    return name;\n}\nconst handleKeyEvents = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec.default(/*@__PURE__*/ EditorView.domEventHandlers({\n    keydown (event, view) {\n        return runHandlers(getKeymap(view.state), event, view, \"editor\");\n    }\n}));\n/**\nFacet used for registering keymaps.\n\nYou can add multiple keymaps to an editor. Their priorities\ndetermine their precedence (the ones specified early or with high\npriority get checked first). When a handler has returned `true`\nfor a given key, no further handlers are called.\n*/ const keymap = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    enables: handleKeyEvents\n});\nconst Keymaps = /*@__PURE__*/ new WeakMap();\n// This is hidden behind an indirection, rather than directly computed\n// by the facet, to keep internal types out of the facet's type.\nfunction getKeymap(state) {\n    let bindings = state.facet(keymap);\n    let map = Keymaps.get(bindings);\n    if (!map) Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b)=>a.concat(b), [])));\n    return map;\n}\n/**\nRun the key handlers registered for a given scope. The event\nobject should be a `\"keydown\"` event. Returns true if any of the\nhandlers handled it.\n*/ function runScopeHandlers(view, event, scope) {\n    return runHandlers(getKeymap(view.state), event, view, scope);\n}\nlet storedPrefix = null;\nconst PrefixTimeout = 4000;\nfunction buildKeymap(bindings, platform = currentPlatform) {\n    let bound = Object.create(null);\n    let isPrefix = Object.create(null);\n    let checkPrefix = (name, is)=>{\n        let current = isPrefix[name];\n        if (current == null) isPrefix[name] = is;\n        else if (current != is) throw new Error(\"Key binding \" + name + \" is used both as a regular binding and as a multi-stroke prefix\");\n    };\n    let add = (scope, key, command, preventDefault, stopPropagation)=>{\n        var _a, _b;\n        let scopeObj = bound[scope] || (bound[scope] = Object.create(null));\n        let parts = key.split(/ (?!$)/).map((k)=>normalizeKeyName(k, platform));\n        for(let i = 1; i < parts.length; i++){\n            let prefix = parts.slice(0, i).join(\" \");\n            checkPrefix(prefix, true);\n            if (!scopeObj[prefix]) scopeObj[prefix] = {\n                preventDefault: true,\n                stopPropagation: false,\n                run: [\n                    (view)=>{\n                        let ourObj = storedPrefix = {\n                            view,\n                            prefix,\n                            scope\n                        };\n                        setTimeout(()=>{\n                            if (storedPrefix == ourObj) storedPrefix = null;\n                        }, PrefixTimeout);\n                        return true;\n                    }\n                ]\n            };\n        }\n        let full = parts.join(\" \");\n        checkPrefix(full, false);\n        let binding = scopeObj[full] || (scopeObj[full] = {\n            preventDefault: false,\n            stopPropagation: false,\n            run: ((_b = (_a = scopeObj._any) === null || _a === void 0 ? void 0 : _a.run) === null || _b === void 0 ? void 0 : _b.slice()) || []\n        });\n        if (command) binding.run.push(command);\n        if (preventDefault) binding.preventDefault = true;\n        if (stopPropagation) binding.stopPropagation = true;\n    };\n    for (let b of bindings){\n        let scopes = b.scope ? b.scope.split(\" \") : [\n            \"editor\"\n        ];\n        if (b.any) for (let scope of scopes){\n            let scopeObj = bound[scope] || (bound[scope] = Object.create(null));\n            if (!scopeObj._any) scopeObj._any = {\n                preventDefault: false,\n                stopPropagation: false,\n                run: []\n            };\n            for(let key in scopeObj)scopeObj[key].run.push(b.any);\n        }\n        let name = b[platform] || b.key;\n        if (!name) continue;\n        for (let scope of scopes){\n            add(scope, name, b.run, b.preventDefault, b.stopPropagation);\n            if (b.shift) add(scope, \"Shift-\" + name, b.shift, b.preventDefault, b.stopPropagation);\n        }\n    }\n    return bound;\n}\nfunction runHandlers(map, event, view, scope) {\n    let name = (0,w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.keyName)(event);\n    let charCode = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.codePointAt)(name, 0), isChar = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.codePointSize)(charCode) == name.length && name != \" \";\n    let prefix = \"\", handled = false, prevented = false, stopPropagation = false;\n    if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {\n        prefix = storedPrefix.prefix + \" \";\n        if (modifierCodes.indexOf(event.keyCode) < 0) {\n            prevented = true;\n            storedPrefix = null;\n        }\n    }\n    let ran = new Set;\n    let runFor = (binding)=>{\n        if (binding) {\n            for (let cmd of binding.run)if (!ran.has(cmd)) {\n                ran.add(cmd);\n                if (cmd(view, event)) {\n                    if (binding.stopPropagation) stopPropagation = true;\n                    return true;\n                }\n            }\n            if (binding.preventDefault) {\n                if (binding.stopPropagation) stopPropagation = true;\n                prevented = true;\n            }\n        }\n        return false;\n    };\n    let scopeObj = map[scope], baseName, shiftName;\n    if (scopeObj) {\n        if (runFor(scopeObj[prefix + modifiers(name, event, !isChar)])) {\n            handled = true;\n        } else if (isChar && (event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows\n        !(browser.windows && event.ctrlKey && event.altKey) && (baseName = w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.base[event.keyCode]) && baseName != name) {\n            if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) {\n                handled = true;\n            } else if (event.shiftKey && (shiftName = w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.shift[event.keyCode]) != name && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) {\n                handled = true;\n            }\n        } else if (isChar && event.shiftKey && runFor(scopeObj[prefix + modifiers(name, event, true)])) {\n            handled = true;\n        }\n        if (!handled && runFor(scopeObj._any)) handled = true;\n    }\n    if (prevented) handled = true;\n    if (handled && stopPropagation) event.stopPropagation();\n    return handled;\n}\n/**\nImplementation of [`LayerMarker`](https://codemirror.net/6/docs/ref/#view.LayerMarker) that creates\na rectangle at a given set of coordinates.\n*/ class RectangleMarker {\n    /**\n    Create a marker with the given class and dimensions. If `width`\n    is null, the DOM element will get no width style.\n    */ constructor(className, /**\n    The left position of the marker (in pixels, document-relative).\n    */ left, /**\n    The top position of the marker.\n    */ top, /**\n    The width of the marker, or null if it shouldn't get a width assigned.\n    */ width, /**\n    The height of the marker.\n    */ height){\n        this.className = className;\n        this.left = left;\n        this.top = top;\n        this.width = width;\n        this.height = height;\n    }\n    draw() {\n        let elt = document.createElement(\"div\");\n        elt.className = this.className;\n        this.adjust(elt);\n        return elt;\n    }\n    update(elt, prev) {\n        if (prev.className != this.className) return false;\n        this.adjust(elt);\n        return true;\n    }\n    adjust(elt) {\n        elt.style.left = this.left + \"px\";\n        elt.style.top = this.top + \"px\";\n        if (this.width != null) elt.style.width = this.width + \"px\";\n        elt.style.height = this.height + \"px\";\n    }\n    eq(p) {\n        return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;\n    }\n    /**\n    Create a set of rectangles for the given selection range,\n    assigning them theclass`className`. Will create a single\n    rectangle for empty ranges, and a set of selection-style\n    rectangles covering the range's content (in a bidi-aware\n    way) for non-empty ones.\n    */ static forRange(view, className, range) {\n        if (range.empty) {\n            let pos = view.coordsAtPos(range.head, range.assoc || 1);\n            if (!pos) return [];\n            let base = getBase(view);\n            return [\n                new RectangleMarker(className, pos.left - base.left, pos.top - base.top, null, pos.bottom - pos.top)\n            ];\n        } else {\n            return rectanglesForRange(view, className, range);\n        }\n    }\n}\nfunction getBase(view) {\n    let rect = view.scrollDOM.getBoundingClientRect();\n    let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth * view.scaleX;\n    return {\n        left: left - view.scrollDOM.scrollLeft * view.scaleX,\n        top: rect.top - view.scrollDOM.scrollTop * view.scaleY\n    };\n}\nfunction wrappedLine(view, pos, inside) {\n    let range = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos);\n    return {\n        from: Math.max(inside.from, view.moveToLineBoundary(range, false, true).from),\n        to: Math.min(inside.to, view.moveToLineBoundary(range, true, true).from),\n        type: BlockType.Text\n    };\n}\nfunction rectanglesForRange(view, className, range) {\n    if (range.to <= view.viewport.from || range.from >= view.viewport.to) return [];\n    let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);\n    let ltr = view.textDirection == Direction.LTR;\n    let content = view.contentDOM, contentRect = content.getBoundingClientRect(), base = getBase(view);\n    let lineElt = content.querySelector(\".cm-line\"), lineStyle = lineElt && window.getComputedStyle(lineElt);\n    let leftSide = contentRect.left + (lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0);\n    let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0);\n    let startBlock = blockAt(view, from), endBlock = blockAt(view, to);\n    let visualStart = startBlock.type == BlockType.Text ? startBlock : null;\n    let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;\n    if (visualStart && (view.lineWrapping || startBlock.widgetLineBreaks)) visualStart = wrappedLine(view, from, visualStart);\n    if (visualEnd && (view.lineWrapping || endBlock.widgetLineBreaks)) visualEnd = wrappedLine(view, to, visualEnd);\n    if (visualStart && visualEnd && visualStart.from == visualEnd.from) {\n        return pieces(drawForLine(range.from, range.to, visualStart));\n    } else {\n        let top = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);\n        let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);\n        let between = [];\n        if ((visualStart || startBlock).to < (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) || startBlock.widgetLineBreaks > 1 && top.bottom + view.defaultLineHeight / 2 < bottom.top) between.push(piece(leftSide, top.bottom, rightSide, bottom.top));\n        else if (top.bottom < bottom.top && view.elementAtHeight((top.bottom + bottom.top) / 2).type == BlockType.Text) top.bottom = bottom.top = (top.bottom + bottom.top) / 2;\n        return pieces(top).concat(between).concat(pieces(bottom));\n    }\n    function piece(left, top, right, bottom) {\n        return new RectangleMarker(className, left - base.left, top - base.top - 0.01 /* C.Epsilon */ , right - left, bottom - top + 0.01 /* C.Epsilon */ );\n    }\n    function pieces({ top, bottom, horizontal }) {\n        let pieces = [];\n        for(let i = 0; i < horizontal.length; i += 2)pieces.push(piece(horizontal[i], top, horizontal[i + 1], bottom));\n        return pieces;\n    }\n    // Gets passed from/to in line-local positions\n    function drawForLine(from, to, line) {\n        let top = 1e9, bottom = -1e9, horizontal = [];\n        function addSpan(from, fromOpen, to, toOpen, dir) {\n            // Passing 2/-2 is a kludge to force the view to return\n            // coordinates on the proper side of block widgets, since\n            // normalizing the side there, though appropriate for most\n            // coordsAtPos queries, would break selection drawing.\n            let fromCoords = view.coordsAtPos(from, from == line.to ? -2 : 2);\n            let toCoords = view.coordsAtPos(to, to == line.from ? 2 : -2);\n            if (!fromCoords || !toCoords) return;\n            top = Math.min(fromCoords.top, toCoords.top, top);\n            bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);\n            if (dir == Direction.LTR) horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);\n            else horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);\n        }\n        let start = from !== null && from !== void 0 ? from : line.from, end = to !== null && to !== void 0 ? to : line.to;\n        // Split the range by visible range and document line\n        for (let r of view.visibleRanges)if (r.to > start && r.from < end) {\n            for(let pos = Math.max(r.from, start), endPos = Math.min(r.to, end);;){\n                let docLine = view.state.doc.lineAt(pos);\n                for (let span of view.bidiSpans(docLine)){\n                    let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;\n                    if (spanFrom >= endPos) break;\n                    if (spanTo > pos) addSpan(Math.max(spanFrom, pos), from == null && spanFrom <= start, Math.min(spanTo, endPos), to == null && spanTo >= end, span.dir);\n                }\n                pos = docLine.to + 1;\n                if (pos >= endPos) break;\n            }\n        }\n        if (horizontal.length == 0) addSpan(start, from == null, end, to == null, view.textDirection);\n        return {\n            top,\n            bottom,\n            horizontal\n        };\n    }\n    function drawForWidget(block, top) {\n        let y = contentRect.top + (top ? block.top : block.bottom);\n        return {\n            top: y,\n            bottom: y,\n            horizontal: []\n        };\n    }\n}\nfunction sameMarker(a, b) {\n    return a.constructor == b.constructor && a.eq(b);\n}\nclass LayerView {\n    constructor(view, layer){\n        this.view = view;\n        this.layer = layer;\n        this.drawn = [];\n        this.scaleX = 1;\n        this.scaleY = 1;\n        this.measureReq = {\n            read: this.measure.bind(this),\n            write: this.draw.bind(this)\n        };\n        this.dom = view.scrollDOM.appendChild(document.createElement(\"div\"));\n        this.dom.classList.add(\"cm-layer\");\n        if (layer.above) this.dom.classList.add(\"cm-layer-above\");\n        if (layer.class) this.dom.classList.add(layer.class);\n        this.scale();\n        this.dom.setAttribute(\"aria-hidden\", \"true\");\n        this.setOrder(view.state);\n        view.requestMeasure(this.measureReq);\n        if (layer.mount) layer.mount(this.dom, view);\n    }\n    update(update) {\n        if (update.startState.facet(layerOrder) != update.state.facet(layerOrder)) this.setOrder(update.state);\n        if (this.layer.update(update, this.dom) || update.geometryChanged) {\n            this.scale();\n            update.view.requestMeasure(this.measureReq);\n        }\n    }\n    setOrder(state) {\n        let pos = 0, order = state.facet(layerOrder);\n        while(pos < order.length && order[pos] != this.layer)pos++;\n        this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);\n    }\n    measure() {\n        return this.layer.markers(this.view);\n    }\n    scale() {\n        let { scaleX, scaleY } = this.view;\n        if (scaleX != this.scaleX || scaleY != this.scaleY) {\n            this.scaleX = scaleX;\n            this.scaleY = scaleY;\n            this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`;\n        }\n    }\n    draw(markers) {\n        if (markers.length != this.drawn.length || markers.some((p, i)=>!sameMarker(p, this.drawn[i]))) {\n            let old = this.dom.firstChild, oldI = 0;\n            for (let marker of markers){\n                if (marker.update && old && marker.constructor && this.drawn[oldI].constructor && marker.update(old, this.drawn[oldI])) {\n                    old = old.nextSibling;\n                    oldI++;\n                } else {\n                    this.dom.insertBefore(marker.draw(), old);\n                }\n            }\n            while(old){\n                let next = old.nextSibling;\n                old.remove();\n                old = next;\n            }\n            this.drawn = markers;\n        }\n    }\n    destroy() {\n        if (this.layer.destroy) this.layer.destroy(this.dom, this.view);\n        this.dom.remove();\n    }\n}\nconst layerOrder = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\n/**\nDefine a layer.\n*/ function layer(config) {\n    return [\n        ViewPlugin.define((v)=>new LayerView(v, config)),\n        layerOrder.of(config)\n    ];\n}\nconst CanHidePrimary = !browser.ios; // FIXME test IE\nconst selectionConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(configs, {\n            cursorBlinkRate: 1200,\n            drawRangeCursor: true\n        }, {\n            cursorBlinkRate: (a, b)=>Math.min(a, b),\n            drawRangeCursor: (a, b)=>a || b\n        });\n    }\n});\n/**\nReturns an extension that hides the browser's native selection and\ncursor, replacing the selection with a background behind the text\n(with the `cm-selectionBackground` class), and the\ncursors with elements overlaid over the code (using\n`cm-cursor-primary` and `cm-cursor-secondary`).\n\nThis allows the editor to display secondary selection ranges, and\ntends to produce a type of selection more in line with that users\nexpect in a text editor (the native selection styling will often\nleave gaps between lines and won't fill the horizontal space after\na line when the selection continues past it).\n\nIt does have a performance cost, in that it requires an extra DOM\nlayout cycle for many updates (the selection is drawn based on DOM\nlayout information that's only available after laying out the\ncontent).\n*/ function drawSelection(config = {}) {\n    return [\n        selectionConfig.of(config),\n        cursorLayer,\n        selectionLayer,\n        hideNativeSelection,\n        nativeSelectionHidden.of(true)\n    ];\n}\n/**\nRetrieve the [`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) configuration\nfor this state. (Note that this will return a set of defaults even\nif `drawSelection` isn't enabled.)\n*/ function getDrawSelectionConfig(state) {\n    return state.facet(selectionConfig);\n}\nfunction configChanged(update) {\n    return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);\n}\nconst cursorLayer = /*@__PURE__*/ layer({\n    above: true,\n    markers (view) {\n        let { state } = view, conf = state.facet(selectionConfig);\n        let cursors = [];\n        for (let r of state.selection.ranges){\n            let prim = r == state.selection.main;\n            if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {\n                let className = prim ? \"cm-cursor cm-cursor-primary\" : \"cm-cursor cm-cursor-secondary\";\n                let cursor = r.empty ? r : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(r.head, r.head > r.anchor ? -1 : 1);\n                for (let piece of RectangleMarker.forRange(view, className, cursor))cursors.push(piece);\n            }\n        }\n        return cursors;\n    },\n    update (update, dom) {\n        if (update.transactions.some((tr)=>tr.selection)) dom.style.animationName = dom.style.animationName == \"cm-blink\" ? \"cm-blink2\" : \"cm-blink\";\n        let confChange = configChanged(update);\n        if (confChange) setBlinkRate(update.state, dom);\n        return update.docChanged || update.selectionSet || confChange;\n    },\n    mount (dom, view) {\n        setBlinkRate(view.state, dom);\n    },\n    class: \"cm-cursorLayer\"\n});\nfunction setBlinkRate(state, dom) {\n    dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + \"ms\";\n}\nconst selectionLayer = /*@__PURE__*/ layer({\n    above: false,\n    markers (view) {\n        return view.state.selection.ranges.map((r)=>r.empty ? [] : RectangleMarker.forRange(view, \"cm-selectionBackground\", r)).reduce((a, b)=>a.concat(b));\n    },\n    update (update, dom) {\n        return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);\n    },\n    class: \"cm-selectionLayer\"\n});\nconst themeSpec = {\n    \".cm-line\": {\n        \"& ::selection\": {\n            backgroundColor: \"transparent !important\"\n        },\n        \"&::selection\": {\n            backgroundColor: \"transparent !important\"\n        }\n    }\n};\nif (CanHidePrimary) {\n    themeSpec[\".cm-line\"].caretColor = \"transparent !important\";\n    themeSpec[\".cm-content\"] = {\n        caretColor: \"transparent !important\"\n    };\n}\nconst hideNativeSelection = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec.highest(/*@__PURE__*/ EditorView.theme(themeSpec));\nconst setDropCursorPos = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define({\n    map (pos, mapping) {\n        return pos == null ? null : mapping.mapPos(pos);\n    }\n});\nconst dropCursorPos = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n    create () {\n        return null;\n    },\n    update (pos, tr) {\n        if (pos != null) pos = tr.changes.mapPos(pos);\n        return tr.effects.reduce((pos, e)=>e.is(setDropCursorPos) ? e.value : pos, pos);\n    }\n});\nconst drawDropCursor = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.cursor = null;\n        this.measureReq = {\n            read: this.readPos.bind(this),\n            write: this.drawCursor.bind(this)\n        };\n    }\n    update(update) {\n        var _a;\n        let cursorPos = update.state.field(dropCursorPos);\n        if (cursorPos == null) {\n            if (this.cursor != null) {\n                (_a = this.cursor) === null || _a === void 0 ? void 0 : _a.remove();\n                this.cursor = null;\n            }\n        } else {\n            if (!this.cursor) {\n                this.cursor = this.view.scrollDOM.appendChild(document.createElement(\"div\"));\n                this.cursor.className = \"cm-dropCursor\";\n            }\n            if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged) this.view.requestMeasure(this.measureReq);\n        }\n    }\n    readPos() {\n        let { view } = this;\n        let pos = view.state.field(dropCursorPos);\n        let rect = pos != null && view.coordsAtPos(pos);\n        if (!rect) return null;\n        let outer = view.scrollDOM.getBoundingClientRect();\n        return {\n            left: rect.left - outer.left + view.scrollDOM.scrollLeft * view.scaleX,\n            top: rect.top - outer.top + view.scrollDOM.scrollTop * view.scaleY,\n            height: rect.bottom - rect.top\n        };\n    }\n    drawCursor(pos) {\n        if (this.cursor) {\n            let { scaleX, scaleY } = this.view;\n            if (pos) {\n                this.cursor.style.left = pos.left / scaleX + \"px\";\n                this.cursor.style.top = pos.top / scaleY + \"px\";\n                this.cursor.style.height = pos.height / scaleY + \"px\";\n            } else {\n                this.cursor.style.left = \"-100000px\";\n            }\n        }\n    }\n    destroy() {\n        if (this.cursor) this.cursor.remove();\n    }\n    setDropPos(pos) {\n        if (this.view.state.field(dropCursorPos) != pos) this.view.dispatch({\n            effects: setDropCursorPos.of(pos)\n        });\n    }\n}, {\n    eventObservers: {\n        dragover (event) {\n            this.setDropPos(this.view.posAtCoords({\n                x: event.clientX,\n                y: event.clientY\n            }));\n        },\n        dragleave (event) {\n            if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget)) this.setDropPos(null);\n        },\n        dragend () {\n            this.setDropPos(null);\n        },\n        drop () {\n            this.setDropPos(null);\n        }\n    }\n});\n/**\nDraws a cursor at the current drop position when something is\ndragged over the editor.\n*/ function dropCursor() {\n    return [\n        dropCursorPos,\n        drawDropCursor\n    ];\n}\nfunction iterMatches(doc, re, from, to, f) {\n    re.lastIndex = 0;\n    for(let cursor = doc.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length){\n        if (!cursor.lineBreak) while(m = re.exec(cursor.value))f(pos + m.index, m);\n    }\n}\nfunction matchRanges(view, maxLength) {\n    let visible = view.visibleRanges;\n    if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to) return visible;\n    let result = [];\n    for (let { from, to } of visible){\n        from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);\n        to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);\n        if (result.length && result[result.length - 1].to >= from) result[result.length - 1].to = to;\n        else result.push({\n            from,\n            to\n        });\n    }\n    return result;\n}\n/**\nHelper class used to make it easier to maintain decorations on\nvisible code that matches a given regular expression. To be used\nin a [view plugin](https://codemirror.net/6/docs/ref/#view.ViewPlugin). Instances of this object\nrepresent a matching configuration.\n*/ class MatchDecorator {\n    /**\n    Create a decorator.\n    */ constructor(config){\n        const { regexp, decoration, decorate, boundary, maxLength = 1000 } = config;\n        if (!regexp.global) throw new RangeError(\"The regular expression given to MatchDecorator should have its 'g' flag set\");\n        this.regexp = regexp;\n        if (decorate) {\n            this.addMatch = (match, view, from, add)=>decorate(add, from, from + match[0].length, match, view);\n        } else if (typeof decoration == \"function\") {\n            this.addMatch = (match, view, from, add)=>{\n                let deco = decoration(match, view, from);\n                if (deco) add(from, from + match[0].length, deco);\n            };\n        } else if (decoration) {\n            this.addMatch = (match, _view, from, add)=>add(from, from + match[0].length, decoration);\n        } else {\n            throw new RangeError(\"Either 'decorate' or 'decoration' should be provided to MatchDecorator\");\n        }\n        this.boundary = boundary;\n        this.maxLength = maxLength;\n    }\n    /**\n    Compute the full set of decorations for matches in the given\n    view's viewport. You'll want to call this when initializing your\n    plugin.\n    */ createDeco(view) {\n        let build = new _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSetBuilder(), add = build.add.bind(build);\n        for (let { from, to } of matchRanges(view, this.maxLength))iterMatches(view.state.doc, this.regexp, from, to, (from, m)=>this.addMatch(m, view, from, add));\n        return build.finish();\n    }\n    /**\n    Update a set of decorations for a view update. `deco` _must_ be\n    the set of decorations produced by _this_ `MatchDecorator` for\n    the view state before the update.\n    */ updateDeco(update, deco) {\n        let changeFrom = 1e9, changeTo = -1;\n        if (update.docChanged) update.changes.iterChanges((_f, _t, from, to)=>{\n            if (to > update.view.viewport.from && from < update.view.viewport.to) {\n                changeFrom = Math.min(from, changeFrom);\n                changeTo = Math.max(to, changeTo);\n            }\n        });\n        if (update.viewportChanged || changeTo - changeFrom > 1000) return this.createDeco(update.view);\n        if (changeTo > -1) return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);\n        return deco;\n    }\n    updateRange(view, deco, updateFrom, updateTo) {\n        for (let r of view.visibleRanges){\n            let from = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);\n            if (to > from) {\n                let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;\n                let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);\n                if (this.boundary) {\n                    for(; from > fromLine.from; from--)if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {\n                        start = from;\n                        break;\n                    }\n                    for(; to < toLine.to; to++)if (this.boundary.test(toLine.text[to - toLine.from])) {\n                        end = to;\n                        break;\n                    }\n                }\n                let ranges = [], m;\n                let add = (from, to, deco)=>ranges.push(deco.range(from, to));\n                if (fromLine == toLine) {\n                    this.regexp.lastIndex = start - fromLine.from;\n                    while((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from)this.addMatch(m, view, m.index + fromLine.from, add);\n                } else {\n                    iterMatches(view.state.doc, this.regexp, start, end, (from, m)=>this.addMatch(m, view, from, add));\n                }\n                deco = deco.update({\n                    filterFrom: start,\n                    filterTo: end,\n                    filter: (from, to)=>from < start || to > end,\n                    add: ranges\n                });\n            }\n        }\n        return deco;\n    }\n}\nconst UnicodeRegexpSupport = /x/.unicode != null ? \"gu\" : \"g\";\nconst Specials = /*@__PURE__*/ new RegExp(\"[\\x00-\\b\\n-\\x1f\\x7f-\\x9f\\xad؜​‎‏\\u2028\\u2029‭‮⁦⁧⁩\\uFEFF￹-￼]\", UnicodeRegexpSupport);\nconst Names = {\n    0: \"null\",\n    7: \"bell\",\n    8: \"backspace\",\n    10: \"newline\",\n    11: \"vertical tab\",\n    13: \"carriage return\",\n    27: \"escape\",\n    8203: \"zero width space\",\n    8204: \"zero width non-joiner\",\n    8205: \"zero width joiner\",\n    8206: \"left-to-right mark\",\n    8207: \"right-to-left mark\",\n    8232: \"line separator\",\n    8237: \"left-to-right override\",\n    8238: \"right-to-left override\",\n    8294: \"left-to-right isolate\",\n    8295: \"right-to-left isolate\",\n    8297: \"pop directional isolate\",\n    8233: \"paragraph separator\",\n    65279: \"zero width no-break space\",\n    65532: \"object replacement\"\n};\nlet _supportsTabSize = null;\nfunction supportsTabSize() {\n    var _a;\n    if (_supportsTabSize == null && typeof document != \"undefined\" && document.body) {\n        let styles = document.body.style;\n        _supportsTabSize = ((_a = styles.tabSize) !== null && _a !== void 0 ? _a : styles.MozTabSize) != null;\n    }\n    return _supportsTabSize || false;\n}\nconst specialCharConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine (configs) {\n        let config = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(configs, {\n            render: null,\n            specialChars: Specials,\n            addSpecialChars: null\n        });\n        if (config.replaceTabs = !supportsTabSize()) config.specialChars = new RegExp(\"\t|\" + config.specialChars.source, UnicodeRegexpSupport);\n        if (config.addSpecialChars) config.specialChars = new RegExp(config.specialChars.source + \"|\" + config.addSpecialChars.source, UnicodeRegexpSupport);\n        return config;\n    }\n});\n/**\nReturns an extension that installs highlighting of special\ncharacters.\n*/ function highlightSpecialChars(/**\nConfiguration options.\n*/ config = {}) {\n    return [\n        specialCharConfig.of(config),\n        specialCharPlugin()\n    ];\n}\nlet _plugin = null;\nfunction specialCharPlugin() {\n    return _plugin || (_plugin = ViewPlugin.fromClass(class {\n        constructor(view){\n            this.view = view;\n            this.decorations = Decoration.none;\n            this.decorationCache = Object.create(null);\n            this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));\n            this.decorations = this.decorator.createDeco(view);\n        }\n        makeDecorator(conf) {\n            return new MatchDecorator({\n                regexp: conf.specialChars,\n                decoration: (m, view, pos)=>{\n                    let { doc } = view.state;\n                    let code = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.codePointAt)(m[0], 0);\n                    if (code == 9) {\n                        let line = doc.lineAt(pos);\n                        let size = view.state.tabSize, col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.countColumn)(line.text, size, pos - line.from);\n                        return Decoration.replace({\n                            widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth / this.view.scaleX)\n                        });\n                    }\n                    return this.decorationCache[code] || (this.decorationCache[code] = Decoration.replace({\n                        widget: new SpecialCharWidget(conf, code)\n                    }));\n                },\n                boundary: conf.replaceTabs ? undefined : /[^]/\n            });\n        }\n        update(update) {\n            let conf = update.state.facet(specialCharConfig);\n            if (update.startState.facet(specialCharConfig) != conf) {\n                this.decorator = this.makeDecorator(conf);\n                this.decorations = this.decorator.createDeco(update.view);\n            } else {\n                this.decorations = this.decorator.updateDeco(update, this.decorations);\n            }\n        }\n    }, {\n        decorations: (v)=>v.decorations\n    }));\n}\nconst DefaultPlaceholder = \"•\";\n// Assigns placeholder characters from the Control Pictures block to\n// ASCII control characters\nfunction placeholder$1(code) {\n    if (code >= 32) return DefaultPlaceholder;\n    if (code == 10) return \"␤\";\n    return String.fromCharCode(9216 + code);\n}\nclass SpecialCharWidget extends WidgetType {\n    constructor(options, code){\n        super();\n        this.options = options;\n        this.code = code;\n    }\n    eq(other) {\n        return other.code == this.code;\n    }\n    toDOM(view) {\n        let ph = placeholder$1(this.code);\n        let desc = view.state.phrase(\"Control character\") + \" \" + (Names[this.code] || \"0x\" + this.code.toString(16));\n        let custom = this.options.render && this.options.render(this.code, desc, ph);\n        if (custom) return custom;\n        let span = document.createElement(\"span\");\n        span.textContent = ph;\n        span.title = desc;\n        span.setAttribute(\"aria-label\", desc);\n        span.className = \"cm-specialChar\";\n        return span;\n    }\n    ignoreEvent() {\n        return false;\n    }\n}\nclass TabWidget extends WidgetType {\n    constructor(width){\n        super();\n        this.width = width;\n    }\n    eq(other) {\n        return other.width == this.width;\n    }\n    toDOM() {\n        let span = document.createElement(\"span\");\n        span.textContent = \"\t\";\n        span.className = \"cm-tab\";\n        span.style.width = this.width + \"px\";\n        return span;\n    }\n    ignoreEvent() {\n        return false;\n    }\n}\nconst plugin = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(){\n        this.height = 1000;\n        this.attrs = {\n            style: \"padding-bottom: 1000px\"\n        };\n    }\n    update(update) {\n        let { view } = update;\n        let height = view.viewState.editorHeight * view.scaleY - view.defaultLineHeight - view.documentPadding.top - 0.5;\n        if (height >= 0 && height != this.height) {\n            this.height = height;\n            this.attrs = {\n                style: `padding-bottom: ${height}px`\n            };\n        }\n    }\n});\n/**\nReturns an extension that makes sure the content has a bottom\nmargin equivalent to the height of the editor, minus one line\nheight, so that every line in the document can be scrolled to the\ntop of the editor.\n\nThis is only meaningful when the editor is scrollable, and should\nnot be enabled in editors that take the size of their content.\n*/ function scrollPastEnd() {\n    return [\n        plugin,\n        contentAttributes.of((view)=>{\n            var _a;\n            return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.attrs) || null;\n        })\n    ];\n}\n/**\nMark lines that have a cursor on them with the `\"cm-activeLine\"`\nDOM class.\n*/ function highlightActiveLine() {\n    return activeLineHighlighter;\n}\nconst lineDeco = /*@__PURE__*/ Decoration.line({\n    class: \"cm-activeLine\"\n});\nconst activeLineHighlighter = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(view){\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.docChanged || update.selectionSet) this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let lastLineStart = -1, deco = [];\n        for (let r of view.state.selection.ranges){\n            let line = view.lineBlockAt(r.head);\n            if (line.from > lastLineStart) {\n                deco.push(lineDeco.range(line.from));\n                lastLineStart = line.from;\n            }\n        }\n        return Decoration.set(deco);\n    }\n}, {\n    decorations: (v)=>v.decorations\n});\nclass Placeholder extends WidgetType {\n    constructor(content){\n        super();\n        this.content = content;\n    }\n    toDOM() {\n        let wrap = document.createElement(\"span\");\n        wrap.className = \"cm-placeholder\";\n        wrap.style.pointerEvents = \"none\";\n        wrap.appendChild(typeof this.content == \"string\" ? document.createTextNode(this.content) : this.content);\n        if (typeof this.content == \"string\") wrap.setAttribute(\"aria-label\", \"placeholder \" + this.content);\n        else wrap.setAttribute(\"aria-hidden\", \"true\");\n        return wrap;\n    }\n    coordsAt(dom) {\n        let rects = dom.firstChild ? clientRectsFor(dom.firstChild) : [];\n        if (!rects.length) return null;\n        let style = window.getComputedStyle(dom.parentNode);\n        let rect = flattenRect(rects[0], style.direction != \"rtl\");\n        let lineHeight = parseInt(style.lineHeight);\n        if (rect.bottom - rect.top > lineHeight * 1.5) return {\n            left: rect.left,\n            right: rect.right,\n            top: rect.top,\n            bottom: rect.top + lineHeight\n        };\n        return rect;\n    }\n    ignoreEvent() {\n        return false;\n    }\n}\n/**\nExtension that enables a placeholder—a piece of example content\nto show when the editor is empty.\n*/ function placeholder(content) {\n    return ViewPlugin.fromClass(class {\n        constructor(view){\n            this.view = view;\n            this.placeholder = content ? Decoration.set([\n                Decoration.widget({\n                    widget: new Placeholder(content),\n                    side: 1\n                }).range(0)\n            ]) : Decoration.none;\n        }\n        get decorations() {\n            return this.view.state.doc.length ? Decoration.none : this.placeholder;\n        }\n    }, {\n        decorations: (v)=>v.decorations\n    });\n}\n// Don't compute precise column positions for line offsets above this\n// (since it could get expensive). Assume offset==column for them.\nconst MaxOff = 2000;\nfunction rectangleFor(state, a, b) {\n    let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);\n    let ranges = [];\n    if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {\n        let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);\n        for(let i = startLine; i <= endLine; i++){\n            let line = state.doc.line(i);\n            if (line.length <= endOff) ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(line.from + startOff, line.to + endOff));\n        }\n    } else {\n        let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);\n        for(let i = startLine; i <= endLine; i++){\n            let line = state.doc.line(i);\n            let start = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findColumn)(line.text, startCol, state.tabSize, true);\n            if (start < 0) {\n                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(line.to));\n            } else {\n                let end = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findColumn)(line.text, endCol, state.tabSize);\n                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(line.from + start, line.from + end));\n            }\n        }\n    }\n    return ranges;\n}\nfunction absoluteColumn(view, x) {\n    let ref = view.coordsAtPos(view.viewport.from);\n    return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;\n}\nfunction getPos(view, event) {\n    let offset = view.posAtCoords({\n        x: event.clientX,\n        y: event.clientY\n    }, false);\n    let line = view.state.doc.lineAt(offset), off = offset - line.from;\n    let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.countColumn)(line.text, view.state.tabSize, offset - line.from);\n    return {\n        line: line.number,\n        col,\n        off\n    };\n}\nfunction rectangleSelectionStyle(view, event) {\n    let start = getPos(view, event), startSel = view.state.selection;\n    if (!start) return null;\n    return {\n        update (update) {\n            if (update.docChanged) {\n                let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);\n                let newLine = update.state.doc.lineAt(newStart);\n                start = {\n                    line: newLine.number,\n                    col: start.col,\n                    off: Math.min(start.off, newLine.length)\n                };\n                startSel = startSel.map(update.changes);\n            }\n        },\n        get (event, _extend, multiple) {\n            let cur = getPos(view, event);\n            if (!cur) return startSel;\n            let ranges = rectangleFor(view.state, start, cur);\n            if (!ranges.length) return startSel;\n            if (multiple) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(ranges.concat(startSel.ranges));\n            else return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(ranges);\n        }\n    };\n}\n/**\nCreate an extension that enables rectangular selections. By\ndefault, it will react to left mouse drag with the Alt key held\ndown. When such a selection occurs, the text within the rectangle\nthat was dragged over will be selected, as one selection\n[range](https://codemirror.net/6/docs/ref/#state.SelectionRange) per line.\n*/ function rectangularSelection(options) {\n    let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || ((e)=>e.altKey && e.button == 0);\n    return EditorView.mouseSelectionStyle.of((view, event)=>filter(event) ? rectangleSelectionStyle(view, event) : null);\n}\nconst keys = {\n    Alt: [\n        18,\n        (e)=>!!e.altKey\n    ],\n    Control: [\n        17,\n        (e)=>!!e.ctrlKey\n    ],\n    Shift: [\n        16,\n        (e)=>!!e.shiftKey\n    ],\n    Meta: [\n        91,\n        (e)=>!!e.metaKey\n    ]\n};\nconst showCrosshair = {\n    style: \"cursor: crosshair\"\n};\n/**\nReturns an extension that turns the pointer cursor into a\ncrosshair when a given modifier key, defaulting to Alt, is held\ndown. Can serve as a visual hint that rectangular selection is\ngoing to happen when paired with\n[`rectangularSelection`](https://codemirror.net/6/docs/ref/#view.rectangularSelection).\n*/ function crosshairCursor(options = {}) {\n    let [code, getter] = keys[options.key || \"Alt\"];\n    let plugin = ViewPlugin.fromClass(class {\n        constructor(view){\n            this.view = view;\n            this.isDown = false;\n        }\n        set(isDown) {\n            if (this.isDown != isDown) {\n                this.isDown = isDown;\n                this.view.update([]);\n            }\n        }\n    }, {\n        eventObservers: {\n            keydown (e) {\n                this.set(e.keyCode == code || getter(e));\n            },\n            keyup (e) {\n                if (e.keyCode == code || !getter(e)) this.set(false);\n            },\n            mousemove (e) {\n                this.set(getter(e));\n            }\n        }\n    });\n    return [\n        plugin,\n        EditorView.contentAttributes.of((view)=>{\n            var _a;\n            return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.isDown) ? showCrosshair : null;\n        })\n    ];\n}\nconst Outside = \"-10000px\";\nclass TooltipViewManager {\n    constructor(view, facet, createTooltipView, removeTooltipView){\n        this.facet = facet;\n        this.createTooltipView = createTooltipView;\n        this.removeTooltipView = removeTooltipView;\n        this.input = view.state.facet(facet);\n        this.tooltips = this.input.filter((t)=>t);\n        this.tooltipViews = this.tooltips.map(createTooltipView);\n    }\n    update(update, above) {\n        var _a;\n        let input = update.state.facet(this.facet);\n        let tooltips = input.filter((x)=>x);\n        if (input === this.input) {\n            for (let t of this.tooltipViews)if (t.update) t.update(update);\n            return false;\n        }\n        let tooltipViews = [], newAbove = above ? [] : null;\n        for(let i = 0; i < tooltips.length; i++){\n            let tip = tooltips[i], known = -1;\n            if (!tip) continue;\n            for(let i = 0; i < this.tooltips.length; i++){\n                let other = this.tooltips[i];\n                if (other && other.create == tip.create) known = i;\n            }\n            if (known < 0) {\n                tooltipViews[i] = this.createTooltipView(tip);\n                if (newAbove) newAbove[i] = !!tip.above;\n            } else {\n                let tooltipView = tooltipViews[i] = this.tooltipViews[known];\n                if (newAbove) newAbove[i] = above[known];\n                if (tooltipView.update) tooltipView.update(update);\n            }\n        }\n        for (let t of this.tooltipViews)if (tooltipViews.indexOf(t) < 0) {\n            this.removeTooltipView(t);\n            (_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);\n        }\n        if (above) {\n            newAbove.forEach((val, i)=>above[i] = val);\n            above.length = newAbove.length;\n        }\n        this.input = input;\n        this.tooltips = tooltips;\n        this.tooltipViews = tooltipViews;\n        return true;\n    }\n}\n/**\nCreates an extension that configures tooltip behavior.\n*/ function tooltips(config = {}) {\n    return tooltipConfig.of(config);\n}\nfunction windowSpace(view) {\n    let { win } = view;\n    return {\n        top: 0,\n        left: 0,\n        bottom: win.innerHeight,\n        right: win.innerWidth\n    };\n}\nconst tooltipConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (values)=>{\n        var _a, _b, _c;\n        return {\n            position: browser.ios ? \"absolute\" : ((_a = values.find((conf)=>conf.position)) === null || _a === void 0 ? void 0 : _a.position) || \"fixed\",\n            parent: ((_b = values.find((conf)=>conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,\n            tooltipSpace: ((_c = values.find((conf)=>conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace\n        };\n    }\n});\nconst knownHeight = /*@__PURE__*/ new WeakMap();\nconst tooltipPlugin = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.above = [];\n        this.inView = true;\n        this.madeAbsolute = false;\n        this.lastTransaction = 0;\n        this.measureTimeout = -1;\n        let config = view.state.facet(tooltipConfig);\n        this.position = config.position;\n        this.parent = config.parent;\n        this.classes = view.themeClasses;\n        this.createContainer();\n        this.measureReq = {\n            read: this.readMeasure.bind(this),\n            write: this.writeMeasure.bind(this),\n            key: this\n        };\n        this.resizeObserver = typeof ResizeObserver == \"function\" ? new ResizeObserver(()=>this.measureSoon()) : null;\n        this.manager = new TooltipViewManager(view, showTooltip, (t)=>this.createTooltip(t), (t)=>{\n            if (this.resizeObserver) this.resizeObserver.unobserve(t.dom);\n            t.dom.remove();\n        });\n        this.above = this.manager.tooltips.map((t)=>!!t.above);\n        this.intersectionObserver = typeof IntersectionObserver == \"function\" ? new IntersectionObserver((entries)=>{\n            if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1) this.measureSoon();\n        }, {\n            threshold: [\n                1\n            ]\n        }) : null;\n        this.observeIntersection();\n        view.win.addEventListener(\"resize\", this.measureSoon = this.measureSoon.bind(this));\n        this.maybeMeasure();\n    }\n    createContainer() {\n        if (this.parent) {\n            this.container = document.createElement(\"div\");\n            this.container.style.position = \"relative\";\n            this.container.className = this.view.themeClasses;\n            this.parent.appendChild(this.container);\n        } else {\n            this.container = this.view.dom;\n        }\n    }\n    observeIntersection() {\n        if (this.intersectionObserver) {\n            this.intersectionObserver.disconnect();\n            for (let tooltip of this.manager.tooltipViews)this.intersectionObserver.observe(tooltip.dom);\n        }\n    }\n    measureSoon() {\n        if (this.measureTimeout < 0) this.measureTimeout = setTimeout(()=>{\n            this.measureTimeout = -1;\n            this.maybeMeasure();\n        }, 50);\n    }\n    update(update) {\n        if (update.transactions.length) this.lastTransaction = Date.now();\n        let updated = this.manager.update(update, this.above);\n        if (updated) this.observeIntersection();\n        let shouldMeasure = updated || update.geometryChanged;\n        let newConfig = update.state.facet(tooltipConfig);\n        if (newConfig.position != this.position && !this.madeAbsolute) {\n            this.position = newConfig.position;\n            for (let t of this.manager.tooltipViews)t.dom.style.position = this.position;\n            shouldMeasure = true;\n        }\n        if (newConfig.parent != this.parent) {\n            if (this.parent) this.container.remove();\n            this.parent = newConfig.parent;\n            this.createContainer();\n            for (let t of this.manager.tooltipViews)this.container.appendChild(t.dom);\n            shouldMeasure = true;\n        } else if (this.parent && this.view.themeClasses != this.classes) {\n            this.classes = this.container.className = this.view.themeClasses;\n        }\n        if (shouldMeasure) this.maybeMeasure();\n    }\n    createTooltip(tooltip) {\n        let tooltipView = tooltip.create(this.view);\n        tooltipView.dom.classList.add(\"cm-tooltip\");\n        if (tooltip.arrow && !tooltipView.dom.querySelector(\".cm-tooltip > .cm-tooltip-arrow\")) {\n            let arrow = document.createElement(\"div\");\n            arrow.className = \"cm-tooltip-arrow\";\n            tooltipView.dom.appendChild(arrow);\n        }\n        tooltipView.dom.style.position = this.position;\n        tooltipView.dom.style.top = Outside;\n        tooltipView.dom.style.left = \"0px\";\n        this.container.appendChild(tooltipView.dom);\n        if (tooltipView.mount) tooltipView.mount(this.view);\n        if (this.resizeObserver) this.resizeObserver.observe(tooltipView.dom);\n        return tooltipView;\n    }\n    destroy() {\n        var _a, _b, _c;\n        this.view.win.removeEventListener(\"resize\", this.measureSoon);\n        for (let tooltipView of this.manager.tooltipViews){\n            tooltipView.dom.remove();\n            (_a = tooltipView.destroy) === null || _a === void 0 ? void 0 : _a.call(tooltipView);\n        }\n        if (this.parent) this.container.remove();\n        (_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();\n        (_c = this.intersectionObserver) === null || _c === void 0 ? void 0 : _c.disconnect();\n        clearTimeout(this.measureTimeout);\n    }\n    readMeasure() {\n        let editor = this.view.dom.getBoundingClientRect();\n        let scaleX = 1, scaleY = 1, makeAbsolute = false;\n        if (this.position == \"fixed\" && this.manager.tooltipViews.length) {\n            let { dom } = this.manager.tooltipViews[0];\n            if (browser.gecko) {\n                // Firefox sets the element's `offsetParent` to the\n                // transformed element when a transform interferes with fixed\n                // positioning.\n                makeAbsolute = dom.offsetParent != this.container.ownerDocument.body;\n            } else if (dom.style.top == Outside && dom.style.left == \"0px\") {\n                // On other browsers, we have to awkwardly try and use other\n                // information to detect a transform.\n                let rect = dom.getBoundingClientRect();\n                makeAbsolute = Math.abs(rect.top + 10000) > 1 || Math.abs(rect.left) > 1;\n            }\n        }\n        if (makeAbsolute || this.position == \"absolute\") {\n            if (this.parent) {\n                let rect = this.parent.getBoundingClientRect();\n                if (rect.width && rect.height) {\n                    scaleX = rect.width / this.parent.offsetWidth;\n                    scaleY = rect.height / this.parent.offsetHeight;\n                }\n            } else {\n                ({ scaleX, scaleY } = this.view.viewState);\n            }\n        }\n        return {\n            editor,\n            parent: this.parent ? this.container.getBoundingClientRect() : editor,\n            pos: this.manager.tooltips.map((t, i)=>{\n                let tv = this.manager.tooltipViews[i];\n                return tv.getCoords ? tv.getCoords(t.pos) : this.view.coordsAtPos(t.pos);\n            }),\n            size: this.manager.tooltipViews.map(({ dom })=>dom.getBoundingClientRect()),\n            space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),\n            scaleX,\n            scaleY,\n            makeAbsolute\n        };\n    }\n    writeMeasure(measured) {\n        var _a;\n        if (measured.makeAbsolute) {\n            this.madeAbsolute = true;\n            this.position = \"absolute\";\n            for (let t of this.manager.tooltipViews)t.dom.style.position = \"absolute\";\n        }\n        let { editor, space, scaleX, scaleY } = measured;\n        let others = [];\n        for(let i = 0; i < this.manager.tooltips.length; i++){\n            let tooltip = this.manager.tooltips[i], tView = this.manager.tooltipViews[i], { dom } = tView;\n            let pos = measured.pos[i], size = measured.size[i];\n            // Hide tooltips that are outside of the editor.\n            if (!pos || pos.bottom <= Math.max(editor.top, space.top) || pos.top >= Math.min(editor.bottom, space.bottom) || pos.right < Math.max(editor.left, space.left) - .1 || pos.left > Math.min(editor.right, space.right) + .1) {\n                dom.style.top = Outside;\n                continue;\n            }\n            let arrow = tooltip.arrow ? tView.dom.querySelector(\".cm-tooltip-arrow\") : null;\n            let arrowHeight = arrow ? 7 /* Arrow.Size */  : 0;\n            let width = size.right - size.left, height = (_a = knownHeight.get(tView)) !== null && _a !== void 0 ? _a : size.bottom - size.top;\n            let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;\n            let left = size.width > space.right - space.left ? ltr ? space.left : space.right - size.width : ltr ? Math.min(pos.left - (arrow ? 14 /* Arrow.Offset */  : 0) + offset.x, space.right - width) : Math.max(space.left, pos.left - width + (arrow ? 14 /* Arrow.Offset */  : 0) - offset.x);\n            let above = this.above[i];\n            if (!tooltip.strictSide && (above ? pos.top - (size.bottom - size.top) - offset.y < space.top : pos.bottom + (size.bottom - size.top) + offset.y > space.bottom) && above == space.bottom - pos.bottom > pos.top - space.top) above = this.above[i] = !above;\n            let spaceVert = (above ? pos.top - space.top : space.bottom - pos.bottom) - arrowHeight;\n            if (spaceVert < height && tView.resize !== false) {\n                if (spaceVert < this.view.defaultLineHeight) {\n                    dom.style.top = Outside;\n                    continue;\n                }\n                knownHeight.set(tView, height);\n                dom.style.height = (height = spaceVert) / scaleY + \"px\";\n            } else if (dom.style.height) {\n                dom.style.height = \"\";\n            }\n            let top = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;\n            let right = left + width;\n            if (tView.overlap !== true) {\n                for (let r of others)if (r.left < right && r.right > left && r.top < top + height && r.bottom > top) top = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;\n            }\n            if (this.position == \"absolute\") {\n                dom.style.top = (top - measured.parent.top) / scaleY + \"px\";\n                dom.style.left = (left - measured.parent.left) / scaleX + \"px\";\n            } else {\n                dom.style.top = top / scaleY + \"px\";\n                dom.style.left = left / scaleX + \"px\";\n            }\n            if (arrow) {\n                let arrowLeft = pos.left + (ltr ? offset.x : -offset.x) - (left + 14 /* Arrow.Offset */  - 7 /* Arrow.Size */ );\n                arrow.style.left = arrowLeft / scaleX + \"px\";\n            }\n            if (tView.overlap !== true) others.push({\n                left,\n                top,\n                right,\n                bottom: top + height\n            });\n            dom.classList.toggle(\"cm-tooltip-above\", above);\n            dom.classList.toggle(\"cm-tooltip-below\", !above);\n            if (tView.positioned) tView.positioned(measured.space);\n        }\n    }\n    maybeMeasure() {\n        if (this.manager.tooltips.length) {\n            if (this.view.inView) this.view.requestMeasure(this.measureReq);\n            if (this.inView != this.view.inView) {\n                this.inView = this.view.inView;\n                if (!this.inView) for (let tv of this.manager.tooltipViews)tv.dom.style.top = Outside;\n            }\n        }\n    }\n}, {\n    eventObservers: {\n        scroll () {\n            this.maybeMeasure();\n        }\n    }\n});\nconst baseTheme = /*@__PURE__*/ EditorView.baseTheme({\n    \".cm-tooltip\": {\n        zIndex: 100,\n        boxSizing: \"border-box\"\n    },\n    \"&light .cm-tooltip\": {\n        border: \"1px solid #bbb\",\n        backgroundColor: \"#f5f5f5\"\n    },\n    \"&light .cm-tooltip-section:not(:first-child)\": {\n        borderTop: \"1px solid #bbb\"\n    },\n    \"&dark .cm-tooltip\": {\n        backgroundColor: \"#333338\",\n        color: \"white\"\n    },\n    \".cm-tooltip-arrow\": {\n        height: `${7 /* Arrow.Size */ }px`,\n        width: `${7 /* Arrow.Size */  * 2}px`,\n        position: \"absolute\",\n        zIndex: -1,\n        overflow: \"hidden\",\n        \"&:before, &:after\": {\n            content: \"''\",\n            position: \"absolute\",\n            width: 0,\n            height: 0,\n            borderLeft: `${7 /* Arrow.Size */ }px solid transparent`,\n            borderRight: `${7 /* Arrow.Size */ }px solid transparent`\n        },\n        \".cm-tooltip-above &\": {\n            bottom: `-${7 /* Arrow.Size */ }px`,\n            \"&:before\": {\n                borderTop: `${7 /* Arrow.Size */ }px solid #bbb`\n            },\n            \"&:after\": {\n                borderTop: `${7 /* Arrow.Size */ }px solid #f5f5f5`,\n                bottom: \"1px\"\n            }\n        },\n        \".cm-tooltip-below &\": {\n            top: `-${7 /* Arrow.Size */ }px`,\n            \"&:before\": {\n                borderBottom: `${7 /* Arrow.Size */ }px solid #bbb`\n            },\n            \"&:after\": {\n                borderBottom: `${7 /* Arrow.Size */ }px solid #f5f5f5`,\n                top: \"1px\"\n            }\n        }\n    },\n    \"&dark .cm-tooltip .cm-tooltip-arrow\": {\n        \"&:before\": {\n            borderTopColor: \"#333338\",\n            borderBottomColor: \"#333338\"\n        },\n        \"&:after\": {\n            borderTopColor: \"transparent\",\n            borderBottomColor: \"transparent\"\n        }\n    }\n});\nconst noOffset = {\n    x: 0,\n    y: 0\n};\n/**\nFacet to which an extension can add a value to show a tooltip.\n*/ const showTooltip = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    enables: [\n        tooltipPlugin,\n        baseTheme\n    ]\n});\nconst showHoverTooltip = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nclass HoverTooltipHost {\n    // Needs to be static so that host tooltip instances always match\n    static create(view) {\n        return new HoverTooltipHost(view);\n    }\n    constructor(view){\n        this.view = view;\n        this.mounted = false;\n        this.dom = document.createElement(\"div\");\n        this.dom.classList.add(\"cm-tooltip-hover\");\n        this.manager = new TooltipViewManager(view, showHoverTooltip, (t)=>this.createHostedView(t), (t)=>t.dom.remove());\n    }\n    createHostedView(tooltip) {\n        let hostedView = tooltip.create(this.view);\n        hostedView.dom.classList.add(\"cm-tooltip-section\");\n        this.dom.appendChild(hostedView.dom);\n        if (this.mounted && hostedView.mount) hostedView.mount(this.view);\n        return hostedView;\n    }\n    mount(view) {\n        for (let hostedView of this.manager.tooltipViews){\n            if (hostedView.mount) hostedView.mount(view);\n        }\n        this.mounted = true;\n    }\n    positioned(space) {\n        for (let hostedView of this.manager.tooltipViews){\n            if (hostedView.positioned) hostedView.positioned(space);\n        }\n    }\n    update(update) {\n        this.manager.update(update);\n    }\n    destroy() {\n        var _a;\n        for (let t of this.manager.tooltipViews)(_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);\n    }\n    passProp(name) {\n        let value = undefined;\n        for (let view of this.manager.tooltipViews){\n            let given = view[name];\n            if (given !== undefined) {\n                if (value === undefined) value = given;\n                else if (value !== given) return undefined;\n            }\n        }\n        return value;\n    }\n    get offset() {\n        return this.passProp(\"offset\");\n    }\n    get getCoords() {\n        return this.passProp(\"getCoords\");\n    }\n    get overlap() {\n        return this.passProp(\"overlap\");\n    }\n    get resize() {\n        return this.passProp(\"resize\");\n    }\n}\nconst showHoverTooltipHost = /*@__PURE__*/ showTooltip.compute([\n    showHoverTooltip\n], (state)=>{\n    let tooltips = state.facet(showHoverTooltip).filter((t)=>t);\n    if (tooltips.length === 0) return null;\n    return {\n        pos: Math.min(...tooltips.map((t)=>t.pos)),\n        end: Math.max(...tooltips.map((t)=>{\n            var _a;\n            return (_a = t.end) !== null && _a !== void 0 ? _a : t.pos;\n        })),\n        create: HoverTooltipHost.create,\n        above: tooltips[0].above,\n        arrow: tooltips.some((t)=>t.arrow)\n    };\n});\nclass HoverPlugin {\n    constructor(view, source, field, setHover, hoverTime){\n        this.view = view;\n        this.source = source;\n        this.field = field;\n        this.setHover = setHover;\n        this.hoverTime = hoverTime;\n        this.hoverTimeout = -1;\n        this.restartTimeout = -1;\n        this.pending = null;\n        this.lastMove = {\n            x: 0,\n            y: 0,\n            target: view.dom,\n            time: 0\n        };\n        this.checkHover = this.checkHover.bind(this);\n        view.dom.addEventListener(\"mouseleave\", this.mouseleave = this.mouseleave.bind(this));\n        view.dom.addEventListener(\"mousemove\", this.mousemove = this.mousemove.bind(this));\n    }\n    update() {\n        if (this.pending) {\n            this.pending = null;\n            clearTimeout(this.restartTimeout);\n            this.restartTimeout = setTimeout(()=>this.startHover(), 20);\n        }\n    }\n    get active() {\n        return this.view.state.field(this.field);\n    }\n    checkHover() {\n        this.hoverTimeout = -1;\n        if (this.active) return;\n        let hovered = Date.now() - this.lastMove.time;\n        if (hovered < this.hoverTime) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);\n        else this.startHover();\n    }\n    startHover() {\n        clearTimeout(this.restartTimeout);\n        let { view, lastMove } = this;\n        let desc = view.docView.nearest(lastMove.target);\n        if (!desc) return;\n        let pos, side = 1;\n        if (desc instanceof WidgetView) {\n            pos = desc.posAtStart;\n        } else {\n            pos = view.posAtCoords(lastMove);\n            if (pos == null) return;\n            let posCoords = view.coordsAtPos(pos);\n            if (!posCoords || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - view.defaultCharacterWidth || lastMove.x > posCoords.right + view.defaultCharacterWidth) return;\n            let bidi = view.bidiSpans(view.state.doc.lineAt(pos)).find((s)=>s.from <= pos && s.to >= pos);\n            let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;\n            side = lastMove.x < posCoords.left ? -rtl : rtl;\n        }\n        let open = this.source(view, pos, side);\n        if (open === null || open === void 0 ? void 0 : open.then) {\n            let pending = this.pending = {\n                pos\n            };\n            open.then((result)=>{\n                if (this.pending == pending) {\n                    this.pending = null;\n                    if (result) view.dispatch({\n                        effects: this.setHover.of(result)\n                    });\n                }\n            }, (e)=>logException(view.state, e, \"hover tooltip\"));\n        } else if (open) {\n            view.dispatch({\n                effects: this.setHover.of(open)\n            });\n        }\n    }\n    get tooltip() {\n        let plugin = this.view.plugin(tooltipPlugin);\n        let index = plugin ? plugin.manager.tooltips.findIndex((t)=>t.create == HoverTooltipHost.create) : -1;\n        return index > -1 ? plugin.manager.tooltipViews[index] : null;\n    }\n    mousemove(event) {\n        var _a;\n        this.lastMove = {\n            x: event.clientX,\n            y: event.clientY,\n            target: event.target,\n            time: Date.now()\n        };\n        if (this.hoverTimeout < 0) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);\n        let { active, tooltip } = this;\n        if (active && tooltip && !isInTooltip(tooltip.dom, event) || this.pending) {\n            let { pos } = active || this.pending, end = (_a = active === null || active === void 0 ? void 0 : active.end) !== null && _a !== void 0 ? _a : pos;\n            if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY)) {\n                this.view.dispatch({\n                    effects: this.setHover.of(null)\n                });\n                this.pending = null;\n            }\n        }\n    }\n    mouseleave(event) {\n        clearTimeout(this.hoverTimeout);\n        this.hoverTimeout = -1;\n        let { active } = this;\n        if (active) {\n            let { tooltip } = this;\n            let inTooltip = tooltip && tooltip.dom.contains(event.relatedTarget);\n            if (!inTooltip) this.view.dispatch({\n                effects: this.setHover.of(null)\n            });\n            else this.watchTooltipLeave(tooltip.dom);\n        }\n    }\n    watchTooltipLeave(tooltip) {\n        let watch = (event)=>{\n            tooltip.removeEventListener(\"mouseleave\", watch);\n            if (this.active && !this.view.dom.contains(event.relatedTarget)) this.view.dispatch({\n                effects: this.setHover.of(null)\n            });\n        };\n        tooltip.addEventListener(\"mouseleave\", watch);\n    }\n    destroy() {\n        clearTimeout(this.hoverTimeout);\n        this.view.dom.removeEventListener(\"mouseleave\", this.mouseleave);\n        this.view.dom.removeEventListener(\"mousemove\", this.mousemove);\n    }\n}\nconst tooltipMargin = 4;\nfunction isInTooltip(tooltip, event) {\n    let rect = tooltip.getBoundingClientRect();\n    return event.clientX >= rect.left - tooltipMargin && event.clientX <= rect.right + tooltipMargin && event.clientY >= rect.top - tooltipMargin && event.clientY <= rect.bottom + tooltipMargin;\n}\nfunction isOverRange(view, from, to, x, y, margin) {\n    let rect = view.scrollDOM.getBoundingClientRect();\n    let docBottom = view.documentTop + view.documentPadding.top + view.contentHeight;\n    if (rect.left > x || rect.right < x || rect.top > y || Math.min(rect.bottom, docBottom) < y) return false;\n    let pos = view.posAtCoords({\n        x,\n        y\n    }, false);\n    return pos >= from && pos <= to;\n}\n/**\nSet up a hover tooltip, which shows up when the pointer hovers\nover ranges of text. The callback is called when the mouse hovers\nover the document text. It should, if there is a tooltip\nassociated with position `pos`, return the tooltip description\n(either directly or in a promise). The `side` argument indicates\non which side of the position the pointer is—it will be -1 if the\npointer is before the position, 1 if after the position.\n\nNote that all hover tooltips are hosted within a single tooltip\ncontainer element. This allows multiple tooltips over the same\nrange to be \"merged\" together without overlapping.\n*/ function hoverTooltip(source, options = {}) {\n    let setHover = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\n    let hoverState = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n        create () {\n            return null;\n        },\n        update (value, tr) {\n            if (value && (options.hideOnChange && (tr.docChanged || tr.selection) || options.hideOn && options.hideOn(tr, value))) return null;\n            if (value && tr.docChanged) {\n                let newPos = tr.changes.mapPos(value.pos, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackDel);\n                if (newPos == null) return null;\n                let copy = Object.assign(Object.create(null), value);\n                copy.pos = newPos;\n                if (value.end != null) copy.end = tr.changes.mapPos(value.end);\n                value = copy;\n            }\n            for (let effect of tr.effects){\n                if (effect.is(setHover)) value = effect.value;\n                if (effect.is(closeHoverTooltipEffect)) value = null;\n            }\n            return value;\n        },\n        provide: (f)=>showHoverTooltip.from(f)\n    });\n    return [\n        hoverState,\n        ViewPlugin.define((view)=>new HoverPlugin(view, source, hoverState, setHover, options.hoverTime || 300 /* Hover.Time */ )),\n        showHoverTooltipHost\n    ];\n}\n/**\nGet the active tooltip view for a given tooltip, if available.\n*/ function getTooltip(view, tooltip) {\n    let plugin = view.plugin(tooltipPlugin);\n    if (!plugin) return null;\n    let found = plugin.manager.tooltips.indexOf(tooltip);\n    return found < 0 ? null : plugin.manager.tooltipViews[found];\n}\n/**\nReturns true if any hover tooltips are currently active.\n*/ function hasHoverTooltips(state) {\n    return state.facet(showHoverTooltip).some((x)=>x);\n}\nconst closeHoverTooltipEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\n/**\nTransaction effect that closes all hover tooltips.\n*/ const closeHoverTooltips = /*@__PURE__*/ closeHoverTooltipEffect.of(null);\n/**\nTell the tooltip extension to recompute the position of the active\ntooltips. This can be useful when something happens (such as a\nre-positioning or CSS change affecting the editor) that could\ninvalidate the existing tooltip positions.\n*/ function repositionTooltips(view) {\n    let plugin = view.plugin(tooltipPlugin);\n    if (plugin) plugin.maybeMeasure();\n}\nconst panelConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine (configs) {\n        let topContainer, bottomContainer;\n        for (let c of configs){\n            topContainer = topContainer || c.topContainer;\n            bottomContainer = bottomContainer || c.bottomContainer;\n        }\n        return {\n            topContainer,\n            bottomContainer\n        };\n    }\n});\n/**\nConfigures the panel-managing extension.\n*/ function panels(config) {\n    return config ? [\n        panelConfig.of(config)\n    ] : [];\n}\n/**\nGet the active panel created by the given constructor, if any.\nThis can be useful when you need access to your panels' DOM\nstructure.\n*/ function getPanel(view, panel) {\n    let plugin = view.plugin(panelPlugin);\n    let index = plugin ? plugin.specs.indexOf(panel) : -1;\n    return index > -1 ? plugin.panels[index] : null;\n}\nconst panelPlugin = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(view){\n        this.input = view.state.facet(showPanel);\n        this.specs = this.input.filter((s)=>s);\n        this.panels = this.specs.map((spec)=>spec(view));\n        let conf = view.state.facet(panelConfig);\n        this.top = new PanelGroup(view, true, conf.topContainer);\n        this.bottom = new PanelGroup(view, false, conf.bottomContainer);\n        this.top.sync(this.panels.filter((p)=>p.top));\n        this.bottom.sync(this.panels.filter((p)=>!p.top));\n        for (let p of this.panels){\n            p.dom.classList.add(\"cm-panel\");\n            if (p.mount) p.mount();\n        }\n    }\n    update(update) {\n        let conf = update.state.facet(panelConfig);\n        if (this.top.container != conf.topContainer) {\n            this.top.sync([]);\n            this.top = new PanelGroup(update.view, true, conf.topContainer);\n        }\n        if (this.bottom.container != conf.bottomContainer) {\n            this.bottom.sync([]);\n            this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);\n        }\n        this.top.syncClasses();\n        this.bottom.syncClasses();\n        let input = update.state.facet(showPanel);\n        if (input != this.input) {\n            let specs = input.filter((x)=>x);\n            let panels = [], top = [], bottom = [], mount = [];\n            for (let spec of specs){\n                let known = this.specs.indexOf(spec), panel;\n                if (known < 0) {\n                    panel = spec(update.view);\n                    mount.push(panel);\n                } else {\n                    panel = this.panels[known];\n                    if (panel.update) panel.update(update);\n                }\n                panels.push(panel);\n                (panel.top ? top : bottom).push(panel);\n            }\n            this.specs = specs;\n            this.panels = panels;\n            this.top.sync(top);\n            this.bottom.sync(bottom);\n            for (let p of mount){\n                p.dom.classList.add(\"cm-panel\");\n                if (p.mount) p.mount();\n            }\n        } else {\n            for (let p of this.panels)if (p.update) p.update(update);\n        }\n    }\n    destroy() {\n        this.top.sync([]);\n        this.bottom.sync([]);\n    }\n}, {\n    provide: (plugin)=>EditorView.scrollMargins.of((view)=>{\n            let value = view.plugin(plugin);\n            return value && {\n                top: value.top.scrollMargin(),\n                bottom: value.bottom.scrollMargin()\n            };\n        })\n});\nclass PanelGroup {\n    constructor(view, top, container){\n        this.view = view;\n        this.top = top;\n        this.container = container;\n        this.dom = undefined;\n        this.classes = \"\";\n        this.panels = [];\n        this.syncClasses();\n    }\n    sync(panels) {\n        for (let p of this.panels)if (p.destroy && panels.indexOf(p) < 0) p.destroy();\n        this.panels = panels;\n        this.syncDOM();\n    }\n    syncDOM() {\n        if (this.panels.length == 0) {\n            if (this.dom) {\n                this.dom.remove();\n                this.dom = undefined;\n            }\n            return;\n        }\n        if (!this.dom) {\n            this.dom = document.createElement(\"div\");\n            this.dom.className = this.top ? \"cm-panels cm-panels-top\" : \"cm-panels cm-panels-bottom\";\n            this.dom.style[this.top ? \"top\" : \"bottom\"] = \"0\";\n            let parent = this.container || this.view.dom;\n            parent.insertBefore(this.dom, this.top ? parent.firstChild : null);\n        }\n        let curDOM = this.dom.firstChild;\n        for (let panel of this.panels){\n            if (panel.dom.parentNode == this.dom) {\n                while(curDOM != panel.dom)curDOM = rm(curDOM);\n                curDOM = curDOM.nextSibling;\n            } else {\n                this.dom.insertBefore(panel.dom, curDOM);\n            }\n        }\n        while(curDOM)curDOM = rm(curDOM);\n    }\n    scrollMargin() {\n        return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);\n    }\n    syncClasses() {\n        if (!this.container || this.classes == this.view.themeClasses) return;\n        for (let cls of this.classes.split(\" \"))if (cls) this.container.classList.remove(cls);\n        for (let cls of (this.classes = this.view.themeClasses).split(\" \"))if (cls) this.container.classList.add(cls);\n    }\n}\nfunction rm(node) {\n    let next = node.nextSibling;\n    node.remove();\n    return next;\n}\n/**\nOpening a panel is done by providing a constructor function for\nthe panel through this facet. (The panel is closed again when its\nconstructor is no longer provided.) Values of `null` are ignored.\n*/ const showPanel = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    enables: panelPlugin\n});\n/**\nA gutter marker represents a bit of information attached to a line\nin a specific gutter. Your own custom markers have to extend this\nclass.\n*/ class GutterMarker extends _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeValue {\n    /**\n    @internal\n    */ compare(other) {\n        return this == other || this.constructor == other.constructor && this.eq(other);\n    }\n    /**\n    Compare this marker to another marker of the same type.\n    */ eq(other) {\n        return false;\n    }\n    /**\n    Called if the marker has a `toDOM` method and its representation\n    was removed from a gutter.\n    */ destroy(dom) {}\n}\nGutterMarker.prototype.elementClass = \"\";\nGutterMarker.prototype.toDOM = undefined;\nGutterMarker.prototype.mapMode = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackBefore;\nGutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;\nGutterMarker.prototype.point = true;\n/**\nFacet used to add a class to all gutter elements for a given line.\nMarkers given to this facet should _only_ define an\n[`elementclass`](https://codemirror.net/6/docs/ref/#view.GutterMarker.elementClass), not a\n[`toDOM`](https://codemirror.net/6/docs/ref/#view.GutterMarker.toDOM) (or the marker will appear\nin all gutters for the line).\n*/ const gutterLineClass = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst defaults = {\n    class: \"\",\n    renderEmptyElements: false,\n    elementStyle: \"\",\n    markers: ()=>_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.empty,\n    lineMarker: ()=>null,\n    widgetMarker: ()=>null,\n    lineMarkerChange: null,\n    initialSpacer: null,\n    updateSpacer: null,\n    domEventHandlers: {}\n};\nconst activeGutters = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\n/**\nDefine an editor gutter. The order in which the gutters appear is\ndetermined by their extension priority.\n*/ function gutter(config) {\n    return [\n        gutters(),\n        activeGutters.of(Object.assign(Object.assign({}, defaults), config))\n    ];\n}\nconst unfixGutters = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (values)=>values.some((x)=>x)\n});\n/**\nThe gutter-drawing plugin is automatically enabled when you add a\ngutter, but you can use this function to explicitly configure it.\n\nUnless `fixed` is explicitly set to `false`, the gutters are\nfixed, meaning they don't scroll along with the content\nhorizontally (except on Internet Explorer, which doesn't support\nCSS [`position:\nsticky`](https://developer.mozilla.org/en-US/docs/Web/CSS/position#sticky)).\n*/ function gutters(config) {\n    let result = [\n        gutterView\n    ];\n    if (config && config.fixed === false) result.push(unfixGutters.of(true));\n    return result;\n}\nconst gutterView = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.prevViewport = view.viewport;\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-gutters\";\n        this.dom.setAttribute(\"aria-hidden\", \"true\");\n        this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + \"px\";\n        this.gutters = view.state.facet(activeGutters).map((conf)=>new SingleGutterView(view, conf));\n        for (let gutter of this.gutters)this.dom.appendChild(gutter.dom);\n        this.fixed = !view.state.facet(unfixGutters);\n        if (this.fixed) {\n            // FIXME IE11 fallback, which doesn't support position: sticky,\n            // by using position: relative + event handlers that realign the\n            // gutter (or just force fixed=false on IE11?)\n            this.dom.style.position = \"sticky\";\n        }\n        this.syncGutters(false);\n        view.scrollDOM.insertBefore(this.dom, view.contentDOM);\n    }\n    update(update) {\n        if (this.updateGutters(update)) {\n            // Detach during sync when the viewport changed significantly\n            // (such as during scrolling), since for large updates that is\n            // faster.\n            let vpA = this.prevViewport, vpB = update.view.viewport;\n            let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);\n            this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);\n        }\n        if (update.geometryChanged) this.dom.style.minHeight = this.view.contentHeight + \"px\";\n        if (this.view.state.facet(unfixGutters) != !this.fixed) {\n            this.fixed = !this.fixed;\n            this.dom.style.position = this.fixed ? \"sticky\" : \"\";\n        }\n        this.prevViewport = update.view.viewport;\n    }\n    syncGutters(detach) {\n        let after = this.dom.nextSibling;\n        if (detach) this.dom.remove();\n        let lineClasses = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);\n        let classSet = [];\n        let contexts = this.gutters.map((gutter)=>new UpdateContext(gutter, this.view.viewport, -this.view.documentPadding.top));\n        for (let line of this.view.viewportLineBlocks){\n            if (classSet.length) classSet = [];\n            if (Array.isArray(line.type)) {\n                let first = true;\n                for (let b of line.type){\n                    if (b.type == BlockType.Text && first) {\n                        advanceCursor(lineClasses, classSet, b.from);\n                        for (let cx of contexts)cx.line(this.view, b, classSet);\n                        first = false;\n                    } else if (b.widget) {\n                        for (let cx of contexts)cx.widget(this.view, b);\n                    }\n                }\n            } else if (line.type == BlockType.Text) {\n                advanceCursor(lineClasses, classSet, line.from);\n                for (let cx of contexts)cx.line(this.view, line, classSet);\n            } else if (line.widget) {\n                for (let cx of contexts)cx.widget(this.view, line);\n            }\n        }\n        for (let cx of contexts)cx.finish();\n        if (detach) this.view.scrollDOM.insertBefore(this.dom, after);\n    }\n    updateGutters(update) {\n        let prev = update.startState.facet(activeGutters), cur = update.state.facet(activeGutters);\n        let change = update.docChanged || update.heightChanged || update.viewportChanged || !_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);\n        if (prev == cur) {\n            for (let gutter of this.gutters)if (gutter.update(update)) change = true;\n        } else {\n            change = true;\n            let gutters = [];\n            for (let conf of cur){\n                let known = prev.indexOf(conf);\n                if (known < 0) {\n                    gutters.push(new SingleGutterView(this.view, conf));\n                } else {\n                    this.gutters[known].update(update);\n                    gutters.push(this.gutters[known]);\n                }\n            }\n            for (let g of this.gutters){\n                g.dom.remove();\n                if (gutters.indexOf(g) < 0) g.destroy();\n            }\n            for (let g of gutters)this.dom.appendChild(g.dom);\n            this.gutters = gutters;\n        }\n        return change;\n    }\n    destroy() {\n        for (let view of this.gutters)view.destroy();\n        this.dom.remove();\n    }\n}, {\n    provide: (plugin)=>EditorView.scrollMargins.of((view)=>{\n            let value = view.plugin(plugin);\n            if (!value || value.gutters.length == 0 || !value.fixed) return null;\n            return view.textDirection == Direction.LTR ? {\n                left: value.dom.offsetWidth * view.scaleX\n            } : {\n                right: value.dom.offsetWidth * view.scaleX\n            };\n        })\n});\nfunction asArray(val) {\n    return Array.isArray(val) ? val : [\n        val\n    ];\n}\nfunction advanceCursor(cursor, collect, pos) {\n    while(cursor.value && cursor.from <= pos){\n        if (cursor.from == pos) collect.push(cursor.value);\n        cursor.next();\n    }\n}\nclass UpdateContext {\n    constructor(gutter, viewport, height){\n        this.gutter = gutter;\n        this.height = height;\n        this.i = 0;\n        this.cursor = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.iter(gutter.markers, viewport.from);\n    }\n    addElement(view, block, markers) {\n        let { gutter } = this, above = (block.top - this.height) / view.scaleY, height = block.height / view.scaleY;\n        if (this.i == gutter.elements.length) {\n            let newElt = new GutterElement(view, height, above, markers);\n            gutter.elements.push(newElt);\n            gutter.dom.appendChild(newElt.dom);\n        } else {\n            gutter.elements[this.i].update(view, height, above, markers);\n        }\n        this.height = block.bottom;\n        this.i++;\n    }\n    line(view, line, extraMarkers) {\n        let localMarkers = [];\n        advanceCursor(this.cursor, localMarkers, line.from);\n        if (extraMarkers.length) localMarkers = localMarkers.concat(extraMarkers);\n        let forLine = this.gutter.config.lineMarker(view, line, localMarkers);\n        if (forLine) localMarkers.unshift(forLine);\n        let gutter = this.gutter;\n        if (localMarkers.length == 0 && !gutter.config.renderEmptyElements) return;\n        this.addElement(view, line, localMarkers);\n    }\n    widget(view, block) {\n        let marker = this.gutter.config.widgetMarker(view, block.widget, block);\n        if (marker) this.addElement(view, block, [\n            marker\n        ]);\n    }\n    finish() {\n        let gutter = this.gutter;\n        while(gutter.elements.length > this.i){\n            let last = gutter.elements.pop();\n            gutter.dom.removeChild(last.dom);\n            last.destroy();\n        }\n    }\n}\nclass SingleGutterView {\n    constructor(view, config){\n        this.view = view;\n        this.config = config;\n        this.elements = [];\n        this.spacer = null;\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-gutter\" + (this.config.class ? \" \" + this.config.class : \"\");\n        for(let prop in config.domEventHandlers){\n            this.dom.addEventListener(prop, (event)=>{\n                let target = event.target, y;\n                if (target != this.dom && this.dom.contains(target)) {\n                    while(target.parentNode != this.dom)target = target.parentNode;\n                    let rect = target.getBoundingClientRect();\n                    y = (rect.top + rect.bottom) / 2;\n                } else {\n                    y = event.clientY;\n                }\n                let line = view.lineBlockAtHeight(y - view.documentTop);\n                if (config.domEventHandlers[prop](view, line, event)) event.preventDefault();\n            });\n        }\n        this.markers = asArray(config.markers(view));\n        if (config.initialSpacer) {\n            this.spacer = new GutterElement(view, 0, 0, [\n                config.initialSpacer(view)\n            ]);\n            this.dom.appendChild(this.spacer.dom);\n            this.spacer.dom.style.cssText += \"visibility: hidden; pointer-events: none\";\n        }\n    }\n    update(update) {\n        let prevMarkers = this.markers;\n        this.markers = asArray(this.config.markers(update.view));\n        if (this.spacer && this.config.updateSpacer) {\n            let updated = this.config.updateSpacer(this.spacer.markers[0], update);\n            if (updated != this.spacer.markers[0]) this.spacer.update(update.view, 0, 0, [\n                updated\n            ]);\n        }\n        let vp = update.view.viewport;\n        return !_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);\n    }\n    destroy() {\n        for (let elt of this.elements)elt.destroy();\n    }\n}\nclass GutterElement {\n    constructor(view, height, above, markers){\n        this.height = -1;\n        this.above = 0;\n        this.markers = [];\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-gutterElement\";\n        this.update(view, height, above, markers);\n    }\n    update(view, height, above, markers) {\n        if (this.height != height) {\n            this.height = height;\n            this.dom.style.height = height + \"px\";\n        }\n        if (this.above != above) this.dom.style.marginTop = (this.above = above) ? above + \"px\" : \"\";\n        if (!sameMarkers(this.markers, markers)) this.setMarkers(view, markers);\n    }\n    setMarkers(view, markers) {\n        let cls = \"cm-gutterElement\", domPos = this.dom.firstChild;\n        for(let iNew = 0, iOld = 0;;){\n            let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;\n            if (marker) {\n                let c = marker.elementClass;\n                if (c) cls += \" \" + c;\n                for(let i = iOld; i < this.markers.length; i++)if (this.markers[i].compare(marker)) {\n                    skipTo = i;\n                    matched = true;\n                    break;\n                }\n            } else {\n                skipTo = this.markers.length;\n            }\n            while(iOld < skipTo){\n                let next = this.markers[iOld++];\n                if (next.toDOM) {\n                    next.destroy(domPos);\n                    let after = domPos.nextSibling;\n                    domPos.remove();\n                    domPos = after;\n                }\n            }\n            if (!marker) break;\n            if (marker.toDOM) {\n                if (matched) domPos = domPos.nextSibling;\n                else this.dom.insertBefore(marker.toDOM(view), domPos);\n            }\n            if (matched) iOld++;\n        }\n        this.dom.className = cls;\n        this.markers = markers;\n    }\n    destroy() {\n        this.setMarkers(null, []); // First argument not used unless creating markers\n    }\n}\nfunction sameMarkers(a, b) {\n    if (a.length != b.length) return false;\n    for(let i = 0; i < a.length; i++)if (!a[i].compare(b[i])) return false;\n    return true;\n}\n/**\nFacet used to provide markers to the line number gutter.\n*/ const lineNumberMarkers = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst lineNumberConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine (values) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(values, {\n            formatNumber: String,\n            domEventHandlers: {}\n        }, {\n            domEventHandlers (a, b) {\n                let result = Object.assign({}, a);\n                for(let event in b){\n                    let exists = result[event], add = b[event];\n                    result[event] = exists ? (view, line, event)=>exists(view, line, event) || add(view, line, event) : add;\n                }\n                return result;\n            }\n        });\n    }\n});\nclass NumberMarker extends GutterMarker {\n    constructor(number){\n        super();\n        this.number = number;\n    }\n    eq(other) {\n        return this.number == other.number;\n    }\n    toDOM() {\n        return document.createTextNode(this.number);\n    }\n}\nfunction formatNumber(view, number) {\n    return view.state.facet(lineNumberConfig).formatNumber(number, view.state);\n}\nconst lineNumberGutter = /*@__PURE__*/ activeGutters.compute([\n    lineNumberConfig\n], (state)=>({\n        class: \"cm-lineNumbers\",\n        renderEmptyElements: false,\n        markers (view) {\n            return view.state.facet(lineNumberMarkers);\n        },\n        lineMarker (view, line, others) {\n            if (others.some((m)=>m.toDOM)) return null;\n            return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));\n        },\n        widgetMarker: ()=>null,\n        lineMarkerChange: (update)=>update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),\n        initialSpacer (view) {\n            return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));\n        },\n        updateSpacer (spacer, update) {\n            let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));\n            return max == spacer.number ? spacer : new NumberMarker(max);\n        },\n        domEventHandlers: state.facet(lineNumberConfig).domEventHandlers\n    }));\n/**\nCreate a line number gutter extension.\n*/ function lineNumbers(config = {}) {\n    return [\n        lineNumberConfig.of(config),\n        gutters(),\n        lineNumberGutter\n    ];\n}\nfunction maxLineNumber(lines) {\n    let last = 9;\n    while(last < lines)last = last * 10 + 9;\n    return last;\n}\nconst activeLineGutterMarker = /*@__PURE__*/ new class extends GutterMarker {\n    constructor(){\n        super(...arguments);\n        this.elementClass = \"cm-activeLineGutter\";\n    }\n};\nconst activeLineGutterHighlighter = /*@__PURE__*/ gutterLineClass.compute([\n    \"selection\"\n], (state)=>{\n    let marks = [], last = -1;\n    for (let range of state.selection.ranges){\n        let linePos = state.doc.lineAt(range.head).from;\n        if (linePos > last) {\n            last = linePos;\n            marks.push(activeLineGutterMarker.range(linePos));\n        }\n    }\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.of(marks);\n});\n/**\nReturns an extension that adds a `cm-activeLineGutter` class to\nall gutter elements on the [active\nline](https://codemirror.net/6/docs/ref/#view.highlightActiveLine).\n*/ function highlightActiveLineGutter() {\n    return activeLineGutterHighlighter;\n}\nconst WhitespaceDeco = /*@__PURE__*/ new Map();\nfunction getWhitespaceDeco(space) {\n    let deco = WhitespaceDeco.get(space);\n    if (!deco) WhitespaceDeco.set(space, deco = Decoration.mark({\n        attributes: space === \"\t\" ? {\n            class: \"cm-highlightTab\"\n        } : {\n            class: \"cm-highlightSpace\",\n            \"data-display\": space.replace(/ /g, \"\\xb7\")\n        }\n    }));\n    return deco;\n}\nfunction matcher(decorator) {\n    return ViewPlugin.define((view)=>({\n            decorations: decorator.createDeco(view),\n            update (u) {\n                this.decorations = decorator.updateDeco(u, this.decorations);\n            }\n        }), {\n        decorations: (v)=>v.decorations\n    });\n}\nconst whitespaceHighlighter = /*@__PURE__*/ matcher(/*@__PURE__*/ new MatchDecorator({\n    regexp: /\\t| +/g,\n    decoration: (match)=>getWhitespaceDeco(match[0]),\n    boundary: /\\S/\n}));\n/**\nReturns an extension that highlights whitespace, adding a\n`cm-highlightSpace` class to stretches of spaces, and a\n`cm-highlightTab` class to individual tab characters. By default,\nthe former are shown as faint dots, and the latter as arrows.\n*/ function highlightWhitespace() {\n    return whitespaceHighlighter;\n}\nconst trailingHighlighter = /*@__PURE__*/ matcher(/*@__PURE__*/ new MatchDecorator({\n    regexp: /\\s+$/g,\n    decoration: /*@__PURE__*/ Decoration.mark({\n        class: \"cm-trailingSpace\"\n    }),\n    boundary: /\\S/\n}));\n/**\nReturns an extension that adds a `cm-trailingSpace` class to all\ntrailing whitespace.\n*/ function highlightTrailingWhitespace() {\n    return trailingHighlighter;\n}\n/**\n@internal\n*/ const __test = {\n    HeightMap,\n    HeightOracle,\n    MeasuredHeights,\n    QueryType,\n    ChangedRange,\n    computeOrder,\n    moveVisually\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivdmlldy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFTO0FBQzdQO0FBQ1c7QUFFbkQsU0FBU3lCLGFBQWFDLElBQUk7SUFDdEIsSUFBSUM7SUFDSiw4REFBOEQ7SUFDOUQsNERBQTREO0lBQzVELFlBQVk7SUFDWixJQUFJRCxLQUFLRSxRQUFRLElBQUksSUFBSTtRQUNyQkQsU0FBU0QsS0FBS0QsWUFBWSxHQUFHQyxPQUFPQSxLQUFLRyxhQUFhO0lBQzFELE9BQ0s7UUFDREYsU0FBU0Q7SUFDYjtJQUNBLE9BQU9DLE9BQU9GLFlBQVk7QUFDOUI7QUFDQSxTQUFTSyxTQUFTQyxHQUFHLEVBQUVDLElBQUk7SUFDdkIsT0FBT0EsT0FBT0QsT0FBT0MsUUFBUUQsSUFBSUQsUUFBUSxDQUFDRSxLQUFLSixRQUFRLElBQUksSUFBSUksS0FBS0MsVUFBVSxHQUFHRCxRQUFRO0FBQzdGO0FBQ0EsU0FBU0Usa0JBQWtCQyxHQUFHO0lBQzFCLElBQUlDLE1BQU1ELElBQUlFLGFBQWE7SUFDM0IsTUFBT0QsT0FBT0EsSUFBSUUsVUFBVSxDQUN4QkYsTUFBTUEsSUFBSUUsVUFBVSxDQUFDRCxhQUFhO0lBQ3RDLE9BQU9EO0FBQ1g7QUFDQSxTQUFTRyxhQUFhUixHQUFHLEVBQUVTLFNBQVM7SUFDaEMsSUFBSSxDQUFDQSxVQUFVQyxVQUFVLEVBQ3JCLE9BQU87SUFDWCxJQUFJO1FBQ0EsK0RBQStEO1FBQy9ELDhEQUE4RDtRQUM5RCxXQUFXO1FBQ1gsT0FBT1gsU0FBU0MsS0FBS1MsVUFBVUMsVUFBVTtJQUM3QyxFQUNBLE9BQU9DLEdBQUc7UUFDTixPQUFPO0lBQ1g7QUFDSjtBQUNBLFNBQVNDLGVBQWVaLEdBQUc7SUFDdkIsSUFBSUEsSUFBSUgsUUFBUSxJQUFJLEdBQ2hCLE9BQU9nQixVQUFVYixLQUFLLEdBQUdBLElB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dXBDLFVBQVVqK0IsVUFBVSxDQUFDMnJDLEdBQUcsSUFBSSxDQUFDajNDLFdBQVc7WUFDL0Q7UUFDSixJQUFJO1FBQ0FBLGFBQWFoUCxDQUFBQSxJQUFLQSxFQUFFZ1AsV0FBVztJQUNuQztBQUNKO0FBQ0EsTUFBTWszQyx3QkFBd0IsV0FBVyxHQUFFRixRQUFRLFdBQVcsR0FBRSxJQUFJalEsZUFBZTtJQUMvRUMsUUFBUTtJQUNSQyxZQUFZSyxDQUFBQSxRQUFTeVAsa0JBQWtCelAsS0FBSyxDQUFDLEVBQUU7SUFDL0NILFVBQVU7QUFDZDtBQUNBOzs7OztBQUtBLEdBQ0EsU0FBU2dRO0lBQ0wsT0FBT0Q7QUFDWDtBQUNBLE1BQU1FLHNCQUFzQixXQUFXLEdBQUVKLFFBQVEsV0FBVyxHQUFFLElBQUlqUSxlQUFlO0lBQzdFQyxRQUFRO0lBQ1JDLFlBQVksV0FBVyxHQUFFN3FDLFdBQVdqRyxJQUFJLENBQUM7UUFBRUcsT0FBTztJQUFtQjtJQUNyRTZ3QyxVQUFVO0FBQ2Q7QUFDQTs7O0FBR0EsR0FDQSxTQUFTa1E7SUFDTCxPQUFPRDtBQUNYO0FBRUE7O0FBRUEsR0FDQSxNQUFNRSxTQUFTO0lBQUV4eUI7SUFBV3JCO0lBQWNjO0lBQWlCSztJQUFXL2I7SUFBYzNFO0lBQWNHO0FBQWE7QUFFaWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWJjLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3ZpZXcvZGlzdC9pbmRleC5qcz84N2MwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRleHQsIFJhbmdlU2V0LCBNYXBNb2RlLCBSYW5nZVZhbHVlLCBmaW5kQ2x1c3RlckJyZWFrLCBFZGl0b3JTZWxlY3Rpb24sIEZhY2V0LCBTdGF0ZUVmZmVjdCwgQ2hhbmdlU2V0LCBmaW5kQ29sdW1uLCBDaGFyQ2F0ZWdvcnksIEFubm90YXRpb24sIEVkaXRvclN0YXRlLCBUcmFuc2FjdGlvbiwgUHJlYywgY29kZVBvaW50QXQsIGNvZGVQb2ludFNpemUsIGNvbWJpbmVDb25maWcsIFN0YXRlRmllbGQsIFJhbmdlU2V0QnVpbGRlciwgY291bnRDb2x1bW4gfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgeyBTdHlsZU1vZHVsZSB9IGZyb20gJ3N0eWxlLW1vZCc7XG5pbXBvcnQgeyBrZXlOYW1lLCBiYXNlLCBzaGlmdCB9IGZyb20gJ3czYy1rZXluYW1lJztcblxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKHJvb3QpIHtcbiAgICBsZXQgdGFyZ2V0O1xuICAgIC8vIEJyb3dzZXJzIGRpZmZlciBvbiB3aGV0aGVyIHNoYWRvdyByb290cyBoYXZlIGEgZ2V0U2VsZWN0aW9uXG4gICAgLy8gbWV0aG9kLiBJZiBpdCBleGlzdHMsIHVzZSB0aGF0LCBvdGhlcndpc2UsIGNhbGwgaXQgb24gdGhlXG4gICAgLy8gZG9jdW1lbnQuXG4gICAgaWYgKHJvb3Qubm9kZVR5cGUgPT0gMTEpIHsgLy8gU2hhZG93IHJvb3RcbiAgICAgICAgdGFyZ2V0ID0gcm9vdC5nZXRTZWxlY3Rpb24gPyByb290IDogcm9vdC5vd25lckRvY3VtZW50O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGFyZ2V0ID0gcm9vdDtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldC5nZXRTZWxlY3Rpb24oKTtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zKGRvbSwgbm9kZSkge1xuICAgIHJldHVybiBub2RlID8gZG9tID09IG5vZGUgfHwgZG9tLmNvbnRhaW5zKG5vZGUubm9kZVR5cGUgIT0gMSA/IG5vZGUucGFyZW50Tm9kZSA6IG5vZGUpIDogZmFsc2U7XG59XG5mdW5jdGlvbiBkZWVwQWN0aXZlRWxlbWVudChkb2MpIHtcbiAgICBsZXQgZWx0ID0gZG9jLmFjdGl2ZUVsZW1lbnQ7XG4gICAgd2hpbGUgKGVsdCAmJiBlbHQuc2hhZG93Um9vdClcbiAgICAgICAgZWx0ID0gZWx0LnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudDtcbiAgICByZXR1cm4gZWx0O1xufVxuZnVuY3Rpb24gaGFzU2VsZWN0aW9uKGRvbSwgc2VsZWN0aW9uKSB7XG4gICAgaWYgKCFzZWxlY3Rpb24uYW5jaG9yTm9kZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEZpcmVmb3ggd2lsbCByYWlzZSAncGVybWlzc2lvbiBkZW5pZWQnIGVycm9ycyB3aGVuIGFjY2Vzc2luZ1xuICAgICAgICAvLyBwcm9wZXJ0aWVzIG9mIGBzZWwuYW5jaG9yTm9kZWAgd2hlbiBpdCdzIGluIGEgZ2VuZXJhdGVkIENTU1xuICAgICAgICAvLyBlbGVtZW50LlxuICAgICAgICByZXR1cm4gY29udGFpbnMoZG9tLCBzZWxlY3Rpb24uYW5jaG9yTm9kZSk7XG4gICAgfVxuICAgIGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbGllbnRSZWN0c0Zvcihkb20pIHtcbiAgICBpZiAoZG9tLm5vZGVUeXBlID09IDMpXG4gICAgICAgIHJldHVybiB0ZXh0UmFuZ2UoZG9tLCAwLCBkb20ubm9kZVZhbHVlLmxlbmd0aCkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICBlbHNlIGlmIChkb20ubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgcmV0dXJuIGRvbS5nZXRDbGllbnRSZWN0cygpO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIFtdO1xufVxuLy8gU2NhbnMgZm9yd2FyZCBhbmQgYmFja3dhcmQgdGhyb3VnaCBET00gcG9zaXRpb25zIGVxdWl2YWxlbnQgdG8gdGhlXG4vLyBnaXZlbiBvbmUgdG8gc2VlIGlmIHRoZSB0d28gYXJlIGluIHRoZSBzYW1lIHBsYWNlIChpLmUuIGFmdGVyIGFcbi8vIHRleHQgbm9kZSB2cyBhdCB0aGUgZW5kIG9mIHRoYXQgdGV4dCBub2RlKVxuZnVuY3Rpb24gaXNFcXVpdmFsZW50UG9zaXRpb24obm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYpIHtcbiAgICByZXR1cm4gdGFyZ2V0Tm9kZSA/IChzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCAtMSkgfHxcbiAgICAgICAgc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgMSkpIDogZmFsc2U7XG59XG5mdW5jdGlvbiBkb21JbmRleChub2RlKSB7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOzsgaW5kZXgrKykge1xuICAgICAgICBub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG59XG5mdW5jdGlvbiBzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCBkaXIpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChub2RlID09IHRhcmdldE5vZGUgJiYgb2ZmID09IHRhcmdldE9mZilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAob2ZmID09IChkaXIgPCAwID8gMCA6IG1heE9mZnNldChub2RlKSkpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IFwiRElWXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmICghcGFyZW50IHx8IHBhcmVudC5ub2RlVHlwZSAhPSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIG9mZiA9IGRvbUluZGV4KG5vZGUpICsgKGRpciA8IDAgPyAwIDogMSk7XG4gICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmYgKyAoZGlyIDwgMCA/IC0xIDogMCldO1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBub2RlLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgb2ZmID0gZGlyIDwgMCA/IG1heE9mZnNldChub2RlKSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBtYXhPZmZzZXQobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09IDMgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xufVxuZnVuY3Rpb24gZmxhdHRlblJlY3QocmVjdCwgbGVmdCkge1xuICAgIGxldCB4ID0gbGVmdCA/IHJlY3QubGVmdCA6IHJlY3QucmlnaHQ7XG4gICAgcmV0dXJuIHsgbGVmdDogeCwgcmlnaHQ6IHgsIHRvcDogcmVjdC50b3AsIGJvdHRvbTogcmVjdC5ib3R0b20gfTtcbn1cbmZ1bmN0aW9uIHdpbmRvd1JlY3Qod2luKSB7XG4gICAgcmV0dXJuIHsgbGVmdDogMCwgcmlnaHQ6IHdpbi5pbm5lcldpZHRoLFxuICAgICAgICB0b3A6IDAsIGJvdHRvbTogd2luLmlubmVySGVpZ2h0IH07XG59XG5mdW5jdGlvbiBnZXRTY2FsZShlbHQsIHJlY3QpIHtcbiAgICBsZXQgc2NhbGVYID0gcmVjdC53aWR0aCAvIGVsdC5vZmZzZXRXaWR0aDtcbiAgICBsZXQgc2NhbGVZID0gcmVjdC5oZWlnaHQgLyBlbHQub2Zmc2V0SGVpZ2h0O1xuICAgIGlmIChzY2FsZVggPiAwLjk5NSAmJiBzY2FsZVggPCAxLjAwNSB8fCAhaXNGaW5pdGUoc2NhbGVYKSB8fCBNYXRoLmFicyhyZWN0LndpZHRoIC0gZWx0Lm9mZnNldFdpZHRoKSA8IDEpXG4gICAgICAgIHNjYWxlWCA9IDE7XG4gICAgaWYgKHNjYWxlWSA+IDAuOTk1ICYmIHNjYWxlWSA8IDEuMDA1IHx8ICFpc0Zpbml0ZShzY2FsZVkpIHx8IE1hdGguYWJzKHJlY3QuaGVpZ2h0IC0gZWx0Lm9mZnNldEhlaWdodCkgPCAxKVxuICAgICAgICBzY2FsZVkgPSAxO1xuICAgIHJldHVybiB7IHNjYWxlWCwgc2NhbGVZIH07XG59XG5mdW5jdGlvbiBzY3JvbGxSZWN0SW50b1ZpZXcoZG9tLCByZWN0LCBzaWRlLCB4LCB5LCB4TWFyZ2luLCB5TWFyZ2luLCBsdHIpIHtcbiAgICBsZXQgZG9jID0gZG9tLm93bmVyRG9jdW1lbnQsIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gICAgZm9yIChsZXQgY3VyID0gZG9tLCBzdG9wID0gZmFsc2U7IGN1ciAmJiAhc3RvcDspIHtcbiAgICAgICAgaWYgKGN1ci5ub2RlVHlwZSA9PSAxKSB7IC8vIEVsZW1lbnRcbiAgICAgICAgICAgIGxldCBib3VuZGluZywgdG9wID0gY3VyID09IGRvYy5ib2R5O1xuICAgICAgICAgICAgbGV0IHNjYWxlWCA9IDEsIHNjYWxlWSA9IDE7XG4gICAgICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgICAgICAgYm91bmRpbmcgPSB3aW5kb3dSZWN0KHdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoL14oZml4ZWR8c3RpY2t5KSQvLnRlc3QoZ2V0Q29tcHV0ZWRTdHlsZShjdXIpLnBvc2l0aW9uKSlcbiAgICAgICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGN1ci5zY3JvbGxIZWlnaHQgPD0gY3VyLmNsaWVudEhlaWdodCAmJiBjdXIuc2Nyb2xsV2lkdGggPD0gY3VyLmNsaWVudFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5hc3NpZ25lZFNsb3QgfHwgY3VyLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmVjdCA9IGN1ci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAoeyBzY2FsZVgsIHNjYWxlWSB9ID0gZ2V0U2NhbGUoY3VyLCByZWN0KSk7XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHNjcm9sbGJhciB3aWR0aCBpc24ndCBpbmNsdWRlZCBpbiB0aGUgcmVjdGFuZ2xlXG4gICAgICAgICAgICAgICAgYm91bmRpbmcgPSB7IGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QubGVmdCArIGN1ci5jbGllbnRXaWR0aCAqIHNjYWxlWCxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiByZWN0LnRvcCwgYm90dG9tOiByZWN0LnRvcCArIGN1ci5jbGllbnRIZWlnaHQgKiBzY2FsZVkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtb3ZlWCA9IDAsIG1vdmVZID0gMDtcbiAgICAgICAgICAgIGlmICh5ID09IFwibmVhcmVzdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3QudG9wIDwgYm91bmRpbmcudG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVZID0gLShib3VuZGluZy50b3AgLSByZWN0LnRvcCArIHlNYXJnaW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZSA+IDAgJiYgcmVjdC5ib3R0b20gPiBib3VuZGluZy5ib3R0b20gKyBtb3ZlWSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVZID0gcmVjdC5ib3R0b20gLSBib3VuZGluZy5ib3R0b20gKyBtb3ZlWSArIHlNYXJnaW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlY3QuYm90dG9tID4gYm91bmRpbmcuYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVZID0gcmVjdC5ib3R0b20gLSBib3VuZGluZy5ib3R0b20gKyB5TWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZSA8IDAgJiYgKHJlY3QudG9wIC0gbW92ZVkpIDwgYm91bmRpbmcudG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVkgPSAtKGJvdW5kaW5nLnRvcCArIG1vdmVZIC0gcmVjdC50b3AgKyB5TWFyZ2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVjdEhlaWdodCA9IHJlY3QuYm90dG9tIC0gcmVjdC50b3AsIGJvdW5kaW5nSGVpZ2h0ID0gYm91bmRpbmcuYm90dG9tIC0gYm91bmRpbmcudG9wO1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXRUb3AgPSB5ID09IFwiY2VudGVyXCIgJiYgcmVjdEhlaWdodCA8PSBib3VuZGluZ0hlaWdodCA/IHJlY3QudG9wICsgcmVjdEhlaWdodCAvIDIgLSBib3VuZGluZ0hlaWdodCAvIDIgOlxuICAgICAgICAgICAgICAgICAgICB5ID09IFwic3RhcnRcIiB8fCB5ID09IFwiY2VudGVyXCIgJiYgc2lkZSA8IDAgPyByZWN0LnRvcCAtIHlNYXJnaW4gOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC5ib3R0b20gLSBib3VuZGluZ0hlaWdodCArIHlNYXJnaW47XG4gICAgICAgICAgICAgICAgbW92ZVkgPSB0YXJnZXRUb3AgLSBib3VuZGluZy50b3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeCA9PSBcIm5lYXJlc3RcIikge1xuICAgICAgICAgICAgICAgIGlmIChyZWN0LmxlZnQgPCBib3VuZGluZy5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVYID0gLShib3VuZGluZy5sZWZ0IC0gcmVjdC5sZWZ0ICsgeE1hcmdpbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWRlID4gMCAmJiByZWN0LnJpZ2h0ID4gYm91bmRpbmcucmlnaHQgKyBtb3ZlWClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVYID0gcmVjdC5yaWdodCAtIGJvdW5kaW5nLnJpZ2h0ICsgbW92ZVggKyB4TWFyZ2luO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWN0LnJpZ2h0ID4gYm91bmRpbmcucmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZVggPSByZWN0LnJpZ2h0IC0gYm91bmRpbmcucmlnaHQgKyB4TWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZSA8IDAgJiYgcmVjdC5sZWZ0IDwgYm91bmRpbmcubGVmdCArIG1vdmVYKVxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVggPSAtKGJvdW5kaW5nLmxlZnQgKyBtb3ZlWCAtIHJlY3QubGVmdCArIHhNYXJnaW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXRMZWZ0ID0geCA9PSBcImNlbnRlclwiID8gcmVjdC5sZWZ0ICsgKHJlY3QucmlnaHQgLSByZWN0LmxlZnQpIC8gMiAtIChib3VuZGluZy5yaWdodCAtIGJvdW5kaW5nLmxlZnQpIC8gMiA6XG4gICAgICAgICAgICAgICAgICAgICh4ID09IFwic3RhcnRcIikgPT0gbHRyID8gcmVjdC5sZWZ0IC0geE1hcmdpbiA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0LnJpZ2h0IC0gKGJvdW5kaW5nLnJpZ2h0IC0gYm91bmRpbmcubGVmdCkgKyB4TWFyZ2luO1xuICAgICAgICAgICAgICAgIG1vdmVYID0gdGFyZ2V0TGVmdCAtIGJvdW5kaW5nLmxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW92ZVggfHwgbW92ZVkpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbi5zY3JvbGxCeShtb3ZlWCwgbW92ZVkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1vdmVkWCA9IDAsIG1vdmVkWSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3ZlWSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gY3VyLnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ci5zY3JvbGxUb3AgKz0gbW92ZVkgLyBzY2FsZVk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlZFkgPSAoY3VyLnNjcm9sbFRvcCAtIHN0YXJ0KSAqIHNjYWxlWTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZVgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGN1ci5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyLnNjcm9sbExlZnQgKz0gbW92ZVggLyBzY2FsZVg7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlZFggPSAoY3VyLnNjcm9sbExlZnQgLSBzdGFydCkgKiBzY2FsZVg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IHsgbGVmdDogcmVjdC5sZWZ0IC0gbW92ZWRYLCB0b3A6IHJlY3QudG9wIC0gbW92ZWRZLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHJlY3QucmlnaHQgLSBtb3ZlZFgsIGJvdHRvbTogcmVjdC5ib3R0b20gLSBtb3ZlZFkgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdmVkWCAmJiBNYXRoLmFicyhtb3ZlZFggLSBtb3ZlWCkgPCAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IFwibmVhcmVzdFwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZWRZICYmIE1hdGguYWJzKG1vdmVkWSAtIG1vdmVZKSA8IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gXCJuZWFyZXN0XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvcClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGN1ciA9IGN1ci5hc3NpZ25lZFNsb3QgfHwgY3VyLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyLm5vZGVUeXBlID09IDExKSB7IC8vIEEgc2hhZG93IHJvb3RcbiAgICAgICAgICAgIGN1ciA9IGN1ci5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBzY3JvbGxhYmxlUGFyZW50KGRvbSkge1xuICAgIGxldCBkb2MgPSBkb20ub3duZXJEb2N1bWVudDtcbiAgICBmb3IgKGxldCBjdXIgPSBkb20ucGFyZW50Tm9kZTsgY3VyOykge1xuICAgICAgICBpZiAoY3VyID09IGRvYy5ib2R5KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXIubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgaWYgKGN1ci5zY3JvbGxIZWlnaHQgPiBjdXIuY2xpZW50SGVpZ2h0IHx8IGN1ci5zY3JvbGxXaWR0aCA+IGN1ci5jbGllbnRXaWR0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICAgICAgY3VyID0gY3VyLmFzc2lnbmVkU2xvdCB8fCBjdXIucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXIubm9kZVR5cGUgPT0gMTEpIHtcbiAgICAgICAgICAgIGN1ciA9IGN1ci5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5jbGFzcyBET01TZWxlY3Rpb25TdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yTm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuYW5jaG9yT2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5mb2N1c05vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmZvY3VzT2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgZXEoZG9tU2VsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuY2hvck5vZGUgPT0gZG9tU2VsLmFuY2hvck5vZGUgJiYgdGhpcy5hbmNob3JPZmZzZXQgPT0gZG9tU2VsLmFuY2hvck9mZnNldCAmJlxuICAgICAgICAgICAgdGhpcy5mb2N1c05vZGUgPT0gZG9tU2VsLmZvY3VzTm9kZSAmJiB0aGlzLmZvY3VzT2Zmc2V0ID09IGRvbVNlbC5mb2N1c09mZnNldDtcbiAgICB9XG4gICAgc2V0UmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgbGV0IHsgYW5jaG9yTm9kZSwgZm9jdXNOb2RlIH0gPSByYW5nZTtcbiAgICAgICAgLy8gQ2xpcCBvZmZzZXRzIHRvIG5vZGUgc2l6ZSB0byBhdm9pZCBjcmFzaGVzIHdoZW4gU2FmYXJpIHJlcG9ydHMgYm9ndXMgb2Zmc2V0cyAoIzExNTIpXG4gICAgICAgIHRoaXMuc2V0KGFuY2hvck5vZGUsIE1hdGgubWluKHJhbmdlLmFuY2hvck9mZnNldCwgYW5jaG9yTm9kZSA/IG1heE9mZnNldChhbmNob3JOb2RlKSA6IDApLCBmb2N1c05vZGUsIE1hdGgubWluKHJhbmdlLmZvY3VzT2Zmc2V0LCBmb2N1c05vZGUgPyBtYXhPZmZzZXQoZm9jdXNOb2RlKSA6IDApKTtcbiAgICB9XG4gICAgc2V0KGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkge1xuICAgICAgICB0aGlzLmFuY2hvck5vZGUgPSBhbmNob3JOb2RlO1xuICAgICAgICB0aGlzLmFuY2hvck9mZnNldCA9IGFuY2hvck9mZnNldDtcbiAgICAgICAgdGhpcy5mb2N1c05vZGUgPSBmb2N1c05vZGU7XG4gICAgICAgIHRoaXMuZm9jdXNPZmZzZXQgPSBmb2N1c09mZnNldDtcbiAgICB9XG59XG5sZXQgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IG51bGw7XG4vLyBGZWF0dXJlLWRldGVjdHMgc3VwcG9ydCBmb3IgLmZvY3VzKHtwcmV2ZW50U2Nyb2xsOiB0cnVlfSksIGFuZCB1c2VzXG4vLyBhIGZhbGxiYWNrIGtsdWRnZSB3aGVuIG5vdCBzdXBwb3J0ZWQuXG5mdW5jdGlvbiBmb2N1c1ByZXZlbnRTY3JvbGwoZG9tKSB7XG4gICAgaWYgKGRvbS5zZXRBY3RpdmUpXG4gICAgICAgIHJldHVybiBkb20uc2V0QWN0aXZlKCk7IC8vIGluIElFXG4gICAgaWYgKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpXG4gICAgICAgIHJldHVybiBkb20uZm9jdXMocHJldmVudFNjcm9sbFN1cHBvcnRlZCk7XG4gICAgbGV0IHN0YWNrID0gW107XG4gICAgZm9yIChsZXQgY3VyID0gZG9tOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlKSB7XG4gICAgICAgIHN0YWNrLnB1c2goY3VyLCBjdXIuc2Nyb2xsVG9wLCBjdXIuc2Nyb2xsTGVmdCk7XG4gICAgICAgIGlmIChjdXIgPT0gY3VyLm93bmVyRG9jdW1lbnQpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZG9tLmZvY3VzKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPT0gbnVsbCA/IHtcbiAgICAgICAgZ2V0IHByZXZlbnRTY3JvbGwoKSB7XG4gICAgICAgICAgICBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0geyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH07XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gOiB1bmRlZmluZWQpO1xuICAgIGlmICghcHJldmVudFNjcm9sbFN1cHBvcnRlZCkge1xuICAgICAgICBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGVsdCA9IHN0YWNrW2krK10sIHRvcCA9IHN0YWNrW2krK10sIGxlZnQgPSBzdGFja1tpKytdO1xuICAgICAgICAgICAgaWYgKGVsdC5zY3JvbGxUb3AgIT0gdG9wKVxuICAgICAgICAgICAgICAgIGVsdC5zY3JvbGxUb3AgPSB0b3A7XG4gICAgICAgICAgICBpZiAoZWx0LnNjcm9sbExlZnQgIT0gbGVmdClcbiAgICAgICAgICAgICAgICBlbHQuc2Nyb2xsTGVmdCA9IGxlZnQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5sZXQgc2NyYXRjaFJhbmdlO1xuZnVuY3Rpb24gdGV4dFJhbmdlKG5vZGUsIGZyb20sIHRvID0gZnJvbSkge1xuICAgIGxldCByYW5nZSA9IHNjcmF0Y2hSYW5nZSB8fCAoc2NyYXRjaFJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKSk7XG4gICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIHRvKTtcbiAgICByYW5nZS5zZXRTdGFydChub2RlLCBmcm9tKTtcbiAgICByZXR1cm4gcmFuZ2U7XG59XG5mdW5jdGlvbiBkaXNwYXRjaEtleShlbHQsIG5hbWUsIGNvZGUpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHsga2V5OiBuYW1lLCBjb2RlOiBuYW1lLCBrZXlDb2RlOiBjb2RlLCB3aGljaDogY29kZSwgY2FuY2VsYWJsZTogdHJ1ZSB9O1xuICAgIGxldCBkb3duID0gbmV3IEtleWJvYXJkRXZlbnQoXCJrZXlkb3duXCIsIG9wdGlvbnMpO1xuICAgIGRvd24uc3ludGhldGljID0gdHJ1ZTtcbiAgICBlbHQuZGlzcGF0Y2hFdmVudChkb3duKTtcbiAgICBsZXQgdXAgPSBuZXcgS2V5Ym9hcmRFdmVudChcImtleXVwXCIsIG9wdGlvbnMpO1xuICAgIHVwLnN5bnRoZXRpYyA9IHRydWU7XG4gICAgZWx0LmRpc3BhdGNoRXZlbnQodXApO1xuICAgIHJldHVybiBkb3duLmRlZmF1bHRQcmV2ZW50ZWQgfHwgdXAuZGVmYXVsdFByZXZlbnRlZDtcbn1cbmZ1bmN0aW9uIGdldFJvb3Qobm9kZSkge1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlICYmIChub2RlLm5vZGVUeXBlID09IDkgfHwgbm9kZS5ub2RlVHlwZSA9PSAxMSAmJiBub2RlLmhvc3QpKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmFzc2lnbmVkU2xvdCB8fCBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY2xlYXJBdHRyaWJ1dGVzKG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZS5hdHRyaWJ1dGVzLmxlbmd0aClcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGVOb2RlKG5vZGUuYXR0cmlidXRlc1swXSk7XG59XG5mdW5jdGlvbiBhdEVsZW1lbnRTdGFydChkb2MsIHNlbGVjdGlvbikge1xuICAgIGxldCBub2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZSwgb2Zmc2V0ID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuICAgIGlmICghbm9kZSB8fCBzZWxlY3Rpb24uYW5jaG9yTm9kZSAhPSBub2RlIHx8IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQgIT0gb2Zmc2V0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gU2FmYXJpIGNhbiByZXBvcnQgYm9ndXMgb2Zmc2V0cyAoIzExNTIpXG4gICAgb2Zmc2V0ID0gTWF0aC5taW4ob2Zmc2V0LCBtYXhPZmZzZXQobm9kZSkpO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG9mZnNldCkge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsZXQgcHJldiA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgIGlmIChwcmV2LmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgb2Zmc2V0LS07XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0gcHJldjtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZSA9PSBkb2MpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2Zmc2V0ID0gZG9tSW5kZXgobm9kZSk7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaXNTY3JvbGxlZFRvQm90dG9tKGVsdCkge1xuICAgIHJldHVybiBlbHQuc2Nyb2xsVG9wID4gTWF0aC5tYXgoMSwgZWx0LnNjcm9sbEhlaWdodCAtIGVsdC5jbGllbnRIZWlnaHQgLSA0KTtcbn1cblxuY2xhc3MgRE9NUG9zIHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBvZmZzZXQsIHByZWNpc2UgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLnByZWNpc2UgPSBwcmVjaXNlO1xuICAgIH1cbiAgICBzdGF0aWMgYmVmb3JlKGRvbSwgcHJlY2lzZSkgeyByZXR1cm4gbmV3IERPTVBvcyhkb20ucGFyZW50Tm9kZSwgZG9tSW5kZXgoZG9tKSwgcHJlY2lzZSk7IH1cbiAgICBzdGF0aWMgYWZ0ZXIoZG9tLCBwcmVjaXNlKSB7IHJldHVybiBuZXcgRE9NUG9zKGRvbS5wYXJlbnROb2RlLCBkb21JbmRleChkb20pICsgMSwgcHJlY2lzZSk7IH1cbn1cbmNvbnN0IG5vQ2hpbGRyZW4gPSBbXTtcbmNsYXNzIENvbnRlbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmRvbSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSAyIC8qIFZpZXdGbGFnLk5vZGVEaXJ0eSAqLztcbiAgICB9XG4gICAgZ2V0IG92ZXJyaWRlRE9NVGV4dCgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBnZXQgcG9zQXRTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQucG9zQmVmb3JlKHRoaXMpIDogMDtcbiAgICB9XG4gICAgZ2V0IHBvc0F0RW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgdGhpcy5sZW5ndGg7XG4gICAgfVxuICAgIHBvc0JlZm9yZSh2aWV3KSB7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLnBvc0F0U3RhcnQ7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZCA9PSB2aWV3KVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgICAgICBwb3MgKz0gY2hpbGQubGVuZ3RoICsgY2hpbGQuYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgY2hpbGQgaW4gcG9zQmVmb3JlXCIpO1xuICAgIH1cbiAgICBwb3NBZnRlcih2aWV3KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc0JlZm9yZSh2aWV3KSArIHZpZXcubGVuZ3RoO1xuICAgIH1cbiAgICBzeW5jKHZpZXcsIHRyYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmZsYWdzICYgMiAvKiBWaWV3RmxhZy5Ob2RlRGlydHkgKi8pIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmRvbTtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gbnVsbCwgbmV4dDtcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZmxhZ3MgJiA3IC8qIFZpZXdGbGFnLkRpcnR5ICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGQuZG9tICYmIChuZXh0ID0gcHJldiA/IHByZXYubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb250ZW50VmlldyA9IENvbnRlbnRWaWV3LmdldChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29udGVudFZpZXcgfHwgIWNvbnRlbnRWaWV3LnBhcmVudCAmJiBjb250ZW50Vmlldy5jYW5SZXVzZURPTShjaGlsZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQucmV1c2VET00obmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuc3luYyh2aWV3LCB0cmFjayk7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmZsYWdzICY9IH43IC8qIFZpZXdGbGFnLkRpcnR5ICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0ID0gcHJldiA/IHByZXYubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2sgJiYgIXRyYWNrLndyaXR0ZW4gJiYgdHJhY2subm9kZSA9PSBwYXJlbnQgJiYgbmV4dCAhPSBjaGlsZC5kb20pXG4gICAgICAgICAgICAgICAgICAgIHRyYWNrLndyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5kb20ucGFyZW50Tm9kZSA9PSBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG5leHQgJiYgbmV4dCAhPSBjaGlsZC5kb20pXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gcm0kMShuZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQuZG9tLCBuZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldiA9IGNoaWxkLmRvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQgPSBwcmV2ID8gcHJldi5uZXh0U2libGluZyA6IHBhcmVudC5maXJzdENoaWxkO1xuICAgICAgICAgICAgaWYgKG5leHQgJiYgdHJhY2sgJiYgdHJhY2subm9kZSA9PSBwYXJlbnQpXG4gICAgICAgICAgICAgICAgdHJhY2sud3JpdHRlbiA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAobmV4dClcbiAgICAgICAgICAgICAgICBuZXh0ID0gcm0kMShuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmZsYWdzICYgMSAvKiBWaWV3RmxhZy5DaGlsZERpcnR5ICovKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5mbGFncyAmIDcgLyogVmlld0ZsYWcuRGlydHkgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuc3luYyh2aWV3LCB0cmFjayk7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmZsYWdzICY9IH43IC8qIFZpZXdGbGFnLkRpcnR5ICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXVzZURPTShfZG9tKSB7IH1cbiAgICBsb2NhbFBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBhZnRlcjtcbiAgICAgICAgaWYgKG5vZGUgPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgIGFmdGVyID0gdGhpcy5kb20uY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGJpYXMgPSBtYXhPZmZzZXQobm9kZSkgPT0gMCA/IDAgOiBvZmZzZXQgPT0gMCA/IC0xIDogMTtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgPT0gdGhpcy5kb20pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChiaWFzID09IDAgJiYgcGFyZW50LmZpcnN0Q2hpbGQgIT0gcGFyZW50Lmxhc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSA9PSBwYXJlbnQuZmlyc3RDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpYXMgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYmlhcyA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmlhcyA8IDApXG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBub2RlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGFmdGVyID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWZ0ZXIgPT0gdGhpcy5kb20uZmlyc3RDaGlsZClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB3aGlsZSAoYWZ0ZXIgJiYgIUNvbnRlbnRWaWV3LmdldChhZnRlcikpXG4gICAgICAgICAgICBhZnRlciA9IGFmdGVyLm5leHRTaWJsaW5nO1xuICAgICAgICBpZiAoIWFmdGVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5kb20gPT0gYWZ0ZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIHBvcyArPSBjaGlsZC5sZW5ndGggKyBjaGlsZC5icmVha0FmdGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvbUJvdW5kc0Fyb3VuZChmcm9tLCB0bywgb2Zmc2V0ID0gMCkge1xuICAgICAgICBsZXQgZnJvbUkgPSAtMSwgZnJvbVN0YXJ0ID0gLTEsIHRvSSA9IC0xLCB0b0VuZCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gb2Zmc2V0LCBwcmV2RW5kID0gb2Zmc2V0OyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gcG9zICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHBvcyA8IGZyb20gJiYgZW5kID4gdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmRvbUJvdW5kc0Fyb3VuZChmcm9tLCB0bywgcG9zKTtcbiAgICAgICAgICAgIGlmIChlbmQgPj0gZnJvbSAmJiBmcm9tSSA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGZyb21JID0gaTtcbiAgICAgICAgICAgICAgICBmcm9tU3RhcnQgPSBwb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zID4gdG8gJiYgY2hpbGQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICB0b0kgPSBpO1xuICAgICAgICAgICAgICAgIHRvRW5kID0gcHJldkVuZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZFbmQgPSBlbmQ7XG4gICAgICAgICAgICBwb3MgPSBlbmQgKyBjaGlsZC5icmVha0FmdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZyb206IGZyb21TdGFydCwgdG86IHRvRW5kIDwgMCA/IG9mZnNldCArIHRoaXMubGVuZ3RoIDogdG9FbmQsXG4gICAgICAgICAgICBzdGFydERPTTogKGZyb21JID8gdGhpcy5jaGlsZHJlbltmcm9tSSAtIDFdLmRvbS5uZXh0U2libGluZyA6IG51bGwpIHx8IHRoaXMuZG9tLmZpcnN0Q2hpbGQsXG4gICAgICAgICAgICBlbmRET006IHRvSSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoICYmIHRvSSA+PSAwID8gdGhpcy5jaGlsZHJlblt0b0ldLmRvbSA6IG51bGwgfTtcbiAgICB9XG4gICAgbWFya0RpcnR5KGFuZFBhcmVudCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZmxhZ3MgfD0gMiAvKiBWaWV3RmxhZy5Ob2RlRGlydHkgKi87XG4gICAgICAgIHRoaXMubWFya1BhcmVudHNEaXJ0eShhbmRQYXJlbnQpO1xuICAgIH1cbiAgICBtYXJrUGFyZW50c0RpcnR5KGNoaWxkTGlzdCkge1xuICAgICAgICBmb3IgKGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudDsgcGFyZW50OyBwYXJlbnQgPSBwYXJlbnQucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRMaXN0KVxuICAgICAgICAgICAgICAgIHBhcmVudC5mbGFncyB8PSAyIC8qIFZpZXdGbGFnLk5vZGVEaXJ0eSAqLztcbiAgICAgICAgICAgIGlmIChwYXJlbnQuZmxhZ3MgJiAxIC8qIFZpZXdGbGFnLkNoaWxkRGlydHkgKi8pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgcGFyZW50LmZsYWdzIHw9IDEgLyogVmlld0ZsYWcuQ2hpbGREaXJ0eSAqLztcbiAgICAgICAgICAgIGNoaWxkTGlzdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50ICE9IHBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICBpZiAodGhpcy5mbGFncyAmIDcgLyogVmlld0ZsYWcuRGlydHkgKi8pXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrUGFyZW50c0RpcnR5KHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldERPTShkb20pIHtcbiAgICAgICAgaWYgKHRoaXMuZG9tID09IGRvbSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuZG9tKVxuICAgICAgICAgICAgdGhpcy5kb20uY21WaWV3ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb20gPSBkb207XG4gICAgICAgIGRvbS5jbVZpZXcgPSB0aGlzO1xuICAgIH1cbiAgICBnZXQgcm9vdFZpZXcoKSB7XG4gICAgICAgIGZvciAobGV0IHYgPSB0aGlzOzspIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB2LnBhcmVudDtcbiAgICAgICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgdiA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlQ2hpbGRyZW4oZnJvbSwgdG8sIGNoaWxkcmVuID0gbm9DaGlsZHJlbikge1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50ID09IHRoaXMgJiYgY2hpbGRyZW4uaW5kZXhPZihjaGlsZCkgPCAwKVxuICAgICAgICAgICAgICAgIGNoaWxkLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShmcm9tLCB0byAtIGZyb20sIC4uLmNoaWxkcmVuKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGNoaWxkcmVuW2ldLnNldFBhcmVudCh0aGlzKTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24oX3JlYykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZ25vcmVFdmVudChfZXZlbnQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgY2hpbGRDdXJzb3IocG9zID0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGlsZEN1cnNvcih0aGlzLmNoaWxkcmVuLCBwb3MsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICB9XG4gICAgY2hpbGRQb3MocG9zLCBiaWFzID0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZEN1cnNvcigpLmZpbmRQb3MocG9zLCBiaWFzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBuYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLnJlcGxhY2UoXCJWaWV3XCIsIFwiXCIpO1xuICAgICAgICByZXR1cm4gbmFtZSArICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA/IFwiKFwiICsgdGhpcy5jaGlsZHJlbi5qb2luKCkgKyBcIilcIiA6XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA/IFwiW1wiICsgKG5hbWUgPT0gXCJUZXh0XCIgPyB0aGlzLnRleHQgOiB0aGlzLmxlbmd0aCkgKyBcIl1cIiA6IFwiXCIpICtcbiAgICAgICAgICAgICh0aGlzLmJyZWFrQWZ0ZXIgPyBcIiNcIiA6IFwiXCIpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0KG5vZGUpIHsgcmV0dXJuIG5vZGUuY21WaWV3OyB9XG4gICAgZ2V0IGlzRWRpdGFibGUoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZ2V0IGlzV2lkZ2V0KCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaXNIaWRkZW4oKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIGhhc1N0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBiZWNvbWUob3RoZXIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgY2FuUmV1c2VET00ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyLmNvbnN0cnVjdG9yID09IHRoaXMuY29uc3RydWN0b3IgJiYgISgodGhpcy5mbGFncyB8IG90aGVyLmZsYWdzKSAmIDggLyogVmlld0ZsYWcuQ29tcG9zaXRpb24gKi8pO1xuICAgIH1cbiAgICAvLyBXaGVuIHRoaXMgaXMgYSB6ZXJvLWxlbmd0aCB2aWV3IHdpdGggYSBzaWRlLCB0aGlzIHNob3VsZCByZXR1cm4gYVxuICAgIC8vIG51bWJlciA8PSAwIHRvIGluZGljYXRlIGl0IGlzIGJlZm9yZSBpdHMgcG9zaXRpb24sIG9yIGFcbiAgICAvLyBudW1iZXIgPiAwIHdoZW4gYWZ0ZXIgaXRzIHBvc2l0aW9uLlxuICAgIGdldFNpZGUoKSB7IHJldHVybiAwOyB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbilcbiAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnQgPT0gdGhpcylcbiAgICAgICAgICAgICAgICBjaGlsZC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB9XG59XG5Db250ZW50Vmlldy5wcm90b3R5cGUuYnJlYWtBZnRlciA9IDA7XG4vLyBSZW1vdmUgYSBET00gbm9kZSBhbmQgcmV0dXJuIGl0cyBuZXh0IHNpYmxpbmcuXG5mdW5jdGlvbiBybSQxKGRvbSkge1xuICAgIGxldCBuZXh0ID0gZG9tLm5leHRTaWJsaW5nO1xuICAgIGRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRvbSk7XG4gICAgcmV0dXJuIG5leHQ7XG59XG5jbGFzcyBDaGlsZEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoY2hpbGRyZW4sIHBvcywgaSkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmkgPSBpO1xuICAgICAgICB0aGlzLm9mZiA9IDA7XG4gICAgfVxuICAgIGZpbmRQb3MocG9zLCBiaWFzID0gMSkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAocG9zID4gdGhpcy5wb3MgfHwgcG9zID09IHRoaXMucG9zICYmXG4gICAgICAgICAgICAgICAgKGJpYXMgPiAwIHx8IHRoaXMuaSA9PSAwIHx8IHRoaXMuY2hpbGRyZW5bdGhpcy5pIC0gMV0uYnJlYWtBZnRlcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZiA9IHBvcyAtIHRoaXMucG9zO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLmNoaWxkcmVuWy0tdGhpcy5pXTtcbiAgICAgICAgICAgIHRoaXMucG9zIC09IG5leHQubGVuZ3RoICsgbmV4dC5icmVha0FmdGVyO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcmVwbGFjZVJhbmdlKHBhcmVudCwgZnJvbUksIGZyb21PZmYsIHRvSSwgdG9PZmYsIGluc2VydCwgYnJlYWtBdFN0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICBsZXQgeyBjaGlsZHJlbiB9ID0gcGFyZW50O1xuICAgIGxldCBiZWZvcmUgPSBjaGlsZHJlbi5sZW5ndGggPyBjaGlsZHJlbltmcm9tSV0gOiBudWxsO1xuICAgIGxldCBsYXN0ID0gaW5zZXJ0Lmxlbmd0aCA/IGluc2VydFtpbnNlcnQubGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgIGxldCBicmVha0F0RW5kID0gbGFzdCA/IGxhc3QuYnJlYWtBZnRlciA6IGJyZWFrQXRTdGFydDtcbiAgICAvLyBDaGFuZ2Ugd2l0aGluIGEgc2luZ2xlIGNoaWxkXG4gICAgaWYgKGZyb21JID09IHRvSSAmJiBiZWZvcmUgJiYgIWJyZWFrQXRTdGFydCAmJiAhYnJlYWtBdEVuZCAmJiBpbnNlcnQubGVuZ3RoIDwgMiAmJlxuICAgICAgICBiZWZvcmUubWVyZ2UoZnJvbU9mZiwgdG9PZmYsIGluc2VydC5sZW5ndGggPyBsYXN0IDogbnVsbCwgZnJvbU9mZiA9PSAwLCBvcGVuU3RhcnQsIG9wZW5FbmQpKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHRvSSA8IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBsZXQgYWZ0ZXIgPSBjaGlsZHJlblt0b0ldO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGVuZCBvZiB0aGUgY2hpbGQgYWZ0ZXIgdGhlIHVwZGF0ZSBpcyBwcmVzZXJ2ZWQgaW4gYGFmdGVyYFxuICAgICAgICBpZiAoYWZ0ZXIgJiYgKHRvT2ZmIDwgYWZ0ZXIubGVuZ3RoIHx8IGFmdGVyLmJyZWFrQWZ0ZXIgJiYgKGxhc3QgPT09IG51bGwgfHwgbGFzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdC5icmVha0FmdGVyKSkpIHtcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIHNwbGl0dGluZyBhIGNoaWxkLCBzZXBhcmF0ZSBwYXJ0IG9mIGl0IHRvIGF2b2lkIHRoYXRcbiAgICAgICAgICAgIC8vIGJlaW5nIG1hbmdsZWQgd2hlbiB1cGRhdGluZyB0aGUgY2hpbGQgYmVmb3JlIHRoZSB1cGRhdGUuXG4gICAgICAgICAgICBpZiAoZnJvbUkgPT0gdG9JKSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBhZnRlci5zcGxpdCh0b09mZik7XG4gICAgICAgICAgICAgICAgdG9PZmYgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgYWZ0ZXIgdGhlIHJlcGxhY2VtZW50IHNob3VsZCBiZSBtZXJnZWQgd2l0aFxuICAgICAgICAgICAgLy8gdGhlIGxhc3QgcmVwbGFjaW5nIGVsZW1lbnQsIHVwZGF0ZSBgY29udGVudGBcbiAgICAgICAgICAgIGlmICghYnJlYWtBdEVuZCAmJiBsYXN0ICYmIGFmdGVyLm1lcmdlKDAsIHRvT2ZmLCBsYXN0LCB0cnVlLCAwLCBvcGVuRW5kKSkge1xuICAgICAgICAgICAgICAgIGluc2VydFtpbnNlcnQubGVuZ3RoIC0gMV0gPSBhZnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc3RhcnQgb2YgdGhlIGFmdGVyIGVsZW1lbnQsIGlmIG5lY2Vzc2FyeSwgYW5kXG4gICAgICAgICAgICAgICAgLy8gYWRkIGl0IHRvIGBjb250ZW50YC5cbiAgICAgICAgICAgICAgICBpZiAodG9PZmYgfHwgYWZ0ZXIuY2hpbGRyZW4ubGVuZ3RoICYmICFhZnRlci5jaGlsZHJlblswXS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyLm1lcmdlKDAsIHRvT2ZmLCBudWxsLCBmYWxzZSwgMCwgb3BlbkVuZCk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0LnB1c2goYWZ0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFmdGVyID09PSBudWxsIHx8IGFmdGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhZnRlci5icmVha0FmdGVyKSB7XG4gICAgICAgICAgICAvLyBUaGUgZWxlbWVudCBhdCBgdG9JYCBpcyBlbnRpcmVseSBjb3ZlcmVkIGJ5IHRoaXMgcmFuZ2UuXG4gICAgICAgICAgICAvLyBQcmVzZXJ2ZSBpdHMgbGluZSBicmVhaywgaWYgYW55LlxuICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgbGFzdC5icmVha0FmdGVyID0gMTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBicmVha0F0U3RhcnQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmNlIHdlJ3ZlIGhhbmRsZWQgdGhlIG5leHQgZWxlbWVudCBmcm9tIHRoZSBjdXJyZW50IGVsZW1lbnRzXG4gICAgICAgIC8vIG5vdywgbWFrZSBzdXJlIGB0b0lgIHBvaW50cyBhZnRlciB0aGF0LlxuICAgICAgICB0b0krKztcbiAgICB9XG4gICAgaWYgKGJlZm9yZSkge1xuICAgICAgICBiZWZvcmUuYnJlYWtBZnRlciA9IGJyZWFrQXRTdGFydDtcbiAgICAgICAgaWYgKGZyb21PZmYgPiAwKSB7XG4gICAgICAgICAgICBpZiAoIWJyZWFrQXRTdGFydCAmJiBpbnNlcnQubGVuZ3RoICYmIGJlZm9yZS5tZXJnZShmcm9tT2ZmLCBiZWZvcmUubGVuZ3RoLCBpbnNlcnRbMF0sIGZhbHNlLCBvcGVuU3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlLmJyZWFrQWZ0ZXIgPSBpbnNlcnQuc2hpZnQoKS5icmVha0FmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZnJvbU9mZiA8IGJlZm9yZS5sZW5ndGggfHwgYmVmb3JlLmNoaWxkcmVuLmxlbmd0aCAmJiBiZWZvcmUuY2hpbGRyZW5bYmVmb3JlLmNoaWxkcmVuLmxlbmd0aCAtIDFdLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlLm1lcmdlKGZyb21PZmYsIGJlZm9yZS5sZW5ndGgsIG51bGwsIGZhbHNlLCBvcGVuU3RhcnQsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJvbUkrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUcnkgdG8gbWVyZ2Ugd2lkZ2V0cyBvbiB0aGUgYm91bmRhcmllcyBvZiB0aGUgcmVwbGFjZW1lbnRcbiAgICB3aGlsZSAoZnJvbUkgPCB0b0kgJiYgaW5zZXJ0Lmxlbmd0aCkge1xuICAgICAgICBpZiAoY2hpbGRyZW5bdG9JIC0gMV0uYmVjb21lKGluc2VydFtpbnNlcnQubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgICAgICB0b0ktLTtcbiAgICAgICAgICAgIGluc2VydC5wb3AoKTtcbiAgICAgICAgICAgIG9wZW5FbmQgPSBpbnNlcnQubGVuZ3RoID8gMCA6IG9wZW5TdGFydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGlsZHJlbltmcm9tSV0uYmVjb21lKGluc2VydFswXSkpIHtcbiAgICAgICAgICAgIGZyb21JKys7XG4gICAgICAgICAgICBpbnNlcnQuc2hpZnQoKTtcbiAgICAgICAgICAgIG9wZW5TdGFydCA9IGluc2VydC5sZW5ndGggPyAwIDogb3BlbkVuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghaW5zZXJ0Lmxlbmd0aCAmJiBmcm9tSSAmJiB0b0kgPCBjaGlsZHJlbi5sZW5ndGggJiYgIWNoaWxkcmVuW2Zyb21JIC0gMV0uYnJlYWtBZnRlciAmJlxuICAgICAgICBjaGlsZHJlblt0b0ldLm1lcmdlKDAsIDAsIGNoaWxkcmVuW2Zyb21JIC0gMV0sIGZhbHNlLCBvcGVuU3RhcnQsIG9wZW5FbmQpKVxuICAgICAgICBmcm9tSS0tO1xuICAgIGlmIChmcm9tSSA8IHRvSSB8fCBpbnNlcnQubGVuZ3RoKVxuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkcmVuKGZyb21JLCB0b0ksIGluc2VydCk7XG59XG5mdW5jdGlvbiBtZXJnZUNoaWxkcmVuSW50byhwYXJlbnQsIGZyb20sIHRvLCBpbnNlcnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgIGxldCBjdXIgPSBwYXJlbnQuY2hpbGRDdXJzb3IoKTtcbiAgICBsZXQgeyBpOiB0b0ksIG9mZjogdG9PZmYgfSA9IGN1ci5maW5kUG9zKHRvLCAxKTtcbiAgICBsZXQgeyBpOiBmcm9tSSwgb2ZmOiBmcm9tT2ZmIH0gPSBjdXIuZmluZFBvcyhmcm9tLCAtMSk7XG4gICAgbGV0IGRMZW4gPSBmcm9tIC0gdG87XG4gICAgZm9yIChsZXQgdmlldyBvZiBpbnNlcnQpXG4gICAgICAgIGRMZW4gKz0gdmlldy5sZW5ndGg7XG4gICAgcGFyZW50Lmxlbmd0aCArPSBkTGVuO1xuICAgIHJlcGxhY2VSYW5nZShwYXJlbnQsIGZyb21JLCBmcm9tT2ZmLCB0b0ksIHRvT2ZmLCBpbnNlcnQsIDAsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG59XG5cbmxldCBuYXYgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgPyBuYXZpZ2F0b3IgOiB7IHVzZXJBZ2VudDogXCJcIiwgdmVuZG9yOiBcIlwiLCBwbGF0Zm9ybTogXCJcIiB9O1xubGV0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiB7IGRvY3VtZW50RWxlbWVudDogeyBzdHlsZToge30gfSB9O1xuY29uc3QgaWVfZWRnZSA9IC8qQF9fUFVSRV9fKi8vRWRnZVxcLyhcXGQrKS8uZXhlYyhuYXYudXNlckFnZW50KTtcbmNvbnN0IGllX3VwdG8xMCA9IC8qQF9fUFVSRV9fKi8vTVNJRSBcXGQvLnRlc3QobmF2LnVzZXJBZ2VudCk7XG5jb25zdCBpZV8xMXVwID0gLypAX19QVVJFX18qLy9UcmlkZW50XFwvKD86WzctOV18XFxkezIsfSlcXC4uKnJ2OihcXGQrKS8uZXhlYyhuYXYudXNlckFnZW50KTtcbmNvbnN0IGllID0gISEoaWVfdXB0bzEwIHx8IGllXzExdXAgfHwgaWVfZWRnZSk7XG5jb25zdCBnZWNrbyA9ICFpZSAmJiAvKkBfX1BVUkVfXyovL2dlY2tvXFwvKFxcZCspL2kudGVzdChuYXYudXNlckFnZW50KTtcbmNvbnN0IGNocm9tZSA9ICFpZSAmJiAvKkBfX1BVUkVfXyovL0Nocm9tZVxcLyhcXGQrKS8uZXhlYyhuYXYudXNlckFnZW50KTtcbmNvbnN0IHdlYmtpdCA9IFwid2Via2l0Rm9udFNtb290aGluZ1wiIGluIGRvYy5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG5jb25zdCBzYWZhcmkgPSAhaWUgJiYgLypAX19QVVJFX18qLy9BcHBsZSBDb21wdXRlci8udGVzdChuYXYudmVuZG9yKTtcbmNvbnN0IGlvcyA9IHNhZmFyaSAmJiAoLypAX19QVVJFX18qLy9Nb2JpbGVcXC9cXHcrLy50ZXN0KG5hdi51c2VyQWdlbnQpIHx8IG5hdi5tYXhUb3VjaFBvaW50cyA+IDIpO1xudmFyIGJyb3dzZXIgPSB7XG4gICAgbWFjOiBpb3MgfHwgLypAX19QVVJFX18qLy9NYWMvLnRlc3QobmF2LnBsYXRmb3JtKSxcbiAgICB3aW5kb3dzOiAvKkBfX1BVUkVfXyovL1dpbi8udGVzdChuYXYucGxhdGZvcm0pLFxuICAgIGxpbnV4OiAvKkBfX1BVUkVfXyovL0xpbnV4fFgxMS8udGVzdChuYXYucGxhdGZvcm0pLFxuICAgIGllLFxuICAgIGllX3ZlcnNpb246IGllX3VwdG8xMCA/IGRvYy5kb2N1bWVudE1vZGUgfHwgNiA6IGllXzExdXAgPyAraWVfMTF1cFsxXSA6IGllX2VkZ2UgPyAraWVfZWRnZVsxXSA6IDAsXG4gICAgZ2Vja28sXG4gICAgZ2Vja29fdmVyc2lvbjogZ2Vja28gPyArKC8qQF9fUFVSRV9fKi8vRmlyZWZveFxcLyhcXGQrKS8uZXhlYyhuYXYudXNlckFnZW50KSB8fCBbMCwgMF0pWzFdIDogMCxcbiAgICBjaHJvbWU6ICEhY2hyb21lLFxuICAgIGNocm9tZV92ZXJzaW9uOiBjaHJvbWUgPyArY2hyb21lWzFdIDogMCxcbiAgICBpb3MsXG4gICAgYW5kcm9pZDogLypAX19QVVJFX18qLy9BbmRyb2lkXFxiLy50ZXN0KG5hdi51c2VyQWdlbnQpLFxuICAgIHdlYmtpdCxcbiAgICBzYWZhcmksXG4gICAgd2Via2l0X3ZlcnNpb246IHdlYmtpdCA/ICsoLypAX19QVVJFX18qLy9cXGJBcHBsZVdlYktpdFxcLyhcXGQrKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KSB8fCBbMCwgMF0pWzFdIDogMCxcbiAgICB0YWJTaXplOiBkb2MuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnRhYlNpemUgIT0gbnVsbCA/IFwidGFiLXNpemVcIiA6IFwiLW1vei10YWItc2l6ZVwiXG59O1xuXG5jb25zdCBNYXhKb2luTGVuID0gMjU2O1xuY2xhc3MgVGV4dFZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3IodGV4dCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aDsgfVxuICAgIGNyZWF0ZURPTSh0ZXh0RE9NKSB7XG4gICAgICAgIHRoaXMuc2V0RE9NKHRleHRET00gfHwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy50ZXh0KSk7XG4gICAgfVxuICAgIHN5bmModmlldywgdHJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSlcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRE9NKCk7XG4gICAgICAgIGlmICh0aGlzLmRvbS5ub2RlVmFsdWUgIT0gdGhpcy50ZXh0KSB7XG4gICAgICAgICAgICBpZiAodHJhY2sgJiYgdHJhY2subm9kZSA9PSB0aGlzLmRvbSlcbiAgICAgICAgICAgICAgICB0cmFjay53cml0dGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZG9tLm5vZGVWYWx1ZSA9IHRoaXMudGV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXVzZURPTShkb20pIHtcbiAgICAgICAgaWYgKGRvbS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgdGhpcy5jcmVhdGVET00oZG9tKTtcbiAgICB9XG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSkge1xuICAgICAgICBpZiAoKHRoaXMuZmxhZ3MgJiA4IC8qIFZpZXdGbGFnLkNvbXBvc2l0aW9uICovKSB8fFxuICAgICAgICAgICAgc291cmNlICYmICghKHNvdXJjZSBpbnN0YW5jZW9mIFRleHRWaWV3KSB8fFxuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoIC0gKHRvIC0gZnJvbSkgKyBzb3VyY2UubGVuZ3RoID4gTWF4Sm9pbkxlbiB8fFxuICAgICAgICAgICAgICAgIChzb3VyY2UuZmxhZ3MgJiA4IC8qIFZpZXdGbGFnLkNvbXBvc2l0aW9uICovKSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMudGV4dCA9IHRoaXMudGV4dC5zbGljZSgwLCBmcm9tKSArIChzb3VyY2UgPyBzb3VyY2UudGV4dCA6IFwiXCIpICsgdGhpcy50ZXh0LnNsaWNlKHRvKTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNwbGl0KGZyb20pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBUZXh0Vmlldyh0aGlzLnRleHQuc2xpY2UoZnJvbSkpO1xuICAgICAgICB0aGlzLnRleHQgPSB0aGlzLnRleHQuc2xpY2UoMCwgZnJvbSk7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJlc3VsdC5mbGFncyB8PSB0aGlzLmZsYWdzICYgOCAvKiBWaWV3RmxhZy5Db21wb3NpdGlvbiAqLztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gbm9kZSA9PSB0aGlzLmRvbSA/IG9mZnNldCA6IG9mZnNldCA/IHRoaXMudGV4dC5sZW5ndGggOiAwO1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHsgcmV0dXJuIG5ldyBET01Qb3ModGhpcy5kb20sIHBvcyk7IH1cbiAgICBkb21Cb3VuZHNBcm91bmQoX2Zyb20sIF90bywgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7IGZyb206IG9mZnNldCwgdG86IG9mZnNldCArIHRoaXMubGVuZ3RoLCBzdGFydERPTTogdGhpcy5kb20sIGVuZERPTTogdGhpcy5kb20ubmV4dFNpYmxpbmcgfTtcbiAgICB9XG4gICAgY29vcmRzQXQocG9zLCBzaWRlKSB7XG4gICAgICAgIHJldHVybiB0ZXh0Q29vcmRzKHRoaXMuZG9tLCBwb3MsIHNpZGUpO1xuICAgIH1cbn1cbmNsYXNzIE1hcmtWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKG1hcmssIGNoaWxkcmVuID0gW10sIGxlbmd0aCA9IDApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgY2ggb2YgY2hpbGRyZW4pXG4gICAgICAgICAgICBjaC5zZXRQYXJlbnQodGhpcyk7XG4gICAgfVxuICAgIHNldEF0dHJzKGRvbSkge1xuICAgICAgICBjbGVhckF0dHJpYnV0ZXMoZG9tKTtcbiAgICAgICAgaWYgKHRoaXMubWFyay5jbGFzcylcbiAgICAgICAgICAgIGRvbS5jbGFzc05hbWUgPSB0aGlzLm1hcmsuY2xhc3M7XG4gICAgICAgIGlmICh0aGlzLm1hcmsuYXR0cnMpXG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMubWFyay5hdHRycylcbiAgICAgICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKG5hbWUsIHRoaXMubWFyay5hdHRyc1tuYW1lXSk7XG4gICAgICAgIHJldHVybiBkb207XG4gICAgfVxuICAgIGNhblJldXNlRE9NKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5jYW5SZXVzZURPTShvdGhlcikgJiYgISgodGhpcy5mbGFncyB8IG90aGVyLmZsYWdzKSAmIDggLyogVmlld0ZsYWcuQ29tcG9zaXRpb24gKi8pO1xuICAgIH1cbiAgICByZXVzZURPTShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IHRoaXMubWFyay50YWdOYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5mbGFncyB8PSA0IC8qIFZpZXdGbGFnLkF0dHJzRGlydHkgKi8gfCAyIC8qIFZpZXdGbGFnLk5vZGVEaXJ0eSAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzeW5jKHZpZXcsIHRyYWNrKSB7XG4gICAgICAgIGlmICghdGhpcy5kb20pXG4gICAgICAgICAgICB0aGlzLnNldERPTSh0aGlzLnNldEF0dHJzKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5tYXJrLnRhZ05hbWUpKSk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZmxhZ3MgJiA0IC8qIFZpZXdGbGFnLkF0dHJzRGlydHkgKi8pXG4gICAgICAgICAgICB0aGlzLnNldEF0dHJzKHRoaXMuZG9tKTtcbiAgICAgICAgc3VwZXIuc3luYyh2aWV3LCB0cmFjayk7XG4gICAgfVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIF9oYXNTdGFydCwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgICAgIGlmIChzb3VyY2UgJiYgKCEoc291cmNlIGluc3RhbmNlb2YgTWFya1ZpZXcgJiYgc291cmNlLm1hcmsuZXEodGhpcy5tYXJrKSkgfHxcbiAgICAgICAgICAgIChmcm9tICYmIG9wZW5TdGFydCA8PSAwKSB8fCAodG8gPCB0aGlzLmxlbmd0aCAmJiBvcGVuRW5kIDw9IDApKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbWVyZ2VDaGlsZHJlbkludG8odGhpcywgZnJvbSwgdG8sIHNvdXJjZSA/IHNvdXJjZS5jaGlsZHJlbi5zbGljZSgpIDogW10sIG9wZW5TdGFydCAtIDEsIG9wZW5FbmQgLSAxKTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNwbGl0KGZyb20pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdLCBvZmYgPSAwLCBkZXRhY2hGcm9tID0gLTEsIGkgPSAwO1xuICAgICAgICBmb3IgKGxldCBlbHQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgbGV0IGVuZCA9IG9mZiArIGVsdC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZW5kID4gZnJvbSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvZmYgPCBmcm9tID8gZWx0LnNwbGl0KGZyb20gLSBvZmYpIDogZWx0KTtcbiAgICAgICAgICAgIGlmIChkZXRhY2hGcm9tIDwgMCAmJiBvZmYgPj0gZnJvbSlcbiAgICAgICAgICAgICAgICBkZXRhY2hGcm9tID0gaTtcbiAgICAgICAgICAgIG9mZiA9IGVuZDtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGVuZ3RoID0gdGhpcy5sZW5ndGggLSBmcm9tO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGZyb207XG4gICAgICAgIGlmIChkZXRhY2hGcm9tID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID0gZGV0YWNoRnJvbTtcbiAgICAgICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrVmlldyh0aGlzLm1hcmssIHJlc3VsdCwgbGVuZ3RoKTtcbiAgICB9XG4gICAgZG9tQXRQb3MocG9zKSB7XG4gICAgICAgIHJldHVybiBpbmxpbmVET01BdFBvcyh0aGlzLCBwb3MpO1xuICAgIH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgcmV0dXJuIGNvb3Jkc0luQ2hpbGRyZW4odGhpcywgcG9zLCBzaWRlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0ZXh0Q29vcmRzKHRleHQsIHBvcywgc2lkZSkge1xuICAgIGxldCBsZW5ndGggPSB0ZXh0Lm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgaWYgKHBvcyA+IGxlbmd0aClcbiAgICAgICAgcG9zID0gbGVuZ3RoO1xuICAgIGxldCBmcm9tID0gcG9zLCB0byA9IHBvcywgZmxhdHRlbiA9IDA7XG4gICAgaWYgKHBvcyA9PSAwICYmIHNpZGUgPCAwIHx8IHBvcyA9PSBsZW5ndGggJiYgc2lkZSA+PSAwKSB7XG4gICAgICAgIGlmICghKGJyb3dzZXIuY2hyb21lIHx8IGJyb3dzZXIuZ2Vja28pKSB7IC8vIFRoZXNlIGJyb3dzZXJzIHJlbGlhYmx5IHJldHVybiB2YWxpZCByZWN0YW5nbGVzIGZvciBlbXB0eSByYW5nZXNcbiAgICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgICAgICBmcm9tLS07XG4gICAgICAgICAgICAgICAgZmxhdHRlbiA9IDE7XG4gICAgICAgICAgICB9IC8vIEZJWE1FIHRoaXMgaXMgd3JvbmcgaW4gUlRMIHRleHRcbiAgICAgICAgICAgIGVsc2UgaWYgKHRvIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdG8rKztcbiAgICAgICAgICAgICAgICBmbGF0dGVuID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChzaWRlIDwgMClcbiAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgZWxzZSBpZiAodG8gPCBsZW5ndGgpXG4gICAgICAgICAgICB0bysrO1xuICAgIH1cbiAgICBsZXQgcmVjdHMgPSB0ZXh0UmFuZ2UodGV4dCwgZnJvbSwgdG8pLmdldENsaWVudFJlY3RzKCk7XG4gICAgaWYgKCFyZWN0cy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCByZWN0ID0gcmVjdHNbKGZsYXR0ZW4gPyBmbGF0dGVuIDwgMCA6IHNpZGUgPj0gMCkgPyAwIDogcmVjdHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGJyb3dzZXIuc2FmYXJpICYmICFmbGF0dGVuICYmIHJlY3Qud2lkdGggPT0gMClcbiAgICAgICAgcmVjdCA9IEFycmF5LnByb3RvdHlwZS5maW5kLmNhbGwocmVjdHMsIHIgPT4gci53aWR0aCkgfHwgcmVjdDtcbiAgICByZXR1cm4gZmxhdHRlbiA/IGZsYXR0ZW5SZWN0KHJlY3QsIGZsYXR0ZW4gPCAwKSA6IHJlY3QgfHwgbnVsbDtcbn1cbi8vIEFsc28gdXNlZCBmb3IgY29sbGFwc2VkIHJhbmdlcyB0aGF0IGRvbid0IGhhdmUgYSBwbGFjZWhvbGRlciB3aWRnZXQhXG5jbGFzcyBXaWRnZXRWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIHN0YXRpYyBjcmVhdGUod2lkZ2V0LCBsZW5ndGgsIHNpZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXaWRnZXRWaWV3KHdpZGdldCwgbGVuZ3RoLCBzaWRlKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iod2lkZ2V0LCBsZW5ndGgsIHNpZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53aWRnZXQgPSB3aWRnZXQ7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLnNpZGUgPSBzaWRlO1xuICAgICAgICB0aGlzLnByZXZXaWRnZXQgPSBudWxsO1xuICAgIH1cbiAgICBzcGxpdChmcm9tKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBXaWRnZXRWaWV3LmNyZWF0ZSh0aGlzLndpZGdldCwgdGhpcy5sZW5ndGggLSBmcm9tLCB0aGlzLnNpZGUpO1xuICAgICAgICB0aGlzLmxlbmd0aCAtPSBmcm9tO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzeW5jKHZpZXcpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSB8fCAhdGhpcy53aWRnZXQudXBkYXRlRE9NKHRoaXMuZG9tLCB2aWV3KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9tICYmIHRoaXMucHJldldpZGdldClcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZXaWRnZXQuZGVzdHJveSh0aGlzLmRvbSk7XG4gICAgICAgICAgICB0aGlzLnByZXZXaWRnZXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zZXRET00odGhpcy53aWRnZXQudG9ET00odmlldykpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLndpZGdldC5lZGl0YWJsZSlcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0U2lkZSgpIHsgcmV0dXJuIHRoaXMuc2lkZTsgfVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIGhhc1N0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoIShzb3VyY2UgaW5zdGFuY2VvZiBXaWRnZXRWaWV3KSB8fCAhdGhpcy53aWRnZXQuY29tcGFyZShzb3VyY2Uud2lkZ2V0KSB8fFxuICAgICAgICAgICAgZnJvbSA+IDAgJiYgb3BlblN0YXJ0IDw9IDAgfHwgdG8gPCB0aGlzLmxlbmd0aCAmJiBvcGVuRW5kIDw9IDApKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGZyb20gKyAoc291cmNlID8gc291cmNlLmxlbmd0aCA6IDApICsgKHRoaXMubGVuZ3RoIC0gdG8pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYmVjb21lKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIFdpZGdldFZpZXcgJiYgb3RoZXIuc2lkZSA9PSB0aGlzLnNpZGUgJiZcbiAgICAgICAgICAgIHRoaXMud2lkZ2V0LmNvbnN0cnVjdG9yID09IG90aGVyLndpZGdldC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLndpZGdldC5jb21wYXJlKG90aGVyLndpZGdldCkpXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrRGlydHkodHJ1ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5kb20gJiYgIXRoaXMucHJldldpZGdldClcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZXaWRnZXQgPSB0aGlzLndpZGdldDtcbiAgICAgICAgICAgIHRoaXMud2lkZ2V0ID0gb3RoZXIud2lkZ2V0O1xuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBvdGhlci5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGlnbm9yZUV2ZW50KGV2ZW50KSB7IHJldHVybiB0aGlzLndpZGdldC5pZ25vcmVFdmVudChldmVudCk7IH1cbiAgICBnZXQgb3ZlcnJpZGVET01UZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBUZXh0LmVtcHR5O1xuICAgICAgICBsZXQgdG9wID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHRvcC5wYXJlbnQpXG4gICAgICAgICAgICB0b3AgPSB0b3AucGFyZW50O1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0b3AsIHRleHQgPSB2aWV3ICYmIHZpZXcuc3RhdGUuZG9jLCBzdGFydCA9IHRoaXMucG9zQXRTdGFydDtcbiAgICAgICAgcmV0dXJuIHRleHQgPyB0ZXh0LnNsaWNlKHN0YXJ0LCBzdGFydCArIHRoaXMubGVuZ3RoKSA6IFRleHQuZW1wdHk7XG4gICAgfVxuICAgIGRvbUF0UG9zKHBvcykge1xuICAgICAgICByZXR1cm4gKHRoaXMubGVuZ3RoID8gcG9zID09IDAgOiB0aGlzLnNpZGUgPiAwKVxuICAgICAgICAgICAgPyBET01Qb3MuYmVmb3JlKHRoaXMuZG9tKVxuICAgICAgICAgICAgOiBET01Qb3MuYWZ0ZXIodGhpcy5kb20sIHBvcyA9PSB0aGlzLmxlbmd0aCk7XG4gICAgfVxuICAgIGRvbUJvdW5kc0Fyb3VuZCgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IGN1c3RvbSA9IHRoaXMud2lkZ2V0LmNvb3Jkc0F0KHRoaXMuZG9tLCBwb3MsIHNpZGUpO1xuICAgICAgICBpZiAoY3VzdG9tKVxuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbTtcbiAgICAgICAgbGV0IHJlY3RzID0gdGhpcy5kb20uZ2V0Q2xpZW50UmVjdHMoKSwgcmVjdCA9IG51bGw7XG4gICAgICAgIGlmICghcmVjdHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBmcm9tQmFjayA9IHRoaXMuc2lkZSA/IHRoaXMuc2lkZSA8IDAgOiBwb3MgPiAwO1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbUJhY2sgPyByZWN0cy5sZW5ndGggLSAxIDogMDs7IGkgKz0gKGZyb21CYWNrID8gLTEgOiAxKSkge1xuICAgICAgICAgICAgcmVjdCA9IHJlY3RzW2ldO1xuICAgICAgICAgICAgaWYgKHBvcyA+IDAgPyBpID09IDAgOiBpID09IHJlY3RzLmxlbmd0aCAtIDEgfHwgcmVjdC50b3AgPCByZWN0LmJvdHRvbSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmxhdHRlblJlY3QocmVjdCwgIWZyb21CYWNrKTtcbiAgICB9XG4gICAgZ2V0IGlzRWRpdGFibGUoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBpc1dpZGdldCgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBnZXQgaXNIaWRkZW4oKSB7IHJldHVybiB0aGlzLndpZGdldC5pc0hpZGRlbjsgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tKVxuICAgICAgICAgICAgdGhpcy53aWRnZXQuZGVzdHJveSh0aGlzLmRvbSk7XG4gICAgfVxufVxuLy8gVGhlc2UgYXJlIGRyYXduIGFyb3VuZCB1bmVkaXRhYmxlIHdpZGdldHMgdG8gYXZvaWQgYSBudW1iZXIgb2Zcbi8vIGJyb3dzZXIgYnVncyB0aGF0IHNob3cgdXAgd2hlbiB0aGUgY3Vyc29yIGlzIGRpcmVjdGx5IG5leHQgdG9cbi8vIHVuZWRpdGFibGUgaW5saW5lIGNvbnRlbnQuXG5jbGFzcyBXaWRnZXRCdWZmZXJWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHNpZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zaWRlID0gc2lkZTtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIDA7IH1cbiAgICBtZXJnZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgYmVjb21lKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIFdpZGdldEJ1ZmZlclZpZXcgJiYgb3RoZXIuc2lkZSA9PSB0aGlzLnNpZGU7XG4gICAgfVxuICAgIHNwbGl0KCkgeyByZXR1cm4gbmV3IFdpZGdldEJ1ZmZlclZpZXcodGhpcy5zaWRlKTsgfVxuICAgIHN5bmMoKSB7XG4gICAgICAgIGlmICghdGhpcy5kb20pIHtcbiAgICAgICAgICAgIGxldCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICAgICAgZG9tLmNsYXNzTmFtZSA9IFwiY20td2lkZ2V0QnVmZmVyXCI7XG4gICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICAgICAgdGhpcy5zZXRET00oZG9tKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRTaWRlKCkgeyByZXR1cm4gdGhpcy5zaWRlOyB9XG4gICAgZG9tQXRQb3MocG9zKSB7IHJldHVybiB0aGlzLnNpZGUgPiAwID8gRE9NUG9zLmJlZm9yZSh0aGlzLmRvbSkgOiBET01Qb3MuYWZ0ZXIodGhpcy5kb20pOyB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKCkgeyByZXR1cm4gMDsgfVxuICAgIGRvbUJvdW5kc0Fyb3VuZCgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBjb29yZHNBdChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH1cbiAgICBnZXQgb3ZlcnJpZGVET01UZXh0KCkge1xuICAgICAgICByZXR1cm4gVGV4dC5lbXB0eTtcbiAgICB9XG4gICAgZ2V0IGlzSGlkZGVuKCkgeyByZXR1cm4gdHJ1ZTsgfVxufVxuVGV4dFZpZXcucHJvdG90eXBlLmNoaWxkcmVuID0gV2lkZ2V0Vmlldy5wcm90b3R5cGUuY2hpbGRyZW4gPSBXaWRnZXRCdWZmZXJWaWV3LnByb3RvdHlwZS5jaGlsZHJlbiA9IG5vQ2hpbGRyZW47XG5mdW5jdGlvbiBpbmxpbmVET01BdFBvcyhwYXJlbnQsIHBvcykge1xuICAgIGxldCBkb20gPSBwYXJlbnQuZG9tLCB7IGNoaWxkcmVuIH0gPSBwYXJlbnQsIGkgPSAwO1xuICAgIGZvciAobGV0IG9mZiA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY2hpbGQgPSBjaGlsZHJlbltpXSwgZW5kID0gb2ZmICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICBpZiAoZW5kID09IG9mZiAmJiBjaGlsZC5nZXRTaWRlKCkgPD0gMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAocG9zID4gb2ZmICYmIHBvcyA8IGVuZCAmJiBjaGlsZC5kb20ucGFyZW50Tm9kZSA9PSBkb20pXG4gICAgICAgICAgICByZXR1cm4gY2hpbGQuZG9tQXRQb3MocG9zIC0gb2ZmKTtcbiAgICAgICAgaWYgKHBvcyA8PSBvZmYpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgb2ZmID0gZW5kO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gaTsgaiA+IDA7IGotLSkge1xuICAgICAgICBsZXQgcHJldiA9IGNoaWxkcmVuW2ogLSAxXTtcbiAgICAgICAgaWYgKHByZXYuZG9tLnBhcmVudE5vZGUgPT0gZG9tKVxuICAgICAgICAgICAgcmV0dXJuIHByZXYuZG9tQXRQb3MocHJldi5sZW5ndGgpO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gaTsgaiA8IGNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGxldCBuZXh0ID0gY2hpbGRyZW5bal07XG4gICAgICAgIGlmIChuZXh0LmRvbS5wYXJlbnROb2RlID09IGRvbSlcbiAgICAgICAgICAgIHJldHVybiBuZXh0LmRvbUF0UG9zKDApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERPTVBvcyhkb20sIDApO1xufVxuLy8gQXNzdW1lcyBgdmlld2AsIGlmIGEgbWFyayB2aWV3LCBoYXMgcHJlY2lzZWx5IDEgY2hpbGQuXG5mdW5jdGlvbiBqb2luSW5saW5lSW50byhwYXJlbnQsIHZpZXcsIG9wZW4pIHtcbiAgICBsZXQgbGFzdCwgeyBjaGlsZHJlbiB9ID0gcGFyZW50O1xuICAgIGlmIChvcGVuID4gMCAmJiB2aWV3IGluc3RhbmNlb2YgTWFya1ZpZXcgJiYgY2hpbGRyZW4ubGVuZ3RoICYmXG4gICAgICAgIChsYXN0ID0gY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0pIGluc3RhbmNlb2YgTWFya1ZpZXcgJiYgbGFzdC5tYXJrLmVxKHZpZXcubWFyaykpIHtcbiAgICAgICAgam9pbklubGluZUludG8obGFzdCwgdmlldy5jaGlsZHJlblswXSwgb3BlbiAtIDEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaCh2aWV3KTtcbiAgICAgICAgdmlldy5zZXRQYXJlbnQocGFyZW50KTtcbiAgICB9XG4gICAgcGFyZW50Lmxlbmd0aCArPSB2aWV3Lmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGNvb3Jkc0luQ2hpbGRyZW4odmlldywgcG9zLCBzaWRlKSB7XG4gICAgbGV0IGJlZm9yZSA9IG51bGwsIGJlZm9yZVBvcyA9IC0xLCBhZnRlciA9IG51bGwsIGFmdGVyUG9zID0gLTE7XG4gICAgZnVuY3Rpb24gc2Nhbih2aWV3LCBwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG9mZiA9IDA7IGkgPCB2aWV3LmNoaWxkcmVuLmxlbmd0aCAmJiBvZmYgPD0gcG9zOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHZpZXcuY2hpbGRyZW5baV0sIGVuZCA9IG9mZiArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPj0gcG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzY2FuKGNoaWxkLCBwb3MgLSBvZmYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoIWFmdGVyIHx8IGFmdGVyLmlzSGlkZGVuICYmIHNpZGUgPiAwKSAmJlxuICAgICAgICAgICAgICAgICAgICAoZW5kID4gcG9zIHx8IG9mZiA9PSBlbmQgJiYgY2hpbGQuZ2V0U2lkZSgpID4gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJQb3MgPSBwb3MgLSBvZmY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9mZiA8IHBvcyB8fCAob2ZmID09IGVuZCAmJiBjaGlsZC5nZXRTaWRlKCkgPCAwKSAmJiAhY2hpbGQuaXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZVBvcyA9IHBvcyAtIG9mZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmYgPSBlbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2Nhbih2aWV3LCBwb3MpO1xuICAgIGxldCB0YXJnZXQgPSAoc2lkZSA8IDAgPyBiZWZvcmUgOiBhZnRlcikgfHwgYmVmb3JlIHx8IGFmdGVyO1xuICAgIGlmICh0YXJnZXQpXG4gICAgICAgIHJldHVybiB0YXJnZXQuY29vcmRzQXQoTWF0aC5tYXgoMCwgdGFyZ2V0ID09IGJlZm9yZSA/IGJlZm9yZVBvcyA6IGFmdGVyUG9zKSwgc2lkZSk7XG4gICAgcmV0dXJuIGZhbGxiYWNrUmVjdCh2aWV3KTtcbn1cbmZ1bmN0aW9uIGZhbGxiYWNrUmVjdCh2aWV3KSB7XG4gICAgbGV0IGxhc3QgPSB2aWV3LmRvbS5sYXN0Q2hpbGQ7XG4gICAgaWYgKCFsYXN0KVxuICAgICAgICByZXR1cm4gdmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHJlY3RzID0gY2xpZW50UmVjdHNGb3IobGFzdCk7XG4gICAgcmV0dXJuIHJlY3RzW3JlY3RzLmxlbmd0aCAtIDFdIHx8IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVBdHRycyhzb3VyY2UsIHRhcmdldCkge1xuICAgIGZvciAobGV0IG5hbWUgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChuYW1lID09IFwiY2xhc3NcIiAmJiB0YXJnZXQuY2xhc3MpXG4gICAgICAgICAgICB0YXJnZXQuY2xhc3MgKz0gXCIgXCIgKyBzb3VyY2UuY2xhc3M7XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT0gXCJzdHlsZVwiICYmIHRhcmdldC5zdHlsZSlcbiAgICAgICAgICAgIHRhcmdldC5zdHlsZSArPSBcIjtcIiArIHNvdXJjZS5zdHlsZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gc291cmNlW25hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuY29uc3Qgbm9BdHRycyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gYXR0cnNFcShhLCBiLCBpZ25vcmUpIHtcbiAgICBpZiAoYSA9PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIWEpXG4gICAgICAgIGEgPSBub0F0dHJzO1xuICAgIGlmICghYilcbiAgICAgICAgYiA9IG5vQXR0cnM7XG4gICAgbGV0IGtleXNBID0gT2JqZWN0LmtleXMoYSksIGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgaWYgKGtleXNBLmxlbmd0aCAtIChpZ25vcmUgJiYga2V5c0EuaW5kZXhPZihpZ25vcmUpID4gLTEgPyAxIDogMCkgIT1cbiAgICAgICAga2V5c0IubGVuZ3RoIC0gKGlnbm9yZSAmJiBrZXlzQi5pbmRleE9mKGlnbm9yZSkgPiAtMSA/IDEgOiAwKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGtleSBvZiBrZXlzQSkge1xuICAgICAgICBpZiAoa2V5ICE9IGlnbm9yZSAmJiAoa2V5c0IuaW5kZXhPZihrZXkpID09IC0xIHx8IGFba2V5XSAhPT0gYltrZXldKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB1cGRhdGVBdHRycyhkb20sIHByZXYsIGF0dHJzKSB7XG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICBpZiAocHJldilcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBwcmV2KVxuICAgICAgICAgICAgaWYgKCEoYXR0cnMgJiYgbmFtZSBpbiBhdHRycykpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBcInN0eWxlXCIpXG4gICAgICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgaWYgKGF0dHJzKVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIGF0dHJzKVxuICAgICAgICAgICAgaWYgKCEocHJldiAmJiBwcmV2W25hbWVdID09IGF0dHJzW25hbWVdKSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwic3R5bGVcIilcbiAgICAgICAgICAgICAgICAgICAgZG9tLnN0eWxlLmNzc1RleHQgPSBhdHRyc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgYXR0cnNbbmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xufVxuZnVuY3Rpb24gZ2V0QXR0cnMoZG9tKSB7XG4gICAgbGV0IGF0dHJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRvbS5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBhdHRyID0gZG9tLmF0dHJpYnV0ZXNbaV07XG4gICAgICAgIGF0dHJzW2F0dHIubmFtZV0gPSBhdHRyLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cnM7XG59XG5cbmNsYXNzIExpbmVWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBudWxsO1xuICAgICAgICB0aGlzLmJyZWFrQWZ0ZXIgPSAwO1xuICAgIH1cbiAgICAvLyBDb25zdW1lcyBzb3VyY2VcbiAgICBtZXJnZShmcm9tLCB0bywgc291cmNlLCBoYXNTdGFydCwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIExpbmVWaWV3KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZG9tKVxuICAgICAgICAgICAgICAgIHNvdXJjZS50cmFuc2ZlckRPTSh0aGlzKTsgLy8gUmV1c2Ugc291cmNlLmRvbSB3aGVuIGFwcHJvcHJpYXRlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc1N0YXJ0KVxuICAgICAgICAgICAgdGhpcy5zZXREZWNvKHNvdXJjZSA/IHNvdXJjZS5hdHRycyA6IG51bGwpO1xuICAgICAgICBtZXJnZUNoaWxkcmVuSW50byh0aGlzLCBmcm9tLCB0bywgc291cmNlID8gc291cmNlLmNoaWxkcmVuLnNsaWNlKCkgOiBbXSwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNwbGl0KGF0KSB7XG4gICAgICAgIGxldCBlbmQgPSBuZXcgTGluZVZpZXc7XG4gICAgICAgIGVuZC5icmVha0FmdGVyID0gdGhpcy5icmVha0FmdGVyO1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBlbmQ7XG4gICAgICAgIGxldCB7IGksIG9mZiB9ID0gdGhpcy5jaGlsZFBvcyhhdCk7XG4gICAgICAgIGlmIChvZmYpIHtcbiAgICAgICAgICAgIGVuZC5hcHBlbmQodGhpcy5jaGlsZHJlbltpXS5zcGxpdChvZmYpLCAwKTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0ubWVyZ2Uob2ZmLCB0aGlzLmNoaWxkcmVuW2ldLmxlbmd0aCwgbnVsbCwgZmFsc2UsIDAsIDApO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGogPSBpOyBqIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGorKylcbiAgICAgICAgICAgIGVuZC5hcHBlbmQodGhpcy5jaGlsZHJlbltqXSwgMCk7XG4gICAgICAgIHdoaWxlIChpID4gMCAmJiB0aGlzLmNoaWxkcmVuW2kgLSAxXS5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5bLS1pXS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID0gaTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBhdDtcbiAgICAgICAgcmV0dXJuIGVuZDtcbiAgICB9XG4gICAgdHJhbnNmZXJET00ob3RoZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgb3RoZXIuc2V0RE9NKHRoaXMuZG9tKTtcbiAgICAgICAgb3RoZXIucHJldkF0dHJzID0gdGhpcy5wcmV2QXR0cnMgPT09IHVuZGVmaW5lZCA/IHRoaXMuYXR0cnMgOiB0aGlzLnByZXZBdHRycztcbiAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZG9tID0gbnVsbDtcbiAgICB9XG4gICAgc2V0RGVjbyhhdHRycykge1xuICAgICAgICBpZiAoIWF0dHJzRXEodGhpcy5hdHRycywgYXR0cnMpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZBdHRycyA9IHRoaXMuYXR0cnM7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBlbmQoY2hpbGQsIG9wZW5TdGFydCkge1xuICAgICAgICBqb2luSW5saW5lSW50byh0aGlzLCBjaGlsZCwgb3BlblN0YXJ0KTtcbiAgICB9XG4gICAgLy8gT25seSBjYWxsZWQgd2hlbiBidWlsZGluZyBhIGxpbmUgdmlldyBpbiBDb250ZW50QnVpbGRlclxuICAgIGFkZExpbmVEZWNvKGRlY28pIHtcbiAgICAgICAgbGV0IGF0dHJzID0gZGVjby5zcGVjLmF0dHJpYnV0ZXMsIGNscyA9IGRlY28uc3BlYy5jbGFzcztcbiAgICAgICAgaWYgKGF0dHJzKVxuICAgICAgICAgICAgdGhpcy5hdHRycyA9IGNvbWJpbmVBdHRycyhhdHRycywgdGhpcy5hdHRycyB8fCB7fSk7XG4gICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICB0aGlzLmF0dHJzID0gY29tYmluZUF0dHJzKHsgY2xhc3M6IGNscyB9LCB0aGlzLmF0dHJzIHx8IHt9KTtcbiAgICB9XG4gICAgZG9tQXRQb3MocG9zKSB7XG4gICAgICAgIHJldHVybiBpbmxpbmVET01BdFBvcyh0aGlzLCBwb3MpO1xuICAgIH1cbiAgICByZXVzZURPTShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IFwiRElWXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5mbGFncyB8PSA0IC8qIFZpZXdGbGFnLkF0dHJzRGlydHkgKi8gfCAyIC8qIFZpZXdGbGFnLk5vZGVEaXJ0eSAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzeW5jKHZpZXcsIHRyYWNrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSkge1xuICAgICAgICAgICAgdGhpcy5zZXRET00oZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBcImNtLWxpbmVcIjtcbiAgICAgICAgICAgIHRoaXMucHJldkF0dHJzID0gdGhpcy5hdHRycyA/IG51bGwgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5mbGFncyAmIDQgLyogVmlld0ZsYWcuQXR0cnNEaXJ0eSAqLykge1xuICAgICAgICAgICAgY2xlYXJBdHRyaWJ1dGVzKHRoaXMuZG9tKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tbGluZVwiO1xuICAgICAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB0aGlzLmF0dHJzID8gbnVsbCA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcmV2QXR0cnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdXBkYXRlQXR0cnModGhpcy5kb20sIHRoaXMucHJldkF0dHJzLCB0aGlzLmF0dHJzKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1saW5lXCIpO1xuICAgICAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuc3luYyh2aWV3LCB0cmFjayk7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5kb20ubGFzdENoaWxkO1xuICAgICAgICB3aGlsZSAobGFzdCAmJiBDb250ZW50Vmlldy5nZXQobGFzdCkgaW5zdGFuY2VvZiBNYXJrVmlldylcbiAgICAgICAgICAgIGxhc3QgPSBsYXN0Lmxhc3RDaGlsZDtcbiAgICAgICAgaWYgKCFsYXN0IHx8ICF0aGlzLmxlbmd0aCB8fFxuICAgICAgICAgICAgbGFzdC5ub2RlTmFtZSAhPSBcIkJSXCIgJiYgKChfYSA9IENvbnRlbnRWaWV3LmdldChsYXN0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzRWRpdGFibGUpID09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgKCFicm93c2VyLmlvcyB8fCAhdGhpcy5jaGlsZHJlbi5zb21lKGNoID0+IGNoIGluc3RhbmNlb2YgVGV4dFZpZXcpKSkge1xuICAgICAgICAgICAgbGV0IGhhY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiQlJcIik7XG4gICAgICAgICAgICBoYWNrLmNtSWdub3JlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGhhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lYXN1cmVUZXh0U2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09IDAgfHwgdGhpcy5sZW5ndGggPiAyMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgdG90YWxXaWR0aCA9IDAsIHRleHRIZWlnaHQ7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmICghKGNoaWxkIGluc3RhbmNlb2YgVGV4dFZpZXcpIHx8IC9bXiAtfl0vLnRlc3QoY2hpbGQudGV4dCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgcmVjdHMgPSBjbGllbnRSZWN0c0ZvcihjaGlsZC5kb20pO1xuICAgICAgICAgICAgaWYgKHJlY3RzLmxlbmd0aCAhPSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdG90YWxXaWR0aCArPSByZWN0c1swXS53aWR0aDtcbiAgICAgICAgICAgIHRleHRIZWlnaHQgPSByZWN0c1swXS5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICF0b3RhbFdpZHRoID8gbnVsbCA6IHtcbiAgICAgICAgICAgIGxpbmVIZWlnaHQ6IHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCxcbiAgICAgICAgICAgIGNoYXJXaWR0aDogdG90YWxXaWR0aCAvIHRoaXMubGVuZ3RoLFxuICAgICAgICAgICAgdGV4dEhlaWdodFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IHJlY3QgPSBjb29yZHNJbkNoaWxkcmVuKHRoaXMsIHBvcywgc2lkZSk7XG4gICAgICAgIC8vIENvcnJlY3QgcmVjdGFuZ2xlIGhlaWdodCBmb3IgZW1wdHkgbGluZXMgd2hlbiB0aGUgcmV0dXJuZWRcbiAgICAgICAgLy8gaGVpZ2h0IGlzIGxhcmdlciB0aGFuIHRoZSB0ZXh0IGhlaWdodC5cbiAgICAgICAgaWYgKCF0aGlzLmNoaWxkcmVuLmxlbmd0aCAmJiByZWN0ICYmIHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICBsZXQgeyBoZWlnaHRPcmFjbGUgfSA9IHRoaXMucGFyZW50LnZpZXcudmlld1N0YXRlLCBoZWlnaHQgPSByZWN0LmJvdHRvbSAtIHJlY3QudG9wO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGhlaWdodCAtIGhlaWdodE9yYWNsZS5saW5lSGVpZ2h0KSA8IDIgJiYgaGVpZ2h0T3JhY2xlLnRleHRIZWlnaHQgPCBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlzdCA9IChoZWlnaHQgLSBoZWlnaHRPcmFjbGUudGV4dEhlaWdodCkgLyAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHRvcDogcmVjdC50b3AgKyBkaXN0LCBib3R0b206IHJlY3QuYm90dG9tIC0gZGlzdCwgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5sZWZ0IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuICAgIGJlY29tZShfb3RoZXIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgY292ZXJzKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIHN0YXRpYyBmaW5kKGRvY1ZpZXcsIHBvcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgb2ZmID0gMDsgaSA8IGRvY1ZpZXcuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBibG9jayA9IGRvY1ZpZXcuY2hpbGRyZW5baV0sIGVuZCA9IG9mZiArIGJsb2NrLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPj0gcG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrIGluc3RhbmNlb2YgTGluZVZpZXcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBibG9jaztcbiAgICAgICAgICAgICAgICBpZiAoZW5kID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZiA9IGVuZCArIGJsb2NrLmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuY2xhc3MgQmxvY2tXaWRnZXRWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHdpZGdldCwgbGVuZ3RoLCBkZWNvKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5kZWNvID0gZGVjbztcbiAgICAgICAgdGhpcy5icmVha0FmdGVyID0gMDtcbiAgICAgICAgdGhpcy5wcmV2V2lkZ2V0ID0gbnVsbDtcbiAgICB9XG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgX3Rha2VEZWNvLCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoIShzb3VyY2UgaW5zdGFuY2VvZiBCbG9ja1dpZGdldFZpZXcpIHx8ICF0aGlzLndpZGdldC5jb21wYXJlKHNvdXJjZS53aWRnZXQpIHx8XG4gICAgICAgICAgICBmcm9tID4gMCAmJiBvcGVuU3RhcnQgPD0gMCB8fCB0byA8IHRoaXMubGVuZ3RoICYmIG9wZW5FbmQgPD0gMCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gZnJvbSArIChzb3VyY2UgPyBzb3VyY2UubGVuZ3RoIDogMCkgKyAodGhpcy5sZW5ndGggLSB0byk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIHBvcyA9PSAwID8gRE9NUG9zLmJlZm9yZSh0aGlzLmRvbSkgOiBET01Qb3MuYWZ0ZXIodGhpcy5kb20sIHBvcyA9PSB0aGlzLmxlbmd0aCk7XG4gICAgfVxuICAgIHNwbGl0KGF0KSB7XG4gICAgICAgIGxldCBsZW4gPSB0aGlzLmxlbmd0aCAtIGF0O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGF0O1xuICAgICAgICBsZXQgZW5kID0gbmV3IEJsb2NrV2lkZ2V0Vmlldyh0aGlzLndpZGdldCwgbGVuLCB0aGlzLmRlY28pO1xuICAgICAgICBlbmQuYnJlYWtBZnRlciA9IHRoaXMuYnJlYWtBZnRlcjtcbiAgICAgICAgcmV0dXJuIGVuZDtcbiAgICB9XG4gICAgZ2V0IGNoaWxkcmVuKCkgeyByZXR1cm4gbm9DaGlsZHJlbjsgfVxuICAgIHN5bmModmlldykge1xuICAgICAgICBpZiAoIXRoaXMuZG9tIHx8ICF0aGlzLndpZGdldC51cGRhdGVET00odGhpcy5kb20sIHZpZXcpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb20gJiYgdGhpcy5wcmV2V2lkZ2V0KVxuICAgICAgICAgICAgICAgIHRoaXMucHJldldpZGdldC5kZXN0cm95KHRoaXMuZG9tKTtcbiAgICAgICAgICAgIHRoaXMucHJldldpZGdldCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNldERPTSh0aGlzLndpZGdldC50b0RPTSh2aWV3KSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMud2lkZ2V0LmVkaXRhYmxlKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgb3ZlcnJpZGVET01UZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC52aWV3LnN0YXRlLmRvYy5zbGljZSh0aGlzLnBvc0F0U3RhcnQsIHRoaXMucG9zQXRFbmQpIDogVGV4dC5lbXB0eTtcbiAgICB9XG4gICAgZG9tQm91bmRzQXJvdW5kKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGJlY29tZShvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBCbG9ja1dpZGdldFZpZXcgJiZcbiAgICAgICAgICAgIG90aGVyLndpZGdldC5jb25zdHJ1Y3RvciA9PSB0aGlzLndpZGdldC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgaWYgKCFvdGhlci53aWRnZXQuY29tcGFyZSh0aGlzLndpZGdldCkpXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrRGlydHkodHJ1ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5kb20gJiYgIXRoaXMucHJldldpZGdldClcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZXaWRnZXQgPSB0aGlzLndpZGdldDtcbiAgICAgICAgICAgIHRoaXMud2lkZ2V0ID0gb3RoZXIud2lkZ2V0O1xuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBvdGhlci5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmRlY28gPSBvdGhlci5kZWNvO1xuICAgICAgICAgICAgdGhpcy5icmVha0FmdGVyID0gb3RoZXIuYnJlYWtBZnRlcjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24oKSB7IHJldHVybiB0cnVlOyB9XG4gICAgaWdub3JlRXZlbnQoZXZlbnQpIHsgcmV0dXJuIHRoaXMud2lkZ2V0Lmlnbm9yZUV2ZW50KGV2ZW50KTsgfVxuICAgIGdldCBpc0VkaXRhYmxlKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaXNXaWRnZXQoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgY29vcmRzQXQocG9zLCBzaWRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZGdldC5jb29yZHNBdCh0aGlzLmRvbSwgcG9zLCBzaWRlKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5kb20pXG4gICAgICAgICAgICB0aGlzLndpZGdldC5kZXN0cm95KHRoaXMuZG9tKTtcbiAgICB9XG4gICAgY292ZXJzKHNpZGUpIHtcbiAgICAgICAgbGV0IHsgc3RhcnRTaWRlLCBlbmRTaWRlIH0gPSB0aGlzLmRlY287XG4gICAgICAgIHJldHVybiBzdGFydFNpZGUgPT0gZW5kU2lkZSA/IGZhbHNlIDogc2lkZSA8IDAgPyBzdGFydFNpZGUgPCAwIDogZW5kU2lkZSA+IDA7XG4gICAgfVxufVxuXG4vKipcbldpZGdldHMgYWRkZWQgdG8gdGhlIGNvbnRlbnQgYXJlIGRlc2NyaWJlZCBieSBzdWJjbGFzc2VzIG9mIHRoaXNcbmNsYXNzLiBVc2luZyBhIGRlc2NyaXB0aW9uIG9iamVjdCBsaWtlIHRoYXQgbWFrZXMgaXQgcG9zc2libGUgdG9cbmRlbGF5IGNyZWF0aW5nIG9mIHRoZSBET00gc3RydWN0dXJlIGZvciBhIHdpZGdldCB1bnRpbCBpdCBpc1xubmVlZGVkLCBhbmQgdG8gYXZvaWQgcmVkcmF3aW5nIHdpZGdldHMgZXZlbiBpZiB0aGUgZGVjb3JhdGlvbnNcbnRoYXQgZGVmaW5lIHRoZW0gYXJlIHJlY3JlYXRlZC5cbiovXG5jbGFzcyBXaWRnZXRUeXBlIHtcbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgaW5zdGFuY2UgdG8gYW5vdGhlciBpbnN0YW5jZSBvZiB0aGUgc2FtZSB0eXBlLlxuICAgIChUeXBlU2NyaXB0IGNhbid0IGV4cHJlc3MgdGhpcywgYnV0IG9ubHkgaW5zdGFuY2VzIG9mIHRoZSBzYW1lXG4gICAgc3BlY2lmaWMgY2xhc3Mgd2lsbCBiZSBwYXNzZWQgdG8gdGhpcyBtZXRob2QuKSBUaGlzIGlzIHVzZWQgdG9cbiAgICBhdm9pZCByZWRyYXdpbmcgd2lkZ2V0cyB3aGVuIHRoZXkgYXJlIHJlcGxhY2VkIGJ5IGEgbmV3XG4gICAgZGVjb3JhdGlvbiBvZiB0aGUgc2FtZSB0eXBlLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBqdXN0XG4gICAgcmV0dXJucyBgZmFsc2VgLCB3aGljaCB3aWxsIGNhdXNlIG5ldyBpbnN0YW5jZXMgb2YgdGhlIHdpZGdldCB0b1xuICAgIGFsd2F5cyBiZSByZWRyYXduLlxuICAgICovXG4gICAgZXEod2lkZ2V0KSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSBhIERPTSBlbGVtZW50IGNyZWF0ZWQgYnkgYSB3aWRnZXQgb2YgdGhlIHNhbWUgdHlwZSAoYnV0XG4gICAgZGlmZmVyZW50LCBub24tYGVxYCBjb250ZW50KSB0byByZWZsZWN0IHRoaXMgd2lkZ2V0LiBNYXkgcmV0dXJuXG4gICAgdHJ1ZSB0byBpbmRpY2F0ZSB0aGF0IGl0IGNvdWxkIHVwZGF0ZSwgZmFsc2UgdG8gaW5kaWNhdGUgaXRcbiAgICBjb3VsZG4ndCAoaW4gd2hpY2ggY2FzZSB0aGUgd2lkZ2V0IHdpbGwgYmUgcmVkcmF3bikuIFRoZSBkZWZhdWx0XG4gICAgaW1wbGVtZW50YXRpb24ganVzdCByZXR1cm5zIGZhbHNlLlxuICAgICovXG4gICAgdXBkYXRlRE9NKGRvbSwgdmlldykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXBhcmUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgdGhpcy5jb25zdHJ1Y3RvciA9PSBvdGhlci5jb25zdHJ1Y3RvciAmJiB0aGlzLmVxKG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGVzdGltYXRlZCBoZWlnaHQgdGhpcyB3aWRnZXQgd2lsbCBoYXZlLCB0byBiZSB1c2VkIHdoZW5cbiAgICBlc3RpbWF0aW5nIHRoZSBoZWlnaHQgb2YgY29udGVudCB0aGF0IGhhc24ndCBiZWVuIGRyYXduLiBNYXlcbiAgICByZXR1cm4gLTEgdG8gaW5kaWNhdGUgeW91IGRvbid0IGtub3cuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uXG4gICAgcmV0dXJucyAtMS5cbiAgICAqL1xuICAgIGdldCBlc3RpbWF0ZWRIZWlnaHQoKSB7IHJldHVybiAtMTsgfVxuICAgIC8qKlxuICAgIEZvciBpbmxpbmUgd2lkZ2V0cyB0aGF0IGFyZSBkaXNwbGF5ZWQgaW5saW5lIChhcyBvcHBvc2VkIHRvXG4gICAgYGlubGluZS1ibG9ja2ApIGFuZCBpbnRyb2R1Y2UgbGluZSBicmVha3MgKHRocm91Z2ggYDxicj5gIHRhZ3NcbiAgICBvciB0ZXh0dWFsIG5ld2xpbmVzKSwgdGhpcyBtdXN0IGluZGljYXRlIHRoZSBhbW91bnQgb2YgbGluZVxuICAgIGJyZWFrcyB0aGV5IGludHJvZHVjZS4gRGVmYXVsdHMgdG8gMC5cbiAgICAqL1xuICAgIGdldCBsaW5lQnJlYWtzKCkgeyByZXR1cm4gMDsgfVxuICAgIC8qKlxuICAgIENhbiBiZSB1c2VkIHRvIGNvbmZpZ3VyZSB3aGljaCBraW5kcyBvZiBldmVudHMgaW5zaWRlIHRoZSB3aWRnZXRcbiAgICBzaG91bGQgYmUgaWdub3JlZCBieSB0aGUgZWRpdG9yLiBUaGUgZGVmYXVsdCBpcyB0byBpZ25vcmUgYWxsXG4gICAgZXZlbnRzLlxuICAgICovXG4gICAgaWdub3JlRXZlbnQoZXZlbnQpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAvKipcbiAgICBPdmVycmlkZSB0aGUgd2F5IHNjcmVlbiBjb29yZGluYXRlcyBmb3IgcG9zaXRpb25zIGF0L2luIHRoZVxuICAgIHdpZGdldCBhcmUgZm91bmQuIGBwb3NgIHdpbGwgYmUgdGhlIG9mZnNldCBpbnRvIHRoZSB3aWRnZXQsIGFuZFxuICAgIGBzaWRlYCB0aGUgc2lkZSBvZiB0aGUgcG9zaXRpb24gdGhhdCBpcyBiZWluZyBxdWVyaWVk4oCUbGVzcyB0aGFuXG4gICAgemVybyBmb3IgYmVmb3JlLCBncmVhdGVyIHRoYW4gemVybyBmb3IgYWZ0ZXIsIGFuZCB6ZXJvIGZvclxuICAgIGRpcmVjdGx5IGF0IHRoYXQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBjb29yZHNBdChkb20sIHBvcywgc2lkZSkgeyByZXR1cm4gbnVsbDsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGlzSGlkZGVuKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBlZGl0YWJsZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgYW4gaW5zdGFuY2Ugb2YgdGhlIHdpZGdldCBpcyByZW1vdmVkXG4gICAgZnJvbSB0aGUgZWRpdG9yIHZpZXcuXG4gICAgKi9cbiAgICBkZXN0cm95KGRvbSkgeyB9XG59XG4vKipcblRoZSBkaWZmZXJlbnQgdHlwZXMgb2YgYmxvY2tzIHRoYXQgY2FuIG9jY3VyIGluIGFuIGVkaXRvciB2aWV3LlxuKi9cbnZhciBCbG9ja1R5cGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChCbG9ja1R5cGUpIHtcbiAgICAvKipcbiAgICBBIGxpbmUgb2YgdGV4dC5cbiAgICAqL1xuICAgIEJsb2NrVHlwZVtCbG9ja1R5cGVbXCJUZXh0XCJdID0gMF0gPSBcIlRleHRcIjtcbiAgICAvKipcbiAgICBBIGJsb2NrIHdpZGdldCBhc3NvY2lhdGVkIHdpdGggdGhlIHBvc2l0aW9uIGFmdGVyIGl0LlxuICAgICovXG4gICAgQmxvY2tUeXBlW0Jsb2NrVHlwZVtcIldpZGdldEJlZm9yZVwiXSA9IDFdID0gXCJXaWRnZXRCZWZvcmVcIjtcbiAgICAvKipcbiAgICBBIGJsb2NrIHdpZGdldCBhc3NvY2lhdGVkIHdpdGggdGhlIHBvc2l0aW9uIGJlZm9yZSBpdC5cbiAgICAqL1xuICAgIEJsb2NrVHlwZVtCbG9ja1R5cGVbXCJXaWRnZXRBZnRlclwiXSA9IDJdID0gXCJXaWRnZXRBZnRlclwiO1xuICAgIC8qKlxuICAgIEEgYmxvY2sgd2lkZ2V0IFtyZXBsYWNpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uXnJlcGxhY2UpIGEgcmFuZ2Ugb2YgY29udGVudC5cbiAgICAqL1xuICAgIEJsb2NrVHlwZVtCbG9ja1R5cGVbXCJXaWRnZXRSYW5nZVwiXSA9IDNdID0gXCJXaWRnZXRSYW5nZVwiO1xucmV0dXJuIEJsb2NrVHlwZX0pKEJsb2NrVHlwZSB8fCAoQmxvY2tUeXBlID0ge30pKTtcbi8qKlxuQSBkZWNvcmF0aW9uIHByb3ZpZGVzIGluZm9ybWF0aW9uIG9uIGhvdyB0byBkcmF3IG9yIHN0eWxlIGEgcGllY2Vcbm9mIGNvbnRlbnQuIFlvdSdsbCB1c3VhbGx5IHVzZSBpdCB3cmFwcGVkIGluIGFcbltgUmFuZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlKSwgd2hpY2ggYWRkcyBhIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb24uXG5Abm9uYWJzdHJhY3RcbiovXG5jbGFzcyBEZWNvcmF0aW9uIGV4dGVuZHMgUmFuZ2VWYWx1ZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGFydFNpZGUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZW5kU2lkZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB3aWRnZXQsIFxuICAgIC8qKlxuICAgIFRoZSBjb25maWcgb2JqZWN0IHVzZWQgdG8gY3JlYXRlIHRoaXMgZGVjb3JhdGlvbi4gWW91IGNhblxuICAgIGluY2x1ZGUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGluIHRoZXJlIHRvIHN0b3JlIG1ldGFkYXRhIGFib3V0XG4gICAgeW91ciBkZWNvcmF0aW9uLlxuICAgICovXG4gICAgc3BlYykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnN0YXJ0U2lkZSA9IHN0YXJ0U2lkZTtcbiAgICAgICAgdGhpcy5lbmRTaWRlID0gZW5kU2lkZTtcbiAgICAgICAgdGhpcy53aWRnZXQgPSB3aWRnZXQ7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGhlaWdodFJlbGV2YW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrIGRlY29yYXRpb24sIHdoaWNoIGluZmx1ZW5jZXMgdGhlIHN0eWxpbmcgb2YgdGhlXG4gICAgY29udGVudCBpbiBpdHMgcmFuZ2UuIE5lc3RlZCBtYXJrIGRlY29yYXRpb25zIHdpbGwgY2F1c2UgbmVzdGVkXG4gICAgRE9NIGVsZW1lbnRzIHRvIGJlIGNyZWF0ZWQuIE5lc3Rpbmcgb3JkZXIgaXMgZGV0ZXJtaW5lZCBieVxuICAgIHByZWNlZGVuY2Ugb2YgdGhlIFtmYWNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeZGVjb3JhdGlvbnMpLCB3aXRoXG4gICAgdGhlIGhpZ2hlci1wcmVjZWRlbmNlIGRlY29yYXRpb25zIGNyZWF0aW5nIHRoZSBpbm5lciBET00gbm9kZXMuXG4gICAgU3VjaCBlbGVtZW50cyBhcmUgc3BsaXQgb24gbGluZSBib3VuZGFyaWVzIGFuZCBvbiB0aGUgYm91bmRhcmllc1xuICAgIG9mIGxvd2VyLXByZWNlZGVuY2UgZGVjb3JhdGlvbnMuXG4gICAgKi9cbiAgICBzdGF0aWMgbWFyayhzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFya0RlY29yYXRpb24oc3BlYyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHdpZGdldCBkZWNvcmF0aW9uLCB3aGljaCBkaXNwbGF5cyBhIERPTSBlbGVtZW50IGF0IHRoZVxuICAgIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgc3RhdGljIHdpZGdldChzcGVjKSB7XG4gICAgICAgIGxldCBzaWRlID0gTWF0aC5tYXgoLTEwMDAwLCBNYXRoLm1pbigxMDAwMCwgc3BlYy5zaWRlIHx8IDApKSwgYmxvY2sgPSAhIXNwZWMuYmxvY2s7XG4gICAgICAgIHNpZGUgKz0gKGJsb2NrICYmICFzcGVjLmlubGluZU9yZGVyKVxuICAgICAgICAgICAgPyAoc2lkZSA+IDAgPyAzMDAwMDAwMDAgLyogU2lkZS5CbG9ja0FmdGVyICovIDogLTQwMDAwMDAwMCAvKiBTaWRlLkJsb2NrQmVmb3JlICovKVxuICAgICAgICAgICAgOiAoc2lkZSA+IDAgPyAxMDAwMDAwMDAgLyogU2lkZS5JbmxpbmVBZnRlciAqLyA6IC0xMDAwMDAwMDAgLyogU2lkZS5JbmxpbmVCZWZvcmUgKi8pO1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50RGVjb3JhdGlvbihzcGVjLCBzaWRlLCBzaWRlLCBibG9jaywgc3BlYy53aWRnZXQgfHwgbnVsbCwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSByZXBsYWNlIGRlY29yYXRpb24gd2hpY2ggcmVwbGFjZXMgdGhlIGdpdmVuIHJhbmdlIHdpdGhcbiAgICBhIHdpZGdldCwgb3Igc2ltcGx5IGhpZGVzIGl0LlxuICAgICovXG4gICAgc3RhdGljIHJlcGxhY2Uoc3BlYykge1xuICAgICAgICBsZXQgYmxvY2sgPSAhIXNwZWMuYmxvY2ssIHN0YXJ0U2lkZSwgZW5kU2lkZTtcbiAgICAgICAgaWYgKHNwZWMuaXNCbG9ja0dhcCkge1xuICAgICAgICAgICAgc3RhcnRTaWRlID0gLTUwMDAwMDAwMCAvKiBTaWRlLkdhcFN0YXJ0ICovO1xuICAgICAgICAgICAgZW5kU2lkZSA9IDQwMDAwMDAwMCAvKiBTaWRlLkdhcEVuZCAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCB7IHN0YXJ0LCBlbmQgfSA9IGdldEluY2x1c2l2ZShzcGVjLCBibG9jayk7XG4gICAgICAgICAgICBzdGFydFNpZGUgPSAoc3RhcnQgPyAoYmxvY2sgPyAtMzAwMDAwMDAwIC8qIFNpZGUuQmxvY2tJbmNTdGFydCAqLyA6IC0xIC8qIFNpZGUuSW5saW5lSW5jU3RhcnQgKi8pIDogNTAwMDAwMDAwIC8qIFNpZGUuTm9uSW5jU3RhcnQgKi8pIC0gMTtcbiAgICAgICAgICAgIGVuZFNpZGUgPSAoZW5kID8gKGJsb2NrID8gMjAwMDAwMDAwIC8qIFNpZGUuQmxvY2tJbmNFbmQgKi8gOiAxIC8qIFNpZGUuSW5saW5lSW5jRW5kICovKSA6IC02MDAwMDAwMDAgLyogU2lkZS5Ob25JbmNFbmQgKi8pICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBvaW50RGVjb3JhdGlvbihzcGVjLCBzdGFydFNpZGUsIGVuZFNpZGUsIGJsb2NrLCBzcGVjLndpZGdldCB8fCBudWxsLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbGluZSBkZWNvcmF0aW9uLCB3aGljaCBjYW4gYWRkIERPTSBhdHRyaWJ1dGVzIHRvIHRoZVxuICAgIGxpbmUgc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGxpbmUoc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IExpbmVEZWNvcmF0aW9uKHNwZWMpO1xuICAgIH1cbiAgICAvKipcbiAgICBCdWlsZCBhIFtgRGVjb3JhdGlvblNldGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uU2V0KSBmcm9tIHRoZSBnaXZlblxuICAgIGRlY29yYXRlZCByYW5nZSBvciByYW5nZXMuIElmIHRoZSByYW5nZXMgYXJlbid0IGFscmVhZHkgc29ydGVkLFxuICAgIHBhc3MgYHRydWVgIGZvciBgc29ydGAgdG8gbWFrZSB0aGUgbGlicmFyeSBzb3J0IHRoZW0gZm9yIHlvdS5cbiAgICAqL1xuICAgIHN0YXRpYyBzZXQob2YsIHNvcnQgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gUmFuZ2VTZXQub2Yob2YsIHNvcnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGhhc0hlaWdodCgpIHsgcmV0dXJuIHRoaXMud2lkZ2V0ID8gdGhpcy53aWRnZXQuZXN0aW1hdGVkSGVpZ2h0ID4gLTEgOiBmYWxzZTsgfVxufVxuLyoqXG5UaGUgZW1wdHkgc2V0IG9mIGRlY29yYXRpb25zLlxuKi9cbkRlY29yYXRpb24ubm9uZSA9IFJhbmdlU2V0LmVtcHR5O1xuY2xhc3MgTWFya0RlY29yYXRpb24gZXh0ZW5kcyBEZWNvcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIGxldCB7IHN0YXJ0LCBlbmQgfSA9IGdldEluY2x1c2l2ZShzcGVjKTtcbiAgICAgICAgc3VwZXIoc3RhcnQgPyAtMSAvKiBTaWRlLklubGluZUluY1N0YXJ0ICovIDogNTAwMDAwMDAwIC8qIFNpZGUuTm9uSW5jU3RhcnQgKi8sIGVuZCA/IDEgLyogU2lkZS5JbmxpbmVJbmNFbmQgKi8gOiAtNjAwMDAwMDAwIC8qIFNpZGUuTm9uSW5jRW5kICovLCBudWxsLCBzcGVjKTtcbiAgICAgICAgdGhpcy50YWdOYW1lID0gc3BlYy50YWdOYW1lIHx8IFwic3BhblwiO1xuICAgICAgICB0aGlzLmNsYXNzID0gc3BlYy5jbGFzcyB8fCBcIlwiO1xuICAgICAgICB0aGlzLmF0dHJzID0gc3BlYy5hdHRyaWJ1dGVzIHx8IG51bGw7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8XG4gICAgICAgICAgICBvdGhlciBpbnN0YW5jZW9mIE1hcmtEZWNvcmF0aW9uICYmXG4gICAgICAgICAgICAgICAgdGhpcy50YWdOYW1lID09IG90aGVyLnRhZ05hbWUgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5jbGFzcyB8fCAoKF9hID0gdGhpcy5hdHRycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsYXNzKSkgPT0gKG90aGVyLmNsYXNzIHx8ICgoX2IgPSBvdGhlci5hdHRycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNsYXNzKSkgJiZcbiAgICAgICAgICAgICAgICBhdHRyc0VxKHRoaXMuYXR0cnMsIG90aGVyLmF0dHJzLCBcImNsYXNzXCIpO1xuICAgIH1cbiAgICByYW5nZShmcm9tLCB0byA9IGZyb20pIHtcbiAgICAgICAgaWYgKGZyb20gPj0gdG8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk1hcmsgZGVjb3JhdGlvbnMgbWF5IG5vdCBiZSBlbXB0eVwiKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnJhbmdlKGZyb20sIHRvKTtcbiAgICB9XG59XG5NYXJrRGVjb3JhdGlvbi5wcm90b3R5cGUucG9pbnQgPSBmYWxzZTtcbmNsYXNzIExpbmVEZWNvcmF0aW9uIGV4dGVuZHMgRGVjb3JhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBzdXBlcigtMjAwMDAwMDAwIC8qIFNpZGUuTGluZSAqLywgLTIwMDAwMDAwMCAvKiBTaWRlLkxpbmUgKi8sIG51bGwsIHNwZWMpO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBMaW5lRGVjb3JhdGlvbiAmJlxuICAgICAgICAgICAgdGhpcy5zcGVjLmNsYXNzID09IG90aGVyLnNwZWMuY2xhc3MgJiZcbiAgICAgICAgICAgIGF0dHJzRXEodGhpcy5zcGVjLmF0dHJpYnV0ZXMsIG90aGVyLnNwZWMuYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIHJhbmdlKGZyb20sIHRvID0gZnJvbSkge1xuICAgICAgICBpZiAodG8gIT0gZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTGluZSBkZWNvcmF0aW9uIHJhbmdlcyBtdXN0IGJlIHplcm8tbGVuZ3RoXCIpO1xuICAgICAgICByZXR1cm4gc3VwZXIucmFuZ2UoZnJvbSwgdG8pO1xuICAgIH1cbn1cbkxpbmVEZWNvcmF0aW9uLnByb3RvdHlwZS5tYXBNb2RlID0gTWFwTW9kZS5UcmFja0JlZm9yZTtcbkxpbmVEZWNvcmF0aW9uLnByb3RvdHlwZS5wb2ludCA9IHRydWU7XG5jbGFzcyBQb2ludERlY29yYXRpb24gZXh0ZW5kcyBEZWNvcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjLCBzdGFydFNpZGUsIGVuZFNpZGUsIGJsb2NrLCB3aWRnZXQsIGlzUmVwbGFjZSkge1xuICAgICAgICBzdXBlcihzdGFydFNpZGUsIGVuZFNpZGUsIHdpZGdldCwgc3BlYyk7XG4gICAgICAgIHRoaXMuYmxvY2sgPSBibG9jaztcbiAgICAgICAgdGhpcy5pc1JlcGxhY2UgPSBpc1JlcGxhY2U7XG4gICAgICAgIHRoaXMubWFwTW9kZSA9ICFibG9jayA/IE1hcE1vZGUuVHJhY2tEZWwgOiBzdGFydFNpZGUgPD0gMCA/IE1hcE1vZGUuVHJhY2tCZWZvcmUgOiBNYXBNb2RlLlRyYWNrQWZ0ZXI7XG4gICAgfVxuICAgIC8vIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGlzLmJsb2NrID09IHRydWVcbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRTaWRlICE9IHRoaXMuZW5kU2lkZSA/IEJsb2NrVHlwZS5XaWRnZXRSYW5nZVxuICAgICAgICAgICAgOiB0aGlzLnN0YXJ0U2lkZSA8PSAwID8gQmxvY2tUeXBlLldpZGdldEJlZm9yZSA6IEJsb2NrVHlwZS5XaWRnZXRBZnRlcjtcbiAgICB9XG4gICAgZ2V0IGhlaWdodFJlbGV2YW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibG9jayB8fCAhIXRoaXMud2lkZ2V0ICYmICh0aGlzLndpZGdldC5lc3RpbWF0ZWRIZWlnaHQgPj0gNSB8fCB0aGlzLndpZGdldC5saW5lQnJlYWtzID4gMCk7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIFBvaW50RGVjb3JhdGlvbiAmJlxuICAgICAgICAgICAgd2lkZ2V0c0VxKHRoaXMud2lkZ2V0LCBvdGhlci53aWRnZXQpICYmXG4gICAgICAgICAgICB0aGlzLmJsb2NrID09IG90aGVyLmJsb2NrICYmXG4gICAgICAgICAgICB0aGlzLnN0YXJ0U2lkZSA9PSBvdGhlci5zdGFydFNpZGUgJiYgdGhpcy5lbmRTaWRlID09IG90aGVyLmVuZFNpZGU7XG4gICAgfVxuICAgIHJhbmdlKGZyb20sIHRvID0gZnJvbSkge1xuICAgICAgICBpZiAodGhpcy5pc1JlcGxhY2UgJiYgKGZyb20gPiB0byB8fCAoZnJvbSA9PSB0byAmJiB0aGlzLnN0YXJ0U2lkZSA+IDAgJiYgdGhpcy5lbmRTaWRlIDw9IDApKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCByYW5nZSBmb3IgcmVwbGFjZW1lbnQgZGVjb3JhdGlvblwiKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVwbGFjZSAmJiB0byAhPSBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJXaWRnZXQgZGVjb3JhdGlvbnMgY2FuIG9ubHkgaGF2ZSB6ZXJvLWxlbmd0aCByYW5nZXNcIik7XG4gICAgICAgIHJldHVybiBzdXBlci5yYW5nZShmcm9tLCB0byk7XG4gICAgfVxufVxuUG9pbnREZWNvcmF0aW9uLnByb3RvdHlwZS5wb2ludCA9IHRydWU7XG5mdW5jdGlvbiBnZXRJbmNsdXNpdmUoc3BlYywgYmxvY2sgPSBmYWxzZSkge1xuICAgIGxldCB7IGluY2x1c2l2ZVN0YXJ0OiBzdGFydCwgaW5jbHVzaXZlRW5kOiBlbmQgfSA9IHNwZWM7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpXG4gICAgICAgIHN0YXJ0ID0gc3BlYy5pbmNsdXNpdmU7XG4gICAgaWYgKGVuZCA9PSBudWxsKVxuICAgICAgICBlbmQgPSBzcGVjLmluY2x1c2l2ZTtcbiAgICByZXR1cm4geyBzdGFydDogc3RhcnQgIT09IG51bGwgJiYgc3RhcnQgIT09IHZvaWQgMCA/IHN0YXJ0IDogYmxvY2ssIGVuZDogZW5kICE9PSBudWxsICYmIGVuZCAhPT0gdm9pZCAwID8gZW5kIDogYmxvY2sgfTtcbn1cbmZ1bmN0aW9uIHdpZGdldHNFcShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT0gYiB8fCAhIShhICYmIGIgJiYgYS5jb21wYXJlKGIpKTtcbn1cbmZ1bmN0aW9uIGFkZFJhbmdlKGZyb20sIHRvLCByYW5nZXMsIG1hcmdpbiA9IDApIHtcbiAgICBsZXQgbGFzdCA9IHJhbmdlcy5sZW5ndGggLSAxO1xuICAgIGlmIChsYXN0ID49IDAgJiYgcmFuZ2VzW2xhc3RdICsgbWFyZ2luID49IGZyb20pXG4gICAgICAgIHJhbmdlc1tsYXN0XSA9IE1hdGgubWF4KHJhbmdlc1tsYXN0XSwgdG8pO1xuICAgIGVsc2VcbiAgICAgICAgcmFuZ2VzLnB1c2goZnJvbSwgdG8pO1xufVxuXG5jbGFzcyBDb250ZW50QnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoZG9jLCBwb3MsIGVuZCwgZGlzYWxsb3dCbG9ja0VmZmVjdHNGb3IpIHtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgdGhpcy5kaXNhbGxvd0Jsb2NrRWZmZWN0c0ZvciA9IGRpc2FsbG93QmxvY2tFZmZlY3RzRm9yO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBbXTtcbiAgICAgICAgdGhpcy5jdXJMaW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5icmVha0F0U3RhcnQgPSAwO1xuICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXIgPSAwIC8qIEJ1Zi5ObyAqLztcbiAgICAgICAgdGhpcy5idWZmZXJNYXJrcyA9IFtdO1xuICAgICAgICAvLyBTZXQgdG8gZmFsc2UgZGlyZWN0bHkgYWZ0ZXIgYSB3aWRnZXQgdGhhdCBjb3ZlcnMgdGhlIHBvc2l0aW9uIGFmdGVyIGl0XG4gICAgICAgIHRoaXMuYXRDdXJzb3JQb3MgPSB0cnVlO1xuICAgICAgICB0aGlzLm9wZW5TdGFydCA9IC0xO1xuICAgICAgICB0aGlzLm9wZW5FbmQgPSAtMTtcbiAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgdGhpcy50ZXh0T2ZmID0gMDtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBkb2MuaXRlcigpO1xuICAgICAgICB0aGlzLnNraXAgPSBwb3M7XG4gICAgfVxuICAgIHBvc0NvdmVyZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuYnJlYWtBdFN0YXJ0ICYmIHRoaXMuZG9jLmxpbmVBdCh0aGlzLnBvcykuZnJvbSAhPSB0aGlzLnBvcztcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gIShsYXN0LmJyZWFrQWZ0ZXIgfHwgbGFzdCBpbnN0YW5jZW9mIEJsb2NrV2lkZ2V0VmlldyAmJiBsYXN0LmRlY28uZW5kU2lkZSA8IDApO1xuICAgIH1cbiAgICBnZXRMaW5lKCkge1xuICAgICAgICBpZiAoIXRoaXMuY3VyTGluZSkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50LnB1c2godGhpcy5jdXJMaW5lID0gbmV3IExpbmVWaWV3KTtcbiAgICAgICAgICAgIHRoaXMuYXRDdXJzb3JQb3MgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmN1ckxpbmU7XG4gICAgfVxuICAgIGZsdXNoQnVmZmVyKGFjdGl2ZSA9IHRoaXMuYnVmZmVyTWFya3MpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0J1ZmZlcikge1xuICAgICAgICAgICAgdGhpcy5jdXJMaW5lLmFwcGVuZCh3cmFwTWFya3MobmV3IFdpZGdldEJ1ZmZlclZpZXcoLTEpLCBhY3RpdmUpLCBhY3RpdmUubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlciA9IDAgLyogQnVmLk5vICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEJsb2NrV2lkZ2V0KHZpZXcpIHtcbiAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlcigpO1xuICAgICAgICB0aGlzLmN1ckxpbmUgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRlbnQucHVzaCh2aWV3KTtcbiAgICB9XG4gICAgZmluaXNoKG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0J1ZmZlciAmJiBvcGVuRW5kIDw9IHRoaXMuYnVmZmVyTWFya3MubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlcigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXIgPSAwIC8qIEJ1Zi5ObyAqLztcbiAgICAgICAgaWYgKCF0aGlzLnBvc0NvdmVyZWQoKSAmJlxuICAgICAgICAgICAgIShvcGVuRW5kICYmIHRoaXMuY29udGVudC5sZW5ndGggJiYgdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXSBpbnN0YW5jZW9mIEJsb2NrV2lkZ2V0VmlldykpXG4gICAgICAgICAgICB0aGlzLmdldExpbmUoKTtcbiAgICB9XG4gICAgYnVpbGRUZXh0KGxlbmd0aCwgYWN0aXZlLCBvcGVuU3RhcnQpIHtcbiAgICAgICAgd2hpbGUgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRleHRPZmYgPT0gdGhpcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCB7IHZhbHVlLCBsaW5lQnJlYWssIGRvbmUgfSA9IHRoaXMuY3Vyc29yLm5leHQodGhpcy5za2lwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNraXAgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSYW4gb3V0IG9mIHRleHQgY29udGVudCB3aGVuIGRyYXdpbmcgaW5saW5lIHZpZXdzXCIpO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lQnJlYWspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBvc0NvdmVyZWQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0uYnJlYWtBZnRlciA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnJlYWtBdFN0YXJ0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1ckxpbmUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0Q3Vyc29yUG9zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dE9mZiA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRha2UgPSBNYXRoLm1pbih0aGlzLnRleHQubGVuZ3RoIC0gdGhpcy50ZXh0T2ZmLCBsZW5ndGgsIDUxMiAvKiBULkNodW5rICovKTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoYWN0aXZlLnNsaWNlKGFjdGl2ZS5sZW5ndGggLSBvcGVuU3RhcnQpKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpLmFwcGVuZCh3cmFwTWFya3MobmV3IFRleHRWaWV3KHRoaXMudGV4dC5zbGljZSh0aGlzLnRleHRPZmYsIHRoaXMudGV4dE9mZiArIHRha2UpKSwgYWN0aXZlKSwgb3BlblN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuYXRDdXJzb3JQb3MgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy50ZXh0T2ZmICs9IHRha2U7XG4gICAgICAgICAgICBsZW5ndGggLT0gdGFrZTtcbiAgICAgICAgICAgIG9wZW5TdGFydCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3Bhbihmcm9tLCB0bywgYWN0aXZlLCBvcGVuU3RhcnQpIHtcbiAgICAgICAgdGhpcy5idWlsZFRleHQodG8gLSBmcm9tLCBhY3RpdmUsIG9wZW5TdGFydCk7XG4gICAgICAgIHRoaXMucG9zID0gdG87XG4gICAgICAgIGlmICh0aGlzLm9wZW5TdGFydCA8IDApXG4gICAgICAgICAgICB0aGlzLm9wZW5TdGFydCA9IG9wZW5TdGFydDtcbiAgICB9XG4gICAgcG9pbnQoZnJvbSwgdG8sIGRlY28sIGFjdGl2ZSwgb3BlblN0YXJ0LCBpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhbGxvd0Jsb2NrRWZmZWN0c0ZvcltpbmRleF0gJiYgZGVjbyBpbnN0YW5jZW9mIFBvaW50RGVjb3JhdGlvbikge1xuICAgICAgICAgICAgaWYgKGRlY28uYmxvY2spXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCbG9jayBkZWNvcmF0aW9ucyBtYXkgbm90IGJlIHNwZWNpZmllZCB2aWEgcGx1Z2luc1wiKTtcbiAgICAgICAgICAgIGlmICh0byA+IHRoaXMuZG9jLmxpbmVBdCh0aGlzLnBvcykudG8pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEZWNvcmF0aW9ucyB0aGF0IHJlcGxhY2UgbGluZSBicmVha3MgbWF5IG5vdCBiZSBzcGVjaWZpZWQgdmlhIHBsdWdpbnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxlbiA9IHRvIC0gZnJvbTtcbiAgICAgICAgaWYgKGRlY28gaW5zdGFuY2VvZiBQb2ludERlY29yYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChkZWNvLmJsb2NrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlY28uc3RhcnRTaWRlID4gMCAmJiAhdGhpcy5wb3NDb3ZlcmVkKCkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQmxvY2tXaWRnZXQobmV3IEJsb2NrV2lkZ2V0VmlldyhkZWNvLndpZGdldCB8fCBuZXcgTnVsbFdpZGdldChcImRpdlwiKSwgbGVuLCBkZWNvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdmlldyA9IFdpZGdldFZpZXcuY3JlYXRlKGRlY28ud2lkZ2V0IHx8IG5ldyBOdWxsV2lkZ2V0KFwic3BhblwiKSwgbGVuLCBsZW4gPyAwIDogZGVjby5zdGFydFNpZGUpO1xuICAgICAgICAgICAgICAgIGxldCBjdXJzb3JCZWZvcmUgPSB0aGlzLmF0Q3Vyc29yUG9zICYmICF2aWV3LmlzRWRpdGFibGUgJiYgb3BlblN0YXJ0IDw9IGFjdGl2ZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgKGZyb20gPCB0byB8fCBkZWNvLnN0YXJ0U2lkZSA+IDApO1xuICAgICAgICAgICAgICAgIGxldCBjdXJzb3JBZnRlciA9ICF2aWV3LmlzRWRpdGFibGUgJiYgKGZyb20gPCB0byB8fCBvcGVuU3RhcnQgPiBhY3RpdmUubGVuZ3RoIHx8IGRlY28uc3RhcnRTaWRlIDw9IDApO1xuICAgICAgICAgICAgICAgIGxldCBsaW5lID0gdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0J1ZmZlciA9PSAyIC8qIEJ1Zi5JZkN1cnNvciAqLyAmJiAhY3Vyc29yQmVmb3JlICYmICF2aWV3LmlzRWRpdGFibGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlciA9IDAgLyogQnVmLk5vICovO1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoYWN0aXZlKTtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yQmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUuYXBwZW5kKHdyYXBNYXJrcyhuZXcgV2lkZ2V0QnVmZmVyVmlldygxKSwgYWN0aXZlKSwgb3BlblN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgb3BlblN0YXJ0ID0gYWN0aXZlLmxlbmd0aCArIE1hdGgubWF4KDAsIG9wZW5TdGFydCAtIGFjdGl2ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5lLmFwcGVuZCh3cmFwTWFya3ModmlldywgYWN0aXZlKSwgb3BlblN0YXJ0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmF0Q3Vyc29yUG9zID0gY3Vyc29yQWZ0ZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyID0gIWN1cnNvckFmdGVyID8gMCAvKiBCdWYuTm8gKi8gOiBmcm9tIDwgdG8gfHwgb3BlblN0YXJ0ID4gYWN0aXZlLmxlbmd0aCA/IDEgLyogQnVmLlllcyAqLyA6IDIgLyogQnVmLklmQ3Vyc29yICovO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdCdWZmZXIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyTWFya3MgPSBhY3RpdmUuc2xpY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRvYy5saW5lQXQodGhpcy5wb3MpLmZyb20gPT0gdGhpcy5wb3MpIHsgLy8gTGluZSBkZWNvcmF0aW9uXG4gICAgICAgICAgICB0aGlzLmdldExpbmUoKS5hZGRMaW5lRGVjbyhkZWNvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAvLyBBZHZhbmNlIHRoZSBpdGVyYXRvciBwYXN0IHRoZSByZXBsYWNlZCBjb250ZW50XG4gICAgICAgICAgICBpZiAodGhpcy50ZXh0T2ZmICsgbGVuIDw9IHRoaXMudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRPZmYgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwICs9IGxlbiAtICh0aGlzLnRleHQubGVuZ3RoIC0gdGhpcy50ZXh0T2ZmKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dE9mZiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRvO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wZW5TdGFydCA8IDApXG4gICAgICAgICAgICB0aGlzLm9wZW5TdGFydCA9IG9wZW5TdGFydDtcbiAgICB9XG4gICAgc3RhdGljIGJ1aWxkKHRleHQsIGZyb20sIHRvLCBkZWNvcmF0aW9ucywgZHluYW1pY0RlY29yYXRpb25NYXApIHtcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgQ29udGVudEJ1aWxkZXIodGV4dCwgZnJvbSwgdG8sIGR5bmFtaWNEZWNvcmF0aW9uTWFwKTtcbiAgICAgICAgYnVpbGRlci5vcGVuRW5kID0gUmFuZ2VTZXQuc3BhbnMoZGVjb3JhdGlvbnMsIGZyb20sIHRvLCBidWlsZGVyKTtcbiAgICAgICAgaWYgKGJ1aWxkZXIub3BlblN0YXJ0IDwgMClcbiAgICAgICAgICAgIGJ1aWxkZXIub3BlblN0YXJ0ID0gYnVpbGRlci5vcGVuRW5kO1xuICAgICAgICBidWlsZGVyLmZpbmlzaChidWlsZGVyLm9wZW5FbmQpO1xuICAgICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9XG59XG5mdW5jdGlvbiB3cmFwTWFya3ModmlldywgYWN0aXZlKSB7XG4gICAgZm9yIChsZXQgbWFyayBvZiBhY3RpdmUpXG4gICAgICAgIHZpZXcgPSBuZXcgTWFya1ZpZXcobWFyaywgW3ZpZXddLCB2aWV3Lmxlbmd0aCk7XG4gICAgcmV0dXJuIHZpZXc7XG59XG5jbGFzcyBOdWxsV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IodGFnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIudGFnID09IHRoaXMudGFnOyB9XG4gICAgdG9ET00oKSB7IHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMudGFnKTsgfVxuICAgIHVwZGF0ZURPTShlbHQpIHsgcmV0dXJuIGVsdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09IHRoaXMudGFnOyB9XG4gICAgZ2V0IGlzSGlkZGVuKCkgeyByZXR1cm4gdHJ1ZTsgfVxufVxuXG4vKipcblVzZWQgdG8gaW5kaWNhdGUgW3RleHQgZGlyZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy50ZXh0RGlyZWN0aW9uKS5cbiovXG52YXIgRGlyZWN0aW9uID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoRGlyZWN0aW9uKSB7XG4gICAgLy8gKFRoZXNlIGFyZSBjaG9zZW4gdG8gbWF0Y2ggdGhlIGJhc2UgbGV2ZWxzLCBpbiBiaWRpIGFsZ29yaXRobVxuICAgIC8vIHRlcm1zLCBvZiBzcGFucyBpbiB0aGF0IGRpcmVjdGlvbi4pXG4gICAgLyoqXG4gICAgTGVmdC10by1yaWdodC5cbiAgICAqL1xuICAgIERpcmVjdGlvbltEaXJlY3Rpb25bXCJMVFJcIl0gPSAwXSA9IFwiTFRSXCI7XG4gICAgLyoqXG4gICAgUmlnaHQtdG8tbGVmdC5cbiAgICAqL1xuICAgIERpcmVjdGlvbltEaXJlY3Rpb25bXCJSVExcIl0gPSAxXSA9IFwiUlRMXCI7XG5yZXR1cm4gRGlyZWN0aW9ufSkoRGlyZWN0aW9uIHx8IChEaXJlY3Rpb24gPSB7fSkpO1xuY29uc3QgTFRSID0gRGlyZWN0aW9uLkxUUiwgUlRMID0gRGlyZWN0aW9uLlJUTDtcbi8vIERlY29kZSBhIHN0cmluZyB3aXRoIGVhY2ggdHlwZSBlbmNvZGVkIGFzIGxvZzIodHlwZSlcbmZ1bmN0aW9uIGRlYyhzdHIpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspXG4gICAgICAgIHJlc3VsdC5wdXNoKDEgPDwgK3N0cltpXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIENoYXJhY3RlciB0eXBlcyBmb3IgY29kZXBvaW50cyAwIHRvIDB4ZjhcbmNvbnN0IExvd1R5cGVzID0gLypAX19QVVJFX18qL2RlYyhcIjg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4NjY2ODg4ODg4Nzg3ODMzMzMzMzMzMzM3ODg4ODg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4ODg4ODgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg3ODY2NjY4ODg4MDg4ODg4NjYzMzgwODg4MzA4ODg4ODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4XCIpO1xuLy8gQ2hhcmFjdGVyIHR5cGVzIGZvciBjb2RlcG9pbnRzIDB4NjAwIHRvIDB4NmY5XG5jb25zdCBBcmFiaWNUeXBlcyA9IC8qQF9fUFVSRV9fKi9kZWMoXCI0NDQ0NDQ4ODI2NjI3Mjg4OTk5OTk5OTk5OTkyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI5OTk5OTk5OTk5OTk5OTk5OTk5OTk0NDQ0NDQ0NDQ0NjQ0MjIyODIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyOTk5OTk5OTQ5OTk5OTk5MjI5OTg5OTk5MjIzMzMzMzMzMzMzXCIpO1xuY29uc3QgQnJhY2tldHMgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKSwgQnJhY2tldFN0YWNrID0gW107XG4vLyBUaGVyZSdzIGEgbG90IG1vcmUgaW5cbi8vIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9VQ0QvbGF0ZXN0L3VjZC9CaWRpQnJhY2tldHMudHh0LFxuLy8gd2hpY2ggYXJlIGxlZnQgb3V0IHRvIGtlZXAgY29kZSBzaXplIGRvd24uXG5mb3IgKGxldCBwIG9mIFtcIigpXCIsIFwiW11cIiwgXCJ7fVwiXSkge1xuICAgIGxldCBsID0gLypAX19QVVJFX18qL3AuY2hhckNvZGVBdCgwKSwgciA9IC8qQF9fUFVSRV9fKi9wLmNoYXJDb2RlQXQoMSk7XG4gICAgQnJhY2tldHNbbF0gPSByO1xuICAgIEJyYWNrZXRzW3JdID0gLWw7XG59XG5mdW5jdGlvbiBjaGFyVHlwZShjaCkge1xuICAgIHJldHVybiBjaCA8PSAweGY3ID8gTG93VHlwZXNbY2hdIDpcbiAgICAgICAgMHg1OTAgPD0gY2ggJiYgY2ggPD0gMHg1ZjQgPyAyIC8qIFQuUiAqLyA6XG4gICAgICAgICAgICAweDYwMCA8PSBjaCAmJiBjaCA8PSAweDZmOSA/IEFyYWJpY1R5cGVzW2NoIC0gMHg2MDBdIDpcbiAgICAgICAgICAgICAgICAweDZlZSA8PSBjaCAmJiBjaCA8PSAweDhhYyA/IDQgLyogVC5BTCAqLyA6XG4gICAgICAgICAgICAgICAgICAgIDB4MjAwMCA8PSBjaCAmJiBjaCA8PSAweDIwMGMgPyAyNTYgLyogVC5OSSAqLyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAweGZiNTAgPD0gY2ggJiYgY2ggPD0gMHhmZGZmID8gNCAvKiBULkFMICovIDogMSAvKiBULkwgKi87XG59XG5jb25zdCBCaWRpUkUgPSAvW1xcdTA1OTAtXFx1MDVmNFxcdTA2MDAtXFx1MDZmZlxcdTA3MDAtXFx1MDhhY1xcdWZiNTAtXFx1ZmRmZl0vO1xuLyoqXG5SZXByZXNlbnRzIGEgY29udGlndW91cyByYW5nZSBvZiB0ZXh0IHRoYXQgaGFzIGEgc2luZ2xlIGRpcmVjdGlvblxuKGFzIGluIGxlZnQtdG8tcmlnaHQgb3IgcmlnaHQtdG8tbGVmdCkuXG4qL1xuY2xhc3MgQmlkaVNwYW4ge1xuICAgIC8qKlxuICAgIFRoZSBkaXJlY3Rpb24gb2YgdGhpcyBzcGFuLlxuICAgICovXG4gICAgZ2V0IGRpcigpIHsgcmV0dXJuIHRoaXMubGV2ZWwgJSAyID8gUlRMIDogTFRSOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgb2YgdGhlIHNwYW4gKHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgbGluZSkuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIG9mIHRoZSBzcGFuLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSBbXCJiaWRpXG4gICAgbGV2ZWxcIl0oaHR0cHM6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyOS8jQmFzaWNfRGlzcGxheV9BbGdvcml0aG0pXG4gICAgb2YgdGhlIHNwYW4gKGluIHRoaXMgY29udGV4dCwgMCBtZWFuc1xuICAgIGxlZnQtdG8tcmlnaHQsIDEgbWVhbnMgcmlnaHQtdG8tbGVmdCwgMiBtZWFucyBsZWZ0LXRvLXJpZ2h0XG4gICAgbnVtYmVyIGluc2lkZSByaWdodC10by1sZWZ0IHRleHQpLlxuICAgICovXG4gICAgbGV2ZWwpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2lkZShlbmQsIGRpcikgeyByZXR1cm4gKHRoaXMuZGlyID09IGRpcikgPT0gZW5kID8gdGhpcy50byA6IHRoaXMuZnJvbTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZm9yd2FyZChmb3J3YXJkLCBkaXIpIHsgcmV0dXJuIGZvcndhcmQgPT0gKHRoaXMuZGlyID09IGRpcik7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmaW5kKG9yZGVyLCBpbmRleCwgbGV2ZWwsIGFzc29jKSB7XG4gICAgICAgIGxldCBtYXliZSA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3BhbiA9IG9yZGVyW2ldO1xuICAgICAgICAgICAgaWYgKHNwYW4uZnJvbSA8PSBpbmRleCAmJiBzcGFuLnRvID49IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwYW4ubGV2ZWwgPT0gbGV2ZWwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gbXVsdGlwbGUgc3BhbnMgbWF0Y2gsIGlmIGFzc29jICE9IDAsIHRha2UgdGhlIG9uZSB0aGF0XG4gICAgICAgICAgICAgICAgLy8gY292ZXJzIHRoYXQgc2lkZSwgb3RoZXJ3aXNlIHRha2UgdGhlIG9uZSB3aXRoIHRoZSBtaW5pbXVtXG4gICAgICAgICAgICAgICAgLy8gbGV2ZWwuXG4gICAgICAgICAgICAgICAgaWYgKG1heWJlIDwgMCB8fCAoYXNzb2MgIT0gMCA/IChhc3NvYyA8IDAgPyBzcGFuLmZyb20gPCBpbmRleCA6IHNwYW4udG8gPiBpbmRleCkgOiBvcmRlclttYXliZV0ubGV2ZWwgPiBzcGFuLmxldmVsKSlcbiAgICAgICAgICAgICAgICAgICAgbWF5YmUgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXliZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtcbiAgICAgICAgcmV0dXJuIG1heWJlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzb2xhdGVzRXEoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgaUEgPSBhW2ldLCBpQiA9IGJbaV07XG4gICAgICAgIGlmIChpQS5mcm9tICE9IGlCLmZyb20gfHwgaUEudG8gIT0gaUIudG8gfHwgaUEuZGlyZWN0aW9uICE9IGlCLmRpcmVjdGlvbiB8fCAhaXNvbGF0ZXNFcShpQS5pbm5lciwgaUIuaW5uZXIpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIFJldXNlZCBhcnJheSBvZiBjaGFyYWN0ZXIgdHlwZXNcbmNvbnN0IHR5cGVzID0gW107XG4vLyBGaWxsIGluIHRoZSBjaGFyYWN0ZXIgdHlwZXMgKGluIGB0eXBlc2ApIGZyb20gYGZyb21gIHRvIGB0b2AgYW5kXG4vLyBhcHBseSBXIG5vcm1hbGl6YXRpb24gcnVsZXMuXG5mdW5jdGlvbiBjb21wdXRlQ2hhclR5cGVzKGxpbmUsIHJGcm9tLCByVG8sIGlzb2xhdGVzLCBvdXRlclR5cGUpIHtcbiAgICBmb3IgKGxldCBpSSA9IDA7IGlJIDw9IGlzb2xhdGVzLmxlbmd0aDsgaUkrKykge1xuICAgICAgICBsZXQgZnJvbSA9IGlJID8gaXNvbGF0ZXNbaUkgLSAxXS50byA6IHJGcm9tLCB0byA9IGlJIDwgaXNvbGF0ZXMubGVuZ3RoID8gaXNvbGF0ZXNbaUldLmZyb20gOiByVG87XG4gICAgICAgIGxldCBwcmV2VHlwZSA9IGlJID8gMjU2IC8qIFQuTkkgKi8gOiBvdXRlclR5cGU7XG4gICAgICAgIC8vIFcxLiBFeGFtaW5lIGVhY2ggbm9uLXNwYWNpbmcgbWFyayAoTlNNKSBpbiB0aGUgbGV2ZWwgcnVuLCBhbmRcbiAgICAgICAgLy8gY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBOU00gdG8gdGhlIHR5cGUgb2YgdGhlIHByZXZpb3VzXG4gICAgICAgIC8vIGNoYXJhY3Rlci4gSWYgdGhlIE5TTSBpcyBhdCB0aGUgc3RhcnQgb2YgdGhlIGxldmVsIHJ1biwgaXQgd2lsbFxuICAgICAgICAvLyBnZXQgdGhlIHR5cGUgb2Ygc29yLlxuICAgICAgICAvLyBXMi4gU2VhcmNoIGJhY2t3YXJkcyBmcm9tIGVhY2ggaW5zdGFuY2Ugb2YgYSBFdXJvcGVhbiBudW1iZXJcbiAgICAgICAgLy8gdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChSLCBMLCBBTCwgb3Igc29yKSBpcyBmb3VuZC4gSWYgYW5cbiAgICAgICAgLy8gQUwgaXMgZm91bmQsIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgRXVyb3BlYW4gbnVtYmVyIHRvIEFyYWJpY1xuICAgICAgICAvLyBudW1iZXIuXG4gICAgICAgIC8vIFczLiBDaGFuZ2UgYWxsIEFMcyB0byBSLlxuICAgICAgICAvLyAoTGVmdCBhZnRlciB0aGlzOiBMLCBSLCBFTiwgQU4sIEVULCBDUywgTkkpXG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tLCBwcmV2ID0gcHJldlR5cGUsIHByZXZTdHJvbmcgPSBwcmV2VHlwZTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gY2hhclR5cGUobGluZS5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09IDUxMiAvKiBULk5TTSAqLylcbiAgICAgICAgICAgICAgICB0eXBlID0gcHJldjtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gOCAvKiBULkVOICovICYmIHByZXZTdHJvbmcgPT0gNCAvKiBULkFMICovKVxuICAgICAgICAgICAgICAgIHR5cGUgPSAxNiAvKiBULkFOICovO1xuICAgICAgICAgICAgdHlwZXNbaV0gPSB0eXBlID09IDQgLyogVC5BTCAqLyA/IDIgLyogVC5SICovIDogdHlwZTtcbiAgICAgICAgICAgIGlmICh0eXBlICYgNyAvKiBULlN0cm9uZyAqLylcbiAgICAgICAgICAgICAgICBwcmV2U3Ryb25nID0gdHlwZTtcbiAgICAgICAgICAgIHByZXYgPSB0eXBlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFc1LiBBIHNlcXVlbmNlIG9mIEV1cm9wZWFuIHRlcm1pbmF0b3JzIGFkamFjZW50IHRvIEV1cm9wZWFuXG4gICAgICAgIC8vIG51bWJlcnMgY2hhbmdlcyB0byBhbGwgRXVyb3BlYW4gbnVtYmVycy5cbiAgICAgICAgLy8gVzYuIE90aGVyd2lzZSwgc2VwYXJhdG9ycyBhbmQgdGVybWluYXRvcnMgY2hhbmdlIHRvIE90aGVyXG4gICAgICAgIC8vIE5ldXRyYWwuXG4gICAgICAgIC8vIFc3LiBTZWFyY2ggYmFja3dhcmRzIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlclxuICAgICAgICAvLyB1bnRpbCB0aGUgZmlyc3Qgc3Ryb25nIHR5cGUgKFIsIEwsIG9yIHNvcikgaXMgZm91bmQuIElmIGFuIEwgaXNcbiAgICAgICAgLy8gZm91bmQsIHRoZW4gY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBFdXJvcGVhbiBudW1iZXIgdG8gTC5cbiAgICAgICAgLy8gKExlZnQgYWZ0ZXIgdGhpczogTCwgUiwgRU4rQU4sIE5JKVxuICAgICAgICBmb3IgKGxldCBpID0gZnJvbSwgcHJldiA9IHByZXZUeXBlLCBwcmV2U3Ryb25nID0gcHJldlR5cGU7IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gMTI4IC8qIFQuQ1MgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IHRvIC0gMSAmJiBwcmV2ID09IHR5cGVzW2kgKyAxXSAmJiAocHJldiAmIDI0IC8qIFQuTnVtICovKSlcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHR5cGVzW2ldID0gcHJldjtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHR5cGVzW2ldID0gMjU2IC8qIFQuTkkgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IDY0IC8qIFQuRVQgKi8pIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kID0gaSArIDE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGVuZCA8IHRvICYmIHR5cGVzW2VuZF0gPT0gNjQgLyogVC5FVCAqLylcbiAgICAgICAgICAgICAgICAgICAgZW5kKys7XG4gICAgICAgICAgICAgICAgbGV0IHJlcGxhY2UgPSAoaSAmJiBwcmV2ID09IDggLyogVC5FTiAqLykgfHwgKGVuZCA8IHJUbyAmJiB0eXBlc1tlbmRdID09IDggLyogVC5FTiAqLykgPyAocHJldlN0cm9uZyA9PSAxIC8qIFQuTCAqLyA/IDEgLyogVC5MICovIDogOCAvKiBULkVOICovKSA6IDI1NiAvKiBULk5JICovO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpOyBqIDwgZW5kOyBqKyspXG4gICAgICAgICAgICAgICAgICAgIHR5cGVzW2pdID0gcmVwbGFjZTtcbiAgICAgICAgICAgICAgICBpID0gZW5kIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gOCAvKiBULkVOICovICYmIHByZXZTdHJvbmcgPT0gMSAvKiBULkwgKi8pIHtcbiAgICAgICAgICAgICAgICB0eXBlc1tpXSA9IDEgLyogVC5MICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldiA9IHR5cGU7XG4gICAgICAgICAgICBpZiAodHlwZSAmIDcgLyogVC5TdHJvbmcgKi8pXG4gICAgICAgICAgICAgICAgcHJldlN0cm9uZyA9IHR5cGU7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBQcm9jZXNzIGJyYWNrZXRzIHRocm91Z2hvdXQgYSBydW4gc2VxdWVuY2UuXG5mdW5jdGlvbiBwcm9jZXNzQnJhY2tldFBhaXJzKGxpbmUsIHJGcm9tLCByVG8sIGlzb2xhdGVzLCBvdXRlclR5cGUpIHtcbiAgICBsZXQgb3Bwb3NpdGVUeXBlID0gb3V0ZXJUeXBlID09IDEgLyogVC5MICovID8gMiAvKiBULlIgKi8gOiAxIC8qIFQuTCAqLztcbiAgICBmb3IgKGxldCBpSSA9IDAsIHNJID0gMCwgY29udGV4dCA9IDA7IGlJIDw9IGlzb2xhdGVzLmxlbmd0aDsgaUkrKykge1xuICAgICAgICBsZXQgZnJvbSA9IGlJID8gaXNvbGF0ZXNbaUkgLSAxXS50byA6IHJGcm9tLCB0byA9IGlJIDwgaXNvbGF0ZXMubGVuZ3RoID8gaXNvbGF0ZXNbaUldLmZyb20gOiByVG87XG4gICAgICAgIC8vIE4wLiBQcm9jZXNzIGJyYWNrZXQgcGFpcnMgaW4gYW4gaXNvbGF0aW5nIHJ1biBzZXF1ZW5jZVxuICAgICAgICAvLyBzZXF1ZW50aWFsbHkgaW4gdGhlIGxvZ2ljYWwgb3JkZXIgb2YgdGhlIHRleHQgcG9zaXRpb25zIG9mIHRoZVxuICAgICAgICAvLyBvcGVuaW5nIHBhaXJlZCBicmFja2V0cyB1c2luZyB0aGUgbG9naWMgZ2l2ZW4gYmVsb3cuIFdpdGhpbiB0aGlzXG4gICAgICAgIC8vIHNjb3BlLCBiaWRpcmVjdGlvbmFsIHR5cGVzIEVOIGFuZCBBTiBhcmUgdHJlYXRlZCBhcyBSLlxuICAgICAgICBmb3IgKGxldCBpID0gZnJvbSwgY2gsIGJyLCB0eXBlOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgLy8gS2VlcHMgW3N0YXJ0SW5kZXgsIHR5cGUsIHN0cm9uZ1NlZW5dIHRyaXBsZXMgZm9yIGVhY2ggb3BlblxuICAgICAgICAgICAgLy8gYnJhY2tldCBvbiBCcmFja2V0U3RhY2suXG4gICAgICAgICAgICBpZiAoYnIgPSBCcmFja2V0c1tjaCA9IGxpbmUuY2hhckNvZGVBdChpKV0pIHtcbiAgICAgICAgICAgICAgICBpZiAoYnIgPCAwKSB7IC8vIENsb3NpbmcgYnJhY2tldFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBzSiA9IHNJIC0gMzsgc0ogPj0gMDsgc0ogLT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEJyYWNrZXRTdGFja1tzSiArIDFdID09IC1icikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmbGFncyA9IEJyYWNrZXRTdGFja1tzSiArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0eXBlID0gKGZsYWdzICYgMiAvKiBCcmFja2V0ZWQuRW1iZWRJbnNpZGUgKi8pID8gb3V0ZXJUeXBlIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIShmbGFncyAmIDQgLyogQnJhY2tldGVkLk9wcG9zaXRlSW5zaWRlICovKSA/IDAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZsYWdzICYgMSAvKiBCcmFja2V0ZWQuT3Bwb3NpdGVCZWZvcmUgKi8pID8gb3Bwb3NpdGVUeXBlIDogb3V0ZXJUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlc1tpXSA9IHR5cGVzW0JyYWNrZXRTdGFja1tzSl1dID0gdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzSSA9IHNKO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEJyYWNrZXRTdGFjay5sZW5ndGggPT0gMTg5IC8qIEJyYWNrZXRlZC5NYXhEZXB0aCAqLykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIEJyYWNrZXRTdGFja1tzSSsrXSA9IGk7XG4gICAgICAgICAgICAgICAgICAgIEJyYWNrZXRTdGFja1tzSSsrXSA9IGNoO1xuICAgICAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0krK10gPSBjb250ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCh0eXBlID0gdHlwZXNbaV0pID09IDIgLyogVC5SICovIHx8IHR5cGUgPT0gMSAvKiBULkwgKi8pIHtcbiAgICAgICAgICAgICAgICBsZXQgZW1iZWQgPSB0eXBlID09IG91dGVyVHlwZTtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gZW1iZWQgPyAwIDogMSAvKiBCcmFja2V0ZWQuT3Bwb3NpdGVCZWZvcmUgKi87XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc0ogPSBzSSAtIDM7IHNKID49IDA7IHNKIC09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1ciA9IEJyYWNrZXRTdGFja1tzSiArIDJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyICYgMiAvKiBCcmFja2V0ZWQuRW1iZWRJbnNpZGUgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVtYmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0ogKyAyXSB8PSAyIC8qIEJyYWNrZXRlZC5FbWJlZEluc2lkZSAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXIgJiA0IC8qIEJyYWNrZXRlZC5PcHBvc2l0ZUluc2lkZSAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIEJyYWNrZXRTdGFja1tzSiArIDJdIHw9IDQgLyogQnJhY2tldGVkLk9wcG9zaXRlSW5zaWRlICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcHJvY2Vzc05ldXRyYWxzKHJGcm9tLCByVG8sIGlzb2xhdGVzLCBvdXRlclR5cGUpIHtcbiAgICBmb3IgKGxldCBpSSA9IDAsIHByZXYgPSBvdXRlclR5cGU7IGlJIDw9IGlzb2xhdGVzLmxlbmd0aDsgaUkrKykge1xuICAgICAgICBsZXQgZnJvbSA9IGlJID8gaXNvbGF0ZXNbaUkgLSAxXS50byA6IHJGcm9tLCB0byA9IGlJIDwgaXNvbGF0ZXMubGVuZ3RoID8gaXNvbGF0ZXNbaUldLmZyb20gOiByVG87XG4gICAgICAgIC8vIE4xLiBBIHNlcXVlbmNlIG9mIG5ldXRyYWxzIHRha2VzIHRoZSBkaXJlY3Rpb24gb2YgdGhlXG4gICAgICAgIC8vIHN1cnJvdW5kaW5nIHN0cm9uZyB0ZXh0IGlmIHRoZSB0ZXh0IG9uIGJvdGggc2lkZXMgaGFzIHRoZSBzYW1lXG4gICAgICAgIC8vIGRpcmVjdGlvbi4gRXVyb3BlYW4gYW5kIEFyYWJpYyBudW1iZXJzIGFjdCBhcyBpZiB0aGV5IHdlcmUgUiBpblxuICAgICAgICAvLyB0ZXJtcyBvZiB0aGVpciBpbmZsdWVuY2Ugb24gbmV1dHJhbHMuIFN0YXJ0LW9mLWxldmVsLXJ1biAoc29yKVxuICAgICAgICAvLyBhbmQgZW5kLW9mLWxldmVsLXJ1biAoZW9yKSBhcmUgdXNlZCBhdCBsZXZlbCBydW4gYm91bmRhcmllcy5cbiAgICAgICAgLy8gTjIuIEFueSByZW1haW5pbmcgbmV1dHJhbHMgdGFrZSB0aGUgZW1iZWRkaW5nIGRpcmVjdGlvbi5cbiAgICAgICAgLy8gKExlZnQgYWZ0ZXIgdGhpczogTCwgUiwgRU4rQU4pXG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87KSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gMjU2IC8qIFQuTkkgKi8pIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kID0gaSArIDE7XG4gICAgICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kID09IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaUkgPT0gaXNvbGF0ZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gaXNvbGF0ZXNbaUkrK10udG87XG4gICAgICAgICAgICAgICAgICAgICAgICB0byA9IGlJIDwgaXNvbGF0ZXMubGVuZ3RoID8gaXNvbGF0ZXNbaUldLmZyb20gOiByVG87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZXNbZW5kXSA9PSAyNTYgLyogVC5OSSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgYmVmb3JlTCA9IHByZXYgPT0gMSAvKiBULkwgKi87XG4gICAgICAgICAgICAgICAgbGV0IGFmdGVyTCA9IChlbmQgPCByVG8gPyB0eXBlc1tlbmRdIDogb3V0ZXJUeXBlKSA9PSAxIC8qIFQuTCAqLztcbiAgICAgICAgICAgICAgICBsZXQgcmVwbGFjZSA9IGJlZm9yZUwgPT0gYWZ0ZXJMID8gKGJlZm9yZUwgPyAxIC8qIFQuTCAqLyA6IDIgLyogVC5SICovKSA6IG91dGVyVHlwZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gZW5kLCBqSSA9IGlJLCBmcm9tSiA9IGpJID8gaXNvbGF0ZXNbakkgLSAxXS50byA6IHJGcm9tOyBqID4gaTspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPT0gZnJvbUopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogPSBpc29sYXRlc1stLWpJXS5mcm9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbUogPSBqSSA/IGlzb2xhdGVzW2pJIC0gMV0udG8gOiByRnJvbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0eXBlc1stLWpdID0gcmVwbGFjZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaSA9IGVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXYgPSB0eXBlO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIEZpbmQgdGhlIGNvbnRpZ3VvdXMgcmFuZ2VzIG9mIGNoYXJhY3RlciB0eXBlcyBpbiBhIGdpdmVuIHJhbmdlLCBhbmRcbi8vIGVtaXQgc3BhbnMgZm9yIHRoZW0uIEZsaXAgdGhlIG9yZGVyIG9mIHRoZSBzcGFucyBhcyBhcHByb3ByaWF0ZVxuLy8gYmFzZWQgb24gdGhlIGxldmVsLCBhbmQgY2FsbCB0aHJvdWdoIHRvIGNvbXB1dGUgdGhlIHNwYW5zIGZvclxuLy8gaXNvbGF0ZXMgYXQgdGhlIHByb3BlciBwb2ludC5cbmZ1bmN0aW9uIGVtaXRTcGFucyhsaW5lLCBmcm9tLCB0bywgbGV2ZWwsIGJhc2VMZXZlbCwgaXNvbGF0ZXMsIG9yZGVyKSB7XG4gICAgbGV0IG91clR5cGUgPSBsZXZlbCAlIDIgPyAyIC8qIFQuUiAqLyA6IDEgLyogVC5MICovO1xuICAgIGlmICgobGV2ZWwgJSAyKSA9PSAoYmFzZUxldmVsICUgMikpIHsgLy8gU2FtZSBkaXIgYXMgYmFzZSBkaXJlY3Rpb24sIGRvbid0IGZsaXBcbiAgICAgICAgZm9yIChsZXQgaUNoID0gZnJvbSwgaUkgPSAwOyBpQ2ggPCB0bzspIHtcbiAgICAgICAgICAgIC8vIFNjYW4gYSBzZWN0aW9uIG9mIGNoYXJhY3RlcnMgaW4gZGlyZWN0aW9uIG91clR5cGUsIHVubGVzc1xuICAgICAgICAgICAgLy8gdGhlcmUncyBhbm90aGVyIHR5cGUgb2YgY2hhciByaWdodCBhZnRlciBpQ2gsIGluIHdoaWNoIGNhc2VcbiAgICAgICAgICAgIC8vIHdlIHNjYW4gYSBzZWN0aW9uIG9mIG90aGVyIGNoYXJhY3RlcnMgKHdoaWNoLCBpZiBvdXJUeXBlID09XG4gICAgICAgICAgICAvLyBULkwsIG1heSBjb250YWluIGJvdGggVC5SIGFuZCBULkFOIGNoYXJzKS5cbiAgICAgICAgICAgIGxldCBzYW1lRGlyID0gdHJ1ZSwgaXNOdW0gPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChpSSA9PSBpc29sYXRlcy5sZW5ndGggfHwgaUNoIDwgaXNvbGF0ZXNbaUldLmZyb20pIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHR5cGVzW2lDaF07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgIT0gb3VyVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBzYW1lRGlyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlzTnVtID0gbmV4dCA9PSAxNiAvKiBULkFOICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhvbGRzIGFuIGFycmF5IG9mIGlzb2xhdGVzIHRvIHBhc3MgdG8gYSByZWN1cnNpdmUgY2FsbCBpZiB3ZVxuICAgICAgICAgICAgLy8gbXVzdCByZWN1cnNlICh0byBkaXN0aW5ndWlzaCBULkFOIGluc2lkZSBhbiBSVEwgc2VjdGlvbiBpblxuICAgICAgICAgICAgLy8gTFRSIHRleHQpLCBudWxsIGlmIHdlIGNhbiBlbWl0IGRpcmVjdGx5XG4gICAgICAgICAgICBsZXQgcmVjdXJzZSA9ICFzYW1lRGlyICYmIG91clR5cGUgPT0gMSAvKiBULkwgKi8gPyBbXSA6IG51bGw7XG4gICAgICAgICAgICBsZXQgbG9jYWxMZXZlbCA9IHNhbWVEaXIgPyBsZXZlbCA6IGxldmVsICsgMTtcbiAgICAgICAgICAgIGxldCBpU2NhbiA9IGlDaDtcbiAgICAgICAgICAgIHJ1bjogZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChpSSA8IGlzb2xhdGVzLmxlbmd0aCAmJiBpU2NhbiA9PSBpc29sYXRlc1tpSV0uZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdW0pXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBydW47XG4gICAgICAgICAgICAgICAgICAgIGxldCBpc28gPSBpc29sYXRlc1tpSV07XG4gICAgICAgICAgICAgICAgICAgIC8vIFNjYW4gYWhlYWQgdG8gdmVyaWZ5IHRoYXQgdGhlcmUgaXMgYW5vdGhlciBjaGFyIGluIHRoaXMgZGlyIGFmdGVyIHRoZSBpc29sYXRlKHMpXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2FtZURpcilcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHVwdG8gPSBpc28udG8sIGpJID0gaUkgKyAxOzspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXB0byA9PSB0bylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgcnVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqSSA8IGlzb2xhdGVzLmxlbmd0aCAmJiBpc29sYXRlc1tqSV0uZnJvbSA9PSB1cHRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHRvID0gaXNvbGF0ZXNbakkrK10udG87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZXNbdXB0b10gPT0gb3VyVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgcnVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlJKys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN1cnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN1cnNlLnB1c2goaXNvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc28uZnJvbSA+IGlDaClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmRlci5wdXNoKG5ldyBCaWRpU3BhbihpQ2gsIGlzby5mcm9tLCBsb2NhbExldmVsKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGlyU3dhcCA9IChpc28uZGlyZWN0aW9uID09IExUUikgIT0gIShsb2NhbExldmVsICUgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlU2VjdGlvbk9yZGVyKGxpbmUsIGRpclN3YXAgPyBsZXZlbCArIDEgOiBsZXZlbCwgYmFzZUxldmVsLCBpc28uaW5uZXIsIGlzby5mcm9tLCBpc28udG8sIG9yZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlDaCA9IGlzby50bztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpU2NhbiA9IGlzby50bztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaVNjYW4gPT0gdG8gfHwgKHNhbWVEaXIgPyB0eXBlc1tpU2Nhbl0gIT0gb3VyVHlwZSA6IHR5cGVzW2lTY2FuXSA9PSBvdXJUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlTY2FuKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlY3Vyc2UpXG4gICAgICAgICAgICAgICAgZW1pdFNwYW5zKGxpbmUsIGlDaCwgaVNjYW4sIGxldmVsICsgMSwgYmFzZUxldmVsLCByZWN1cnNlLCBvcmRlcik7XG4gICAgICAgICAgICBlbHNlIGlmIChpQ2ggPCBpU2NhbilcbiAgICAgICAgICAgICAgICBvcmRlci5wdXNoKG5ldyBCaWRpU3BhbihpQ2gsIGlTY2FuLCBsb2NhbExldmVsKSk7XG4gICAgICAgICAgICBpQ2ggPSBpU2NhbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gSXRlcmF0ZSBpbiByZXZlcnNlIHRvIGZsaXAgdGhlIHNwYW4gb3JkZXIuIFNhbWUgY29kZSBhZ2FpbiwgYnV0XG4gICAgICAgIC8vIGdvaW5nIGZyb20gdGhlIGJhY2sgb2YgdGhlIHNlY3Rpb24gdG8gdGhlIGZyb250XG4gICAgICAgIGZvciAobGV0IGlDaCA9IHRvLCBpSSA9IGlzb2xhdGVzLmxlbmd0aDsgaUNoID4gZnJvbTspIHtcbiAgICAgICAgICAgIGxldCBzYW1lRGlyID0gdHJ1ZSwgaXNOdW0gPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICghaUkgfHwgaUNoID4gaXNvbGF0ZXNbaUkgLSAxXS50bykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdHlwZXNbaUNoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgIT0gb3VyVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBzYW1lRGlyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlzTnVtID0gbmV4dCA9PSAxNiAvKiBULkFOICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZWN1cnNlID0gIXNhbWVEaXIgJiYgb3VyVHlwZSA9PSAxIC8qIFQuTCAqLyA/IFtdIDogbnVsbDtcbiAgICAgICAgICAgIGxldCBsb2NhbExldmVsID0gc2FtZURpciA/IGxldmVsIDogbGV2ZWwgKyAxO1xuICAgICAgICAgICAgbGV0IGlTY2FuID0gaUNoO1xuICAgICAgICAgICAgcnVuOiBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlJICYmIGlTY2FuID09IGlzb2xhdGVzW2lJIC0gMV0udG8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgcnVuO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXNvID0gaXNvbGF0ZXNbLS1pSV07XG4gICAgICAgICAgICAgICAgICAgIC8vIFNjYW4gYWhlYWQgdG8gdmVyaWZ5IHRoYXQgdGhlcmUgaXMgYW5vdGhlciBjaGFyIGluIHRoaXMgZGlyIGFmdGVyIHRoZSBpc29sYXRlKHMpXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2FtZURpcilcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHVwdG8gPSBpc28uZnJvbSwgakkgPSBpSTs7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwdG8gPT0gZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgcnVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqSSAmJiBpc29sYXRlc1tqSSAtIDFdLnRvID09IHVwdG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwdG8gPSBpc29sYXRlc1stLWpJXS5mcm9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVzW3VwdG8gLSAxXSA9PSBvdXJUeXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBydW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3Vyc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Vyc2UucHVzaChpc28pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzby50byA8IGlDaClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmRlci5wdXNoKG5ldyBCaWRpU3Bhbihpc28udG8sIGlDaCwgbG9jYWxMZXZlbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRpclN3YXAgPSAoaXNvLmRpcmVjdGlvbiA9PSBMVFIpICE9ICEobG9jYWxMZXZlbCAlIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZVNlY3Rpb25PcmRlcihsaW5lLCBkaXJTd2FwID8gbGV2ZWwgKyAxIDogbGV2ZWwsIGJhc2VMZXZlbCwgaXNvLmlubmVyLCBpc28uZnJvbSwgaXNvLnRvLCBvcmRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpQ2ggPSBpc28uZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpU2NhbiA9IGlzby5mcm9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpU2NhbiA9PSBmcm9tIHx8IChzYW1lRGlyID8gdHlwZXNbaVNjYW4gLSAxXSAhPSBvdXJUeXBlIDogdHlwZXNbaVNjYW4gLSAxXSA9PSBvdXJUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlTY2FuLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlY3Vyc2UpXG4gICAgICAgICAgICAgICAgZW1pdFNwYW5zKGxpbmUsIGlTY2FuLCBpQ2gsIGxldmVsICsgMSwgYmFzZUxldmVsLCByZWN1cnNlLCBvcmRlcik7XG4gICAgICAgICAgICBlbHNlIGlmIChpU2NhbiA8IGlDaClcbiAgICAgICAgICAgICAgICBvcmRlci5wdXNoKG5ldyBCaWRpU3BhbihpU2NhbiwgaUNoLCBsb2NhbExldmVsKSk7XG4gICAgICAgICAgICBpQ2ggPSBpU2NhbjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVTZWN0aW9uT3JkZXIobGluZSwgbGV2ZWwsIGJhc2VMZXZlbCwgaXNvbGF0ZXMsIGZyb20sIHRvLCBvcmRlcikge1xuICAgIGxldCBvdXRlclR5cGUgPSAobGV2ZWwgJSAyID8gMiAvKiBULlIgKi8gOiAxIC8qIFQuTCAqLyk7XG4gICAgY29tcHV0ZUNoYXJUeXBlcyhsaW5lLCBmcm9tLCB0bywgaXNvbGF0ZXMsIG91dGVyVHlwZSk7XG4gICAgcHJvY2Vzc0JyYWNrZXRQYWlycyhsaW5lLCBmcm9tLCB0bywgaXNvbGF0ZXMsIG91dGVyVHlwZSk7XG4gICAgcHJvY2Vzc05ldXRyYWxzKGZyb20sIHRvLCBpc29sYXRlcywgb3V0ZXJUeXBlKTtcbiAgICBlbWl0U3BhbnMobGluZSwgZnJvbSwgdG8sIGxldmVsLCBiYXNlTGV2ZWwsIGlzb2xhdGVzLCBvcmRlcik7XG59XG5mdW5jdGlvbiBjb21wdXRlT3JkZXIobGluZSwgZGlyZWN0aW9uLCBpc29sYXRlcykge1xuICAgIGlmICghbGluZSlcbiAgICAgICAgcmV0dXJuIFtuZXcgQmlkaVNwYW4oMCwgMCwgZGlyZWN0aW9uID09IFJUTCA/IDEgOiAwKV07XG4gICAgaWYgKGRpcmVjdGlvbiA9PSBMVFIgJiYgIWlzb2xhdGVzLmxlbmd0aCAmJiAhQmlkaVJFLnRlc3QobGluZSkpXG4gICAgICAgIHJldHVybiB0cml2aWFsT3JkZXIobGluZS5sZW5ndGgpO1xuICAgIGlmIChpc29sYXRlcy5sZW5ndGgpXG4gICAgICAgIHdoaWxlIChsaW5lLmxlbmd0aCA+IHR5cGVzLmxlbmd0aClcbiAgICAgICAgICAgIHR5cGVzW3R5cGVzLmxlbmd0aF0gPSAyNTYgLyogVC5OSSAqLzsgLy8gTWFrZSBzdXJlIHR5cGVzIGFycmF5IGhhcyBubyBnYXBzXG4gICAgbGV0IG9yZGVyID0gW10sIGxldmVsID0gZGlyZWN0aW9uID09IExUUiA/IDAgOiAxO1xuICAgIGNvbXB1dGVTZWN0aW9uT3JkZXIobGluZSwgbGV2ZWwsIGxldmVsLCBpc29sYXRlcywgMCwgbGluZS5sZW5ndGgsIG9yZGVyKTtcbiAgICByZXR1cm4gb3JkZXI7XG59XG5mdW5jdGlvbiB0cml2aWFsT3JkZXIobGVuZ3RoKSB7XG4gICAgcmV0dXJuIFtuZXcgQmlkaVNwYW4oMCwgbGVuZ3RoLCAwKV07XG59XG5sZXQgbW92ZWRPdmVyID0gXCJcIjtcbi8vIFRoaXMgaW1wbGVtZW50YXRpb24gbW92ZXMgc3RyaWN0bHkgdmlzdWFsbHksIHdpdGhvdXQgY29uY2VybiBmb3IgYVxuLy8gdHJhdmVyc2FsIHZpc2l0aW5nIGV2ZXJ5IGxvZ2ljYWwgcG9zaXRpb24gaW4gdGhlIHN0cmluZy4gSXQgd2lsbFxuLy8gc3RpbGwgZG8gc28gZm9yIHNpbXBsZSBpbnB1dCwgYnV0IHNpdHVhdGlvbnMgbGlrZSBtdWx0aXBsZSBpc29sYXRlc1xuLy8gd2l0aCB0aGUgc2FtZSBsZXZlbCBuZXh0IHRvIGVhY2ggb3RoZXIsIG9yIHRleHQgZ29pbmcgYWdhaW5zdCB0aGVcbi8vIG1haW4gZGlyIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUsIHdpbGwgbWFrZSBzb21lIHBvc2l0aW9uc1xuLy8gdW5yZWFjaGFibGUgd2l0aCB0aGlzIG1vdGlvbi4gRWFjaCB2aXNpYmxlIGN1cnNvciBwb3NpdGlvbiB3aWxsXG4vLyBjb3JyZXNwb25kIHRvIHRoZSBsb3dlci1sZXZlbCBiaWRpIHNwYW4gdGhhdCB0b3VjaGVzIGl0LlxuLy9cbi8vIFRoZSBhbHRlcm5hdGl2ZSB3b3VsZCBiZSB0byBzb2x2ZSBhbiBvcmRlciBnbG9iYWxseSBmb3IgYSBnaXZlblxuLy8gbGluZSwgbWFraW5nIHN1cmUgdGhhdCBpdCBpbmNsdWRlcyBldmVyeSBwb3NpdGlvbiwgYnV0IHRoYXQgd291bGRcbi8vIHJlcXVpcmUgYXNzb2NpYXRpbmcgbm9uLWNhbm9uaWNhbCAoaGlnaGVyIGJpZGkgc3BhbiBsZXZlbClcbi8vIHBvc2l0aW9ucyB3aXRoIGEgZ2l2ZW4gdmlzdWFsIHBvc2l0aW9uLCB3aGljaCBpcyBsaWtlbHkgdG8gY29uZnVzZVxuLy8gcGVvcGxlLiAoQW5kIHdvdWxkIGdlbmVyYWxseSBiZSBhIGxvdCBtb3JlIGNvbXBsaWNhdGVkLilcbmZ1bmN0aW9uIG1vdmVWaXN1YWxseShsaW5lLCBvcmRlciwgZGlyLCBzdGFydCwgZm9yd2FyZCkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgc3RhcnRJbmRleCA9IHN0YXJ0LmhlYWQgLSBsaW5lLmZyb207XG4gICAgbGV0IHNwYW5JID0gQmlkaVNwYW4uZmluZChvcmRlciwgc3RhcnRJbmRleCwgKF9hID0gc3RhcnQuYmlkaUxldmVsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAtMSwgc3RhcnQuYXNzb2MpO1xuICAgIGxldCBzcGFuID0gb3JkZXJbc3BhbkldLCBzcGFuRW5kID0gc3Bhbi5zaWRlKGZvcndhcmQsIGRpcik7XG4gICAgLy8gRW5kIG9mIHNwYW5cbiAgICBpZiAoc3RhcnRJbmRleCA9PSBzcGFuRW5kKSB7XG4gICAgICAgIGxldCBuZXh0SSA9IHNwYW5JICs9IGZvcndhcmQgPyAxIDogLTE7XG4gICAgICAgIGlmIChuZXh0SSA8IDAgfHwgbmV4dEkgPj0gb3JkZXIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHNwYW4gPSBvcmRlcltzcGFuSSA9IG5leHRJXTtcbiAgICAgICAgc3RhcnRJbmRleCA9IHNwYW4uc2lkZSghZm9yd2FyZCwgZGlyKTtcbiAgICAgICAgc3BhbkVuZCA9IHNwYW4uc2lkZShmb3J3YXJkLCBkaXIpO1xuICAgIH1cbiAgICBsZXQgbmV4dEluZGV4ID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHN0YXJ0SW5kZXgsIHNwYW4uZm9yd2FyZChmb3J3YXJkLCBkaXIpKTtcbiAgICBpZiAobmV4dEluZGV4IDwgc3Bhbi5mcm9tIHx8IG5leHRJbmRleCA+IHNwYW4udG8pXG4gICAgICAgIG5leHRJbmRleCA9IHNwYW5FbmQ7XG4gICAgbW92ZWRPdmVyID0gbGluZS50ZXh0LnNsaWNlKE1hdGgubWluKHN0YXJ0SW5kZXgsIG5leHRJbmRleCksIE1hdGgubWF4KHN0YXJ0SW5kZXgsIG5leHRJbmRleCkpO1xuICAgIGxldCBuZXh0U3BhbiA9IHNwYW5JID09IChmb3J3YXJkID8gb3JkZXIubGVuZ3RoIC0gMSA6IDApID8gbnVsbCA6IG9yZGVyW3NwYW5JICsgKGZvcndhcmQgPyAxIDogLTEpXTtcbiAgICBpZiAobmV4dFNwYW4gJiYgbmV4dEluZGV4ID09IHNwYW5FbmQgJiYgbmV4dFNwYW4ubGV2ZWwgKyAoZm9yd2FyZCA/IDAgOiAxKSA8IHNwYW4ubGV2ZWwpXG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKG5leHRTcGFuLnNpZGUoIWZvcndhcmQsIGRpcikgKyBsaW5lLmZyb20sIG5leHRTcGFuLmZvcndhcmQoZm9yd2FyZCwgZGlyKSA/IDEgOiAtMSwgbmV4dFNwYW4ubGV2ZWwpO1xuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKG5leHRJbmRleCArIGxpbmUuZnJvbSwgc3Bhbi5mb3J3YXJkKGZvcndhcmQsIGRpcikgPyAtMSA6IDEsIHNwYW4ubGV2ZWwpO1xufVxuZnVuY3Rpb24gYXV0b0RpcmVjdGlvbih0ZXh0LCBmcm9tLCB0bykge1xuICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgICBsZXQgdHlwZSA9IGNoYXJUeXBlKHRleHQuY2hhckNvZGVBdChpKSk7XG4gICAgICAgIGlmICh0eXBlID09IDEgLyogVC5MICovKVxuICAgICAgICAgICAgcmV0dXJuIExUUjtcbiAgICAgICAgaWYgKHR5cGUgPT0gMiAvKiBULlIgKi8gfHwgdHlwZSA9PSA0IC8qIFQuQUwgKi8pXG4gICAgICAgICAgICByZXR1cm4gUlRMO1xuICAgIH1cbiAgICByZXR1cm4gTFRSO1xufVxuXG5jb25zdCBjbGlja0FkZHNTZWxlY3Rpb25SYW5nZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGRyYWdNb3Zlc1NlbGVjdGlvbiQxID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgbW91c2VTZWxlY3Rpb25TdHlsZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGV4Y2VwdGlvblNpbmsgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCB1cGRhdGVMaXN0ZW5lciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGlucHV0SGFuZGxlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGZvY3VzQ2hhbmdlRWZmZWN0ID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgcGVyTGluZVRleHREaXJlY3Rpb24gPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnNvbWUoeCA9PiB4KVxufSk7XG5jb25zdCBuYXRpdmVTZWxlY3Rpb25IaWRkZW4gPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnNvbWUoeCA9PiB4KVxufSk7XG5jbGFzcyBTY3JvbGxUYXJnZXQge1xuICAgIGNvbnN0cnVjdG9yKHJhbmdlLCB5ID0gXCJuZWFyZXN0XCIsIHggPSBcIm5lYXJlc3RcIiwgeU1hcmdpbiA9IDUsIHhNYXJnaW4gPSA1LCBcbiAgICAvLyBUaGlzIGRhdGEgc3RydWN0dXJlIGlzIGFidXNlZCB0byBhbHNvIHN0b3JlIHByZWNpc2Ugc2Nyb2xsXG4gICAgLy8gc25hcHNob3RzLCBpbnN0ZWFkIG9mIGEgYHNjcm9sbEludG9WaWV3YCByZXF1ZXN0LiBXaGVuIHRoaXNcbiAgICAvLyBmbGFnIGlzIGB0cnVlYCwgYHJhbmdlYCBwb2ludHMgYXQgYSBwb3NpdGlvbiBpbiB0aGUgcmVmZXJlbmNlXG4gICAgLy8gbGluZSwgYHlNYXJnaW5gIGhvbGRzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHRvcCBvZiB0aGF0XG4gICAgLy8gbGluZSBhbmQgdGhlIHRvcCBvZiB0aGUgZWRpdG9yLCBhbmQgYHhNYXJnaW5gIGhvbGRzIHRoZVxuICAgIC8vIGVkaXRvcidzIGBzY3JvbGxMZWZ0YC5cbiAgICBpc1NuYXBzaG90ID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlO1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnlNYXJnaW4gPSB5TWFyZ2luO1xuICAgICAgICB0aGlzLnhNYXJnaW4gPSB4TWFyZ2luO1xuICAgICAgICB0aGlzLmlzU25hcHNob3QgPSBpc1NuYXBzaG90O1xuICAgIH1cbiAgICBtYXAoY2hhbmdlcykge1xuICAgICAgICByZXR1cm4gY2hhbmdlcy5lbXB0eSA/IHRoaXMgOlxuICAgICAgICAgICAgbmV3IFNjcm9sbFRhcmdldCh0aGlzLnJhbmdlLm1hcChjaGFuZ2VzKSwgdGhpcy55LCB0aGlzLngsIHRoaXMueU1hcmdpbiwgdGhpcy54TWFyZ2luLCB0aGlzLmlzU25hcHNob3QpO1xuICAgIH1cbiAgICBjbGlwKHN0YXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlLnRvIDw9IHN0YXRlLmRvYy5sZW5ndGggPyB0aGlzIDpcbiAgICAgICAgICAgIG5ldyBTY3JvbGxUYXJnZXQoRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihzdGF0ZS5kb2MubGVuZ3RoKSwgdGhpcy55LCB0aGlzLngsIHRoaXMueU1hcmdpbiwgdGhpcy54TWFyZ2luLCB0aGlzLmlzU25hcHNob3QpO1xuICAgIH1cbn1cbmNvbnN0IHNjcm9sbEludG9WaWV3ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7IG1hcDogKHQsIGNoKSA9PiB0Lm1hcChjaCkgfSk7XG4vKipcbkxvZyBvciByZXBvcnQgYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbiBpbiBjbGllbnQgY29kZS4gU2hvdWxkXG5wcm9iYWJseSBvbmx5IGJlIHVzZWQgYnkgZXh0ZW5zaW9uIGNvZGUgdGhhdCBhbGxvd3MgY2xpZW50IGNvZGUgdG9cbnByb3ZpZGUgZnVuY3Rpb25zLCBhbmQgY2FsbHMgdGhvc2UgZnVuY3Rpb25zIGluIGEgY29udGV4dCB3aGVyZSBhblxuZXhjZXB0aW9uIGNhbid0IGJlIHByb3BhZ2F0ZWQgdG8gY2FsbGluZyBjb2RlIGluIGEgcmVhc29uYWJsZSB3YXlcbihmb3IgZXhhbXBsZSB3aGVuIGluIGFuIGV2ZW50IGhhbmRsZXIpLlxuXG5FaXRoZXIgY2FsbHMgYSBoYW5kbGVyIHJlZ2lzdGVyZWQgd2l0aFxuW2BFZGl0b3JWaWV3LmV4Y2VwdGlvblNpbmtgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15leGNlcHRpb25TaW5rKSxcbmB3aW5kb3cub25lcnJvcmAsIGlmIGRlZmluZWQsIG9yIGBjb25zb2xlLmVycm9yYCAoaW4gd2hpY2ggY2FzZVxuaXQnbGwgcGFzcyBgY29udGV4dGAsIHdoZW4gZ2l2ZW4sIGFzIGZpcnN0IGFyZ3VtZW50KS5cbiovXG5mdW5jdGlvbiBsb2dFeGNlcHRpb24oc3RhdGUsIGV4Y2VwdGlvbiwgY29udGV4dCkge1xuICAgIGxldCBoYW5kbGVyID0gc3RhdGUuZmFjZXQoZXhjZXB0aW9uU2luayk7XG4gICAgaWYgKGhhbmRsZXIubGVuZ3RoKVxuICAgICAgICBoYW5kbGVyWzBdKGV4Y2VwdGlvbik7XG4gICAgZWxzZSBpZiAod2luZG93Lm9uZXJyb3IpXG4gICAgICAgIHdpbmRvdy5vbmVycm9yKFN0cmluZyhleGNlcHRpb24pLCBjb250ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZXhjZXB0aW9uKTtcbiAgICBlbHNlIGlmIChjb250ZXh0KVxuICAgICAgICBjb25zb2xlLmVycm9yKGNvbnRleHQgKyBcIjpcIiwgZXhjZXB0aW9uKTtcbiAgICBlbHNlXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXhjZXB0aW9uKTtcbn1cbmNvbnN0IGVkaXRhYmxlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7IGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMubGVuZ3RoID8gdmFsdWVzWzBdIDogdHJ1ZSB9KTtcbmxldCBuZXh0UGx1Z2luSUQgPSAwO1xuY29uc3Qgdmlld1BsdWdpbiA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbi8qKlxuVmlldyBwbHVnaW5zIGFzc29jaWF0ZSBzdGF0ZWZ1bCB2YWx1ZXMgd2l0aCBhIHZpZXcuIFRoZXkgY2FuXG5pbmZsdWVuY2UgdGhlIHdheSB0aGUgY29udGVudCBpcyBkcmF3biwgYW5kIGFyZSBub3RpZmllZCBvZiB0aGluZ3NcbnRoYXQgaGFwcGVuIGluIHRoZSB2aWV3LlxuKi9cbmNsYXNzIFZpZXdQbHVnaW4ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaWQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY3JlYXRlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGRvbUV2ZW50SGFuZGxlcnMsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZG9tRXZlbnRPYnNlcnZlcnMsIGJ1aWxkRXh0ZW5zaW9ucykge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuY3JlYXRlID0gY3JlYXRlO1xuICAgICAgICB0aGlzLmRvbUV2ZW50SGFuZGxlcnMgPSBkb21FdmVudEhhbmRsZXJzO1xuICAgICAgICB0aGlzLmRvbUV2ZW50T2JzZXJ2ZXJzID0gZG9tRXZlbnRPYnNlcnZlcnM7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uID0gYnVpbGRFeHRlbnNpb25zKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBwbHVnaW4gZnJvbSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyB0aGVcbiAgICBwbHVnaW4ncyB2YWx1ZSwgZ2l2ZW4gYW4gZWRpdG9yIHZpZXcuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKGNyZWF0ZSwgc3BlYykge1xuICAgICAgICBjb25zdCB7IGV2ZW50SGFuZGxlcnMsIGV2ZW50T2JzZXJ2ZXJzLCBwcm92aWRlLCBkZWNvcmF0aW9uczogZGVjbyB9ID0gc3BlYyB8fCB7fTtcbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3UGx1Z2luKG5leHRQbHVnaW5JRCsrLCBjcmVhdGUsIGV2ZW50SGFuZGxlcnMsIGV2ZW50T2JzZXJ2ZXJzLCBwbHVnaW4gPT4ge1xuICAgICAgICAgICAgbGV0IGV4dCA9IFt2aWV3UGx1Z2luLm9mKHBsdWdpbildO1xuICAgICAgICAgICAgaWYgKGRlY28pXG4gICAgICAgICAgICAgICAgZXh0LnB1c2goZGVjb3JhdGlvbnMub2YodmlldyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwbHVnaW5JbnN0ID0gdmlldy5wbHVnaW4ocGx1Z2luKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbkluc3QgPyBkZWNvKHBsdWdpbkluc3QpIDogRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlKVxuICAgICAgICAgICAgICAgIGV4dC5wdXNoKHByb3ZpZGUocGx1Z2luKSk7XG4gICAgICAgICAgICByZXR1cm4gZXh0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcGx1Z2luIGZvciBhIGNsYXNzIHdob3NlIGNvbnN0cnVjdG9yIHRha2VzIGEgc2luZ2xlXG4gICAgZWRpdG9yIHZpZXcgYXMgYXJndW1lbnQuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUNsYXNzKGNscywgc3BlYykge1xuICAgICAgICByZXR1cm4gVmlld1BsdWdpbi5kZWZpbmUodmlldyA9PiBuZXcgY2xzKHZpZXcpLCBzcGVjKTtcbiAgICB9XG59XG5jbGFzcyBQbHVnaW5JbnN0YW5jZSB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgICAgICAvLyBXaGVuIHN0YXJ0aW5nIGFuIHVwZGF0ZSwgYWxsIHBsdWdpbnMgaGF2ZSB0aGlzIGZpZWxkIHNldCB0byB0aGVcbiAgICAgICAgLy8gdXBkYXRlIG9iamVjdCwgaW5kaWNhdGluZyB0aGV5IG5lZWQgdG8gYmUgdXBkYXRlZC4gV2hlbiBmaW5pc2hlZFxuICAgICAgICAvLyB1cGRhdGluZywgaXQgaXMgc2V0IHRvIGBmYWxzZWAuIFJldHJpZXZpbmcgYSBwbHVnaW4gdGhhdCBuZWVkcyB0b1xuICAgICAgICAvLyBiZSB1cGRhdGVkIHdpdGggYHZpZXcucGx1Z2luYCBmb3JjZXMgYW4gZWFnZXIgdXBkYXRlLlxuICAgICAgICB0aGlzLm11c3RVcGRhdGUgPSBudWxsO1xuICAgICAgICAvLyBUaGlzIGlzIG51bGwgd2hlbiB0aGUgcGx1Z2luIGlzIGluaXRpYWxseSBjcmVhdGVkLCBidXRcbiAgICAgICAgLy8gaW5pdGlhbGl6ZWQgb24gdGhlIGZpcnN0IHVwZGF0ZS5cbiAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgfVxuICAgIHVwZGF0ZSh2aWV3KSB7XG4gICAgICAgIGlmICghdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3BlYykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnNwZWMuY3JlYXRlKHZpZXcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odmlldy5zdGF0ZSwgZSwgXCJDb2RlTWlycm9yIHBsdWdpbiBjcmFzaGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5tdXN0VXBkYXRlKSB7XG4gICAgICAgICAgICBsZXQgdXBkYXRlID0gdGhpcy5tdXN0VXBkYXRlO1xuICAgICAgICAgICAgdGhpcy5tdXN0VXBkYXRlID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlLnVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih1cGRhdGUuc3RhdGUsIGUsIFwiQ29kZU1pcnJvciBwbHVnaW4gY3Jhc2hlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUuZGVzdHJveSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVzdHJveSh2aWV3KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKChfYSA9IHRoaXMudmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odmlldy5zdGF0ZSwgZSwgXCJDb2RlTWlycm9yIHBsdWdpbiBjcmFzaGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRlYWN0aXZhdGUoKSB7XG4gICAgICAgIHRoaXMuc3BlYyA9IHRoaXMudmFsdWUgPSBudWxsO1xuICAgIH1cbn1cbmNvbnN0IGVkaXRvckF0dHJpYnV0ZXMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBjb250ZW50QXR0cmlidXRlcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbi8vIFByb3ZpZGUgZGVjb3JhdGlvbnNcbmNvbnN0IGRlY29yYXRpb25zID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3Qgb3V0ZXJEZWNvcmF0aW9ucyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGF0b21pY1JhbmdlcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGJpZGlJc29sYXRlZFJhbmdlcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmZ1bmN0aW9uIGdldElzb2xhdGVkUmFuZ2VzKHZpZXcsIGxpbmUpIHtcbiAgICBsZXQgaXNvbGF0ZXMgPSB2aWV3LnN0YXRlLmZhY2V0KGJpZGlJc29sYXRlZFJhbmdlcyk7XG4gICAgaWYgKCFpc29sYXRlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBpc29sYXRlcztcbiAgICBsZXQgc2V0cyA9IGlzb2xhdGVzLm1hcChpID0+IGkgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGkodmlldykgOiBpKTtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgUmFuZ2VTZXQuc3BhbnMoc2V0cywgbGluZS5mcm9tLCBsaW5lLnRvLCB7XG4gICAgICAgIHBvaW50KCkgeyB9LFxuICAgICAgICBzcGFuKGZyb21Eb2MsIHRvRG9jLCBhY3RpdmUsIG9wZW4pIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gZnJvbURvYyAtIGxpbmUuZnJvbSwgdG8gPSB0b0RvYyAtIGxpbmUuZnJvbTtcbiAgICAgICAgICAgIGxldCBsZXZlbCA9IHJlc3VsdDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBhY3RpdmUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0sIG9wZW4tLSkge1xuICAgICAgICAgICAgICAgIGxldCBkaXJlY3Rpb24gPSBhY3RpdmVbaV0uc3BlYy5iaWRpSXNvbGF0ZSwgdXBkYXRlO1xuICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gYXV0b0RpcmVjdGlvbihsaW5lLnRleHQsIGZyb20sIHRvKTtcbiAgICAgICAgICAgICAgICBpZiAob3BlbiA+IDAgJiYgbGV2ZWwubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICh1cGRhdGUgPSBsZXZlbFtsZXZlbC5sZW5ndGggLSAxXSkudG8gPT0gZnJvbSAmJiB1cGRhdGUuZGlyZWN0aW9uID09IGRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGUudG8gPSB0bztcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwgPSB1cGRhdGUuaW5uZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWRkID0geyBmcm9tLCB0bywgZGlyZWN0aW9uLCBpbm5lcjogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwucHVzaChhZGQpO1xuICAgICAgICAgICAgICAgICAgICBsZXZlbCA9IGFkZC5pbm5lcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3Qgc2Nyb2xsTWFyZ2lucyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmZ1bmN0aW9uIGdldFNjcm9sbE1hcmdpbnModmlldykge1xuICAgIGxldCBsZWZ0ID0gMCwgcmlnaHQgPSAwLCB0b3AgPSAwLCBib3R0b20gPSAwO1xuICAgIGZvciAobGV0IHNvdXJjZSBvZiB2aWV3LnN0YXRlLmZhY2V0KHNjcm9sbE1hcmdpbnMpKSB7XG4gICAgICAgIGxldCBtID0gc291cmNlKHZpZXcpO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgaWYgKG0ubGVmdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1heChsZWZ0LCBtLmxlZnQpO1xuICAgICAgICAgICAgaWYgKG0ucmlnaHQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICByaWdodCA9IE1hdGgubWF4KHJpZ2h0LCBtLnJpZ2h0KTtcbiAgICAgICAgICAgIGlmIChtLnRvcCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRvcCA9IE1hdGgubWF4KHRvcCwgbS50b3ApO1xuICAgICAgICAgICAgaWYgKG0uYm90dG9tICE9IG51bGwpXG4gICAgICAgICAgICAgICAgYm90dG9tID0gTWF0aC5tYXgoYm90dG9tLCBtLmJvdHRvbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tIH07XG59XG5jb25zdCBzdHlsZU1vZHVsZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNsYXNzIENoYW5nZWRSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoZnJvbUEsIHRvQSwgZnJvbUIsIHRvQikge1xuICAgICAgICB0aGlzLmZyb21BID0gZnJvbUE7XG4gICAgICAgIHRoaXMudG9BID0gdG9BO1xuICAgICAgICB0aGlzLmZyb21CID0gZnJvbUI7XG4gICAgICAgIHRoaXMudG9CID0gdG9CO1xuICAgIH1cbiAgICBqb2luKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlZFJhbmdlKE1hdGgubWluKHRoaXMuZnJvbUEsIG90aGVyLmZyb21BKSwgTWF0aC5tYXgodGhpcy50b0EsIG90aGVyLnRvQSksIE1hdGgubWluKHRoaXMuZnJvbUIsIG90aGVyLmZyb21CKSwgTWF0aC5tYXgodGhpcy50b0IsIG90aGVyLnRvQikpO1xuICAgIH1cbiAgICBhZGRUb1NldChzZXQpIHtcbiAgICAgICAgbGV0IGkgPSBzZXQubGVuZ3RoLCBtZSA9IHRoaXM7XG4gICAgICAgIGZvciAoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSBzZXRbaSAtIDFdO1xuICAgICAgICAgICAgaWYgKHJhbmdlLmZyb21BID4gbWUudG9BKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHJhbmdlLnRvQSA8IG1lLmZyb21BKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbWUgPSBtZS5qb2luKHJhbmdlKTtcbiAgICAgICAgICAgIHNldC5zcGxpY2UoaSAtIDEsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHNldC5zcGxpY2UoaSwgMCwgbWUpO1xuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH1cbiAgICBzdGF0aWMgZXh0ZW5kV2l0aFJhbmdlcyhkaWZmLCByYW5nZXMpIHtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGRJID0gMCwgckkgPSAwLCBwb3NBID0gMCwgcG9zQiA9IDA7OyBkSSsrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGRJID09IGRpZmYubGVuZ3RoID8gbnVsbCA6IGRpZmZbZEldLCBvZmYgPSBwb3NBIC0gcG9zQjtcbiAgICAgICAgICAgIGxldCBlbmQgPSBuZXh0ID8gbmV4dC5mcm9tQiA6IDFlOTtcbiAgICAgICAgICAgIHdoaWxlIChySSA8IHJhbmdlcy5sZW5ndGggJiYgcmFuZ2VzW3JJXSA8IGVuZCkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gcmFuZ2VzW3JJXSwgdG8gPSByYW5nZXNbckkgKyAxXTtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbUIgPSBNYXRoLm1heChwb3NCLCBmcm9tKSwgdG9CID0gTWF0aC5taW4oZW5kLCB0byk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb21CIDw9IHRvQilcbiAgICAgICAgICAgICAgICAgICAgbmV3IENoYW5nZWRSYW5nZShmcm9tQiArIG9mZiwgdG9CICsgb2ZmLCBmcm9tQiwgdG9CKS5hZGRUb1NldChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmICh0byA+IGVuZClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBySSArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBuZXcgQ2hhbmdlZFJhbmdlKG5leHQuZnJvbUEsIG5leHQudG9BLCBuZXh0LmZyb21CLCBuZXh0LnRvQikuYWRkVG9TZXQocmVzdWx0KTtcbiAgICAgICAgICAgIHBvc0EgPSBuZXh0LnRvQTtcbiAgICAgICAgICAgIHBvc0IgPSBuZXh0LnRvQjtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuVmlldyBbcGx1Z2luc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LlZpZXdQbHVnaW4pIGFyZSBnaXZlbiBpbnN0YW5jZXMgb2YgdGhpc1xuY2xhc3MsIHdoaWNoIGRlc2NyaWJlIHdoYXQgaGFwcGVuZWQsIHdoZW5ldmVyIHRoZSB2aWV3IGlzIHVwZGF0ZWQuXG4qL1xuY2xhc3MgVmlld1VwZGF0ZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGVkaXRvciB2aWV3IHRoYXQgdGhlIHVwZGF0ZSBpcyBhc3NvY2lhdGVkIHdpdGguXG4gICAgKi9cbiAgICB2aWV3LCBcbiAgICAvKipcbiAgICBUaGUgbmV3IGVkaXRvciBzdGF0ZS5cbiAgICAqL1xuICAgIHN0YXRlLCBcbiAgICAvKipcbiAgICBUaGUgdHJhbnNhY3Rpb25zIGludm9sdmVkIGluIHRoZSB1cGRhdGUuIE1heSBiZSBlbXB0eS5cbiAgICAqL1xuICAgIHRyYW5zYWN0aW9ucykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZmxhZ3MgPSAwO1xuICAgICAgICB0aGlzLnN0YXJ0U3RhdGUgPSB2aWV3LnN0YXRlO1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBDaGFuZ2VTZXQuZW1wdHkodGhpcy5zdGFydFN0YXRlLmRvYy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCB0ciBvZiB0cmFuc2FjdGlvbnMpXG4gICAgICAgICAgICB0aGlzLmNoYW5nZXMgPSB0aGlzLmNoYW5nZXMuY29tcG9zZSh0ci5jaGFuZ2VzKTtcbiAgICAgICAgbGV0IGNoYW5nZWRSYW5nZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLml0ZXJDaGFuZ2VkUmFuZ2VzKChmcm9tQSwgdG9BLCBmcm9tQiwgdG9CKSA9PiBjaGFuZ2VkUmFuZ2VzLnB1c2gobmV3IENoYW5nZWRSYW5nZShmcm9tQSwgdG9BLCBmcm9tQiwgdG9CKSkpO1xuICAgICAgICB0aGlzLmNoYW5nZWRSYW5nZXMgPSBjaGFuZ2VkUmFuZ2VzO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUodmlldywgc3RhdGUsIHRyYW5zYWN0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFZpZXdVcGRhdGUodmlldywgc3RhdGUsIHRyYW5zYWN0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlbGxzIHlvdSB3aGV0aGVyIHRoZSBbdmlld3BvcnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnZpZXdwb3J0KSBvclxuICAgIFt2aXNpYmxlIHJhbmdlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudmlzaWJsZVJhbmdlcykgY2hhbmdlZCBpbiB0aGlzXG4gICAgdXBkYXRlLlxuICAgICovXG4gICAgZ2V0IHZpZXdwb3J0Q2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgNCAvKiBVcGRhdGVGbGFnLlZpZXdwb3J0ICovKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoZSBoZWlnaHQgb2YgYSBibG9jayBlbGVtZW50IGluIHRoZSBlZGl0b3JcbiAgICBjaGFuZ2VkIGluIHRoaXMgdXBkYXRlLlxuICAgICovXG4gICAgZ2V0IGhlaWdodENoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi8pID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIHdoZW4gdGhlIGRvY3VtZW50IHdhcyBtb2RpZmllZCBvciB0aGUgc2l6ZSBvZiB0aGVcbiAgICBlZGl0b3IsIG9yIGVsZW1lbnRzIHdpdGhpbiB0aGUgZWRpdG9yLCBjaGFuZ2VkLlxuICAgICovXG4gICAgZ2V0IGdlb21ldHJ5Q2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jQ2hhbmdlZCB8fCAodGhpcy5mbGFncyAmICg4IC8qIFVwZGF0ZUZsYWcuR2VvbWV0cnkgKi8gfCAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovKSkgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyB1cGRhdGUgaW5kaWNhdGVzIGEgZm9jdXMgY2hhbmdlLlxuICAgICovXG4gICAgZ2V0IGZvY3VzQ2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgMSAvKiBVcGRhdGVGbGFnLkZvY3VzICovKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhlIGRvY3VtZW50IGNoYW5nZWQgaW4gdGhpcyB1cGRhdGUuXG4gICAgKi9cbiAgICBnZXQgZG9jQ2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNoYW5nZXMuZW1wdHk7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhlIHNlbGVjdGlvbiB3YXMgZXhwbGljaXRseSBzZXQgaW4gdGhpcyB1cGRhdGUuXG4gICAgKi9cbiAgICBnZXQgc2VsZWN0aW9uU2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5zZWxlY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBlbXB0eSgpIHsgcmV0dXJuIHRoaXMuZmxhZ3MgPT0gMCAmJiB0aGlzLnRyYW5zYWN0aW9ucy5sZW5ndGggPT0gMDsgfVxufVxuXG5jbGFzcyBEb2NWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZG9jLmxlbmd0aDsgfVxuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLmR5bmFtaWNEZWNvcmF0aW9uTWFwID0gW107XG4gICAgICAgIHRoaXMuZG9tQ2hhbmdlZCA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFzQ29tcG9zaXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLm1hcmtlZEZvckNvbXBvc2l0aW9uID0gbmV3IFNldDtcbiAgICAgICAgLy8gVHJhY2sgYSBtaW5pbXVtIHdpZHRoIGZvciB0aGUgZWRpdG9yLiBXaGVuIG1lYXN1cmluZyBzaXplcyBpblxuICAgICAgICAvLyBtZWFzdXJlVmlzaWJsZUxpbmVIZWlnaHRzLCB0aGlzIGlzIHVwZGF0ZWQgdG8gcG9pbnQgYXQgdGhlIHdpZHRoXG4gICAgICAgIC8vIG9mIGEgZ2l2ZW4gZWxlbWVudCBhbmQgaXRzIGV4dGVudCBpbiB0aGUgZG9jdW1lbnQuIFdoZW4gYSBjaGFuZ2VcbiAgICAgICAgLy8gaGFwcGVucyBpbiB0aGF0IHJhbmdlLCB0aGVzZSBhcmUgcmVzZXQuIFRoYXQgd2F5LCBvbmNlIHdlJ3ZlIHNlZW5cbiAgICAgICAgLy8gYSBsaW5lL2VsZW1lbnQgb2YgYSBnaXZlbiBsZW5ndGgsIHdlIGtlZXAgdGhlIGVkaXRvciB3aWRlIGVub3VnaFxuICAgICAgICAvLyB0byBmaXQgYXQgbGVhc3QgdGhhdCBlbGVtZW50LCB1bnRpbCBpdCBpcyBjaGFuZ2VkLCBhdCB3aGljaCBwb2ludFxuICAgICAgICAvLyB3ZSBmb3JnZXQgaXQgYWdhaW4uXG4gICAgICAgIHRoaXMubWluV2lkdGggPSAwO1xuICAgICAgICB0aGlzLm1pbldpZHRoRnJvbSA9IDA7XG4gICAgICAgIHRoaXMubWluV2lkdGhUbyA9IDA7XG4gICAgICAgIC8vIFRyYWNrIHdoZXRoZXIgdGhlIERPTSBzZWxlY3Rpb24gd2FzIHNldCBpbiBhIGxvc3N5IHdheSwgc28gdGhhdFxuICAgICAgICAvLyB3ZSBkb24ndCBtZXNzIGl0IHVwIHdoZW4gcmVhZGluZyBpdCBiYWNrIGl0XG4gICAgICAgIHRoaXMuaW1wcmVjaXNlQW5jaG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbXByZWNpc2VIZWFkID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb3JjZVNlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICAvLyBVc2VkIGJ5IHRoZSByZXNpemUgb2JzZXJ2ZXIgdG8gaWdub3JlIHJlc2l6ZXMgdGhhdCB3ZSBjYXVzZWRcbiAgICAgICAgLy8gb3Vyc2VsdmVzXG4gICAgICAgIHRoaXMubGFzdFVwZGF0ZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuc2V0RE9NKHZpZXcuY29udGVudERPTSk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbbmV3IExpbmVWaWV3XTtcbiAgICAgICAgdGhpcy5jaGlsZHJlblswXS5zZXRQYXJlbnQodGhpcyk7XG4gICAgICAgIHRoaXMudXBkYXRlRGVjbygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUlubmVyKFtuZXcgQ2hhbmdlZFJhbmdlKDAsIDAsIDAsIHZpZXcuc3RhdGUuZG9jLmxlbmd0aCldLCAwLCBudWxsKTtcbiAgICB9XG4gICAgLy8gVXBkYXRlIHRoZSBkb2N1bWVudCB2aWV3IHRvIGEgZ2l2ZW4gc3RhdGUuXG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBjaGFuZ2VkUmFuZ2VzID0gdXBkYXRlLmNoYW5nZWRSYW5nZXM7XG4gICAgICAgIGlmICh0aGlzLm1pbldpZHRoID4gMCAmJiBjaGFuZ2VkUmFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCFjaGFuZ2VkUmFuZ2VzLmV2ZXJ5KCh7IGZyb21BLCB0b0EgfSkgPT4gdG9BIDwgdGhpcy5taW5XaWR0aEZyb20gfHwgZnJvbUEgPiB0aGlzLm1pbldpZHRoVG8pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aCA9IHRoaXMubWluV2lkdGhGcm9tID0gdGhpcy5taW5XaWR0aFRvID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGhGcm9tID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHRoaXMubWluV2lkdGhGcm9tLCAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoVG8gPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3ModGhpcy5taW5XaWR0aFRvLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVhZENvbXBvc2l0aW9uQXQgPSAtMTtcbiAgICAgICAgaWYgKHRoaXMudmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoKF9hID0gdGhpcy5kb21DaGFuZ2VkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmV3U2VsKVxuICAgICAgICAgICAgICAgIHJlYWRDb21wb3NpdGlvbkF0ID0gdGhpcy5kb21DaGFuZ2VkLm5ld1NlbC5oZWFkO1xuICAgICAgICAgICAgZWxzZSBpZiAoIXRvdWNoZXNDb21wb3NpdGlvbih1cGRhdGUuY2hhbmdlcywgdGhpcy5oYXNDb21wb3NpdGlvbikgJiYgIXVwZGF0ZS5zZWxlY3Rpb25TZXQpXG4gICAgICAgICAgICAgICAgcmVhZENvbXBvc2l0aW9uQXQgPSB1cGRhdGUuc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29tcG9zaXRpb24gPSByZWFkQ29tcG9zaXRpb25BdCA+IC0xID8gZmluZENvbXBvc2l0aW9uUmFuZ2UodGhpcy52aWV3LCB1cGRhdGUuY2hhbmdlcywgcmVhZENvbXBvc2l0aW9uQXQpIDogbnVsbDtcbiAgICAgICAgdGhpcy5kb21DaGFuZ2VkID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29tcG9zaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubWFya2VkRm9yQ29tcG9zaXRpb24uY2xlYXIoKTtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSB0aGlzLmhhc0NvbXBvc2l0aW9uO1xuICAgICAgICAgICAgY2hhbmdlZFJhbmdlcyA9IG5ldyBDaGFuZ2VkUmFuZ2UoZnJvbSwgdG8sIHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyhmcm9tLCAtMSksIHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyh0bywgMSkpXG4gICAgICAgICAgICAgICAgLmFkZFRvU2V0KGNoYW5nZWRSYW5nZXMuc2xpY2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYXNDb21wb3NpdGlvbiA9IGNvbXBvc2l0aW9uID8geyBmcm9tOiBjb21wb3NpdGlvbi5yYW5nZS5mcm9tQiwgdG86IGNvbXBvc2l0aW9uLnJhbmdlLnRvQiB9IDogbnVsbDtcbiAgICAgICAgLy8gV2hlbiB0aGUgRE9NIG5vZGVzIGFyb3VuZCB0aGUgc2VsZWN0aW9uIGFyZSBtb3ZlZCB0byBhbm90aGVyXG4gICAgICAgIC8vIHBhcmVudCwgQ2hyb21lIHNvbWV0aW1lcyByZXBvcnRzIGEgZGlmZmVyZW50IHNlbGVjdGlvbiB0aHJvdWdoXG4gICAgICAgIC8vIGdldFNlbGVjdGlvbiB0aGFuIHRoZSBvbmUgdGhhdCBpdCBhY3R1YWxseSBzaG93cyB0byB0aGUgdXNlci5cbiAgICAgICAgLy8gVGhpcyBmb3JjZXMgYSBzZWxlY3Rpb24gdXBkYXRlIHdoZW4gbGluZXMgYXJlIGpvaW5lZCB0byB3b3JrXG4gICAgICAgIC8vIGFyb3VuZCB0aGF0LiBJc3N1ZSAjNTRcbiAgICAgICAgaWYgKChicm93c2VyLmllIHx8IGJyb3dzZXIuY2hyb21lKSAmJiAhY29tcG9zaXRpb24gJiYgdXBkYXRlICYmXG4gICAgICAgICAgICB1cGRhdGUuc3RhdGUuZG9jLmxpbmVzICE9IHVwZGF0ZS5zdGFydFN0YXRlLmRvYy5saW5lcylcbiAgICAgICAgICAgIHRoaXMuZm9yY2VTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICBsZXQgcHJldkRlY28gPSB0aGlzLmRlY29yYXRpb25zLCBkZWNvID0gdGhpcy51cGRhdGVEZWNvKCk7XG4gICAgICAgIGxldCBkZWNvRGlmZiA9IGZpbmRDaGFuZ2VkRGVjbyhwcmV2RGVjbywgZGVjbywgdXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICBjaGFuZ2VkUmFuZ2VzID0gQ2hhbmdlZFJhbmdlLmV4dGVuZFdpdGhSYW5nZXMoY2hhbmdlZFJhbmdlcywgZGVjb0RpZmYpO1xuICAgICAgICBpZiAoISh0aGlzLmZsYWdzICYgNyAvKiBWaWV3RmxhZy5EaXJ0eSAqLykgJiYgY2hhbmdlZFJhbmdlcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVJbm5lcihjaGFuZ2VkUmFuZ2VzLCB1cGRhdGUuc3RhcnRTdGF0ZS5kb2MubGVuZ3RoLCBjb21wb3NpdGlvbik7XG4gICAgICAgICAgICBpZiAodXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0VXBkYXRlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFVzZWQgYnkgdXBkYXRlIGFuZCB0aGUgY29uc3RydWN0b3IgZG8gcGVyZm9ybSB0aGUgYWN0dWFsIERPTVxuICAgIC8vIHVwZGF0ZVxuICAgIHVwZGF0ZUlubmVyKGNoYW5nZXMsIG9sZExlbmd0aCwgY29tcG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy52aWV3LnZpZXdTdGF0ZS5tdXN0TWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xuICAgICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKGNoYW5nZXMsIG9sZExlbmd0aCwgY29tcG9zaXRpb24pO1xuICAgICAgICBsZXQgeyBvYnNlcnZlciB9ID0gdGhpcy52aWV3O1xuICAgICAgICBvYnNlcnZlci5pZ25vcmUoKCkgPT4ge1xuICAgICAgICAgICAgLy8gTG9jayB0aGUgaGVpZ2h0IGR1cmluZyByZWRyYXdpbmcsIHNpbmNlIENocm9tZSBzb21ldGltZXNcbiAgICAgICAgICAgIC8vIG1lc3NlcyB3aXRoIHRoZSBzY3JvbGwgcG9zaXRpb24gZHVyaW5nIERPTSBtdXRhdGlvbiAodGhvdWdoXG4gICAgICAgICAgICAvLyBubyByZWxheW91dCBpcyB0cmlnZ2VyZWQgYW5kIEkgY2Fubm90IGltYWdpbmUgaG93IGl0IGNhblxuICAgICAgICAgICAgLy8gcmVjb21wdXRlIHRoZSBzY3JvbGwgcG9zaXRpb24gd2l0aG91dCBhIGxheW91dClcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLmhlaWdodCA9IHRoaXMudmlldy52aWV3U3RhdGUuY29udGVudEhlaWdodCAvIHRoaXMudmlldy5zY2FsZVkgKyBcInB4XCI7XG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5mbGV4QmFzaXMgPSB0aGlzLm1pbldpZHRoID8gdGhpcy5taW5XaWR0aCArIFwicHhcIiA6IFwiXCI7XG4gICAgICAgICAgICAvLyBDaHJvbWUgd2lsbCBzb21ldGltZXMsIHdoZW4gRE9NIG11dGF0aW9ucyBvY2N1ciBkaXJlY3RseVxuICAgICAgICAgICAgLy8gYXJvdW5kIHRoZSBzZWxlY3Rpb24sIGdldCBjb25mdXNlZCBhbmQgcmVwb3J0IGEgZGlmZmVyZW50XG4gICAgICAgICAgICAvLyBzZWxlY3Rpb24gZnJvbSB0aGUgb25lIGl0IGRpc3BsYXlzIChpc3N1ZSAjMjE4KS4gVGhpcyB0cmllc1xuICAgICAgICAgICAgLy8gdG8gZGV0ZWN0IHRoYXQgc2l0dWF0aW9uLlxuICAgICAgICAgICAgbGV0IHRyYWNrID0gYnJvd3Nlci5jaHJvbWUgfHwgYnJvd3Nlci5pb3MgPyB7IG5vZGU6IG9ic2VydmVyLnNlbGVjdGlvblJhbmdlLmZvY3VzTm9kZSwgd3JpdHRlbjogZmFsc2UgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc3luYyh0aGlzLnZpZXcsIHRyYWNrKTtcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MgJj0gfjcgLyogVmlld0ZsYWcuRGlydHkgKi87XG4gICAgICAgICAgICBpZiAodHJhY2sgJiYgKHRyYWNrLndyaXR0ZW4gfHwgb2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2UuZm9jdXNOb2RlICE9IHRyYWNrLm5vZGUpKVxuICAgICAgICAgICAgICAgIHRoaXMuZm9yY2VTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUuaGVpZ2h0ID0gXCJcIjtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFya2VkRm9yQ29tcG9zaXRpb24uZm9yRWFjaChjVmlldyA9PiBjVmlldy5mbGFncyAmPSB+OCAvKiBWaWV3RmxhZy5Db21wb3NpdGlvbiAqLyk7XG4gICAgICAgIGxldCBnYXBzID0gW107XG4gICAgICAgIGlmICh0aGlzLnZpZXcudmlld3BvcnQuZnJvbSB8fCB0aGlzLnZpZXcudmlld3BvcnQudG8gPCB0aGlzLnZpZXcuc3RhdGUuZG9jLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgQmxvY2tXaWRnZXRWaWV3ICYmIGNoaWxkLndpZGdldCBpbnN0YW5jZW9mIEJsb2NrR2FwV2lkZ2V0KVxuICAgICAgICAgICAgICAgICAgICBnYXBzLnB1c2goY2hpbGQuZG9tKTtcbiAgICAgICAgb2JzZXJ2ZXIudXBkYXRlR2FwcyhnYXBzKTtcbiAgICB9XG4gICAgdXBkYXRlQ2hpbGRyZW4oY2hhbmdlcywgb2xkTGVuZ3RoLCBjb21wb3NpdGlvbikge1xuICAgICAgICBsZXQgcmFuZ2VzID0gY29tcG9zaXRpb24gPyBjb21wb3NpdGlvbi5yYW5nZS5hZGRUb1NldChjaGFuZ2VzLnNsaWNlKCkpIDogY2hhbmdlcztcbiAgICAgICAgbGV0IGN1cnNvciA9IHRoaXMuY2hpbGRDdXJzb3Iob2xkTGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHJhbmdlcy5sZW5ndGggLSAxOzsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGkgPj0gMCA/IHJhbmdlc1tpXSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoIW5leHQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgeyBmcm9tQSwgdG9BLCBmcm9tQiwgdG9CIH0gPSBuZXh0LCBjb250ZW50LCBicmVha0F0U3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZDtcbiAgICAgICAgICAgIGlmIChjb21wb3NpdGlvbiAmJiBjb21wb3NpdGlvbi5yYW5nZS5mcm9tQiA8IHRvQiAmJiBjb21wb3NpdGlvbi5yYW5nZS50b0IgPiBmcm9tQikge1xuICAgICAgICAgICAgICAgIGxldCBiZWZvcmUgPSBDb250ZW50QnVpbGRlci5idWlsZCh0aGlzLnZpZXcuc3RhdGUuZG9jLCBmcm9tQiwgY29tcG9zaXRpb24ucmFuZ2UuZnJvbUIsIHRoaXMuZGVjb3JhdGlvbnMsIHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXApO1xuICAgICAgICAgICAgICAgIGxldCBhZnRlciA9IENvbnRlbnRCdWlsZGVyLmJ1aWxkKHRoaXMudmlldy5zdGF0ZS5kb2MsIGNvbXBvc2l0aW9uLnJhbmdlLnRvQiwgdG9CLCB0aGlzLmRlY29yYXRpb25zLCB0aGlzLmR5bmFtaWNEZWNvcmF0aW9uTWFwKTtcbiAgICAgICAgICAgICAgICBicmVha0F0U3RhcnQgPSBiZWZvcmUuYnJlYWtBdFN0YXJ0O1xuICAgICAgICAgICAgICAgIG9wZW5TdGFydCA9IGJlZm9yZS5vcGVuU3RhcnQ7XG4gICAgICAgICAgICAgICAgb3BlbkVuZCA9IGFmdGVyLm9wZW5FbmQ7XG4gICAgICAgICAgICAgICAgbGV0IGNvbXBMaW5lID0gdGhpcy5jb21wb3NpdGlvblZpZXcoY29tcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGlmIChhZnRlci5icmVha0F0U3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcExpbmUuYnJlYWtBZnRlciA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFmdGVyLmNvbnRlbnQubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbXBMaW5lLm1lcmdlKGNvbXBMaW5lLmxlbmd0aCwgY29tcExpbmUubGVuZ3RoLCBhZnRlci5jb250ZW50WzBdLCBmYWxzZSwgYWZ0ZXIub3BlblN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgICAgICBjb21wTGluZS5icmVha0FmdGVyID0gYWZ0ZXIuY29udGVudFswXS5icmVha0FmdGVyO1xuICAgICAgICAgICAgICAgICAgICBhZnRlci5jb250ZW50LnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChiZWZvcmUuY29udGVudC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgY29tcExpbmUubWVyZ2UoMCwgMCwgYmVmb3JlLmNvbnRlbnRbYmVmb3JlLmNvbnRlbnQubGVuZ3RoIC0gMV0sIHRydWUsIDAsIGJlZm9yZS5vcGVuRW5kKSkge1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmUuY29udGVudC5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGVudCA9IGJlZm9yZS5jb250ZW50LmNvbmNhdChjb21wTGluZSkuY29uY2F0KGFmdGVyLmNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgKHsgY29udGVudCwgYnJlYWtBdFN0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQgfSA9XG4gICAgICAgICAgICAgICAgICAgIENvbnRlbnRCdWlsZGVyLmJ1aWxkKHRoaXMudmlldy5zdGF0ZS5kb2MsIGZyb21CLCB0b0IsIHRoaXMuZGVjb3JhdGlvbnMsIHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB7IGk6IHRvSSwgb2ZmOiB0b09mZiB9ID0gY3Vyc29yLmZpbmRQb3ModG9BLCAxKTtcbiAgICAgICAgICAgIGxldCB7IGk6IGZyb21JLCBvZmY6IGZyb21PZmYgfSA9IGN1cnNvci5maW5kUG9zKGZyb21BLCAtMSk7XG4gICAgICAgICAgICByZXBsYWNlUmFuZ2UodGhpcywgZnJvbUksIGZyb21PZmYsIHRvSSwgdG9PZmYsIGNvbnRlbnQsIGJyZWFrQXRTdGFydCwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcG9zaXRpb24pXG4gICAgICAgICAgICB0aGlzLmZpeENvbXBvc2l0aW9uRE9NKGNvbXBvc2l0aW9uKTtcbiAgICB9XG4gICAgY29tcG9zaXRpb25WaWV3KGNvbXBvc2l0aW9uKSB7XG4gICAgICAgIGxldCBjdXIgPSBuZXcgVGV4dFZpZXcoY29tcG9zaXRpb24udGV4dC5ub2RlVmFsdWUpO1xuICAgICAgICBjdXIuZmxhZ3MgfD0gOCAvKiBWaWV3RmxhZy5Db21wb3NpdGlvbiAqLztcbiAgICAgICAgZm9yIChsZXQgeyBkZWNvIH0gb2YgY29tcG9zaXRpb24ubWFya3MpXG4gICAgICAgICAgICBjdXIgPSBuZXcgTWFya1ZpZXcoZGVjbywgW2N1cl0sIGN1ci5sZW5ndGgpO1xuICAgICAgICBsZXQgbGluZSA9IG5ldyBMaW5lVmlldztcbiAgICAgICAgbGluZS5hcHBlbmQoY3VyLCAwKTtcbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuICAgIGZpeENvbXBvc2l0aW9uRE9NKGNvbXBvc2l0aW9uKSB7XG4gICAgICAgIGxldCBmaXggPSAoZG9tLCBjVmlldykgPT4ge1xuICAgICAgICAgICAgY1ZpZXcuZmxhZ3MgfD0gOCAvKiBWaWV3RmxhZy5Db21wb3NpdGlvbiAqLyB8IChjVmlldy5jaGlsZHJlbi5zb21lKGMgPT4gYy5mbGFncyAmIDcgLyogVmlld0ZsYWcuRGlydHkgKi8pID8gMSAvKiBWaWV3RmxhZy5DaGlsZERpcnR5ICovIDogMCk7XG4gICAgICAgICAgICB0aGlzLm1hcmtlZEZvckNvbXBvc2l0aW9uLmFkZChjVmlldyk7XG4gICAgICAgICAgICBsZXQgcHJldiA9IENvbnRlbnRWaWV3LmdldChkb20pO1xuICAgICAgICAgICAgaWYgKHByZXYgJiYgcHJldiAhPSBjVmlldylcbiAgICAgICAgICAgICAgICBwcmV2LmRvbSA9IG51bGw7XG4gICAgICAgICAgICBjVmlldy5zZXRET00oZG9tKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuY2hpbGRQb3MoY29tcG9zaXRpb24ucmFuZ2UuZnJvbUIsIDEpO1xuICAgICAgICBsZXQgY1ZpZXcgPSB0aGlzLmNoaWxkcmVuW3Bvcy5pXTtcbiAgICAgICAgZml4KGNvbXBvc2l0aW9uLmxpbmUsIGNWaWV3KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGNvbXBvc2l0aW9uLm1hcmtzLmxlbmd0aCAtIDE7IGkgPj0gLTE7IGktLSkge1xuICAgICAgICAgICAgcG9zID0gY1ZpZXcuY2hpbGRQb3MocG9zLm9mZiwgMSk7XG4gICAgICAgICAgICBjVmlldyA9IGNWaWV3LmNoaWxkcmVuW3Bvcy5pXTtcbiAgICAgICAgICAgIGZpeChpID49IDAgPyBjb21wb3NpdGlvbi5tYXJrc1tpXS5ub2RlIDogY29tcG9zaXRpb24udGV4dCwgY1ZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFN5bmMgdGhlIERPTSBzZWxlY3Rpb24gdG8gdGhpcy5zdGF0ZS5zZWxlY3Rpb25cbiAgICB1cGRhdGVTZWxlY3Rpb24obXVzdFJlYWQgPSBmYWxzZSwgZnJvbVBvaW50ZXIgPSBmYWxzZSkge1xuICAgICAgICBpZiAobXVzdFJlYWQgfHwgIXRoaXMudmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZS5mb2N1c05vZGUpXG4gICAgICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIucmVhZFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCBhY3RpdmVFbHQgPSB0aGlzLnZpZXcucm9vdC5hY3RpdmVFbGVtZW50LCBmb2N1c2VkID0gYWN0aXZlRWx0ID09IHRoaXMuZG9tO1xuICAgICAgICBsZXQgc2VsZWN0aW9uTm90Rm9jdXMgPSAhZm9jdXNlZCAmJlxuICAgICAgICAgICAgaGFzU2VsZWN0aW9uKHRoaXMuZG9tLCB0aGlzLnZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2UpICYmICEoYWN0aXZlRWx0ICYmIHRoaXMuZG9tLmNvbnRhaW5zKGFjdGl2ZUVsdCkpO1xuICAgICAgICBpZiAoIShmb2N1c2VkIHx8IGZyb21Qb2ludGVyIHx8IHNlbGVjdGlvbk5vdEZvY3VzKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGZvcmNlID0gdGhpcy5mb3JjZVNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5mb3JjZVNlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICBsZXQgbWFpbiA9IHRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICAgICAgbGV0IGFuY2hvciA9IHRoaXMubW92ZVRvTGluZSh0aGlzLmRvbUF0UG9zKG1haW4uYW5jaG9yKSk7XG4gICAgICAgIGxldCBoZWFkID0gbWFpbi5lbXB0eSA/IGFuY2hvciA6IHRoaXMubW92ZVRvTGluZSh0aGlzLmRvbUF0UG9zKG1haW4uaGVhZCkpO1xuICAgICAgICAvLyBBbHdheXMgcmVzZXQgb24gRmlyZWZveCB3aGVuIG5leHQgdG8gYW4gdW5lZGl0YWJsZSBub2RlIHRvXG4gICAgICAgIC8vIGF2b2lkIGludmlzaWJsZSBjdXJzb3IgYnVncyAoIzExMSlcbiAgICAgICAgaWYgKGJyb3dzZXIuZ2Vja28gJiYgbWFpbi5lbXB0eSAmJiAhdGhpcy5oYXNDb21wb3NpdGlvbiAmJiBiZXR3ZWVuVW5lZGl0YWJsZShhbmNob3IpKSB7XG4gICAgICAgICAgICBsZXQgZHVtbXkgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKTtcbiAgICAgICAgICAgIHRoaXMudmlldy5vYnNlcnZlci5pZ25vcmUoKCkgPT4gYW5jaG9yLm5vZGUuaW5zZXJ0QmVmb3JlKGR1bW15LCBhbmNob3Iubm9kZS5jaGlsZE5vZGVzW2FuY2hvci5vZmZzZXRdIHx8IG51bGwpKTtcbiAgICAgICAgICAgIGFuY2hvciA9IGhlYWQgPSBuZXcgRE9NUG9zKGR1bW15LCAwKTtcbiAgICAgICAgICAgIGZvcmNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZG9tU2VsID0gdGhpcy52aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlO1xuICAgICAgICAvLyBJZiB0aGUgc2VsZWN0aW9uIGlzIGFscmVhZHkgaGVyZSwgb3IgaW4gYW4gZXF1aXZhbGVudCBwb3NpdGlvbiwgZG9uJ3QgdG91Y2ggaXRcbiAgICAgICAgaWYgKGZvcmNlIHx8ICFkb21TZWwuZm9jdXNOb2RlIHx8ICghaXNFcXVpdmFsZW50UG9zaXRpb24oYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQsIGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KSB8fFxuICAgICAgICAgICAgIWlzRXF1aXZhbGVudFBvc2l0aW9uKGhlYWQubm9kZSwgaGVhZC5vZmZzZXQsIGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCkpICYmICF0aGlzLnN1cHByZXNzV2lkZ2V0Q3Vyc29yQ2hhbmdlKGRvbVNlbCwgbWFpbikpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5vYnNlcnZlci5pZ25vcmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIENocm9tZSBBbmRyb2lkIHdpbGwgaGlkZSB0aGUgdmlydHVhbCBrZXlib2FyZCB3aGVuIHRhcHBpbmdcbiAgICAgICAgICAgICAgICAvLyBpbnNpZGUgYW4gdW5lZGl0YWJsZSBub2RlLCBhbmQgbm90IGJyaW5nIGl0IGJhY2sgd2hlbiB3ZVxuICAgICAgICAgICAgICAgIC8vIG1vdmUgdGhlIGN1cnNvciB0byBpdHMgcHJvcGVyIHBvc2l0aW9uLiBUaGlzIHRyaWVzIHRvXG4gICAgICAgICAgICAgICAgLy8gcmVzdG9yZSB0aGUga2V5Ym9hcmQgYnkgY3ljbGluZyBmb2N1cy5cbiAgICAgICAgICAgICAgICBpZiAoYnJvd3Nlci5hbmRyb2lkICYmIGJyb3dzZXIuY2hyb21lICYmIHRoaXMuZG9tLmNvbnRhaW5zKGRvbVNlbC5mb2N1c05vZGUpICYmXG4gICAgICAgICAgICAgICAgICAgIGluVW5lZGl0YWJsZShkb21TZWwuZm9jdXNOb2RlLCB0aGlzLmRvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByYXdTZWwgPSBnZXRTZWxlY3Rpb24odGhpcy52aWV3LnJvb3QpO1xuICAgICAgICAgICAgICAgIGlmICghcmF3U2VsKSA7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWFpbi5lbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXb3JrIGFyb3VuZCBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNjEyMDc2XG4gICAgICAgICAgICAgICAgICAgIGlmIChicm93c2VyLmdlY2tvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dFRvID0gbmV4dFRvVW5lZGl0YWJsZShhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFRvICYmIG5leHRUbyAhPSAoMSAvKiBOZXh0VG8uQmVmb3JlICovIHwgMiAvKiBOZXh0VG8uQWZ0ZXIgKi8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRleHQgPSBuZWFyYnlUZXh0Tm9kZShhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCwgbmV4dFRvID09IDEgLyogTmV4dFRvLkJlZm9yZSAqLyA/IDEgOiAtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvciA9IG5ldyBET01Qb3ModGV4dC5ub2RlLCB0ZXh0Lm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmF3U2VsLmNvbGxhcHNlKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1haW4uYmlkaUxldmVsICE9IG51bGwgJiYgcmF3U2VsLmNhcmV0QmlkaUxldmVsICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdTZWwuY2FyZXRCaWRpTGV2ZWwgPSBtYWluLmJpZGlMZXZlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmF3U2VsLmV4dGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZWxlY3Rpb24uZXh0ZW5kIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhbiAnaW52ZXJ0ZWQnIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyAob25lIHdoZXJlIHRoZSBmb2N1cyBpcyBiZWZvcmUgdGhlIGFuY2hvciksIGJ1dCBub3QgYWxsXG4gICAgICAgICAgICAgICAgICAgIC8vIGJyb3dzZXJzIHN1cHBvcnQgaXQgeWV0LlxuICAgICAgICAgICAgICAgICAgICByYXdTZWwuY29sbGFwc2UoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgd2lsbCBpZ25vcmUgdGhlIGNhbGwgYWJvdmUgd2hlbiB0aGUgZWRpdG9yIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIGhpZGRlbiwgYW5kIHRoZW4gcmFpc2UgYW4gZXJyb3Igb24gdGhlIGNhbGwgdG8gZXh0ZW5kXG4gICAgICAgICAgICAgICAgICAgIC8vICgjOTQwKS5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd1NlbC5leHRlbmQoaGVhZC5ub2RlLCBoZWFkLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJpbWl0aXZlIChJRSkgd2F5XG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYWluLmFuY2hvciA+IG1haW4uaGVhZClcbiAgICAgICAgICAgICAgICAgICAgICAgIFthbmNob3IsIGhlYWRdID0gW2hlYWQsIGFuY2hvcl07XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZChoZWFkLm5vZGUsIGhlYWQub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICByYXdTZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJhd1NlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25Ob3RGb2N1cyAmJiB0aGlzLnZpZXcucm9vdC5hY3RpdmVFbGVtZW50ID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUVsdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUVsdC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLnNldFNlbGVjdGlvblJhbmdlKGFuY2hvciwgaGVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbXByZWNpc2VBbmNob3IgPSBhbmNob3IucHJlY2lzZSA/IG51bGwgOiBuZXcgRE9NUG9zKGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgdGhpcy5pbXByZWNpc2VIZWFkID0gaGVhZC5wcmVjaXNlID8gbnVsbCA6IG5ldyBET01Qb3MoZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0KTtcbiAgICB9XG4gICAgLy8gSWYgYSB6ZXJvLWxlbmd0aCB3aWRnZXQgaXMgaW5zZXJ0ZWQgbmV4dCB0byB0aGUgY3Vyc29yIGR1cmluZ1xuICAgIC8vIGNvbXBvc2l0aW9uLCBhdm9pZCBtb3ZpbmcgaXQgYWNyb3NzIGl0IGFuZCBkaXNydXB0aW5nIHRoZVxuICAgIC8vIGNvbXBvc2l0aW9uLlxuICAgIHN1cHByZXNzV2lkZ2V0Q3Vyc29yQ2hhbmdlKHNlbCwgY3Vyc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0NvbXBvc2l0aW9uICYmIGN1cnNvci5lbXB0eSAmJlxuICAgICAgICAgICAgaXNFcXVpdmFsZW50UG9zaXRpb24oc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0LCBzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCkgJiZcbiAgICAgICAgICAgIHRoaXMucG9zRnJvbURPTShzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpID09IGN1cnNvci5oZWFkO1xuICAgIH1cbiAgICBlbmZvcmNlQ3Vyc29yQXNzb2MoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0NvbXBvc2l0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzLCBjdXJzb3IgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICBsZXQgc2VsID0gZ2V0U2VsZWN0aW9uKHZpZXcucm9vdCk7XG4gICAgICAgIGxldCB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCB9ID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgaWYgKCFzZWwgfHwgIWN1cnNvci5lbXB0eSB8fCAhY3Vyc29yLmFzc29jIHx8ICFzZWwubW9kaWZ5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbGluZSA9IExpbmVWaWV3LmZpbmQodGhpcywgY3Vyc29yLmhlYWQpO1xuICAgICAgICBpZiAoIWxpbmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBsaW5lU3RhcnQgPSBsaW5lLnBvc0F0U3RhcnQ7XG4gICAgICAgIGlmIChjdXJzb3IuaGVhZCA9PSBsaW5lU3RhcnQgfHwgY3Vyc29yLmhlYWQgPT0gbGluZVN0YXJ0ICsgbGluZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBiZWZvcmUgPSB0aGlzLmNvb3Jkc0F0KGN1cnNvci5oZWFkLCAtMSksIGFmdGVyID0gdGhpcy5jb29yZHNBdChjdXJzb3IuaGVhZCwgMSk7XG4gICAgICAgIGlmICghYmVmb3JlIHx8ICFhZnRlciB8fCBiZWZvcmUuYm90dG9tID4gYWZ0ZXIudG9wKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZG9tID0gdGhpcy5kb21BdFBvcyhjdXJzb3IuaGVhZCArIGN1cnNvci5hc3NvYyk7XG4gICAgICAgIHNlbC5jb2xsYXBzZShkb20ubm9kZSwgZG9tLm9mZnNldCk7XG4gICAgICAgIHNlbC5tb2RpZnkoXCJtb3ZlXCIsIGN1cnNvci5hc3NvYyA8IDAgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIiwgXCJsaW5lYm91bmRhcnlcIik7XG4gICAgICAgIC8vIFRoaXMgY2FuIGdvIHdyb25nIGluIGNvcm5lciBjYXNlcyBsaWtlIHNpbmdsZS1jaGFyYWN0ZXIgbGluZXMsXG4gICAgICAgIC8vIHNvIGNoZWNrIGFuZCByZXNldCBpZiBuZWNlc3NhcnkuXG4gICAgICAgIHZpZXcub2JzZXJ2ZXIucmVhZFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCBuZXdSYW5nZSA9IHZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2U7XG4gICAgICAgIGlmICh2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShuZXdSYW5nZS5hbmNob3JOb2RlLCBuZXdSYW5nZS5hbmNob3JPZmZzZXQpICE9IGN1cnNvci5mcm9tKVxuICAgICAgICAgICAgc2VsLmNvbGxhcHNlKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCk7XG4gICAgfVxuICAgIC8vIElmIGEgcG9zaXRpb24gaXMgaW4vbmVhciBhIGJsb2NrIHdpZGdldCwgbW92ZSBpdCB0byBhIG5lYXJieSB0ZXh0XG4gICAgLy8gbGluZSwgc2luY2Ugd2UgZG9uJ3Qgd2FudCB0aGUgY3Vyc29yIGluc2lkZSBhIGJsb2NrIHdpZGdldC5cbiAgICBtb3ZlVG9MaW5lKHBvcykge1xuICAgICAgICAvLyBCbG9jayB3aWRnZXRzIHdpbGwgcmV0dXJuIHBvc2l0aW9ucyBiZWZvcmUvYWZ0ZXIgdGhlbSwgd2hpY2hcbiAgICAgICAgLy8gYXJlIHRodXMgZGlyZWN0bHkgaW4gdGhlIGRvY3VtZW50IERPTSBlbGVtZW50LlxuICAgICAgICBsZXQgZG9tID0gdGhpcy5kb20sIG5ld1BvcztcbiAgICAgICAgaWYgKHBvcy5ub2RlICE9IGRvbSlcbiAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIGZvciAobGV0IGkgPSBwb3Mub2Zmc2V0OyAhbmV3UG9zICYmIGkgPCBkb20uY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHZpZXcgPSBDb250ZW50Vmlldy5nZXQoZG9tLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICAgICAgaWYgKHZpZXcgaW5zdGFuY2VvZiBMaW5lVmlldylcbiAgICAgICAgICAgICAgICBuZXdQb3MgPSB2aWV3LmRvbUF0UG9zKDApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBwb3Mub2Zmc2V0IC0gMTsgIW5ld1BvcyAmJiBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHZpZXcgPSBDb250ZW50Vmlldy5nZXQoZG9tLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICAgICAgaWYgKHZpZXcgaW5zdGFuY2VvZiBMaW5lVmlldylcbiAgICAgICAgICAgICAgICBuZXdQb3MgPSB2aWV3LmRvbUF0UG9zKHZpZXcubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3UG9zID8gbmV3IERPTVBvcyhuZXdQb3Mubm9kZSwgbmV3UG9zLm9mZnNldCwgdHJ1ZSkgOiBwb3M7XG4gICAgfVxuICAgIG5lYXJlc3QoZG9tKSB7XG4gICAgICAgIGZvciAobGV0IGN1ciA9IGRvbTsgY3VyOykge1xuICAgICAgICAgICAgbGV0IGRvbVZpZXcgPSBDb250ZW50Vmlldy5nZXQoY3VyKTtcbiAgICAgICAgICAgIGlmIChkb21WaWV3ICYmIGRvbVZpZXcucm9vdFZpZXcgPT0gdGhpcylcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tVmlldztcbiAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBwb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkge1xuICAgICAgICBsZXQgdmlldyA9IHRoaXMubmVhcmVzdChub2RlKTtcbiAgICAgICAgaWYgKCF2aWV3KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUcnlpbmcgdG8gZmluZCBwb3NpdGlvbiBmb3IgYSBET00gcG9zaXRpb24gb3V0c2lkZSBvZiB0aGUgZG9jdW1lbnRcIik7XG4gICAgICAgIHJldHVybiB2aWV3LmxvY2FsUG9zRnJvbURPTShub2RlLCBvZmZzZXQpICsgdmlldy5wb3NBdFN0YXJ0O1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgbGV0IHsgaSwgb2ZmIH0gPSB0aGlzLmNoaWxkQ3Vyc29yKCkuZmluZFBvcyhwb3MsIC0xKTtcbiAgICAgICAgZm9yICg7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDE7KSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKG9mZiA8IGNoaWxkLmxlbmd0aCB8fCBjaGlsZCBpbnN0YW5jZW9mIExpbmVWaWV3KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgb2ZmID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpXS5kb21BdFBvcyhvZmYpO1xuICAgIH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IGJlc3QgPSBudWxsLCBiZXN0UG9zID0gMDtcbiAgICAgICAgZm9yIChsZXQgb2ZmID0gdGhpcy5sZW5ndGgsIGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBvZmYgLSBjaGlsZC5icmVha0FmdGVyLCBzdGFydCA9IGVuZCAtIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPCBwb3MpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPD0gcG9zICYmIChzdGFydCA8IHBvcyB8fCBjaGlsZC5jb3ZlcnMoLTEpKSAmJiAoZW5kID4gcG9zIHx8IGNoaWxkLmNvdmVycygxKSkgJiZcbiAgICAgICAgICAgICAgICAoIWJlc3QgfHwgY2hpbGQgaW5zdGFuY2VvZiBMaW5lVmlldyAmJiAhKGJlc3QgaW5zdGFuY2VvZiBMaW5lVmlldyAmJiBzaWRlID49IDApKSkge1xuICAgICAgICAgICAgICAgIGJlc3QgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICBiZXN0UG9zID0gc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmYgPSBzdGFydDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmVzdCA/IGJlc3QuY29vcmRzQXQocG9zIC0gYmVzdFBvcywgc2lkZSkgOiBudWxsO1xuICAgIH1cbiAgICBjb29yZHNGb3JDaGFyKHBvcykge1xuICAgICAgICBsZXQgeyBpLCBvZmYgfSA9IHRoaXMuY2hpbGRQb3MocG9zLCAxKSwgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoIShjaGlsZCBpbnN0YW5jZW9mIExpbmVWaWV3KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB3aGlsZSAoY2hpbGQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgeyBpLCBvZmY6IGNoaWxkT2ZmIH0gPSBjaGlsZC5jaGlsZFBvcyhvZmYsIDEpO1xuICAgICAgICAgICAgZm9yICg7OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSBjaGlsZC5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIGlmICgoY2hpbGQgPSBjaGlsZC5jaGlsZHJlbltpXSkubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZiA9IGNoaWxkT2ZmO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGNoaWxkIGluc3RhbmNlb2YgVGV4dFZpZXcpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBlbmQgPSBmaW5kQ2x1c3RlckJyZWFrKGNoaWxkLnRleHQsIG9mZik7XG4gICAgICAgIGlmIChlbmQgPT0gb2ZmKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCByZWN0cyA9IHRleHRSYW5nZShjaGlsZC5kb20sIG9mZiwgZW5kKS5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW2ldO1xuICAgICAgICAgICAgaWYgKGkgPT0gcmVjdHMubGVuZ3RoIC0gMSB8fCByZWN0LnRvcCA8IHJlY3QuYm90dG9tICYmIHJlY3QubGVmdCA8IHJlY3QucmlnaHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG1lYXN1cmVWaXNpYmxlTGluZUhlaWdodHModmlld3BvcnQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdLCB7IGZyb20sIHRvIH0gPSB2aWV3cG9ydDtcbiAgICAgICAgbGV0IGNvbnRlbnRXaWR0aCA9IHRoaXMudmlldy5jb250ZW50RE9NLmNsaWVudFdpZHRoO1xuICAgICAgICBsZXQgaXNXaWRlciA9IGNvbnRlbnRXaWR0aCA+IE1hdGgubWF4KHRoaXMudmlldy5zY3JvbGxET00uY2xpZW50V2lkdGgsIHRoaXMubWluV2lkdGgpICsgMTtcbiAgICAgICAgbGV0IHdpZGVzdCA9IC0xLCBsdHIgPSB0aGlzLnZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPiB0bylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChwb3MgPj0gZnJvbSkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZFJlY3QgPSBjaGlsZC5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGRSZWN0LmhlaWdodCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzV2lkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBjaGlsZC5kb20ubGFzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVjdHMgPSBsYXN0ID8gY2xpZW50UmVjdHNGb3IobGFzdCkgOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3RzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tyZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3aWR0aCA9IGx0ciA/IHJlY3QucmlnaHQgLSBjaGlsZFJlY3QubGVmdCA6IGNoaWxkUmVjdC5yaWdodCAtIHJlY3QubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aWR0aCA+IHdpZGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZGVzdCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGggPSBjb250ZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aEZyb20gPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aFRvID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gZW5kICsgY2hpbGQuYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0ZXh0RGlyZWN0aW9uQXQocG9zKSB7XG4gICAgICAgIGxldCB7IGkgfSA9IHRoaXMuY2hpbGRQb3MocG9zLCAxKTtcbiAgICAgICAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUodGhpcy5jaGlsZHJlbltpXS5kb20pLmRpcmVjdGlvbiA9PSBcInJ0bFwiID8gRGlyZWN0aW9uLlJUTCA6IERpcmVjdGlvbi5MVFI7XG4gICAgfVxuICAgIG1lYXN1cmVUZXh0U2l6ZSgpIHtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgTGluZVZpZXcpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWVhc3VyZSA9IGNoaWxkLm1lYXN1cmVUZXh0U2l6ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChtZWFzdXJlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVhc3VyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBubyB3b3JrYWJsZSBsaW5lIGV4aXN0cywgZm9yY2UgYSBsYXlvdXQgb2YgYSBtZWFzdXJhYmxlIGVsZW1lbnRcbiAgICAgICAgbGV0IGR1bW15ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgbGluZUhlaWdodCwgY2hhcldpZHRoLCB0ZXh0SGVpZ2h0O1xuICAgICAgICBkdW1teS5jbGFzc05hbWUgPSBcImNtLWxpbmVcIjtcbiAgICAgICAgZHVtbXkuc3R5bGUud2lkdGggPSBcIjk5OTk5cHhcIjtcbiAgICAgICAgZHVtbXkuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgIGR1bW15LnRleHRDb250ZW50ID0gXCJhYmMgZGVmIGdoaSBqa2wgbW5vIHBxciBzdHVcIjtcbiAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZChkdW1teSk7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IGNsaWVudFJlY3RzRm9yKGR1bW15LmZpcnN0Q2hpbGQpWzBdO1xuICAgICAgICAgICAgbGluZUhlaWdodCA9IGR1bW15LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICAgICAgICAgIGNoYXJXaWR0aCA9IHJlY3QgPyByZWN0LndpZHRoIC8gMjcgOiA3O1xuICAgICAgICAgICAgdGV4dEhlaWdodCA9IHJlY3QgPyByZWN0LmhlaWdodCA6IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICBkdW1teS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IGxpbmVIZWlnaHQsIGNoYXJXaWR0aCwgdGV4dEhlaWdodCB9O1xuICAgIH1cbiAgICBjaGlsZEN1cnNvcihwb3MgPSB0aGlzLmxlbmd0aCkge1xuICAgICAgICAvLyBNb3ZlIGJhY2sgdG8gc3RhcnQgb2YgbGFzdCBlbGVtZW50IHdoZW4gcG9zc2libGUsIHNvIHRoYXRcbiAgICAgICAgLy8gYENoaWxkQ3Vyc29yLmZpbmRQb3NgIGRvZXNuJ3QgaGF2ZSB0byBkZWFsIHdpdGggdGhlIGVkZ2UgY2FzZVxuICAgICAgICAvLyBvZiBiZWluZyBhZnRlciB0aGUgbGFzdCBlbGVtZW50LlxuICAgICAgICBsZXQgaSA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICBpZiAoaSlcbiAgICAgICAgICAgIHBvcyAtPSB0aGlzLmNoaWxkcmVuWy0taV0ubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbmV3IENoaWxkQ3Vyc29yKHRoaXMuY2hpbGRyZW4sIHBvcywgaSk7XG4gICAgfVxuICAgIGNvbXB1dGVCbG9ja0dhcERlY28oKSB7XG4gICAgICAgIGxldCBkZWNvID0gW10sIHZzID0gdGhpcy52aWV3LnZpZXdTdGF0ZTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaSA9PSB2cy52aWV3cG9ydHMubGVuZ3RoID8gbnVsbCA6IHZzLnZpZXdwb3J0c1tpXTtcbiAgICAgICAgICAgIGxldCBlbmQgPSBuZXh0ID8gbmV4dC5mcm9tIC0gMSA6IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA+IHBvcykge1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSAodnMubGluZUJsb2NrQXQoZW5kKS5ib3R0b20gLSB2cy5saW5lQmxvY2tBdChwb3MpLnRvcCkgLyB0aGlzLnZpZXcuc2NhbGVZO1xuICAgICAgICAgICAgICAgIGRlY28ucHVzaChEZWNvcmF0aW9uLnJlcGxhY2Uoe1xuICAgICAgICAgICAgICAgICAgICB3aWRnZXQ6IG5ldyBCbG9ja0dhcFdpZGdldChoZWlnaHQpLFxuICAgICAgICAgICAgICAgICAgICBibG9jazogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpc0Jsb2NrR2FwOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pLnJhbmdlKHBvcywgZW5kKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwb3MgPSBuZXh0LnRvICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQoZGVjbyk7XG4gICAgfVxuICAgIHVwZGF0ZURlY28oKSB7XG4gICAgICAgIGxldCBhbGxEZWNvID0gdGhpcy52aWV3LnN0YXRlLmZhY2V0KGRlY29yYXRpb25zKS5tYXAoKGQsIGkpID0+IHtcbiAgICAgICAgICAgIGxldCBkeW5hbWljID0gdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcFtpXSA9IHR5cGVvZiBkID09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgICAgIHJldHVybiBkeW5hbWljID8gZCh0aGlzLnZpZXcpIDogZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBkeW5hbWljT3V0ZXIgPSBmYWxzZSwgb3V0ZXJEZWNvID0gdGhpcy52aWV3LnN0YXRlLmZhY2V0KG91dGVyRGVjb3JhdGlvbnMpLm1hcCgoZCwgaSkgPT4ge1xuICAgICAgICAgICAgbGV0IGR5bmFtaWMgPSB0eXBlb2YgZCA9PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgICAgICBpZiAoZHluYW1pYylcbiAgICAgICAgICAgICAgICBkeW5hbWljT3V0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGR5bmFtaWMgPyBkKHRoaXMudmlldykgOiBkO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG91dGVyRGVjby5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXBbYWxsRGVjby5sZW5ndGhdID0gZHluYW1pY091dGVyO1xuICAgICAgICAgICAgYWxsRGVjby5wdXNoKFJhbmdlU2V0LmpvaW4ob3V0ZXJEZWNvKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IGFsbERlY28ubGVuZ3RoOyBpIDwgYWxsRGVjby5sZW5ndGggKyAzOyBpKyspXG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNEZWNvcmF0aW9uTWFwW2ldID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY29yYXRpb25zID0gW1xuICAgICAgICAgICAgLi4uYWxsRGVjbyxcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZUJsb2NrR2FwRGVjbygpLFxuICAgICAgICAgICAgdGhpcy52aWV3LnZpZXdTdGF0ZS5saW5lR2FwRGVjb1xuICAgICAgICBdO1xuICAgIH1cbiAgICBzY3JvbGxJbnRvVmlldyh0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRhcmdldC5pc1NuYXBzaG90KSB7XG4gICAgICAgICAgICBsZXQgcmVmID0gdGhpcy52aWV3LnZpZXdTdGF0ZS5saW5lQmxvY2tBdCh0YXJnZXQucmFuZ2UuaGVhZCk7XG4gICAgICAgICAgICB0aGlzLnZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCA9IHJlZi50b3AgLSB0YXJnZXQueU1hcmdpbjtcbiAgICAgICAgICAgIHRoaXMudmlldy5zY3JvbGxET00uc2Nyb2xsTGVmdCA9IHRhcmdldC54TWFyZ2luO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IHJhbmdlIH0gPSB0YXJnZXQ7XG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5jb29yZHNBdChyYW5nZS5oZWFkLCByYW5nZS5lbXB0eSA/IHJhbmdlLmFzc29jIDogcmFuZ2UuaGVhZCA+IHJhbmdlLmFuY2hvciA/IC0xIDogMSksIG90aGVyO1xuICAgICAgICBpZiAoIXJlY3QpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkgJiYgKG90aGVyID0gdGhpcy5jb29yZHNBdChyYW5nZS5hbmNob3IsIHJhbmdlLmFuY2hvciA+IHJhbmdlLmhlYWQgPyAtMSA6IDEpKSlcbiAgICAgICAgICAgIHJlY3QgPSB7IGxlZnQ6IE1hdGgubWluKHJlY3QubGVmdCwgb3RoZXIubGVmdCksIHRvcDogTWF0aC5taW4ocmVjdC50b3AsIG90aGVyLnRvcCksXG4gICAgICAgICAgICAgICAgcmlnaHQ6IE1hdGgubWF4KHJlY3QucmlnaHQsIG90aGVyLnJpZ2h0KSwgYm90dG9tOiBNYXRoLm1heChyZWN0LmJvdHRvbSwgb3RoZXIuYm90dG9tKSB9O1xuICAgICAgICBsZXQgbWFyZ2lucyA9IGdldFNjcm9sbE1hcmdpbnModGhpcy52aWV3KTtcbiAgICAgICAgbGV0IHRhcmdldFJlY3QgPSB7XG4gICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQgLSBtYXJnaW5zLmxlZnQsIHRvcDogcmVjdC50b3AgLSBtYXJnaW5zLnRvcCxcbiAgICAgICAgICAgIHJpZ2h0OiByZWN0LnJpZ2h0ICsgbWFyZ2lucy5yaWdodCwgYm90dG9tOiByZWN0LmJvdHRvbSArIG1hcmdpbnMuYm90dG9tXG4gICAgICAgIH07XG4gICAgICAgIGxldCB7IG9mZnNldFdpZHRoLCBvZmZzZXRIZWlnaHQgfSA9IHRoaXMudmlldy5zY3JvbGxET007XG4gICAgICAgIHNjcm9sbFJlY3RJbnRvVmlldyh0aGlzLnZpZXcuc2Nyb2xsRE9NLCB0YXJnZXRSZWN0LCByYW5nZS5oZWFkIDwgcmFuZ2UuYW5jaG9yID8gLTEgOiAxLCB0YXJnZXQueCwgdGFyZ2V0LnksIE1hdGgubWF4KE1hdGgubWluKHRhcmdldC54TWFyZ2luLCBvZmZzZXRXaWR0aCksIC1vZmZzZXRXaWR0aCksIE1hdGgubWF4KE1hdGgubWluKHRhcmdldC55TWFyZ2luLCBvZmZzZXRIZWlnaHQpLCAtb2Zmc2V0SGVpZ2h0KSwgdGhpcy52aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUik7XG4gICAgfVxufVxuZnVuY3Rpb24gYmV0d2VlblVuZWRpdGFibGUocG9zKSB7XG4gICAgcmV0dXJuIHBvcy5ub2RlLm5vZGVUeXBlID09IDEgJiYgcG9zLm5vZGUuZmlyc3RDaGlsZCAmJlxuICAgICAgICAocG9zLm9mZnNldCA9PSAwIHx8IHBvcy5ub2RlLmNoaWxkTm9kZXNbcG9zLm9mZnNldCAtIDFdLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpICYmXG4gICAgICAgIChwb3Mub2Zmc2V0ID09IHBvcy5ub2RlLmNoaWxkTm9kZXMubGVuZ3RoIHx8IHBvcy5ub2RlLmNoaWxkTm9kZXNbcG9zLm9mZnNldF0uY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIik7XG59XG5jbGFzcyBCbG9ja0dhcFdpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGhlaWdodCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG4gICAgdG9ET00oKSB7XG4gICAgICAgIGxldCBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBlbHQuY2xhc3NOYW1lID0gXCJjbS1nYXBcIjtcbiAgICAgICAgdGhpcy51cGRhdGVET00oZWx0KTtcbiAgICAgICAgcmV0dXJuIGVsdDtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLmhlaWdodCA9PSB0aGlzLmhlaWdodDsgfVxuICAgIHVwZGF0ZURPTShlbHQpIHtcbiAgICAgICAgZWx0LnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IGVkaXRhYmxlKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGdldCBlc3RpbWF0ZWRIZWlnaHQoKSB7IHJldHVybiB0aGlzLmhlaWdodDsgfVxufVxuZnVuY3Rpb24gZmluZENvbXBvc2l0aW9uTm9kZSh2aWV3LCBoZWFkUG9zKSB7XG4gICAgbGV0IHNlbCA9IHZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2U7XG4gICAgbGV0IHRleHROb2RlID0gc2VsLmZvY3VzTm9kZSAmJiBuZWFyYnlUZXh0Tm9kZShzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQsIDApO1xuICAgIGlmICghdGV4dE5vZGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBmcm9tID0gaGVhZFBvcyAtIHRleHROb2RlLm9mZnNldDtcbiAgICByZXR1cm4geyBmcm9tLCB0bzogZnJvbSArIHRleHROb2RlLm5vZGUubm9kZVZhbHVlLmxlbmd0aCwgbm9kZTogdGV4dE5vZGUubm9kZSB9O1xufVxuZnVuY3Rpb24gZmluZENvbXBvc2l0aW9uUmFuZ2UodmlldywgY2hhbmdlcywgaGVhZFBvcykge1xuICAgIGxldCBmb3VuZCA9IGZpbmRDb21wb3NpdGlvbk5vZGUodmlldywgaGVhZFBvcyk7XG4gICAgaWYgKCFmb3VuZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHsgbm9kZTogdGV4dE5vZGUsIGZyb20sIHRvIH0gPSBmb3VuZCwgdGV4dCA9IHRleHROb2RlLm5vZGVWYWx1ZTtcbiAgICAvLyBEb24ndCB0cnkgdG8gcHJlc2VydmUgbXVsdGktbGluZSBjb21wb3NpdGlvbnNcbiAgICBpZiAoL1tcXG5cXHJdLy50ZXN0KHRleHQpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAodmlldy5zdGF0ZS5kb2Muc2xpY2VTdHJpbmcoZm91bmQuZnJvbSwgZm91bmQudG8pICE9IHRleHQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBpbnYgPSBjaGFuZ2VzLmludmVydGVkRGVzYztcbiAgICBsZXQgcmFuZ2UgPSBuZXcgQ2hhbmdlZFJhbmdlKGludi5tYXBQb3MoZnJvbSksIGludi5tYXBQb3ModG8pLCBmcm9tLCB0byk7XG4gICAgbGV0IG1hcmtzID0gW107XG4gICAgZm9yIChsZXQgcGFyZW50ID0gdGV4dE5vZGUucGFyZW50Tm9kZTs7IHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGxldCBwYXJlbnRWaWV3ID0gQ29udGVudFZpZXcuZ2V0KHBhcmVudCk7XG4gICAgICAgIGlmIChwYXJlbnRWaWV3IGluc3RhbmNlb2YgTWFya1ZpZXcpXG4gICAgICAgICAgICBtYXJrcy5wdXNoKHsgbm9kZTogcGFyZW50LCBkZWNvOiBwYXJlbnRWaWV3Lm1hcmsgfSk7XG4gICAgICAgIGVsc2UgaWYgKHBhcmVudFZpZXcgaW5zdGFuY2VvZiBMaW5lVmlldyB8fCBwYXJlbnQubm9kZU5hbWUgPT0gXCJESVZcIiAmJiBwYXJlbnQucGFyZW50Tm9kZSA9PSB2aWV3LmNvbnRlbnRET00pXG4gICAgICAgICAgICByZXR1cm4geyByYW5nZSwgdGV4dDogdGV4dE5vZGUsIG1hcmtzLCBsaW5lOiBwYXJlbnQgfTtcbiAgICAgICAgZWxzZSBpZiAocGFyZW50ICE9IHZpZXcuY29udGVudERPTSlcbiAgICAgICAgICAgIG1hcmtzLnB1c2goeyBub2RlOiBwYXJlbnQsIGRlY286IG5ldyBNYXJrRGVjb3JhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogZ2V0QXR0cnMocGFyZW50KSxcbiAgICAgICAgICAgICAgICAgICAgdGFnTmFtZTogcGFyZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgIH0pIH0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBuZWFyYnlUZXh0Tm9kZShzdGFydE5vZGUsIHN0YXJ0T2Zmc2V0LCBzaWRlKSB7XG4gICAgaWYgKHNpZGUgPD0gMClcbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IHN0YXJ0Tm9kZSwgb2Zmc2V0ID0gc3RhcnRPZmZzZXQ7Oykge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgICAgICByZXR1cm4geyBub2RlOiBub2RlLCBvZmZzZXQ6IG9mZnNldCB9O1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIGlmIChzaWRlID49IDApXG4gICAgICAgIGZvciAobGV0IG5vZGUgPSBzdGFydE5vZGUsIG9mZnNldCA9IHN0YXJ0T2Zmc2V0OzspIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogbm9kZSwgb2Zmc2V0OiBvZmZzZXQgfTtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAmJiBzaWRlID49IDApIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBuZXh0VG9VbmVkaXRhYmxlKG5vZGUsIG9mZnNldCkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEpXG4gICAgICAgIHJldHVybiAwO1xuICAgIHJldHVybiAob2Zmc2V0ICYmIG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiID8gMSAvKiBOZXh0VG8uQmVmb3JlICovIDogMCkgfFxuICAgICAgICAob2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAmJiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiID8gMiAvKiBOZXh0VG8uQWZ0ZXIgKi8gOiAwKTtcbn1cbmxldCBEZWNvcmF0aW9uQ29tcGFyYXRvciQxID0gY2xhc3MgRGVjb3JhdGlvbkNvbXBhcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBbXTtcbiAgICB9XG4gICAgY29tcGFyZVJhbmdlKGZyb20sIHRvKSB7IGFkZFJhbmdlKGZyb20sIHRvLCB0aGlzLmNoYW5nZXMpOyB9XG4gICAgY29tcGFyZVBvaW50KGZyb20sIHRvKSB7IGFkZFJhbmdlKGZyb20sIHRvLCB0aGlzLmNoYW5nZXMpOyB9XG59O1xuZnVuY3Rpb24gZmluZENoYW5nZWREZWNvKGEsIGIsIGRpZmYpIHtcbiAgICBsZXQgY29tcCA9IG5ldyBEZWNvcmF0aW9uQ29tcGFyYXRvciQxO1xuICAgIFJhbmdlU2V0LmNvbXBhcmUoYSwgYiwgZGlmZiwgY29tcCk7XG4gICAgcmV0dXJuIGNvbXAuY2hhbmdlcztcbn1cbmZ1bmN0aW9uIGluVW5lZGl0YWJsZShub2RlLCBpbnNpZGUpIHtcbiAgICBmb3IgKGxldCBjdXIgPSBub2RlOyBjdXIgJiYgY3VyICE9IGluc2lkZTsgY3VyID0gY3VyLmFzc2lnbmVkU2xvdCB8fCBjdXIucGFyZW50Tm9kZSkge1xuICAgICAgICBpZiAoY3VyLm5vZGVUeXBlID09IDEgJiYgY3VyLmNvbnRlbnRFZGl0YWJsZSA9PSAnZmFsc2UnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiB0b3VjaGVzQ29tcG9zaXRpb24oY2hhbmdlcywgY29tcG9zaXRpb24pIHtcbiAgICBsZXQgdG91Y2hlZCA9IGZhbHNlO1xuICAgIGlmIChjb21wb3NpdGlvbilcbiAgICAgICAgY2hhbmdlcy5pdGVyQ2hhbmdlZFJhbmdlcygoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgY29tcG9zaXRpb24udG8gJiYgdG8gPiBjb21wb3NpdGlvbi5mcm9tKVxuICAgICAgICAgICAgICAgIHRvdWNoZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICByZXR1cm4gdG91Y2hlZDtcbn1cblxuZnVuY3Rpb24gZ3JvdXBBdChzdGF0ZSwgcG9zLCBiaWFzID0gMSkge1xuICAgIGxldCBjYXRlZ29yaXplID0gc3RhdGUuY2hhckNhdGVnb3JpemVyKHBvcyk7XG4gICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyksIGxpbmVQb3MgPSBwb3MgLSBsaW5lLmZyb207XG4gICAgaWYgKGxpbmUubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcyk7XG4gICAgaWYgKGxpbmVQb3MgPT0gMClcbiAgICAgICAgYmlhcyA9IDE7XG4gICAgZWxzZSBpZiAobGluZVBvcyA9PSBsaW5lLmxlbmd0aClcbiAgICAgICAgYmlhcyA9IC0xO1xuICAgIGxldCBmcm9tID0gbGluZVBvcywgdG8gPSBsaW5lUG9zO1xuICAgIGlmIChiaWFzIDwgMClcbiAgICAgICAgZnJvbSA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBsaW5lUG9zLCBmYWxzZSk7XG4gICAgZWxzZVxuICAgICAgICB0byA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBsaW5lUG9zKTtcbiAgICBsZXQgY2F0ID0gY2F0ZWdvcml6ZShsaW5lLnRleHQuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICB3aGlsZSAoZnJvbSA+IDApIHtcbiAgICAgICAgbGV0IHByZXYgPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgZnJvbSwgZmFsc2UpO1xuICAgICAgICBpZiAoY2F0ZWdvcml6ZShsaW5lLnRleHQuc2xpY2UocHJldiwgZnJvbSkpICE9IGNhdClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBmcm9tID0gcHJldjtcbiAgICB9XG4gICAgd2hpbGUgKHRvIDwgbGluZS5sZW5ndGgpIHtcbiAgICAgICAgbGV0IG5leHQgPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgdG8pO1xuICAgICAgICBpZiAoY2F0ZWdvcml6ZShsaW5lLnRleHQuc2xpY2UodG8sIG5leHQpKSAhPSBjYXQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgdG8gPSBuZXh0O1xuICAgIH1cbiAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20gKyBsaW5lLmZyb20sIHRvICsgbGluZS5mcm9tKTtcbn1cbi8vIFNlYXJjaCB0aGUgRE9NIGZvciB0aGUge25vZGUsIG9mZnNldH0gcG9zaXRpb24gY2xvc2VzdCB0byB0aGUgZ2l2ZW5cbi8vIGNvb3JkaW5hdGVzLiBWZXJ5IGluZWZmaWNpZW50IGFuZCBjcnVkZSwgYnV0IGNhbiB1c3VhbGx5IGJlIGF2b2lkZWRcbi8vIGJ5IGNhbGxpbmcgY2FyZXQoUG9zaXRpb258UmFuZ2UpRnJvbVBvaW50IGluc3RlYWQuXG5mdW5jdGlvbiBnZXRkeCh4LCByZWN0KSB7XG4gICAgcmV0dXJuIHJlY3QubGVmdCA+IHggPyByZWN0LmxlZnQgLSB4IDogTWF0aC5tYXgoMCwgeCAtIHJlY3QucmlnaHQpO1xufVxuZnVuY3Rpb24gZ2V0ZHkoeSwgcmVjdCkge1xuICAgIHJldHVybiByZWN0LnRvcCA+IHkgPyByZWN0LnRvcCAtIHkgOiBNYXRoLm1heCgwLCB5IC0gcmVjdC5ib3R0b20pO1xufVxuZnVuY3Rpb24geU92ZXJsYXAoYSwgYikge1xuICAgIHJldHVybiBhLnRvcCA8IGIuYm90dG9tIC0gMSAmJiBhLmJvdHRvbSA+IGIudG9wICsgMTtcbn1cbmZ1bmN0aW9uIHVwVG9wKHJlY3QsIHRvcCkge1xuICAgIHJldHVybiB0b3AgPCByZWN0LnRvcCA/IHsgdG9wLCBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LnJpZ2h0LCBib3R0b206IHJlY3QuYm90dG9tIH0gOiByZWN0O1xufVxuZnVuY3Rpb24gdXBCb3QocmVjdCwgYm90dG9tKSB7XG4gICAgcmV0dXJuIGJvdHRvbSA+IHJlY3QuYm90dG9tID8geyB0b3A6IHJlY3QudG9wLCBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LnJpZ2h0LCBib3R0b20gfSA6IHJlY3Q7XG59XG5mdW5jdGlvbiBkb21Qb3NBdENvb3JkcyhwYXJlbnQsIHgsIHkpIHtcbiAgICBsZXQgY2xvc2VzdCwgY2xvc2VzdFJlY3QsIGNsb3Nlc3RYLCBjbG9zZXN0WSwgY2xvc2VzdE92ZXJsYXAgPSBmYWxzZTtcbiAgICBsZXQgYWJvdmUsIGJlbG93LCBhYm92ZVJlY3QsIGJlbG93UmVjdDtcbiAgICBmb3IgKGxldCBjaGlsZCA9IHBhcmVudC5maXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgICAgICBsZXQgcmVjdHMgPSBjbGllbnRSZWN0c0ZvcihjaGlsZCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gcmVjdHNbaV07XG4gICAgICAgICAgICBpZiAoY2xvc2VzdFJlY3QgJiYgeU92ZXJsYXAoY2xvc2VzdFJlY3QsIHJlY3QpKVxuICAgICAgICAgICAgICAgIHJlY3QgPSB1cFRvcCh1cEJvdChyZWN0LCBjbG9zZXN0UmVjdC5ib3R0b20pLCBjbG9zZXN0UmVjdC50b3ApO1xuICAgICAgICAgICAgbGV0IGR4ID0gZ2V0ZHgoeCwgcmVjdCksIGR5ID0gZ2V0ZHkoeSwgcmVjdCk7XG4gICAgICAgICAgICBpZiAoZHggPT0gMCAmJiBkeSA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5ub2RlVHlwZSA9PSAzID8gZG9tUG9zSW5UZXh0KGNoaWxkLCB4LCB5KSA6IGRvbVBvc0F0Q29vcmRzKGNoaWxkLCB4LCB5KTtcbiAgICAgICAgICAgIGlmICghY2xvc2VzdCB8fCBjbG9zZXN0WSA+IGR5IHx8IGNsb3Nlc3RZID09IGR5ICYmIGNsb3Nlc3RYID4gZHgpIHtcbiAgICAgICAgICAgICAgICBjbG9zZXN0ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgY2xvc2VzdFJlY3QgPSByZWN0O1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RYID0gZHg7XG4gICAgICAgICAgICAgICAgY2xvc2VzdFkgPSBkeTtcbiAgICAgICAgICAgICAgICBsZXQgc2lkZSA9IGR5ID8gKHkgPCByZWN0LnRvcCA/IC0xIDogMSkgOiBkeCA/ICh4IDwgcmVjdC5sZWZ0ID8gLTEgOiAxKSA6IDA7XG4gICAgICAgICAgICAgICAgY2xvc2VzdE92ZXJsYXAgPSAhc2lkZSB8fCAoc2lkZSA+IDAgPyBpIDwgcmVjdHMubGVuZ3RoIC0gMSA6IGkgPiAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkeCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHkgPiByZWN0LmJvdHRvbSAmJiAoIWFib3ZlUmVjdCB8fCBhYm92ZVJlY3QuYm90dG9tIDwgcmVjdC5ib3R0b20pKSB7XG4gICAgICAgICAgICAgICAgICAgIGFib3ZlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGFib3ZlUmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHkgPCByZWN0LnRvcCAmJiAoIWJlbG93UmVjdCB8fCBiZWxvd1JlY3QudG9wID4gcmVjdC50b3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlbG93ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGJlbG93UmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWJvdmVSZWN0ICYmIHlPdmVybGFwKGFib3ZlUmVjdCwgcmVjdCkpIHtcbiAgICAgICAgICAgICAgICBhYm92ZVJlY3QgPSB1cEJvdChhYm92ZVJlY3QsIHJlY3QuYm90dG9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJlbG93UmVjdCAmJiB5T3ZlcmxhcChiZWxvd1JlY3QsIHJlY3QpKSB7XG4gICAgICAgICAgICAgICAgYmVsb3dSZWN0ID0gdXBUb3AoYmVsb3dSZWN0LCByZWN0LnRvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFib3ZlUmVjdCAmJiBhYm92ZVJlY3QuYm90dG9tID49IHkpIHtcbiAgICAgICAgY2xvc2VzdCA9IGFib3ZlO1xuICAgICAgICBjbG9zZXN0UmVjdCA9IGFib3ZlUmVjdDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYmVsb3dSZWN0ICYmIGJlbG93UmVjdC50b3AgPD0geSkge1xuICAgICAgICBjbG9zZXN0ID0gYmVsb3c7XG4gICAgICAgIGNsb3Nlc3RSZWN0ID0gYmVsb3dSZWN0O1xuICAgIH1cbiAgICBpZiAoIWNsb3Nlc3QpXG4gICAgICAgIHJldHVybiB7IG5vZGU6IHBhcmVudCwgb2Zmc2V0OiAwIH07XG4gICAgbGV0IGNsaXBYID0gTWF0aC5tYXgoY2xvc2VzdFJlY3QubGVmdCwgTWF0aC5taW4oY2xvc2VzdFJlY3QucmlnaHQsIHgpKTtcbiAgICBpZiAoY2xvc2VzdC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICByZXR1cm4gZG9tUG9zSW5UZXh0KGNsb3Nlc3QsIGNsaXBYLCB5KTtcbiAgICBpZiAoY2xvc2VzdE92ZXJsYXAgJiYgY2xvc2VzdC5jb250ZW50RWRpdGFibGUgIT0gXCJmYWxzZVwiKVxuICAgICAgICByZXR1cm4gZG9tUG9zQXRDb29yZHMoY2xvc2VzdCwgY2xpcFgsIHkpO1xuICAgIGxldCBvZmZzZXQgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHBhcmVudC5jaGlsZE5vZGVzLCBjbG9zZXN0KSArXG4gICAgICAgICh4ID49IChjbG9zZXN0UmVjdC5sZWZ0ICsgY2xvc2VzdFJlY3QucmlnaHQpIC8gMiA/IDEgOiAwKTtcbiAgICByZXR1cm4geyBub2RlOiBwYXJlbnQsIG9mZnNldCB9O1xufVxuZnVuY3Rpb24gZG9tUG9zSW5UZXh0KG5vZGUsIHgsIHkpIHtcbiAgICBsZXQgbGVuID0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xuICAgIGxldCBjbG9zZXN0T2Zmc2V0ID0gLTEsIGNsb3Nlc3REWSA9IDFlOSwgZ2VuZXJhbFNpZGUgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbGV0IHJlY3RzID0gdGV4dFJhbmdlKG5vZGUsIGksIGkgKyAxKS5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJlY3RzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW2pdO1xuICAgICAgICAgICAgaWYgKHJlY3QudG9wID09IHJlY3QuYm90dG9tKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFnZW5lcmFsU2lkZSlcbiAgICAgICAgICAgICAgICBnZW5lcmFsU2lkZSA9IHggLSByZWN0LmxlZnQ7XG4gICAgICAgICAgICBsZXQgZHkgPSAocmVjdC50b3AgPiB5ID8gcmVjdC50b3AgLSB5IDogeSAtIHJlY3QuYm90dG9tKSAtIDE7XG4gICAgICAgICAgICBpZiAocmVjdC5sZWZ0IC0gMSA8PSB4ICYmIHJlY3QucmlnaHQgKyAxID49IHggJiYgZHkgPCBjbG9zZXN0RFkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmlnaHQgPSB4ID49IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIsIGFmdGVyID0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKGJyb3dzZXIuY2hyb21lIHx8IGJyb3dzZXIuZ2Vja28pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIFJUTCBvbiBicm93c2VycyB0aGF0IHN1cHBvcnQgZ2V0dGluZyBjbGllbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjdHMgZm9yIGVtcHR5IHJhbmdlcy5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3RCZWZvcmUgPSB0ZXh0UmFuZ2Uobm9kZSwgaSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN0QmVmb3JlLmxlZnQgPT0gcmVjdC5yaWdodClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyID0gIXJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZHkgPD0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbm9kZSwgb2Zmc2V0OiBpICsgKGFmdGVyID8gMSA6IDApIH07XG4gICAgICAgICAgICAgICAgY2xvc2VzdE9mZnNldCA9IGkgKyAoYWZ0ZXIgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgY2xvc2VzdERZID0gZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbm9kZSwgb2Zmc2V0OiBjbG9zZXN0T2Zmc2V0ID4gLTEgPyBjbG9zZXN0T2Zmc2V0IDogZ2VuZXJhbFNpZGUgPiAwID8gbm9kZS5ub2RlVmFsdWUubGVuZ3RoIDogMCB9O1xufVxuZnVuY3Rpb24gcG9zQXRDb29yZHModmlldywgY29vcmRzLCBwcmVjaXNlLCBiaWFzID0gLTEpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGxldCBjb250ZW50ID0gdmlldy5jb250ZW50RE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBkb2NUb3AgPSBjb250ZW50LnRvcCArIHZpZXcudmlld1N0YXRlLnBhZGRpbmdUb3A7XG4gICAgbGV0IGJsb2NrLCB7IGRvY0hlaWdodCB9ID0gdmlldy52aWV3U3RhdGU7XG4gICAgbGV0IHsgeCwgeSB9ID0gY29vcmRzLCB5T2Zmc2V0ID0geSAtIGRvY1RvcDtcbiAgICBpZiAoeU9mZnNldCA8IDApXG4gICAgICAgIHJldHVybiAwO1xuICAgIGlmICh5T2Zmc2V0ID4gZG9jSGVpZ2h0KVxuICAgICAgICByZXR1cm4gdmlldy5zdGF0ZS5kb2MubGVuZ3RoO1xuICAgIC8vIFNjYW4gZm9yIGEgdGV4dCBibG9jayBuZWFyIHRoZSBxdWVyaWVkIHkgcG9zaXRpb25cbiAgICBmb3IgKGxldCBoYWxmTGluZSA9IHZpZXcudmlld1N0YXRlLmhlaWdodE9yYWNsZS50ZXh0SGVpZ2h0IC8gMiwgYm91bmNlZCA9IGZhbHNlOzspIHtcbiAgICAgICAgYmxvY2sgPSB2aWV3LmVsZW1lbnRBdEhlaWdodCh5T2Zmc2V0KTtcbiAgICAgICAgaWYgKGJsb2NrLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgLy8gTW92ZSB0aGUgeSBwb3NpdGlvbiBvdXQgb2YgdGhpcyBibG9ja1xuICAgICAgICAgICAgeU9mZnNldCA9IGJpYXMgPiAwID8gYmxvY2suYm90dG9tICsgaGFsZkxpbmUgOiBibG9jay50b3AgLSBoYWxmTGluZTtcbiAgICAgICAgICAgIGlmICh5T2Zmc2V0ID49IDAgJiYgeU9mZnNldCA8PSBkb2NIZWlnaHQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZG9jdW1lbnQgY29uc2lzdHMgZW50aXJlbHkgb2YgcmVwbGFjZWQgd2lkZ2V0cywgd2VcbiAgICAgICAgICAgIC8vIHdvbid0IGZpbmQgYSB0ZXh0IGJsb2NrLCBzbyByZXR1cm4gMFxuICAgICAgICAgICAgaWYgKGJvdW5jZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWNpc2UgPyBudWxsIDogMDtcbiAgICAgICAgICAgIGJvdW5jZWQgPSB0cnVlO1xuICAgICAgICAgICAgYmlhcyA9IC1iaWFzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHkgPSBkb2NUb3AgKyB5T2Zmc2V0O1xuICAgIGxldCBsaW5lU3RhcnQgPSBibG9jay5mcm9tO1xuICAgIC8vIElmIHRoaXMgaXMgb3V0c2lkZSBvZiB0aGUgcmVuZGVyZWQgdmlld3BvcnQsIHdlIGNhbid0IGRldGVybWluZSBhIHBvc2l0aW9uXG4gICAgaWYgKGxpbmVTdGFydCA8IHZpZXcudmlld3BvcnQuZnJvbSlcbiAgICAgICAgcmV0dXJuIHZpZXcudmlld3BvcnQuZnJvbSA9PSAwID8gMCA6IHByZWNpc2UgPyBudWxsIDogcG9zQXRDb29yZHNJbXByZWNpc2UodmlldywgY29udGVudCwgYmxvY2ssIHgsIHkpO1xuICAgIGlmIChsaW5lU3RhcnQgPiB2aWV3LnZpZXdwb3J0LnRvKVxuICAgICAgICByZXR1cm4gdmlldy52aWV3cG9ydC50byA9PSB2aWV3LnN0YXRlLmRvYy5sZW5ndGggPyB2aWV3LnN0YXRlLmRvYy5sZW5ndGggOlxuICAgICAgICAgICAgcHJlY2lzZSA/IG51bGwgOiBwb3NBdENvb3Jkc0ltcHJlY2lzZSh2aWV3LCBjb250ZW50LCBibG9jaywgeCwgeSk7XG4gICAgLy8gUHJlZmVyIFNoYWRvd1Jvb3RPckRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQgaWYgcHJlc2VudCwgZmFsbCBiYWNrIHRvIGRvY3VtZW50IGlmIG5vdFxuICAgIGxldCBkb2MgPSB2aWV3LmRvbS5vd25lckRvY3VtZW50O1xuICAgIGxldCByb290ID0gdmlldy5yb290LmVsZW1lbnRGcm9tUG9pbnQgPyB2aWV3LnJvb3QgOiBkb2M7XG4gICAgbGV0IGVsZW1lbnQgPSByb290LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgaWYgKGVsZW1lbnQgJiYgIXZpZXcuY29udGVudERPTS5jb250YWlucyhlbGVtZW50KSlcbiAgICAgICAgZWxlbWVudCA9IG51bGw7XG4gICAgLy8gSWYgdGhlIGVsZW1lbnQgaXMgdW5leHBlY3RlZCwgY2xpcCB4IGF0IHRoZSBzaWRlcyBvZiB0aGUgY29udGVudCBhcmVhIGFuZCB0cnkgYWdhaW5cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgeCA9IE1hdGgubWF4KGNvbnRlbnQubGVmdCArIDEsIE1hdGgubWluKGNvbnRlbnQucmlnaHQgLSAxLCB4KSk7XG4gICAgICAgIGVsZW1lbnQgPSByb290LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgIGlmIChlbGVtZW50ICYmICF2aWV3LmNvbnRlbnRET00uY29udGFpbnMoZWxlbWVudCkpXG4gICAgICAgICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gICAgLy8gVGhlcmUncyB2aXNpYmxlIGVkaXRvciBjb250ZW50IHVuZGVyIHRoZSBwb2ludCwgc28gd2UgY2FuIHRyeVxuICAgIC8vIHVzaW5nIGNhcmV0KFBvc2l0aW9ufFJhbmdlKUZyb21Qb2ludCBhcyBhIHNob3J0Y3V0XG4gICAgbGV0IG5vZGUsIG9mZnNldCA9IC0xO1xuICAgIGlmIChlbGVtZW50ICYmICgoX2EgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdChlbGVtZW50KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzRWRpdGFibGUpICE9IGZhbHNlKSB7XG4gICAgICAgIGlmIChkb2MuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCkge1xuICAgICAgICAgICAgbGV0IHBvcyA9IGRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50KHgsIHkpO1xuICAgICAgICAgICAgaWYgKHBvcylcbiAgICAgICAgICAgICAgICAoeyBvZmZzZXROb2RlOiBub2RlLCBvZmZzZXQgfSA9IHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG9jLmNhcmV0UmFuZ2VGcm9tUG9pbnQpIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IGRvYy5jYXJldFJhbmdlRnJvbVBvaW50KHgsIHkpO1xuICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgKHsgc3RhcnRDb250YWluZXI6IG5vZGUsIHN0YXJ0T2Zmc2V0OiBvZmZzZXQgfSA9IHJhbmdlKTtcbiAgICAgICAgICAgICAgICBpZiAoIXZpZXcuY29udGVudERPTS5jb250YWlucyhub2RlKSB8fFxuICAgICAgICAgICAgICAgICAgICBicm93c2VyLnNhZmFyaSAmJiBpc1N1c3BpY2lvdXNTYWZhcmlDYXJldFJlc3VsdChub2RlLCBvZmZzZXQsIHgpIHx8XG4gICAgICAgICAgICAgICAgICAgIGJyb3dzZXIuY2hyb21lICYmIGlzU3VzcGljaW91c0Nocm9tZUNhcmV0UmVzdWx0KG5vZGUsIG9mZnNldCwgeCkpXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTm8gbHVjaywgZG8gb3VyIG93biAocG90ZW50aWFsbHkgZXhwZW5zaXZlKSBzZWFyY2hcbiAgICBpZiAoIW5vZGUgfHwgIXZpZXcuZG9jVmlldy5kb20uY29udGFpbnMobm9kZSkpIHtcbiAgICAgICAgbGV0IGxpbmUgPSBMaW5lVmlldy5maW5kKHZpZXcuZG9jVmlldywgbGluZVN0YXJ0KTtcbiAgICAgICAgaWYgKCFsaW5lKVxuICAgICAgICAgICAgcmV0dXJuIHlPZmZzZXQgPiBibG9jay50b3AgKyBibG9jay5oZWlnaHQgLyAyID8gYmxvY2sudG8gOiBibG9jay5mcm9tO1xuICAgICAgICAoeyBub2RlLCBvZmZzZXQgfSA9IGRvbVBvc0F0Q29vcmRzKGxpbmUuZG9tLCB4LCB5KSk7XG4gICAgfVxuICAgIGxldCBuZWFyZXN0ID0gdmlldy5kb2NWaWV3Lm5lYXJlc3Qobm9kZSk7XG4gICAgaWYgKCFuZWFyZXN0KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAobmVhcmVzdC5pc1dpZGdldCAmJiAoKF9iID0gbmVhcmVzdC5kb20pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5ub2RlVHlwZSkgPT0gMSkge1xuICAgICAgICBsZXQgcmVjdCA9IG5lYXJlc3QuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4gY29vcmRzLnkgPCByZWN0LnRvcCB8fCBjb29yZHMueSA8PSByZWN0LmJvdHRvbSAmJiBjb29yZHMueCA8PSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyXG4gICAgICAgICAgICA/IG5lYXJlc3QucG9zQXRTdGFydCA6IG5lYXJlc3QucG9zQXRFbmQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmVhcmVzdC5sb2NhbFBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KSArIG5lYXJlc3QucG9zQXRTdGFydDtcbiAgICB9XG59XG5mdW5jdGlvbiBwb3NBdENvb3Jkc0ltcHJlY2lzZSh2aWV3LCBjb250ZW50UmVjdCwgYmxvY2ssIHgsIHkpIHtcbiAgICBsZXQgaW50byA9IE1hdGgucm91bmQoKHggLSBjb250ZW50UmVjdC5sZWZ0KSAqIHZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoKTtcbiAgICBpZiAodmlldy5saW5lV3JhcHBpbmcgJiYgYmxvY2suaGVpZ2h0ID4gdmlldy5kZWZhdWx0TGluZUhlaWdodCAqIDEuNSkge1xuICAgICAgICBsZXQgdGV4dEhlaWdodCA9IHZpZXcudmlld1N0YXRlLmhlaWdodE9yYWNsZS50ZXh0SGVpZ2h0O1xuICAgICAgICBsZXQgbGluZSA9IE1hdGguZmxvb3IoKHkgLSBibG9jay50b3AgLSAodmlldy5kZWZhdWx0TGluZUhlaWdodCAtIHRleHRIZWlnaHQpICogMC41KSAvIHRleHRIZWlnaHQpO1xuICAgICAgICBpbnRvICs9IGxpbmUgKiB2aWV3LnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUubGluZUxlbmd0aDtcbiAgICB9XG4gICAgbGV0IGNvbnRlbnQgPSB2aWV3LnN0YXRlLnNsaWNlRG9jKGJsb2NrLmZyb20sIGJsb2NrLnRvKTtcbiAgICByZXR1cm4gYmxvY2suZnJvbSArIGZpbmRDb2x1bW4oY29udGVudCwgaW50bywgdmlldy5zdGF0ZS50YWJTaXplKTtcbn1cbi8vIEluIGNhc2Ugb2YgYSBoaWdoIGxpbmUgaGVpZ2h0LCBTYWZhcmkncyBjYXJldFJhbmdlRnJvbVBvaW50IHRyZWF0c1xuLy8gdGhlIHNwYWNlIGJldHdlZW4gbGluZXMgYXMgYmVsb25naW5nIHRvIHRoZSBsYXN0IGNoYXJhY3RlciBvZiB0aGVcbi8vIGxpbmUgYmVmb3JlLiBUaGlzIGlzIHVzZWQgdG8gZGV0ZWN0IHN1Y2ggYSByZXN1bHQgc28gdGhhdCBpdCBjYW4gYmVcbi8vIGlnbm9yZWQgKGlzc3VlICM0MDEpLlxuZnVuY3Rpb24gaXNTdXNwaWNpb3VzU2FmYXJpQ2FyZXRSZXN1bHQobm9kZSwgb2Zmc2V0LCB4KSB7XG4gICAgbGV0IGxlbjtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAzIHx8IG9mZnNldCAhPSAobGVuID0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IG5leHQgPSBub2RlLm5leHRTaWJsaW5nOyBuZXh0OyBuZXh0ID0gbmV4dC5uZXh0U2libGluZylcbiAgICAgICAgaWYgKG5leHQubm9kZVR5cGUgIT0gMSB8fCBuZXh0Lm5vZGVOYW1lICE9IFwiQlJcIilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGV4dFJhbmdlKG5vZGUsIGxlbiAtIDEsIGxlbikuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCA+IHg7XG59XG4vLyBDaHJvbWUgd2lsbCBtb3ZlIHBvc2l0aW9ucyBiZXR3ZWVuIGxpbmVzIHRvIHRoZSBzdGFydCBvZiB0aGUgbmV4dCBsaW5lXG5mdW5jdGlvbiBpc1N1c3BpY2lvdXNDaHJvbWVDYXJldFJlc3VsdChub2RlLCBvZmZzZXQsIHgpIHtcbiAgICBpZiAob2Zmc2V0ICE9IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBjdXIgPSBub2RlOzspIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQubm9kZVR5cGUgIT0gMSB8fCBwYXJlbnQuZmlyc3RDaGlsZCAhPSBjdXIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwYXJlbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiY20tbGluZVwiKSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjdXIgPSBwYXJlbnQ7XG4gICAgfVxuICAgIGxldCByZWN0ID0gbm9kZS5ub2RlVHlwZSA9PSAxID8gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICA6IHRleHRSYW5nZShub2RlLCAwLCBNYXRoLm1heChub2RlLm5vZGVWYWx1ZS5sZW5ndGgsIDEpKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4geCAtIHJlY3QubGVmdCA+IDU7XG59XG5mdW5jdGlvbiBibG9ja0F0KHZpZXcsIHBvcykge1xuICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdChwb3MpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGxpbmUudHlwZSkpXG4gICAgICAgIGZvciAobGV0IGwgb2YgbGluZS50eXBlKSB7XG4gICAgICAgICAgICBpZiAobC50byA+IHBvcyB8fCBsLnRvID09IHBvcyAmJiAobC50byA9PSBsaW5lLnRvIHx8IGwudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGw7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbGluZTtcbn1cbmZ1bmN0aW9uIG1vdmVUb0xpbmVCb3VuZGFyeSh2aWV3LCBzdGFydCwgZm9yd2FyZCwgaW5jbHVkZVdyYXApIHtcbiAgICBsZXQgbGluZSA9IGJsb2NrQXQodmlldywgc3RhcnQuaGVhZCk7XG4gICAgbGV0IGNvb3JkcyA9ICFpbmNsdWRlV3JhcCB8fCBsaW5lLnR5cGUgIT0gQmxvY2tUeXBlLlRleHQgfHwgISh2aWV3LmxpbmVXcmFwcGluZyB8fCBsaW5lLndpZGdldExpbmVCcmVha3MpID8gbnVsbFxuICAgICAgICA6IHZpZXcuY29vcmRzQXRQb3Moc3RhcnQuYXNzb2MgPCAwICYmIHN0YXJ0LmhlYWQgPiBsaW5lLmZyb20gPyBzdGFydC5oZWFkIC0gMSA6IHN0YXJ0LmhlYWQpO1xuICAgIGlmIChjb29yZHMpIHtcbiAgICAgICAgbGV0IGVkaXRvclJlY3QgPSB2aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IGRpcmVjdGlvbiA9IHZpZXcudGV4dERpcmVjdGlvbkF0KGxpbmUuZnJvbSk7XG4gICAgICAgIGxldCBwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZm9yd2FyZCA9PSAoZGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFIpID8gZWRpdG9yUmVjdC5yaWdodCAtIDEgOiBlZGl0b3JSZWN0LmxlZnQgKyAxLFxuICAgICAgICAgICAgeTogKGNvb3Jkcy50b3AgKyBjb29yZHMuYm90dG9tKSAvIDIgfSk7XG4gICAgICAgIGlmIChwb3MgIT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcywgZm9yd2FyZCA/IC0xIDogMSk7XG4gICAgfVxuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZvcndhcmQgPyBsaW5lLnRvIDogbGluZS5mcm9tLCBmb3J3YXJkID8gLTEgOiAxKTtcbn1cbmZ1bmN0aW9uIG1vdmVCeUNoYXIodmlldywgc3RhcnQsIGZvcndhcmQsIGJ5KSB7XG4gICAgbGV0IGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoc3RhcnQuaGVhZCksIHNwYW5zID0gdmlldy5iaWRpU3BhbnMobGluZSk7XG4gICAgbGV0IGRpcmVjdGlvbiA9IHZpZXcudGV4dERpcmVjdGlvbkF0KGxpbmUuZnJvbSk7XG4gICAgZm9yIChsZXQgY3VyID0gc3RhcnQsIGNoZWNrID0gbnVsbDs7KSB7XG4gICAgICAgIGxldCBuZXh0ID0gbW92ZVZpc3VhbGx5KGxpbmUsIHNwYW5zLCBkaXJlY3Rpb24sIGN1ciwgZm9yd2FyZCksIGNoYXIgPSBtb3ZlZE92ZXI7XG4gICAgICAgIGlmICghbmV4dCkge1xuICAgICAgICAgICAgaWYgKGxpbmUubnVtYmVyID09IChmb3J3YXJkID8gdmlldy5zdGF0ZS5kb2MubGluZXMgOiAxKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICAgICAgY2hhciA9IFwiXFxuXCI7XG4gICAgICAgICAgICBsaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZShsaW5lLm51bWJlciArIChmb3J3YXJkID8gMSA6IC0xKSk7XG4gICAgICAgICAgICBzcGFucyA9IHZpZXcuYmlkaVNwYW5zKGxpbmUpO1xuICAgICAgICAgICAgbmV4dCA9IHZpZXcudmlzdWFsTGluZVNpZGUobGluZSwgIWZvcndhcmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hlY2spIHtcbiAgICAgICAgICAgIGlmICghYnkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICBjaGVjayA9IGJ5KGNoYXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFjaGVjayhjaGFyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgfVxuICAgICAgICBjdXIgPSBuZXh0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ5R3JvdXAodmlldywgcG9zLCBzdGFydCkge1xuICAgIGxldCBjYXRlZ29yaXplID0gdmlldy5zdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocG9zKTtcbiAgICBsZXQgY2F0ID0gY2F0ZWdvcml6ZShzdGFydCk7XG4gICAgcmV0dXJuIChuZXh0KSA9PiB7XG4gICAgICAgIGxldCBuZXh0Q2F0ID0gY2F0ZWdvcml6ZShuZXh0KTtcbiAgICAgICAgaWYgKGNhdCA9PSBDaGFyQ2F0ZWdvcnkuU3BhY2UpXG4gICAgICAgICAgICBjYXQgPSBuZXh0Q2F0O1xuICAgICAgICByZXR1cm4gY2F0ID09IG5leHRDYXQ7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1vdmVWZXJ0aWNhbGx5KHZpZXcsIHN0YXJ0LCBmb3J3YXJkLCBkaXN0YW5jZSkge1xuICAgIGxldCBzdGFydFBvcyA9IHN0YXJ0LmhlYWQsIGRpciA9IGZvcndhcmQgPyAxIDogLTE7XG4gICAgaWYgKHN0YXJ0UG9zID09IChmb3J3YXJkID8gdmlldy5zdGF0ZS5kb2MubGVuZ3RoIDogMCkpXG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHN0YXJ0UG9zLCBzdGFydC5hc3NvYyk7XG4gICAgbGV0IGdvYWwgPSBzdGFydC5nb2FsQ29sdW1uLCBzdGFydFk7XG4gICAgbGV0IHJlY3QgPSB2aWV3LmNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHN0YXJ0Q29vcmRzID0gdmlldy5jb29yZHNBdFBvcyhzdGFydFBvcywgc3RhcnQuYXNzb2MgfHwgLTEpLCBkb2NUb3AgPSB2aWV3LmRvY3VtZW50VG9wO1xuICAgIGlmIChzdGFydENvb3Jkcykge1xuICAgICAgICBpZiAoZ29hbCA9PSBudWxsKVxuICAgICAgICAgICAgZ29hbCA9IHN0YXJ0Q29vcmRzLmxlZnQgLSByZWN0LmxlZnQ7XG4gICAgICAgIHN0YXJ0WSA9IGRpciA8IDAgPyBzdGFydENvb3Jkcy50b3AgOiBzdGFydENvb3Jkcy5ib3R0b207XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgbGluZSA9IHZpZXcudmlld1N0YXRlLmxpbmVCbG9ja0F0KHN0YXJ0UG9zKTtcbiAgICAgICAgaWYgKGdvYWwgPT0gbnVsbClcbiAgICAgICAgICAgIGdvYWwgPSBNYXRoLm1pbihyZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0LCB2aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCAqIChzdGFydFBvcyAtIGxpbmUuZnJvbSkpO1xuICAgICAgICBzdGFydFkgPSAoZGlyIDwgMCA/IGxpbmUudG9wIDogbGluZS5ib3R0b20pICsgZG9jVG9wO1xuICAgIH1cbiAgICBsZXQgcmVzb2x2ZWRHb2FsID0gcmVjdC5sZWZ0ICsgZ29hbDtcbiAgICBsZXQgZGlzdCA9IGRpc3RhbmNlICE9PSBudWxsICYmIGRpc3RhbmNlICE9PSB2b2lkIDAgPyBkaXN0YW5jZSA6ICh2aWV3LnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUudGV4dEhlaWdodCA+PiAxKTtcbiAgICBmb3IgKGxldCBleHRyYSA9IDA7OyBleHRyYSArPSAxMCkge1xuICAgICAgICBsZXQgY3VyWSA9IHN0YXJ0WSArIChkaXN0ICsgZXh0cmEpICogZGlyO1xuICAgICAgICBsZXQgcG9zID0gcG9zQXRDb29yZHModmlldywgeyB4OiByZXNvbHZlZEdvYWwsIHk6IGN1clkgfSwgZmFsc2UsIGRpcik7XG4gICAgICAgIGlmIChjdXJZIDwgcmVjdC50b3AgfHwgY3VyWSA+IHJlY3QuYm90dG9tIHx8IChkaXIgPCAwID8gcG9zIDwgc3RhcnRQb3MgOiBwb3MgPiBzdGFydFBvcykpIHtcbiAgICAgICAgICAgIGxldCBjaGFyUmVjdCA9IHZpZXcuZG9jVmlldy5jb29yZHNGb3JDaGFyKHBvcyk7XG4gICAgICAgICAgICBsZXQgYXNzb2MgPSAhY2hhclJlY3QgfHwgY3VyWSA8IGNoYXJSZWN0LnRvcCA/IC0xIDogMTtcbiAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcywgYXNzb2MsIHVuZGVmaW5lZCwgZ29hbCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBza2lwQXRvbWljUmFuZ2VzKGF0b21zLCBwb3MsIGJpYXMpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBtb3ZlZCA9IDA7XG4gICAgICAgIGZvciAobGV0IHNldCBvZiBhdG9tcykge1xuICAgICAgICAgICAgc2V0LmJldHdlZW4ocG9zIC0gMSwgcG9zICsgMSwgKGZyb20sIHRvLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPiBmcm9tICYmIHBvcyA8IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaWRlID0gbW92ZWQgfHwgYmlhcyB8fCAocG9zIC0gZnJvbSA8IHRvIC0gcG9zID8gLTEgOiAxKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gc2lkZSA8IDAgPyBmcm9tIDogdG87XG4gICAgICAgICAgICAgICAgICAgIG1vdmVkID0gc2lkZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vdmVkKVxuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG59XG5mdW5jdGlvbiBza2lwQXRvbXModmlldywgb2xkUG9zLCBwb3MpIHtcbiAgICBsZXQgbmV3UG9zID0gc2tpcEF0b21pY1Jhbmdlcyh2aWV3LnN0YXRlLmZhY2V0KGF0b21pY1JhbmdlcykubWFwKGYgPT4gZih2aWV3KSksIHBvcy5mcm9tLCBvbGRQb3MuaGVhZCA+IHBvcy5mcm9tID8gLTEgOiAxKTtcbiAgICByZXR1cm4gbmV3UG9zID09IHBvcy5mcm9tID8gcG9zIDogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihuZXdQb3MsIG5ld1BvcyA8IHBvcy5mcm9tID8gMSA6IC0xKTtcbn1cblxuLy8gVGhpcyB3aWxsIGFsc28gYmUgd2hlcmUgZHJhZ2dpbmcgaW5mbyBhbmQgc3VjaCBnb2VzXG5jbGFzcyBJbnB1dFN0YXRlIHtcbiAgICBzZXRTZWxlY3Rpb25PcmlnaW4ob3JpZ2luKSB7XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvbk9yaWdpbiA9IG9yaWdpbjtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uVGltZSA9IERhdGUubm93KCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5sYXN0S2V5Q29kZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdEtleVRpbWUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RUb3VjaFRpbWUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RGb2N1c1RpbWUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RTY3JvbGxUb3AgPSAwO1xuICAgICAgICB0aGlzLmxhc3RTY3JvbGxMZWZ0ID0gMDtcbiAgICAgICAgLy8gT24gaU9TLCBzb21lIGtleXMgbmVlZCB0byBoYXZlIHRoZWlyIGRlZmF1bHQgYmVoYXZpb3IgaGFwcGVuXG4gICAgICAgIC8vIChhZnRlciB3aGljaCB3ZSByZXRyb2FjdGl2ZWx5IGhhbmRsZSB0aGVtIGFuZCByZXNldCB0aGUgRE9NKSB0b1xuICAgICAgICAvLyBhdm9pZCBtZXNzaW5nIHVwIHRoZSB2aXJ0dWFsIGtleWJvYXJkIHN0YXRlLlxuICAgICAgICB0aGlzLnBlbmRpbmdJT1NLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvbk9yaWdpbiA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvblRpbWUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RFc2NQcmVzcyA9IDA7XG4gICAgICAgIHRoaXMubGFzdENvbnRleHRNZW51ID0gMDtcbiAgICAgICAgdGhpcy5zY3JvbGxIYW5kbGVycyA9IFtdO1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgLy8gLTEgbWVhbnMgbm90IGluIGEgY29tcG9zaXRpb24uIE90aGVyd2lzZSwgdGhpcyBjb3VudHMgdGhlIG51bWJlclxuICAgICAgICAvLyBvZiBjaGFuZ2VzIG1hZGUgZHVyaW5nIHRoZSBjb21wb3NpdGlvbi4gVGhlIGNvdW50IGlzIHVzZWQgdG9cbiAgICAgICAgLy8gYXZvaWQgdHJlYXRpbmcgdGhlIHN0YXJ0IHN0YXRlIG9mIHRoZSBjb21wb3NpdGlvbiwgYmVmb3JlIGFueVxuICAgICAgICAvLyBjaGFuZ2VzIGhhdmUgYmVlbiBtYWRlLCBhcyBwYXJ0IG9mIHRoZSBjb21wb3NpdGlvbi5cbiAgICAgICAgdGhpcy5jb21wb3NpbmcgPSAtMTtcbiAgICAgICAgLy8gVHJhY2tzIHdoZXRoZXIgdGhlIG5leHQgY2hhbmdlIHNob3VsZCBiZSBtYXJrZWQgYXMgc3RhcnRpbmcgdGhlXG4gICAgICAgIC8vIGNvbXBvc2l0aW9uIChudWxsIG1lYW5zIG5vIGNvbXBvc2l0aW9uLCB0cnVlIG1lYW5zIG5leHQgaXMgdGhlXG4gICAgICAgIC8vIGZpcnN0LCBmYWxzZSBtZWFucyBmaXJzdCBoYXMgYWxyZWFkeSBiZWVuIG1hcmtlZCBmb3IgdGhpc1xuICAgICAgICAvLyBjb21wb3NpdGlvbilcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID0gbnVsbDtcbiAgICAgICAgLy8gRW5kIHRpbWUgb2YgdGhlIHByZXZpb3VzIGNvbXBvc2l0aW9uXG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25FbmRlZEF0ID0gMDtcbiAgICAgICAgLy8gVXNlZCBpbiBhIGtsdWRnZSB0byBkZXRlY3Qgd2hlbiBhbiBFbnRlciBrZXlwcmVzcyBzaG91bGQgYmVcbiAgICAgICAgLy8gY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBjb21wb3NpdGlvbiBvbiBTYWZhcmksIHdoaWNoIGZpcmVzIGV2ZW50c1xuICAgICAgICAvLyBpbiB0aGUgd3Jvbmcgb3JkZXJcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvblBlbmRpbmdLZXkgPSBmYWxzZTtcbiAgICAgICAgLy8gVXNlZCB0byBjYXRlZ29yaXplIGNoYW5nZXMgYXMgcGFydCBvZiBhIGNvbXBvc2l0aW9uLCBldmVuIHdoZW5cbiAgICAgICAgLy8gdGhlIG11dGF0aW9uIGV2ZW50cyBmaXJlIHNob3J0bHkgYWZ0ZXIgdGhlIGNvbXBvc2l0aW9uZW5kIGV2ZW50XG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubW91c2VTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAvLyBXaGVuIGEgZHJhZyBmcm9tIHRoZSBlZGl0b3IgaXMgYWN0aXZlLCB0aGlzIHBvaW50cyBhdCB0aGUgcmFuZ2VcbiAgICAgICAgLy8gYmVpbmcgZHJhZ2dlZC5cbiAgICAgICAgdGhpcy5kcmFnZ2VkQ29udGVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlRXZlbnQgPSB0aGlzLmhhbmRsZUV2ZW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubm90aWZpZWRGb2N1c2VkID0gdmlldy5oYXNGb2N1cztcbiAgICAgICAgLy8gT24gU2FmYXJpIGFkZGluZyBhbiBpbnB1dCBldmVudCBoYW5kbGVyIHNvbWVob3cgcHJldmVudHMgYW5cbiAgICAgICAgLy8gaXNzdWUgd2hlcmUgdGhlIGNvbXBvc2l0aW9uIHZhbmlzaGVzIHdoZW4geW91IHByZXNzIGVudGVyLlxuICAgICAgICBpZiAoYnJvd3Nlci5zYWZhcmkpXG4gICAgICAgICAgICB2aWV3LmNvbnRlbnRET00uYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsICgpID0+IG51bGwpO1xuICAgICAgICBpZiAoYnJvd3Nlci5nZWNrbylcbiAgICAgICAgICAgIGZpcmVmb3hDb3B5Q3V0SGFjayh2aWV3LmNvbnRlbnRET00ub3duZXJEb2N1bWVudCk7XG4gICAgfVxuICAgIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmICghZXZlbnRCZWxvbmdzVG9FZGl0b3IodGhpcy52aWV3LCBldmVudCkgfHwgdGhpcy5pZ25vcmVEdXJpbmdDb21wb3NpdGlvbihldmVudCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChldmVudC50eXBlID09IFwia2V5ZG93blwiICYmIHRoaXMua2V5ZG93bihldmVudCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucnVuSGFuZGxlcnMoZXZlbnQudHlwZSwgZXZlbnQpO1xuICAgIH1cbiAgICBydW5IYW5kbGVycyh0eXBlLCBldmVudCkge1xuICAgICAgICBsZXQgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW3R5cGVdO1xuICAgICAgICBpZiAoaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IG9ic2VydmVyIG9mIGhhbmRsZXJzLm9ic2VydmVycylcbiAgICAgICAgICAgICAgICBvYnNlcnZlcih0aGlzLnZpZXcsIGV2ZW50KTtcbiAgICAgICAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgaGFuZGxlcnMuaGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIodGhpcy52aWV3LCBldmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVuc3VyZUhhbmRsZXJzKHBsdWdpbnMpIHtcbiAgICAgICAgbGV0IGhhbmRsZXJzID0gY29tcHV0ZUhhbmRsZXJzKHBsdWdpbnMpLCBwcmV2ID0gdGhpcy5oYW5kbGVycywgZG9tID0gdGhpcy52aWV3LmNvbnRlbnRET007XG4gICAgICAgIGZvciAobGV0IHR5cGUgaW4gaGFuZGxlcnMpXG4gICAgICAgICAgICBpZiAodHlwZSAhPSBcInNjcm9sbFwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhc3NpdmUgPSAhaGFuZGxlcnNbdHlwZV0uaGFuZGxlcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBleGlzdHMgPSBwcmV2W3R5cGVdO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdHMgJiYgcGFzc2l2ZSAhPSAhZXhpc3RzLmhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLmhhbmRsZUV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFleGlzdHMpXG4gICAgICAgICAgICAgICAgICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHRoaXMuaGFuZGxlRXZlbnQsIHsgcGFzc2l2ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBwcmV2KVxuICAgICAgICAgICAgaWYgKHR5cGUgIT0gXCJzY3JvbGxcIiAmJiAhaGFuZGxlcnNbdHlwZV0pXG4gICAgICAgICAgICAgICAgZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5oYW5kbGVFdmVudCk7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBoYW5kbGVycztcbiAgICB9XG4gICAga2V5ZG93bihldmVudCkge1xuICAgICAgICAvLyBNdXN0IGFsd2F5cyBydW4sIGV2ZW4gaWYgYSBjdXN0b20gaGFuZGxlciBoYW5kbGVkIHRoZSBldmVudFxuICAgICAgICB0aGlzLmxhc3RLZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgICAgICAgdGhpcy5sYXN0S2V5VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IDkgJiYgRGF0ZS5ub3coKSA8IHRoaXMubGFzdEVzY1ByZXNzICsgMjAwMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSAhPSAyNyAmJiBtb2RpZmllckNvZGVzLmluZGV4T2YoZXZlbnQua2V5Q29kZSkgPCAwKVxuICAgICAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUubGFzdEVzY1ByZXNzID0gMDtcbiAgICAgICAgLy8gQ2hyb21lIGZvciBBbmRyb2lkIHVzdWFsbHkgZG9lc24ndCBmaXJlIHByb3BlciBrZXkgZXZlbnRzLCBidXRcbiAgICAgICAgLy8gb2NjYXNpb25hbGx5IGRvZXMsIHVzdWFsbHkgc3Vycm91bmRlZCBieSBhIGJ1bmNoIG9mIGNvbXBsaWNhdGVkXG4gICAgICAgIC8vIGNvbXBvc2l0aW9uIGNoYW5nZXMuIFdoZW4gYW4gZW50ZXIgb3IgYmFja3NwYWNlIGtleSBldmVudCBpc1xuICAgICAgICAvLyBzZWVuLCBob2xkIG9mZiBvbiBoYW5kbGluZyBET00gZXZlbnRzIGZvciBhIGJpdCwgYW5kIHRoZW5cbiAgICAgICAgLy8gZGlzcGF0Y2ggaXQuXG4gICAgICAgIGlmIChicm93c2VyLmFuZHJvaWQgJiYgYnJvd3Nlci5jaHJvbWUgJiYgIWV2ZW50LnN5bnRoZXRpYyAmJlxuICAgICAgICAgICAgKGV2ZW50LmtleUNvZGUgPT0gMTMgfHwgZXZlbnQua2V5Q29kZSA9PSA4KSkge1xuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmRlbGF5QW5kcm9pZEtleShldmVudC5rZXksIGV2ZW50LmtleUNvZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJldmVudGluZyB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiBFbnRlciBvbiBpT1MgbWFrZXMgdGhlXG4gICAgICAgIC8vIHZpcnR1YWwga2V5Ym9hcmQgZ2V0IHN0dWNrIGluIHRoZSB3cm9uZyAobG93ZXJjYXNlKVxuICAgICAgICAvLyBzdGF0ZS4gU28gd2UgbGV0IGl0IGdvIHRocm91Z2gsIGFuZCB0aGVuLCBpblxuICAgICAgICAvLyBhcHBseURPTUNoYW5nZSwgbm90aWZ5IGtleSBoYW5kbGVycyBvZiBpdCBhbmQgcmVzZXQgdG9cbiAgICAgICAgLy8gdGhlIHN0YXRlIHRoZXkgcHJvZHVjZS5cbiAgICAgICAgbGV0IHBlbmRpbmc7XG4gICAgICAgIGlmIChicm93c2VyLmlvcyAmJiAhZXZlbnQuc3ludGhldGljICYmICFldmVudC5hbHRLZXkgJiYgIWV2ZW50Lm1ldGFLZXkgJiZcbiAgICAgICAgICAgICgocGVuZGluZyA9IFBlbmRpbmdLZXlzLmZpbmQoa2V5ID0+IGtleS5rZXlDb2RlID09IGV2ZW50LmtleUNvZGUpKSAmJiAhZXZlbnQuY3RybEtleSB8fFxuICAgICAgICAgICAgICAgIEVtYWNzeVBlbmRpbmdLZXlzLmluZGV4T2YoZXZlbnQua2V5KSA+IC0xICYmIGV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50LnNoaWZ0S2V5KSkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nSU9TS2V5ID0gcGVuZGluZyB8fCBldmVudDtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5mbHVzaElPU0tleSgpLCAyNTApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgIT0gMjI5KVxuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmZvcmNlRmx1c2goKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmbHVzaElPU0tleSgpIHtcbiAgICAgICAgbGV0IGtleSA9IHRoaXMucGVuZGluZ0lPU0tleTtcbiAgICAgICAgaWYgKCFrZXkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMucGVuZGluZ0lPU0tleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoS2V5KHRoaXMudmlldy5jb250ZW50RE9NLCBrZXkua2V5LCBrZXkua2V5Q29kZSk7XG4gICAgfVxuICAgIGlnbm9yZUR1cmluZ0NvbXBvc2l0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICghL15rZXkvLnRlc3QoZXZlbnQudHlwZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvc2luZyA+IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vd3d3LnN0dW0uZGUvMjAxNi8wNi8yNC9oYW5kbGluZy1pbWUtZXZlbnRzLWluLWphdmFzY3JpcHQvLlxuICAgICAgICAvLyBPbiBzb21lIGlucHV0IG1ldGhvZCBlZGl0b3JzIChJTUVzKSwgdGhlIEVudGVyIGtleSBpcyB1c2VkIHRvXG4gICAgICAgIC8vIGNvbmZpcm0gY2hhcmFjdGVyIHNlbGVjdGlvbi4gT24gU2FmYXJpLCB3aGVuIEVudGVyIGlzIHByZXNzZWQsXG4gICAgICAgIC8vIGNvbXBvc2l0aW9uZW5kIGFuZCBrZXlkb3duIGV2ZW50cyBhcmUgc29tZXRpbWVzIGVtaXR0ZWQgaW4gdGhlXG4gICAgICAgIC8vIHdyb25nIG9yZGVyLiBUaGUga2V5IGV2ZW50IHNob3VsZCBzdGlsbCBiZSBpZ25vcmVkLCBldmVuIHdoZW5cbiAgICAgICAgLy8gaXQgaGFwcGVucyBhZnRlciB0aGUgY29tcG9zaXRpb25lbmQgZXZlbnQuXG4gICAgICAgIGlmIChicm93c2VyLnNhZmFyaSAmJiAhYnJvd3Nlci5pb3MgJiYgdGhpcy5jb21wb3NpdGlvblBlbmRpbmdLZXkgJiYgRGF0ZS5ub3coKSAtIHRoaXMuY29tcG9zaXRpb25FbmRlZEF0IDwgMTAwKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvc2l0aW9uUGVuZGluZ0tleSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzdGFydE1vdXNlU2VsZWN0aW9uKG1vdXNlU2VsZWN0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdXNlU2VsZWN0aW9uKVxuICAgICAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbi5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMubW91c2VTZWxlY3Rpb24gPSBtb3VzZVNlbGVjdGlvbjtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5tb3VzZVNlbGVjdGlvbilcbiAgICAgICAgICAgIHRoaXMubW91c2VTZWxlY3Rpb24udXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnZWRDb250ZW50ICYmIHVwZGF0ZS5kb2NDaGFuZ2VkKVxuICAgICAgICAgICAgdGhpcy5kcmFnZ2VkQ29udGVudCA9IHRoaXMuZHJhZ2dlZENvbnRlbnQubWFwKHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5sYXN0S2V5Q29kZSA9IHRoaXMubGFzdFNlbGVjdGlvblRpbWUgPSAwO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5tb3VzZVNlbGVjdGlvbilcbiAgICAgICAgICAgIHRoaXMubW91c2VTZWxlY3Rpb24uZGVzdHJveSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJpbmRIYW5kbGVyKHBsdWdpbiwgaGFuZGxlcikge1xuICAgIHJldHVybiAodmlldywgZXZlbnQpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLmNhbGwocGx1Z2luLCBldmVudCwgdmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih2aWV3LnN0YXRlLCBlKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjb21wdXRlSGFuZGxlcnMocGx1Z2lucykge1xuICAgIGxldCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZ1bmN0aW9uIHJlY29yZCh0eXBlKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRbdHlwZV0gfHwgKHJlc3VsdFt0eXBlXSA9IHsgb2JzZXJ2ZXJzOiBbXSwgaGFuZGxlcnM6IFtdIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgICAgICBsZXQgc3BlYyA9IHBsdWdpbi5zcGVjO1xuICAgICAgICBpZiAoc3BlYyAmJiBzcGVjLmRvbUV2ZW50SGFuZGxlcnMpXG4gICAgICAgICAgICBmb3IgKGxldCB0eXBlIGluIHNwZWMuZG9tRXZlbnRIYW5kbGVycykge1xuICAgICAgICAgICAgICAgIGxldCBmID0gc3BlYy5kb21FdmVudEhhbmRsZXJzW3R5cGVdO1xuICAgICAgICAgICAgICAgIGlmIChmKVxuICAgICAgICAgICAgICAgICAgICByZWNvcmQodHlwZSkuaGFuZGxlcnMucHVzaChiaW5kSGFuZGxlcihwbHVnaW4udmFsdWUsIGYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKHNwZWMgJiYgc3BlYy5kb21FdmVudE9ic2VydmVycylcbiAgICAgICAgICAgIGZvciAobGV0IHR5cGUgaW4gc3BlYy5kb21FdmVudE9ic2VydmVycykge1xuICAgICAgICAgICAgICAgIGxldCBmID0gc3BlYy5kb21FdmVudE9ic2VydmVyc1t0eXBlXTtcbiAgICAgICAgICAgICAgICBpZiAoZilcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkKHR5cGUpLm9ic2VydmVycy5wdXNoKGJpbmRIYW5kbGVyKHBsdWdpbi52YWx1ZSwgZikpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCB0eXBlIGluIGhhbmRsZXJzKVxuICAgICAgICByZWNvcmQodHlwZSkuaGFuZGxlcnMucHVzaChoYW5kbGVyc1t0eXBlXSk7XG4gICAgZm9yIChsZXQgdHlwZSBpbiBvYnNlcnZlcnMpXG4gICAgICAgIHJlY29yZCh0eXBlKS5vYnNlcnZlcnMucHVzaChvYnNlcnZlcnNbdHlwZV0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBQZW5kaW5nS2V5cyA9IFtcbiAgICB7IGtleTogXCJCYWNrc3BhY2VcIiwga2V5Q29kZTogOCwgaW5wdXRUeXBlOiBcImRlbGV0ZUNvbnRlbnRCYWNrd2FyZFwiIH0sXG4gICAgeyBrZXk6IFwiRW50ZXJcIiwga2V5Q29kZTogMTMsIGlucHV0VHlwZTogXCJpbnNlcnRQYXJhZ3JhcGhcIiB9LFxuICAgIHsga2V5OiBcIkVudGVyXCIsIGtleUNvZGU6IDEzLCBpbnB1dFR5cGU6IFwiaW5zZXJ0TGluZUJyZWFrXCIgfSxcbiAgICB7IGtleTogXCJEZWxldGVcIiwga2V5Q29kZTogNDYsIGlucHV0VHlwZTogXCJkZWxldGVDb250ZW50Rm9yd2FyZFwiIH1cbl07XG5jb25zdCBFbWFjc3lQZW5kaW5nS2V5cyA9IFwiZHRoa29cIjtcbi8vIEtleSBjb2RlcyBmb3IgbW9kaWZpZXIga2V5c1xuY29uc3QgbW9kaWZpZXJDb2RlcyA9IFsxNiwgMTcsIDE4LCAyMCwgOTEsIDkyLCAyMjQsIDIyNV07XG5jb25zdCBkcmFnU2Nyb2xsTWFyZ2luID0gNjtcbmZ1bmN0aW9uIGRyYWdTY3JvbGxTcGVlZChkaXN0KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIGRpc3QpICogMC43ICsgODtcbn1cbmZ1bmN0aW9uIGRpc3QoYSwgYikge1xuICAgIHJldHVybiBNYXRoLm1heChNYXRoLmFicyhhLmNsaWVudFggLSBiLmNsaWVudFgpLCBNYXRoLmFicyhhLmNsaWVudFkgLSBiLmNsaWVudFkpKTtcbn1cbmNsYXNzIE1vdXNlU2VsZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBzdGFydEV2ZW50LCBzdHlsZSwgbXVzdFNlbGVjdCkge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnN0YXJ0RXZlbnQgPSBzdGFydEV2ZW50O1xuICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgICAgIHRoaXMubXVzdFNlbGVjdCA9IG11c3RTZWxlY3Q7XG4gICAgICAgIHRoaXMuc2Nyb2xsU3BlZWQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgdGhpcy5zY3JvbGxpbmcgPSAtMTtcbiAgICAgICAgdGhpcy5sYXN0RXZlbnQgPSBzdGFydEV2ZW50O1xuICAgICAgICB0aGlzLnNjcm9sbFBhcmVudCA9IHNjcm9sbGFibGVQYXJlbnQodmlldy5jb250ZW50RE9NKTtcbiAgICAgICAgdGhpcy5hdG9tcyA9IHZpZXcuc3RhdGUuZmFjZXQoYXRvbWljUmFuZ2VzKS5tYXAoZiA9PiBmKHZpZXcpKTtcbiAgICAgICAgbGV0IGRvYyA9IHZpZXcuY29udGVudERPTS5vd25lckRvY3VtZW50O1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdmUgPSB0aGlzLm1vdmUuYmluZCh0aGlzKSk7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLnVwID0gdGhpcy51cC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5leHRlbmQgPSBzdGFydEV2ZW50LnNoaWZ0S2V5O1xuICAgICAgICB0aGlzLm11bHRpcGxlID0gdmlldy5zdGF0ZS5mYWNldChFZGl0b3JTdGF0ZS5hbGxvd011bHRpcGxlU2VsZWN0aW9ucykgJiYgYWRkc1NlbGVjdGlvblJhbmdlKHZpZXcsIHN0YXJ0RXZlbnQpO1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gaXNJblByaW1hcnlTZWxlY3Rpb24odmlldywgc3RhcnRFdmVudCkgJiYgZ2V0Q2xpY2tUeXBlKHN0YXJ0RXZlbnQpID09IDEgPyBudWxsIDogZmFsc2U7XG4gICAgfVxuICAgIHN0YXJ0KGV2ZW50KSB7XG4gICAgICAgIC8vIFdoZW4gY2xpY2tpbmcgb3V0c2lkZSBvZiB0aGUgc2VsZWN0aW9uLCBpbW1lZGlhdGVseSBhcHBseSB0aGVcbiAgICAgICAgLy8gZWZmZWN0IG9mIHN0YXJ0aW5nIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcgPT09IGZhbHNlKVxuICAgICAgICAgICAgdGhpcy5zZWxlY3QoZXZlbnQpO1xuICAgIH1cbiAgICBtb3ZlKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbnMgPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcgfHwgdGhpcy5kcmFnZ2luZyA9PSBudWxsICYmIGRpc3QodGhpcy5zdGFydEV2ZW50LCBldmVudCkgPCAxMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5zZWxlY3QodGhpcy5sYXN0RXZlbnQgPSBldmVudCk7XG4gICAgICAgIGxldCBzeCA9IDAsIHN5ID0gMDtcbiAgICAgICAgbGV0IHJlY3QgPSAoKF9hID0gdGhpcy5zY3JvbGxQYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSlcbiAgICAgICAgICAgIHx8IHsgbGVmdDogMCwgdG9wOiAwLCByaWdodDogdGhpcy52aWV3Lndpbi5pbm5lcldpZHRoLCBib3R0b206IHRoaXMudmlldy53aW4uaW5uZXJIZWlnaHQgfTtcbiAgICAgICAgbGV0IG1hcmdpbnMgPSBnZXRTY3JvbGxNYXJnaW5zKHRoaXMudmlldyk7XG4gICAgICAgIGlmIChldmVudC5jbGllbnRYIC0gbWFyZ2lucy5sZWZ0IDw9IHJlY3QubGVmdCArIGRyYWdTY3JvbGxNYXJnaW4pXG4gICAgICAgICAgICBzeCA9IC1kcmFnU2Nyb2xsU3BlZWQocmVjdC5sZWZ0IC0gZXZlbnQuY2xpZW50WCk7XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LmNsaWVudFggKyBtYXJnaW5zLnJpZ2h0ID49IHJlY3QucmlnaHQgLSBkcmFnU2Nyb2xsTWFyZ2luKVxuICAgICAgICAgICAgc3ggPSBkcmFnU2Nyb2xsU3BlZWQoZXZlbnQuY2xpZW50WCAtIHJlY3QucmlnaHQpO1xuICAgICAgICBpZiAoZXZlbnQuY2xpZW50WSAtIG1hcmdpbnMudG9wIDw9IHJlY3QudG9wICsgZHJhZ1Njcm9sbE1hcmdpbilcbiAgICAgICAgICAgIHN5ID0gLWRyYWdTY3JvbGxTcGVlZChyZWN0LnRvcCAtIGV2ZW50LmNsaWVudFkpO1xuICAgICAgICBlbHNlIGlmIChldmVudC5jbGllbnRZICsgbWFyZ2lucy5ib3R0b20gPj0gcmVjdC5ib3R0b20gLSBkcmFnU2Nyb2xsTWFyZ2luKVxuICAgICAgICAgICAgc3kgPSBkcmFnU2Nyb2xsU3BlZWQoZXZlbnQuY2xpZW50WSAtIHJlY3QuYm90dG9tKTtcbiAgICAgICAgdGhpcy5zZXRTY3JvbGxTcGVlZChzeCwgc3kpO1xuICAgIH1cbiAgICB1cChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyA9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5zZWxlY3QodGhpcy5sYXN0RXZlbnQpO1xuICAgICAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXRTY3JvbGxTcGVlZCgwLCAwKTtcbiAgICAgICAgbGV0IGRvYyA9IHRoaXMudmlldy5jb250ZW50RE9NLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW92ZSk7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLnVwKTtcbiAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUubW91c2VTZWxlY3Rpb24gPSB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5kcmFnZ2VkQ29udGVudCA9IG51bGw7XG4gICAgfVxuICAgIHNldFNjcm9sbFNwZWVkKHN4LCBzeSkge1xuICAgICAgICB0aGlzLnNjcm9sbFNwZWVkID0geyB4OiBzeCwgeTogc3kgfTtcbiAgICAgICAgaWYgKHN4IHx8IHN5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zY3JvbGxpbmcgPCAwKVxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsaW5nID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5zY3JvbGwoKSwgNTApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2Nyb2xsaW5nID4gLTEpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5zY3JvbGxpbmcpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxpbmcgPSAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzY3JvbGwoKSB7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbFBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCArPSB0aGlzLnNjcm9sbFNwZWVkLng7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxUb3AgKz0gdGhpcy5zY3JvbGxTcGVlZC55O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52aWV3Lndpbi5zY3JvbGxCeSh0aGlzLnNjcm9sbFNwZWVkLngsIHRoaXMuc2Nyb2xsU3BlZWQueSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcgPT09IGZhbHNlKVxuICAgICAgICAgICAgdGhpcy5zZWxlY3QodGhpcy5sYXN0RXZlbnQpO1xuICAgIH1cbiAgICBza2lwQXRvbXMoc2VsKSB7XG4gICAgICAgIGxldCByYW5nZXMgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHNlbC5yYW5nZXNbaV0sIHVwZGF0ZWQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJhbmdlLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgbGV0IHBvcyA9IHNraXBBdG9taWNSYW5nZXModGhpcy5hdG9tcywgcmFuZ2UuZnJvbSwgMCk7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyAhPSByYW5nZS5mcm9tKVxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkID0gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gc2tpcEF0b21pY1Jhbmdlcyh0aGlzLmF0b21zLCByYW5nZS5mcm9tLCAtMSk7XG4gICAgICAgICAgICAgICAgbGV0IHRvID0gc2tpcEF0b21pY1Jhbmdlcyh0aGlzLmF0b21zLCByYW5nZS50bywgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gIT0gcmFuZ2UuZnJvbSB8fCB0byAhPSByYW5nZS50bylcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZCA9IEVkaXRvclNlbGVjdGlvbi5yYW5nZShyYW5nZS5mcm9tID09IHJhbmdlLmFuY2hvciA/IGZyb20gOiB0bywgcmFuZ2UuZnJvbSA9PSByYW5nZS5oZWFkID8gZnJvbSA6IHRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyYW5nZXMpXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlcyA9IHNlbC5yYW5nZXMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICByYW5nZXNbaV0gPSB1cGRhdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZXMgPyBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcywgc2VsLm1haW5JbmRleCkgOiBzZWw7XG4gICAgfVxuICAgIHNlbGVjdChldmVudCkge1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzLCBzZWxlY3Rpb24gPSB0aGlzLnNraXBBdG9tcyh0aGlzLnN0eWxlLmdldChldmVudCwgdGhpcy5leHRlbmQsIHRoaXMubXVsdGlwbGUpKTtcbiAgICAgICAgaWYgKHRoaXMubXVzdFNlbGVjdCB8fCAhc2VsZWN0aW9uLmVxKHZpZXcuc3RhdGUuc2VsZWN0aW9uLCB0aGlzLmRyYWdnaW5nID09PSBmYWxzZSkpXG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICB1c2VyRXZlbnQ6IFwic2VsZWN0LnBvaW50ZXJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubXVzdFNlbGVjdCA9IGZhbHNlO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0eWxlLnVwZGF0ZSh1cGRhdGUpKVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnNlbGVjdCh0aGlzLmxhc3RFdmVudCksIDIwKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRzU2VsZWN0aW9uUmFuZ2UodmlldywgZXZlbnQpIHtcbiAgICBsZXQgZmFjZXQgPSB2aWV3LnN0YXRlLmZhY2V0KGNsaWNrQWRkc1NlbGVjdGlvblJhbmdlKTtcbiAgICByZXR1cm4gZmFjZXQubGVuZ3RoID8gZmFjZXRbMF0oZXZlbnQpIDogYnJvd3Nlci5tYWMgPyBldmVudC5tZXRhS2V5IDogZXZlbnQuY3RybEtleTtcbn1cbmZ1bmN0aW9uIGRyYWdNb3Zlc1NlbGVjdGlvbih2aWV3LCBldmVudCkge1xuICAgIGxldCBmYWNldCA9IHZpZXcuc3RhdGUuZmFjZXQoZHJhZ01vdmVzU2VsZWN0aW9uJDEpO1xuICAgIHJldHVybiBmYWNldC5sZW5ndGggPyBmYWNldFswXShldmVudCkgOiBicm93c2VyLm1hYyA/ICFldmVudC5hbHRLZXkgOiAhZXZlbnQuY3RybEtleTtcbn1cbmZ1bmN0aW9uIGlzSW5QcmltYXJ5U2VsZWN0aW9uKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IHsgbWFpbiB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKG1haW4uZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBPbiBib3VuZGFyeSBjbGlja3MsIGNoZWNrIHdoZXRoZXIgdGhlIGNvb3JkaW5hdGVzIGFyZSBpbnNpZGUgdGhlXG4gICAgLy8gc2VsZWN0aW9uJ3MgY2xpZW50IHJlY3RhbmdsZXNcbiAgICBsZXQgc2VsID0gZ2V0U2VsZWN0aW9uKHZpZXcucm9vdCk7XG4gICAgaWYgKCFzZWwgfHwgc2VsLnJhbmdlQ291bnQgPT0gMClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IHJlY3RzID0gc2VsLmdldFJhbmdlQXQoMCkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCByZWN0ID0gcmVjdHNbaV07XG4gICAgICAgIGlmIChyZWN0LmxlZnQgPD0gZXZlbnQuY2xpZW50WCAmJiByZWN0LnJpZ2h0ID49IGV2ZW50LmNsaWVudFggJiZcbiAgICAgICAgICAgIHJlY3QudG9wIDw9IGV2ZW50LmNsaWVudFkgJiYgcmVjdC5ib3R0b20gPj0gZXZlbnQuY2xpZW50WSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBldmVudEJlbG9uZ3NUb0VkaXRvcih2aWV3LCBldmVudCkge1xuICAgIGlmICghZXZlbnQuYnViYmxlcylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBub2RlID0gZXZlbnQudGFyZ2V0LCBjVmlldzsgbm9kZSAhPSB2aWV3LmNvbnRlbnRET007IG5vZGUgPSBub2RlLnBhcmVudE5vZGUpXG4gICAgICAgIGlmICghbm9kZSB8fCBub2RlLm5vZGVUeXBlID09IDExIHx8ICgoY1ZpZXcgPSBDb250ZW50Vmlldy5nZXQobm9kZSkpICYmIGNWaWV3Lmlnbm9yZUV2ZW50KGV2ZW50KSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBoYW5kbGVycyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuY29uc3Qgb2JzZXJ2ZXJzID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG4vLyBUaGlzIGlzIHZlcnkgY3J1ZGUsIGJ1dCB1bmZvcnR1bmF0ZWx5IGJvdGggdGhlc2UgYnJvd3NlcnMgX3ByZXRlbmRfXG4vLyB0aGF0IHRoZXkgaGF2ZSBhIGNsaXBib2FyZCBBUEnigJRhbGwgdGhlIG9iamVjdHMgYW5kIG1ldGhvZHMgYXJlXG4vLyB0aGVyZSwgdGhleSBqdXN0IGRvbid0IHdvcmssIGFuZCB0aGV5IGFyZSBoYXJkIHRvIHRlc3QuXG5jb25zdCBicm9rZW5DbGlwYm9hcmRBUEkgPSAoYnJvd3Nlci5pZSAmJiBicm93c2VyLmllX3ZlcnNpb24gPCAxNSkgfHxcbiAgICAoYnJvd3Nlci5pb3MgJiYgYnJvd3Nlci53ZWJraXRfdmVyc2lvbiA8IDYwNCk7XG5mdW5jdGlvbiBjYXB0dXJlUGFzdGUodmlldykge1xuICAgIGxldCBwYXJlbnQgPSB2aWV3LmRvbS5wYXJlbnROb2RlO1xuICAgIGlmICghcGFyZW50KVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHRhcmdldCA9IHBhcmVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIikpO1xuICAgIHRhcmdldC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogZml4ZWQ7IGxlZnQ6IC0xMDAwMHB4OyB0b3A6IDEwcHhcIjtcbiAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICB0YXJnZXQucmVtb3ZlKCk7XG4gICAgICAgIGRvUGFzdGUodmlldywgdGFyZ2V0LnZhbHVlKTtcbiAgICB9LCA1MCk7XG59XG5mdW5jdGlvbiBkb1Bhc3RlKHZpZXcsIGlucHV0KSB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIGNoYW5nZXMsIGkgPSAxLCB0ZXh0ID0gc3RhdGUudG9UZXh0KGlucHV0KTtcbiAgICBsZXQgYnlMaW5lID0gdGV4dC5saW5lcyA9PSBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmxlbmd0aDtcbiAgICBsZXQgbGluZXdpc2UgPSBsYXN0TGluZXdpc2VDb3B5ICE9IG51bGwgJiYgc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5ldmVyeShyID0+IHIuZW1wdHkpICYmIGxhc3RMaW5ld2lzZUNvcHkgPT0gdGV4dC50b1N0cmluZygpO1xuICAgIGlmIChsaW5ld2lzZSkge1xuICAgICAgICBsZXQgbGFzdExpbmUgPSAtMTtcbiAgICAgICAgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHJhbmdlLmZyb20pO1xuICAgICAgICAgICAgaWYgKGxpbmUuZnJvbSA9PSBsYXN0TGluZSlcbiAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZSB9O1xuICAgICAgICAgICAgbGFzdExpbmUgPSBsaW5lLmZyb207XG4gICAgICAgICAgICBsZXQgaW5zZXJ0ID0gc3RhdGUudG9UZXh0KChieUxpbmUgPyB0ZXh0LmxpbmUoaSsrKS50ZXh0IDogaW5wdXQpICsgc3RhdGUubGluZUJyZWFrKTtcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbTogbGluZS5mcm9tLCBpbnNlcnQgfSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5mcm9tICsgaW5zZXJ0Lmxlbmd0aCkgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJ5TGluZSkge1xuICAgICAgICBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHRleHQubGluZShpKyspO1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiByYW5nZS5mcm9tLCB0bzogcmFuZ2UudG8sIGluc2VydDogbGluZS50ZXh0IH0sXG4gICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuZnJvbSArIGxpbmUubGVuZ3RoKSB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNoYW5nZXMgPSBzdGF0ZS5yZXBsYWNlU2VsZWN0aW9uKHRleHQpO1xuICAgIH1cbiAgICB2aWV3LmRpc3BhdGNoKGNoYW5nZXMsIHtcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnBhc3RlXCIsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlXG4gICAgfSk7XG59XG5vYnNlcnZlcnMuc2Nyb2xsID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLmxhc3RTY3JvbGxUb3AgPSB2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3A7XG4gICAgdmlldy5pbnB1dFN0YXRlLmxhc3RTY3JvbGxMZWZ0ID0gdmlldy5zY3JvbGxET00uc2Nyb2xsTGVmdDtcbn07XG5oYW5kbGVycy5rZXlkb3duID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLnNldFNlbGVjdGlvbk9yaWdpbihcInNlbGVjdFwiKTtcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAyNylcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmxhc3RFc2NQcmVzcyA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbm9ic2VydmVycy50b3VjaHN0YXJ0ID0gKHZpZXcsIGUpID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUubGFzdFRvdWNoVGltZSA9IERhdGUubm93KCk7XG4gICAgdmlldy5pbnB1dFN0YXRlLnNldFNlbGVjdGlvbk9yaWdpbihcInNlbGVjdC5wb2ludGVyXCIpO1xufTtcbm9ic2VydmVycy50b3VjaG1vdmUgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUuc2V0U2VsZWN0aW9uT3JpZ2luKFwic2VsZWN0LnBvaW50ZXJcIik7XG59O1xuaGFuZGxlcnMubW91c2Vkb3duID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgdmlldy5vYnNlcnZlci5mbHVzaCgpO1xuICAgIGlmICh2aWV3LmlucHV0U3RhdGUubGFzdFRvdWNoVGltZSA+IERhdGUubm93KCkgLSAyMDAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIElnbm9yZSB0b3VjaCBpbnRlcmFjdGlvblxuICAgIGxldCBzdHlsZSA9IG51bGw7XG4gICAgZm9yIChsZXQgbWFrZVN0eWxlIG9mIHZpZXcuc3RhdGUuZmFjZXQobW91c2VTZWxlY3Rpb25TdHlsZSkpIHtcbiAgICAgICAgc3R5bGUgPSBtYWtlU3R5bGUodmlldywgZXZlbnQpO1xuICAgICAgICBpZiAoc3R5bGUpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKCFzdHlsZSAmJiBldmVudC5idXR0b24gPT0gMClcbiAgICAgICAgc3R5bGUgPSBiYXNpY01vdXNlU2VsZWN0aW9uKHZpZXcsIGV2ZW50KTtcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgbGV0IG11c3RGb2N1cyA9ICF2aWV3Lmhhc0ZvY3VzO1xuICAgICAgICB2aWV3LmlucHV0U3RhdGUuc3RhcnRNb3VzZVNlbGVjdGlvbihuZXcgTW91c2VTZWxlY3Rpb24odmlldywgZXZlbnQsIHN0eWxlLCBtdXN0Rm9jdXMpKTtcbiAgICAgICAgaWYgKG11c3RGb2N1cylcbiAgICAgICAgICAgIHZpZXcub2JzZXJ2ZXIuaWdub3JlKCgpID0+IGZvY3VzUHJldmVudFNjcm9sbCh2aWV3LmNvbnRlbnRET00pKTtcbiAgICAgICAgbGV0IG1vdXNlU2VsID0gdmlldy5pbnB1dFN0YXRlLm1vdXNlU2VsZWN0aW9uO1xuICAgICAgICBpZiAobW91c2VTZWwpIHtcbiAgICAgICAgICAgIG1vdXNlU2VsLnN0YXJ0KGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybiBtb3VzZVNlbC5kcmFnZ2luZyA9PT0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmZ1bmN0aW9uIHJhbmdlRm9yQ2xpY2sodmlldywgcG9zLCBiaWFzLCB0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gMSkgeyAvLyBTaW5nbGUgY2xpY2tcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zLCBiaWFzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PSAyKSB7IC8vIERvdWJsZSBjbGlja1xuICAgICAgICByZXR1cm4gZ3JvdXBBdCh2aWV3LnN0YXRlLCBwb3MsIGJpYXMpO1xuICAgIH1cbiAgICBlbHNlIHsgLy8gVHJpcGxlIGNsaWNrXG4gICAgICAgIGxldCB2aXN1YWwgPSBMaW5lVmlldy5maW5kKHZpZXcuZG9jVmlldywgcG9zKSwgbGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdCh2aXN1YWwgPyB2aXN1YWwucG9zQXRFbmQgOiBwb3MpO1xuICAgICAgICBsZXQgZnJvbSA9IHZpc3VhbCA/IHZpc3VhbC5wb3NBdFN0YXJ0IDogbGluZS5mcm9tLCB0byA9IHZpc3VhbCA/IHZpc3VhbC5wb3NBdEVuZCA6IGxpbmUudG87XG4gICAgICAgIGlmICh0byA8IHZpZXcuc3RhdGUuZG9jLmxlbmd0aCAmJiB0byA9PSBsaW5lLnRvKVxuICAgICAgICAgICAgdG8rKztcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0byk7XG4gICAgfVxufVxubGV0IGluc2lkZVkgPSAoeSwgcmVjdCkgPT4geSA+PSByZWN0LnRvcCAmJiB5IDw9IHJlY3QuYm90dG9tO1xubGV0IGluc2lkZSA9ICh4LCB5LCByZWN0KSA9PiBpbnNpZGVZKHksIHJlY3QpICYmIHggPj0gcmVjdC5sZWZ0ICYmIHggPD0gcmVjdC5yaWdodDtcbi8vIFRyeSB0byBkZXRlcm1pbmUsIGZvciB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMsIGFzc29jaWF0ZWQgd2l0aCB0aGVcbi8vIGdpdmVuIHBvc2l0aW9uLCB3aGV0aGVyIHRoZXkgYXJlIHJlbGF0ZWQgdG8gdGhlIGVsZW1lbnQgYmVmb3JlIG9yXG4vLyB0aGUgZWxlbWVudCBhZnRlciB0aGUgcG9zaXRpb24uXG5mdW5jdGlvbiBmaW5kUG9zaXRpb25TaWRlKHZpZXcsIHBvcywgeCwgeSkge1xuICAgIGxldCBsaW5lID0gTGluZVZpZXcuZmluZCh2aWV3LmRvY1ZpZXcsIHBvcyk7XG4gICAgaWYgKCFsaW5lKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBsZXQgb2ZmID0gcG9zIC0gbGluZS5wb3NBdFN0YXJ0O1xuICAgIC8vIExpbmUgYm91bmRhcmllcyBwb2ludCBpbnRvIHRoZSBsaW5lXG4gICAgaWYgKG9mZiA9PSAwKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAob2ZmID09IGxpbmUubGVuZ3RoKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgLy8gUG9zaXRpb25zIG9uIHRvcCBvZiBhbiBlbGVtZW50IHBvaW50IGF0IHRoYXQgZWxlbWVudFxuICAgIGxldCBiZWZvcmUgPSBsaW5lLmNvb3Jkc0F0KG9mZiwgLTEpO1xuICAgIGlmIChiZWZvcmUgJiYgaW5zaWRlKHgsIHksIGJlZm9yZSkpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICBsZXQgYWZ0ZXIgPSBsaW5lLmNvb3Jkc0F0KG9mZiwgMSk7XG4gICAgaWYgKGFmdGVyICYmIGluc2lkZSh4LCB5LCBhZnRlcikpXG4gICAgICAgIHJldHVybiAxO1xuICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYSBsaW5lIHdyYXAgcG9pbnQuIFBpY2sgYmVmb3JlIGlmIHRoZSBwb2ludCBpc1xuICAgIC8vIGJlc2lkZSBpdC5cbiAgICByZXR1cm4gYmVmb3JlICYmIGluc2lkZVkoeSwgYmVmb3JlKSA/IC0xIDogMTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5UG9zKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IHBvcyA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0sIGZhbHNlKTtcbiAgICByZXR1cm4geyBwb3MsIGJpYXM6IGZpbmRQb3NpdGlvblNpZGUodmlldywgcG9zLCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKSB9O1xufVxuY29uc3QgQmFkTW91c2VEZXRhaWwgPSBicm93c2VyLmllICYmIGJyb3dzZXIuaWVfdmVyc2lvbiA8PSAxMTtcbmxldCBsYXN0TW91c2VEb3duID0gbnVsbCwgbGFzdE1vdXNlRG93bkNvdW50ID0gMCwgbGFzdE1vdXNlRG93blRpbWUgPSAwO1xuZnVuY3Rpb24gZ2V0Q2xpY2tUeXBlKGV2ZW50KSB7XG4gICAgaWYgKCFCYWRNb3VzZURldGFpbClcbiAgICAgICAgcmV0dXJuIGV2ZW50LmRldGFpbDtcbiAgICBsZXQgbGFzdCA9IGxhc3RNb3VzZURvd24sIGxhc3RUaW1lID0gbGFzdE1vdXNlRG93blRpbWU7XG4gICAgbGFzdE1vdXNlRG93biA9IGV2ZW50O1xuICAgIGxhc3RNb3VzZURvd25UaW1lID0gRGF0ZS5ub3coKTtcbiAgICByZXR1cm4gbGFzdE1vdXNlRG93bkNvdW50ID0gIWxhc3QgfHwgKGxhc3RUaW1lID4gRGF0ZS5ub3coKSAtIDQwMCAmJiBNYXRoLmFicyhsYXN0LmNsaWVudFggLSBldmVudC5jbGllbnRYKSA8IDIgJiZcbiAgICAgICAgTWF0aC5hYnMobGFzdC5jbGllbnRZIC0gZXZlbnQuY2xpZW50WSkgPCAyKSA/IChsYXN0TW91c2VEb3duQ291bnQgKyAxKSAlIDMgOiAxO1xufVxuZnVuY3Rpb24gYmFzaWNNb3VzZVNlbGVjdGlvbih2aWV3LCBldmVudCkge1xuICAgIGxldCBzdGFydCA9IHF1ZXJ5UG9zKHZpZXcsIGV2ZW50KSwgdHlwZSA9IGdldENsaWNrVHlwZShldmVudCk7XG4gICAgbGV0IHN0YXJ0U2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQucG9zID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHN0YXJ0LnBvcyk7XG4gICAgICAgICAgICAgICAgc3RhcnRTZWwgPSBzdGFydFNlbC5tYXAodXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXQoZXZlbnQsIGV4dGVuZCwgbXVsdGlwbGUpIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSBxdWVyeVBvcyh2aWV3LCBldmVudCksIHJlbW92ZWQ7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSByYW5nZUZvckNsaWNrKHZpZXcsIGN1ci5wb3MsIGN1ci5iaWFzLCB0eXBlKTtcbiAgICAgICAgICAgIGlmIChzdGFydC5wb3MgIT0gY3VyLnBvcyAmJiAhZXh0ZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0UmFuZ2UgPSByYW5nZUZvckNsaWNrKHZpZXcsIHN0YXJ0LnBvcywgc3RhcnQuYmlhcywgdHlwZSk7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1pbihzdGFydFJhbmdlLmZyb20sIHJhbmdlLmZyb20pLCB0byA9IE1hdGgubWF4KHN0YXJ0UmFuZ2UudG8sIHJhbmdlLnRvKTtcbiAgICAgICAgICAgICAgICByYW5nZSA9IGZyb20gPCByYW5nZS5mcm9tID8gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIHRvKSA6IEVkaXRvclNlbGVjdGlvbi5yYW5nZSh0bywgZnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXh0ZW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydFNlbC5yZXBsYWNlUmFuZ2Uoc3RhcnRTZWwubWFpbi5leHRlbmQocmFuZ2UuZnJvbSwgcmFuZ2UudG8pKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG11bHRpcGxlICYmIHR5cGUgPT0gMSAmJiBzdGFydFNlbC5yYW5nZXMubGVuZ3RoID4gMSAmJiAocmVtb3ZlZCA9IHJlbW92ZVJhbmdlQXJvdW5kKHN0YXJ0U2VsLCBjdXIucG9zKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgICAgICAgICBlbHNlIGlmIChtdWx0aXBsZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRTZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKFtyYW5nZV0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVJhbmdlQXJvdW5kKHNlbCwgcG9zKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSBzZWwucmFuZ2VzW2ldO1xuICAgICAgICBpZiAoZnJvbSA8PSBwb3MgJiYgdG8gPj0gcG9zKVxuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoc2VsLnJhbmdlcy5zbGljZSgwLCBpKS5jb25jYXQoc2VsLnJhbmdlcy5zbGljZShpICsgMSkpLCBzZWwubWFpbkluZGV4ID09IGkgPyAwIDogc2VsLm1haW5JbmRleCAtIChzZWwubWFpbkluZGV4ID4gaSA/IDEgOiAwKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuaGFuZGxlcnMuZHJhZ3N0YXJ0ID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgbGV0IHsgc2VsZWN0aW9uOiB7IG1haW46IHJhbmdlIH0gfSA9IHZpZXcuc3RhdGU7XG4gICAgaWYgKGV2ZW50LnRhcmdldC5kcmFnZ2FibGUpIHtcbiAgICAgICAgbGV0IGNWaWV3ID0gdmlldy5kb2NWaWV3Lm5lYXJlc3QoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgaWYgKGNWaWV3ICYmIGNWaWV3LmlzV2lkZ2V0KSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IGNWaWV3LnBvc0F0U3RhcnQsIHRvID0gZnJvbSArIGNWaWV3Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChmcm9tID49IHJhbmdlLnRvIHx8IHRvIDw9IHJhbmdlLmZyb20pXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSwgdG8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCB7IGlucHV0U3RhdGUgfSA9IHZpZXc7XG4gICAgaWYgKGlucHV0U3RhdGUubW91c2VTZWxlY3Rpb24pXG4gICAgICAgIGlucHV0U3RhdGUubW91c2VTZWxlY3Rpb24uZHJhZ2dpbmcgPSB0cnVlO1xuICAgIGlucHV0U3RhdGUuZHJhZ2dlZENvbnRlbnQgPSByYW5nZTtcbiAgICBpZiAoZXZlbnQuZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKFwiVGV4dFwiLCB2aWV3LnN0YXRlLnNsaWNlRG9jKHJhbmdlLmZyb20sIHJhbmdlLnRvKSk7XG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gXCJjb3B5TW92ZVwiO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuaGFuZGxlcnMuZHJhZ2VuZCA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5kcmFnZ2VkQ29udGVudCA9IG51bGw7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmZ1bmN0aW9uIGRyb3BUZXh0KHZpZXcsIGV2ZW50LCB0ZXh0LCBkaXJlY3QpIHtcbiAgICBpZiAoIXRleHQpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgZHJvcFBvcyA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0sIGZhbHNlKTtcbiAgICBsZXQgeyBkcmFnZ2VkQ29udGVudCB9ID0gdmlldy5pbnB1dFN0YXRlO1xuICAgIGxldCBkZWwgPSBkaXJlY3QgJiYgZHJhZ2dlZENvbnRlbnQgJiYgZHJhZ01vdmVzU2VsZWN0aW9uKHZpZXcsIGV2ZW50KVxuICAgICAgICA/IHsgZnJvbTogZHJhZ2dlZENvbnRlbnQuZnJvbSwgdG86IGRyYWdnZWRDb250ZW50LnRvIH0gOiBudWxsO1xuICAgIGxldCBpbnMgPSB7IGZyb206IGRyb3BQb3MsIGluc2VydDogdGV4dCB9O1xuICAgIGxldCBjaGFuZ2VzID0gdmlldy5zdGF0ZS5jaGFuZ2VzKGRlbCA/IFtkZWwsIGluc10gOiBpbnMpO1xuICAgIHZpZXcuZm9jdXMoKTtcbiAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgc2VsZWN0aW9uOiB7IGFuY2hvcjogY2hhbmdlcy5tYXBQb3MoZHJvcFBvcywgLTEpLCBoZWFkOiBjaGFuZ2VzLm1hcFBvcyhkcm9wUG9zLCAxKSB9LFxuICAgICAgICB1c2VyRXZlbnQ6IGRlbCA/IFwibW92ZS5kcm9wXCIgOiBcImlucHV0LmRyb3BcIlxuICAgIH0pO1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5kcmFnZ2VkQ29udGVudCA9IG51bGw7XG59XG5oYW5kbGVycy5kcm9wID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgaWYgKCFldmVudC5kYXRhVHJhbnNmZXIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IGZpbGVzID0gZXZlbnQuZGF0YVRyYW5zZmVyLmZpbGVzO1xuICAgIGlmIChmaWxlcyAmJiBmaWxlcy5sZW5ndGgpIHsgLy8gRm9yIGEgZmlsZSBkcm9wLCByZWFkIHRoZSBmaWxlJ3MgdGV4dC5cbiAgICAgICAgbGV0IHRleHQgPSBBcnJheShmaWxlcy5sZW5ndGgpLCByZWFkID0gMDtcbiAgICAgICAgbGV0IGZpbmlzaEZpbGUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoKytyZWFkID09IGZpbGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBkcm9wVGV4dCh2aWV3LCBldmVudCwgdGV4dC5maWx0ZXIocyA9PiBzICE9IG51bGwpLmpvaW4odmlldy5zdGF0ZS5saW5lQnJlYWspLCBmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcjtcbiAgICAgICAgICAgIHJlYWRlci5vbmVycm9yID0gZmluaXNoRmlsZTtcbiAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCEvW1xceDAwLVxceDA4XFx4MGUtXFx4MWZdezJ9Ly50ZXN0KHJlYWRlci5yZXN1bHQpKVxuICAgICAgICAgICAgICAgICAgICB0ZXh0W2ldID0gcmVhZGVyLnJlc3VsdDtcbiAgICAgICAgICAgICAgICBmaW5pc2hGaWxlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHRleHQgPSBldmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcIlRleHRcIik7XG4gICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICBkcm9wVGV4dCh2aWV3LCBldmVudCwgdGV4dCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuaGFuZGxlcnMucGFzdGUgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgdmlldy5vYnNlcnZlci5mbHVzaCgpO1xuICAgIGxldCBkYXRhID0gYnJva2VuQ2xpcGJvYXJkQVBJID8gbnVsbCA6IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgZG9QYXN0ZSh2aWV3LCBkYXRhLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpIHx8IGRhdGEuZ2V0RGF0YShcInRleHQvdXJpLXRleHRcIikpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNhcHR1cmVQYXN0ZSh2aWV3KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5mdW5jdGlvbiBjYXB0dXJlQ29weSh2aWV3LCB0ZXh0KSB7XG4gICAgLy8gVGhlIGV4dHJhIHdyYXBwZXIgaXMgc29tZWhvdyBuZWNlc3Nhcnkgb24gSUUvRWRnZSB0byBwcmV2ZW50IHRoZVxuICAgIC8vIGNvbnRlbnQgZnJvbSBiZWluZyBtYW5nbGVkIHdoZW4gaXQgaXMgcHV0IG9udG8gdGhlIGNsaXBib2FyZFxuICAgIGxldCBwYXJlbnQgPSB2aWV3LmRvbS5wYXJlbnROb2RlO1xuICAgIGlmICghcGFyZW50KVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHRhcmdldCA9IHBhcmVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIikpO1xuICAgIHRhcmdldC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogZml4ZWQ7IGxlZnQ6IC0xMDAwMHB4OyB0b3A6IDEwcHhcIjtcbiAgICB0YXJnZXQudmFsdWUgPSB0ZXh0O1xuICAgIHRhcmdldC5mb2N1cygpO1xuICAgIHRhcmdldC5zZWxlY3Rpb25FbmQgPSB0ZXh0Lmxlbmd0aDtcbiAgICB0YXJnZXQuc2VsZWN0aW9uU3RhcnQgPSAwO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0YXJnZXQucmVtb3ZlKCk7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB9LCA1MCk7XG59XG5mdW5jdGlvbiBjb3BpZWRSYW5nZShzdGF0ZSkge1xuICAgIGxldCBjb250ZW50ID0gW10sIHJhbmdlcyA9IFtdLCBsaW5ld2lzZSA9IGZhbHNlO1xuICAgIGZvciAobGV0IHJhbmdlIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpXG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGNvbnRlbnQucHVzaChzdGF0ZS5zbGljZURvYyhyYW5nZS5mcm9tLCByYW5nZS50bykpO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2gocmFuZ2UpO1xuICAgICAgICB9XG4gICAgaWYgKCFjb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAvLyBOb3RoaW5nIHNlbGVjdGVkLCBkbyBhIGxpbmUtd2lzZSBjb3B5XG4gICAgICAgIGxldCB1cHRvID0gLTE7XG4gICAgICAgIGZvciAobGV0IHsgZnJvbSB9IG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChmcm9tKTtcbiAgICAgICAgICAgIGlmIChsaW5lLm51bWJlciA+IHVwdG8pIHtcbiAgICAgICAgICAgICAgICBjb250ZW50LnB1c2gobGluZS50ZXh0KTtcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSwgdG86IE1hdGgubWluKHN0YXRlLmRvYy5sZW5ndGgsIGxpbmUudG8gKyAxKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwdG8gPSBsaW5lLm51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBsaW5ld2lzZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB7IHRleHQ6IGNvbnRlbnQuam9pbihzdGF0ZS5saW5lQnJlYWspLCByYW5nZXMsIGxpbmV3aXNlIH07XG59XG5sZXQgbGFzdExpbmV3aXNlQ29weSA9IG51bGw7XG5oYW5kbGVycy5jb3B5ID0gaGFuZGxlcnMuY3V0ID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgbGV0IHsgdGV4dCwgcmFuZ2VzLCBsaW5ld2lzZSB9ID0gY29waWVkUmFuZ2Uodmlldy5zdGF0ZSk7XG4gICAgaWYgKCF0ZXh0ICYmICFsaW5ld2lzZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxhc3RMaW5ld2lzZUNvcHkgPSBsaW5ld2lzZSA/IHRleHQgOiBudWxsO1xuICAgIGlmIChldmVudC50eXBlID09IFwiY3V0XCIgJiYgIXZpZXcuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgY2hhbmdlczogcmFuZ2VzLFxuICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgICAgICB1c2VyRXZlbnQ6IFwiZGVsZXRlLmN1dFwiXG4gICAgICAgIH0pO1xuICAgIGxldCBkYXRhID0gYnJva2VuQ2xpcGJvYXJkQVBJID8gbnVsbCA6IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgZGF0YS5jbGVhckRhdGEoKTtcbiAgICAgICAgZGF0YS5zZXREYXRhKFwidGV4dC9wbGFpblwiLCB0ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjYXB0dXJlQ29weSh2aWV3LCB0ZXh0KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5jb25zdCBpc0ZvY3VzQ2hhbmdlID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG5mdW5jdGlvbiBmb2N1c0NoYW5nZVRyYW5zYWN0aW9uKHN0YXRlLCBmb2N1cykge1xuICAgIGxldCBlZmZlY3RzID0gW107XG4gICAgZm9yIChsZXQgZ2V0RWZmZWN0IG9mIHN0YXRlLmZhY2V0KGZvY3VzQ2hhbmdlRWZmZWN0KSkge1xuICAgICAgICBsZXQgZWZmZWN0ID0gZ2V0RWZmZWN0KHN0YXRlLCBmb2N1cyk7XG4gICAgICAgIGlmIChlZmZlY3QpXG4gICAgICAgICAgICBlZmZlY3RzLnB1c2goZWZmZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIGVmZmVjdHMgPyBzdGF0ZS51cGRhdGUoeyBlZmZlY3RzLCBhbm5vdGF0aW9uczogaXNGb2N1c0NoYW5nZS5vZih0cnVlKSB9KSA6IG51bGw7XG59XG5mdW5jdGlvbiB1cGRhdGVGb3JGb2N1c0NoYW5nZSh2aWV3KSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGxldCBmb2N1cyA9IHZpZXcuaGFzRm9jdXM7XG4gICAgICAgIGlmIChmb2N1cyAhPSB2aWV3LmlucHV0U3RhdGUubm90aWZpZWRGb2N1c2VkKSB7XG4gICAgICAgICAgICBsZXQgdHIgPSBmb2N1c0NoYW5nZVRyYW5zYWN0aW9uKHZpZXcuc3RhdGUsIGZvY3VzKTtcbiAgICAgICAgICAgIGlmICh0cilcbiAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB2aWV3LnVwZGF0ZShbXSk7XG4gICAgICAgIH1cbiAgICB9LCAxMCk7XG59XG5vYnNlcnZlcnMuZm9jdXMgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUubGFzdEZvY3VzVGltZSA9IERhdGUubm93KCk7XG4gICAgLy8gV2hlbiBmb2N1c2luZyByZXNldCB0aGUgc2Nyb2xsIHBvc2l0aW9uLCBtb3ZlIGl0IGJhY2sgdG8gd2hlcmUgaXQgd2FzXG4gICAgaWYgKCF2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgJiYgKHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2Nyb2xsVG9wIHx8IHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2Nyb2xsTGVmdCkpIHtcbiAgICAgICAgdmlldy5zY3JvbGxET00uc2Nyb2xsVG9wID0gdmlldy5pbnB1dFN0YXRlLmxhc3RTY3JvbGxUb3A7XG4gICAgICAgIHZpZXcuc2Nyb2xsRE9NLnNjcm9sbExlZnQgPSB2aWV3LmlucHV0U3RhdGUubGFzdFNjcm9sbExlZnQ7XG4gICAgfVxuICAgIHVwZGF0ZUZvckZvY3VzQ2hhbmdlKHZpZXcpO1xufTtcbm9ic2VydmVycy5ibHVyID0gdmlldyA9PiB7XG4gICAgdmlldy5vYnNlcnZlci5jbGVhclNlbGVjdGlvblJhbmdlKCk7XG4gICAgdXBkYXRlRm9yRm9jdXNDaGFuZ2Uodmlldyk7XG59O1xub2JzZXJ2ZXJzLmNvbXBvc2l0aW9uc3RhcnQgPSBvYnNlcnZlcnMuY29tcG9zaXRpb251cGRhdGUgPSB2aWV3ID0+IHtcbiAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPT0gbnVsbClcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSB0cnVlO1xuICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nIDwgMCkge1xuICAgICAgICAvLyBGSVhNRSBwb3NzaWJseSBzZXQgYSB0aW1lb3V0IHRvIGNsZWFyIGl0IGFnYWluIG9uIEFuZHJvaWRcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA9IDA7XG4gICAgfVxufTtcbm9ic2VydmVycy5jb21wb3NpdGlvbmVuZCA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPSAtMTtcbiAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25FbmRlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25QZW5kaW5nS2V5ID0gdHJ1ZTtcbiAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlID0gdmlldy5vYnNlcnZlci5wZW5kaW5nUmVjb3JkcygpLmxlbmd0aCA+IDA7XG4gICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSBudWxsO1xuICAgIGlmIChicm93c2VyLmNocm9tZSAmJiBicm93c2VyLmFuZHJvaWQpIHtcbiAgICAgICAgLy8gRGVsYXkgZmx1c2hpbmcgZm9yIGEgYml0IG9uIEFuZHJvaWQgYmVjYXVzZSBpdCdsbCBvZnRlbiBmaXJlIGFcbiAgICAgICAgLy8gYnVuY2ggb2YgY29udHJhZGljdG9yeSBjaGFuZ2VzIGluIGEgcm93IGF0IGVuZCBvZiBjb21wb3NpdG9uXG4gICAgICAgIHZpZXcub2JzZXJ2ZXIuZmx1c2hTb29uKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2UpIHtcbiAgICAgICAgLy8gSWYgd2UgZm91bmQgcGVuZGluZyByZWNvcmRzLCBzY2hlZHVsZSBhIGZsdXNoLlxuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHZpZXcub2JzZXJ2ZXIuZmx1c2goKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UsIG1ha2Ugc3VyZSB0aGF0LCBpZiBubyBjaGFuZ2VzIGNvbWUgaW4gc29vbiwgdGhlXG4gICAgICAgIC8vIGNvbXBvc2l0aW9uIHZpZXcgaXMgY2xlYXJlZC5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA8IDAgJiYgdmlldy5kb2NWaWV3Lmhhc0NvbXBvc2l0aW9uKVxuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlKFtdKTtcbiAgICAgICAgfSwgNTApO1xuICAgIH1cbn07XG5vYnNlcnZlcnMuY29udGV4dG1lbnUgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUubGFzdENvbnRleHRNZW51ID0gRGF0ZS5ub3coKTtcbn07XG5oYW5kbGVycy5iZWZvcmVpbnB1dCA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICAvLyBCZWNhdXNlIENocm9tZSBBbmRyb2lkIGRvZXNuJ3QgZmlyZSB1c2VmdWwga2V5IGV2ZW50cywgdXNlXG4gICAgLy8gYmVmb3JlaW5wdXQgdG8gZGV0ZWN0IGJhY2tzcGFjZSAoYW5kIHBvc3NpYmx5IGVudGVyIGFuZCBkZWxldGUsXG4gICAgLy8gYnV0IHRob3NlIHVzdWFsbHkgZG9uJ3QgZXZlbiBzZWVtIHRvIGZpcmUgYmVmb3JlaW5wdXQgZXZlbnRzIGF0XG4gICAgLy8gdGhlIG1vbWVudCkgYW5kIGZha2UgYSBrZXkgZXZlbnQgZm9yIGl0LlxuICAgIC8vXG4gICAgLy8gKHByZXZlbnREZWZhdWx0IG9uIGJlZm9yZWlucHV0LCB0aG91Z2ggc3VwcG9ydGVkIGluIHRoZSBzcGVjLFxuICAgIC8vIHNlZW1zIHRvIGRvIG5vdGhpbmcgYXQgYWxsIG9uIENocm9tZSkuXG4gICAgbGV0IHBlbmRpbmc7XG4gICAgaWYgKGJyb3dzZXIuY2hyb21lICYmIGJyb3dzZXIuYW5kcm9pZCAmJiAocGVuZGluZyA9IFBlbmRpbmdLZXlzLmZpbmQoa2V5ID0+IGtleS5pbnB1dFR5cGUgPT0gZXZlbnQuaW5wdXRUeXBlKSkpIHtcbiAgICAgICAgdmlldy5vYnNlcnZlci5kZWxheUFuZHJvaWRLZXkocGVuZGluZy5rZXksIHBlbmRpbmcua2V5Q29kZSk7XG4gICAgICAgIGlmIChwZW5kaW5nLmtleSA9PSBcIkJhY2tzcGFjZVwiIHx8IHBlbmRpbmcua2V5ID09IFwiRGVsZXRlXCIpIHtcbiAgICAgICAgICAgIGxldCBzdGFydFZpZXdIZWlnaHQgPSAoKF9hID0gd2luZG93LnZpc3VhbFZpZXdwb3J0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVpZ2h0KSB8fCAwO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIC8vIEJhY2tzcGFjaW5nIG5lYXIgdW5lZGl0YWJsZSBub2RlcyBvbiBDaHJvbWUgQW5kcm9pZCBzb21ldGltZXNcbiAgICAgICAgICAgICAgICAvLyBjbG9zZXMgdGhlIHZpcnR1YWwga2V5Ym9hcmQuIFRoaXMgdHJpZXMgdG8gY3J1ZGVseSBkZXRlY3RcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGFuZCByZWZvY3VzIHRvIGdldCBpdCBiYWNrLlxuICAgICAgICAgICAgICAgIGlmICgoKChfYSA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlaWdodCkgfHwgMCkgPiBzdGFydFZpZXdIZWlnaHQgKyAxMCAmJiB2aWV3Lmhhc0ZvY3VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuY29udGVudERPTS5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5jb25zdCBhcHBsaWVkRmlyZWZveEhhY2sgPSAvKkBfX1BVUkVfXyovbmV3IFNldDtcbi8vIEluIEZpcmVmb3gsIHdoZW4gY3V0L2NvcHkgaGFuZGxlcnMgYXJlIGFkZGVkIHRvIHRoZSBkb2N1bWVudCwgdGhhdFxuLy8gc29tZWhvdyBhdm9pZHMgYSBidWcgd2hlcmUgdGhvc2UgZXZlbnRzIGFyZW4ndCBmaXJlZCB3aGVuIHRoZVxuLy8gc2VsZWN0aW9uIGlzIGVtcHR5LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NvZGVtaXJyb3IvZGV2L2lzc3Vlcy8xMDgyXG4vLyBhbmQgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTk1OTYxXG5mdW5jdGlvbiBmaXJlZm94Q29weUN1dEhhY2soZG9jKSB7XG4gICAgaWYgKCFhcHBsaWVkRmlyZWZveEhhY2suaGFzKGRvYykpIHtcbiAgICAgICAgYXBwbGllZEZpcmVmb3hIYWNrLmFkZChkb2MpO1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcImNvcHlcIiwgKCkgPT4geyB9KTtcbiAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoXCJjdXRcIiwgKCkgPT4geyB9KTtcbiAgICB9XG59XG5cbmNvbnN0IHdyYXBwaW5nV2hpdGVTcGFjZSA9IFtcInByZS13cmFwXCIsIFwibm9ybWFsXCIsIFwicHJlLWxpbmVcIiwgXCJicmVhay1zcGFjZXNcIl07XG5jbGFzcyBIZWlnaHRPcmFjbGUge1xuICAgIGNvbnN0cnVjdG9yKGxpbmVXcmFwcGluZykge1xuICAgICAgICB0aGlzLmxpbmVXcmFwcGluZyA9IGxpbmVXcmFwcGluZztcbiAgICAgICAgdGhpcy5kb2MgPSBUZXh0LmVtcHR5O1xuICAgICAgICB0aGlzLmhlaWdodFNhbXBsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5saW5lSGVpZ2h0ID0gMTQ7IC8vIFRoZSBoZWlnaHQgb2YgYW4gZW50aXJlIGxpbmUgKGxpbmUtaGVpZ2h0KVxuICAgICAgICB0aGlzLmNoYXJXaWR0aCA9IDc7XG4gICAgICAgIHRoaXMudGV4dEhlaWdodCA9IDE0OyAvLyBUaGUgaGVpZ2h0IG9mIHRoZSBhY3R1YWwgZm9udCAoZm9udC1zaXplKVxuICAgICAgICB0aGlzLmxpbmVMZW5ndGggPSAzMDtcbiAgICAgICAgLy8gVXNlZCB0byB0cmFjaywgZHVyaW5nIHVwZGF0ZUhlaWdodCwgaWYgYW55IGFjdHVhbCBoZWlnaHRzIGNoYW5nZWRcbiAgICAgICAgdGhpcy5oZWlnaHRDaGFuZ2VkID0gZmFsc2U7XG4gICAgfVxuICAgIGhlaWdodEZvckdhcChmcm9tLCB0bykge1xuICAgICAgICBsZXQgbGluZXMgPSB0aGlzLmRvYy5saW5lQXQodG8pLm51bWJlciAtIHRoaXMuZG9jLmxpbmVBdChmcm9tKS5udW1iZXIgKyAxO1xuICAgICAgICBpZiAodGhpcy5saW5lV3JhcHBpbmcpXG4gICAgICAgICAgICBsaW5lcyArPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKCh0byAtIGZyb20pIC0gKGxpbmVzICogdGhpcy5saW5lTGVuZ3RoICogMC41KSkgLyB0aGlzLmxpbmVMZW5ndGgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUhlaWdodCAqIGxpbmVzO1xuICAgIH1cbiAgICBoZWlnaHRGb3JMaW5lKGxlbmd0aCkge1xuICAgICAgICBpZiAoIXRoaXMubGluZVdyYXBwaW5nKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGluZUhlaWdodDtcbiAgICAgICAgbGV0IGxpbmVzID0gMSArIE1hdGgubWF4KDAsIE1hdGguY2VpbCgobGVuZ3RoIC0gdGhpcy5saW5lTGVuZ3RoKSAvICh0aGlzLmxpbmVMZW5ndGggLSA1KSkpO1xuICAgICAgICByZXR1cm4gbGluZXMgKiB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgfVxuICAgIHNldERvYyhkb2MpIHsgdGhpcy5kb2MgPSBkb2M7IHJldHVybiB0aGlzOyB9XG4gICAgbXVzdFJlZnJlc2hGb3JXcmFwcGluZyh3aGl0ZVNwYWNlKSB7XG4gICAgICAgIHJldHVybiAod3JhcHBpbmdXaGl0ZVNwYWNlLmluZGV4T2Yod2hpdGVTcGFjZSkgPiAtMSkgIT0gdGhpcy5saW5lV3JhcHBpbmc7XG4gICAgfVxuICAgIG11c3RSZWZyZXNoRm9ySGVpZ2h0cyhsaW5lSGVpZ2h0cykge1xuICAgICAgICBsZXQgbmV3SGVpZ2h0ID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZUhlaWdodHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBoID0gbGluZUhlaWdodHNbaV07XG4gICAgICAgICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5oZWlnaHRTYW1wbGVzW01hdGguZmxvb3IoaCAqIDEwKV0pIHsgLy8gUm91bmQgdG8gLjEgcGl4ZWxzXG4gICAgICAgICAgICAgICAgbmV3SGVpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodFNhbXBsZXNbTWF0aC5mbG9vcihoICogMTApXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0hlaWdodDtcbiAgICB9XG4gICAgcmVmcmVzaCh3aGl0ZVNwYWNlLCBsaW5lSGVpZ2h0LCBjaGFyV2lkdGgsIHRleHRIZWlnaHQsIGxpbmVMZW5ndGgsIGtub3duSGVpZ2h0cykge1xuICAgICAgICBsZXQgbGluZVdyYXBwaW5nID0gd3JhcHBpbmdXaGl0ZVNwYWNlLmluZGV4T2Yod2hpdGVTcGFjZSkgPiAtMTtcbiAgICAgICAgbGV0IGNoYW5nZWQgPSBNYXRoLnJvdW5kKGxpbmVIZWlnaHQpICE9IE1hdGgucm91bmQodGhpcy5saW5lSGVpZ2h0KSB8fCB0aGlzLmxpbmVXcmFwcGluZyAhPSBsaW5lV3JhcHBpbmc7XG4gICAgICAgIHRoaXMubGluZVdyYXBwaW5nID0gbGluZVdyYXBwaW5nO1xuICAgICAgICB0aGlzLmxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgICB0aGlzLmNoYXJXaWR0aCA9IGNoYXJXaWR0aDtcbiAgICAgICAgdGhpcy50ZXh0SGVpZ2h0ID0gdGV4dEhlaWdodDtcbiAgICAgICAgdGhpcy5saW5lTGVuZ3RoID0gbGluZUxlbmd0aDtcbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0U2FtcGxlcyA9IHt9O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrbm93bkhlaWdodHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgaCA9IGtub3duSGVpZ2h0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoaCA8IDApXG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0U2FtcGxlc1tNYXRoLmZsb29yKGggKiAxMCldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9XG59XG4vLyBUaGlzIG9iamVjdCBpcyB1c2VkIGJ5IGB1cGRhdGVIZWlnaHRgIHRvIG1ha2UgRE9NIG1lYXN1cmVtZW50c1xuLy8gYXJyaXZlIGF0IHRoZSByaWdodCBuaWRlcy4gVGhlIGBoZWlnaHRzYCBhcnJheSBpcyBhIHNlcXVlbmNlIG9mXG4vLyBibG9jayBoZWlnaHRzLCBzdGFydGluZyBmcm9tIHBvc2l0aW9uIGBmcm9tYC5cbmNsYXNzIE1lYXN1cmVkSGVpZ2h0cyB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgaGVpZ2h0cykge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLmhlaWdodHMgPSBoZWlnaHRzO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgZ2V0IG1vcmUoKSB7IHJldHVybiB0aGlzLmluZGV4IDwgdGhpcy5oZWlnaHRzLmxlbmd0aDsgfVxufVxuLyoqXG5SZWNvcmQgdXNlZCB0byByZXByZXNlbnQgaW5mb3JtYXRpb24gYWJvdXQgYSBibG9jay1sZXZlbCBlbGVtZW50XG5pbiB0aGUgZWRpdG9yIHZpZXcuXG4qL1xuY2xhc3MgQmxvY2tJbmZvIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiB0aGUgZWxlbWVudCBpbiB0aGUgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgbGVuZ3RoIG9mIHRoZSBlbGVtZW50LlxuICAgICovXG4gICAgbGVuZ3RoLCBcbiAgICAvKipcbiAgICBUaGUgdG9wIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50IChyZWxhdGl2ZSB0byB0aGUgdG9wIG9mIHRoZVxuICAgIGRvY3VtZW50KS5cbiAgICAqL1xuICAgIHRvcCwgXG4gICAgLyoqXG4gICAgSXRzIGhlaWdodC5cbiAgICAqL1xuICAgIGhlaWdodCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsIFdlaXJkIHBhY2tlZCBmaWVsZCB0aGF0IGhvbGRzIGFuIGFycmF5IG9mIGNoaWxkcmVuXG4gICAgZm9yIGNvbXBvc2l0ZSBibG9ja3MsIGEgZGVjb3JhdGlvbiBmb3IgYmxvY2sgd2lkZ2V0cywgYW5kIGFcbiAgICBudW1iZXIgaW5kaWNhdGluZyB0aGUgYW1vdW50IG9mIHdpZGdldC1jcmVhdGUgbGluZSBicmVha3MgZm9yXG4gICAgdGV4dCBibG9ja3MuXG4gICAgKi9cbiAgICBfY29udGVudCkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLl9jb250ZW50ID0gX2NvbnRlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSB0eXBlIG9mIGVsZW1lbnQgdGhpcyBpcy4gV2hlbiBxdWVyeWluZyBsaW5lcywgdGhpcyBtYXkgYmVcbiAgICBhbiBhcnJheSBvZiBhbGwgdGhlIGJsb2NrcyB0aGF0IG1ha2UgdXAgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLl9jb250ZW50ID09IFwibnVtYmVyXCIgPyBCbG9ja1R5cGUuVGV4dCA6XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHRoaXMuX2NvbnRlbnQpID8gdGhpcy5fY29udGVudCA6IHRoaXMuX2NvbnRlbnQudHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgZWxlbWVudCBhcyBhIGRvY3VtZW50IHBvc2l0aW9uLlxuICAgICovXG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy5mcm9tICsgdGhpcy5sZW5ndGg7IH1cbiAgICAvKipcbiAgICBUaGUgYm90dG9tIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50LlxuICAgICovXG4gICAgZ2V0IGJvdHRvbSgpIHsgcmV0dXJuIHRoaXMudG9wICsgdGhpcy5oZWlnaHQ7IH1cbiAgICAvKipcbiAgICBJZiB0aGlzIGlzIGEgd2lkZ2V0IGJsb2NrLCB0aGlzIHdpbGwgcmV0dXJuIHRoZSB3aWRnZXRcbiAgICBhc3NvY2lhdGVkIHdpdGggaXQuXG4gICAgKi9cbiAgICBnZXQgd2lkZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudCBpbnN0YW5jZW9mIFBvaW50RGVjb3JhdGlvbiA/IHRoaXMuX2NvbnRlbnQud2lkZ2V0IDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgSWYgdGhpcyBpcyBhIHRleHRibG9jaywgdGhpcyBob2xkcyB0aGUgbnVtYmVyIG9mIGxpbmUgYnJlYWtzXG4gICAgdGhhdCBhcHBlYXIgaW4gd2lkZ2V0cyBpbnNpZGUgdGhlIGJsb2NrLlxuICAgICovXG4gICAgZ2V0IHdpZGdldExpbmVCcmVha3MoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5fY29udGVudCA9PSBcIm51bWJlclwiID8gdGhpcy5fY29udGVudCA6IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgam9pbihvdGhlcikge1xuICAgICAgICBsZXQgY29udGVudCA9IChBcnJheS5pc0FycmF5KHRoaXMuX2NvbnRlbnQpID8gdGhpcy5fY29udGVudCA6IFt0aGlzXSlcbiAgICAgICAgICAgIC5jb25jYXQoQXJyYXkuaXNBcnJheShvdGhlci5fY29udGVudCkgPyBvdGhlci5fY29udGVudCA6IFtvdGhlcl0pO1xuICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyh0aGlzLmZyb20sIHRoaXMubGVuZ3RoICsgb3RoZXIubGVuZ3RoLCB0aGlzLnRvcCwgdGhpcy5oZWlnaHQgKyBvdGhlci5oZWlnaHQsIGNvbnRlbnQpO1xuICAgIH1cbn1cbnZhciBRdWVyeVR5cGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChRdWVyeVR5cGUpIHtcbiAgICBRdWVyeVR5cGVbUXVlcnlUeXBlW1wiQnlQb3NcIl0gPSAwXSA9IFwiQnlQb3NcIjtcbiAgICBRdWVyeVR5cGVbUXVlcnlUeXBlW1wiQnlIZWlnaHRcIl0gPSAxXSA9IFwiQnlIZWlnaHRcIjtcbiAgICBRdWVyeVR5cGVbUXVlcnlUeXBlW1wiQnlQb3NOb0hlaWdodFwiXSA9IDJdID0gXCJCeVBvc05vSGVpZ2h0XCI7XG5yZXR1cm4gUXVlcnlUeXBlfSkoUXVlcnlUeXBlIHx8IChRdWVyeVR5cGUgPSB7fSkpO1xuY29uc3QgRXBzaWxvbiA9IDFlLTM7XG5jbGFzcyBIZWlnaHRNYXAge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgLy8gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvdmVyZWRcbiAgICBoZWlnaHQsIC8vIEhlaWdodCBvZiB0aGlzIHBhcnQgb2YgdGhlIGRvY3VtZW50XG4gICAgZmxhZ3MgPSAyIC8qIEZsYWcuT3V0ZGF0ZWQgKi8pIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgfVxuICAgIGdldCBvdXRkYXRlZCgpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgMiAvKiBGbGFnLk91dGRhdGVkICovKSA+IDA7IH1cbiAgICBzZXQgb3V0ZGF0ZWQodmFsdWUpIHsgdGhpcy5mbGFncyA9ICh2YWx1ZSA/IDIgLyogRmxhZy5PdXRkYXRlZCAqLyA6IDApIHwgKHRoaXMuZmxhZ3MgJiB+MiAvKiBGbGFnLk91dGRhdGVkICovKTsgfVxuICAgIHNldEhlaWdodChvcmFjbGUsIGhlaWdodCkge1xuICAgICAgICBpZiAodGhpcy5oZWlnaHQgIT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5oZWlnaHQgLSBoZWlnaHQpID4gRXBzaWxvbilcbiAgICAgICAgICAgICAgICBvcmFjbGUuaGVpZ2h0Q2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBCYXNlIGNhc2UgaXMgdG8gcmVwbGFjZSBhIGxlYWYgbm9kZSwgd2hpY2ggc2ltcGx5IGJ1aWxkcyBhIHRyZWVcbiAgICAvLyBmcm9tIHRoZSBuZXcgbm9kZXMgYW5kIHJldHVybnMgdGhhdCAoSGVpZ2h0TWFwQnJhbmNoIGFuZFxuICAgIC8vIEhlaWdodE1hcEdhcCBvdmVycmlkZSB0aGlzIHRvIGFjdHVhbGx5IHVzZSBmcm9tL3RvKVxuICAgIHJlcGxhY2UoX2Zyb20sIF90bywgbm9kZXMpIHtcbiAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZihub2Rlcyk7XG4gICAgfVxuICAgIC8vIEFnYWluLCB0aGVzZSBhcmUgYmFzZSBjYXNlcywgYW5kIGFyZSBvdmVycmlkZGVuIGZvciBicmFuY2ggYW5kIGdhcCBub2Rlcy5cbiAgICBkZWNvbXBvc2VMZWZ0KF90bywgcmVzdWx0KSB7IHJlc3VsdC5wdXNoKHRoaXMpOyB9XG4gICAgZGVjb21wb3NlUmlnaHQoX2Zyb20sIHJlc3VsdCkgeyByZXN1bHQucHVzaCh0aGlzKTsgfVxuICAgIGFwcGx5Q2hhbmdlcyhkZWNvcmF0aW9ucywgb2xkRG9jLCBvcmFjbGUsIGNoYW5nZXMpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcywgZG9jID0gb3JhY2xlLmRvYztcbiAgICAgICAgZm9yIChsZXQgaSA9IGNoYW5nZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB7IGZyb21BLCB0b0EsIGZyb21CLCB0b0IgfSA9IGNoYW5nZXNbaV07XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBtZS5saW5lQXQoZnJvbUEsIFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0LCBvcmFjbGUuc2V0RG9jKG9sZERvYyksIDAsIDApO1xuICAgICAgICAgICAgbGV0IGVuZCA9IHN0YXJ0LnRvID49IHRvQSA/IHN0YXJ0IDogbWUubGluZUF0KHRvQSwgUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQsIG9yYWNsZSwgMCwgMCk7XG4gICAgICAgICAgICB0b0IgKz0gZW5kLnRvIC0gdG9BO1xuICAgICAgICAgICAgdG9BID0gZW5kLnRvO1xuICAgICAgICAgICAgd2hpbGUgKGkgPiAwICYmIHN0YXJ0LmZyb20gPD0gY2hhbmdlc1tpIC0gMV0udG9BKSB7XG4gICAgICAgICAgICAgICAgZnJvbUEgPSBjaGFuZ2VzW2kgLSAxXS5mcm9tQTtcbiAgICAgICAgICAgICAgICBmcm9tQiA9IGNoYW5nZXNbaSAtIDFdLmZyb21CO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUEgPCBzdGFydC5mcm9tKVxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG1lLmxpbmVBdChmcm9tQSwgUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQsIG9yYWNsZSwgMCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcm9tQiArPSBzdGFydC5mcm9tIC0gZnJvbUE7XG4gICAgICAgICAgICBmcm9tQSA9IHN0YXJ0LmZyb207XG4gICAgICAgICAgICBsZXQgbm9kZXMgPSBOb2RlQnVpbGRlci5idWlsZChvcmFjbGUuc2V0RG9jKGRvYyksIGRlY29yYXRpb25zLCBmcm9tQiwgdG9CKTtcbiAgICAgICAgICAgIG1lID0gbWUucmVwbGFjZShmcm9tQSwgdG9BLCBub2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lLnVwZGF0ZUhlaWdodChvcmFjbGUsIDApO1xuICAgIH1cbiAgICBzdGF0aWMgZW1wdHkoKSB7IHJldHVybiBuZXcgSGVpZ2h0TWFwVGV4dCgwLCAwKTsgfVxuICAgIC8vIG5vZGVzIHVzZXMgbnVsbCB2YWx1ZXMgdG8gaW5kaWNhdGUgdGhlIHBvc2l0aW9uIG9mIGxpbmUgYnJlYWtzLlxuICAgIC8vIFRoZXJlIGFyZSBuZXZlciBsaW5lIGJyZWFrcyBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBhcnJheSwgb3JcbiAgICAvLyB0d28gbGluZSBicmVha3MgbmV4dCB0byBlYWNoIG90aGVyLCBhbmQgdGhlIGFycmF5IGlzbid0IGFsbG93ZWRcbiAgICAvLyB0byBiZSBlbXB0eSAoc2FtZSByZXN0cmljdGlvbnMgYXMgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGJ1aWxkZXIpLlxuICAgIHN0YXRpYyBvZihub2Rlcykge1xuICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09IDEpXG4gICAgICAgICAgICByZXR1cm4gbm9kZXNbMF07XG4gICAgICAgIGxldCBpID0gMCwgaiA9IG5vZGVzLmxlbmd0aCwgYmVmb3JlID0gMCwgYWZ0ZXIgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoaSA9PSBqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZSA+IGFmdGVyICogMikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3BsaXQgPSBub2Rlc1tpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGxpdC5icmVhaylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZSgtLWksIDEsIHNwbGl0LmxlZnQsIG51bGwsIHNwbGl0LnJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKC0taSwgMSwgc3BsaXQubGVmdCwgc3BsaXQucmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBqICs9IDEgKyBzcGxpdC5icmVhaztcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlIC09IHNwbGl0LnNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFmdGVyID4gYmVmb3JlICogMikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3BsaXQgPSBub2Rlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwbGl0LmJyZWFrKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGosIDEsIHNwbGl0LmxlZnQsIG51bGwsIHNwbGl0LnJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGosIDEsIHNwbGl0LmxlZnQsIHNwbGl0LnJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgaiArPSAyICsgc3BsaXQuYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyIC09IHNwbGl0LnNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiZWZvcmUgPCBhZnRlcikge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZXNbaSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dClcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlICs9IG5leHQuc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZXNbLS1qXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dClcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgKz0gbmV4dC5zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBicmsgPSAwO1xuICAgICAgICBpZiAobm9kZXNbaSAtIDFdID09IG51bGwpIHtcbiAgICAgICAgICAgIGJyayA9IDE7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZXNbaV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgYnJrID0gMTtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEhlaWdodE1hcEJyYW5jaChIZWlnaHRNYXAub2Yobm9kZXMuc2xpY2UoMCwgaSkpLCBicmssIEhlaWdodE1hcC5vZihub2Rlcy5zbGljZShqKSkpO1xuICAgIH1cbn1cbkhlaWdodE1hcC5wcm90b3R5cGUuc2l6ZSA9IDE7XG5jbGFzcyBIZWlnaHRNYXBCbG9jayBleHRlbmRzIEhlaWdodE1hcCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBoZWlnaHQsIGRlY28pIHtcbiAgICAgICAgc3VwZXIobGVuZ3RoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmRlY28gPSBkZWNvO1xuICAgIH1cbiAgICBibG9ja0F0KF9oZWlnaHQsIF9vcmFjbGUsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKG9mZnNldCwgdGhpcy5sZW5ndGgsIHRvcCwgdGhpcy5oZWlnaHQsIHRoaXMuZGVjbyB8fCAwKTtcbiAgICB9XG4gICAgbGluZUF0KF92YWx1ZSwgX3R5cGUsIG9yYWNsZSwgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2tBdCgwLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgZm9yRWFjaExpbmUoZnJvbSwgdG8sIG9yYWNsZSwgdG9wLCBvZmZzZXQsIGYpIHtcbiAgICAgICAgaWYgKGZyb20gPD0gb2Zmc2V0ICsgdGhpcy5sZW5ndGggJiYgdG8gPj0gb2Zmc2V0KVxuICAgICAgICAgICAgZih0aGlzLmJsb2NrQXQoMCwgb3JhY2xlLCB0b3AsIG9mZnNldCkpO1xuICAgIH1cbiAgICB1cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQgPSAwLCBfZm9yY2UgPSBmYWxzZSwgbWVhc3VyZWQpIHtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gb2Zmc2V0ICYmIG1lYXN1cmVkLm1vcmUpXG4gICAgICAgICAgICB0aGlzLnNldEhlaWdodChvcmFjbGUsIG1lYXN1cmVkLmhlaWdodHNbbWVhc3VyZWQuaW5kZXgrK10pO1xuICAgICAgICB0aGlzLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIGBibG9jaygke3RoaXMubGVuZ3RofSlgOyB9XG59XG5jbGFzcyBIZWlnaHRNYXBUZXh0IGV4dGVuZHMgSGVpZ2h0TWFwQmxvY2sge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGxlbmd0aCwgaGVpZ2h0LCBudWxsKTtcbiAgICAgICAgdGhpcy5jb2xsYXBzZWQgPSAwOyAvLyBBbW91bnQgb2YgY29sbGFwc2VkIGNvbnRlbnQgaW4gdGhlIGxpbmVcbiAgICAgICAgdGhpcy53aWRnZXRIZWlnaHQgPSAwOyAvLyBNYXhpbXVtIGlubGluZSB3aWRnZXQgaGVpZ2h0XG4gICAgICAgIHRoaXMuYnJlYWtzID0gMDsgLy8gTnVtYmVyIG9mIHdpZGdldC1pbnRyb2R1Y2VkIGxpbmUgYnJlYWtzIG9uIHRoZSBsaW5lXG4gICAgfVxuICAgIGJsb2NrQXQoX2hlaWdodCwgX29yYWNsZSwgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8ob2Zmc2V0LCB0aGlzLmxlbmd0aCwgdG9wLCB0aGlzLmhlaWdodCwgdGhpcy5icmVha3MpO1xuICAgIH1cbiAgICByZXBsYWNlKF9mcm9tLCBfdG8sIG5vZGVzKSB7XG4gICAgICAgIGxldCBub2RlID0gbm9kZXNbMF07XG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT0gMSAmJiAobm9kZSBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQgfHwgbm9kZSBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcCAmJiAobm9kZS5mbGFncyAmIDQgLyogRmxhZy5TaW5nbGVMaW5lICovKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKHRoaXMubGVuZ3RoIC0gbm9kZS5sZW5ndGgpIDwgMTApIHtcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwKVxuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXcgSGVpZ2h0TWFwVGV4dChub2RlLmxlbmd0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG5vZGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMub3V0ZGF0ZWQpXG4gICAgICAgICAgICAgICAgbm9kZS5vdXRkYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKG5vZGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQgPSAwLCBmb3JjZSA9IGZhbHNlLCBtZWFzdXJlZCkge1xuICAgICAgICBpZiAobWVhc3VyZWQgJiYgbWVhc3VyZWQuZnJvbSA8PSBvZmZzZXQgJiYgbWVhc3VyZWQubW9yZSlcbiAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KG9yYWNsZSwgbWVhc3VyZWQuaGVpZ2h0c1ttZWFzdXJlZC5pbmRleCsrXSk7XG4gICAgICAgIGVsc2UgaWYgKGZvcmNlIHx8IHRoaXMub3V0ZGF0ZWQpXG4gICAgICAgICAgICB0aGlzLnNldEhlaWdodChvcmFjbGUsIE1hdGgubWF4KHRoaXMud2lkZ2V0SGVpZ2h0LCBvcmFjbGUuaGVpZ2h0Rm9yTGluZSh0aGlzLmxlbmd0aCAtIHRoaXMuY29sbGFwc2VkKSkgK1xuICAgICAgICAgICAgICAgIHRoaXMuYnJlYWtzICogb3JhY2xlLmxpbmVIZWlnaHQpO1xuICAgICAgICB0aGlzLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBsaW5lKCR7dGhpcy5sZW5ndGh9JHt0aGlzLmNvbGxhcHNlZCA/IC10aGlzLmNvbGxhcHNlZCA6IFwiXCJ9JHt0aGlzLndpZGdldEhlaWdodCA/IFwiOlwiICsgdGhpcy53aWRnZXRIZWlnaHQgOiBcIlwifSlgO1xuICAgIH1cbn1cbmNsYXNzIEhlaWdodE1hcEdhcCBleHRlbmRzIEhlaWdodE1hcCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7IHN1cGVyKGxlbmd0aCwgMCk7IH1cbiAgICBoZWlnaHRNZXRyaWNzKG9yYWNsZSwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBmaXJzdExpbmUgPSBvcmFjbGUuZG9jLmxpbmVBdChvZmZzZXQpLm51bWJlciwgbGFzdExpbmUgPSBvcmFjbGUuZG9jLmxpbmVBdChvZmZzZXQgKyB0aGlzLmxlbmd0aCkubnVtYmVyO1xuICAgICAgICBsZXQgbGluZXMgPSBsYXN0TGluZSAtIGZpcnN0TGluZSArIDE7XG4gICAgICAgIGxldCBwZXJMaW5lLCBwZXJDaGFyID0gMDtcbiAgICAgICAgaWYgKG9yYWNsZS5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgICAgIGxldCB0b3RhbFBlckxpbmUgPSBNYXRoLm1pbih0aGlzLmhlaWdodCwgb3JhY2xlLmxpbmVIZWlnaHQgKiBsaW5lcyk7XG4gICAgICAgICAgICBwZXJMaW5lID0gdG90YWxQZXJMaW5lIC8gbGluZXM7XG4gICAgICAgICAgICBpZiAodGhpcy5sZW5ndGggPiBsaW5lcyArIDEpXG4gICAgICAgICAgICAgICAgcGVyQ2hhciA9ICh0aGlzLmhlaWdodCAtIHRvdGFsUGVyTGluZSkgLyAodGhpcy5sZW5ndGggLSBsaW5lcyAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGVyTGluZSA9IHRoaXMuaGVpZ2h0IC8gbGluZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZmlyc3RMaW5lLCBsYXN0TGluZSwgcGVyTGluZSwgcGVyQ2hhciB9O1xuICAgIH1cbiAgICBibG9ja0F0KGhlaWdodCwgb3JhY2xlLCB0b3AsIG9mZnNldCkge1xuICAgICAgICBsZXQgeyBmaXJzdExpbmUsIGxhc3RMaW5lLCBwZXJMaW5lLCBwZXJDaGFyIH0gPSB0aGlzLmhlaWdodE1ldHJpY3Mob3JhY2xlLCBvZmZzZXQpO1xuICAgICAgICBpZiAob3JhY2xlLmxpbmVXcmFwcGluZykge1xuICAgICAgICAgICAgbGV0IGd1ZXNzID0gb2Zmc2V0ICsgTWF0aC5yb3VuZChNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoaGVpZ2h0IC0gdG9wKSAvIHRoaXMuaGVpZ2h0KSkgKiB0aGlzLmxlbmd0aCk7XG4gICAgICAgICAgICBsZXQgbGluZSA9IG9yYWNsZS5kb2MubGluZUF0KGd1ZXNzKSwgbGluZUhlaWdodCA9IHBlckxpbmUgKyBsaW5lLmxlbmd0aCAqIHBlckNoYXI7XG4gICAgICAgICAgICBsZXQgbGluZVRvcCA9IE1hdGgubWF4KHRvcCwgaGVpZ2h0IC0gbGluZUhlaWdodCAvIDIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8obGluZS5mcm9tLCBsaW5lLmxlbmd0aCwgbGluZVRvcCwgbGluZUhlaWdodCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKGxhc3RMaW5lIC0gZmlyc3RMaW5lLCBNYXRoLmZsb29yKChoZWlnaHQgLSB0b3ApIC8gcGVyTGluZSkpKTtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIGxlbmd0aCB9ID0gb3JhY2xlLmRvYy5saW5lKGZpcnN0TGluZSArIGxpbmUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8oZnJvbSwgbGVuZ3RoLCB0b3AgKyBwZXJMaW5lICogbGluZSwgcGVyTGluZSwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGluZUF0KHZhbHVlLCB0eXBlLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh0eXBlID09IFF1ZXJ5VHlwZS5CeUhlaWdodClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJsb2NrQXQodmFsdWUsIG9yYWNsZSwgdG9wLCBvZmZzZXQpO1xuICAgICAgICBpZiAodHlwZSA9PSBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCkge1xuICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IG9yYWNsZS5kb2MubGluZUF0KHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGZyb20sIHRvIC0gZnJvbSwgMCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgZmlyc3RMaW5lLCBwZXJMaW5lLCBwZXJDaGFyIH0gPSB0aGlzLmhlaWdodE1ldHJpY3Mob3JhY2xlLCBvZmZzZXQpO1xuICAgICAgICBsZXQgbGluZSA9IG9yYWNsZS5kb2MubGluZUF0KHZhbHVlKSwgbGluZUhlaWdodCA9IHBlckxpbmUgKyBsaW5lLmxlbmd0aCAqIHBlckNoYXI7XG4gICAgICAgIGxldCBsaW5lc0Fib3ZlID0gbGluZS5udW1iZXIgLSBmaXJzdExpbmU7XG4gICAgICAgIGxldCBsaW5lVG9wID0gdG9wICsgcGVyTGluZSAqIGxpbmVzQWJvdmUgKyBwZXJDaGFyICogKGxpbmUuZnJvbSAtIG9mZnNldCAtIGxpbmVzQWJvdmUpO1xuICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhsaW5lLmZyb20sIGxpbmUubGVuZ3RoLCBNYXRoLm1heCh0b3AsIE1hdGgubWluKGxpbmVUb3AsIHRvcCArIHRoaXMuaGVpZ2h0IC0gbGluZUhlaWdodCkpLCBsaW5lSGVpZ2h0LCAwKTtcbiAgICB9XG4gICAgZm9yRWFjaExpbmUoZnJvbSwgdG8sIG9yYWNsZSwgdG9wLCBvZmZzZXQsIGYpIHtcbiAgICAgICAgZnJvbSA9IE1hdGgubWF4KGZyb20sIG9mZnNldCk7XG4gICAgICAgIHRvID0gTWF0aC5taW4odG8sIG9mZnNldCArIHRoaXMubGVuZ3RoKTtcbiAgICAgICAgbGV0IHsgZmlyc3RMaW5lLCBwZXJMaW5lLCBwZXJDaGFyIH0gPSB0aGlzLmhlaWdodE1ldHJpY3Mob3JhY2xlLCBvZmZzZXQpO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSBmcm9tLCBsaW5lVG9wID0gdG9wOyBwb3MgPD0gdG87KSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IG9yYWNsZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAocG9zID09IGZyb20pIHtcbiAgICAgICAgICAgICAgICBsZXQgbGluZXNBYm92ZSA9IGxpbmUubnVtYmVyIC0gZmlyc3RMaW5lO1xuICAgICAgICAgICAgICAgIGxpbmVUb3AgKz0gcGVyTGluZSAqIGxpbmVzQWJvdmUgKyBwZXJDaGFyICogKGZyb20gLSBvZmZzZXQgLSBsaW5lc0Fib3ZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBsaW5lSGVpZ2h0ID0gcGVyTGluZSArIHBlckNoYXIgKiBsaW5lLmxlbmd0aDtcbiAgICAgICAgICAgIGYobmV3IEJsb2NrSW5mbyhsaW5lLmZyb20sIGxpbmUubGVuZ3RoLCBsaW5lVG9wLCBsaW5lSGVpZ2h0LCAwKSk7XG4gICAgICAgICAgICBsaW5lVG9wICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICBwb3MgPSBsaW5lLnRvICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKGZyb20sIHRvLCBub2Rlcykge1xuICAgICAgICBsZXQgYWZ0ZXIgPSB0aGlzLmxlbmd0aCAtIHRvO1xuICAgICAgICBpZiAoYWZ0ZXIgPiAwKSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKGxhc3QgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXApXG4gICAgICAgICAgICAgICAgbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0gPSBuZXcgSGVpZ2h0TWFwR2FwKGxhc3QubGVuZ3RoICsgYWZ0ZXIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobnVsbCwgbmV3IEhlaWdodE1hcEdhcChhZnRlciAtIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbSA+IDApIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IG5vZGVzWzBdO1xuICAgICAgICAgICAgaWYgKGZpcnN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwKVxuICAgICAgICAgICAgICAgIG5vZGVzWzBdID0gbmV3IEhlaWdodE1hcEdhcChmcm9tICsgZmlyc3QubGVuZ3RoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2Rlcy51bnNoaWZ0KG5ldyBIZWlnaHRNYXBHYXAoZnJvbSAtIDEpLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKG5vZGVzKTtcbiAgICB9XG4gICAgZGVjb21wb3NlTGVmdCh0bywgcmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG5ldyBIZWlnaHRNYXBHYXAodG8gLSAxKSwgbnVsbCk7XG4gICAgfVxuICAgIGRlY29tcG9zZVJpZ2h0KGZyb20sIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQucHVzaChudWxsLCBuZXcgSGVpZ2h0TWFwR2FwKHRoaXMubGVuZ3RoIC0gZnJvbSAtIDEpKTtcbiAgICB9XG4gICAgdXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0ID0gMCwgZm9yY2UgPSBmYWxzZSwgbWVhc3VyZWQpIHtcbiAgICAgICAgbGV0IGVuZCA9IG9mZnNldCArIHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAobWVhc3VyZWQgJiYgbWVhc3VyZWQuZnJvbSA8PSBvZmZzZXQgKyB0aGlzLmxlbmd0aCAmJiBtZWFzdXJlZC5tb3JlKSB7XG4gICAgICAgICAgICAvLyBGaWxsIGluIHBhcnQgb2YgdGhpcyBnYXAgd2l0aCBtZWFzdXJlZCBsaW5lcy4gV2Uga25vdyB0aGVyZVxuICAgICAgICAgICAgLy8gY2FuJ3QgYmUgd2lkZ2V0cyBvciBjb2xsYXBzZWQgcmFuZ2VzIGluIHRob3NlIGxpbmVzLCBiZWNhdXNlXG4gICAgICAgICAgICAvLyB0aGV5IHdvdWxkIGFscmVhZHkgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBoZWlnaHRtYXAgKGdhcHNcbiAgICAgICAgICAgIC8vIG9ubHkgY29udGFpbiBwbGFpbiB0ZXh0KS5cbiAgICAgICAgICAgIGxldCBub2RlcyA9IFtdLCBwb3MgPSBNYXRoLm1heChvZmZzZXQsIG1lYXN1cmVkLmZyb20pLCBzaW5nbGVIZWlnaHQgPSAtMTtcbiAgICAgICAgICAgIGlmIChtZWFzdXJlZC5mcm9tID4gb2Zmc2V0KVxuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobmV3IEhlaWdodE1hcEdhcChtZWFzdXJlZC5mcm9tIC0gb2Zmc2V0IC0gMSkudXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0KSk7XG4gICAgICAgICAgICB3aGlsZSAocG9zIDw9IGVuZCAmJiBtZWFzdXJlZC5tb3JlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IG9yYWNsZS5kb2MubGluZUF0KHBvcykubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChub2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgbGV0IGhlaWdodCA9IG1lYXN1cmVkLmhlaWdodHNbbWVhc3VyZWQuaW5kZXgrK107XG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZUhlaWdodCA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKE1hdGguYWJzKGhlaWdodCAtIHNpbmdsZUhlaWdodCkgPj0gRXBzaWxvbilcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlSGVpZ2h0ID0gLTI7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmUgPSBuZXcgSGVpZ2h0TWFwVGV4dChsZW4sIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgbGluZS5vdXRkYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobGluZSk7XG4gICAgICAgICAgICAgICAgcG9zICs9IGxlbiArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zIDw9IGVuZClcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG51bGwsIG5ldyBIZWlnaHRNYXBHYXAoZW5kIC0gcG9zKS51cGRhdGVIZWlnaHQob3JhY2xlLCBwb3MpKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBIZWlnaHRNYXAub2Yobm9kZXMpO1xuICAgICAgICAgICAgaWYgKHNpbmdsZUhlaWdodCA8IDAgfHwgTWF0aC5hYnMocmVzdWx0LmhlaWdodCAtIHRoaXMuaGVpZ2h0KSA+PSBFcHNpbG9uIHx8XG4gICAgICAgICAgICAgICAgTWF0aC5hYnMoc2luZ2xlSGVpZ2h0IC0gdGhpcy5oZWlnaHRNZXRyaWNzKG9yYWNsZSwgb2Zmc2V0KS5wZXJMaW5lKSA+PSBFcHNpbG9uKVxuICAgICAgICAgICAgICAgIG9yYWNsZS5oZWlnaHRDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZm9yY2UgfHwgdGhpcy5vdXRkYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQob3JhY2xlLCBvcmFjbGUuaGVpZ2h0Rm9yR2FwKG9mZnNldCwgb2Zmc2V0ICsgdGhpcy5sZW5ndGgpKTtcbiAgICAgICAgICAgIHRoaXMub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiBgZ2FwKCR7dGhpcy5sZW5ndGh9KWA7IH1cbn1cbmNsYXNzIEhlaWdodE1hcEJyYW5jaCBleHRlbmRzIEhlaWdodE1hcCB7XG4gICAgY29uc3RydWN0b3IobGVmdCwgYnJrLCByaWdodCkge1xuICAgICAgICBzdXBlcihsZWZ0Lmxlbmd0aCArIGJyayArIHJpZ2h0Lmxlbmd0aCwgbGVmdC5oZWlnaHQgKyByaWdodC5oZWlnaHQsIGJyayB8IChsZWZ0Lm91dGRhdGVkIHx8IHJpZ2h0Lm91dGRhdGVkID8gMiAvKiBGbGFnLk91dGRhdGVkICovIDogMCkpO1xuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHRoaXMuc2l6ZSA9IGxlZnQuc2l6ZSArIHJpZ2h0LnNpemU7XG4gICAgfVxuICAgIGdldCBicmVhaygpIHsgcmV0dXJuIHRoaXMuZmxhZ3MgJiAxIC8qIEZsYWcuQnJlYWsgKi87IH1cbiAgICBibG9ja0F0KGhlaWdodCwgb3JhY2xlLCB0b3AsIG9mZnNldCkge1xuICAgICAgICBsZXQgbWlkID0gdG9wICsgdGhpcy5sZWZ0LmhlaWdodDtcbiAgICAgICAgcmV0dXJuIGhlaWdodCA8IG1pZCA/IHRoaXMubGVmdC5ibG9ja0F0KGhlaWdodCwgb3JhY2xlLCB0b3AsIG9mZnNldClcbiAgICAgICAgICAgIDogdGhpcy5yaWdodC5ibG9ja0F0KGhlaWdodCwgb3JhY2xlLCBtaWQsIG9mZnNldCArIHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrKTtcbiAgICB9XG4gICAgbGluZUF0KHZhbHVlLCB0eXBlLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCByaWdodFRvcCA9IHRvcCArIHRoaXMubGVmdC5oZWlnaHQsIHJpZ2h0T2Zmc2V0ID0gb2Zmc2V0ICsgdGhpcy5sZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWs7XG4gICAgICAgIGxldCBsZWZ0ID0gdHlwZSA9PSBRdWVyeVR5cGUuQnlIZWlnaHQgPyB2YWx1ZSA8IHJpZ2h0VG9wIDogdmFsdWUgPCByaWdodE9mZnNldDtcbiAgICAgICAgbGV0IGJhc2UgPSBsZWZ0ID8gdGhpcy5sZWZ0LmxpbmVBdCh2YWx1ZSwgdHlwZSwgb3JhY2xlLCB0b3AsIG9mZnNldClcbiAgICAgICAgICAgIDogdGhpcy5yaWdodC5saW5lQXQodmFsdWUsIHR5cGUsIG9yYWNsZSwgcmlnaHRUb3AsIHJpZ2h0T2Zmc2V0KTtcbiAgICAgICAgaWYgKHRoaXMuYnJlYWsgfHwgKGxlZnQgPyBiYXNlLnRvIDwgcmlnaHRPZmZzZXQgOiBiYXNlLmZyb20gPiByaWdodE9mZnNldCkpXG4gICAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgbGV0IHN1YlF1ZXJ5ID0gdHlwZSA9PSBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCA/IFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0IDogUXVlcnlUeXBlLkJ5UG9zO1xuICAgICAgICBpZiAobGVmdClcbiAgICAgICAgICAgIHJldHVybiBiYXNlLmpvaW4odGhpcy5yaWdodC5saW5lQXQocmlnaHRPZmZzZXQsIHN1YlF1ZXJ5LCBvcmFjbGUsIHJpZ2h0VG9wLCByaWdodE9mZnNldCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmxpbmVBdChyaWdodE9mZnNldCwgc3ViUXVlcnksIG9yYWNsZSwgdG9wLCBvZmZzZXQpLmpvaW4oYmFzZSk7XG4gICAgfVxuICAgIGZvckVhY2hMaW5lKGZyb20sIHRvLCBvcmFjbGUsIHRvcCwgb2Zmc2V0LCBmKSB7XG4gICAgICAgIGxldCByaWdodFRvcCA9IHRvcCArIHRoaXMubGVmdC5oZWlnaHQsIHJpZ2h0T2Zmc2V0ID0gb2Zmc2V0ICsgdGhpcy5sZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWs7XG4gICAgICAgIGlmICh0aGlzLmJyZWFrKSB7XG4gICAgICAgICAgICBpZiAoZnJvbSA8IHJpZ2h0T2Zmc2V0KVxuICAgICAgICAgICAgICAgIHRoaXMubGVmdC5mb3JFYWNoTGluZShmcm9tLCB0bywgb3JhY2xlLCB0b3AsIG9mZnNldCwgZik7XG4gICAgICAgICAgICBpZiAodG8gPj0gcmlnaHRPZmZzZXQpXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodC5mb3JFYWNoTGluZShmcm9tLCB0bywgb3JhY2xlLCByaWdodFRvcCwgcmlnaHRPZmZzZXQsIGYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1pZCA9IHRoaXMubGluZUF0KHJpZ2h0T2Zmc2V0LCBRdWVyeVR5cGUuQnlQb3MsIG9yYWNsZSwgdG9wLCBvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKGZyb20gPCBtaWQuZnJvbSlcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnQuZm9yRWFjaExpbmUoZnJvbSwgbWlkLmZyb20gLSAxLCBvcmFjbGUsIHRvcCwgb2Zmc2V0LCBmKTtcbiAgICAgICAgICAgIGlmIChtaWQudG8gPj0gZnJvbSAmJiBtaWQuZnJvbSA8PSB0bylcbiAgICAgICAgICAgICAgICBmKG1pZCk7XG4gICAgICAgICAgICBpZiAodG8gPiBtaWQudG8pXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodC5mb3JFYWNoTGluZShtaWQudG8gKyAxLCB0bywgb3JhY2xlLCByaWdodFRvcCwgcmlnaHRPZmZzZXQsIGYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2UoZnJvbSwgdG8sIG5vZGVzKSB7XG4gICAgICAgIGxldCByaWdodFN0YXJ0ID0gdGhpcy5sZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWs7XG4gICAgICAgIGlmICh0byA8IHJpZ2h0U3RhcnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYWxhbmNlZCh0aGlzLmxlZnQucmVwbGFjZShmcm9tLCB0bywgbm9kZXMpLCB0aGlzLnJpZ2h0KTtcbiAgICAgICAgaWYgKGZyb20gPiB0aGlzLmxlZnQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFsYW5jZWQodGhpcy5sZWZ0LCB0aGlzLnJpZ2h0LnJlcGxhY2UoZnJvbSAtIHJpZ2h0U3RhcnQsIHRvIC0gcmlnaHRTdGFydCwgbm9kZXMpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoZnJvbSA+IDApXG4gICAgICAgICAgICB0aGlzLmRlY29tcG9zZUxlZnQoZnJvbSwgcmVzdWx0KTtcbiAgICAgICAgbGV0IGxlZnQgPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gICAgICAgIGlmIChmcm9tID4gMClcbiAgICAgICAgICAgIG1lcmdlR2FwcyhyZXN1bHQsIGxlZnQgLSAxKTtcbiAgICAgICAgaWYgKHRvIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCByaWdodCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmRlY29tcG9zZVJpZ2h0KHRvLCByZXN1bHQpO1xuICAgICAgICAgICAgbWVyZ2VHYXBzKHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBIZWlnaHRNYXAub2YocmVzdWx0KTtcbiAgICB9XG4gICAgZGVjb21wb3NlTGVmdCh0bywgcmVzdWx0KSB7XG4gICAgICAgIGxldCBsZWZ0ID0gdGhpcy5sZWZ0Lmxlbmd0aDtcbiAgICAgICAgaWYgKHRvIDw9IGxlZnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmRlY29tcG9zZUxlZnQodG8sIHJlc3VsdCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubGVmdCk7XG4gICAgICAgIGlmICh0aGlzLmJyZWFrKSB7XG4gICAgICAgICAgICBsZWZ0Kys7XG4gICAgICAgICAgICBpZiAodG8gPj0gbGVmdClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG8gPiBsZWZ0KVxuICAgICAgICAgICAgdGhpcy5yaWdodC5kZWNvbXBvc2VMZWZ0KHRvIC0gbGVmdCwgcmVzdWx0KTtcbiAgICB9XG4gICAgZGVjb21wb3NlUmlnaHQoZnJvbSwgcmVzdWx0KSB7XG4gICAgICAgIGxldCBsZWZ0ID0gdGhpcy5sZWZ0Lmxlbmd0aCwgcmlnaHQgPSBsZWZ0ICsgdGhpcy5icmVhaztcbiAgICAgICAgaWYgKGZyb20gPj0gcmlnaHQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5kZWNvbXBvc2VSaWdodChmcm9tIC0gcmlnaHQsIHJlc3VsdCk7XG4gICAgICAgIGlmIChmcm9tIDwgbGVmdClcbiAgICAgICAgICAgIHRoaXMubGVmdC5kZWNvbXBvc2VSaWdodChmcm9tLCByZXN1bHQpO1xuICAgICAgICBpZiAodGhpcy5icmVhayAmJiBmcm9tIDwgcmlnaHQpXG4gICAgICAgICAgICByZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5yaWdodCk7XG4gICAgfVxuICAgIGJhbGFuY2VkKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChsZWZ0LnNpemUgPiAyICogcmlnaHQuc2l6ZSB8fCByaWdodC5zaXplID4gMiAqIGxlZnQuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBIZWlnaHRNYXAub2YodGhpcy5icmVhayA/IFtsZWZ0LCBudWxsLCByaWdodF0gOiBbbGVmdCwgcmlnaHRdKTtcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICB0aGlzLmhlaWdodCA9IGxlZnQuaGVpZ2h0ICsgcmlnaHQuaGVpZ2h0O1xuICAgICAgICB0aGlzLm91dGRhdGVkID0gbGVmdC5vdXRkYXRlZCB8fCByaWdodC5vdXRkYXRlZDtcbiAgICAgICAgdGhpcy5zaXplID0gbGVmdC5zaXplICsgcmlnaHQuc2l6ZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWsgKyByaWdodC5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB1cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQgPSAwLCBmb3JjZSA9IGZhbHNlLCBtZWFzdXJlZCkge1xuICAgICAgICBsZXQgeyBsZWZ0LCByaWdodCB9ID0gdGhpcywgcmlnaHRTdGFydCA9IG9mZnNldCArIGxlZnQubGVuZ3RoICsgdGhpcy5icmVhaywgcmViYWxhbmNlID0gbnVsbDtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gb2Zmc2V0ICsgbGVmdC5sZW5ndGggJiYgbWVhc3VyZWQubW9yZSlcbiAgICAgICAgICAgIHJlYmFsYW5jZSA9IGxlZnQgPSBsZWZ0LnVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCwgZm9yY2UsIG1lYXN1cmVkKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGVmdC51cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQsIGZvcmNlKTtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gcmlnaHRTdGFydCArIHJpZ2h0Lmxlbmd0aCAmJiBtZWFzdXJlZC5tb3JlKVxuICAgICAgICAgICAgcmViYWxhbmNlID0gcmlnaHQgPSByaWdodC51cGRhdGVIZWlnaHQob3JhY2xlLCByaWdodFN0YXJ0LCBmb3JjZSwgbWVhc3VyZWQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByaWdodC51cGRhdGVIZWlnaHQob3JhY2xlLCByaWdodFN0YXJ0LCBmb3JjZSk7XG4gICAgICAgIGlmIChyZWJhbGFuY2UpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYWxhbmNlZChsZWZ0LCByaWdodCk7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5sZWZ0LmhlaWdodCArIHRoaXMucmlnaHQuaGVpZ2h0O1xuICAgICAgICB0aGlzLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMubGVmdCArICh0aGlzLmJyZWFrID8gXCIgXCIgOiBcIi1cIikgKyB0aGlzLnJpZ2h0OyB9XG59XG5mdW5jdGlvbiBtZXJnZUdhcHMobm9kZXMsIGFyb3VuZCkge1xuICAgIGxldCBiZWZvcmUsIGFmdGVyO1xuICAgIGlmIChub2Rlc1thcm91bmRdID09IG51bGwgJiZcbiAgICAgICAgKGJlZm9yZSA9IG5vZGVzW2Fyb3VuZCAtIDFdKSBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcCAmJlxuICAgICAgICAoYWZ0ZXIgPSBub2Rlc1thcm91bmQgKyAxXSkgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXApXG4gICAgICAgIG5vZGVzLnNwbGljZShhcm91bmQgLSAxLCAzLCBuZXcgSGVpZ2h0TWFwR2FwKGJlZm9yZS5sZW5ndGggKyAxICsgYWZ0ZXIubGVuZ3RoKSk7XG59XG5jb25zdCByZWxldmFudFdpZGdldEhlaWdodCA9IDU7XG5jbGFzcyBOb2RlQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IocG9zLCBvcmFjbGUpIHtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMub3JhY2xlID0gb3JhY2xlO1xuICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgICAgIHRoaXMubGluZVN0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMubGluZUVuZCA9IC0xO1xuICAgICAgICB0aGlzLmNvdmVyaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy53cml0dGVuVG8gPSBwb3M7XG4gICAgfVxuICAgIGdldCBpc0NvdmVyZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvdmVyaW5nICYmIHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXSA9PSB0aGlzLmNvdmVyaW5nO1xuICAgIH1cbiAgICBzcGFuKF9mcm9tLCB0bykge1xuICAgICAgICBpZiAodGhpcy5saW5lU3RhcnQgPiAtMSkge1xuICAgICAgICAgICAgbGV0IGVuZCA9IE1hdGgubWluKHRvLCB0aGlzLmxpbmVFbmQpLCBsYXN0ID0gdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKGxhc3QgaW5zdGFuY2VvZiBIZWlnaHRNYXBUZXh0KVxuICAgICAgICAgICAgICAgIGxhc3QubGVuZ3RoICs9IGVuZCAtIHRoaXMucG9zO1xuICAgICAgICAgICAgZWxzZSBpZiAoZW5kID4gdGhpcy5wb3MgfHwgIXRoaXMuaXNDb3ZlcmVkKVxuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChuZXcgSGVpZ2h0TWFwVGV4dChlbmQgLSB0aGlzLnBvcywgLTEpKTtcbiAgICAgICAgICAgIHRoaXMud3JpdHRlblRvID0gZW5kO1xuICAgICAgICAgICAgaWYgKHRvID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdHRlblRvKys7XG4gICAgICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcyA9IHRvO1xuICAgIH1cbiAgICBwb2ludChmcm9tLCB0bywgZGVjbykge1xuICAgICAgICBpZiAoZnJvbSA8IHRvIHx8IGRlY28uaGVpZ2h0UmVsZXZhbnQpIHtcbiAgICAgICAgICAgIGxldCBoZWlnaHQgPSBkZWNvLndpZGdldCA/IGRlY28ud2lkZ2V0LmVzdGltYXRlZEhlaWdodCA6IDA7XG4gICAgICAgICAgICBsZXQgYnJlYWtzID0gZGVjby53aWRnZXQgPyBkZWNvLndpZGdldC5saW5lQnJlYWtzIDogMDtcbiAgICAgICAgICAgIGlmIChoZWlnaHQgPCAwKVxuICAgICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMub3JhY2xlLmxpbmVIZWlnaHQ7XG4gICAgICAgICAgICBsZXQgbGVuID0gdG8gLSBmcm9tO1xuICAgICAgICAgICAgaWYgKGRlY28uYmxvY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEJsb2NrKG5ldyBIZWlnaHRNYXBCbG9jayhsZW4sIGhlaWdodCwgZGVjbykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGVuIHx8IGJyZWFrcyB8fCBoZWlnaHQgPj0gcmVsZXZhbnRXaWRnZXRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZExpbmVEZWNvKGhlaWdodCwgYnJlYWtzLCBsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRvID4gZnJvbSkge1xuICAgICAgICAgICAgdGhpcy5zcGFuKGZyb20sIHRvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5saW5lRW5kID4gLTEgJiYgdGhpcy5saW5lRW5kIDwgdGhpcy5wb3MpXG4gICAgICAgICAgICB0aGlzLmxpbmVFbmQgPSB0aGlzLm9yYWNsZS5kb2MubGluZUF0KHRoaXMucG9zKS50bztcbiAgICB9XG4gICAgZW50ZXJMaW5lKCkge1xuICAgICAgICBpZiAodGhpcy5saW5lU3RhcnQgPiAtMSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHRoaXMub3JhY2xlLmRvYy5saW5lQXQodGhpcy5wb3MpO1xuICAgICAgICB0aGlzLmxpbmVTdGFydCA9IGZyb207XG4gICAgICAgIHRoaXMubGluZUVuZCA9IHRvO1xuICAgICAgICBpZiAodGhpcy53cml0dGVuVG8gPCBmcm9tKSB7XG4gICAgICAgICAgICBpZiAodGhpcy53cml0dGVuVG8gPCBmcm9tIC0gMSB8fCB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoIC0gMV0gPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2godGhpcy5ibGFua0NvbnRlbnQodGhpcy53cml0dGVuVG8sIGZyb20gLSAxKSk7XG4gICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucG9zID4gZnJvbSlcbiAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChuZXcgSGVpZ2h0TWFwVGV4dCh0aGlzLnBvcyAtIGZyb20sIC0xKSk7XG4gICAgICAgIHRoaXMud3JpdHRlblRvID0gdGhpcy5wb3M7XG4gICAgfVxuICAgIGJsYW5rQ29udGVudChmcm9tLCB0bykge1xuICAgICAgICBsZXQgZ2FwID0gbmV3IEhlaWdodE1hcEdhcCh0byAtIGZyb20pO1xuICAgICAgICBpZiAodGhpcy5vcmFjbGUuZG9jLmxpbmVBdChmcm9tKS50byA9PSB0bylcbiAgICAgICAgICAgIGdhcC5mbGFncyB8PSA0IC8qIEZsYWcuU2luZ2xlTGluZSAqLztcbiAgICAgICAgcmV0dXJuIGdhcDtcbiAgICB9XG4gICAgZW5zdXJlTGluZSgpIHtcbiAgICAgICAgdGhpcy5lbnRlckxpbmUoKTtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLm5vZGVzLmxlbmd0aCA/IHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICAgIGlmIChsYXN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwVGV4dClcbiAgICAgICAgICAgIHJldHVybiBsYXN0O1xuICAgICAgICBsZXQgbGluZSA9IG5ldyBIZWlnaHRNYXBUZXh0KDAsIC0xKTtcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGxpbmUpO1xuICAgICAgICByZXR1cm4gbGluZTtcbiAgICB9XG4gICAgYWRkQmxvY2soYmxvY2spIHtcbiAgICAgICAgdGhpcy5lbnRlckxpbmUoKTtcbiAgICAgICAgbGV0IGRlY28gPSBibG9jay5kZWNvO1xuICAgICAgICBpZiAoZGVjbyAmJiBkZWNvLnN0YXJ0U2lkZSA+IDAgJiYgIXRoaXMuaXNDb3ZlcmVkKVxuICAgICAgICAgICAgdGhpcy5lbnN1cmVMaW5lKCk7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChibG9jayk7XG4gICAgICAgIHRoaXMud3JpdHRlblRvID0gdGhpcy5wb3MgPSB0aGlzLnBvcyArIGJsb2NrLmxlbmd0aDtcbiAgICAgICAgaWYgKGRlY28gJiYgZGVjby5lbmRTaWRlID4gMClcbiAgICAgICAgICAgIHRoaXMuY292ZXJpbmcgPSBibG9jaztcbiAgICB9XG4gICAgYWRkTGluZURlY28oaGVpZ2h0LCBicmVha3MsIGxlbmd0aCkge1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuZW5zdXJlTGluZSgpO1xuICAgICAgICBsaW5lLmxlbmd0aCArPSBsZW5ndGg7XG4gICAgICAgIGxpbmUuY29sbGFwc2VkICs9IGxlbmd0aDtcbiAgICAgICAgbGluZS53aWRnZXRIZWlnaHQgPSBNYXRoLm1heChsaW5lLndpZGdldEhlaWdodCwgaGVpZ2h0KTtcbiAgICAgICAgbGluZS5icmVha3MgKz0gYnJlYWtzO1xuICAgICAgICB0aGlzLndyaXR0ZW5UbyA9IHRoaXMucG9zID0gdGhpcy5wb3MgKyBsZW5ndGg7XG4gICAgfVxuICAgIGZpbmlzaChmcm9tKSB7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5ub2Rlcy5sZW5ndGggPT0gMCA/IG51bGwgOiB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0aGlzLmxpbmVTdGFydCA+IC0xICYmICEobGFzdCBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQpICYmICF0aGlzLmlzQ292ZXJlZClcbiAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChuZXcgSGVpZ2h0TWFwVGV4dCgwLCAtMSkpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLndyaXR0ZW5UbyA8IHRoaXMucG9zIHx8IGxhc3QgPT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaCh0aGlzLmJsYW5rQ29udGVudCh0aGlzLndyaXR0ZW5UbywgdGhpcy5wb3MpKTtcbiAgICAgICAgbGV0IHBvcyA9IGZyb207XG4gICAgICAgIGZvciAobGV0IG5vZGUgb2YgdGhpcy5ub2Rlcykge1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBIZWlnaHRNYXBUZXh0KVxuICAgICAgICAgICAgICAgIG5vZGUudXBkYXRlSGVpZ2h0KHRoaXMub3JhY2xlLCBwb3MpO1xuICAgICAgICAgICAgcG9zICs9IG5vZGUgPyBub2RlLmxlbmd0aCA6IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXM7XG4gICAgfVxuICAgIC8vIEFsd2F5cyBjYWxsZWQgd2l0aCBhIHJlZ2lvbiB0aGF0IG9uIGJvdGggc2lkZXMgZWl0aGVyIHN0cmV0Y2hlc1xuICAgIC8vIHRvIGEgbGluZSBicmVhayBvciB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cbiAgICAvLyBUaGUgcmV0dXJuZWQgYXJyYXkgdXNlcyBudWxsIHRvIGluZGljYXRlIGxpbmUgYnJlYWtzLCBidXQgbmV2ZXJcbiAgICAvLyBzdGFydHMgb3IgZW5kcyBpbiBhIGxpbmUgYnJlYWssIG9yIGhhcyBtdWx0aXBsZSBsaW5lIGJyZWFrcyBuZXh0XG4gICAgLy8gdG8gZWFjaCBvdGhlci5cbiAgICBzdGF0aWMgYnVpbGQob3JhY2xlLCBkZWNvcmF0aW9ucywgZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgTm9kZUJ1aWxkZXIoZnJvbSwgb3JhY2xlKTtcbiAgICAgICAgUmFuZ2VTZXQuc3BhbnMoZGVjb3JhdGlvbnMsIGZyb20sIHRvLCBidWlsZGVyLCAwKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZmluaXNoKGZyb20pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhlaWdodFJlbGV2YW50RGVjb0NoYW5nZXMoYSwgYiwgZGlmZikge1xuICAgIGxldCBjb21wID0gbmV3IERlY29yYXRpb25Db21wYXJhdG9yO1xuICAgIFJhbmdlU2V0LmNvbXBhcmUoYSwgYiwgZGlmZiwgY29tcCwgMCk7XG4gICAgcmV0dXJuIGNvbXAuY2hhbmdlcztcbn1cbmNsYXNzIERlY29yYXRpb25Db21wYXJhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gW107XG4gICAgfVxuICAgIGNvbXBhcmVSYW5nZSgpIHsgfVxuICAgIGNvbXBhcmVQb2ludChmcm9tLCB0bywgYSwgYikge1xuICAgICAgICBpZiAoZnJvbSA8IHRvIHx8IGEgJiYgYS5oZWlnaHRSZWxldmFudCB8fCBiICYmIGIuaGVpZ2h0UmVsZXZhbnQpXG4gICAgICAgICAgICBhZGRSYW5nZShmcm9tLCB0bywgdGhpcy5jaGFuZ2VzLCA1KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHZpc2libGVQaXhlbFJhbmdlKGRvbSwgcGFkZGluZ1RvcCkge1xuICAgIGxldCByZWN0ID0gZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBkb2MgPSBkb20ub3duZXJEb2N1bWVudCwgd2luID0gZG9jLmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgICBsZXQgbGVmdCA9IE1hdGgubWF4KDAsIHJlY3QubGVmdCksIHJpZ2h0ID0gTWF0aC5taW4od2luLmlubmVyV2lkdGgsIHJlY3QucmlnaHQpO1xuICAgIGxldCB0b3AgPSBNYXRoLm1heCgwLCByZWN0LnRvcCksIGJvdHRvbSA9IE1hdGgubWluKHdpbi5pbm5lckhlaWdodCwgcmVjdC5ib3R0b20pO1xuICAgIGZvciAobGV0IHBhcmVudCA9IGRvbS5wYXJlbnROb2RlOyBwYXJlbnQgJiYgcGFyZW50ICE9IGRvYy5ib2R5Oykge1xuICAgICAgICBpZiAocGFyZW50Lm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIGxldCBlbHQgPSBwYXJlbnQ7XG4gICAgICAgICAgICBsZXQgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbHQpO1xuICAgICAgICAgICAgaWYgKChlbHQuc2Nyb2xsSGVpZ2h0ID4gZWx0LmNsaWVudEhlaWdodCB8fCBlbHQuc2Nyb2xsV2lkdGggPiBlbHQuY2xpZW50V2lkdGgpICYmXG4gICAgICAgICAgICAgICAgc3R5bGUub3ZlcmZsb3cgIT0gXCJ2aXNpYmxlXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50UmVjdCA9IGVsdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gTWF0aC5tYXgobGVmdCwgcGFyZW50UmVjdC5sZWZ0KTtcbiAgICAgICAgICAgICAgICByaWdodCA9IE1hdGgubWluKHJpZ2h0LCBwYXJlbnRSZWN0LnJpZ2h0KTtcbiAgICAgICAgICAgICAgICB0b3AgPSBNYXRoLm1heCh0b3AsIHBhcmVudFJlY3QudG9wKTtcbiAgICAgICAgICAgICAgICBib3R0b20gPSBwYXJlbnQgPT0gZG9tLnBhcmVudE5vZGUgPyBwYXJlbnRSZWN0LmJvdHRvbSA6IE1hdGgubWluKGJvdHRvbSwgcGFyZW50UmVjdC5ib3R0b20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50ID0gc3R5bGUucG9zaXRpb24gPT0gXCJhYnNvbHV0ZVwiIHx8IHN0eWxlLnBvc2l0aW9uID09IFwiZml4ZWRcIiA/IGVsdC5vZmZzZXRQYXJlbnQgOiBlbHQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJlbnQubm9kZVR5cGUgPT0gMTEpIHsgLy8gU2hhZG93IHJvb3RcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbGVmdDogbGVmdCAtIHJlY3QubGVmdCwgcmlnaHQ6IE1hdGgubWF4KGxlZnQsIHJpZ2h0KSAtIHJlY3QubGVmdCxcbiAgICAgICAgdG9wOiB0b3AgLSAocmVjdC50b3AgKyBwYWRkaW5nVG9wKSwgYm90dG9tOiBNYXRoLm1heCh0b3AsIGJvdHRvbSkgLSAocmVjdC50b3AgKyBwYWRkaW5nVG9wKSB9O1xufVxuZnVuY3Rpb24gZnVsbFBpeGVsUmFuZ2UoZG9tLCBwYWRkaW5nVG9wKSB7XG4gICAgbGV0IHJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHsgbGVmdDogMCwgcmlnaHQ6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQsXG4gICAgICAgIHRvcDogcGFkZGluZ1RvcCwgYm90dG9tOiByZWN0LmJvdHRvbSAtIChyZWN0LnRvcCArIHBhZGRpbmdUb3ApIH07XG59XG4vLyBMaW5lIGdhcHMgYXJlIHBsYWNlaG9sZGVyIHdpZGdldHMgdXNlZCB0byBoaWRlIHBpZWNlcyBvZiBvdmVybG9uZ1xuLy8gbGluZXMgd2l0aGluIHRoZSB2aWV3cG9ydCwgYXMgYSBrbHVkZ2UgdG8ga2VlcCB0aGUgZWRpdG9yXG4vLyByZXNwb25zaXZlIHdoZW4gYSByaWRpY3Vsb3VzbHkgbG9uZyBsaW5lIGlzIGxvYWRlZCBpbnRvIGl0LlxuY2xhc3MgTGluZUdhcCB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIHNpemUpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIH1cbiAgICBzdGF0aWMgc2FtZShhLCBiKSB7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZ0EgPSBhW2ldLCBnQiA9IGJbaV07XG4gICAgICAgICAgICBpZiAoZ0EuZnJvbSAhPSBnQi5mcm9tIHx8IGdBLnRvICE9IGdCLnRvIHx8IGdBLnNpemUgIT0gZ0Iuc2l6ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGRyYXcodmlld1N0YXRlLCB3cmFwcGluZykge1xuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5yZXBsYWNlKHtcbiAgICAgICAgICAgIHdpZGdldDogbmV3IExpbmVHYXBXaWRnZXQodGhpcy5zaXplICogKHdyYXBwaW5nID8gdmlld1N0YXRlLnNjYWxlWSA6IHZpZXdTdGF0ZS5zY2FsZVgpLCB3cmFwcGluZylcbiAgICAgICAgfSkucmFuZ2UodGhpcy5mcm9tLCB0aGlzLnRvKTtcbiAgICB9XG59XG5jbGFzcyBMaW5lR2FwV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgdmVydGljYWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICAgICAgdGhpcy52ZXJ0aWNhbCA9IHZlcnRpY2FsO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIuc2l6ZSA9PSB0aGlzLnNpemUgJiYgb3RoZXIudmVydGljYWwgPT0gdGhpcy52ZXJ0aWNhbDsgfVxuICAgIHRvRE9NKCkge1xuICAgICAgICBsZXQgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgaWYgKHRoaXMudmVydGljYWwpIHtcbiAgICAgICAgICAgIGVsdC5zdHlsZS5oZWlnaHQgPSB0aGlzLnNpemUgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbHQuc3R5bGUud2lkdGggPSB0aGlzLnNpemUgKyBcInB4XCI7XG4gICAgICAgICAgICBlbHQuc3R5bGUuaGVpZ2h0ID0gXCIycHhcIjtcbiAgICAgICAgICAgIGVsdC5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWx0O1xuICAgIH1cbiAgICBnZXQgZXN0aW1hdGVkSGVpZ2h0KCkgeyByZXR1cm4gdGhpcy52ZXJ0aWNhbCA/IHRoaXMuc2l6ZSA6IC0xOyB9XG59XG5jbGFzcyBWaWV3U3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKHN0YXRlKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgLy8gVGhlc2UgYXJlIGNvbnRlbnRET00tbG9jYWwgY29vcmRpbmF0ZXNcbiAgICAgICAgdGhpcy5waXhlbFZpZXdwb3J0ID0geyBsZWZ0OiAwLCByaWdodDogd2luZG93LmlubmVyV2lkdGgsIHRvcDogMCwgYm90dG9tOiAwIH07XG4gICAgICAgIHRoaXMuaW5WaWV3ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wYWRkaW5nVG9wID0gMDsgLy8gUGFkZGluZyBhYm92ZSB0aGUgZG9jdW1lbnQsIHNjYWxlZFxuICAgICAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSAwOyAvLyBQYWRkaW5nIGJlbG93IHRoZSBkb2N1bWVudCwgc2NhbGVkXG4gICAgICAgIHRoaXMuY29udGVudERPTVdpZHRoID0gMDsgLy8gY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aFxuICAgICAgICB0aGlzLmNvbnRlbnRET01IZWlnaHQgPSAwOyAvLyBjb250ZW50RE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodFxuICAgICAgICB0aGlzLmVkaXRvckhlaWdodCA9IDA7IC8vIHNjcm9sbERPTS5jbGllbnRIZWlnaHQsIHVuc2NhbGVkXG4gICAgICAgIHRoaXMuZWRpdG9yV2lkdGggPSAwOyAvLyBzY3JvbGxET00uY2xpZW50V2lkdGgsIHVuc2NhbGVkXG4gICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gMDsgLy8gTGFzdCBzZWVuIHNjcm9sbERPTS5zY3JvbGxUb3AsIHNjYWxlZFxuICAgICAgICB0aGlzLnNjcm9sbGVkVG9Cb3R0b20gPSB0cnVlO1xuICAgICAgICAvLyBUaGUgQ1NTLXRyYW5zZm9ybWF0aW9uIHNjYWxlIG9mIHRoZSBlZGl0b3IgKHRyYW5zZm9ybWVkIHNpemUgL1xuICAgICAgICAvLyBjb25jcmV0ZSBzaXplKVxuICAgICAgICB0aGlzLnNjYWxlWCA9IDE7XG4gICAgICAgIHRoaXMuc2NhbGVZID0gMTtcbiAgICAgICAgLy8gVGhlIHZlcnRpY2FsIHBvc2l0aW9uIChkb2N1bWVudC1yZWxhdGl2ZSkgdG8gd2hpY2ggdG8gYW5jaG9yIHRoZVxuICAgICAgICAvLyBzY3JvbGwgcG9zaXRpb24uIC0xIG1lYW5zIGFuY2hvciB0byB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cbiAgICAgICAgdGhpcy5zY3JvbGxBbmNob3JQb3MgPSAwO1xuICAgICAgICAvLyBUaGUgaGVpZ2h0IGF0IHRoZSBhbmNob3IgcG9zaXRpb24uIFNldCBieSB0aGUgRE9NIHVwZGF0ZSBwaGFzZS5cbiAgICAgICAgLy8gLTEgbWVhbnMgbm8gaGVpZ2h0IGF2YWlsYWJsZS5cbiAgICAgICAgdGhpcy5zY3JvbGxBbmNob3JIZWlnaHQgPSAtMTtcbiAgICAgICAgLy8gU2VlIFZQLk1heERPTUhlaWdodFxuICAgICAgICB0aGlzLnNjYWxlciA9IElkU2NhbGVyO1xuICAgICAgICB0aGlzLnNjcm9sbFRhcmdldCA9IG51bGw7XG4gICAgICAgIC8vIEJyaWVmbHkgc2V0IHRvIHRydWUgd2hlbiBwcmludGluZywgdG8gZGlzYWJsZSB2aWV3cG9ydCBsaW1pdGluZ1xuICAgICAgICB0aGlzLnByaW50aW5nID0gZmFsc2U7XG4gICAgICAgIC8vIEZsYWcgc2V0IHdoZW4gZWRpdG9yIGNvbnRlbnQgd2FzIHJlZHJhd24sIHNvIHRoYXQgdGhlIG5leHRcbiAgICAgICAgLy8gbWVhc3VyZSBzdGFnZSBrbm93cyBpdCBtdXN0IHJlYWQgRE9NIGxheW91dFxuICAgICAgICB0aGlzLm11c3RNZWFzdXJlQ29udGVudCA9IHRydWU7XG4gICAgICAgIHRoaXMuZGVmYXVsdFRleHREaXJlY3Rpb24gPSBEaXJlY3Rpb24uTFRSO1xuICAgICAgICB0aGlzLnZpc2libGVSYW5nZXMgPSBbXTtcbiAgICAgICAgLy8gQ3Vyc29yICdhc3NvYycgaXMgb25seSBzaWduaWZpY2FudCB3aGVuIHRoZSBjdXJzb3IgaXMgb24gYSBsaW5lXG4gICAgICAgIC8vIHdyYXAgcG9pbnQsIHdoZXJlIGl0IG11c3Qgc3RpY2sgdG8gdGhlIGNoYXJhY3RlciB0aGF0IGl0IGlzXG4gICAgICAgIC8vIGFzc29jaWF0ZWQgd2l0aC4gU2luY2UgYnJvd3NlcnMgZG9uJ3QgcHJvdmlkZSBhIHJlYXNvbmFibGVcbiAgICAgICAgLy8gaW50ZXJmYWNlIHRvIHNldCBvciBxdWVyeSB0aGlzLCB3aGVuIGEgc2VsZWN0aW9uIGlzIHNldCB0aGF0XG4gICAgICAgIC8vIG1pZ2h0IGNhdXNlIHRoaXMgdG8gYmUgc2lnbmlmaWNhbnQsIHRoaXMgZmxhZyBpcyBzZXQuIFRoZSBuZXh0XG4gICAgICAgIC8vIG1lYXN1cmUgcGhhc2Ugd2lsbCBjaGVjayB3aGV0aGVyIHRoZSBjdXJzb3IgaXMgb24gYSBsaW5lLXdyYXBwaW5nXG4gICAgICAgIC8vIGJvdW5kYXJ5IGFuZCwgaWYgc28sIHJlc2V0IGl0IHRvIG1ha2Ugc3VyZSBpdCBpcyBwb3NpdGlvbmVkIGluXG4gICAgICAgIC8vIHRoZSByaWdodCBwbGFjZS5cbiAgICAgICAgdGhpcy5tdXN0RW5mb3JjZUN1cnNvckFzc29jID0gZmFsc2U7XG4gICAgICAgIGxldCBndWVzc1dyYXBwaW5nID0gc3RhdGUuZmFjZXQoY29udGVudEF0dHJpYnV0ZXMpLnNvbWUodiA9PiB0eXBlb2YgdiAhPSBcImZ1bmN0aW9uXCIgJiYgdi5jbGFzcyA9PSBcImNtLWxpbmVXcmFwcGluZ1wiKTtcbiAgICAgICAgdGhpcy5oZWlnaHRPcmFjbGUgPSBuZXcgSGVpZ2h0T3JhY2xlKGd1ZXNzV3JhcHBpbmcpO1xuICAgICAgICB0aGlzLnN0YXRlRGVjbyA9IHN0YXRlLmZhY2V0KGRlY29yYXRpb25zKS5maWx0ZXIoZCA9PiB0eXBlb2YgZCAhPSBcImZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLmhlaWdodE1hcCA9IEhlaWdodE1hcC5lbXB0eSgpLmFwcGx5Q2hhbmdlcyh0aGlzLnN0YXRlRGVjbywgVGV4dC5lbXB0eSwgdGhpcy5oZWlnaHRPcmFjbGUuc2V0RG9jKHN0YXRlLmRvYyksIFtuZXcgQ2hhbmdlZFJhbmdlKDAsIDAsIDAsIHN0YXRlLmRvYy5sZW5ndGgpXSk7XG4gICAgICAgIHRoaXMudmlld3BvcnQgPSB0aGlzLmdldFZpZXdwb3J0KDAsIG51bGwpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0TGluZXMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVGb3JWaWV3cG9ydCgpO1xuICAgICAgICB0aGlzLmxpbmVHYXBzID0gdGhpcy5lbnN1cmVMaW5lR2FwcyhbXSk7XG4gICAgICAgIHRoaXMubGluZUdhcERlY28gPSBEZWNvcmF0aW9uLnNldCh0aGlzLmxpbmVHYXBzLm1hcChnYXAgPT4gZ2FwLmRyYXcodGhpcywgZmFsc2UpKSk7XG4gICAgICAgIHRoaXMuY29tcHV0ZVZpc2libGVSYW5nZXMoKTtcbiAgICB9XG4gICAgdXBkYXRlRm9yVmlld3BvcnQoKSB7XG4gICAgICAgIGxldCB2aWV3cG9ydHMgPSBbdGhpcy52aWV3cG9ydF0sIHsgbWFpbiB9ID0gdGhpcy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IDE7IGkrKykge1xuICAgICAgICAgICAgbGV0IHBvcyA9IGkgPyBtYWluLmhlYWQgOiBtYWluLmFuY2hvcjtcbiAgICAgICAgICAgIGlmICghdmlld3BvcnRzLnNvbWUoKHsgZnJvbSwgdG8gfSkgPT4gcG9zID49IGZyb20gJiYgcG9zIDw9IHRvKSkge1xuICAgICAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSB0aGlzLmxpbmVCbG9ja0F0KHBvcyk7XG4gICAgICAgICAgICAgICAgdmlld3BvcnRzLnB1c2gobmV3IFZpZXdwb3J0KGZyb20sIHRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWV3cG9ydHMgPSB2aWV3cG9ydHMuc29ydCgoYSwgYikgPT4gYS5mcm9tIC0gYi5mcm9tKTtcbiAgICAgICAgdGhpcy5zY2FsZXIgPSB0aGlzLmhlaWdodE1hcC5oZWlnaHQgPD0gNzAwMDAwMCAvKiBWUC5NYXhET01IZWlnaHQgKi8gPyBJZFNjYWxlciA6XG4gICAgICAgICAgICBuZXcgQmlnU2NhbGVyKHRoaXMuaGVpZ2h0T3JhY2xlLCB0aGlzLmhlaWdodE1hcCwgdGhpcy52aWV3cG9ydHMpO1xuICAgIH1cbiAgICB1cGRhdGVWaWV3cG9ydExpbmVzKCkge1xuICAgICAgICB0aGlzLnZpZXdwb3J0TGluZXMgPSBbXTtcbiAgICAgICAgdGhpcy5oZWlnaHRNYXAuZm9yRWFjaExpbmUodGhpcy52aWV3cG9ydC5mcm9tLCB0aGlzLnZpZXdwb3J0LnRvLCB0aGlzLmhlaWdodE9yYWNsZS5zZXREb2ModGhpcy5zdGF0ZS5kb2MpLCAwLCAwLCBibG9jayA9PiB7XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0TGluZXMucHVzaCh0aGlzLnNjYWxlci5zY2FsZSA9PSAxID8gYmxvY2sgOiBzY2FsZUJsb2NrKGJsb2NrLCB0aGlzLnNjYWxlcikpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSwgc2Nyb2xsVGFyZ2V0ID0gbnVsbCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gdXBkYXRlLnN0YXRlO1xuICAgICAgICBsZXQgcHJldkRlY28gPSB0aGlzLnN0YXRlRGVjbztcbiAgICAgICAgdGhpcy5zdGF0ZURlY28gPSB0aGlzLnN0YXRlLmZhY2V0KGRlY29yYXRpb25zKS5maWx0ZXIoZCA9PiB0eXBlb2YgZCAhPSBcImZ1bmN0aW9uXCIpO1xuICAgICAgICBsZXQgY29udGVudENoYW5nZXMgPSB1cGRhdGUuY2hhbmdlZFJhbmdlcztcbiAgICAgICAgbGV0IGhlaWdodENoYW5nZXMgPSBDaGFuZ2VkUmFuZ2UuZXh0ZW5kV2l0aFJhbmdlcyhjb250ZW50Q2hhbmdlcywgaGVpZ2h0UmVsZXZhbnREZWNvQ2hhbmdlcyhwcmV2RGVjbywgdGhpcy5zdGF0ZURlY28sIHVwZGF0ZSA/IHVwZGF0ZS5jaGFuZ2VzIDogQ2hhbmdlU2V0LmVtcHR5KHRoaXMuc3RhdGUuZG9jLmxlbmd0aCkpKTtcbiAgICAgICAgbGV0IHByZXZIZWlnaHQgPSB0aGlzLmhlaWdodE1hcC5oZWlnaHQ7XG4gICAgICAgIGxldCBzY3JvbGxBbmNob3IgPSB0aGlzLnNjcm9sbGVkVG9Cb3R0b20gPyBudWxsIDogdGhpcy5zY3JvbGxBbmNob3JBdCh0aGlzLnNjcm9sbFRvcCk7XG4gICAgICAgIHRoaXMuaGVpZ2h0TWFwID0gdGhpcy5oZWlnaHRNYXAuYXBwbHlDaGFuZ2VzKHRoaXMuc3RhdGVEZWNvLCB1cGRhdGUuc3RhcnRTdGF0ZS5kb2MsIHRoaXMuaGVpZ2h0T3JhY2xlLnNldERvYyh0aGlzLnN0YXRlLmRvYyksIGhlaWdodENoYW5nZXMpO1xuICAgICAgICBpZiAodGhpcy5oZWlnaHRNYXAuaGVpZ2h0ICE9IHByZXZIZWlnaHQpXG4gICAgICAgICAgICB1cGRhdGUuZmxhZ3MgfD0gMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLztcbiAgICAgICAgaWYgKHNjcm9sbEFuY2hvcikge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxBbmNob3JQb3MgPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3Moc2Nyb2xsQW5jaG9yLmZyb20sIC0xKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gc2Nyb2xsQW5jaG9yLnRvcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQW5jaG9yUG9zID0gLTE7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEFuY2hvckhlaWdodCA9IHRoaXMuaGVpZ2h0TWFwLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmlld3BvcnQgPSBoZWlnaHRDaGFuZ2VzLmxlbmd0aCA/IHRoaXMubWFwVmlld3BvcnQodGhpcy52aWV3cG9ydCwgdXBkYXRlLmNoYW5nZXMpIDogdGhpcy52aWV3cG9ydDtcbiAgICAgICAgaWYgKHNjcm9sbFRhcmdldCAmJiAoc2Nyb2xsVGFyZ2V0LnJhbmdlLmhlYWQgPCB2aWV3cG9ydC5mcm9tIHx8IHNjcm9sbFRhcmdldC5yYW5nZS5oZWFkID4gdmlld3BvcnQudG8pIHx8XG4gICAgICAgICAgICAhdGhpcy52aWV3cG9ydElzQXBwcm9wcmlhdGUodmlld3BvcnQpKVxuICAgICAgICAgICAgdmlld3BvcnQgPSB0aGlzLmdldFZpZXdwb3J0KDAsIHNjcm9sbFRhcmdldCk7XG4gICAgICAgIGxldCB1cGRhdGVMaW5lcyA9ICF1cGRhdGUuY2hhbmdlcy5lbXB0eSB8fCAodXBkYXRlLmZsYWdzICYgMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLykgfHxcbiAgICAgICAgICAgIHZpZXdwb3J0LmZyb20gIT0gdGhpcy52aWV3cG9ydC5mcm9tIHx8IHZpZXdwb3J0LnRvICE9IHRoaXMudmlld3BvcnQudG87XG4gICAgICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAgICAgdGhpcy51cGRhdGVGb3JWaWV3cG9ydCgpO1xuICAgICAgICBpZiAodXBkYXRlTGluZXMpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0TGluZXMoKTtcbiAgICAgICAgaWYgKHRoaXMubGluZUdhcHMubGVuZ3RoIHx8IHRoaXMudmlld3BvcnQudG8gLSB0aGlzLnZpZXdwb3J0LmZyb20gPiAoMjAwMCAvKiBMRy5NYXJnaW4gKi8gPDwgMSkpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxpbmVHYXBzKHRoaXMuZW5zdXJlTGluZUdhcHModGhpcy5tYXBMaW5lR2Fwcyh0aGlzLmxpbmVHYXBzLCB1cGRhdGUuY2hhbmdlcykpKTtcbiAgICAgICAgdXBkYXRlLmZsYWdzIHw9IHRoaXMuY29tcHV0ZVZpc2libGVSYW5nZXMoKTtcbiAgICAgICAgaWYgKHNjcm9sbFRhcmdldClcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0ID0gc2Nyb2xsVGFyZ2V0O1xuICAgICAgICBpZiAoIXRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyAmJiB1cGRhdGUuc2VsZWN0aW9uU2V0ICYmIHVwZGF0ZS52aWV3LmxpbmVXcmFwcGluZyAmJlxuICAgICAgICAgICAgdXBkYXRlLnN0YXRlLnNlbGVjdGlvbi5tYWluLmVtcHR5ICYmIHVwZGF0ZS5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5hc3NvYyAmJlxuICAgICAgICAgICAgIXVwZGF0ZS5zdGF0ZS5mYWNldChuYXRpdmVTZWxlY3Rpb25IaWRkZW4pKVxuICAgICAgICAgICAgdGhpcy5tdXN0RW5mb3JjZUN1cnNvckFzc29jID0gdHJ1ZTtcbiAgICB9XG4gICAgbWVhc3VyZSh2aWV3KSB7XG4gICAgICAgIGxldCBkb20gPSB2aWV3LmNvbnRlbnRET00sIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9tKTtcbiAgICAgICAgbGV0IG9yYWNsZSA9IHRoaXMuaGVpZ2h0T3JhY2xlO1xuICAgICAgICBsZXQgd2hpdGVTcGFjZSA9IHN0eWxlLndoaXRlU3BhY2U7XG4gICAgICAgIHRoaXMuZGVmYXVsdFRleHREaXJlY3Rpb24gPSBzdHlsZS5kaXJlY3Rpb24gPT0gXCJydGxcIiA/IERpcmVjdGlvbi5SVEwgOiBEaXJlY3Rpb24uTFRSO1xuICAgICAgICBsZXQgcmVmcmVzaCA9IHRoaXMuaGVpZ2h0T3JhY2xlLm11c3RSZWZyZXNoRm9yV3JhcHBpbmcod2hpdGVTcGFjZSk7XG4gICAgICAgIGxldCBkb21SZWN0ID0gZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgbWVhc3VyZUNvbnRlbnQgPSByZWZyZXNoIHx8IHRoaXMubXVzdE1lYXN1cmVDb250ZW50IHx8IHRoaXMuY29udGVudERPTUhlaWdodCAhPSBkb21SZWN0LmhlaWdodDtcbiAgICAgICAgdGhpcy5jb250ZW50RE9NSGVpZ2h0ID0gZG9tUmVjdC5oZWlnaHQ7XG4gICAgICAgIHRoaXMubXVzdE1lYXN1cmVDb250ZW50ID0gZmFsc2U7XG4gICAgICAgIGxldCByZXN1bHQgPSAwLCBiaWFzID0gMDtcbiAgICAgICAgaWYgKGRvbVJlY3Qud2lkdGggJiYgZG9tUmVjdC5oZWlnaHQpIHtcbiAgICAgICAgICAgIGxldCB7IHNjYWxlWCwgc2NhbGVZIH0gPSBnZXRTY2FsZShkb20sIGRvbVJlY3QpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2NhbGVYICE9IHNjYWxlWCB8fCB0aGlzLnNjYWxlWSAhPSBzY2FsZVkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlWCA9IHNjYWxlWDtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlWSA9IHNjYWxlWTtcbiAgICAgICAgICAgICAgICByZXN1bHQgfD0gOCAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovO1xuICAgICAgICAgICAgICAgIHJlZnJlc2ggPSBtZWFzdXJlQ29udGVudCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmVydGljYWwgcGFkZGluZ1xuICAgICAgICBsZXQgcGFkZGluZ1RvcCA9IChwYXJzZUludChzdHlsZS5wYWRkaW5nVG9wKSB8fCAwKSAqIHRoaXMuc2NhbGVZO1xuICAgICAgICBsZXQgcGFkZGluZ0JvdHRvbSA9IChwYXJzZUludChzdHlsZS5wYWRkaW5nQm90dG9tKSB8fCAwKSAqIHRoaXMuc2NhbGVZO1xuICAgICAgICBpZiAodGhpcy5wYWRkaW5nVG9wICE9IHBhZGRpbmdUb3AgfHwgdGhpcy5wYWRkaW5nQm90dG9tICE9IHBhZGRpbmdCb3R0b20pIHtcbiAgICAgICAgICAgIHRoaXMucGFkZGluZ1RvcCA9IHBhZGRpbmdUb3A7XG4gICAgICAgICAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSBwYWRkaW5nQm90dG9tO1xuICAgICAgICAgICAgcmVzdWx0IHw9IDggLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLyB8IDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZWRpdG9yV2lkdGggIT0gdmlldy5zY3JvbGxET00uY2xpZW50V2lkdGgpIHtcbiAgICAgICAgICAgIGlmIChvcmFjbGUubGluZVdyYXBwaW5nKVxuICAgICAgICAgICAgICAgIG1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yV2lkdGggPSB2aWV3LnNjcm9sbERPTS5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIHJlc3VsdCB8PSA4IC8qIFVwZGF0ZUZsYWcuR2VvbWV0cnkgKi87XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNjcm9sbFRvcCA9IHZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCAqIHRoaXMuc2NhbGVZO1xuICAgICAgICBpZiAodGhpcy5zY3JvbGxUb3AgIT0gc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEFuY2hvckhlaWdodCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY3JvbGxlZFRvQm90dG9tID0gaXNTY3JvbGxlZFRvQm90dG9tKHZpZXcuc2Nyb2xsRE9NKTtcbiAgICAgICAgLy8gUGl4ZWwgdmlld3BvcnRcbiAgICAgICAgbGV0IHBpeGVsVmlld3BvcnQgPSAodGhpcy5wcmludGluZyA/IGZ1bGxQaXhlbFJhbmdlIDogdmlzaWJsZVBpeGVsUmFuZ2UpKGRvbSwgdGhpcy5wYWRkaW5nVG9wKTtcbiAgICAgICAgbGV0IGRUb3AgPSBwaXhlbFZpZXdwb3J0LnRvcCAtIHRoaXMucGl4ZWxWaWV3cG9ydC50b3AsIGRCb3R0b20gPSBwaXhlbFZpZXdwb3J0LmJvdHRvbSAtIHRoaXMucGl4ZWxWaWV3cG9ydC5ib3R0b207XG4gICAgICAgIHRoaXMucGl4ZWxWaWV3cG9ydCA9IHBpeGVsVmlld3BvcnQ7XG4gICAgICAgIGxldCBpblZpZXcgPSB0aGlzLnBpeGVsVmlld3BvcnQuYm90dG9tID4gdGhpcy5waXhlbFZpZXdwb3J0LnRvcCAmJiB0aGlzLnBpeGVsVmlld3BvcnQucmlnaHQgPiB0aGlzLnBpeGVsVmlld3BvcnQubGVmdDtcbiAgICAgICAgaWYgKGluVmlldyAhPSB0aGlzLmluVmlldykge1xuICAgICAgICAgICAgdGhpcy5pblZpZXcgPSBpblZpZXc7XG4gICAgICAgICAgICBpZiAoaW5WaWV3KVxuICAgICAgICAgICAgICAgIG1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaW5WaWV3ICYmICF0aGlzLnNjcm9sbFRhcmdldClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgY29udGVudFdpZHRoID0gZG9tUmVjdC53aWR0aDtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTVdpZHRoICE9IGNvbnRlbnRXaWR0aCB8fCB0aGlzLmVkaXRvckhlaWdodCAhPSB2aWV3LnNjcm9sbERPTS5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudERPTVdpZHRoID0gZG9tUmVjdC53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9ySGVpZ2h0ID0gdmlldy5zY3JvbGxET00uY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgcmVzdWx0IHw9IDggLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVhc3VyZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIGxldCBsaW5lSGVpZ2h0cyA9IHZpZXcuZG9jVmlldy5tZWFzdXJlVmlzaWJsZUxpbmVIZWlnaHRzKHRoaXMudmlld3BvcnQpO1xuICAgICAgICAgICAgaWYgKG9yYWNsZS5tdXN0UmVmcmVzaEZvckhlaWdodHMobGluZUhlaWdodHMpKVxuICAgICAgICAgICAgICAgIHJlZnJlc2ggPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHJlZnJlc2ggfHwgb3JhY2xlLmxpbmVXcmFwcGluZyAmJiBNYXRoLmFicyhjb250ZW50V2lkdGggLSB0aGlzLmNvbnRlbnRET01XaWR0aCkgPiBvcmFjbGUuY2hhcldpZHRoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgbGluZUhlaWdodCwgY2hhcldpZHRoLCB0ZXh0SGVpZ2h0IH0gPSB2aWV3LmRvY1ZpZXcubWVhc3VyZVRleHRTaXplKCk7XG4gICAgICAgICAgICAgICAgcmVmcmVzaCA9IGxpbmVIZWlnaHQgPiAwICYmIG9yYWNsZS5yZWZyZXNoKHdoaXRlU3BhY2UsIGxpbmVIZWlnaHQsIGNoYXJXaWR0aCwgdGV4dEhlaWdodCwgY29udGVudFdpZHRoIC8gY2hhcldpZHRoLCBsaW5lSGVpZ2h0cyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZnJlc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5kb2NWaWV3Lm1pbldpZHRoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0IHw9IDggLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZFRvcCA+IDAgJiYgZEJvdHRvbSA+IDApXG4gICAgICAgICAgICAgICAgYmlhcyA9IE1hdGgubWF4KGRUb3AsIGRCb3R0b20pO1xuICAgICAgICAgICAgZWxzZSBpZiAoZFRvcCA8IDAgJiYgZEJvdHRvbSA8IDApXG4gICAgICAgICAgICAgICAgYmlhcyA9IE1hdGgubWluKGRUb3AsIGRCb3R0b20pO1xuICAgICAgICAgICAgb3JhY2xlLmhlaWdodENoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAobGV0IHZwIG9mIHRoaXMudmlld3BvcnRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGhlaWdodHMgPSB2cC5mcm9tID09IHRoaXMudmlld3BvcnQuZnJvbSA/IGxpbmVIZWlnaHRzIDogdmlldy5kb2NWaWV3Lm1lYXN1cmVWaXNpYmxlTGluZUhlaWdodHModnApO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0TWFwID0gKHJlZnJlc2ggPyBIZWlnaHRNYXAuZW1wdHkoKS5hcHBseUNoYW5nZXModGhpcy5zdGF0ZURlY28sIFRleHQuZW1wdHksIHRoaXMuaGVpZ2h0T3JhY2xlLCBbbmV3IENoYW5nZWRSYW5nZSgwLCAwLCAwLCB2aWV3LnN0YXRlLmRvYy5sZW5ndGgpXSkgOiB0aGlzLmhlaWdodE1hcCkudXBkYXRlSGVpZ2h0KG9yYWNsZSwgMCwgcmVmcmVzaCwgbmV3IE1lYXN1cmVkSGVpZ2h0cyh2cC5mcm9tLCBoZWlnaHRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3JhY2xlLmhlaWdodENoYW5nZWQpXG4gICAgICAgICAgICAgICAgcmVzdWx0IHw9IDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi87XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZpZXdwb3J0Q2hhbmdlID0gIXRoaXMudmlld3BvcnRJc0FwcHJvcHJpYXRlKHRoaXMudmlld3BvcnQsIGJpYXMpIHx8XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRhcmdldCAmJiAodGhpcy5zY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA8IHRoaXMudmlld3BvcnQuZnJvbSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0LnJhbmdlLmhlYWQgPiB0aGlzLnZpZXdwb3J0LnRvKTtcbiAgICAgICAgaWYgKHZpZXdwb3J0Q2hhbmdlKVxuICAgICAgICAgICAgdGhpcy52aWV3cG9ydCA9IHRoaXMuZ2V0Vmlld3BvcnQoYmlhcywgdGhpcy5zY3JvbGxUYXJnZXQpO1xuICAgICAgICB0aGlzLnVwZGF0ZUZvclZpZXdwb3J0KCk7XG4gICAgICAgIGlmICgocmVzdWx0ICYgMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLykgfHwgdmlld3BvcnRDaGFuZ2UpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0TGluZXMoKTtcbiAgICAgICAgaWYgKHRoaXMubGluZUdhcHMubGVuZ3RoIHx8IHRoaXMudmlld3BvcnQudG8gLSB0aGlzLnZpZXdwb3J0LmZyb20gPiAoMjAwMCAvKiBMRy5NYXJnaW4gKi8gPDwgMSkpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxpbmVHYXBzKHRoaXMuZW5zdXJlTGluZUdhcHMocmVmcmVzaCA/IFtdIDogdGhpcy5saW5lR2FwcywgdmlldykpO1xuICAgICAgICByZXN1bHQgfD0gdGhpcy5jb21wdXRlVmlzaWJsZVJhbmdlcygpO1xuICAgICAgICBpZiAodGhpcy5tdXN0RW5mb3JjZUN1cnNvckFzc29jKSB7XG4gICAgICAgICAgICB0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgZG9uZSBpbiB0aGUgcmVhZCBzdGFnZSwgYmVjYXVzZSBtb3ZpbmcgdGhlIHNlbGVjdGlvblxuICAgICAgICAgICAgLy8gdG8gYSBsaW5lIGVuZCBpcyBnb2luZyB0byB0cmlnZ2VyIGEgbGF5b3V0IGFueXdheSwgc28gaXRcbiAgICAgICAgICAgIC8vIGNhbid0IGJlIGEgcHVyZSB3cml0ZS4gSXQgc2hvdWxkIGJlIHJhcmUgdGhhdCBpdCBkb2VzIGFueVxuICAgICAgICAgICAgLy8gd3JpdGluZy5cbiAgICAgICAgICAgIHZpZXcuZG9jVmlldy5lbmZvcmNlQ3Vyc29yQXNzb2MoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBnZXQgdmlzaWJsZVRvcCgpIHsgcmV0dXJuIHRoaXMuc2NhbGVyLmZyb21ET00odGhpcy5waXhlbFZpZXdwb3J0LnRvcCk7IH1cbiAgICBnZXQgdmlzaWJsZUJvdHRvbSgpIHsgcmV0dXJuIHRoaXMuc2NhbGVyLmZyb21ET00odGhpcy5waXhlbFZpZXdwb3J0LmJvdHRvbSk7IH1cbiAgICBnZXRWaWV3cG9ydChiaWFzLCBzY3JvbGxUYXJnZXQpIHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIGRpdmlkZSBWUC5NYXJnaW4gYmV0d2VlbiB0aGUgdG9wIGFuZCB0aGVcbiAgICAgICAgLy8gYm90dG9tLCBkZXBlbmRpbmcgb24gdGhlIGJpYXMgKHRoZSBjaGFuZ2UgaW4gdmlld3BvcnQgcG9zaXRpb25cbiAgICAgICAgLy8gc2luY2UgdGhlIGxhc3QgdXBkYXRlKS4gSXQnbGwgaG9sZCBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgICAgbGV0IG1hcmdpblRvcCA9IDAuNSAtIE1hdGgubWF4KC0wLjUsIE1hdGgubWluKDAuNSwgYmlhcyAvIDEwMDAgLyogVlAuTWFyZ2luICovIC8gMikpO1xuICAgICAgICBsZXQgbWFwID0gdGhpcy5oZWlnaHRNYXAsIG9yYWNsZSA9IHRoaXMuaGVpZ2h0T3JhY2xlO1xuICAgICAgICBsZXQgeyB2aXNpYmxlVG9wLCB2aXNpYmxlQm90dG9tIH0gPSB0aGlzO1xuICAgICAgICBsZXQgdmlld3BvcnQgPSBuZXcgVmlld3BvcnQobWFwLmxpbmVBdCh2aXNpYmxlVG9wIC0gbWFyZ2luVG9wICogMTAwMCAvKiBWUC5NYXJnaW4gKi8sIFF1ZXJ5VHlwZS5CeUhlaWdodCwgb3JhY2xlLCAwLCAwKS5mcm9tLCBtYXAubGluZUF0KHZpc2libGVCb3R0b20gKyAoMSAtIG1hcmdpblRvcCkgKiAxMDAwIC8qIFZQLk1hcmdpbiAqLywgUXVlcnlUeXBlLkJ5SGVpZ2h0LCBvcmFjbGUsIDAsIDApLnRvKTtcbiAgICAgICAgLy8gSWYgc2Nyb2xsVGFyZ2V0IGlzIGdpdmVuLCBtYWtlIHN1cmUgdGhlIHZpZXdwb3J0IGluY2x1ZGVzIHRoYXQgcG9zaXRpb25cbiAgICAgICAgaWYgKHNjcm9sbFRhcmdldCkge1xuICAgICAgICAgICAgbGV0IHsgaGVhZCB9ID0gc2Nyb2xsVGFyZ2V0LnJhbmdlO1xuICAgICAgICAgICAgaWYgKGhlYWQgPCB2aWV3cG9ydC5mcm9tIHx8IGhlYWQgPiB2aWV3cG9ydC50bykge1xuICAgICAgICAgICAgICAgIGxldCB2aWV3SGVpZ2h0ID0gTWF0aC5taW4odGhpcy5lZGl0b3JIZWlnaHQsIHRoaXMucGl4ZWxWaWV3cG9ydC5ib3R0b20gLSB0aGlzLnBpeGVsVmlld3BvcnQudG9wKTtcbiAgICAgICAgICAgICAgICBsZXQgYmxvY2sgPSBtYXAubGluZUF0KGhlYWQsIFF1ZXJ5VHlwZS5CeVBvcywgb3JhY2xlLCAwLCAwKSwgdG9wUG9zO1xuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxUYXJnZXQueSA9PSBcImNlbnRlclwiKVxuICAgICAgICAgICAgICAgICAgICB0b3BQb3MgPSAoYmxvY2sudG9wICsgYmxvY2suYm90dG9tKSAvIDIgLSB2aWV3SGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzY3JvbGxUYXJnZXQueSA9PSBcInN0YXJ0XCIgfHwgc2Nyb2xsVGFyZ2V0LnkgPT0gXCJuZWFyZXN0XCIgJiYgaGVhZCA8IHZpZXdwb3J0LmZyb20pXG4gICAgICAgICAgICAgICAgICAgIHRvcFBvcyA9IGJsb2NrLnRvcDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRvcFBvcyA9IGJsb2NrLmJvdHRvbSAtIHZpZXdIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmlld3BvcnQgPSBuZXcgVmlld3BvcnQobWFwLmxpbmVBdCh0b3BQb3MgLSAxMDAwIC8qIFZQLk1hcmdpbiAqLyAvIDIsIFF1ZXJ5VHlwZS5CeUhlaWdodCwgb3JhY2xlLCAwLCAwKS5mcm9tLCBtYXAubGluZUF0KHRvcFBvcyArIHZpZXdIZWlnaHQgKyAxMDAwIC8qIFZQLk1hcmdpbiAqLyAvIDIsIFF1ZXJ5VHlwZS5CeUhlaWdodCwgb3JhY2xlLCAwLCAwKS50byk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpZXdwb3J0O1xuICAgIH1cbiAgICBtYXBWaWV3cG9ydCh2aWV3cG9ydCwgY2hhbmdlcykge1xuICAgICAgICBsZXQgZnJvbSA9IGNoYW5nZXMubWFwUG9zKHZpZXdwb3J0LmZyb20sIC0xKSwgdG8gPSBjaGFuZ2VzLm1hcFBvcyh2aWV3cG9ydC50bywgMSk7XG4gICAgICAgIHJldHVybiBuZXcgVmlld3BvcnQodGhpcy5oZWlnaHRNYXAubGluZUF0KGZyb20sIFF1ZXJ5VHlwZS5CeVBvcywgdGhpcy5oZWlnaHRPcmFjbGUsIDAsIDApLmZyb20sIHRoaXMuaGVpZ2h0TWFwLmxpbmVBdCh0bywgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLmhlaWdodE9yYWNsZSwgMCwgMCkudG8pO1xuICAgIH1cbiAgICAvLyBDaGVja3MgaWYgYSBnaXZlbiB2aWV3cG9ydCBjb3ZlcnMgdGhlIHZpc2libGUgcGFydCBvZiB0aGVcbiAgICAvLyBkb2N1bWVudCBhbmQgbm90IHRvbyBtdWNoIGJleW9uZCB0aGF0LlxuICAgIHZpZXdwb3J0SXNBcHByb3ByaWF0ZSh7IGZyb20sIHRvIH0sIGJpYXMgPSAwKSB7XG4gICAgICAgIGlmICghdGhpcy5pblZpZXcpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGV0IHsgdG9wIH0gPSB0aGlzLmhlaWdodE1hcC5saW5lQXQoZnJvbSwgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLmhlaWdodE9yYWNsZSwgMCwgMCk7XG4gICAgICAgIGxldCB7IGJvdHRvbSB9ID0gdGhpcy5oZWlnaHRNYXAubGluZUF0KHRvLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKTtcbiAgICAgICAgbGV0IHsgdmlzaWJsZVRvcCwgdmlzaWJsZUJvdHRvbSB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChmcm9tID09IDAgfHwgdG9wIDw9IHZpc2libGVUb3AgLSBNYXRoLm1heCgxMCAvKiBWUC5NaW5Db3Zlck1hcmdpbiAqLywgTWF0aC5taW4oLWJpYXMsIDI1MCAvKiBWUC5NYXhDb3Zlck1hcmdpbiAqLykpKSAmJlxuICAgICAgICAgICAgKHRvID09IHRoaXMuc3RhdGUuZG9jLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgIGJvdHRvbSA+PSB2aXNpYmxlQm90dG9tICsgTWF0aC5tYXgoMTAgLyogVlAuTWluQ292ZXJNYXJnaW4gKi8sIE1hdGgubWluKGJpYXMsIDI1MCAvKiBWUC5NYXhDb3Zlck1hcmdpbiAqLykpKSAmJlxuICAgICAgICAgICAgKHRvcCA+IHZpc2libGVUb3AgLSAyICogMTAwMCAvKiBWUC5NYXJnaW4gKi8gJiYgYm90dG9tIDwgdmlzaWJsZUJvdHRvbSArIDIgKiAxMDAwIC8qIFZQLk1hcmdpbiAqLyk7XG4gICAgfVxuICAgIG1hcExpbmVHYXBzKGdhcHMsIGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKCFnYXBzLmxlbmd0aCB8fCBjaGFuZ2VzLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIGdhcHM7XG4gICAgICAgIGxldCBtYXBwZWQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZ2FwIG9mIGdhcHMpXG4gICAgICAgICAgICBpZiAoIWNoYW5nZXMudG91Y2hlc1JhbmdlKGdhcC5mcm9tLCBnYXAudG8pKVxuICAgICAgICAgICAgICAgIG1hcHBlZC5wdXNoKG5ldyBMaW5lR2FwKGNoYW5nZXMubWFwUG9zKGdhcC5mcm9tKSwgY2hhbmdlcy5tYXBQb3MoZ2FwLnRvKSwgZ2FwLnNpemUpKTtcbiAgICAgICAgcmV0dXJuIG1hcHBlZDtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZXMgcG9zaXRpb25zIGluIHRoZSB2aWV3cG9ydCB3aGVyZSB0aGUgc3RhcnQgb3IgZW5kIG9mIGFcbiAgICAvLyBsaW5lIHNob3VsZCBiZSBoaWRkZW4sIHRyeWluZyB0byByZXVzZSBleGlzdGluZyBsaW5lIGdhcHMgd2hlblxuICAgIC8vIGFwcHJvcHJpYXRlIHRvIGF2b2lkIHVubmVjY2VzYXJ5IHJlZHJhd3MuXG4gICAgLy8gVXNlcyBjcnVkZSBjaGFyYWN0ZXItY291bnRpbmcgZm9yIHRoZSBwb3NpdGlvbmluZyBhbmQgc2l6aW5nLFxuICAgIC8vIHNpbmNlIGFjdHVhbCBET00gY29vcmRpbmF0ZXMgYXJlbid0IGFsd2F5cyBhdmFpbGFibGUgYW5kXG4gICAgLy8gcHJlZGljdGFibGUuIFJlbGllcyBvbiBnZW5lcm91cyBtYXJnaW5zIChzZWUgTEcuTWFyZ2luKSB0byBoaWRlXG4gICAgLy8gdGhlIGFydGlmYWN0cyB0aGlzIG1pZ2h0IHByb2R1Y2UgZnJvbSB0aGUgdXNlci5cbiAgICBlbnN1cmVMaW5lR2FwcyhjdXJyZW50LCBtYXlNZWFzdXJlKSB7XG4gICAgICAgIGxldCB3cmFwcGluZyA9IHRoaXMuaGVpZ2h0T3JhY2xlLmxpbmVXcmFwcGluZztcbiAgICAgICAgbGV0IG1hcmdpbiA9IHdyYXBwaW5nID8gMTAwMDAgLyogTEcuTWFyZ2luV3JhcCAqLyA6IDIwMDAgLyogTEcuTWFyZ2luICovLCBoYWxmTWFyZ2luID0gbWFyZ2luID4+IDEsIGRvdWJsZU1hcmdpbiA9IG1hcmdpbiA8PCAxO1xuICAgICAgICAvLyBUaGUgbm9uLXdyYXBwaW5nIGxvZ2ljIHdvbid0IHdvcmsgYXQgYWxsIGluIHByZWRvbWluYW50bHkgcmlnaHQtdG8tbGVmdCB0ZXh0LlxuICAgICAgICBpZiAodGhpcy5kZWZhdWx0VGV4dERpcmVjdGlvbiAhPSBEaXJlY3Rpb24uTFRSICYmICF3cmFwcGluZylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgbGV0IGdhcHMgPSBbXTtcbiAgICAgICAgbGV0IGFkZEdhcCA9IChmcm9tLCB0bywgbGluZSwgc3RydWN0dXJlKSA9PiB7XG4gICAgICAgICAgICBpZiAodG8gLSBmcm9tIDwgaGFsZk1hcmdpbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgc2VsID0gdGhpcy5zdGF0ZS5zZWxlY3Rpb24ubWFpbiwgYXZvaWQgPSBbc2VsLmZyb21dO1xuICAgICAgICAgICAgaWYgKCFzZWwuZW1wdHkpXG4gICAgICAgICAgICAgICAgYXZvaWQucHVzaChzZWwudG8pO1xuICAgICAgICAgICAgZm9yIChsZXQgcG9zIG9mIGF2b2lkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20gJiYgcG9zIDwgdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkR2FwKGZyb20sIHBvcyAtIDEwIC8qIExHLlNlbGVjdGlvbk1hcmdpbiAqLywgbGluZSwgc3RydWN0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkR2FwKHBvcyArIDEwIC8qIExHLlNlbGVjdGlvbk1hcmdpbiAqLywgdG8sIGxpbmUsIHN0cnVjdHVyZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZ2FwID0gZmluZChjdXJyZW50LCBnYXAgPT4gZ2FwLmZyb20gPj0gbGluZS5mcm9tICYmIGdhcC50byA8PSBsaW5lLnRvICYmXG4gICAgICAgICAgICAgICAgTWF0aC5hYnMoZ2FwLmZyb20gLSBmcm9tKSA8IGhhbGZNYXJnaW4gJiYgTWF0aC5hYnMoZ2FwLnRvIC0gdG8pIDwgaGFsZk1hcmdpbiAmJlxuICAgICAgICAgICAgICAgICFhdm9pZC5zb21lKHBvcyA9PiBnYXAuZnJvbSA8IHBvcyAmJiBnYXAudG8gPiBwb3MpKTtcbiAgICAgICAgICAgIGlmICghZ2FwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBzY3JvbGxpbmcgZG93biwgc25hcCBnYXAgZW5kcyB0byBsaW5lIHN0YXJ0cyB0byBhdm9pZCBzaGlmdHMgaW4gd3JhcHBpbmdcbiAgICAgICAgICAgICAgICBpZiAodG8gPCBsaW5lLnRvICYmIG1heU1lYXN1cmUgJiYgd3JhcHBpbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgbWF5TWVhc3VyZS52aXNpYmxlUmFuZ2VzLnNvbWUociA9PiByLmZyb20gPD0gdG8gJiYgci50byA+PSB0bykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmVTdGFydCA9IG1heU1lYXN1cmUubW92ZVRvTGluZUJvdW5kYXJ5KEVkaXRvclNlbGVjdGlvbi5jdXJzb3IodG8pLCBmYWxzZSwgdHJ1ZSkuaGVhZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVTdGFydCA+IGZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICB0byA9IGxpbmVTdGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2FwID0gbmV3IExpbmVHYXAoZnJvbSwgdG8sIHRoaXMuZ2FwU2l6ZShsaW5lLCBmcm9tLCB0bywgc3RydWN0dXJlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnYXBzLnB1c2goZ2FwKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0aGlzLnZpZXdwb3J0TGluZXMpIHtcbiAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA8IGRvdWJsZU1hcmdpbilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBzdHJ1Y3R1cmUgPSBsaW5lU3RydWN0dXJlKGxpbmUuZnJvbSwgbGluZS50bywgdGhpcy5zdGF0ZURlY28pO1xuICAgICAgICAgICAgaWYgKHN0cnVjdHVyZS50b3RhbCA8IGRvdWJsZU1hcmdpbilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLnNjcm9sbFRhcmdldCA/IHRoaXMuc2Nyb2xsVGFyZ2V0LnJhbmdlLmhlYWQgOiBudWxsO1xuICAgICAgICAgICAgbGV0IHZpZXdGcm9tLCB2aWV3VG87XG4gICAgICAgICAgICBpZiAod3JhcHBpbmcpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFyZ2luSGVpZ2h0ID0gKG1hcmdpbiAvIHRoaXMuaGVpZ2h0T3JhY2xlLmxpbmVMZW5ndGgpICogdGhpcy5oZWlnaHRPcmFjbGUubGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICBsZXQgdG9wLCBib3Q7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXRGcmFjID0gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwYWNlRnJhYyA9ICgodGhpcy52aXNpYmxlQm90dG9tIC0gdGhpcy52aXNpYmxlVG9wKSAvIDIgKyBtYXJnaW5IZWlnaHQpIC8gbGluZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IHRhcmdldEZyYWMgLSBzcGFjZUZyYWM7XG4gICAgICAgICAgICAgICAgICAgIGJvdCA9IHRhcmdldEZyYWMgKyBzcGFjZUZyYWM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b3AgPSAodGhpcy52aXNpYmxlVG9wIC0gbGluZS50b3AgLSBtYXJnaW5IZWlnaHQpIC8gbGluZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGJvdCA9ICh0aGlzLnZpc2libGVCb3R0b20gLSBsaW5lLnRvcCArIG1hcmdpbkhlaWdodCkgLyBsaW5lLmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmlld0Zyb20gPSBmaW5kUG9zaXRpb24oc3RydWN0dXJlLCB0b3ApO1xuICAgICAgICAgICAgICAgIHZpZXdUbyA9IGZpbmRQb3NpdGlvbihzdHJ1Y3R1cmUsIGJvdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdG90YWxXaWR0aCA9IHN0cnVjdHVyZS50b3RhbCAqIHRoaXMuaGVpZ2h0T3JhY2xlLmNoYXJXaWR0aDtcbiAgICAgICAgICAgICAgICBsZXQgbWFyZ2luV2lkdGggPSBtYXJnaW4gKiB0aGlzLmhlaWdodE9yYWNsZS5jaGFyV2lkdGg7XG4gICAgICAgICAgICAgICAgbGV0IGxlZnQsIHJpZ2h0O1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0RnJhYyA9IGZpbmRGcmFjdGlvbihzdHJ1Y3R1cmUsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGFjZUZyYWMgPSAoKHRoaXMucGl4ZWxWaWV3cG9ydC5yaWdodCAtIHRoaXMucGl4ZWxWaWV3cG9ydC5sZWZ0KSAvIDIgKyBtYXJnaW5XaWR0aCkgLyB0b3RhbFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gdGFyZ2V0RnJhYyAtIHNwYWNlRnJhYztcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB0YXJnZXRGcmFjICsgc3BhY2VGcmFjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9ICh0aGlzLnBpeGVsVmlld3BvcnQubGVmdCAtIG1hcmdpbldpZHRoKSAvIHRvdGFsV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gKHRoaXMucGl4ZWxWaWV3cG9ydC5yaWdodCArIG1hcmdpbldpZHRoKSAvIHRvdGFsV2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZpZXdGcm9tID0gZmluZFBvc2l0aW9uKHN0cnVjdHVyZSwgbGVmdCk7XG4gICAgICAgICAgICAgICAgdmlld1RvID0gZmluZFBvc2l0aW9uKHN0cnVjdHVyZSwgcmlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpZXdGcm9tID4gbGluZS5mcm9tKVxuICAgICAgICAgICAgICAgIGFkZEdhcChsaW5lLmZyb20sIHZpZXdGcm9tLCBsaW5lLCBzdHJ1Y3R1cmUpO1xuICAgICAgICAgICAgaWYgKHZpZXdUbyA8IGxpbmUudG8pXG4gICAgICAgICAgICAgICAgYWRkR2FwKHZpZXdUbywgbGluZS50bywgbGluZSwgc3RydWN0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2FwcztcbiAgICB9XG4gICAgZ2FwU2l6ZShsaW5lLCBmcm9tLCB0bywgc3RydWN0dXJlKSB7XG4gICAgICAgIGxldCBmcmFjdGlvbiA9IGZpbmRGcmFjdGlvbihzdHJ1Y3R1cmUsIHRvKSAtIGZpbmRGcmFjdGlvbihzdHJ1Y3R1cmUsIGZyb20pO1xuICAgICAgICBpZiAodGhpcy5oZWlnaHRPcmFjbGUubGluZVdyYXBwaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbGluZS5oZWlnaHQgKiBmcmFjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3R1cmUudG90YWwgKiB0aGlzLmhlaWdodE9yYWNsZS5jaGFyV2lkdGggKiBmcmFjdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVMaW5lR2FwcyhnYXBzKSB7XG4gICAgICAgIGlmICghTGluZUdhcC5zYW1lKGdhcHMsIHRoaXMubGluZUdhcHMpKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVHYXBzID0gZ2FwcztcbiAgICAgICAgICAgIHRoaXMubGluZUdhcERlY28gPSBEZWNvcmF0aW9uLnNldChnYXBzLm1hcChnYXAgPT4gZ2FwLmRyYXcodGhpcywgdGhpcy5oZWlnaHRPcmFjbGUubGluZVdyYXBwaW5nKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXB1dGVWaXNpYmxlUmFuZ2VzKCkge1xuICAgICAgICBsZXQgZGVjbyA9IHRoaXMuc3RhdGVEZWNvO1xuICAgICAgICBpZiAodGhpcy5saW5lR2Fwcy5sZW5ndGgpXG4gICAgICAgICAgICBkZWNvID0gZGVjby5jb25jYXQodGhpcy5saW5lR2FwRGVjbyk7XG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgUmFuZ2VTZXQuc3BhbnMoZGVjbywgdGhpcy52aWV3cG9ydC5mcm9tLCB0aGlzLnZpZXdwb3J0LnRvLCB7XG4gICAgICAgICAgICBzcGFuKGZyb20sIHRvKSB7IHJhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSk7IH0sXG4gICAgICAgICAgICBwb2ludCgpIHsgfVxuICAgICAgICB9LCAyMCk7XG4gICAgICAgIGxldCBjaGFuZ2VkID0gcmFuZ2VzLmxlbmd0aCAhPSB0aGlzLnZpc2libGVSYW5nZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICB0aGlzLnZpc2libGVSYW5nZXMuc29tZSgociwgaSkgPT4gci5mcm9tICE9IHJhbmdlc1tpXS5mcm9tIHx8IHIudG8gIT0gcmFuZ2VzW2ldLnRvKTtcbiAgICAgICAgdGhpcy52aXNpYmxlUmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICByZXR1cm4gY2hhbmdlZCA/IDQgLyogVXBkYXRlRmxhZy5WaWV3cG9ydCAqLyA6IDA7XG4gICAgfVxuICAgIGxpbmVCbG9ja0F0KHBvcykge1xuICAgICAgICByZXR1cm4gKHBvcyA+PSB0aGlzLnZpZXdwb3J0LmZyb20gJiYgcG9zIDw9IHRoaXMudmlld3BvcnQudG8gJiYgdGhpcy52aWV3cG9ydExpbmVzLmZpbmQoYiA9PiBiLmZyb20gPD0gcG9zICYmIGIudG8gPj0gcG9zKSkgfHxcbiAgICAgICAgICAgIHNjYWxlQmxvY2sodGhpcy5oZWlnaHRNYXAubGluZUF0KHBvcywgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLmhlaWdodE9yYWNsZSwgMCwgMCksIHRoaXMuc2NhbGVyKTtcbiAgICB9XG4gICAgbGluZUJsb2NrQXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBzY2FsZUJsb2NrKHRoaXMuaGVpZ2h0TWFwLmxpbmVBdCh0aGlzLnNjYWxlci5mcm9tRE9NKGhlaWdodCksIFF1ZXJ5VHlwZS5CeUhlaWdodCwgdGhpcy5oZWlnaHRPcmFjbGUsIDAsIDApLCB0aGlzLnNjYWxlcik7XG4gICAgfVxuICAgIHNjcm9sbEFuY2hvckF0KHNjcm9sbFRvcCkge1xuICAgICAgICBsZXQgYmxvY2sgPSB0aGlzLmxpbmVCbG9ja0F0SGVpZ2h0KHNjcm9sbFRvcCArIDgpO1xuICAgICAgICByZXR1cm4gYmxvY2suZnJvbSA+PSB0aGlzLnZpZXdwb3J0LmZyb20gfHwgdGhpcy52aWV3cG9ydExpbmVzWzBdLnRvcCAtIHNjcm9sbFRvcCA+IDIwMCA/IGJsb2NrIDogdGhpcy52aWV3cG9ydExpbmVzWzBdO1xuICAgIH1cbiAgICBlbGVtZW50QXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBzY2FsZUJsb2NrKHRoaXMuaGVpZ2h0TWFwLmJsb2NrQXQodGhpcy5zY2FsZXIuZnJvbURPTShoZWlnaHQpLCB0aGlzLmhlaWdodE9yYWNsZSwgMCwgMCksIHRoaXMuc2NhbGVyKTtcbiAgICB9XG4gICAgZ2V0IGRvY0hlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGVyLnRvRE9NKHRoaXMuaGVpZ2h0TWFwLmhlaWdodCk7XG4gICAgfVxuICAgIGdldCBjb250ZW50SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NIZWlnaHQgKyB0aGlzLnBhZGRpbmdUb3AgKyB0aGlzLnBhZGRpbmdCb3R0b207XG4gICAgfVxufVxuY2xhc3MgVmlld3BvcnQge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG59XG5mdW5jdGlvbiBsaW5lU3RydWN0dXJlKGZyb20sIHRvLCBzdGF0ZURlY28pIHtcbiAgICBsZXQgcmFuZ2VzID0gW10sIHBvcyA9IGZyb20sIHRvdGFsID0gMDtcbiAgICBSYW5nZVNldC5zcGFucyhzdGF0ZURlY28sIGZyb20sIHRvLCB7XG4gICAgICAgIHNwYW4oKSB7IH0sXG4gICAgICAgIHBvaW50KGZyb20sIHRvKSB7XG4gICAgICAgICAgICBpZiAoZnJvbSA+IHBvcykge1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbTogcG9zLCB0bzogZnJvbSB9KTtcbiAgICAgICAgICAgICAgICB0b3RhbCArPSBmcm9tIC0gcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gdG87XG4gICAgICAgIH1cbiAgICB9LCAyMCk7IC8vIFdlJ3JlIG9ubHkgaW50ZXJlc3RlZCBpbiBjb2xsYXBzZWQgcmFuZ2VzIG9mIGEgc2lnbmlmaWNhbnQgc2l6ZVxuICAgIGlmIChwb3MgPCB0bykge1xuICAgICAgICByYW5nZXMucHVzaCh7IGZyb206IHBvcywgdG8gfSk7XG4gICAgICAgIHRvdGFsICs9IHRvIC0gcG9zO1xuICAgIH1cbiAgICByZXR1cm4geyB0b3RhbCwgcmFuZ2VzIH07XG59XG5mdW5jdGlvbiBmaW5kUG9zaXRpb24oeyB0b3RhbCwgcmFuZ2VzIH0sIHJhdGlvKSB7XG4gICAgaWYgKHJhdGlvIDw9IDApXG4gICAgICAgIHJldHVybiByYW5nZXNbMF0uZnJvbTtcbiAgICBpZiAocmF0aW8gPj0gMSlcbiAgICAgICAgcmV0dXJuIHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0udG87XG4gICAgbGV0IGRpc3QgPSBNYXRoLmZsb29yKHRvdGFsICogcmF0aW8pO1xuICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSByYW5nZXNbaV0sIHNpemUgPSB0byAtIGZyb207XG4gICAgICAgIGlmIChkaXN0IDw9IHNpemUpXG4gICAgICAgICAgICByZXR1cm4gZnJvbSArIGRpc3Q7XG4gICAgICAgIGRpc3QgLT0gc2l6ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kRnJhY3Rpb24oc3RydWN0dXJlLCBwb3MpIHtcbiAgICBsZXQgY291bnRlZCA9IDA7XG4gICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIHN0cnVjdHVyZS5yYW5nZXMpIHtcbiAgICAgICAgaWYgKHBvcyA8PSB0bykge1xuICAgICAgICAgICAgY291bnRlZCArPSBwb3MgLSBmcm9tO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY291bnRlZCArPSB0byAtIGZyb207XG4gICAgfVxuICAgIHJldHVybiBjb3VudGVkIC8gc3RydWN0dXJlLnRvdGFsO1xufVxuZnVuY3Rpb24gZmluZChhcnJheSwgZikge1xuICAgIGZvciAobGV0IHZhbCBvZiBhcnJheSlcbiAgICAgICAgaWYgKGYodmFsKSlcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8vIERvbid0IHNjYWxlIHdoZW4gdGhlIGRvY3VtZW50IGhlaWdodCBpcyB3aXRoaW4gdGhlIHJhbmdlIG9mIHdoYXRcbi8vIHRoZSBET00gY2FuIGhhbmRsZS5cbmNvbnN0IElkU2NhbGVyID0ge1xuICAgIHRvRE9NKG4pIHsgcmV0dXJuIG47IH0sXG4gICAgZnJvbURPTShuKSB7IHJldHVybiBuOyB9LFxuICAgIHNjYWxlOiAxXG59O1xuLy8gV2hlbiB0aGUgaGVpZ2h0IGlzIHRvbyBiaWcgKD4gVlAuTWF4RE9NSGVpZ2h0KSwgc2NhbGUgZG93biB0aGVcbi8vIHJlZ2lvbnMgb3V0c2lkZSB0aGUgdmlld3BvcnRzIHNvIHRoYXQgdGhlIHRvdGFsIGhlaWdodCBpc1xuLy8gVlAuTWF4RE9NSGVpZ2h0LlxuY2xhc3MgQmlnU2NhbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcmFjbGUsIGhlaWdodE1hcCwgdmlld3BvcnRzKSB7XG4gICAgICAgIGxldCB2cEhlaWdodCA9IDAsIGJhc2UgPSAwLCBkb21CYXNlID0gMDtcbiAgICAgICAgdGhpcy52aWV3cG9ydHMgPSB2aWV3cG9ydHMubWFwKCh7IGZyb20sIHRvIH0pID0+IHtcbiAgICAgICAgICAgIGxldCB0b3AgPSBoZWlnaHRNYXAubGluZUF0KGZyb20sIFF1ZXJ5VHlwZS5CeVBvcywgb3JhY2xlLCAwLCAwKS50b3A7XG4gICAgICAgICAgICBsZXQgYm90dG9tID0gaGVpZ2h0TWFwLmxpbmVBdCh0bywgUXVlcnlUeXBlLkJ5UG9zLCBvcmFjbGUsIDAsIDApLmJvdHRvbTtcbiAgICAgICAgICAgIHZwSGVpZ2h0ICs9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgICAgIHJldHVybiB7IGZyb20sIHRvLCB0b3AsIGJvdHRvbSwgZG9tVG9wOiAwLCBkb21Cb3R0b206IDAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2NhbGUgPSAoNzAwMDAwMCAvKiBWUC5NYXhET01IZWlnaHQgKi8gLSB2cEhlaWdodCkgLyAoaGVpZ2h0TWFwLmhlaWdodCAtIHZwSGVpZ2h0KTtcbiAgICAgICAgZm9yIChsZXQgb2JqIG9mIHRoaXMudmlld3BvcnRzKSB7XG4gICAgICAgICAgICBvYmouZG9tVG9wID0gZG9tQmFzZSArIChvYmoudG9wIC0gYmFzZSkgKiB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgZG9tQmFzZSA9IG9iai5kb21Cb3R0b20gPSBvYmouZG9tVG9wICsgKG9iai5ib3R0b20gLSBvYmoudG9wKTtcbiAgICAgICAgICAgIGJhc2UgPSBvYmouYm90dG9tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvRE9NKG4pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGJhc2UgPSAwLCBkb21CYXNlID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IHZwID0gaSA8IHRoaXMudmlld3BvcnRzLmxlbmd0aCA/IHRoaXMudmlld3BvcnRzW2ldIDogbnVsbDtcbiAgICAgICAgICAgIGlmICghdnAgfHwgbiA8IHZwLnRvcClcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tQmFzZSArIChuIC0gYmFzZSkgKiB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgaWYgKG4gPD0gdnAuYm90dG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiB2cC5kb21Ub3AgKyAobiAtIHZwLnRvcCk7XG4gICAgICAgICAgICBiYXNlID0gdnAuYm90dG9tO1xuICAgICAgICAgICAgZG9tQmFzZSA9IHZwLmRvbUJvdHRvbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmcm9tRE9NKG4pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGJhc2UgPSAwLCBkb21CYXNlID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IHZwID0gaSA8IHRoaXMudmlld3BvcnRzLmxlbmd0aCA/IHRoaXMudmlld3BvcnRzW2ldIDogbnVsbDtcbiAgICAgICAgICAgIGlmICghdnAgfHwgbiA8IHZwLmRvbVRvcClcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZSArIChuIC0gZG9tQmFzZSkgLyB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgaWYgKG4gPD0gdnAuZG9tQm90dG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiB2cC50b3AgKyAobiAtIHZwLmRvbVRvcCk7XG4gICAgICAgICAgICBiYXNlID0gdnAuYm90dG9tO1xuICAgICAgICAgICAgZG9tQmFzZSA9IHZwLmRvbUJvdHRvbTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNjYWxlQmxvY2soYmxvY2ssIHNjYWxlcikge1xuICAgIGlmIChzY2FsZXIuc2NhbGUgPT0gMSlcbiAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIGxldCBiVG9wID0gc2NhbGVyLnRvRE9NKGJsb2NrLnRvcCksIGJCb3R0b20gPSBzY2FsZXIudG9ET00oYmxvY2suYm90dG9tKTtcbiAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhibG9jay5mcm9tLCBibG9jay5sZW5ndGgsIGJUb3AsIGJCb3R0b20gLSBiVG9wLCBBcnJheS5pc0FycmF5KGJsb2NrLl9jb250ZW50KSA/IGJsb2NrLl9jb250ZW50Lm1hcChiID0+IHNjYWxlQmxvY2soYiwgc2NhbGVyKSkgOiBibG9jay5fY29udGVudCk7XG59XG5cbmNvbnN0IHRoZW1lID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7IGNvbWJpbmU6IHN0cnMgPT4gc3Rycy5qb2luKFwiIFwiKSB9KTtcbmNvbnN0IGRhcmtUaGVtZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmluZGV4T2YodHJ1ZSkgPiAtMSB9KTtcbmNvbnN0IGJhc2VUaGVtZUlEID0gLypAX19QVVJFX18qL1N0eWxlTW9kdWxlLm5ld05hbWUoKSwgYmFzZUxpZ2h0SUQgPSAvKkBfX1BVUkVfXyovU3R5bGVNb2R1bGUubmV3TmFtZSgpLCBiYXNlRGFya0lEID0gLypAX19QVVJFX18qL1N0eWxlTW9kdWxlLm5ld05hbWUoKTtcbmNvbnN0IGxpZ2h0RGFya0lEcyA9IHsgXCImbGlnaHRcIjogXCIuXCIgKyBiYXNlTGlnaHRJRCwgXCImZGFya1wiOiBcIi5cIiArIGJhc2VEYXJrSUQgfTtcbmZ1bmN0aW9uIGJ1aWxkVGhlbWUobWFpbiwgc3BlYywgc2NvcGVzKSB7XG4gICAgcmV0dXJuIG5ldyBTdHlsZU1vZHVsZShzcGVjLCB7XG4gICAgICAgIGZpbmlzaChzZWwpIHtcbiAgICAgICAgICAgIHJldHVybiAvJi8udGVzdChzZWwpID8gc2VsLnJlcGxhY2UoLyZcXHcqLywgbSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG0gPT0gXCImXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWluO1xuICAgICAgICAgICAgICAgIGlmICghc2NvcGVzIHx8ICFzY29wZXNbbV0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVbnN1cHBvcnRlZCBzZWxlY3RvcjogJHttfWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZXNbbV07XG4gICAgICAgICAgICB9KSA6IG1haW4gKyBcIiBcIiArIHNlbDtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuY29uc3QgYmFzZVRoZW1lJDEgPSAvKkBfX1BVUkVfXyovYnVpbGRUaGVtZShcIi5cIiArIGJhc2VUaGVtZUlELCB7XG4gICAgXCImXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmUgIWltcG9ydGFudFwiLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBcIiYuY20tZm9jdXNlZFwiOiB7XG4gICAgICAgICAgICAvLyBQcm92aWRlIGEgc2ltcGxlIGRlZmF1bHQgb3V0bGluZSB0byBtYWtlIHN1cmUgYSBmb2N1c2VkXG4gICAgICAgICAgICAvLyBlZGl0b3IgaXMgdmlzdWFsbHkgZGlzdGluY3QuIENhbid0IGxlYXZlIHRoZSBkZWZhdWx0IGJlaGF2aW9yXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd2lsbCBhcHBseSB0byB0aGUgY29udGVudCBlbGVtZW50LCB3aGljaCBpc1xuICAgICAgICAgICAgLy8gaW5zaWRlIHRoZSBzY3JvbGxhYmxlIGNvbnRhaW5lciBhbmQgZG9lc24ndCBpbmNsdWRlIHRoZVxuICAgICAgICAgICAgLy8gZ3V0dGVycy4gV2UgYWxzbyBjYW4ndCB1c2UgYW4gJ2F1dG8nIG91dGxpbmUsIHNpbmNlIHRob3NlXG4gICAgICAgICAgICAvLyBhcmUsIGZvciBzb21lIHJlYXNvbiwgZHJhd24gYmVoaW5kIHRoZSBlbGVtZW50IGNvbnRlbnQsIHdoaWNoXG4gICAgICAgICAgICAvLyB3aWxsIGNhdXNlIHRoaW5ncyBsaWtlIHRoZSBhY3RpdmUgbGluZSBiYWNrZ3JvdW5kIHRvIGNvdmVyXG4gICAgICAgICAgICAvLyB0aGUgb3V0bGluZSAoIzI5NykuXG4gICAgICAgICAgICBvdXRsaW5lOiBcIjFweCBkb3R0ZWQgIzIxMjEyMVwiXG4gICAgICAgIH0sXG4gICAgICAgIGRpc3BsYXk6IFwiZmxleCAhaW1wb3J0YW50XCIsXG4gICAgICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCJcbiAgICB9LFxuICAgIFwiLmNtLXNjcm9sbGVyXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJmbGV4ICFpbXBvcnRhbnRcIixcbiAgICAgICAgYWxpZ25JdGVtczogXCJmbGV4LXN0YXJ0ICFpbXBvcnRhbnRcIixcbiAgICAgICAgZm9udEZhbWlseTogXCJtb25vc3BhY2VcIixcbiAgICAgICAgbGluZUhlaWdodDogMS40LFxuICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBvdmVyZmxvd1g6IFwiYXV0b1wiLFxuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICB6SW5kZXg6IDBcbiAgICB9LFxuICAgIFwiLmNtLWNvbnRlbnRcIjoge1xuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIGZsZXhHcm93OiAyLFxuICAgICAgICBmbGV4U2hyaW5rOiAwLFxuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICAgIHdoaXRlU3BhY2U6IFwicHJlXCIsXG4gICAgICAgIHdvcmRXcmFwOiBcIm5vcm1hbFwiLCAvLyBodHRwczovL2dpdGh1Yi5jb20vY29kZW1pcnJvci9kZXYvaXNzdWVzLzQ1NlxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBtaW5IZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBwYWRkaW5nOiBcIjRweCAwXCIsXG4gICAgICAgIG91dGxpbmU6IFwibm9uZVwiLFxuICAgICAgICBcIiZbY29udGVudGVkaXRhYmxlPXRydWVdXCI6IHtcbiAgICAgICAgICAgIFdlYmtpdFVzZXJNb2RpZnk6IFwicmVhZC13cml0ZS1wbGFpbnRleHQtb25seVwiLFxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIi5jbS1saW5lV3JhcHBpbmdcIjoge1xuICAgICAgICB3aGl0ZVNwYWNlX2ZhbGxiYWNrOiBcInByZS13cmFwXCIsIC8vIEZvciBJRVxuICAgICAgICB3aGl0ZVNwYWNlOiBcImJyZWFrLXNwYWNlc1wiLFxuICAgICAgICB3b3JkQnJlYWs6IFwiYnJlYWstd29yZFwiLCAvLyBGb3IgU2FmYXJpLCB3aGljaCBkb2Vzbid0IHN1cHBvcnQgb3ZlcmZsb3ctd3JhcDogYW55d2hlcmVcbiAgICAgICAgb3ZlcmZsb3dXcmFwOiBcImFueXdoZXJlXCIsXG4gICAgICAgIGZsZXhTaHJpbms6IDFcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1jb250ZW50XCI6IHsgY2FyZXRDb2xvcjogXCJibGFja1wiIH0sXG4gICAgXCImZGFyayAuY20tY29udGVudFwiOiB7IGNhcmV0Q29sb3I6IFwid2hpdGVcIiB9LFxuICAgIFwiLmNtLWxpbmVcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiMCAycHggMCA2cHhcIlxuICAgIH0sXG4gICAgXCIuY20tbGF5ZXJcIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGNvbnRhaW46IFwic2l6ZSBzdHlsZVwiLFxuICAgICAgICBcIiYgPiAqXCI6IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXNlbGVjdGlvbkJhY2tncm91bmRcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNkOWQ5ZDlcIlxuICAgIH0sXG4gICAgXCImZGFyayAuY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzIyMlwiXG4gICAgfSxcbiAgICBcIiZsaWdodC5jbS1mb2N1c2VkID4gLmNtLXNjcm9sbGVyID4gLmNtLXNlbGVjdGlvbkxheWVyIC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjZDdkNGYwXCJcbiAgICB9LFxuICAgIFwiJmRhcmsuY20tZm9jdXNlZCA+IC5jbS1zY3JvbGxlciA+IC5jbS1zZWxlY3Rpb25MYXllciAuY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzIzM1wiXG4gICAgfSxcbiAgICBcIi5jbS1jdXJzb3JMYXllclwiOiB7XG4gICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiXG4gICAgfSxcbiAgICBcIiYuY20tZm9jdXNlZCA+IC5jbS1zY3JvbGxlciA+IC5jbS1jdXJzb3JMYXllclwiOiB7XG4gICAgICAgIGFuaW1hdGlvbjogXCJzdGVwcygxKSBjbS1ibGluayAxLjJzIGluZmluaXRlXCJcbiAgICB9LFxuICAgIC8vIFR3byBhbmltYXRpb25zIGRlZmluZWQgc28gdGhhdCB3ZSBjYW4gc3dpdGNoIGJldHdlZW4gdGhlbSB0b1xuICAgIC8vIHJlc3RhcnQgdGhlIGFuaW1hdGlvbiB3aXRob3V0IGZvcmNpbmcgYW5vdGhlciBzdHlsZVxuICAgIC8vIHJlY29tcHV0YXRpb24uXG4gICAgXCJAa2V5ZnJhbWVzIGNtLWJsaW5rXCI6IHsgXCIwJVwiOiB7fSwgXCI1MCVcIjogeyBvcGFjaXR5OiAwIH0sIFwiMTAwJVwiOiB7fSB9LFxuICAgIFwiQGtleWZyYW1lcyBjbS1ibGluazJcIjogeyBcIjAlXCI6IHt9LCBcIjUwJVwiOiB7IG9wYWNpdHk6IDAgfSwgXCIxMDAlXCI6IHt9IH0sXG4gICAgXCIuY20tY3Vyc29yLCAuY20tZHJvcEN1cnNvclwiOiB7XG4gICAgICAgIGJvcmRlckxlZnQ6IFwiMS4ycHggc29saWQgYmxhY2tcIixcbiAgICAgICAgbWFyZ2luTGVmdDogXCItMC42cHhcIixcbiAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCIsXG4gICAgfSxcbiAgICBcIi5jbS1jdXJzb3JcIjoge1xuICAgICAgICBkaXNwbGF5OiBcIm5vbmVcIlxuICAgIH0sXG4gICAgXCImZGFyayAuY20tY3Vyc29yXCI6IHtcbiAgICAgICAgYm9yZGVyTGVmdENvbG9yOiBcIiM0NDRcIlxuICAgIH0sXG4gICAgXCIuY20tZHJvcEN1cnNvclwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCJcbiAgICB9LFxuICAgIFwiJi5jbS1mb2N1c2VkID4gLmNtLXNjcm9sbGVyID4gLmNtLWN1cnNvckxheWVyIC5jbS1jdXJzb3JcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCJcbiAgICB9LFxuICAgIFwiLmNtLWlzb1wiOiB7XG4gICAgICAgIHVuaWNvZGVCaWRpOiBcImlzb2xhdGVcIlxuICAgIH0sXG4gICAgXCIuY20tYW5ub3VuY2VkXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwiZml4ZWRcIixcbiAgICAgICAgdG9wOiBcIi0xMDAwMHB4XCJcbiAgICB9LFxuICAgIFwiQG1lZGlhIHByaW50XCI6IHtcbiAgICAgICAgXCIuY20tYW5ub3VuY2VkXCI6IHsgZGlzcGxheTogXCJub25lXCIgfVxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLWFjdGl2ZUxpbmVcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2NjZWVmZjQ0XCIgfSxcbiAgICBcIiZkYXJrIC5jbS1hY3RpdmVMaW5lXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiM5OWVlZmYzM1wiIH0sXG4gICAgXCImbGlnaHQgLmNtLXNwZWNpYWxDaGFyXCI6IHsgY29sb3I6IFwicmVkXCIgfSxcbiAgICBcIiZkYXJrIC5jbS1zcGVjaWFsQ2hhclwiOiB7IGNvbG9yOiBcIiNmNzhcIiB9LFxuICAgIFwiLmNtLWd1dHRlcnNcIjoge1xuICAgICAgICBmbGV4U2hyaW5rOiAwLFxuICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgaW5zZXRJbmxpbmVTdGFydDogMCxcbiAgICAgICAgekluZGV4OiAyMDBcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1ndXR0ZXJzXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmNWY1ZjVcIixcbiAgICAgICAgY29sb3I6IFwiIzZjNmM2Y1wiLFxuICAgICAgICBib3JkZXJSaWdodDogXCIxcHggc29saWQgI2RkZFwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1ndXR0ZXJzXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMzMzMzMzhcIixcbiAgICAgICAgY29sb3I6IFwiI2NjY1wiXG4gICAgfSxcbiAgICBcIi5jbS1ndXR0ZXJcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImZsZXggIWltcG9ydGFudFwiLCAvLyBOZWNlc3NhcnkgLS0gcHJldmVudHMgbWFyZ2luIGNvbGxhcHNpbmdcbiAgICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcbiAgICAgICAgZmxleFNocmluazogMCxcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgbWluSGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCJcbiAgICB9LFxuICAgIFwiLmNtLWd1dHRlckVsZW1lbnRcIjoge1xuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiXG4gICAgfSxcbiAgICBcIi5jbS1saW5lTnVtYmVycyAuY20tZ3V0dGVyRWxlbWVudFwiOiB7XG4gICAgICAgIHBhZGRpbmc6IFwiMCAzcHggMCA1cHhcIixcbiAgICAgICAgbWluV2lkdGg6IFwiMjBweFwiLFxuICAgICAgICB0ZXh0QWxpZ246IFwicmlnaHRcIixcbiAgICAgICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLWFjdGl2ZUxpbmVHdXR0ZXJcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2UyZjJmZlwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1hY3RpdmVMaW5lR3V0dGVyXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMyMjIyMjdcIlxuICAgIH0sXG4gICAgXCIuY20tcGFuZWxzXCI6IHtcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgcG9zaXRpb246IFwic3RpY2t5XCIsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHJpZ2h0OiAwXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tcGFuZWxzXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmNWY1ZjVcIixcbiAgICAgICAgY29sb3I6IFwiYmxhY2tcIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXBhbmVscy10b3BcIjoge1xuICAgICAgICBib3JkZXJCb3R0b206IFwiMXB4IHNvbGlkICNkZGRcIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXBhbmVscy1ib3R0b21cIjoge1xuICAgICAgICBib3JkZXJUb3A6IFwiMXB4IHNvbGlkICNkZGRcIlxuICAgIH0sXG4gICAgXCImZGFyayAuY20tcGFuZWxzXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMzMzMzMzhcIixcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIlxuICAgIH0sXG4gICAgXCIuY20tdGFiXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgICAgIHZlcnRpY2FsQWxpZ246IFwiYm90dG9tXCJcbiAgICB9LFxuICAgIFwiLmNtLXdpZGdldEJ1ZmZlclwiOiB7XG4gICAgICAgIHZlcnRpY2FsQWxpZ246IFwidGV4dC10b3BcIixcbiAgICAgICAgaGVpZ2h0OiBcIjFlbVwiLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmVcIlxuICAgIH0sXG4gICAgXCIuY20tcGxhY2Vob2xkZXJcIjoge1xuICAgICAgICBjb2xvcjogXCIjODg4XCIsXG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgIHZlcnRpY2FsQWxpZ246IFwidG9wXCIsXG4gICAgfSxcbiAgICBcIi5jbS1oaWdobGlnaHRTcGFjZTpiZWZvcmVcIjoge1xuICAgICAgICBjb250ZW50OiBcImF0dHIoZGF0YS1kaXNwbGF5KVwiLFxuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcbiAgICAgICAgY29sb3I6IFwiIzg4OFwiXG4gICAgfSxcbiAgICBcIi5jbS1oaWdobGlnaHRUYWJcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGB1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbCw8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjIwMFwiIGhlaWdodD1cIjIwXCI+PHBhdGggc3Ryb2tlPVwiJTIzODg4XCIgc3Ryb2tlLXdpZHRoPVwiMVwiIGZpbGw9XCJub25lXCIgZD1cIk0xIDEwSDE5NkwxOTAgNU0xOTAgMTVMMTk2IDEwTTE5NyA0TDE5NyAxNlwiLz48L3N2Zz4nKWAsXG4gICAgICAgIGJhY2tncm91bmRTaXplOiBcImF1dG8gMTAwJVwiLFxuICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb246IFwicmlnaHQgOTAlXCIsXG4gICAgICAgIGJhY2tncm91bmRSZXBlYXQ6IFwibm8tcmVwZWF0XCJcbiAgICB9LFxuICAgIFwiLmNtLXRyYWlsaW5nU3BhY2VcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmMzMyMjU1XCJcbiAgICB9LFxuICAgIFwiLmNtLWJ1dHRvblwiOiB7XG4gICAgICAgIHZlcnRpY2FsQWxpZ246IFwibWlkZGxlXCIsXG4gICAgICAgIGNvbG9yOiBcImluaGVyaXRcIixcbiAgICAgICAgZm9udFNpemU6IFwiNzAlXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiLjJlbSAxZW1cIixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBcIjFweFwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tYnV0dG9uXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZEltYWdlOiBcImxpbmVhci1ncmFkaWVudCgjZWZmMWY1LCAjZDlkOWRmKVwiLFxuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICM4ODhcIixcbiAgICAgICAgXCImOmFjdGl2ZVwiOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCNiNGI0YjQsICNkMGQzZDYpXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCImZGFyayAuY20tYnV0dG9uXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZEltYWdlOiBcImxpbmVhci1ncmFkaWVudCgjMzkzOTM5LCAjMTExKVwiLFxuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICM4ODhcIixcbiAgICAgICAgXCImOmFjdGl2ZVwiOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCMxMTEsICMzMzMpXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCIuY20tdGV4dGZpZWxkXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJtaWRkbGVcIixcbiAgICAgICAgY29sb3I6IFwiaW5oZXJpdFwiLFxuICAgICAgICBmb250U2l6ZTogXCI3MCVcIixcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCBzaWx2ZXJcIixcbiAgICAgICAgcGFkZGluZzogXCIuMmVtIC41ZW1cIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXRleHRmaWVsZFwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJ3aGl0ZVwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS10ZXh0ZmllbGRcIjoge1xuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICM1NTVcIixcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcImluaGVyaXRcIlxuICAgIH1cbn0sIGxpZ2h0RGFya0lEcyk7XG5cbmNvbnN0IExpbmVCcmVha1BsYWNlaG9sZGVyID0gXCJcXHVmZmZmXCI7XG5jbGFzcyBET01SZWFkZXIge1xuICAgIGNvbnN0cnVjdG9yKHBvaW50cywgc3RhdGUpIHtcbiAgICAgICAgdGhpcy5wb2ludHMgPSBwb2ludHM7XG4gICAgICAgIHRoaXMudGV4dCA9IFwiXCI7XG4gICAgICAgIHRoaXMubGluZVNlcGFyYXRvciA9IHN0YXRlLmZhY2V0KEVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IpO1xuICAgIH1cbiAgICBhcHBlbmQodGV4dCkge1xuICAgICAgICB0aGlzLnRleHQgKz0gdGV4dDtcbiAgICB9XG4gICAgbGluZUJyZWFrKCkge1xuICAgICAgICB0aGlzLnRleHQgKz0gTGluZUJyZWFrUGxhY2Vob2xkZXI7XG4gICAgfVxuICAgIHJlYWRSYW5nZShzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmICghc3RhcnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHN0YXJ0LnBhcmVudE5vZGU7XG4gICAgICAgIGZvciAobGV0IGN1ciA9IHN0YXJ0OzspIHtcbiAgICAgICAgICAgIHRoaXMuZmluZFBvaW50QmVmb3JlKHBhcmVudCwgY3VyKTtcbiAgICAgICAgICAgIGxldCBvbGRMZW4gPSB0aGlzLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5yZWFkTm9kZShjdXIpO1xuICAgICAgICAgICAgbGV0IG5leHQgPSBjdXIubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAobmV4dCA9PSBlbmQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgdmlldyA9IENvbnRlbnRWaWV3LmdldChjdXIpLCBuZXh0VmlldyA9IENvbnRlbnRWaWV3LmdldChuZXh0KTtcbiAgICAgICAgICAgIGlmICh2aWV3ICYmIG5leHRWaWV3ID8gdmlldy5icmVha0FmdGVyIDpcbiAgICAgICAgICAgICAgICAodmlldyA/IHZpZXcuYnJlYWtBZnRlciA6IGlzQmxvY2tFbGVtZW50KGN1cikpIHx8XG4gICAgICAgICAgICAgICAgICAgIChpc0Jsb2NrRWxlbWVudChuZXh0KSAmJiAoY3VyLm5vZGVOYW1lICE9IFwiQlJcIiB8fCBjdXIuY21JZ25vcmUpICYmIHRoaXMudGV4dC5sZW5ndGggPiBvbGRMZW4pKVxuICAgICAgICAgICAgICAgIHRoaXMubGluZUJyZWFrKCk7XG4gICAgICAgICAgICBjdXIgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmluZFBvaW50QmVmb3JlKHBhcmVudCwgZW5kKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlYWRUZXh0Tm9kZShub2RlKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gbm9kZS5ub2RlVmFsdWU7XG4gICAgICAgIGZvciAobGV0IHBvaW50IG9mIHRoaXMucG9pbnRzKVxuICAgICAgICAgICAgaWYgKHBvaW50Lm5vZGUgPT0gbm9kZSlcbiAgICAgICAgICAgICAgICBwb2ludC5wb3MgPSB0aGlzLnRleHQubGVuZ3RoICsgTWF0aC5taW4ocG9pbnQub2Zmc2V0LCB0ZXh0Lmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IG9mZiA9IDAsIHJlID0gdGhpcy5saW5lU2VwYXJhdG9yID8gbnVsbCA6IC9cXHJcXG4/fFxcbi9nOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0QnJlYWsgPSAtMSwgYnJlYWtTaXplID0gMSwgbTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpbmVTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBuZXh0QnJlYWsgPSB0ZXh0LmluZGV4T2YodGhpcy5saW5lU2VwYXJhdG9yLCBvZmYpO1xuICAgICAgICAgICAgICAgIGJyZWFrU2l6ZSA9IHRoaXMubGluZVNlcGFyYXRvci5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtID0gcmUuZXhlYyh0ZXh0KSkge1xuICAgICAgICAgICAgICAgIG5leHRCcmVhayA9IG0uaW5kZXg7XG4gICAgICAgICAgICAgICAgYnJlYWtTaXplID0gbVswXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFwcGVuZCh0ZXh0LnNsaWNlKG9mZiwgbmV4dEJyZWFrIDwgMCA/IHRleHQubGVuZ3RoIDogbmV4dEJyZWFrKSk7XG4gICAgICAgICAgICBpZiAobmV4dEJyZWFrIDwgMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHRoaXMubGluZUJyZWFrKCk7XG4gICAgICAgICAgICBpZiAoYnJlYWtTaXplID4gMSlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwb2ludCBvZiB0aGlzLnBvaW50cylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50Lm5vZGUgPT0gbm9kZSAmJiBwb2ludC5wb3MgPiB0aGlzLnRleHQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQucG9zIC09IGJyZWFrU2l6ZSAtIDE7XG4gICAgICAgICAgICBvZmYgPSBuZXh0QnJlYWsgKyBicmVha1NpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZE5vZGUobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5jbUlnbm9yZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHZpZXcgPSBDb250ZW50Vmlldy5nZXQobm9kZSk7XG4gICAgICAgIGxldCBmcm9tVmlldyA9IHZpZXcgJiYgdmlldy5vdmVycmlkZURPTVRleHQ7XG4gICAgICAgIGlmIChmcm9tVmlldyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRQb2ludEluc2lkZShub2RlLCBmcm9tVmlldy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGZyb21WaWV3Lml0ZXIoKTsgIWkubmV4dCgpLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgaWYgKGkubGluZUJyZWFrKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVCcmVhaygpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmQoaS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRUZXh0Tm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVOYW1lID09IFwiQlJcIikge1xuICAgICAgICAgICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpXG4gICAgICAgICAgICAgICAgdGhpcy5saW5lQnJlYWsoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZFJhbmdlKG5vZGUuZmlyc3RDaGlsZCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluZFBvaW50QmVmb3JlKG5vZGUsIG5leHQpIHtcbiAgICAgICAgZm9yIChsZXQgcG9pbnQgb2YgdGhpcy5wb2ludHMpXG4gICAgICAgICAgICBpZiAocG9pbnQubm9kZSA9PSBub2RlICYmIG5vZGUuY2hpbGROb2Rlc1twb2ludC5vZmZzZXRdID09IG5leHQpXG4gICAgICAgICAgICAgICAgcG9pbnQucG9zID0gdGhpcy50ZXh0Lmxlbmd0aDtcbiAgICB9XG4gICAgZmluZFBvaW50SW5zaWRlKG5vZGUsIGxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBwb2ludCBvZiB0aGlzLnBvaW50cylcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMgPyBwb2ludC5ub2RlID09IG5vZGUgOiBub2RlLmNvbnRhaW5zKHBvaW50Lm5vZGUpKVxuICAgICAgICAgICAgICAgIHBvaW50LnBvcyA9IHRoaXMudGV4dC5sZW5ndGggKyAoaXNBdEVuZChub2RlLCBwb2ludC5ub2RlLCBwb2ludC5vZmZzZXQpID8gbGVuZ3RoIDogMCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNBdEVuZChwYXJlbnQsIG5vZGUsIG9mZnNldCkge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKCFub2RlIHx8IG9mZnNldCA8IG1heE9mZnNldChub2RlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKG5vZGUgPT0gcGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpICsgMTtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0Jsb2NrRWxlbWVudChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT0gMSAmJiAvXihESVZ8UHxMSXxVTHxPTHxCTE9DS1FVT1RFfEREfERUfEhcXGR8U0VDVElPTnxQUkUpJC8udGVzdChub2RlLm5vZGVOYW1lKTtcbn1cbmNsYXNzIERPTVBvaW50IHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMucG9zID0gLTE7XG4gICAgfVxufVxuXG5jbGFzcyBET01DaGFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIHN0YXJ0LCBlbmQsIHR5cGVPdmVyKSB7XG4gICAgICAgIHRoaXMudHlwZU92ZXIgPSB0eXBlT3ZlcjtcbiAgICAgICAgdGhpcy5ib3VuZHMgPSBudWxsO1xuICAgICAgICB0aGlzLnRleHQgPSBcIlwiO1xuICAgICAgICBsZXQgeyBpbXByZWNpc2VIZWFkOiBpSGVhZCwgaW1wcmVjaXNlQW5jaG9yOiBpQW5jaG9yIH0gPSB2aWV3LmRvY1ZpZXc7XG4gICAgICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5ICYmIHN0YXJ0ID4gLTEpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBjaGFuZ2VzIHdoZW4gdGhlIGVkaXRvciBpcyByZWFkLW9ubHlcbiAgICAgICAgICAgIHRoaXMubmV3U2VsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGFydCA+IC0xICYmICh0aGlzLmJvdW5kcyA9IHZpZXcuZG9jVmlldy5kb21Cb3VuZHNBcm91bmQoc3RhcnQsIGVuZCwgMCkpKSB7XG4gICAgICAgICAgICBsZXQgc2VsUG9pbnRzID0gaUhlYWQgfHwgaUFuY2hvciA/IFtdIDogc2VsZWN0aW9uUG9pbnRzKHZpZXcpO1xuICAgICAgICAgICAgbGV0IHJlYWRlciA9IG5ldyBET01SZWFkZXIoc2VsUG9pbnRzLCB2aWV3LnN0YXRlKTtcbiAgICAgICAgICAgIHJlYWRlci5yZWFkUmFuZ2UodGhpcy5ib3VuZHMuc3RhcnRET00sIHRoaXMuYm91bmRzLmVuZERPTSk7XG4gICAgICAgICAgICB0aGlzLnRleHQgPSByZWFkZXIudGV4dDtcbiAgICAgICAgICAgIHRoaXMubmV3U2VsID0gc2VsZWN0aW9uRnJvbVBvaW50cyhzZWxQb2ludHMsIHRoaXMuYm91bmRzLmZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGRvbVNlbCA9IHZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2U7XG4gICAgICAgICAgICBsZXQgaGVhZCA9IGlIZWFkICYmIGlIZWFkLm5vZGUgPT0gZG9tU2VsLmZvY3VzTm9kZSAmJiBpSGVhZC5vZmZzZXQgPT0gZG9tU2VsLmZvY3VzT2Zmc2V0IHx8XG4gICAgICAgICAgICAgICAgIWNvbnRhaW5zKHZpZXcuY29udGVudERPTSwgZG9tU2VsLmZvY3VzTm9kZSlcbiAgICAgICAgICAgICAgICA/IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZFxuICAgICAgICAgICAgICAgIDogdmlldy5kb2NWaWV3LnBvc0Zyb21ET00oZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0KTtcbiAgICAgICAgICAgIGxldCBhbmNob3IgPSBpQW5jaG9yICYmIGlBbmNob3Iubm9kZSA9PSBkb21TZWwuYW5jaG9yTm9kZSAmJiBpQW5jaG9yLm9mZnNldCA9PSBkb21TZWwuYW5jaG9yT2Zmc2V0IHx8XG4gICAgICAgICAgICAgICAgIWNvbnRhaW5zKHZpZXcuY29udGVudERPTSwgZG9tU2VsLmFuY2hvck5vZGUpXG4gICAgICAgICAgICAgICAgPyB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmFuY2hvclxuICAgICAgICAgICAgICAgIDogdmlldy5kb2NWaWV3LnBvc0Zyb21ET00oZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpO1xuICAgICAgICAgICAgLy8gaU9TIHdpbGwgcmVmdXNlIHRvIHNlbGVjdCB0aGUgYmxvY2sgZ2FwcyB3aGVuIGRvaW5nIHNlbGVjdC1hbGxcbiAgICAgICAgICAgIGxldCB2cCA9IHZpZXcudmlld3BvcnQ7XG4gICAgICAgICAgICBpZiAoYnJvd3Nlci5pb3MgJiYgdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5lbXB0eSAmJiBoZWFkICE9IGFuY2hvciAmJlxuICAgICAgICAgICAgICAgICh2cC5mcm9tID4gMCB8fCB2cC50byA8IHZpZXcuc3RhdGUuZG9jLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgb2ZmRnJvbSA9IHZwLmZyb20gLSBNYXRoLm1pbihoZWFkLCBhbmNob3IpLCBvZmZUbyA9IHZwLnRvIC0gTWF0aC5tYXgoaGVhZCwgYW5jaG9yKTtcbiAgICAgICAgICAgICAgICBpZiAoKG9mZkZyb20gPT0gMCB8fCBvZmZGcm9tID09IDEpICYmIChvZmZUbyA9PSAwIHx8IG9mZlRvID09IC0xKSkge1xuICAgICAgICAgICAgICAgICAgICBoZWFkID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yID0gdmlldy5zdGF0ZS5kb2MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubmV3U2VsID0gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShhbmNob3IsIGhlYWQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlET01DaGFuZ2UodmlldywgZG9tQ2hhbmdlKSB7XG4gICAgbGV0IGNoYW5nZTtcbiAgICBsZXQgeyBuZXdTZWwgfSA9IGRvbUNoYW5nZSwgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBsZXQgbGFzdEtleSA9IHZpZXcuaW5wdXRTdGF0ZS5sYXN0S2V5VGltZSA+IERhdGUubm93KCkgLSAxMDAgPyB2aWV3LmlucHV0U3RhdGUubGFzdEtleUNvZGUgOiAtMTtcbiAgICBpZiAoZG9tQ2hhbmdlLmJvdW5kcykge1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gZG9tQ2hhbmdlLmJvdW5kcztcbiAgICAgICAgbGV0IHByZWZlcnJlZFBvcyA9IHNlbC5mcm9tLCBwcmVmZXJyZWRTaWRlID0gbnVsbDtcbiAgICAgICAgLy8gUHJlZmVyIGFuY2hvcmluZyB0byBlbmQgd2hlbiBCYWNrc3BhY2UgaXMgcHJlc3NlZCAob3IsIG9uXG4gICAgICAgIC8vIEFuZHJvaWQsIHdoZW4gc29tZXRoaW5nIHdhcyBkZWxldGVkKVxuICAgICAgICBpZiAobGFzdEtleSA9PT0gOCB8fCBicm93c2VyLmFuZHJvaWQgJiYgZG9tQ2hhbmdlLnRleHQubGVuZ3RoIDwgdG8gLSBmcm9tKSB7XG4gICAgICAgICAgICBwcmVmZXJyZWRQb3MgPSBzZWwudG87XG4gICAgICAgICAgICBwcmVmZXJyZWRTaWRlID0gXCJlbmRcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGlmZiA9IGZpbmREaWZmKHZpZXcuc3RhdGUuZG9jLnNsaWNlU3RyaW5nKGZyb20sIHRvLCBMaW5lQnJlYWtQbGFjZWhvbGRlciksIGRvbUNoYW5nZS50ZXh0LCBwcmVmZXJyZWRQb3MgLSBmcm9tLCBwcmVmZXJyZWRTaWRlKTtcbiAgICAgICAgaWYgKGRpZmYpIHtcbiAgICAgICAgICAgIC8vIENocm9tZSBpbnNlcnRzIHR3byBuZXdsaW5lcyB3aGVuIHByZXNzaW5nIHNoaWZ0LWVudGVyIGF0IHRoZVxuICAgICAgICAgICAgLy8gZW5kIG9mIGEgbGluZS4gRG9tQ2hhbmdlIGRyb3BzIG9uZSBvZiB0aG9zZS5cbiAgICAgICAgICAgIGlmIChicm93c2VyLmNocm9tZSAmJiBsYXN0S2V5ID09IDEzICYmXG4gICAgICAgICAgICAgICAgZGlmZi50b0IgPT0gZGlmZi5mcm9tICsgMiAmJiBkb21DaGFuZ2UudGV4dC5zbGljZShkaWZmLmZyb20sIGRpZmYudG9CKSA9PSBMaW5lQnJlYWtQbGFjZWhvbGRlciArIExpbmVCcmVha1BsYWNlaG9sZGVyKVxuICAgICAgICAgICAgICAgIGRpZmYudG9CLS07XG4gICAgICAgICAgICBjaGFuZ2UgPSB7IGZyb206IGZyb20gKyBkaWZmLmZyb20sIHRvOiBmcm9tICsgZGlmZi50b0EsXG4gICAgICAgICAgICAgICAgaW5zZXJ0OiBUZXh0Lm9mKGRvbUNoYW5nZS50ZXh0LnNsaWNlKGRpZmYuZnJvbSwgZGlmZi50b0IpLnNwbGl0KExpbmVCcmVha1BsYWNlaG9sZGVyKSkgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChuZXdTZWwgJiYgKCF2aWV3Lmhhc0ZvY3VzICYmIHZpZXcuc3RhdGUuZmFjZXQoZWRpdGFibGUpIHx8IG5ld1NlbC5tYWluLmVxKHNlbCkpKSB7XG4gICAgICAgIG5ld1NlbCA9IG51bGw7XG4gICAgfVxuICAgIGlmICghY2hhbmdlICYmICFuZXdTZWwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWNoYW5nZSAmJiBkb21DaGFuZ2UudHlwZU92ZXIgJiYgIXNlbC5lbXB0eSAmJiBuZXdTZWwgJiYgbmV3U2VsLm1haW4uZW1wdHkpIHtcbiAgICAgICAgLy8gSGV1cmlzdGljIHRvIG5vdGljZSB0eXBpbmcgb3ZlciBhIHNlbGVjdGVkIGNoYXJhY3RlclxuICAgICAgICBjaGFuZ2UgPSB7IGZyb206IHNlbC5mcm9tLCB0bzogc2VsLnRvLCBpbnNlcnQ6IHZpZXcuc3RhdGUuZG9jLnNsaWNlKHNlbC5mcm9tLCBzZWwudG8pIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoYW5nZSAmJiBjaGFuZ2UuZnJvbSA+PSBzZWwuZnJvbSAmJiBjaGFuZ2UudG8gPD0gc2VsLnRvICYmXG4gICAgICAgIChjaGFuZ2UuZnJvbSAhPSBzZWwuZnJvbSB8fCBjaGFuZ2UudG8gIT0gc2VsLnRvKSAmJlxuICAgICAgICAoc2VsLnRvIC0gc2VsLmZyb20pIC0gKGNoYW5nZS50byAtIGNoYW5nZS5mcm9tKSA8PSA0KSB7XG4gICAgICAgIC8vIElmIHRoZSBjaGFuZ2UgaXMgaW5zaWRlIHRoZSBzZWxlY3Rpb24gYW5kIGNvdmVycyBtb3N0IG9mIGl0LFxuICAgICAgICAvLyBhc3N1bWUgaXQgaXMgYSBzZWxlY3Rpb24gcmVwbGFjZSAod2l0aCBpZGVudGljYWwgY2hhcmFjdGVycyBhdFxuICAgICAgICAvLyB0aGUgc3RhcnQvZW5kIG5vdCBpbmNsdWRlZCBpbiB0aGUgZGlmZilcbiAgICAgICAgY2hhbmdlID0ge1xuICAgICAgICAgICAgZnJvbTogc2VsLmZyb20sIHRvOiBzZWwudG8sXG4gICAgICAgICAgICBpbnNlcnQ6IHZpZXcuc3RhdGUuZG9jLnNsaWNlKHNlbC5mcm9tLCBjaGFuZ2UuZnJvbSkuYXBwZW5kKGNoYW5nZS5pbnNlcnQpLmFwcGVuZCh2aWV3LnN0YXRlLmRvYy5zbGljZShjaGFuZ2UudG8sIHNlbC50bykpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKChicm93c2VyLm1hYyB8fCBicm93c2VyLmFuZHJvaWQpICYmIGNoYW5nZSAmJiBjaGFuZ2UuZnJvbSA9PSBjaGFuZ2UudG8gJiYgY2hhbmdlLmZyb20gPT0gc2VsLmhlYWQgLSAxICYmXG4gICAgICAgIC9eXFwuID8kLy50ZXN0KGNoYW5nZS5pbnNlcnQudG9TdHJpbmcoKSkgJiYgdmlldy5jb250ZW50RE9NLmdldEF0dHJpYnV0ZShcImF1dG9jb3JyZWN0XCIpID09IFwib2ZmXCIpIHtcbiAgICAgICAgLy8gRGV0ZWN0IGluc2VydC1wZXJpb2Qtb24tZG91YmxlLXNwYWNlIE1hYyBhbmQgQW5kcm9pZCBiZWhhdmlvcixcbiAgICAgICAgLy8gYW5kIHRyYW5zZm9ybSBpdCBpbnRvIGEgcmVndWxhciBzcGFjZSBpbnNlcnQuXG4gICAgICAgIGlmIChuZXdTZWwgJiYgY2hhbmdlLmluc2VydC5sZW5ndGggPT0gMilcbiAgICAgICAgICAgIG5ld1NlbCA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUobmV3U2VsLm1haW4uYW5jaG9yIC0gMSwgbmV3U2VsLm1haW4uaGVhZCAtIDEpO1xuICAgICAgICBjaGFuZ2UgPSB7IGZyb206IHNlbC5mcm9tLCB0bzogc2VsLnRvLCBpbnNlcnQ6IFRleHQub2YoW1wiIFwiXSkgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYnJvd3Nlci5jaHJvbWUgJiYgY2hhbmdlICYmIGNoYW5nZS5mcm9tID09IGNoYW5nZS50byAmJiBjaGFuZ2UuZnJvbSA9PSBzZWwuaGVhZCAmJlxuICAgICAgICBjaGFuZ2UuaW5zZXJ0LnRvU3RyaW5nKCkgPT0gXCJcXG4gXCIgJiYgdmlldy5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgLy8gSW4gQ2hyb21lLCBpZiB5b3UgaW5zZXJ0IGEgc3BhY2UgYXQgdGhlIHN0YXJ0IG9mIGEgd3JhcHBlZFxuICAgICAgICAvLyBsaW5lLCBpdCB3aWxsIGFjdHVhbGx5IGluc2VydCBhIG5ld2xpbmUgYW5kIGEgc3BhY2UsIGNhdXNpbmcgYVxuICAgICAgICAvLyBib2d1cyBuZXcgbGluZSB0byBiZSBjcmVhdGVkIGluIENvZGVNaXJyb3IgKCM5NjgpXG4gICAgICAgIGlmIChuZXdTZWwpXG4gICAgICAgICAgICBuZXdTZWwgPSBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKG5ld1NlbC5tYWluLmFuY2hvciAtIDEsIG5ld1NlbC5tYWluLmhlYWQgLSAxKTtcbiAgICAgICAgY2hhbmdlID0geyBmcm9tOiBzZWwuZnJvbSwgdG86IHNlbC50bywgaW5zZXJ0OiBUZXh0Lm9mKFtcIiBcIl0pIH07XG4gICAgfVxuICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgICAgaWYgKGJyb3dzZXIuaW9zICYmIHZpZXcuaW5wdXRTdGF0ZS5mbHVzaElPU0tleSgpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIEFuZHJvaWQgYnJvd3NlcnMgZG9uJ3QgZmlyZSByZWFzb25hYmxlIGtleSBldmVudHMgZm9yIGVudGVyLFxuICAgICAgICAvLyBiYWNrc3BhY2UsIG9yIGRlbGV0ZS4gU28gdGhpcyBkZXRlY3RzIGNoYW5nZXMgdGhhdCBsb29rIGxpa2VcbiAgICAgICAgLy8gdGhleSdyZSBjYXVzZWQgYnkgdGhvc2Uga2V5cywgYW5kIHJlaW50ZXJwcmV0cyB0aGVtIGFzIGtleVxuICAgICAgICAvLyBldmVudHMuIChTb21lIG9mIHRoZXNlIGtleXMgYXJlIGFsc28gaGFuZGxlZCBieSBiZWZvcmVpbnB1dFxuICAgICAgICAvLyBldmVudHMgYW5kIHRoZSBwZW5kaW5nQW5kcm9pZEtleSBtZWNoYW5pc20sIGJ1dCB0aGF0J3Mgbm90XG4gICAgICAgIC8vIHJlbGlhYmxlIGluIGFsbCBzaXR1YXRpb25zLilcbiAgICAgICAgaWYgKGJyb3dzZXIuYW5kcm9pZCAmJlxuICAgICAgICAgICAgKChjaGFuZ2UuZnJvbSA9PSBzZWwuZnJvbSAmJiBjaGFuZ2UudG8gPT0gc2VsLnRvICYmXG4gICAgICAgICAgICAgICAgY2hhbmdlLmluc2VydC5sZW5ndGggPT0gMSAmJiBjaGFuZ2UuaW5zZXJ0LmxpbmVzID09IDIgJiZcbiAgICAgICAgICAgICAgICBkaXNwYXRjaEtleSh2aWV3LmNvbnRlbnRET00sIFwiRW50ZXJcIiwgMTMpKSB8fFxuICAgICAgICAgICAgICAgICgoY2hhbmdlLmZyb20gPT0gc2VsLmZyb20gLSAxICYmIGNoYW5nZS50byA9PSBzZWwudG8gJiYgY2hhbmdlLmluc2VydC5sZW5ndGggPT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICBsYXN0S2V5ID09IDggJiYgY2hhbmdlLmluc2VydC5sZW5ndGggPCBjaGFuZ2UudG8gLSBjaGFuZ2UuZnJvbSAmJiBjaGFuZ2UudG8gPiBzZWwuaGVhZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hLZXkodmlldy5jb250ZW50RE9NLCBcIkJhY2tzcGFjZVwiLCA4KSkgfHxcbiAgICAgICAgICAgICAgICAoY2hhbmdlLmZyb20gPT0gc2VsLmZyb20gJiYgY2hhbmdlLnRvID09IHNlbC50byArIDEgJiYgY2hhbmdlLmluc2VydC5sZW5ndGggPT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaEtleSh2aWV3LmNvbnRlbnRET00sIFwiRGVsZXRlXCIsIDQ2KSkpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCB0ZXh0ID0gY2hhbmdlLmluc2VydC50b1N0cmluZygpO1xuICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+PSAwKVxuICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZysrO1xuICAgICAgICBsZXQgZGVmYXVsdFRyO1xuICAgICAgICBsZXQgZGVmYXVsdEluc2VydCA9ICgpID0+IGRlZmF1bHRUciB8fCAoZGVmYXVsdFRyID0gYXBwbHlEZWZhdWx0SW5zZXJ0KHZpZXcsIGNoYW5nZSwgbmV3U2VsKSk7XG4gICAgICAgIGlmICghdmlldy5zdGF0ZS5mYWNldChpbnB1dEhhbmRsZXIpLnNvbWUoaCA9PiBoKHZpZXcsIGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8sIHRleHQsIGRlZmF1bHRJbnNlcnQpKSlcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goZGVmYXVsdEluc2VydCgpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5ld1NlbCAmJiAhbmV3U2VsLm1haW4uZXEoc2VsKSkge1xuICAgICAgICBsZXQgc2Nyb2xsSW50b1ZpZXcgPSBmYWxzZSwgdXNlckV2ZW50ID0gXCJzZWxlY3RcIjtcbiAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2VsZWN0aW9uVGltZSA+IERhdGUubm93KCkgLSA1MCkge1xuICAgICAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2VsZWN0aW9uT3JpZ2luID09IFwic2VsZWN0XCIpXG4gICAgICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXcgPSB0cnVlO1xuICAgICAgICAgICAgdXNlckV2ZW50ID0gdmlldy5pbnB1dFN0YXRlLmxhc3RTZWxlY3Rpb25PcmlnaW47XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IHNlbGVjdGlvbjogbmV3U2VsLCBzY3JvbGxJbnRvVmlldywgdXNlckV2ZW50IH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseURlZmF1bHRJbnNlcnQodmlldywgY2hhbmdlLCBuZXdTZWwpIHtcbiAgICBsZXQgdHIsIHN0YXJ0U3RhdGUgPSB2aWV3LnN0YXRlLCBzZWwgPSBzdGFydFN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGlmIChjaGFuZ2UuZnJvbSA+PSBzZWwuZnJvbSAmJiBjaGFuZ2UudG8gPD0gc2VsLnRvICYmIGNoYW5nZS50byAtIGNoYW5nZS5mcm9tID49IChzZWwudG8gLSBzZWwuZnJvbSkgLyAzICYmXG4gICAgICAgICghbmV3U2VsIHx8IG5ld1NlbC5tYWluLmVtcHR5ICYmIG5ld1NlbC5tYWluLmZyb20gPT0gY2hhbmdlLmZyb20gKyBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCkgJiZcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA8IDApIHtcbiAgICAgICAgbGV0IGJlZm9yZSA9IHNlbC5mcm9tIDwgY2hhbmdlLmZyb20gPyBzdGFydFN0YXRlLnNsaWNlRG9jKHNlbC5mcm9tLCBjaGFuZ2UuZnJvbSkgOiBcIlwiO1xuICAgICAgICBsZXQgYWZ0ZXIgPSBzZWwudG8gPiBjaGFuZ2UudG8gPyBzdGFydFN0YXRlLnNsaWNlRG9jKGNoYW5nZS50bywgc2VsLnRvKSA6IFwiXCI7XG4gICAgICAgIHRyID0gc3RhcnRTdGF0ZS5yZXBsYWNlU2VsZWN0aW9uKHZpZXcuc3RhdGUudG9UZXh0KGJlZm9yZSArIGNoYW5nZS5pbnNlcnQuc2xpY2VTdHJpbmcoMCwgdW5kZWZpbmVkLCB2aWV3LnN0YXRlLmxpbmVCcmVhaykgKyBhZnRlcikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBzdGFydFN0YXRlLmNoYW5nZXMoY2hhbmdlKTtcbiAgICAgICAgbGV0IG1haW5TZWwgPSBuZXdTZWwgJiYgbmV3U2VsLm1haW4udG8gPD0gY2hhbmdlcy5uZXdMZW5ndGggPyBuZXdTZWwubWFpbiA6IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gVHJ5IHRvIGFwcGx5IGEgY29tcG9zaXRpb24gY2hhbmdlIHRvIGFsbCBjdXJzb3JzXG4gICAgICAgIGlmIChzdGFydFN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubGVuZ3RoID4gMSAmJiB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID49IDAgJiZcbiAgICAgICAgICAgIGNoYW5nZS50byA8PSBzZWwudG8gJiYgY2hhbmdlLnRvID49IHNlbC50byAtIDEwKSB7XG4gICAgICAgICAgICBsZXQgcmVwbGFjZWQgPSB2aWV3LnN0YXRlLnNsaWNlRG9jKGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pO1xuICAgICAgICAgICAgbGV0IGNvbXBvc2l0aW9uUmFuZ2UsIGNvbXBvc2l0aW9uID0gbmV3U2VsICYmIGZpbmRDb21wb3NpdGlvbk5vZGUodmlldywgbmV3U2VsLm1haW4uaGVhZCk7XG4gICAgICAgICAgICBpZiAoY29tcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBsZXQgZExlbiA9IGNoYW5nZS5pbnNlcnQubGVuZ3RoIC0gKGNoYW5nZS50byAtIGNoYW5nZS5mcm9tKTtcbiAgICAgICAgICAgICAgICBjb21wb3NpdGlvblJhbmdlID0geyBmcm9tOiBjb21wb3NpdGlvbi5mcm9tLCB0bzogY29tcG9zaXRpb24udG8gLSBkTGVuIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21wb3NpdGlvblJhbmdlID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHNlbC5oZWFkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSBzZWwudG8gLSBjaGFuZ2UudG8sIHNpemUgPSBzZWwudG8gLSBzZWwuZnJvbTtcbiAgICAgICAgICAgIHRyID0gc3RhcnRTdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UuZnJvbSA9PSBzZWwuZnJvbSAmJiByYW5nZS50byA9PSBzZWwudG8pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXMsIHJhbmdlOiBtYWluU2VsIHx8IHJhbmdlLm1hcChjaGFuZ2VzKSB9O1xuICAgICAgICAgICAgICAgIGxldCB0byA9IHJhbmdlLnRvIC0gb2Zmc2V0LCBmcm9tID0gdG8gLSByZXBsYWNlZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLnRvIC0gcmFuZ2UuZnJvbSAhPSBzaXplIHx8IHZpZXcuc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pICE9IHJlcGxhY2VkIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIHRoZXJlJ3Mgbm8gd2F5IHRvIG1ha2UgbXVsdGlwbGVcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlcyBpbiB0aGUgc2FtZSBub2RlIHdvcmsgd2l0aG91dCBhYm9ydGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBjb21wb3NpdGlvbiwgc28gY3Vyc29ycyBpbiB0aGUgY29tcG9zaXRpb24gcmFuZ2UgYXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZWQuXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnRvID49IGNvbXBvc2l0aW9uUmFuZ2UuZnJvbSAmJiByYW5nZS5mcm9tIDw9IGNvbXBvc2l0aW9uUmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHJhbmdlIH07XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlQ2hhbmdlcyA9IHN0YXJ0U3RhdGUuY2hhbmdlcyh7IGZyb20sIHRvLCBpbnNlcnQ6IGNoYW5nZS5pbnNlcnQgfSksIHNlbE9mZiA9IHJhbmdlLnRvIC0gc2VsLnRvO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZXM6IHJhbmdlQ2hhbmdlcyxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6ICFtYWluU2VsID8gcmFuZ2UubWFwKHJhbmdlQ2hhbmdlcykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgRWRpdG9yU2VsZWN0aW9uLnJhbmdlKE1hdGgubWF4KDAsIG1haW5TZWwuYW5jaG9yICsgc2VsT2ZmKSwgTWF0aC5tYXgoMCwgbWFpblNlbC5oZWFkICsgc2VsT2ZmKSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0ciA9IHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogbWFpblNlbCAmJiBzdGFydFN0YXRlLnNlbGVjdGlvbi5yZXBsYWNlUmFuZ2UobWFpblNlbClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHVzZXJFdmVudCA9IFwiaW5wdXQudHlwZVwiO1xuICAgIGlmICh2aWV3LmNvbXBvc2luZyB8fFxuICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlICYmIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkVuZGVkQXQgPiBEYXRlLm5vdygpIC0gNTApIHtcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZSA9IGZhbHNlO1xuICAgICAgICB1c2VyRXZlbnQgKz0gXCIuY29tcG9zZVwiO1xuICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UpIHtcbiAgICAgICAgICAgIHVzZXJFdmVudCArPSBcIi5zdGFydFwiO1xuICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhcnRTdGF0ZS51cGRhdGUodHIsIHsgdXNlckV2ZW50LCBzY3JvbGxJbnRvVmlldzogdHJ1ZSB9KTtcbn1cbmZ1bmN0aW9uIGZpbmREaWZmKGEsIGIsIHByZWZlcnJlZFBvcywgcHJlZmVycmVkU2lkZSkge1xuICAgIGxldCBtaW5MZW4gPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpO1xuICAgIGxldCBmcm9tID0gMDtcbiAgICB3aGlsZSAoZnJvbSA8IG1pbkxlbiAmJiBhLmNoYXJDb2RlQXQoZnJvbSkgPT0gYi5jaGFyQ29kZUF0KGZyb20pKVxuICAgICAgICBmcm9tKys7XG4gICAgaWYgKGZyb20gPT0gbWluTGVuICYmIGEubGVuZ3RoID09IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgdG9BID0gYS5sZW5ndGgsIHRvQiA9IGIubGVuZ3RoO1xuICAgIHdoaWxlICh0b0EgPiAwICYmIHRvQiA+IDAgJiYgYS5jaGFyQ29kZUF0KHRvQSAtIDEpID09IGIuY2hhckNvZGVBdCh0b0IgLSAxKSkge1xuICAgICAgICB0b0EtLTtcbiAgICAgICAgdG9CLS07XG4gICAgfVxuICAgIGlmIChwcmVmZXJyZWRTaWRlID09IFwiZW5kXCIpIHtcbiAgICAgICAgbGV0IGFkanVzdCA9IE1hdGgubWF4KDAsIGZyb20gLSBNYXRoLm1pbih0b0EsIHRvQikpO1xuICAgICAgICBwcmVmZXJyZWRQb3MgLT0gdG9BICsgYWRqdXN0IC0gZnJvbTtcbiAgICB9XG4gICAgaWYgKHRvQSA8IGZyb20gJiYgYS5sZW5ndGggPCBiLmxlbmd0aCkge1xuICAgICAgICBsZXQgbW92ZSA9IHByZWZlcnJlZFBvcyA8PSBmcm9tICYmIHByZWZlcnJlZFBvcyA+PSB0b0EgPyBmcm9tIC0gcHJlZmVycmVkUG9zIDogMDtcbiAgICAgICAgZnJvbSAtPSBtb3ZlO1xuICAgICAgICB0b0IgPSBmcm9tICsgKHRvQiAtIHRvQSk7XG4gICAgICAgIHRvQSA9IGZyb207XG4gICAgfVxuICAgIGVsc2UgaWYgKHRvQiA8IGZyb20pIHtcbiAgICAgICAgbGV0IG1vdmUgPSBwcmVmZXJyZWRQb3MgPD0gZnJvbSAmJiBwcmVmZXJyZWRQb3MgPj0gdG9CID8gZnJvbSAtIHByZWZlcnJlZFBvcyA6IDA7XG4gICAgICAgIGZyb20gLT0gbW92ZTtcbiAgICAgICAgdG9BID0gZnJvbSArICh0b0EgLSB0b0IpO1xuICAgICAgICB0b0IgPSBmcm9tO1xuICAgIH1cbiAgICByZXR1cm4geyBmcm9tLCB0b0EsIHRvQiB9O1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uUG9pbnRzKHZpZXcpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgaWYgKHZpZXcucm9vdC5hY3RpdmVFbGVtZW50ICE9IHZpZXcuY29udGVudERPTSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBsZXQgeyBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQgfSA9IHZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2U7XG4gICAgaWYgKGFuY2hvck5vZGUpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobmV3IERPTVBvaW50KGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCkpO1xuICAgICAgICBpZiAoZm9jdXNOb2RlICE9IGFuY2hvck5vZGUgfHwgZm9jdXNPZmZzZXQgIT0gYW5jaG9yT2Zmc2V0KVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IERPTVBvaW50KGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvbkZyb21Qb2ludHMocG9pbnRzLCBiYXNlKSB7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGFuY2hvciA9IHBvaW50c1swXS5wb3MsIGhlYWQgPSBwb2ludHMubGVuZ3RoID09IDIgPyBwb2ludHNbMV0ucG9zIDogYW5jaG9yO1xuICAgIHJldHVybiBhbmNob3IgPiAtMSAmJiBoZWFkID4gLTEgPyBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKGFuY2hvciArIGJhc2UsIGhlYWQgKyBiYXNlKSA6IG51bGw7XG59XG5cbmNvbnN0IG9ic2VydmVPcHRpb25zID0ge1xuICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgIHN1YnRyZWU6IHRydWUsXG4gICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhT2xkVmFsdWU6IHRydWVcbn07XG4vLyBJRTExIGhhcyB2ZXJ5IGJyb2tlbiBtdXRhdGlvbiBvYnNlcnZlcnMsIHNvIHdlIGFsc28gbGlzdGVuIHRvXG4vLyBET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWQgdGhlcmVcbmNvbnN0IHVzZUNoYXJEYXRhID0gYnJvd3Nlci5pZSAmJiBicm93c2VyLmllX3ZlcnNpb24gPD0gMTE7XG5jbGFzcyBET01PYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAvLyBUaGUga25vd24gc2VsZWN0aW9uLiBLZXB0IGluIG91ciBvd24gb2JqZWN0LCBhcyBvcHBvc2VkIHRvIGp1c3RcbiAgICAgICAgLy8gZGlyZWN0bHkgYWNjZXNzaW5nIHRoZSBzZWxlY3Rpb24gYmVjYXVzZTpcbiAgICAgICAgLy8gIC0gU2FmYXJpIGRvZXNuJ3QgcmVwb3J0IHRoZSByaWdodCBzZWxlY3Rpb24gaW4gc2hhZG93IERPTVxuICAgICAgICAvLyAgLSBSZWFkaW5nIGZyb20gdGhlIHNlbGVjdGlvbiBmb3JjZXMgYSBET00gbGF5b3V0XG4gICAgICAgIC8vICAtIFRoaXMgd2F5LCB3ZSBjYW4gaWdub3JlIHNlbGVjdGlvbmNoYW5nZSBldmVudHMgaWYgd2UgaGF2ZVxuICAgICAgICAvLyAgICBhbHJlYWR5IHNlZW4gdGhlICduZXcnIHNlbGVjdGlvblxuICAgICAgICB0aGlzLnNlbGVjdGlvblJhbmdlID0gbmV3IERPTVNlbGVjdGlvblN0YXRlO1xuICAgICAgICAvLyBTZXQgd2hlbiBhIHNlbGVjdGlvbiBjaGFuZ2UgaXMgZGV0ZWN0ZWQsIGNsZWFyZWQgb24gZmx1c2hcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVsYXllZEZsdXNoID0gLTE7XG4gICAgICAgIHRoaXMucmVzaXplVGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuZGVsYXllZEFuZHJvaWRLZXkgPSBudWxsO1xuICAgICAgICB0aGlzLmZsdXNoaW5nQW5kcm9pZEtleSA9IC0xO1xuICAgICAgICB0aGlzLmxhc3RDaGFuZ2UgPSAwO1xuICAgICAgICB0aGlzLnNjcm9sbFRhcmdldHMgPSBbXTtcbiAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLnJlc2l6ZVNjcm9sbCA9IG51bGw7XG4gICAgICAgIHRoaXMuaW50ZXJzZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZ2FwSW50ZXJzZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5nYXBzID0gW107XG4gICAgICAgIC8vIFRpbWVvdXQgZm9yIHNjaGVkdWxpbmcgY2hlY2sgb2YgdGhlIHBhcmVudHMgdGhhdCBuZWVkIHNjcm9sbCBoYW5kbGVyc1xuICAgICAgICB0aGlzLnBhcmVudENoZWNrID0gLTE7XG4gICAgICAgIHRoaXMuZG9tID0gdmlldy5jb250ZW50RE9NO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IG11dCBvZiBtdXRhdGlvbnMpXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKG11dCk7XG4gICAgICAgICAgICAvLyBJRTExIHdpbGwgc29tZXRpbWVzIChvbiB0eXBpbmcgb3ZlciBhIHNlbGVjdGlvbiBvclxuICAgICAgICAgICAgLy8gYmFja3NwYWNpbmcgb3V0IGEgc2luZ2xlIGNoYXJhY3RlciB0ZXh0IG5vZGUpIGNhbGwgdGhlXG4gICAgICAgICAgICAvLyBvYnNlcnZlciBjYWxsYmFjayBiZWZvcmUgYWN0dWFsbHkgdXBkYXRpbmcgdGhlIERPTS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBVbnJlbGF0ZWRseSwgaU9TIFNhZmFyaSB3aWxsLCB3aGVuIGVuZGluZyBhIGNvbXBvc2l0aW9uLFxuICAgICAgICAgICAgLy8gc29tZXRpbWVzIGZpcnN0IGNsZWFyIGl0LCBkZWxpdmVyIHRoZSBtdXRhdGlvbnMsIGFuZCB0aGVuXG4gICAgICAgICAgICAvLyByZWluc2VydCB0aGUgZmluaXNoZWQgdGV4dC4gQ29kZU1pcnJvcidzIGhhbmRsaW5nIG9mIHRoZVxuICAgICAgICAgICAgLy8gZGVsZXRpb24gd2lsbCBwcmV2ZW50IHRoZSByZWluc2VydGlvbiBmcm9tIGhhcHBlbmluZyxcbiAgICAgICAgICAgIC8vIGJyZWFraW5nIGNvbXBvc2l0aW9uLlxuICAgICAgICAgICAgaWYgKChicm93c2VyLmllICYmIGJyb3dzZXIuaWVfdmVyc2lvbiA8PSAxMSB8fCBicm93c2VyLmlvcyAmJiB2aWV3LmNvbXBvc2luZykgJiZcbiAgICAgICAgICAgICAgICBtdXRhdGlvbnMuc29tZShtID0+IG0udHlwZSA9PSBcImNoaWxkTGlzdFwiICYmIG0ucmVtb3ZlZE5vZGVzLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgICAgICBtLnR5cGUgPT0gXCJjaGFyYWN0ZXJEYXRhXCIgJiYgbS5vbGRWYWx1ZS5sZW5ndGggPiBtLnRhcmdldC5ub2RlVmFsdWUubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh1c2VDaGFyRGF0YSlcbiAgICAgICAgICAgIHRoaXMub25DaGFyRGF0YSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWUucHVzaCh7IHRhcmdldDogZXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNoYXJhY3RlckRhdGFcIixcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWU6IGV2ZW50LnByZXZWYWx1ZSB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSA9IHRoaXMub25TZWxlY3Rpb25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblJlc2l6ZSA9IHRoaXMub25SZXNpemUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblByaW50ID0gdGhpcy5vblByaW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25TY3JvbGwgPSB0aGlzLm9uU2Nyb2xsLmJpbmQodGhpcyk7XG4gICAgICAgIGlmICh0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVNjcm9sbCA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmICgoKF9hID0gdGhpcy52aWV3LmRvY1ZpZXcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYXN0VXBkYXRlKSA8IERhdGUubm93KCkgLSA3NSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblJlc2l6ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVNjcm9sbC5vYnNlcnZlKHZpZXcuc2Nyb2xsRE9NKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZFdpbmRvd0xpc3RlbmVycyh0aGlzLndpbiA9IHZpZXcud2luKTtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICBpZiAodHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Q2hlY2sgPCAwKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudENoZWNrID0gc2V0VGltZW91dCh0aGlzLmxpc3RlbkZvclNjcm9sbC5iaW5kKHRoaXMpLCAxMDAwKTtcbiAgICAgICAgICAgICAgICBpZiAoZW50cmllcy5sZW5ndGggPiAwICYmIChlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV0uaW50ZXJzZWN0aW9uUmF0aW8gPiAwKSAhPSB0aGlzLmludGVyc2VjdGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVyc2VjdGluZyA9ICF0aGlzLmludGVyc2VjdGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0aW5nICE9IHRoaXMudmlldy5pblZpZXcpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uU2Nyb2xsQ2hhbmdlZChkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7IHRocmVzaG9sZDogWzAsIC4wMDFdIH0pO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24ub2JzZXJ2ZSh0aGlzLmRvbSk7XG4gICAgICAgICAgICB0aGlzLmdhcEludGVyc2VjdGlvbiA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZW50cmllcy5sZW5ndGggPiAwICYmIGVudHJpZXNbZW50cmllcy5sZW5ndGggLSAxXS5pbnRlcnNlY3Rpb25SYXRpbyA+IDApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25TY3JvbGxDaGFuZ2VkKGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIikpO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGlzdGVuRm9yU2Nyb2xsKCk7XG4gICAgICAgIHRoaXMucmVhZFNlbGVjdGlvblJhbmdlKCk7XG4gICAgfVxuICAgIG9uU2Nyb2xsQ2hhbmdlZChlKSB7XG4gICAgICAgIHRoaXMudmlldy5pbnB1dFN0YXRlLnJ1bkhhbmRsZXJzKFwic2Nyb2xsXCIsIGUpO1xuICAgICAgICBpZiAodGhpcy5pbnRlcnNlY3RpbmcpXG4gICAgICAgICAgICB0aGlzLnZpZXcubWVhc3VyZSgpO1xuICAgIH1cbiAgICBvblNjcm9sbChlKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVyc2VjdGluZylcbiAgICAgICAgICAgIHRoaXMuZmx1c2goZmFsc2UpO1xuICAgICAgICB0aGlzLm9uU2Nyb2xsQ2hhbmdlZChlKTtcbiAgICB9XG4gICAgb25SZXNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc2l6ZVRpbWVvdXQgPCAwKVxuICAgICAgICAgICAgdGhpcy5yZXNpemVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemVUaW1lb3V0ID0gLTE7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgICAgICB9LCA1MCk7XG4gICAgfVxuICAgIG9uUHJpbnQoKSB7XG4gICAgICAgIHRoaXMudmlldy52aWV3U3RhdGUucHJpbnRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnZpZXcubWVhc3VyZSgpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudmlldy52aWV3U3RhdGUucHJpbnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgICAgICB9LCA1MDApO1xuICAgIH1cbiAgICB1cGRhdGVHYXBzKGdhcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2FwSW50ZXJzZWN0aW9uICYmIChnYXBzLmxlbmd0aCAhPSB0aGlzLmdhcHMubGVuZ3RoIHx8IHRoaXMuZ2Fwcy5zb21lKChnLCBpKSA9PiBnICE9IGdhcHNbaV0pKSkge1xuICAgICAgICAgICAgdGhpcy5nYXBJbnRlcnNlY3Rpb24uZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgZ2FwIG9mIGdhcHMpXG4gICAgICAgICAgICAgICAgdGhpcy5nYXBJbnRlcnNlY3Rpb24ub2JzZXJ2ZShnYXApO1xuICAgICAgICAgICAgdGhpcy5nYXBzID0gZ2FwcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBvblNlbGVjdGlvbkNoYW5nZShldmVudCkge1xuICAgICAgICBsZXQgd2FzQ2hhbmdlZCA9IHRoaXMuc2VsZWN0aW9uQ2hhbmdlZDtcbiAgICAgICAgaWYgKCF0aGlzLnJlYWRTZWxlY3Rpb25SYW5nZSgpIHx8IHRoaXMuZGVsYXllZEFuZHJvaWRLZXkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXMsIHNlbCA9IHRoaXMuc2VsZWN0aW9uUmFuZ2U7XG4gICAgICAgIGlmICh2aWV3LnN0YXRlLmZhY2V0KGVkaXRhYmxlKSA/IHZpZXcucm9vdC5hY3RpdmVFbGVtZW50ICE9IHRoaXMuZG9tIDogIWhhc1NlbGVjdGlvbih2aWV3LmRvbSwgc2VsKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBzZWwuYW5jaG9yTm9kZSAmJiB2aWV3LmRvY1ZpZXcubmVhcmVzdChzZWwuYW5jaG9yTm9kZSk7XG4gICAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuaWdub3JlRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgICAgICBpZiAoIXdhc0NoYW5nZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVsZXRpb25zIG9uIElFMTEgZmlyZSB0aGVpciBldmVudHMgaW4gdGhlIHdyb25nIG9yZGVyLCBnaXZpbmdcbiAgICAgICAgLy8gdXMgYSBzZWxlY3Rpb24gY2hhbmdlIGV2ZW50IGJlZm9yZSB0aGUgRE9NIGNoYW5nZXMgYXJlXG4gICAgICAgIC8vIHJlcG9ydGVkLlxuICAgICAgICAvLyBDaHJvbWUgQW5kcm9pZCBoYXMgYSBzaW1pbGFyIGlzc3VlIHdoZW4gYmFja3NwYWNpbmcgb3V0IGFcbiAgICAgICAgLy8gc2VsZWN0aW9uICgjNjQ1KS5cbiAgICAgICAgaWYgKChicm93c2VyLmllICYmIGJyb3dzZXIuaWVfdmVyc2lvbiA8PSAxMSB8fCBicm93c2VyLmFuZHJvaWQgJiYgYnJvd3Nlci5jaHJvbWUpICYmICF2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmVtcHR5ICYmXG4gICAgICAgICAgICAvLyAoU2VsZWN0aW9uLmlzQ29sbGFwc2VkIGlzbid0IHJlbGlhYmxlIG9uIElFKVxuICAgICAgICAgICAgc2VsLmZvY3VzTm9kZSAmJiBpc0VxdWl2YWxlbnRQb3NpdGlvbihzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQsIHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0KSlcbiAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZmx1c2goZmFsc2UpO1xuICAgIH1cbiAgICByZWFkU2VsZWN0aW9uUmFuZ2UoKSB7XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXM7XG4gICAgICAgIC8vIFRoZSBTZWxlY3Rpb24gb2JqZWN0IGlzIGJyb2tlbiBpbiBzaGFkb3cgcm9vdHMgaW4gU2FmYXJpLiBTZWVcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NvZGVtaXJyb3IvZGV2L2lzc3Vlcy80MTRcbiAgICAgICAgbGV0IHJhbmdlID0gYnJvd3Nlci5zYWZhcmkgJiYgdmlldy5yb290Lm5vZGVUeXBlID09IDExICYmXG4gICAgICAgICAgICBkZWVwQWN0aXZlRWxlbWVudCh0aGlzLmRvbS5vd25lckRvY3VtZW50KSA9PSB0aGlzLmRvbSAmJlxuICAgICAgICAgICAgc2FmYXJpU2VsZWN0aW9uUmFuZ2VIYWNrKHRoaXMudmlldykgfHwgZ2V0U2VsZWN0aW9uKHZpZXcucm9vdCk7XG4gICAgICAgIGlmICghcmFuZ2UgfHwgdGhpcy5zZWxlY3Rpb25SYW5nZS5lcShyYW5nZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBsb2NhbCA9IGhhc1NlbGVjdGlvbih0aGlzLmRvbSwgcmFuZ2UpO1xuICAgICAgICAvLyBEZXRlY3QgdGhlIHNpdHVhdGlvbiB3aGVyZSB0aGUgYnJvd3NlciBoYXMsIG9uIGZvY3VzLCBtb3ZlZCB0aGVcbiAgICAgICAgLy8gc2VsZWN0aW9uIHRvIHRoZSBzdGFydCBvZiB0aGUgY29udGVudCBlbGVtZW50LiBSZXNldCBpdCB0byB0aGVcbiAgICAgICAgLy8gcG9zaXRpb24gZnJvbSB0aGUgZWRpdG9yIHN0YXRlLlxuICAgICAgICBpZiAobG9jYWwgJiYgIXRoaXMuc2VsZWN0aW9uQ2hhbmdlZCAmJlxuICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmxhc3RGb2N1c1RpbWUgPiBEYXRlLm5vdygpIC0gMjAwICYmXG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUubGFzdFRvdWNoVGltZSA8IERhdGUubm93KCkgLSAzMDAgJiZcbiAgICAgICAgICAgIGF0RWxlbWVudFN0YXJ0KHRoaXMuZG9tLCByYW5nZSkpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5pbnB1dFN0YXRlLmxhc3RGb2N1c1RpbWUgPSAwO1xuICAgICAgICAgICAgdmlldy5kb2NWaWV3LnVwZGF0ZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2Uuc2V0UmFuZ2UocmFuZ2UpO1xuICAgICAgICBpZiAobG9jYWwpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc2V0U2VsZWN0aW9uUmFuZ2UoYW5jaG9yLCBoZWFkKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2Uuc2V0KGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0LCBoZWFkLm5vZGUsIGhlYWQub2Zmc2V0KTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XG4gICAgfVxuICAgIGNsZWFyU2VsZWN0aW9uUmFuZ2UoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2Uuc2V0KG51bGwsIDAsIG51bGwsIDApO1xuICAgIH1cbiAgICBsaXN0ZW5Gb3JTY3JvbGwoKSB7XG4gICAgICAgIHRoaXMucGFyZW50Q2hlY2sgPSAtMTtcbiAgICAgICAgbGV0IGkgPSAwLCBjaGFuZ2VkID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgZG9tID0gdGhpcy5kb207IGRvbTspIHtcbiAgICAgICAgICAgIGlmIChkb20ubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgICAgIGlmICghY2hhbmdlZCAmJiBpIDwgdGhpcy5zY3JvbGxUYXJnZXRzLmxlbmd0aCAmJiB0aGlzLnNjcm9sbFRhcmdldHNbaV0gPT0gZG9tKVxuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWNoYW5nZWQpXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0aGlzLnNjcm9sbFRhcmdldHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWQpXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQucHVzaChkb20pO1xuICAgICAgICAgICAgICAgIGRvbSA9IGRvbS5hc3NpZ25lZFNsb3QgfHwgZG9tLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkb20ubm9kZVR5cGUgPT0gMTEpIHsgLy8gU2hhZG93IHJvb3RcbiAgICAgICAgICAgICAgICBkb20gPSBkb20uaG9zdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpIDwgdGhpcy5zY3JvbGxUYXJnZXRzLmxlbmd0aCAmJiAhY2hhbmdlZClcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0aGlzLnNjcm9sbFRhcmdldHMuc2xpY2UoMCwgaSk7XG4gICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBkb20gb2YgdGhpcy5zY3JvbGxUYXJnZXRzKVxuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgICAgICAgICAgZm9yIChsZXQgZG9tIG9mIHRoaXMuc2Nyb2xsVGFyZ2V0cyA9IGNoYW5nZWQpXG4gICAgICAgICAgICAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWdub3JlKGYpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybiBmKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgIHJldHVybiBmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5vYnNlcnZlKHRoaXMuZG9tLCBvYnNlcnZlT3B0aW9ucyk7XG4gICAgICAgIGlmICh1c2VDaGFyRGF0YSlcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcy5vbkNoYXJEYXRhKTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgaWYgKHVzZUNoYXJEYXRhKVxuICAgICAgICAgICAgdGhpcy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLm9uQ2hhckRhdGEpO1xuICAgIH1cbiAgICAvLyBUaHJvdyBhd2F5IGFueSBwZW5kaW5nIGNoYW5nZXNcbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzUmVjb3JkcygpO1xuICAgICAgICB0aGlzLnF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBDaHJvbWUgQW5kcm9pZCwgZXNwZWNpYWxseSBpbiBjb21iaW5hdGlvbiB3aXRoIEdCb2FyZCwgbm90IG9ubHlcbiAgICAvLyBkb2Vzbid0IHJlbGlhYmx5IGZpcmUgcmVndWxhciBrZXkgZXZlbnRzLCBidXQgYWxzbyBvZnRlblxuICAgIC8vIHN1cnJvdW5kcyB0aGUgZWZmZWN0IG9mIGVudGVyIG9yIGJhY2tzcGFjZSB3aXRoIGEgYnVuY2ggb2ZcbiAgICAvLyBjb21wb3NpdGlvbiBldmVudHMgdGhhdCwgd2hlbiBpbnRlcnJ1cHRlZCwgY2F1c2UgdGV4dCBkdXBsaWNhdGlvblxuICAgIC8vIG9yIG90aGVyIGtpbmRzIG9mIGNvcnJ1cHRpb24uIFRoaXMgaGFjayBtYWtlcyB0aGUgZWRpdG9yIGJhY2sgb2ZmXG4gICAgLy8gZnJvbSBoYW5kbGluZyBET00gY2hhbmdlcyBmb3IgYSBtb21lbnQgd2hlbiBzdWNoIGEga2V5IGlzXG4gICAgLy8gZGV0ZWN0ZWQgKHZpYSBiZWZvcmVpbnB1dCBvciBrZXlkb3duKSwgYW5kIHRoZW4gdHJpZXMgdG8gZmx1c2hcbiAgICAvLyB0aGVtIG9yLCBpZiB0aGF0IGhhcyBubyBlZmZlY3QsIGRpc3BhdGNoZXMgdGhlIGdpdmVuIGtleS5cbiAgICBkZWxheUFuZHJvaWRLZXkoa2V5LCBrZXlDb2RlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5KSB7XG4gICAgICAgICAgICBsZXQgZmx1c2ggPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGtleSA9IHRoaXMuZGVsYXllZEFuZHJvaWRLZXk7XG4gICAgICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyRGVsYXllZEFuZHJvaWRLZXkoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUubGFzdEtleUNvZGUgPSBrZXkua2V5Q29kZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUubGFzdEtleVRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmx1c2hlZCA9IHRoaXMuZmx1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmbHVzaGVkICYmIGtleS5mb3JjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHRoaXMuZG9tLCBrZXkua2V5LCBrZXkua2V5Q29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5ID0gdGhpcy52aWV3Lndpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZmx1c2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmNlIGJhY2tzcGFjZSBiZWZvcmVpbnB1dCBpcyBzb21ldGltZXMgc2lnbmFsbGVkIHNwdXJpb3VzbHksXG4gICAgICAgIC8vIEVudGVyIGFsd2F5cyB0YWtlcyBwcmVjZWRlbmNlLlxuICAgICAgICBpZiAoIXRoaXMuZGVsYXllZEFuZHJvaWRLZXkgfHwga2V5ID09IFwiRW50ZXJcIilcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZEFuZHJvaWRLZXkgPSB7XG4gICAgICAgICAgICAgICAga2V5LCBrZXlDb2RlLFxuICAgICAgICAgICAgICAgIC8vIE9ubHkgcnVuIHRoZSBrZXkgaGFuZGxlciB3aGVuIG5vIGNoYW5nZXMgYXJlIGRldGVjdGVkIGlmXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpc24ndCBjb21pbmcgcmlnaHQgYWZ0ZXIgYW5vdGhlciBjaGFuZ2UsIGluIHdoaWNoIGNhc2VcbiAgICAgICAgICAgICAgICAvLyBpdCBpcyBwcm9iYWJseSBwYXJ0IG9mIGEgd2VpcmQgY2hhaW4gb2YgdXBkYXRlcywgYW5kIHNob3VsZFxuICAgICAgICAgICAgICAgIC8vIGJlIGlnbm9yZWQgaWYgaXQgcmV0dXJucyB0aGUgRE9NIHRvIGl0cyBwcmV2aW91cyBzdGF0ZS5cbiAgICAgICAgICAgICAgICBmb3JjZTogdGhpcy5sYXN0Q2hhbmdlIDwgRGF0ZS5ub3coKSAtIDUwIHx8ICEhKChfYSA9IHRoaXMuZGVsYXllZEFuZHJvaWRLZXkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JjZSlcbiAgICAgICAgICAgIH07XG4gICAgfVxuICAgIGNsZWFyRGVsYXllZEFuZHJvaWRLZXkoKSB7XG4gICAgICAgIHRoaXMud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5KTtcbiAgICAgICAgdGhpcy5kZWxheWVkQW5kcm9pZEtleSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5ID0gLTE7XG4gICAgfVxuICAgIGZsdXNoU29vbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVsYXllZEZsdXNoIDwgMClcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZEZsdXNoID0gdGhpcy52aWV3Lndpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4geyB0aGlzLmRlbGF5ZWRGbHVzaCA9IC0xOyB0aGlzLmZsdXNoKCk7IH0pO1xuICAgIH1cbiAgICBmb3JjZUZsdXNoKCkge1xuICAgICAgICBpZiAodGhpcy5kZWxheWVkRmx1c2ggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy52aWV3Lndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmRlbGF5ZWRGbHVzaCk7XG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRGbHVzaCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG4gICAgcGVuZGluZ1JlY29yZHMoKSB7XG4gICAgICAgIGZvciAobGV0IG11dCBvZiB0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCkpXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2gobXV0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWU7XG4gICAgfVxuICAgIHByb2Nlc3NSZWNvcmRzKCkge1xuICAgICAgICBsZXQgcmVjb3JkcyA9IHRoaXMucGVuZGluZ1JlY29yZHMoKTtcbiAgICAgICAgaWYgKHJlY29yZHMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICBsZXQgZnJvbSA9IC0xLCB0byA9IC0xLCB0eXBlT3ZlciA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCByZWNvcmQgb2YgcmVjb3Jkcykge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gdGhpcy5yZWFkTXV0YXRpb24ocmVjb3JkKTtcbiAgICAgICAgICAgIGlmICghcmFuZ2UpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmFuZ2UudHlwZU92ZXIpXG4gICAgICAgICAgICAgICAgdHlwZU92ZXIgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGZyb20gPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAoeyBmcm9tLCB0byB9ID0gcmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJvbSA9IE1hdGgubWluKHJhbmdlLmZyb20sIGZyb20pO1xuICAgICAgICAgICAgICAgIHRvID0gTWF0aC5tYXgocmFuZ2UudG8sIHRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmcm9tLCB0bywgdHlwZU92ZXIgfTtcbiAgICB9XG4gICAgcmVhZENoYW5nZSgpIHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8sIHR5cGVPdmVyIH0gPSB0aGlzLnByb2Nlc3NSZWNvcmRzKCk7XG4gICAgICAgIGxldCBuZXdTZWwgPSB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgJiYgaGFzU2VsZWN0aW9uKHRoaXMuZG9tLCB0aGlzLnNlbGVjdGlvblJhbmdlKTtcbiAgICAgICAgaWYgKGZyb20gPCAwICYmICFuZXdTZWwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKGZyb20gPiAtMSlcbiAgICAgICAgICAgIHRoaXMubGFzdENoYW5nZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMudmlldy5pbnB1dFN0YXRlLmxhc3RGb2N1c1RpbWUgPSAwO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNoYW5nZSA9IG5ldyBET01DaGFuZ2UodGhpcy52aWV3LCBmcm9tLCB0bywgdHlwZU92ZXIpO1xuICAgICAgICB0aGlzLnZpZXcuZG9jVmlldy5kb21DaGFuZ2VkID0geyBuZXdTZWw6IGNoYW5nZS5uZXdTZWwgPyBjaGFuZ2UubmV3U2VsLm1haW4gOiBudWxsIH07XG4gICAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfVxuICAgIC8vIEFwcGx5IHBlbmRpbmcgY2hhbmdlcywgaWYgYW55XG4gICAgZmx1c2gocmVhZFNlbGVjdGlvbiA9IHRydWUpIHtcbiAgICAgICAgLy8gQ29tcGxldGVseSBob2xkIG9mZiBmbHVzaGluZyB3aGVuIHBlbmRpbmcga2V5cyBhcmUgc2V04oCUdGhlIGNvZGVcbiAgICAgICAgLy8gbWFuYWdpbmcgdGhvc2Ugd2lsbCBtYWtlIHN1cmUgcHJvY2Vzc1JlY29yZHMgaXMgY2FsbGVkIGFuZCB0aGVcbiAgICAgICAgLy8gdmlldyBpcyByZXN5bmNocm9uaXplZCBhZnRlclxuICAgICAgICBpZiAodGhpcy5kZWxheWVkRmx1c2ggPj0gMCB8fCB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAocmVhZFNlbGVjdGlvbilcbiAgICAgICAgICAgIHRoaXMucmVhZFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCBkb21DaGFuZ2UgPSB0aGlzLnJlYWRDaGFuZ2UoKTtcbiAgICAgICAgaWYgKCFkb21DaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydFN0YXRlID0gdGhpcy52aWV3LnN0YXRlO1xuICAgICAgICBsZXQgaGFuZGxlZCA9IGFwcGx5RE9NQ2hhbmdlKHRoaXMudmlldywgZG9tQ2hhbmdlKTtcbiAgICAgICAgLy8gVGhlIHZpZXcgd2Fzbid0IHVwZGF0ZWRcbiAgICAgICAgaWYgKHRoaXMudmlldy5zdGF0ZSA9PSBzdGFydFN0YXRlKVxuICAgICAgICAgICAgdGhpcy52aWV3LnVwZGF0ZShbXSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVkO1xuICAgIH1cbiAgICByZWFkTXV0YXRpb24ocmVjKSB7XG4gICAgICAgIGxldCBjVmlldyA9IHRoaXMudmlldy5kb2NWaWV3Lm5lYXJlc3QocmVjLnRhcmdldCk7XG4gICAgICAgIGlmICghY1ZpZXcgfHwgY1ZpZXcuaWdub3JlTXV0YXRpb24ocmVjKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjVmlldy5tYXJrRGlydHkocmVjLnR5cGUgPT0gXCJhdHRyaWJ1dGVzXCIpO1xuICAgICAgICBpZiAocmVjLnR5cGUgPT0gXCJhdHRyaWJ1dGVzXCIpXG4gICAgICAgICAgICBjVmlldy5mbGFncyB8PSA0IC8qIFZpZXdGbGFnLkF0dHJzRGlydHkgKi87XG4gICAgICAgIGlmIChyZWMudHlwZSA9PSBcImNoaWxkTGlzdFwiKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGRCZWZvcmUgPSBmaW5kQ2hpbGQoY1ZpZXcsIHJlYy5wcmV2aW91c1NpYmxpbmcgfHwgcmVjLnRhcmdldC5wcmV2aW91c1NpYmxpbmcsIC0xKTtcbiAgICAgICAgICAgIGxldCBjaGlsZEFmdGVyID0gZmluZENoaWxkKGNWaWV3LCByZWMubmV4dFNpYmxpbmcgfHwgcmVjLnRhcmdldC5uZXh0U2libGluZywgMSk7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tOiBjaGlsZEJlZm9yZSA/IGNWaWV3LnBvc0FmdGVyKGNoaWxkQmVmb3JlKSA6IGNWaWV3LnBvc0F0U3RhcnQsXG4gICAgICAgICAgICAgICAgdG86IGNoaWxkQWZ0ZXIgPyBjVmlldy5wb3NCZWZvcmUoY2hpbGRBZnRlcikgOiBjVmlldy5wb3NBdEVuZCwgdHlwZU92ZXI6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVjLnR5cGUgPT0gXCJjaGFyYWN0ZXJEYXRhXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGZyb206IGNWaWV3LnBvc0F0U3RhcnQsIHRvOiBjVmlldy5wb3NBdEVuZCwgdHlwZU92ZXI6IHJlYy50YXJnZXQubm9kZVZhbHVlID09IHJlYy5vbGRWYWx1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0V2luZG93KHdpbikge1xuICAgICAgICBpZiAod2luICE9IHRoaXMud2luKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVdpbmRvd0xpc3RlbmVycyh0aGlzLndpbik7XG4gICAgICAgICAgICB0aGlzLndpbiA9IHdpbjtcbiAgICAgICAgICAgIHRoaXMuYWRkV2luZG93TGlzdGVuZXJzKHRoaXMud2luKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRXaW5kb3dMaXN0ZW5lcnMod2luKSB7XG4gICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMub25SZXNpemUpO1xuICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXByaW50XCIsIHRoaXMub25QcmludCk7XG4gICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgICAgICB3aW4uZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICB9XG4gICAgcmVtb3ZlV2luZG93TGlzdGVuZXJzKHdpbikge1xuICAgICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5vblJlc2l6ZSk7XG4gICAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JlcHJpbnRcIiwgdGhpcy5vblByaW50KTtcbiAgICAgICAgd2luLmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgKF9hID0gdGhpcy5pbnRlcnNlY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNjb25uZWN0KCk7XG4gICAgICAgIChfYiA9IHRoaXMuZ2FwSW50ZXJzZWN0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlzY29ubmVjdCgpO1xuICAgICAgICAoX2MgPSB0aGlzLnJlc2l6ZVNjcm9sbCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgZm9yIChsZXQgZG9tIG9mIHRoaXMuc2Nyb2xsVGFyZ2V0cylcbiAgICAgICAgICAgIGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgICAgICB0aGlzLnJlbW92ZVdpbmRvd0xpc3RlbmVycyh0aGlzLndpbik7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBhcmVudENoZWNrKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVzaXplVGltZW91dCk7XG4gICAgICAgIHRoaXMud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZGVsYXllZEZsdXNoKTtcbiAgICAgICAgdGhpcy53aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRDaGlsZChjVmlldywgZG9tLCBkaXIpIHtcbiAgICB3aGlsZSAoZG9tKSB7XG4gICAgICAgIGxldCBjdXJWaWV3ID0gQ29udGVudFZpZXcuZ2V0KGRvbSk7XG4gICAgICAgIGlmIChjdXJWaWV3ICYmIGN1clZpZXcucGFyZW50ID09IGNWaWV3KVxuICAgICAgICAgICAgcmV0dXJuIGN1clZpZXc7XG4gICAgICAgIGxldCBwYXJlbnQgPSBkb20ucGFyZW50Tm9kZTtcbiAgICAgICAgZG9tID0gcGFyZW50ICE9IGNWaWV3LmRvbSA/IHBhcmVudCA6IGRpciA+IDAgPyBkb20ubmV4dFNpYmxpbmcgOiBkb20ucHJldmlvdXNTaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8vIFVzZWQgdG8gd29yayBhcm91bmQgYSBTYWZhcmkgU2VsZWN0aW9uL3NoYWRvdyBET00gYnVnICgjNDE0KVxuZnVuY3Rpb24gc2FmYXJpU2VsZWN0aW9uUmFuZ2VIYWNrKHZpZXcpIHtcbiAgICBsZXQgZm91bmQgPSBudWxsO1xuICAgIC8vIEJlY2F1c2UgU2FmYXJpIChhdCBsZWFzdCBpbiAyMDE4LTIwMjEpIGRvZXNuJ3QgcHJvdmlkZSByZWd1bGFyXG4gICAgLy8gYWNjZXNzIHRvIHRoZSBzZWxlY3Rpb24gaW5zaWRlIGEgc2hhZG93cm9vdCwgd2UgaGF2ZSB0byBwZXJmb3JtIGFcbiAgICAvLyByaWRpY3Vsb3VzIGhhY2sgdG8gZ2V0IGF0IGl04oCUdXNpbmcgYGV4ZWNDb21tYW5kYCB0byB0cmlnZ2VyIGFcbiAgICAvLyBgYmVmb3JlSW5wdXRgIGV2ZW50IHNvIHRoYXQgd2UgY2FuIHJlYWQgdGhlIHRhcmdldCByYW5nZSBmcm9tIHRoZVxuICAgIC8vIGV2ZW50LlxuICAgIGZ1bmN0aW9uIHJlYWQoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGZvdW5kID0gZXZlbnQuZ2V0VGFyZ2V0UmFuZ2VzKClbMF07XG4gICAgfVxuICAgIHZpZXcuY29udGVudERPTS5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgcmVhZCwgdHJ1ZSk7XG4gICAgdmlldy5kb20ub3duZXJEb2N1bWVudC5leGVjQ29tbWFuZChcImluZGVudFwiKTtcbiAgICB2aWV3LmNvbnRlbnRET00ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZWlucHV0XCIsIHJlYWQsIHRydWUpO1xuICAgIGlmICghZm91bmQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBhbmNob3JOb2RlID0gZm91bmQuc3RhcnRDb250YWluZXIsIGFuY2hvck9mZnNldCA9IGZvdW5kLnN0YXJ0T2Zmc2V0O1xuICAgIGxldCBmb2N1c05vZGUgPSBmb3VuZC5lbmRDb250YWluZXIsIGZvY3VzT2Zmc2V0ID0gZm91bmQuZW5kT2Zmc2V0O1xuICAgIGxldCBjdXJBbmNob3IgPSB2aWV3LmRvY1ZpZXcuZG9tQXRQb3Modmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5hbmNob3IpO1xuICAgIC8vIFNpbmNlIHN1Y2ggYSByYW5nZSBkb2Vzbid0IGRpc3Rpbmd1aXNoIGJldHdlZW4gYW5jaG9yIGFuZCBoZWFkLFxuICAgIC8vIHVzZSBhIGhldXJpc3RpYyB0aGF0IGZsaXBzIGl0IGFyb3VuZCBpZiBpdHMgZW5kIG1hdGNoZXMgdGhlXG4gICAgLy8gY3VycmVudCBhbmNob3IuXG4gICAgaWYgKGlzRXF1aXZhbGVudFBvc2l0aW9uKGN1ckFuY2hvci5ub2RlLCBjdXJBbmNob3Iub2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSlcbiAgICAgICAgW2FuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldF0gPSBbZm9jdXNOb2RlLCBmb2N1c09mZnNldCwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0XTtcbiAgICByZXR1cm4geyBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQgfTtcbn1cblxuLy8gVGhlIGVkaXRvcidzIHVwZGF0ZSBzdGF0ZSBtYWNoaW5lIGxvb2tzIHNvbWV0aGluZyBsaWtlIHRoaXM6XG4vL1xuLy8gICAgIElkbGUg4oaSIFVwZGF0aW5nIOKHhiBJZGxlICh1bmNoZWNrZWQpIOKGkiBNZWFzdXJpbmcg4oaSIElkbGVcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDihpEgICAgICDihpNcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVcGRhdGluZyAobWVhc3VyZSlcbi8vXG4vLyBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuICdJZGxlJyBhbmQgJ0lkbGUgKHVuY2hlY2tlZCknIGxpZXMgaW5cbi8vIHdoZXRoZXIgYSBsYXlvdXQgY2hlY2sgaGFzIGJlZW4gc2NoZWR1bGVkLiBBIHJlZ3VsYXIgdXBkYXRlIHRocm91Z2hcbi8vIHRoZSBgdXBkYXRlYCBtZXRob2QgdXBkYXRlcyB0aGUgRE9NIGluIGEgd3JpdGUtb25seSBmYXNoaW9uLCBhbmRcbi8vIHJlbGllcyBvbiBhIGNoZWNrIChzY2hlZHVsZWQgd2l0aCBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCkgdG8gbWFrZVxuLy8gc3VyZSBldmVyeXRoaW5nIGlzIHdoZXJlIGl0IHNob3VsZCBiZSBhbmQgdGhlIHZpZXdwb3J0IGNvdmVycyB0aGVcbi8vIHZpc2libGUgY29kZS4gVGhhdCBjaGVjayBjb250aW51ZXMgdG8gbWVhc3VyZSBhbmQgdGhlbiBvcHRpb25hbGx5XG4vLyB1cGRhdGUgdW50aWwgaXQgcmVhY2hlcyBhIGNvaGVyZW50IHN0YXRlLlxuLyoqXG5BbiBlZGl0b3IgdmlldyByZXByZXNlbnRzIHRoZSBlZGl0b3IncyB1c2VyIGludGVyZmFjZS4gSXQgaG9sZHNcbnRoZSBlZGl0YWJsZSBET00gc3VyZmFjZSwgYW5kIHBvc3NpYmx5IG90aGVyIGVsZW1lbnRzIHN1Y2ggYXMgdGhlXG5saW5lIG51bWJlciBndXR0ZXIuIEl0IGhhbmRsZXMgZXZlbnRzIGFuZCBkaXNwYXRjaGVzIHN0YXRlXG50cmFuc2FjdGlvbnMgZm9yIGVkaXRpbmcgYWN0aW9ucy5cbiovXG5jbGFzcyBFZGl0b3JWaWV3IHtcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBlZGl0b3Igc3RhdGUuXG4gICAgKi9cbiAgICBnZXQgc3RhdGUoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5zdGF0ZTsgfVxuICAgIC8qKlxuICAgIFRvIGJlIGFibGUgdG8gZGlzcGxheSBsYXJnZSBkb2N1bWVudHMgd2l0aG91dCBjb25zdW1pbmcgdG9vIG11Y2hcbiAgICBtZW1vcnkgb3Igb3ZlcmxvYWRpbmcgdGhlIGJyb3dzZXIsIENvZGVNaXJyb3Igb25seSBkcmF3cyB0aGVcbiAgICBjb2RlIHRoYXQgaXMgdmlzaWJsZSAocGx1cyBhIG1hcmdpbiBhcm91bmQgaXQpIHRvIHRoZSBET00uIFRoaXNcbiAgICBwcm9wZXJ0eSB0ZWxscyB5b3UgdGhlIGV4dGVudCBvZiB0aGUgY3VycmVudCBkcmF3biB2aWV3cG9ydCwgaW5cbiAgICBkb2N1bWVudCBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICBnZXQgdmlld3BvcnQoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS52aWV3cG9ydDsgfVxuICAgIC8qKlxuICAgIFdoZW4gdGhlcmUgYXJlLCBmb3IgZXhhbXBsZSwgbGFyZ2UgY29sbGFwc2VkIHJhbmdlcyBpbiB0aGVcbiAgICB2aWV3cG9ydCwgaXRzIHNpemUgY2FuIGJlIGEgbG90IGJpZ2dlciB0aGFuIHRoZSBhY3R1YWwgdmlzaWJsZVxuICAgIGNvbnRlbnQuIFRodXMsIGlmIHlvdSBhcmUgZG9pbmcgc29tZXRoaW5nIGxpa2Ugc3R5bGluZyB0aGVcbiAgICBjb250ZW50IGluIHRoZSB2aWV3cG9ydCwgaXQgaXMgcHJlZmVyYWJsZSB0byBvbmx5IGRvIHNvIGZvclxuICAgIHRoZXNlIHJhbmdlcywgd2hpY2ggYXJlIHRoZSBzdWJzZXQgb2YgdGhlIHZpZXdwb3J0IHRoYXQgaXNcbiAgICBhY3R1YWxseSBkcmF3bi5cbiAgICAqL1xuICAgIGdldCB2aXNpYmxlUmFuZ2VzKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUudmlzaWJsZVJhbmdlczsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgZmFsc2Ugd2hlbiB0aGUgZWRpdG9yIGlzIGVudGlyZWx5IHNjcm9sbGVkIG91dCBvZiB2aWV3XG4gICAgb3Igb3RoZXJ3aXNlIGhpZGRlbi5cbiAgICAqL1xuICAgIGdldCBpblZpZXcoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5pblZpZXc7IH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdXNlciBpcyBjdXJyZW50bHkgY29tcG9zaW5nIHRleHQgdmlhXG4gICAgW0lNRV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW5wdXRfbWV0aG9kKSwgYW5kIGF0IGxlYXN0XG4gICAgb25lIGNoYW5nZSBoYXMgYmVlbiBtYWRlIGluIHRoZSBjdXJyZW50IGNvbXBvc2l0aW9uLlxuICAgICovXG4gICAgZ2V0IGNvbXBvc2luZygpIHsgcmV0dXJuIHRoaXMuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPiAwOyB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHVzZXIgaXMgY3VycmVudGx5IGluIGNvbXBvc2luZyBzdGF0ZS4gTm90ZVxuICAgIHRoYXQgb24gc29tZSBwbGF0Zm9ybXMsIGxpa2UgQW5kcm9pZCwgdGhpcyB3aWxsIGJlIHRoZSBjYXNlIGFcbiAgICBsb3QsIHNpbmNlIGp1c3QgcHV0dGluZyB0aGUgY3Vyc29yIG9uIGEgd29yZCBzdGFydHMgYVxuICAgIGNvbXBvc2l0aW9uIHRoZXJlLlxuICAgICovXG4gICAgZ2V0IGNvbXBvc2l0aW9uU3RhcnRlZCgpIHsgcmV0dXJuIHRoaXMuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPj0gMDsgfVxuICAgIC8qKlxuICAgIFRoZSBkb2N1bWVudCBvciBzaGFkb3cgcm9vdCB0aGF0IHRoZSB2aWV3IGxpdmVzIGluLlxuICAgICovXG4gICAgZ2V0IHJvb3QoKSB7IHJldHVybiB0aGlzLl9yb290OyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgd2luKCkgeyByZXR1cm4gdGhpcy5kb20ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7IH1cbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBuZXcgdmlldy4gWW91J2xsIHdhbnQgdG8gZWl0aGVyIHByb3ZpZGUgYSBgcGFyZW50YFxuICAgIG9wdGlvbiwgb3IgcHV0IGB2aWV3LmRvbWAgaW50byB5b3VyIGRvY3VtZW50IGFmdGVyIGNyZWF0aW5nIGFcbiAgICB2aWV3LCBzbyB0aGF0IHRoZSB1c2VyIGNhbiBzZWUgdGhlIGVkaXRvci5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IFtdO1xuICAgICAgICB0aGlzLnBsdWdpbk1hcCA9IG5ldyBNYXA7XG4gICAgICAgIHRoaXMuZWRpdG9yQXR0cnMgPSB7fTtcbiAgICAgICAgdGhpcy5jb250ZW50QXR0cnMgPSB7fTtcbiAgICAgICAgdGhpcy5iaWRpQ2FjaGUgPSBbXTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMiAvKiBVcGRhdGVTdGF0ZS5VcGRhdGluZyAqLztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSAtMTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm1lYXN1cmVSZXF1ZXN0cyA9IFtdO1xuICAgICAgICB0aGlzLmNvbnRlbnRET00gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLnNjcm9sbERPTSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuc2Nyb2xsRE9NLnRhYkluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuc2Nyb2xsRE9NLmNsYXNzTmFtZSA9IFwiY20tc2Nyb2xsZXJcIjtcbiAgICAgICAgdGhpcy5zY3JvbGxET00uYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RE9NKTtcbiAgICAgICAgdGhpcy5hbm5vdW5jZURPTSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuYW5ub3VuY2VET00uY2xhc3NOYW1lID0gXCJjbS1hbm5vdW5jZWRcIjtcbiAgICAgICAgdGhpcy5hbm5vdW5jZURPTS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxpdmVcIiwgXCJwb2xpdGVcIik7XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQodGhpcy5hbm5vdW5jZURPTSk7XG4gICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuc2Nyb2xsRE9NKTtcbiAgICAgICAgaWYgKGNvbmZpZy5wYXJlbnQpXG4gICAgICAgICAgICBjb25maWcucGFyZW50LmFwcGVuZENoaWxkKHRoaXMuZG9tKTtcbiAgICAgICAgbGV0IHsgZGlzcGF0Y2ggfSA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5kaXNwYXRjaFRyYW5zYWN0aW9ucyA9IGNvbmZpZy5kaXNwYXRjaFRyYW5zYWN0aW9ucyB8fFxuICAgICAgICAgICAgKGRpc3BhdGNoICYmICgodHJzKSA9PiB0cnMuZm9yRWFjaCh0ciA9PiBkaXNwYXRjaCh0ciwgdGhpcykpKSkgfHxcbiAgICAgICAgICAgICgodHJzKSA9PiB0aGlzLnVwZGF0ZSh0cnMpKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCA9IHRoaXMuZGlzcGF0Y2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcm9vdCA9IChjb25maWcucm9vdCB8fCBnZXRSb290KGNvbmZpZy5wYXJlbnQpIHx8IGRvY3VtZW50KTtcbiAgICAgICAgdGhpcy52aWV3U3RhdGUgPSBuZXcgVmlld1N0YXRlKGNvbmZpZy5zdGF0ZSB8fCBFZGl0b3JTdGF0ZS5jcmVhdGUoY29uZmlnKSk7XG4gICAgICAgIGlmIChjb25maWcuc2Nyb2xsVG8gJiYgY29uZmlnLnNjcm9sbFRvLmlzKHNjcm9sbEludG9WaWV3KSlcbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLnNjcm9sbFRhcmdldCA9IGNvbmZpZy5zY3JvbGxUby52YWx1ZS5jbGlwKHRoaXMudmlld1N0YXRlLnN0YXRlKTtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gdGhpcy5zdGF0ZS5mYWNldCh2aWV3UGx1Z2luKS5tYXAoc3BlYyA9PiBuZXcgUGx1Z2luSW5zdGFuY2Uoc3BlYykpO1xuICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgcGx1Z2luLnVwZGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG5ldyBET01PYnNlcnZlcih0aGlzKTtcbiAgICAgICAgdGhpcy5pbnB1dFN0YXRlID0gbmV3IElucHV0U3RhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5lbnN1cmVIYW5kbGVycyh0aGlzLnBsdWdpbnMpO1xuICAgICAgICB0aGlzLmRvY1ZpZXcgPSBuZXcgRG9jVmlldyh0aGlzKTtcbiAgICAgICAgdGhpcy5tb3VudFN0eWxlcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUF0dHJzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi87XG4gICAgICAgIHRoaXMucmVxdWVzdE1lYXN1cmUoKTtcbiAgICB9XG4gICAgZGlzcGF0Y2goLi4uaW5wdXQpIHtcbiAgICAgICAgbGV0IHRycyA9IGlucHV0Lmxlbmd0aCA9PSAxICYmIGlucHV0WzBdIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24gPyBpbnB1dFxuICAgICAgICAgICAgOiBpbnB1dC5sZW5ndGggPT0gMSAmJiBBcnJheS5pc0FycmF5KGlucHV0WzBdKSA/IGlucHV0WzBdXG4gICAgICAgICAgICAgICAgOiBbdGhpcy5zdGF0ZS51cGRhdGUoLi4uaW5wdXQpXTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFRyYW5zYWN0aW9ucyh0cnMsIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIHZpZXcgZm9yIHRoZSBnaXZlbiBhcnJheSBvZiB0cmFuc2FjdGlvbnMuIFRoaXMgd2lsbFxuICAgIHVwZGF0ZSB0aGUgdmlzaWJsZSBkb2N1bWVudCBhbmQgc2VsZWN0aW9uIHRvIG1hdGNoIHRoZSBzdGF0ZVxuICAgIHByb2R1Y2VkIGJ5IHRoZSB0cmFuc2FjdGlvbnMsIGFuZCBub3RpZnkgdmlldyBwbHVnaW5zIG9mIHRoZVxuICAgIGNoYW5nZS4gWW91IHNob3VsZCB1c3VhbGx5IGNhbGxcbiAgICBbYGRpc3BhdGNoYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZGlzcGF0Y2gpIGluc3RlYWQsIHdoaWNoIHVzZXMgdGhpc1xuICAgIGFzIGEgcHJpbWl0aXZlLlxuICAgICovXG4gICAgdXBkYXRlKHRyYW5zYWN0aW9ucykge1xuICAgICAgICBpZiAodGhpcy51cGRhdGVTdGF0ZSAhPSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYWxscyB0byBFZGl0b3JWaWV3LnVwZGF0ZSBhcmUgbm90IGFsbG93ZWQgd2hpbGUgYW4gdXBkYXRlIGlzIGluIHByb2dyZXNzXCIpO1xuICAgICAgICBsZXQgcmVkcmF3biA9IGZhbHNlLCBhdHRyc0NoYW5nZWQgPSBmYWxzZSwgdXBkYXRlO1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICBmb3IgKGxldCB0ciBvZiB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0ci5zdGFydFN0YXRlICE9IHN0YXRlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVHJ5aW5nIHRvIHVwZGF0ZSBzdGF0ZSB3aXRoIGEgdHJhbnNhY3Rpb24gdGhhdCBkb2Vzbid0IHN0YXJ0IGZyb20gdGhlIHByZXZpb3VzIHN0YXRlLlwiKTtcbiAgICAgICAgICAgIHN0YXRlID0gdHIuc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmb2N1cyA9IHRoaXMuaGFzRm9jdXMsIGZvY3VzRmxhZyA9IDAsIGRpc3BhdGNoRm9jdXMgPSBudWxsO1xuICAgICAgICBpZiAodHJhbnNhY3Rpb25zLnNvbWUodHIgPT4gdHIuYW5ub3RhdGlvbihpc0ZvY3VzQ2hhbmdlKSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQgPSBmb2N1cztcbiAgICAgICAgICAgIC8vIElmIGEgZm9jdXMtY2hhbmdlIHRyYW5zYWN0aW9uIGlzIGJlaW5nIGRpc3BhdGNoZWQsIHNldCB0aGlzIHVwZGF0ZSBmbGFnLlxuICAgICAgICAgICAgZm9jdXNGbGFnID0gMSAvKiBVcGRhdGVGbGFnLkZvY3VzICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZvY3VzICE9IHRoaXMuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQgPSBmb2N1cztcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGEgc2VwYXJhdGUgZm9jdXMgdHJhbnNhY3Rpb24gaWYgbmVjZXNzYXJ5LCBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIGFkZCBhIGZsYWcgdG8gdGhpcyB1cGRhdGVcbiAgICAgICAgICAgIGRpc3BhdGNoRm9jdXMgPSBmb2N1c0NoYW5nZVRyYW5zYWN0aW9uKHN0YXRlLCBmb2N1cyk7XG4gICAgICAgICAgICBpZiAoIWRpc3BhdGNoRm9jdXMpXG4gICAgICAgICAgICAgICAgZm9jdXNGbGFnID0gMSAvKiBVcGRhdGVGbGFnLkZvY3VzICovO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIHdhcyBhIHBlbmRpbmcgRE9NIGNoYW5nZSwgZWFnZXJseSByZWFkIGl0IGFuZCB0cnkgdG9cbiAgICAgICAgLy8gYXBwbHkgaXQgYWZ0ZXIgdGhlIGdpdmVuIHRyYW5zYWN0aW9ucy5cbiAgICAgICAgbGV0IHBlbmRpbmdLZXkgPSB0aGlzLm9ic2VydmVyLmRlbGF5ZWRBbmRyb2lkS2V5LCBkb21DaGFuZ2UgPSBudWxsO1xuICAgICAgICBpZiAocGVuZGluZ0tleSkge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5jbGVhckRlbGF5ZWRBbmRyb2lkS2V5KCk7XG4gICAgICAgICAgICBkb21DaGFuZ2UgPSB0aGlzLm9ic2VydmVyLnJlYWRDaGFuZ2UoKTtcbiAgICAgICAgICAgIC8vIE9ubHkgdHJ5IHRvIGFwcGx5IERPTSBjaGFuZ2VzIGlmIHRoZSB0cmFuc2FjdGlvbnMgZGlkbid0XG4gICAgICAgICAgICAvLyBjaGFuZ2UgdGhlIGRvYyBvciBzZWxlY3Rpb24uXG4gICAgICAgICAgICBpZiAoZG9tQ2hhbmdlICYmICF0aGlzLnN0YXRlLmRvYy5lcShzdGF0ZS5kb2MpIHx8ICF0aGlzLnN0YXRlLnNlbGVjdGlvbi5lcShzdGF0ZS5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgICAgIGRvbUNoYW5nZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hlbiB0aGUgcGhyYXNlcyBjaGFuZ2UsIHJlZHJhdyB0aGUgZWRpdG9yXG4gICAgICAgIGlmIChzdGF0ZS5mYWNldChFZGl0b3JTdGF0ZS5waHJhc2VzKSAhPSB0aGlzLnN0YXRlLmZhY2V0KEVkaXRvclN0YXRlLnBocmFzZXMpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0U3RhdGUoc3RhdGUpO1xuICAgICAgICB1cGRhdGUgPSBWaWV3VXBkYXRlLmNyZWF0ZSh0aGlzLCBzdGF0ZSwgdHJhbnNhY3Rpb25zKTtcbiAgICAgICAgdXBkYXRlLmZsYWdzIHw9IGZvY3VzRmxhZztcbiAgICAgICAgbGV0IHNjcm9sbFRhcmdldCA9IHRoaXMudmlld1N0YXRlLnNjcm9sbFRhcmdldDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAyIC8qIFVwZGF0ZVN0YXRlLlVwZGF0aW5nICovO1xuICAgICAgICAgICAgZm9yIChsZXQgdHIgb2YgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbFRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVGFyZ2V0ID0gc2Nyb2xsVGFyZ2V0Lm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICBpZiAodHIuc2Nyb2xsSW50b1ZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgbWFpbiB9ID0gdHIuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxUYXJnZXQgPSBuZXcgU2Nyb2xsVGFyZ2V0KG1haW4uZW1wdHkgPyBtYWluIDogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihtYWluLmhlYWQsIG1haW4uaGVhZCA+IG1haW4uYW5jaG9yID8gLTEgOiAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGUgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuaXMoc2Nyb2xsSW50b1ZpZXcpKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVGFyZ2V0ID0gZS52YWx1ZS5jbGlwKHRoaXMuc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUudXBkYXRlKHVwZGF0ZSwgc2Nyb2xsVGFyZ2V0KTtcbiAgICAgICAgICAgIHRoaXMuYmlkaUNhY2hlID0gQ2FjaGVkT3JkZXIudXBkYXRlKHRoaXMuYmlkaUNhY2hlLCB1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgICAgICBpZiAoIXVwZGF0ZS5lbXB0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUGx1Z2lucyh1cGRhdGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZHJhd24gPSB0aGlzLmRvY1ZpZXcudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5mYWNldChzdHlsZU1vZHVsZSkgIT0gdGhpcy5zdHlsZU1vZHVsZXMpXG4gICAgICAgICAgICAgICAgdGhpcy5tb3VudFN0eWxlcygpO1xuICAgICAgICAgICAgYXR0cnNDaGFuZ2VkID0gdGhpcy51cGRhdGVBdHRycygpO1xuICAgICAgICAgICAgdGhpcy5zaG93QW5ub3VuY2VtZW50cyh0cmFuc2FjdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnVwZGF0ZVNlbGVjdGlvbihyZWRyYXduLCB0cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5pc1VzZXJFdmVudChcInNlbGVjdC5wb2ludGVyXCIpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldCh0aGVtZSkgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KHRoZW1lKSlcbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLm11c3RNZWFzdXJlQ29udGVudCA9IHRydWU7XG4gICAgICAgIGlmIChyZWRyYXduIHx8IGF0dHJzQ2hhbmdlZCB8fCBzY3JvbGxUYXJnZXQgfHwgdGhpcy52aWV3U3RhdGUubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyB8fCB0aGlzLnZpZXdTdGF0ZS5tdXN0TWVhc3VyZUNvbnRlbnQpXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgIGlmICghdXBkYXRlLmVtcHR5KVxuICAgICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5zdGF0ZS5mYWNldCh1cGRhdGVMaXN0ZW5lcikpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcih1cGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy5zdGF0ZSwgZSwgXCJ1cGRhdGUgbGlzdGVuZXJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoZGlzcGF0Y2hGb2N1cyB8fCBkb21DaGFuZ2UpXG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZGlzcGF0Y2hGb2N1cyAmJiB0aGlzLnN0YXRlID09IGRpc3BhdGNoRm9jdXMuc3RhcnRTdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaChkaXNwYXRjaEZvY3VzKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9tQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYXBwbHlET01DaGFuZ2UodGhpcywgZG9tQ2hhbmdlKSAmJiBwZW5kaW5nS2V5LmZvcmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hLZXkodGhpcy5jb250ZW50RE9NLCBwZW5kaW5nS2V5LmtleSwgcGVuZGluZ0tleS5rZXlDb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVzZXQgdGhlIHZpZXcgdG8gdGhlIGdpdmVuIHN0YXRlLiAoVGhpcyB3aWxsIGNhdXNlIHRoZSBlbnRpcmVcbiAgICBkb2N1bWVudCB0byBiZSByZWRyYXduIGFuZCBhbGwgdmlldyBwbHVnaW5zIHRvIGJlIHJlaW5pdGlhbGl6ZWQsXG4gICAgc28geW91IHNob3VsZCBwcm9iYWJseSBvbmx5IHVzZSBpdCB3aGVuIHRoZSBuZXcgc3RhdGUgaXNuJ3RcbiAgICBkZXJpdmVkIGZyb20gdGhlIG9sZCBzdGF0ZS4gT3RoZXJ3aXNlLCB1c2VcbiAgICBbYGRpc3BhdGNoYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZGlzcGF0Y2gpIGluc3RlYWQuKVxuICAgICovXG4gICAgc2V0U3RhdGUobmV3U3RhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU3RhdGUgIT0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbHMgdG8gRWRpdG9yVmlldy5zZXRTdGF0ZSBhcmUgbm90IGFsbG93ZWQgd2hpbGUgYW4gdXBkYXRlIGlzIGluIHByb2dyZXNzXCIpO1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDIgLyogVXBkYXRlU3RhdGUuVXBkYXRpbmcgKi87XG4gICAgICAgIGxldCBoYWRGb2N1cyA9IHRoaXMuaGFzRm9jdXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgICAgIHBsdWdpbi5kZXN0cm95KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUgPSBuZXcgVmlld1N0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgICAgIHRoaXMucGx1Z2lucyA9IG5ld1N0YXRlLmZhY2V0KHZpZXdQbHVnaW4pLm1hcChzcGVjID0+IG5ldyBQbHVnaW5JbnN0YW5jZShzcGVjKSk7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbk1hcC5jbGVhcigpO1xuICAgICAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgICAgICBwbHVnaW4udXBkYXRlKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5kb2NWaWV3LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldyA9IG5ldyBEb2NWaWV3KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLmVuc3VyZUhhbmRsZXJzKHRoaXMucGx1Z2lucyk7XG4gICAgICAgICAgICB0aGlzLm1vdW50U3R5bGVzKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUF0dHJzKCk7XG4gICAgICAgICAgICB0aGlzLmJpZGlDYWNoZSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFkRm9jdXMpXG4gICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIHRoaXMucmVxdWVzdE1lYXN1cmUoKTtcbiAgICB9XG4gICAgdXBkYXRlUGx1Z2lucyh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHByZXZTcGVjcyA9IHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHZpZXdQbHVnaW4pLCBzcGVjcyA9IHVwZGF0ZS5zdGF0ZS5mYWNldCh2aWV3UGx1Z2luKTtcbiAgICAgICAgaWYgKHByZXZTcGVjcyAhPSBzcGVjcykge1xuICAgICAgICAgICAgbGV0IG5ld1BsdWdpbnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHNwZWMgb2Ygc3BlY3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBwcmV2U3BlY3MuaW5kZXhPZihzcGVjKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1BsdWdpbnMucHVzaChuZXcgUGx1Z2luSW5zdGFuY2Uoc3BlYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHRoaXMucGx1Z2luc1tmb3VuZF07XG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbi5tdXN0VXBkYXRlID0gdXBkYXRlO1xuICAgICAgICAgICAgICAgICAgICBuZXdQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4ubXVzdFVwZGF0ZSAhPSB1cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbi5kZXN0cm95KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5zID0gbmV3UGx1Z2lucztcbiAgICAgICAgICAgIHRoaXMucGx1Z2luTWFwLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgICAgICBwLm11c3RVcGRhdGUgPSB1cGRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBsdWdpbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLnBsdWdpbnNbaV0udXBkYXRlKHRoaXMpO1xuICAgICAgICBpZiAocHJldlNwZWNzICE9IHNwZWNzKVxuICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLmVuc3VyZUhhbmRsZXJzKHRoaXMucGx1Z2lucyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWVhc3VyZShmbHVzaCA9IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlU2NoZWR1bGVkID4gLTEpXG4gICAgICAgICAgICB0aGlzLndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLm1lYXN1cmVTY2hlZHVsZWQpO1xuICAgICAgICBpZiAodGhpcy5vYnNlcnZlci5kZWxheWVkQW5kcm9pZEtleSkge1xuICAgICAgICAgICAgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID0gLTE7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID0gMDsgLy8gUHJldmVudCByZXF1ZXN0TWVhc3VyZSBjYWxscyBmcm9tIHNjaGVkdWxpbmcgYW5vdGhlciBhbmltYXRpb24gZnJhbWVcbiAgICAgICAgaWYgKGZsdXNoKVxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5mb3JjZUZsdXNoKCk7XG4gICAgICAgIGxldCB1cGRhdGVkID0gbnVsbDtcbiAgICAgICAgbGV0IHNET00gPSB0aGlzLnNjcm9sbERPTSwgc2Nyb2xsVG9wID0gc0RPTS5zY3JvbGxUb3AgKiB0aGlzLnNjYWxlWTtcbiAgICAgICAgbGV0IHsgc2Nyb2xsQW5jaG9yUG9zLCBzY3JvbGxBbmNob3JIZWlnaHQgfSA9IHRoaXMudmlld1N0YXRlO1xuICAgICAgICBpZiAoTWF0aC5hYnMoc2Nyb2xsVG9wIC0gdGhpcy52aWV3U3RhdGUuc2Nyb2xsVG9wKSA+IDEpXG4gICAgICAgICAgICBzY3JvbGxBbmNob3JIZWlnaHQgPSAtMTtcbiAgICAgICAgdGhpcy52aWV3U3RhdGUuc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gLTE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxBbmNob3JIZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Njcm9sbGVkVG9Cb3R0b20oc0RPTSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEFuY2hvclBvcyA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gdGhpcy52aWV3U3RhdGUuaGVpZ2h0TWFwLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBibG9jayA9IHRoaXMudmlld1N0YXRlLnNjcm9sbEFuY2hvckF0KHNjcm9sbFRvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3JQb3MgPSBibG9jay5mcm9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gYmxvY2sudG9wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAxIC8qIFVwZGF0ZVN0YXRlLk1lYXN1cmluZyAqLztcbiAgICAgICAgICAgICAgICBsZXQgY2hhbmdlZCA9IHRoaXMudmlld1N0YXRlLm1lYXN1cmUodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGFuZ2VkICYmICF0aGlzLm1lYXN1cmVSZXF1ZXN0cy5sZW5ndGggJiYgdGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0ID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChpID4gNSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4odGhpcy5tZWFzdXJlUmVxdWVzdHMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiTWVhc3VyZSBsb29wIHJlc3RhcnRlZCBtb3JlIHRoYW4gNSB0aW1lc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwiVmlld3BvcnQgZmFpbGVkIHRvIHN0YWJpbGl6ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBtZWFzdXJpbmcgPSBbXTtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHJ1biBtZWFzdXJlIHJlcXVlc3RzIGluIHRoaXMgY3ljbGUgd2hlbiB0aGUgdmlld3BvcnQgZGlkbid0IGNoYW5nZVxuICAgICAgICAgICAgICAgIGlmICghKGNoYW5nZWQgJiA0IC8qIFVwZGF0ZUZsYWcuVmlld3BvcnQgKi8pKVxuICAgICAgICAgICAgICAgICAgICBbdGhpcy5tZWFzdXJlUmVxdWVzdHMsIG1lYXN1cmluZ10gPSBbbWVhc3VyaW5nLCB0aGlzLm1lYXN1cmVSZXF1ZXN0c107XG4gICAgICAgICAgICAgICAgbGV0IG1lYXN1cmVkID0gbWVhc3VyaW5nLm1hcChtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtLnJlYWQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih0aGlzLnN0YXRlLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCYWRNZWFzdXJlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGV0IHVwZGF0ZSA9IFZpZXdVcGRhdGUuY3JlYXRlKHRoaXMsIHRoaXMuc3RhdGUsIFtdKSwgcmVkcmF3biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHVwZGF0ZS5mbGFncyB8PSBjaGFuZ2VkO1xuICAgICAgICAgICAgICAgIGlmICghdXBkYXRlZClcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZCA9IHVwZGF0ZTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQuZmxhZ3MgfD0gY2hhbmdlZDtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMiAvKiBVcGRhdGVTdGF0ZS5VcGRhdGluZyAqLztcbiAgICAgICAgICAgICAgICBpZiAoIXVwZGF0ZS5lbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBsdWdpbnModXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUF0dHJzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlZHJhd24gPSB0aGlzLmRvY1ZpZXcudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVhc3VyaW5nLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAobWVhc3VyZWRbaV0gIT0gQmFkTWVhc3VyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbSA9IG1lYXN1cmluZ1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobS53cml0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbS53cml0ZShtZWFzdXJlZFtpXSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih0aGlzLnN0YXRlLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZWRyYXduKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY1ZpZXcudXBkYXRlU2VsZWN0aW9uKHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCAmJiB0aGlzLm1lYXN1cmVSZXF1ZXN0cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3U3RhdGUuZWRpdG9ySGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnNjcm9sbEludG9WaWV3KHRoaXMudmlld1N0YXRlLnNjcm9sbFRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3JIZWlnaHQgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdBbmNob3JIZWlnaHQgPSBzY3JvbGxBbmNob3JQb3MgPCAwID8gdGhpcy52aWV3U3RhdGUuaGVpZ2h0TWFwLmhlaWdodCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLmxpbmVCbG9ja0F0KHNjcm9sbEFuY2hvclBvcykudG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaWZmID0gbmV3QW5jaG9ySGVpZ2h0IC0gc2Nyb2xsQW5jaG9ySGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaWZmID4gMSB8fCBkaWZmIDwgLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9wID0gc2Nyb2xsVG9wICsgZGlmZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc0RPTS5zY3JvbGxUb3AgPSBzY3JvbGxUb3AgLyB0aGlzLnNjYWxlWTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovO1xuICAgICAgICAgICAgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZWQgJiYgIXVwZGF0ZWQuZW1wdHkpXG4gICAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLnN0YXRlLmZhY2V0KHVwZGF0ZUxpc3RlbmVyKSlcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcih1cGRhdGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBDU1MgY2xhc3NlcyBmb3IgdGhlIGN1cnJlbnRseSBhY3RpdmUgZWRpdG9yIHRoZW1lcy5cbiAgICAqL1xuICAgIGdldCB0aGVtZUNsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiBiYXNlVGhlbWVJRCArIFwiIFwiICtcbiAgICAgICAgICAgICh0aGlzLnN0YXRlLmZhY2V0KGRhcmtUaGVtZSkgPyBiYXNlRGFya0lEIDogYmFzZUxpZ2h0SUQpICsgXCIgXCIgK1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5mYWNldCh0aGVtZSk7XG4gICAgfVxuICAgIHVwZGF0ZUF0dHJzKCkge1xuICAgICAgICBsZXQgZWRpdG9yQXR0cnMgPSBhdHRyc0Zyb21GYWNldCh0aGlzLCBlZGl0b3JBdHRyaWJ1dGVzLCB7XG4gICAgICAgICAgICBjbGFzczogXCJjbS1lZGl0b3JcIiArICh0aGlzLmhhc0ZvY3VzID8gXCIgY20tZm9jdXNlZCBcIiA6IFwiIFwiKSArIHRoaXMudGhlbWVDbGFzc2VzXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgY29udGVudEF0dHJzID0ge1xuICAgICAgICAgICAgc3BlbGxjaGVjazogXCJmYWxzZVwiLFxuICAgICAgICAgICAgYXV0b2NvcnJlY3Q6IFwib2ZmXCIsXG4gICAgICAgICAgICBhdXRvY2FwaXRhbGl6ZTogXCJvZmZcIixcbiAgICAgICAgICAgIHRyYW5zbGF0ZTogXCJub1wiLFxuICAgICAgICAgICAgY29udGVudGVkaXRhYmxlOiAhdGhpcy5zdGF0ZS5mYWNldChlZGl0YWJsZSkgPyBcImZhbHNlXCIgOiBcInRydWVcIixcbiAgICAgICAgICAgIGNsYXNzOiBcImNtLWNvbnRlbnRcIixcbiAgICAgICAgICAgIHN0eWxlOiBgJHticm93c2VyLnRhYlNpemV9OiAke3RoaXMuc3RhdGUudGFiU2l6ZX1gLFxuICAgICAgICAgICAgcm9sZTogXCJ0ZXh0Ym94XCIsXG4gICAgICAgICAgICBcImFyaWEtbXVsdGlsaW5lXCI6IFwidHJ1ZVwiXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICAgICAgY29udGVudEF0dHJzW1wiYXJpYS1yZWFkb25seVwiXSA9IFwidHJ1ZVwiO1xuICAgICAgICBhdHRyc0Zyb21GYWNldCh0aGlzLCBjb250ZW50QXR0cmlidXRlcywgY29udGVudEF0dHJzKTtcbiAgICAgICAgbGV0IGNoYW5nZWQgPSB0aGlzLm9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICBsZXQgY2hhbmdlZENvbnRlbnQgPSB1cGRhdGVBdHRycyh0aGlzLmNvbnRlbnRET00sIHRoaXMuY29udGVudEF0dHJzLCBjb250ZW50QXR0cnMpO1xuICAgICAgICAgICAgbGV0IGNoYW5nZWRFZGl0b3IgPSB1cGRhdGVBdHRycyh0aGlzLmRvbSwgdGhpcy5lZGl0b3JBdHRycywgZWRpdG9yQXR0cnMpO1xuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZWRDb250ZW50IHx8IGNoYW5nZWRFZGl0b3I7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVkaXRvckF0dHJzID0gZWRpdG9yQXR0cnM7XG4gICAgICAgIHRoaXMuY29udGVudEF0dHJzID0gY29udGVudEF0dHJzO1xuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9XG4gICAgc2hvd0Fubm91bmNlbWVudHModHJzKSB7XG4gICAgICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IHRyIG9mIHRycylcbiAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKVxuICAgICAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoRWRpdG9yVmlldy5hbm5vdW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbm5vdW5jZURPTS50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkaXYgPSB0aGlzLmFubm91bmNlRE9NLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgICAgICAgICAgICAgICAgICBkaXYudGV4dENvbnRlbnQgPSBlZmZlY3QudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgIH1cbiAgICBtb3VudFN0eWxlcygpIHtcbiAgICAgICAgdGhpcy5zdHlsZU1vZHVsZXMgPSB0aGlzLnN0YXRlLmZhY2V0KHN0eWxlTW9kdWxlKTtcbiAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5zdGF0ZS5mYWNldChFZGl0b3JWaWV3LmNzcE5vbmNlKTtcbiAgICAgICAgU3R5bGVNb2R1bGUubW91bnQodGhpcy5yb290LCB0aGlzLnN0eWxlTW9kdWxlcy5jb25jYXQoYmFzZVRoZW1lJDEpLnJldmVyc2UoKSwgbm9uY2UgPyB7IG5vbmNlIH0gOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICByZWFkTWVhc3VyZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVN0YXRlID09IDIgLyogVXBkYXRlU3RhdGUuVXBkYXRpbmcgKi8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFkaW5nIHRoZSBlZGl0b3IgbGF5b3V0IGlzbid0IGFsbG93ZWQgZHVyaW5nIGFuIHVwZGF0ZVwiKTtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU3RhdGUgPT0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovICYmIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA+IC0xKVxuICAgICAgICAgICAgdGhpcy5tZWFzdXJlKGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgU2NoZWR1bGUgYSBsYXlvdXQgbWVhc3VyZW1lbnQsIG9wdGlvbmFsbHkgcHJvdmlkaW5nIGNhbGxiYWNrcyB0b1xuICAgIGRvIGN1c3RvbSBET00gbWVhc3VyaW5nIGZvbGxvd2VkIGJ5IGEgRE9NIHdyaXRlIHBoYXNlLiBVc2luZ1xuICAgIHRoaXMgaXMgcHJlZmVyYWJsZSByZWFkaW5nIERPTSBsYXlvdXQgZGlyZWN0bHkgZnJvbSwgZm9yXG4gICAgZXhhbXBsZSwgYW4gZXZlbnQgaGFuZGxlciwgYmVjYXVzZSBpdCdsbCBtYWtlIHN1cmUgbWVhc3VyaW5nIGFuZFxuICAgIGRyYXdpbmcgZG9uZSBieSBvdGhlciBjb21wb25lbnRzIGlzIHN5bmNocm9uaXplZCwgYXZvaWRpbmdcbiAgICB1bm5lY2Vzc2FyeSBET00gbGF5b3V0IGNvbXB1dGF0aW9ucy5cbiAgICAqL1xuICAgIHJlcXVlc3RNZWFzdXJlKHJlcXVlc3QpIHtcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZVNjaGVkdWxlZCA8IDApXG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSB0aGlzLndpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5tZWFzdXJlKCkpO1xuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWVhc3VyZVJlcXVlc3RzLmluZGV4T2YocmVxdWVzdCkgPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5rZXkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWVhc3VyZVJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1lYXN1cmVSZXF1ZXN0c1tpXS5rZXkgPT09IHJlcXVlc3Qua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lYXN1cmVSZXF1ZXN0c1tpXSA9IHJlcXVlc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVSZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdmFsdWUgb2YgYSBzcGVjaWZpYyBwbHVnaW4sIGlmIHByZXNlbnQuIE5vdGUgdGhhdFxuICAgIHBsdWdpbnMgdGhhdCBjcmFzaCBjYW4gYmUgZHJvcHBlZCBmcm9tIGEgdmlldywgc28gZXZlbiB3aGVuIHlvdVxuICAgIGtub3cgeW91IHJlZ2lzdGVyZWQgYSBnaXZlbiBwbHVnaW4sIGl0IGlzIHJlY29tbWVuZGVkIHRvIGNoZWNrXG4gICAgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIG1ldGhvZC5cbiAgICAqL1xuICAgIHBsdWdpbihwbHVnaW4pIHtcbiAgICAgICAgbGV0IGtub3duID0gdGhpcy5wbHVnaW5NYXAuZ2V0KHBsdWdpbik7XG4gICAgICAgIGlmIChrbm93biA9PT0gdW5kZWZpbmVkIHx8IGtub3duICYmIGtub3duLnNwZWMgIT0gcGx1Z2luKVxuICAgICAgICAgICAgdGhpcy5wbHVnaW5NYXAuc2V0KHBsdWdpbiwga25vd24gPSB0aGlzLnBsdWdpbnMuZmluZChwID0+IHAuc3BlYyA9PSBwbHVnaW4pIHx8IG51bGwpO1xuICAgICAgICByZXR1cm4ga25vd24gJiYga25vd24udXBkYXRlKHRoaXMpLnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgdG9wIHBvc2l0aW9uIG9mIHRoZSBkb2N1bWVudCwgaW4gc2NyZWVuIGNvb3JkaW5hdGVzLiBUaGlzXG4gICAgbWF5IGJlIG5lZ2F0aXZlIHdoZW4gdGhlIGVkaXRvciBpcyBzY3JvbGxlZCBkb3duLiBQb2ludHNcbiAgICBkaXJlY3RseSB0byB0aGUgdG9wIG9mIHRoZSBmaXJzdCBsaW5lLCBub3QgYWJvdmUgdGhlIHBhZGRpbmcuXG4gICAgKi9cbiAgICBnZXQgZG9jdW1lbnRUb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgdGhpcy52aWV3U3RhdGUucGFkZGluZ1RvcDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwb3J0cyB0aGUgcGFkZGluZyBhYm92ZSBhbmQgYmVsb3cgdGhlIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IGRvY3VtZW50UGFkZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHsgdG9wOiB0aGlzLnZpZXdTdGF0ZS5wYWRkaW5nVG9wLCBib3R0b206IHRoaXMudmlld1N0YXRlLnBhZGRpbmdCb3R0b20gfTtcbiAgICB9XG4gICAgLyoqXG4gICAgSWYgdGhlIGVkaXRvciBpcyB0cmFuc2Zvcm1lZCB3aXRoIENTUywgdGhpcyBwcm92aWRlcyB0aGUgc2NhbGVcbiAgICBhbG9uZyB0aGUgWCBheGlzLiBPdGhlcndpc2UsIGl0IHdpbGwganVzdCBiZSAxLiBOb3RlIHRoYXRcbiAgICB0cmFuc2Zvcm1zIG90aGVyIHRoYW4gdHJhbnNsYXRpb24gYW5kIHNjYWxpbmcgYXJlIG5vdCBzdXBwb3J0ZWQuXG4gICAgKi9cbiAgICBnZXQgc2NhbGVYKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuc2NhbGVYOyB9XG4gICAgLyoqXG4gICAgUHJvdmlkZSB0aGUgQ1NTIHRyYW5zZm9ybWVkIHNjYWxlIGFsb25nIHRoZSBZIGF4aXMuXG4gICAgKi9cbiAgICBnZXQgc2NhbGVZKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuc2NhbGVZOyB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgdGV4dCBsaW5lIG9yIGJsb2NrIHdpZGdldCBhdCB0aGUgZ2l2ZW4gdmVydGljYWxcbiAgICBwb3NpdGlvbiAod2hpY2ggaXMgaW50ZXJwcmV0ZWQgYXMgcmVsYXRpdmUgdG8gdGhlIFt0b3Agb2YgdGhlXG4gICAgZG9jdW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRvY3VtZW50VG9wKSkuXG4gICAgKi9cbiAgICBlbGVtZW50QXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS5lbGVtZW50QXRIZWlnaHQoaGVpZ2h0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgbGluZSBibG9jayAoc2VlXG4gICAgW2BsaW5lQmxvY2tBdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmxpbmVCbG9ja0F0KSBhdCB0aGUgZ2l2ZW5cbiAgICBoZWlnaHQsIGFnYWluIGludGVycHJldGVkIHJlbGF0aXZlIHRvIHRoZSBbdG9wIG9mIHRoZVxuICAgIGRvY3VtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kb2N1bWVudFRvcCkuXG4gICAgKi9cbiAgICBsaW5lQmxvY2tBdEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5yZWFkTWVhc3VyZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLmxpbmVCbG9ja0F0SGVpZ2h0KGhlaWdodCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZXh0ZW50IGFuZCB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiBhbGwgW2xpbmVcbiAgICBibG9ja3NdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmxpbmVCbG9ja0F0KSBpbiB0aGUgdmlld3BvcnQuIFBvc2l0aW9uc1xuICAgIGFyZSByZWxhdGl2ZSB0byB0aGUgW3RvcCBvZiB0aGVcbiAgICBkb2N1bWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZG9jdW1lbnRUb3ApO1xuICAgICovXG4gICAgZ2V0IHZpZXdwb3J0TGluZUJsb2NrcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLnZpZXdwb3J0TGluZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGxpbmUgYmxvY2sgYXJvdW5kIHRoZSBnaXZlbiBkb2N1bWVudCBwb3NpdGlvbi4gQSBsaW5lXG4gICAgYmxvY2sgaXMgYSByYW5nZSBkZWxpbWl0ZWQgb24gYm90aCBzaWRlcyBieSBlaXRoZXIgYVxuICAgIG5vbi1baGlkZGVuXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvbl5yZXBsYWNlKSBsaW5lIGJyZWFrcywgb3IgdGhlXG4gICAgc3RhcnQvZW5kIG9mIHRoZSBkb2N1bWVudC4gSXQgd2lsbCB1c3VhbGx5IGp1c3QgaG9sZCBhIGxpbmUgb2ZcbiAgICB0ZXh0LCBidXQgbWF5IGJlIGJyb2tlbiBpbnRvIG11bHRpcGxlIHRleHRibG9ja3MgYnkgYmxvY2tcbiAgICB3aWRnZXRzLlxuICAgICovXG4gICAgbGluZUJsb2NrQXQocG9zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS5saW5lQmxvY2tBdChwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZWRpdG9yJ3MgdG90YWwgY29udGVudCBoZWlnaHQuXG4gICAgKi9cbiAgICBnZXQgY29udGVudEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLmNvbnRlbnRIZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgYSBjdXJzb3IgcG9zaXRpb24gYnkgW2dyYXBoZW1lXG4gICAgY2x1c3Rlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5maW5kQ2x1c3RlckJyZWFrKS4gYGZvcndhcmRgIGRldGVybWluZXMgd2hldGhlclxuICAgIHRoZSBtb3Rpb24gaXMgYXdheSBmcm9tIHRoZSBsaW5lIHN0YXJ0LCBvciB0b3dhcmRzIGl0LiBJblxuICAgIGJpZGlyZWN0aW9uYWwgdGV4dCwgdGhlIGxpbmUgaXMgdHJhdmVyc2VkIGluIHZpc3VhbCBvcmRlciwgdXNpbmdcbiAgICB0aGUgZWRpdG9yJ3MgW3RleHQgZGlyZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy50ZXh0RGlyZWN0aW9uKS5cbiAgICBXaGVuIHRoZSBzdGFydCBwb3NpdGlvbiB3YXMgdGhlIGxhc3Qgb25lIG9uIHRoZSBsaW5lLCB0aGVcbiAgICByZXR1cm5lZCBwb3NpdGlvbiB3aWxsIGJlIGFjcm9zcyB0aGUgbGluZSBicmVhay4gSWYgdGhlcmUgaXMgbm9cbiAgICBmdXJ0aGVyIGxpbmUsIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiBpcyByZXR1cm5lZC5cbiAgICBcbiAgICBCeSBkZWZhdWx0LCB0aGlzIG1ldGhvZCBtb3ZlcyBvdmVyIGEgc2luZ2xlIGNsdXN0ZXIuIFRoZVxuICAgIG9wdGlvbmFsIGBieWAgYXJndW1lbnQgY2FuIGJlIHVzZWQgdG8gbW92ZSBhY3Jvc3MgbW9yZS4gSXQgd2lsbFxuICAgIGJlIGNhbGxlZCB3aXRoIHRoZSBmaXJzdCBjbHVzdGVyIGFzIGFyZ3VtZW50LCBhbmQgc2hvdWxkIHJldHVyblxuICAgIGEgcHJlZGljYXRlIHRoYXQgZGV0ZXJtaW5lcywgZm9yIGVhY2ggc3Vic2VxdWVudCBjbHVzdGVyLFxuICAgIHdoZXRoZXIgaXQgc2hvdWxkIGFsc28gYmUgbW92ZWQgb3Zlci5cbiAgICAqL1xuICAgIG1vdmVCeUNoYXIoc3RhcnQsIGZvcndhcmQsIGJ5KSB7XG4gICAgICAgIHJldHVybiBza2lwQXRvbXModGhpcywgc3RhcnQsIG1vdmVCeUNoYXIodGhpcywgc3RhcnQsIGZvcndhcmQsIGJ5KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgYSBjdXJzb3IgcG9zaXRpb24gYWNyb3NzIHRoZSBuZXh0IGdyb3VwIG9mIGVpdGhlclxuICAgIFtsZXR0ZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYXJDYXRlZ29yaXplcikgb3Igbm9uLWxldHRlclxuICAgIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXG4gICAgKi9cbiAgICBtb3ZlQnlHcm91cChzdGFydCwgZm9yd2FyZCkge1xuICAgICAgICByZXR1cm4gc2tpcEF0b21zKHRoaXMsIHN0YXJ0LCBtb3ZlQnlDaGFyKHRoaXMsIHN0YXJ0LCBmb3J3YXJkLCBpbml0aWFsID0+IGJ5R3JvdXAodGhpcywgc3RhcnQuaGVhZCwgaW5pdGlhbCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjdXJzb3IgcG9zaXRpb24gdmlzdWFsbHkgYXQgdGhlIHN0YXJ0IG9yIGVuZCBvZiBhIGxpbmUuXG4gICAgTm90ZSB0aGF0IHRoaXMgbWF5IGRpZmZlciBmcm9tIHRoZSBfbG9naWNhbF8gcG9zaXRpb24gYXQgaXRzXG4gICAgc3RhcnQgb3IgZW5kICh3aGljaCBpcyBzaW1wbHkgYXQgYGxpbmUuZnJvbWAvYGxpbmUudG9gKSBpZiB0ZXh0XG4gICAgYXQgdGhlIHN0YXJ0IG9yIGVuZCBnb2VzIGFnYWluc3QgdGhlIGxpbmUncyBiYXNlIHRleHQgZGlyZWN0aW9uLlxuICAgICovXG4gICAgdmlzdWFsTGluZVNpZGUobGluZSwgZW5kKSB7XG4gICAgICAgIGxldCBvcmRlciA9IHRoaXMuYmlkaVNwYW5zKGxpbmUpLCBkaXIgPSB0aGlzLnRleHREaXJlY3Rpb25BdChsaW5lLmZyb20pO1xuICAgICAgICBsZXQgc3BhbiA9IG9yZGVyW2VuZCA/IG9yZGVyLmxlbmd0aCAtIDEgOiAwXTtcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3Ioc3Bhbi5zaWRlKGVuZCwgZGlyKSArIGxpbmUuZnJvbSwgc3Bhbi5mb3J3YXJkKCFlbmQsIGRpcikgPyAxIDogLTEpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBuZXh0IGxpbmUgYm91bmRhcnkgaW4gdGhlIGdpdmVuIGRpcmVjdGlvbi4gSWZcbiAgICBgaW5jbHVkZVdyYXBgIGlzIHRydWUsIGxpbmUgd3JhcHBpbmcgaXMgb24sIGFuZCB0aGVyZSBpcyBhXG4gICAgZnVydGhlciB3cmFwIHBvaW50IG9uIHRoZSBjdXJyZW50IGxpbmUsIHRoZSB3cmFwIHBvaW50IHdpbGwgYmVcbiAgICByZXR1cm5lZC4gT3RoZXJ3aXNlIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHN0YXJ0IG9yIGVuZFxuICAgIG9mIHRoZSBsaW5lLlxuICAgICovXG4gICAgbW92ZVRvTGluZUJvdW5kYXJ5KHN0YXJ0LCBmb3J3YXJkLCBpbmNsdWRlV3JhcCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIG1vdmVUb0xpbmVCb3VuZGFyeSh0aGlzLCBzdGFydCwgZm9yd2FyZCwgaW5jbHVkZVdyYXApO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIGEgY3Vyc29yIHBvc2l0aW9uIHZlcnRpY2FsbHkuIFdoZW4gYGRpc3RhbmNlYCBpc24ndCBnaXZlbixcbiAgICBpdCBkZWZhdWx0cyB0byBtb3ZpbmcgdG8gdGhlIG5leHQgbGluZSAoaW5jbHVkaW5nIHdyYXBwZWRcbiAgICBsaW5lcykuIE90aGVyd2lzZSwgYGRpc3RhbmNlYCBzaG91bGQgcHJvdmlkZSBhIHBvc2l0aXZlIGRpc3RhbmNlXG4gICAgaW4gcGl4ZWxzLlxuICAgIFxuICAgIFdoZW4gYHN0YXJ0YCBoYXMgYVxuICAgIFtgZ29hbENvbHVtbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU2VsZWN0aW9uUmFuZ2UuZ29hbENvbHVtbiksIHRoZSB2ZXJ0aWNhbFxuICAgIG1vdGlvbiB3aWxsIHVzZSB0aGF0IGFzIGEgdGFyZ2V0IGhvcml6b250YWwgcG9zaXRpb24uIE90aGVyd2lzZSxcbiAgICB0aGUgY3Vyc29yJ3Mgb3duIGhvcml6b250YWwgcG9zaXRpb24gaXMgdXNlZC4gVGhlIHJldHVybmVkXG4gICAgY3Vyc29yIHdpbGwgaGF2ZSBpdHMgZ29hbCBjb2x1bW4gc2V0IHRvIHdoaWNoZXZlciBjb2x1bW4gd2FzXG4gICAgdXNlZC5cbiAgICAqL1xuICAgIG1vdmVWZXJ0aWNhbGx5KHN0YXJ0LCBmb3J3YXJkLCBkaXN0YW5jZSkge1xuICAgICAgICByZXR1cm4gc2tpcEF0b21zKHRoaXMsIHN0YXJ0LCBtb3ZlVmVydGljYWxseSh0aGlzLCBzdGFydCwgZm9yd2FyZCwgZGlzdGFuY2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgRE9NIHBhcmVudCBub2RlIGFuZCBvZmZzZXQgKGNoaWxkIG9mZnNldCBpZiBgbm9kZWAgaXNcbiAgICBhbiBlbGVtZW50LCBjaGFyYWN0ZXIgb2Zmc2V0IHdoZW4gaXQgaXMgYSB0ZXh0IG5vZGUpIGF0IHRoZVxuICAgIGdpdmVuIGRvY3VtZW50IHBvc2l0aW9uLlxuICAgIFxuICAgIE5vdGUgdGhhdCBmb3IgcG9zaXRpb25zIHRoYXQgYXJlbid0IGN1cnJlbnRseSBpblxuICAgIGB2aXNpYmxlUmFuZ2VzYCwgdGhlIHJlc3VsdGluZyBET00gcG9zaXRpb24gaXNuJ3QgbmVjZXNzYXJpbHlcbiAgICBtZWFuaW5nZnVsIChpdCBtYXkganVzdCBwb2ludCBiZWZvcmUgb3IgYWZ0ZXIgYSBwbGFjZWhvbGRlclxuICAgIGVsZW1lbnQpLlxuICAgICovXG4gICAgZG9tQXRQb3MocG9zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcuZG9tQXRQb3MocG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgZG9jdW1lbnQgcG9zaXRpb24gYXQgdGhlIGdpdmVuIERPTSBub2RlLiBDYW4gYmUgdXNlZnVsXG4gICAgZm9yIGFzc29jaWF0aW5nIHBvc2l0aW9ucyB3aXRoIERPTSBldmVudHMuIFdpbGwgcmFpc2UgYW4gZXJyb3JcbiAgICB3aGVuIGBub2RlYCBpc24ndCBwYXJ0IG9mIHRoZSBlZGl0b3IgY29udGVudC5cbiAgICAqL1xuICAgIHBvc0F0RE9NKG5vZGUsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldy5wb3NGcm9tRE9NKG5vZGUsIG9mZnNldCk7XG4gICAgfVxuICAgIHBvc0F0Q29vcmRzKGNvb3JkcywgcHJlY2lzZSA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5yZWFkTWVhc3VyZWQoKTtcbiAgICAgICAgcmV0dXJuIHBvc0F0Q29vcmRzKHRoaXMsIGNvb3JkcywgcHJlY2lzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgc2NyZWVuIGNvb3JkaW5hdGVzIGF0IHRoZSBnaXZlbiBkb2N1bWVudCBwb3NpdGlvbi5cbiAgICBgc2lkZWAgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjb29yZGluYXRlcyBhcmUgYmFzZWQgb24gdGhlXG4gICAgZWxlbWVudCBiZWZvcmUgKC0xKSBvciBhZnRlciAoMSkgdGhlIHBvc2l0aW9uIChpZiBubyBlbGVtZW50IGlzXG4gICAgYXZhaWxhYmxlIG9uIHRoZSBnaXZlbiBzaWRlLCB0aGUgbWV0aG9kIHdpbGwgdHJhbnNwYXJlbnRseSB1c2VcbiAgICBhbm90aGVyIHN0cmF0ZWd5IHRvIGdldCByZWFzb25hYmxlIGNvb3JkaW5hdGVzKS5cbiAgICAqL1xuICAgIGNvb3Jkc0F0UG9zKHBvcywgc2lkZSA9IDEpIHtcbiAgICAgICAgdGhpcy5yZWFkTWVhc3VyZWQoKTtcbiAgICAgICAgbGV0IHJlY3QgPSB0aGlzLmRvY1ZpZXcuY29vcmRzQXQocG9zLCBzaWRlKTtcbiAgICAgICAgaWYgKCFyZWN0IHx8IHJlY3QubGVmdCA9PSByZWN0LnJpZ2h0KVxuICAgICAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5zdGF0ZS5kb2MubGluZUF0KHBvcyksIG9yZGVyID0gdGhpcy5iaWRpU3BhbnMobGluZSk7XG4gICAgICAgIGxldCBzcGFuID0gb3JkZXJbQmlkaVNwYW4uZmluZChvcmRlciwgcG9zIC0gbGluZS5mcm9tLCAtMSwgc2lkZSldO1xuICAgICAgICByZXR1cm4gZmxhdHRlblJlY3QocmVjdCwgKHNwYW4uZGlyID09IERpcmVjdGlvbi5MVFIpID09IChzaWRlID4gMCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gdGhlIHJlY3RhbmdsZSBhcm91bmQgYSBnaXZlbiBjaGFyYWN0ZXIuIElmIGBwb3NgIGRvZXMgbm90XG4gICAgcG9pbnQgaW4gZnJvbnQgb2YgYSBjaGFyYWN0ZXIgdGhhdCBpcyBpbiB0aGUgdmlld3BvcnQgYW5kXG4gICAgcmVuZGVyZWQgKGkuZS4gbm90IHJlcGxhY2VkLCBub3QgYSBsaW5lIGJyZWFrKSwgdGhpcyB3aWxsIHJldHVyblxuICAgIG51bGwuIEZvciBzcGFjZSBjaGFyYWN0ZXJzIHRoYXQgYXJlIGEgbGluZSB3cmFwIHBvaW50LCB0aGlzIHdpbGxcbiAgICByZXR1cm4gdGhlIHBvc2l0aW9uIGJlZm9yZSB0aGUgbGluZSBicmVhay5cbiAgICAqL1xuICAgIGNvb3Jkc0ZvckNoYXIocG9zKSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcuY29vcmRzRm9yQ2hhcihwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZGVmYXVsdCB3aWR0aCBvZiBhIGNoYXJhY3RlciBpbiB0aGUgZWRpdG9yLiBNYXkgbm90XG4gICAgYWNjdXJhdGVseSByZWZsZWN0IHRoZSB3aWR0aCBvZiBhbGwgY2hhcmFjdGVycyAoZ2l2ZW4gdmFyaWFibGVcbiAgICB3aWR0aCBmb250cyBvciBzdHlsaW5nIG9mIGludmlkaWR1YWwgcmFuZ2VzKS5cbiAgICAqL1xuICAgIGdldCBkZWZhdWx0Q2hhcmFjdGVyV2lkdGgoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUuY2hhcldpZHRoOyB9XG4gICAgLyoqXG4gICAgVGhlIGRlZmF1bHQgaGVpZ2h0IG9mIGEgbGluZSBpbiB0aGUgZWRpdG9yLiBNYXkgbm90IGJlIGFjY3VyYXRlXG4gICAgZm9yIGFsbCBsaW5lcy5cbiAgICAqL1xuICAgIGdldCBkZWZhdWx0TGluZUhlaWdodCgpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLmhlaWdodE9yYWNsZS5saW5lSGVpZ2h0OyB9XG4gICAgLyoqXG4gICAgVGhlIHRleHQgZGlyZWN0aW9uXG4gICAgKFtgZGlyZWN0aW9uYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2RpcmVjdGlvbilcbiAgICBDU1MgcHJvcGVydHkpIG9mIHRoZSBlZGl0b3IncyBjb250ZW50IGVsZW1lbnQuXG4gICAgKi9cbiAgICBnZXQgdGV4dERpcmVjdGlvbigpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLmRlZmF1bHRUZXh0RGlyZWN0aW9uOyB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgdGV4dCBkaXJlY3Rpb24gb2YgdGhlIGJsb2NrIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiwgYXNcbiAgICBhc3NpZ25lZCBieSBDU1MuIElmXG4gICAgW2BwZXJMaW5lVGV4dERpcmVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XnBlckxpbmVUZXh0RGlyZWN0aW9uKVxuICAgIGlzbid0IGVuYWJsZWQsIG9yIHRoZSBnaXZlbiBwb3NpdGlvbiBpcyBvdXRzaWRlIG9mIHRoZSB2aWV3cG9ydCxcbiAgICB0aGlzIHdpbGwgYWx3YXlzIHJldHVybiB0aGUgc2FtZSBhc1xuICAgIFtgdGV4dERpcmVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnRleHREaXJlY3Rpb24pLiBOb3RlIHRoYXRcbiAgICB0aGlzIG1heSB0cmlnZ2VyIGEgRE9NIGxheW91dC5cbiAgICAqL1xuICAgIHRleHREaXJlY3Rpb25BdChwb3MpIHtcbiAgICAgICAgbGV0IHBlckxpbmUgPSB0aGlzLnN0YXRlLmZhY2V0KHBlckxpbmVUZXh0RGlyZWN0aW9uKTtcbiAgICAgICAgaWYgKCFwZXJMaW5lIHx8IHBvcyA8IHRoaXMudmlld3BvcnQuZnJvbSB8fCBwb3MgPiB0aGlzLnZpZXdwb3J0LnRvKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dERpcmVjdGlvbjtcbiAgICAgICAgdGhpcy5yZWFkTWVhc3VyZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldy50ZXh0RGlyZWN0aW9uQXQocG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGlzIGVkaXRvciBbd3JhcHMgbGluZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmxpbmVXcmFwcGluZylcbiAgICAoYXMgZGV0ZXJtaW5lZCBieSB0aGVcbiAgICBbYHdoaXRlLXNwYWNlYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3doaXRlLXNwYWNlKVxuICAgIENTUyBwcm9wZXJ0eSBvZiBpdHMgY29udGVudCBlbGVtZW50KS5cbiAgICAqL1xuICAgIGdldCBsaW5lV3JhcHBpbmcoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUubGluZVdyYXBwaW5nOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGUgYmlkaXJlY3Rpb25hbCB0ZXh0IHN0cnVjdHVyZSBvZiB0aGUgZ2l2ZW4gbGluZVxuICAgICh3aGljaCBzaG91bGQgYmUgaW4gdGhlIGN1cnJlbnQgZG9jdW1lbnQpIGFzIGFuIGFycmF5IG9mIHNwYW5cbiAgICBvYmplY3RzLiBUaGUgb3JkZXIgb2YgdGhlc2Ugc3BhbnMgbWF0Y2hlcyB0aGUgW3RleHRcbiAgICBkaXJlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnRleHREaXJlY3Rpb24p4oCUaWYgdGhhdCBpc1xuICAgIGxlZnQtdG8tcmlnaHQsIHRoZSBsZWZ0bW9zdCBzcGFucyBjb21lIGZpcnN0LCBvdGhlcndpc2UgdGhlXG4gICAgcmlnaHRtb3N0IHNwYW5zIGNvbWUgZmlyc3QuXG4gICAgKi9cbiAgICBiaWRpU3BhbnMobGluZSkge1xuICAgICAgICBpZiAobGluZS5sZW5ndGggPiBNYXhCaWRpTGluZSlcbiAgICAgICAgICAgIHJldHVybiB0cml2aWFsT3JkZXIobGluZS5sZW5ndGgpO1xuICAgICAgICBsZXQgZGlyID0gdGhpcy50ZXh0RGlyZWN0aW9uQXQobGluZS5mcm9tKSwgaXNvbGF0ZXM7XG4gICAgICAgIGZvciAobGV0IGVudHJ5IG9mIHRoaXMuYmlkaUNhY2hlKSB7XG4gICAgICAgICAgICBpZiAoZW50cnkuZnJvbSA9PSBsaW5lLmZyb20gJiYgZW50cnkuZGlyID09IGRpciAmJlxuICAgICAgICAgICAgICAgIChlbnRyeS5mcmVzaCB8fCBpc29sYXRlc0VxKGVudHJ5Lmlzb2xhdGVzLCBpc29sYXRlcyA9IGdldElzb2xhdGVkUmFuZ2VzKHRoaXMsIGxpbmUpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5Lm9yZGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNvbGF0ZXMpXG4gICAgICAgICAgICBpc29sYXRlcyA9IGdldElzb2xhdGVkUmFuZ2VzKHRoaXMsIGxpbmUpO1xuICAgICAgICBsZXQgb3JkZXIgPSBjb21wdXRlT3JkZXIobGluZS50ZXh0LCBkaXIsIGlzb2xhdGVzKTtcbiAgICAgICAgdGhpcy5iaWRpQ2FjaGUucHVzaChuZXcgQ2FjaGVkT3JkZXIobGluZS5mcm9tLCBsaW5lLnRvLCBkaXIsIGlzb2xhdGVzLCB0cnVlLCBvcmRlcikpO1xuICAgICAgICByZXR1cm4gb3JkZXI7XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIHdoZXRoZXIgdGhlIGVkaXRvciBoYXMgZm9jdXMuXG4gICAgKi9cbiAgICBnZXQgaGFzRm9jdXMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gU2FmYXJpIHJldHVybiBmYWxzZSBmb3IgaGFzRm9jdXMgd2hlbiB0aGUgY29udGV4dCBtZW51IGlzIG9wZW5cbiAgICAgICAgLy8gb3IgY2xvc2luZywgd2hpY2ggbGVhZHMgdXMgdG8gaWdub3JlIHNlbGVjdGlvbiBjaGFuZ2VzIGZyb20gdGhlXG4gICAgICAgIC8vIGNvbnRleHQgbWVudSBiZWNhdXNlIGl0IGxvb2tzIGxpa2UgdGhlIGVkaXRvciBpc24ndCBmb2N1c2VkLlxuICAgICAgICAvLyBUaGlzIGtsdWRnZXMgYXJvdW5kIHRoYXQuXG4gICAgICAgIHJldHVybiAodGhpcy5kb20ub3duZXJEb2N1bWVudC5oYXNGb2N1cygpIHx8IGJyb3dzZXIuc2FmYXJpICYmICgoX2EgPSB0aGlzLmlucHV0U3RhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYXN0Q29udGV4dE1lbnUpID4gRGF0ZS5ub3coKSAtIDNlNCkgJiZcbiAgICAgICAgICAgIHRoaXMucm9vdC5hY3RpdmVFbGVtZW50ID09IHRoaXMuY29udGVudERPTTtcbiAgICB9XG4gICAgLyoqXG4gICAgUHV0IGZvY3VzIG9uIHRoZSBlZGl0b3IuXG4gICAgKi9cbiAgICBmb2N1cygpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5pZ25vcmUoKCkgPT4ge1xuICAgICAgICAgICAgZm9jdXNQcmV2ZW50U2Nyb2xsKHRoaXMuY29udGVudERPTSk7XG4gICAgICAgICAgICB0aGlzLmRvY1ZpZXcudXBkYXRlU2VsZWN0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIFtyb290XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvIyN2aWV3LkVkaXRvclZpZXdDb25maWcucm9vdCkgaW4gd2hpY2ggdGhlIGVkaXRvciBsaXZlcy4gVGhpcyBpcyBvbmx5XG4gICAgbmVjZXNzYXJ5IHdoZW4gbW92aW5nIHRoZSBlZGl0b3IncyBleGlzdGluZyBET00gdG8gYSBuZXcgd2luZG93IG9yIHNoYWRvdyByb290LlxuICAgICovXG4gICAgc2V0Um9vdChyb290KSB7XG4gICAgICAgIGlmICh0aGlzLl9yb290ICE9IHJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSByb290O1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5zZXRXaW5kb3coKHJvb3Qubm9kZVR5cGUgPT0gOSA/IHJvb3QgOiByb290Lm93bmVyRG9jdW1lbnQpLmRlZmF1bHRWaWV3IHx8IHdpbmRvdyk7XG4gICAgICAgICAgICB0aGlzLm1vdW50U3R5bGVzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ2xlYW4gdXAgdGhpcyBlZGl0b3IgdmlldywgcmVtb3ZpbmcgaXRzIGVsZW1lbnQgZnJvbSB0aGVcbiAgICBkb2N1bWVudCwgdW5yZWdpc3RlcmluZyBldmVudCBoYW5kbGVycywgYW5kIG5vdGlmeWluZ1xuICAgIHBsdWdpbnMuIFRoZSB2aWV3IGluc3RhbmNlIGNhbiBubyBsb25nZXIgYmUgdXNlZCBhZnRlclxuICAgIGNhbGxpbmcgdGhpcy5cbiAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICBwbHVnaW4uZGVzdHJveSh0aGlzKTtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gW107XG4gICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZG9jVmlldy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLm9ic2VydmVyLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZVNjaGVkdWxlZCA+IC0xKVxuICAgICAgICAgICAgdGhpcy53aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5tZWFzdXJlU2NoZWR1bGVkKTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGFuIGVmZmVjdCB0aGF0IGNhbiBiZVxuICAgIFthZGRlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZWZmZWN0cykgdG8gYSB0cmFuc2FjdGlvbiB0b1xuICAgIGNhdXNlIGl0IHRvIHNjcm9sbCB0aGUgZ2l2ZW4gcG9zaXRpb24gb3IgcmFuZ2UgaW50byB2aWV3LlxuICAgICovXG4gICAgc3RhdGljIHNjcm9sbEludG9WaWV3KHBvcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBzY3JvbGxJbnRvVmlldy5vZihuZXcgU2Nyb2xsVGFyZ2V0KHR5cGVvZiBwb3MgPT0gXCJudW1iZXJcIiA/IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zKSA6IHBvcywgb3B0aW9ucy55LCBvcHRpb25zLngsIG9wdGlvbnMueU1hcmdpbiwgb3B0aW9ucy54TWFyZ2luKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhbiBlZmZlY3QgdGhhdCByZXNldHMgdGhlIGVkaXRvciB0byBpdHMgY3VycmVudCAoYXQgdGhlXG4gICAgdGltZSB0aGlzIG1ldGhvZCB3YXMgY2FsbGVkKSBzY3JvbGwgcG9zaXRpb24uIE5vdGUgdGhhdCB0aGlzXG4gICAgb25seSBhZmZlY3RzIHRoZSBlZGl0b3IncyBvd24gc2Nyb2xsYWJsZSBlbGVtZW50LCBub3QgcGFyZW50cy5cbiAgICBTZWUgYWxzb1xuICAgIFtgRWRpdG9yVmlld0NvbmZpZy5zY3JvbGxUb2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3Q29uZmlnLnNjcm9sbFRvKS5cbiAgICBcbiAgICBUaGUgZWZmZWN0IHNob3VsZCBiZSB1c2VkIHdpdGggYSBkb2N1bWVudCBpZGVudGljYWwgdG8gdGhlIG9uZVxuICAgIGl0IHdhcyBjcmVhdGVkIGZvci4gRmFpbGluZyB0byBkbyBzbyBpcyBub3QgYW4gZXJyb3IsIGJ1dCBtYXlcbiAgICBub3Qgc2Nyb2xsIHRvIHRoZSBleHBlY3RlZCBwb3NpdGlvbi4gWW91IGNhblxuICAgIFttYXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3QubWFwKSB0aGUgZWZmZWN0IHRvIGFjY291bnQgZm9yIGNoYW5nZXMuXG4gICAgKi9cbiAgICBzY3JvbGxTbmFwc2hvdCgpIHtcbiAgICAgICAgbGV0IHsgc2Nyb2xsVG9wLCBzY3JvbGxMZWZ0IH0gPSB0aGlzLnNjcm9sbERPTTtcbiAgICAgICAgbGV0IHJlZiA9IHRoaXMudmlld1N0YXRlLnNjcm9sbEFuY2hvckF0KHNjcm9sbFRvcCk7XG4gICAgICAgIHJldHVybiBzY3JvbGxJbnRvVmlldy5vZihuZXcgU2Nyb2xsVGFyZ2V0KEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmVmLmZyb20pLCBcInN0YXJ0XCIsIFwic3RhcnRcIiwgcmVmLnRvcCAtIHNjcm9sbFRvcCwgc2Nyb2xsTGVmdCwgdHJ1ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGFkZCBET00gZXZlbnQgaGFuZGxlcnMuXG4gICAgVGhlIHZhbHVlIHNob3VsZCBiZSBhbiBvYmplY3QgbWFwcGluZyBldmVudCBuYW1lcyB0byBoYW5kbGVyXG4gICAgZnVuY3Rpb25zLiBGb3IgYW55IGdpdmVuIGV2ZW50LCBzdWNoIGZ1bmN0aW9ucyBhcmUgb3JkZXJlZCBieVxuICAgIGV4dGVuc2lvbiBwcmVjZWRlbmNlLCBhbmQgdGhlIGZpcnN0IGhhbmRsZXIgdG8gcmV0dXJuIHRydWUgd2lsbFxuICAgIGJlIGFzc3VtZWQgdG8gaGF2ZSBoYW5kbGVkIHRoYXQgZXZlbnQsIGFuZCBubyBvdGhlciBoYW5kbGVycyBvclxuICAgIGJ1aWx0LWluIGJlaGF2aW9yIHdpbGwgYmUgYWN0aXZhdGVkIGZvciBpdC4gVGhlc2UgYXJlIHJlZ2lzdGVyZWRcbiAgICBvbiB0aGUgW2NvbnRlbnQgZWxlbWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuY29udGVudERPTSksIGV4Y2VwdFxuICAgIGZvciBgc2Nyb2xsYCBoYW5kbGVycywgd2hpY2ggd2lsbCBiZSBjYWxsZWQgYW55IHRpbWUgdGhlXG4gICAgZWRpdG9yJ3MgW3Njcm9sbCBlbGVtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5zY3JvbGxET00pIG9yIG9uZSBvZlxuICAgIGl0cyBwYXJlbnQgbm9kZXMgaXMgc2Nyb2xsZWQuXG4gICAgKi9cbiAgICBzdGF0aWMgZG9tRXZlbnRIYW5kbGVycyhoYW5kbGVycykge1xuICAgICAgICByZXR1cm4gVmlld1BsdWdpbi5kZWZpbmUoKCkgPT4gKHt9KSwgeyBldmVudEhhbmRsZXJzOiBoYW5kbGVycyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IHJlZ2lzdGVycyBET00gZXZlbnQgb2JzZXJ2ZXJzLiBDb250cmFyeVxuICAgIHRvIGV2ZW50IFtoYW5kbGVyc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeZG9tRXZlbnRIYW5kbGVycyksXG4gICAgb2JzZXJ2ZXJzIGNhbid0IGJlIHByZXZlbnRlZCBmcm9tIHJ1bm5pbmcgYnkgYSBoaWdoZXItcHJlY2VkZW5jZVxuICAgIGhhbmRsZXIgcmV0dXJuaW5nIHRydWUuIFRoZXkgYWxzbyBkb24ndCBwcmV2ZW50IG90aGVyIGhhbmRsZXJzXG4gICAgYW5kIG9ic2VydmVycyBmcm9tIHJ1bm5pbmcgd2hlbiB0aGV5IHJldHVybiB0cnVlLCBhbmQgc2hvdWxkIG5vdFxuICAgIGNhbGwgYHByZXZlbnREZWZhdWx0YC5cbiAgICAqL1xuICAgIHN0YXRpYyBkb21FdmVudE9ic2VydmVycyhvYnNlcnZlcnMpIHtcbiAgICAgICAgcmV0dXJuIFZpZXdQbHVnaW4uZGVmaW5lKCgpID0+ICh7fSksIHsgZXZlbnRPYnNlcnZlcnM6IG9ic2VydmVycyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdGhlbWUgZXh0ZW5zaW9uLiBUaGUgZmlyc3QgYXJndW1lbnQgY2FuIGJlIGFcbiAgICBbYHN0eWxlLW1vZGBdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL3N0eWxlLW1vZCNkb2N1bWVudGF0aW9uKVxuICAgIHN0eWxlIHNwZWMgcHJvdmlkaW5nIHRoZSBzdHlsZXMgZm9yIHRoZSB0aGVtZS4gVGhlc2Ugd2lsbCBiZVxuICAgIHByZWZpeGVkIHdpdGggYSBnZW5lcmF0ZWQgY2xhc3MgZm9yIHRoZSBzdHlsZS5cbiAgICBcbiAgICBCZWNhdXNlIHRoZSBzZWxlY3RvcnMgd2lsbCBiZSBwcmVmaXhlZCB3aXRoIGEgc2NvcGUgY2xhc3MsIHJ1bGVcbiAgICB0aGF0IGRpcmVjdGx5IG1hdGNoIHRoZSBlZGl0b3IncyBbd3JhcHBlclxuICAgIGVsZW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRvbSnigJR0byB3aGljaCB0aGUgc2NvcGUgY2xhc3Mgd2lsbCBiZVxuICAgIGFkZGVk4oCUbmVlZCB0byBiZSBleHBsaWNpdGx5IGRpZmZlcmVudGlhdGVkIGJ5IGFkZGluZyBhbiBgJmAgdG9cbiAgICB0aGUgc2VsZWN0b3IgZm9yIHRoYXQgZWxlbWVudOKAlGZvciBleGFtcGxlXG4gICAgYCYuY20tZm9jdXNlZGAuXG4gICAgXG4gICAgV2hlbiBgZGFya2AgaXMgc2V0IHRvIHRydWUsIHRoZSB0aGVtZSB3aWxsIGJlIG1hcmtlZCBhcyBkYXJrLFxuICAgIHdoaWNoIHdpbGwgY2F1c2UgdGhlIGAmZGFya2AgcnVsZXMgZnJvbSBbYmFzZVxuICAgIHRoZW1lc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeYmFzZVRoZW1lKSB0byBiZSB1c2VkIChhcyBvcHBvc2VkIHRvXG4gICAgYCZsaWdodGAgd2hlbiBhIGxpZ2h0IHRoZW1lIGlzIGFjdGl2ZSkuXG4gICAgKi9cbiAgICBzdGF0aWMgdGhlbWUoc3BlYywgb3B0aW9ucykge1xuICAgICAgICBsZXQgcHJlZml4ID0gU3R5bGVNb2R1bGUubmV3TmFtZSgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW3RoZW1lLm9mKHByZWZpeCksIHN0eWxlTW9kdWxlLm9mKGJ1aWxkVGhlbWUoYC4ke3ByZWZpeH1gLCBzcGVjKSldO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRhcmspXG4gICAgICAgICAgICByZXN1bHQucHVzaChkYXJrVGhlbWUub2YodHJ1ZSkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgYWRkcyBzdHlsZXMgdG8gdGhlIGJhc2UgdGhlbWUuIExpa2VcbiAgICB3aXRoIFtgdGhlbWVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld150aGVtZSksIHVzZSBgJmAgdG8gaW5kaWNhdGUgdGhlXG4gICAgcGxhY2Ugb2YgdGhlIGVkaXRvciB3cmFwcGVyIGVsZW1lbnQgd2hlbiBkaXJlY3RseSB0YXJnZXRpbmdcbiAgICB0aGF0LiBZb3UgY2FuIGFsc28gdXNlIGAmZGFya2Agb3IgYCZsaWdodGAgaW5zdGVhZCB0byBvbmx5XG4gICAgdGFyZ2V0IGVkaXRvcnMgd2l0aCBhIGRhcmsgb3IgbGlnaHQgdGhlbWUuXG4gICAgKi9cbiAgICBzdGF0aWMgYmFzZVRoZW1lKHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIFByZWMubG93ZXN0KHN0eWxlTW9kdWxlLm9mKGJ1aWxkVGhlbWUoXCIuXCIgKyBiYXNlVGhlbWVJRCwgc3BlYywgbGlnaHREYXJrSURzKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSBhbiBlZGl0b3IgdmlldyBpbnN0YW5jZSBmcm9tIHRoZSB2aWV3J3MgRE9NXG4gICAgcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZmluZEZyb21ET00oZG9tKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBkb20ucXVlcnlTZWxlY3RvcihcIi5jbS1jb250ZW50XCIpO1xuICAgICAgICBsZXQgY1ZpZXcgPSBjb250ZW50ICYmIENvbnRlbnRWaWV3LmdldChjb250ZW50KSB8fCBDb250ZW50Vmlldy5nZXQoZG9tKTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBjVmlldyA9PT0gbnVsbCB8fCBjVmlldyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY1ZpZXcucm9vdFZpZXcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52aWV3KSB8fCBudWxsO1xuICAgIH1cbn1cbi8qKlxuRmFjZXQgdG8gYWRkIGEgW3N0eWxlXG5tb2R1bGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL3N0eWxlLW1vZCNkb2N1bWVudGF0aW9uKSB0b1xuYW4gZWRpdG9yIHZpZXcuIFRoZSB2aWV3IHdpbGwgZW5zdXJlIHRoYXQgdGhlIG1vZHVsZSBpc1xubW91bnRlZCBpbiBpdHMgW2RvY3VtZW50XG5yb290XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5jb25zdHJ1Y3Rvcl5jb25maWcucm9vdCkuXG4qL1xuRWRpdG9yVmlldy5zdHlsZU1vZHVsZSA9IHN0eWxlTW9kdWxlO1xuLyoqXG5BbiBpbnB1dCBoYW5kbGVyIGNhbiBvdmVycmlkZSB0aGUgd2F5IGNoYW5nZXMgdG8gdGhlIGVkaXRhYmxlXG5ET00gY29udGVudCBhcmUgaGFuZGxlZC4gSGFuZGxlcnMgYXJlIHBhc3NlZCB0aGUgZG9jdW1lbnRcbnBvc2l0aW9ucyBiZXR3ZWVuIHdoaWNoIHRoZSBjaGFuZ2Ugd2FzIGZvdW5kLCBhbmQgdGhlIG5ld1xuY29udGVudC4gV2hlbiBvbmUgcmV0dXJucyB0cnVlLCBubyBmdXJ0aGVyIGlucHV0IGhhbmRsZXJzIGFyZVxuY2FsbGVkIGFuZCB0aGUgZGVmYXVsdCBiZWhhdmlvciBpcyBwcmV2ZW50ZWQuXG5cblRoZSBgaW5zZXJ0YCBhcmd1bWVudCBjYW4gYmUgdXNlZCB0byBnZXQgdGhlIGRlZmF1bHQgdHJhbnNhY3Rpb25cbnRoYXQgd291bGQgYmUgYXBwbGllZCBmb3IgdGhpcyBpbnB1dC4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW5cbmRpc3BhdGNoaW5nIHRoZSBjdXN0b20gYmVoYXZpb3IgYXMgYSBzZXBhcmF0ZSB0cmFuc2FjdGlvbi5cbiovXG5FZGl0b3JWaWV3LmlucHV0SGFuZGxlciA9IGlucHV0SGFuZGxlcjtcbi8qKlxuVGhpcyBmYWNldCBjYW4gYmUgdXNlZCB0byBwcm92aWRlIGZ1bmN0aW9ucyB0aGF0IGNyZWF0ZSBlZmZlY3RzXG50byBiZSBkaXNwYXRjaGVkIHdoZW4gdGhlIGVkaXRvcidzIGZvY3VzIHN0YXRlIGNoYW5nZXMuXG4qL1xuRWRpdG9yVmlldy5mb2N1c0NoYW5nZUVmZmVjdCA9IGZvY3VzQ2hhbmdlRWZmZWN0O1xuLyoqXG5CeSBkZWZhdWx0LCB0aGUgZWRpdG9yIGFzc3VtZXMgYWxsIGl0cyBjb250ZW50IGhhcyB0aGUgc2FtZVxuW3RleHQgZGlyZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGlyZWN0aW9uKS4gQ29uZmlndXJlIHRoaXMgd2l0aCBhIGB0cnVlYFxudmFsdWUgdG8gbWFrZSBpdCByZWFkIHRoZSB0ZXh0IGRpcmVjdGlvbiBvZiBldmVyeSAocmVuZGVyZWQpXG5saW5lIHNlcGFyYXRlbHkuXG4qL1xuRWRpdG9yVmlldy5wZXJMaW5lVGV4dERpcmVjdGlvbiA9IHBlckxpbmVUZXh0RGlyZWN0aW9uO1xuLyoqXG5BbGxvd3MgeW91IHRvIHByb3ZpZGUgYSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQgd2hlbiB0aGVcbmxpYnJhcnkgY2F0Y2hlcyBhbiBleGNlcHRpb24gZnJvbSBhbiBleHRlbnNpb24gKG1vc3RseSBmcm9tIHZpZXdcbnBsdWdpbnMsIGJ1dCBtYXkgYmUgdXNlZCBieSBvdGhlciBleHRlbnNpb25zIHRvIHJvdXRlIGV4Y2VwdGlvbnNcbmZyb20gdXNlci1jb2RlLXByb3ZpZGVkIGNhbGxiYWNrcykuIFRoaXMgaXMgbW9zdGx5IHVzZWZ1bCBmb3JcbmRlYnVnZ2luZyBhbmQgbG9nZ2luZy4gU2VlIFtgbG9nRXhjZXB0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmxvZ0V4Y2VwdGlvbikuXG4qL1xuRWRpdG9yVmlldy5leGNlcHRpb25TaW5rID0gZXhjZXB0aW9uU2luaztcbi8qKlxuQSBmYWNldCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlZ2lzdGVyIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG5ldmVyeSB0aW1lIHRoZSB2aWV3IHVwZGF0ZXMuXG4qL1xuRWRpdG9yVmlldy51cGRhdGVMaXN0ZW5lciA9IHVwZGF0ZUxpc3RlbmVyO1xuLyoqXG5GYWNldCB0aGF0IGNvbnRyb2xzIHdoZXRoZXIgdGhlIGVkaXRvciBjb250ZW50IERPTSBpcyBlZGl0YWJsZS5cbldoZW4gaXRzIGhpZ2hlc3QtcHJlY2VkZW5jZSB2YWx1ZSBpcyBgZmFsc2VgLCB0aGUgZWxlbWVudCB3aWxsXG5ub3QgaGF2ZSBpdHMgYGNvbnRlbnRlZGl0YWJsZWAgYXR0cmlidXRlIHNldC4gKE5vdGUgdGhhdCB0aGlzXG5kb2Vzbid0IGFmZmVjdCBBUEkgY2FsbHMgdGhhdCBjaGFuZ2UgdGhlIGVkaXRvciBjb250ZW50LCBldmVuXG53aGVuIHRob3NlIGFyZSBib3VuZCB0byBrZXlzIG9yIGJ1dHRvbnMuIFNlZSB0aGVcbltgcmVhZE9ubHlgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnJlYWRPbmx5KSBmYWNldCBmb3IgdGhhdC4pXG4qL1xuRWRpdG9yVmlldy5lZGl0YWJsZSA9IGVkaXRhYmxlO1xuLyoqXG5BbGxvd3MgeW91IHRvIGluZmx1ZW5jZSB0aGUgd2F5IG1vdXNlIHNlbGVjdGlvbiBoYXBwZW5zLiBUaGVcbmZ1bmN0aW9ucyBpbiB0aGlzIGZhY2V0IHdpbGwgYmUgY2FsbGVkIGZvciBhIGBtb3VzZWRvd25gIGV2ZW50XG5vbiB0aGUgZWRpdG9yLCBhbmQgY2FuIHJldHVybiBhbiBvYmplY3QgdGhhdCBvdmVycmlkZXMgdGhlIHdheSBhXG5zZWxlY3Rpb24gaXMgY29tcHV0ZWQgZnJvbSB0aGF0IG1vdXNlIGNsaWNrIG9yIGRyYWcuXG4qL1xuRWRpdG9yVmlldy5tb3VzZVNlbGVjdGlvblN0eWxlID0gbW91c2VTZWxlY3Rpb25TdHlsZTtcbi8qKlxuRmFjZXQgdXNlZCB0byBjb25maWd1cmUgd2hldGhlciBhIGdpdmVuIHNlbGVjdGlvbiBkcmFnIGV2ZW50XG5zaG91bGQgbW92ZSBvciBjb3B5IHRoZSBzZWxlY3Rpb24uIFRoZSBnaXZlbiBwcmVkaWNhdGUgd2lsbCBiZVxuY2FsbGVkIHdpdGggdGhlIGBtb3VzZWRvd25gIGV2ZW50LCBhbmQgY2FuIHJldHVybiBgdHJ1ZWAgd2hlblxudGhlIGRyYWcgc2hvdWxkIG1vdmUgdGhlIGNvbnRlbnQuXG4qL1xuRWRpdG9yVmlldy5kcmFnTW92ZXNTZWxlY3Rpb24gPSBkcmFnTW92ZXNTZWxlY3Rpb24kMTtcbi8qKlxuRmFjZXQgdXNlZCB0byBjb25maWd1cmUgd2hldGhlciBhIGdpdmVuIHNlbGVjdGluZyBjbGljayBhZGRzIGFcbm5ldyByYW5nZSB0byB0aGUgZXhpc3Rpbmcgc2VsZWN0aW9uIG9yIHJlcGxhY2VzIGl0IGVudGlyZWx5LiBUaGVcbmRlZmF1bHQgYmVoYXZpb3IgaXMgdG8gY2hlY2sgYGV2ZW50Lm1ldGFLZXlgIG9uIG1hY09TLCBhbmRcbmBldmVudC5jdHJsS2V5YCBlbHNld2hlcmUuXG4qL1xuRWRpdG9yVmlldy5jbGlja0FkZHNTZWxlY3Rpb25SYW5nZSA9IGNsaWNrQWRkc1NlbGVjdGlvblJhbmdlO1xuLyoqXG5BIGZhY2V0IHRoYXQgZGV0ZXJtaW5lcyB3aGljaCBbZGVjb3JhdGlvbnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uKVxuYXJlIHNob3duIGluIHRoZSB2aWV3LiBEZWNvcmF0aW9ucyBjYW4gYmUgcHJvdmlkZWQgaW4gdHdvXG53YXlz4oCUZGlyZWN0bHksIG9yIHZpYSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gZWRpdG9yIHZpZXcuXG5cbk9ubHkgZGVjb3JhdGlvbiBzZXRzIHByb3ZpZGVkIGRpcmVjdGx5IGFyZSBhbGxvd2VkIHRvIGluZmx1ZW5jZVxudGhlIGVkaXRvcidzIHZlcnRpY2FsIGxheW91dCBzdHJ1Y3R1cmUuIFRoZSBvbmVzIHByb3ZpZGVkIGFzXG5mdW5jdGlvbnMgYXJlIGNhbGxlZCBfYWZ0ZXJfIHRoZSBuZXcgdmlld3BvcnQgaGFzIGJlZW4gY29tcHV0ZWQsXG5hbmQgdGh1cyAqKm11c3Qgbm90KiogaW50cm9kdWNlIGJsb2NrIHdpZGdldHMgb3IgcmVwbGFjaW5nXG5kZWNvcmF0aW9ucyB0aGF0IGNvdmVyIGxpbmUgYnJlYWtzLlxuXG5JZiB5b3Ugd2FudCBkZWNvcmF0ZWQgcmFuZ2VzIHRvIGJlaGF2ZSBsaWtlIGF0b21pYyB1bml0cyBmb3JcbmN1cnNvciBtb3Rpb24gYW5kIGRlbGV0aW9uIHB1cnBvc2VzLCBhbHNvIHByb3ZpZGUgdGhlIHJhbmdlIHNldFxuY29udGFpbmluZyB0aGUgZGVjb3JhdGlvbnMgdG9cbltgRWRpdG9yVmlldy5hdG9taWNSYW5nZXNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15hdG9taWNSYW5nZXMpLlxuKi9cbkVkaXRvclZpZXcuZGVjb3JhdGlvbnMgPSBkZWNvcmF0aW9ucztcbi8qKlxuRmFjZXQgdGhhdCB3b3JrcyBtdWNoIGxpa2VcbltgZGVjb3JhdGlvbnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15kZWNvcmF0aW9ucyksIGJ1dCBwdXRzIGl0c1xuaW5wdXRzIGF0IHRoZSB2ZXJ5IGJvdHRvbSBvZiB0aGUgcHJlY2VkZW5jZSBzdGFjaywgbWVhbmluZyBtYXJrXG5kZWNvcmF0aW9ucyBwcm92aWRlZCBoZXJlIHdpbGwgb25seSBiZSBzcGxpdCBieSBvdGhlciwgcGFydGlhbGx5XG5vdmVybGFwcGluZyBcXGBvdXRlckRlY29yYXRpb25zXFxgIHJhbmdlcywgYW5kIHdyYXAgYXJvdW5kIGFsbFxucmVndWxhciBkZWNvcmF0aW9ucy4gVXNlIHRoaXMgZm9yIG1hcmsgZWxlbWVudHMgdGhhdCBzaG91bGQsIGFzXG5tdWNoIGFzIHBvc3NpYmxlLCByZW1haW4gaW4gb25lIHBpZWNlLlxuKi9cbkVkaXRvclZpZXcub3V0ZXJEZWNvcmF0aW9ucyA9IG91dGVyRGVjb3JhdGlvbnM7XG4vKipcblVzZWQgdG8gcHJvdmlkZSByYW5nZXMgdGhhdCBzaG91bGQgYmUgdHJlYXRlZCBhcyBhdG9tcyBhcyBmYXIgYXNcbmN1cnNvciBtb3Rpb24gaXMgY29uY2VybmVkLiBUaGlzIGNhdXNlcyBtZXRob2RzIGxpa2VcbltgbW92ZUJ5Q2hhcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3Lm1vdmVCeUNoYXIpIGFuZFxuW2Btb3ZlVmVydGljYWxseWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3Lm1vdmVWZXJ0aWNhbGx5KSAoYW5kIHRoZVxuY29tbWFuZHMgYnVpbHQgb24gdG9wIG9mIHRoZW0pIHRvIHNraXAgYWNyb3NzIHN1Y2ggcmVnaW9ucyB3aGVuXG5hIHNlbGVjdGlvbiBlbmRwb2ludCB3b3VsZCBlbnRlciB0aGVtLiBUaGlzIGRvZXMgX25vdF8gcHJldmVudFxuZGlyZWN0IHByb2dyYW1tYXRpYyBbc2VsZWN0aW9uXG51cGRhdGVzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5zZWxlY3Rpb24pIGZyb20gbW92aW5nIGludG8gc3VjaFxucmVnaW9ucy5cbiovXG5FZGl0b3JWaWV3LmF0b21pY1JhbmdlcyA9IGF0b21pY1Jhbmdlcztcbi8qKlxuV2hlbiByYW5nZSBkZWNvcmF0aW9ucyBhZGQgYSBgdW5pY29kZS1iaWRpOiBpc29sYXRlYCBzdHlsZSwgdGhleVxuc2hvdWxkIGFsc28gaW5jbHVkZSBhXG5bYGJpZGlJc29sYXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3Lk1hcmtEZWNvcmF0aW9uU3BlYy5iaWRpSXNvbGF0ZSkgcHJvcGVydHlcbmluIHRoZWlyIGRlY29yYXRpb24gc3BlYywgYW5kIGJlIGV4cG9zZWQgdGhyb3VnaCB0aGlzIGZhY2V0LCBzb1xudGhhdCB0aGUgZWRpdG9yIGNhbiBjb21wdXRlIHRoZSBwcm9wZXIgdGV4dCBvcmRlci4gKE90aGVyIHZhbHVlc1xuZm9yIGB1bmljb2RlLWJpZGlgLCBleGNlcHQgb2YgY291cnNlIGBub3JtYWxgLCBhcmUgbm90XG5zdXBwb3J0ZWQuKVxuKi9cbkVkaXRvclZpZXcuYmlkaUlzb2xhdGVkUmFuZ2VzID0gYmlkaUlzb2xhdGVkUmFuZ2VzO1xuLyoqXG5GYWNldCB0aGF0IGFsbG93cyBleHRlbnNpb25zIHRvIHByb3ZpZGUgYWRkaXRpb25hbCBzY3JvbGxcbm1hcmdpbnMgKHNwYWNlIGFyb3VuZCB0aGUgc2lkZXMgb2YgdGhlIHNjcm9sbGluZyBlbGVtZW50IHRoYXRcbnNob3VsZCBiZSBjb25zaWRlcmVkIGludmlzaWJsZSkuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHRoZVxucGx1Z2luIGludHJvZHVjZXMgZWxlbWVudHMgdGhhdCBjb3ZlciBwYXJ0IG9mIHRoYXQgZWxlbWVudCAoZm9yXG5leGFtcGxlIGEgaG9yaXpvbnRhbGx5IGZpeGVkIGd1dHRlcikuXG4qL1xuRWRpdG9yVmlldy5zY3JvbGxNYXJnaW5zID0gc2Nyb2xsTWFyZ2lucztcbi8qKlxuVGhpcyBmYWNldCByZWNvcmRzIHdoZXRoZXIgYSBkYXJrIHRoZW1lIGlzIGFjdGl2ZS4gVGhlIGV4dGVuc2lvblxucmV0dXJuZWQgYnkgW2B0aGVtZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XnRoZW1lKSBhdXRvbWF0aWNhbGx5XG5pbmNsdWRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIHdoZW4gdGhlIGBkYXJrYCBvcHRpb24gaXMgc2V0IHRvXG50cnVlLlxuKi9cbkVkaXRvclZpZXcuZGFya1RoZW1lID0gZGFya1RoZW1lO1xuLyoqXG5Qcm92aWRlcyBhIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IG5vbmNlIHRvIHVzZSB3aGVuIGNyZWF0aW5nXG50aGUgc3R5bGUgc2hlZXRzIGZvciB0aGUgZWRpdG9yLiBIb2xkcyB0aGUgZW1wdHkgc3RyaW5nIHdoZW4gbm9cbm5vbmNlIGhhcyBiZWVuIHByb3ZpZGVkLlxuKi9cbkVkaXRvclZpZXcuY3NwTm9uY2UgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiBcIlwiIH0pO1xuLyoqXG5GYWNldCB0aGF0IHByb3ZpZGVzIGFkZGl0aW9uYWwgRE9NIGF0dHJpYnV0ZXMgZm9yIHRoZSBlZGl0b3Inc1xuZWRpdGFibGUgRE9NIGVsZW1lbnQuXG4qL1xuRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcyA9IGNvbnRlbnRBdHRyaWJ1dGVzO1xuLyoqXG5GYWNldCB0aGF0IHByb3ZpZGVzIERPTSBhdHRyaWJ1dGVzIGZvciB0aGUgZWRpdG9yJ3Mgb3V0ZXJcbmVsZW1lbnQuXG4qL1xuRWRpdG9yVmlldy5lZGl0b3JBdHRyaWJ1dGVzID0gZWRpdG9yQXR0cmlidXRlcztcbi8qKlxuQW4gZXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyBsaW5lIHdyYXBwaW5nIGluIHRoZSBlZGl0b3IgKGJ5XG5zZXR0aW5nIENTUyBgd2hpdGUtc3BhY2VgIHRvIGBwcmUtd3JhcGAgaW4gdGhlIGNvbnRlbnQpLlxuKi9cbkVkaXRvclZpZXcubGluZVdyYXBwaW5nID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuY29udGVudEF0dHJpYnV0ZXMub2YoeyBcImNsYXNzXCI6IFwiY20tbGluZVdyYXBwaW5nXCIgfSk7XG4vKipcblN0YXRlIGVmZmVjdCB1c2VkIHRvIGluY2x1ZGUgc2NyZWVuIHJlYWRlciBhbm5vdW5jZW1lbnRzIGluIGFcbnRyYW5zYWN0aW9uLiBUaGVzZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBET00gaW4gYSB2aXN1YWxseSBoaWRkZW5cbmVsZW1lbnQgd2l0aCBgYXJpYS1saXZlPVwicG9saXRlXCJgIHNldCwgYW5kIHNob3VsZCBiZSB1c2VkIHRvXG5kZXNjcmliZSBlZmZlY3RzIHRoYXQgYXJlIHZpc3VhbGx5IG9idmlvdXMgYnV0IG1heSBub3QgYmVcbm5vdGljZWQgYnkgc2NyZWVuIHJlYWRlciB1c2VycyAoc3VjaCBhcyBtb3ZpbmcgdG8gdGhlIG5leHRcbnNlYXJjaCBtYXRjaCkuXG4qL1xuRWRpdG9yVmlldy5hbm5vdW5jZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbi8vIE1heGltdW0gbGluZSBsZW5ndGggZm9yIHdoaWNoIHdlIGNvbXB1dGUgYWNjdXJhdGUgYmlkaSBpbmZvXG5jb25zdCBNYXhCaWRpTGluZSA9IDQwOTY7XG5jb25zdCBCYWRNZWFzdXJlID0ge307XG5jbGFzcyBDYWNoZWRPcmRlciB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIGRpciwgaXNvbGF0ZXMsIGZyZXNoLCBvcmRlcikge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuZGlyID0gZGlyO1xuICAgICAgICB0aGlzLmlzb2xhdGVzID0gaXNvbGF0ZXM7XG4gICAgICAgIHRoaXMuZnJlc2ggPSBmcmVzaDtcbiAgICAgICAgdGhpcy5vcmRlciA9IG9yZGVyO1xuICAgIH1cbiAgICBzdGF0aWMgdXBkYXRlKGNhY2hlLCBjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmVtcHR5ICYmICFjYWNoZS5zb21lKGMgPT4gYy5mcmVzaCkpXG4gICAgICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXSwgbGFzdERpciA9IGNhY2hlLmxlbmd0aCA/IGNhY2hlW2NhY2hlLmxlbmd0aCAtIDFdLmRpciA6IERpcmVjdGlvbi5MVFI7XG4gICAgICAgIGZvciAobGV0IGkgPSBNYXRoLm1heCgwLCBjYWNoZS5sZW5ndGggLSAxMCk7IGkgPCBjYWNoZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGVudHJ5ID0gY2FjaGVbaV07XG4gICAgICAgICAgICBpZiAoZW50cnkuZGlyID09IGxhc3REaXIgJiYgIWNoYW5nZXMudG91Y2hlc1JhbmdlKGVudHJ5LmZyb20sIGVudHJ5LnRvKSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgQ2FjaGVkT3JkZXIoY2hhbmdlcy5tYXBQb3MoZW50cnkuZnJvbSwgMSksIGNoYW5nZXMubWFwUG9zKGVudHJ5LnRvLCAtMSksIGVudHJ5LmRpciwgZW50cnkuaXNvbGF0ZXMsIGZhbHNlLCBlbnRyeS5vcmRlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gYXR0cnNGcm9tRmFjZXQodmlldywgZmFjZXQsIGJhc2UpIHtcbiAgICBmb3IgKGxldCBzb3VyY2VzID0gdmlldy5zdGF0ZS5mYWNldChmYWNldCksIGkgPSBzb3VyY2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBzb3VyY2UgPSBzb3VyY2VzW2ldLCB2YWx1ZSA9IHR5cGVvZiBzb3VyY2UgPT0gXCJmdW5jdGlvblwiID8gc291cmNlKHZpZXcpIDogc291cmNlO1xuICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICBjb21iaW5lQXR0cnModmFsdWUsIGJhc2UpO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTtcbn1cblxuY29uc3QgY3VycmVudFBsYXRmb3JtID0gYnJvd3Nlci5tYWMgPyBcIm1hY1wiIDogYnJvd3Nlci53aW5kb3dzID8gXCJ3aW5cIiA6IGJyb3dzZXIubGludXggPyBcImxpbnV4XCIgOiBcImtleVwiO1xuZnVuY3Rpb24gbm9ybWFsaXplS2V5TmFtZShuYW1lLCBwbGF0Zm9ybSkge1xuICAgIGNvbnN0IHBhcnRzID0gbmFtZS5zcGxpdCgvLSg/ISQpLyk7XG4gICAgbGV0IHJlc3VsdCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChyZXN1bHQgPT0gXCJTcGFjZVwiKVxuICAgICAgICByZXN1bHQgPSBcIiBcIjtcbiAgICBsZXQgYWx0LCBjdHJsLCBzaGlmdCwgbWV0YTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICBjb25zdCBtb2QgPSBwYXJ0c1tpXTtcbiAgICAgICAgaWYgKC9eKGNtZHxtZXRhfG0pJC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIG1ldGEgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXmEobHQpPyQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBhbHQgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXihjfGN0cmx8Y29udHJvbCkkL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgY3RybCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9ecyhoaWZ0KT8kL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgc2hpZnQgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXm1vZCQvaS50ZXN0KG1vZCkpIHtcbiAgICAgICAgICAgIGlmIChwbGF0Zm9ybSA9PSBcIm1hY1wiKVxuICAgICAgICAgICAgICAgIG1ldGEgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGN0cmwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBtb2RpZmllciBuYW1lOiBcIiArIG1vZCk7XG4gICAgfVxuICAgIGlmIChhbHQpXG4gICAgICAgIHJlc3VsdCA9IFwiQWx0LVwiICsgcmVzdWx0O1xuICAgIGlmIChjdHJsKVxuICAgICAgICByZXN1bHQgPSBcIkN0cmwtXCIgKyByZXN1bHQ7XG4gICAgaWYgKG1ldGEpXG4gICAgICAgIHJlc3VsdCA9IFwiTWV0YS1cIiArIHJlc3VsdDtcbiAgICBpZiAoc2hpZnQpXG4gICAgICAgIHJlc3VsdCA9IFwiU2hpZnQtXCIgKyByZXN1bHQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1vZGlmaWVycyhuYW1lLCBldmVudCwgc2hpZnQpIHtcbiAgICBpZiAoZXZlbnQuYWx0S2V5KVxuICAgICAgICBuYW1lID0gXCJBbHQtXCIgKyBuYW1lO1xuICAgIGlmIChldmVudC5jdHJsS2V5KVxuICAgICAgICBuYW1lID0gXCJDdHJsLVwiICsgbmFtZTtcbiAgICBpZiAoZXZlbnQubWV0YUtleSlcbiAgICAgICAgbmFtZSA9IFwiTWV0YS1cIiArIG5hbWU7XG4gICAgaWYgKHNoaWZ0ICE9PSBmYWxzZSAmJiBldmVudC5zaGlmdEtleSlcbiAgICAgICAgbmFtZSA9IFwiU2hpZnQtXCIgKyBuYW1lO1xuICAgIHJldHVybiBuYW1lO1xufVxuY29uc3QgaGFuZGxlS2V5RXZlbnRzID0gLypAX19QVVJFX18qL1ByZWMuZGVmYXVsdCgvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5kb21FdmVudEhhbmRsZXJzKHtcbiAgICBrZXlkb3duKGV2ZW50LCB2aWV3KSB7XG4gICAgICAgIHJldHVybiBydW5IYW5kbGVycyhnZXRLZXltYXAodmlldy5zdGF0ZSksIGV2ZW50LCB2aWV3LCBcImVkaXRvclwiKTtcbiAgICB9XG59KSk7XG4vKipcbkZhY2V0IHVzZWQgZm9yIHJlZ2lzdGVyaW5nIGtleW1hcHMuXG5cbllvdSBjYW4gYWRkIG11bHRpcGxlIGtleW1hcHMgdG8gYW4gZWRpdG9yLiBUaGVpciBwcmlvcml0aWVzXG5kZXRlcm1pbmUgdGhlaXIgcHJlY2VkZW5jZSAodGhlIG9uZXMgc3BlY2lmaWVkIGVhcmx5IG9yIHdpdGggaGlnaFxucHJpb3JpdHkgZ2V0IGNoZWNrZWQgZmlyc3QpLiBXaGVuIGEgaGFuZGxlciBoYXMgcmV0dXJuZWQgYHRydWVgXG5mb3IgYSBnaXZlbiBrZXksIG5vIGZ1cnRoZXIgaGFuZGxlcnMgYXJlIGNhbGxlZC5cbiovXG5jb25zdCBrZXltYXAgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgZW5hYmxlczogaGFuZGxlS2V5RXZlbnRzIH0pO1xuY29uc3QgS2V5bWFwcyA9IC8qQF9fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xuLy8gVGhpcyBpcyBoaWRkZW4gYmVoaW5kIGFuIGluZGlyZWN0aW9uLCByYXRoZXIgdGhhbiBkaXJlY3RseSBjb21wdXRlZFxuLy8gYnkgdGhlIGZhY2V0LCB0byBrZWVwIGludGVybmFsIHR5cGVzIG91dCBvZiB0aGUgZmFjZXQncyB0eXBlLlxuZnVuY3Rpb24gZ2V0S2V5bWFwKHN0YXRlKSB7XG4gICAgbGV0IGJpbmRpbmdzID0gc3RhdGUuZmFjZXQoa2V5bWFwKTtcbiAgICBsZXQgbWFwID0gS2V5bWFwcy5nZXQoYmluZGluZ3MpO1xuICAgIGlmICghbWFwKVxuICAgICAgICBLZXltYXBzLnNldChiaW5kaW5ncywgbWFwID0gYnVpbGRLZXltYXAoYmluZGluZ3MucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pKSk7XG4gICAgcmV0dXJuIG1hcDtcbn1cbi8qKlxuUnVuIHRoZSBrZXkgaGFuZGxlcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBzY29wZS4gVGhlIGV2ZW50XG5vYmplY3Qgc2hvdWxkIGJlIGEgYFwia2V5ZG93blwiYCBldmVudC4gUmV0dXJucyB0cnVlIGlmIGFueSBvZiB0aGVcbmhhbmRsZXJzIGhhbmRsZWQgaXQuXG4qL1xuZnVuY3Rpb24gcnVuU2NvcGVIYW5kbGVycyh2aWV3LCBldmVudCwgc2NvcGUpIHtcbiAgICByZXR1cm4gcnVuSGFuZGxlcnMoZ2V0S2V5bWFwKHZpZXcuc3RhdGUpLCBldmVudCwgdmlldywgc2NvcGUpO1xufVxubGV0IHN0b3JlZFByZWZpeCA9IG51bGw7XG5jb25zdCBQcmVmaXhUaW1lb3V0ID0gNDAwMDtcbmZ1bmN0aW9uIGJ1aWxkS2V5bWFwKGJpbmRpbmdzLCBwbGF0Zm9ybSA9IGN1cnJlbnRQbGF0Zm9ybSkge1xuICAgIGxldCBib3VuZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGlzUHJlZml4ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgY2hlY2tQcmVmaXggPSAobmFtZSwgaXMpID0+IHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBpc1ByZWZpeFtuYW1lXTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPT0gbnVsbClcbiAgICAgICAgICAgIGlzUHJlZml4W25hbWVdID0gaXM7XG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnQgIT0gaXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXkgYmluZGluZyBcIiArIG5hbWUgKyBcIiBpcyB1c2VkIGJvdGggYXMgYSByZWd1bGFyIGJpbmRpbmcgYW5kIGFzIGEgbXVsdGktc3Ryb2tlIHByZWZpeFwiKTtcbiAgICB9O1xuICAgIGxldCBhZGQgPSAoc2NvcGUsIGtleSwgY29tbWFuZCwgcHJldmVudERlZmF1bHQsIHN0b3BQcm9wYWdhdGlvbikgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgc2NvcGVPYmogPSBib3VuZFtzY29wZV0gfHwgKGJvdW5kW3Njb3BlXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgICBsZXQgcGFydHMgPSBrZXkuc3BsaXQoLyAoPyEkKS8pLm1hcChrID0+IG5vcm1hbGl6ZUtleU5hbWUoaywgcGxhdGZvcm0pKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHByZWZpeCA9IHBhcnRzLnNsaWNlKDAsIGkpLmpvaW4oXCIgXCIpO1xuICAgICAgICAgICAgY2hlY2tQcmVmaXgocHJlZml4LCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghc2NvcGVPYmpbcHJlZml4XSlcbiAgICAgICAgICAgICAgICBzY29wZU9ialtwcmVmaXhdID0ge1xuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcnVuOiBbKHZpZXcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgb3VyT2JqID0gc3RvcmVkUHJlZml4ID0geyB2aWV3LCBwcmVmaXgsIHNjb3BlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IGlmIChzdG9yZWRQcmVmaXggPT0gb3VyT2JqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRQcmVmaXggPSBudWxsOyB9LCBQcmVmaXhUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZnVsbCA9IHBhcnRzLmpvaW4oXCIgXCIpO1xuICAgICAgICBjaGVja1ByZWZpeChmdWxsLCBmYWxzZSk7XG4gICAgICAgIGxldCBiaW5kaW5nID0gc2NvcGVPYmpbZnVsbF0gfHwgKHNjb3BlT2JqW2Z1bGxdID0ge1xuICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgIHJ1bjogKChfYiA9IChfYSA9IHNjb3BlT2JqLl9hbnkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ydW4pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zbGljZSgpKSB8fCBbXVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbW1hbmQpXG4gICAgICAgICAgICBiaW5kaW5nLnJ1bi5wdXNoKGNvbW1hbmQpO1xuICAgICAgICBpZiAocHJldmVudERlZmF1bHQpXG4gICAgICAgICAgICBiaW5kaW5nLnByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHN0b3BQcm9wYWdhdGlvbilcbiAgICAgICAgICAgIGJpbmRpbmcuc3RvcFByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICB9O1xuICAgIGZvciAobGV0IGIgb2YgYmluZGluZ3MpIHtcbiAgICAgICAgbGV0IHNjb3BlcyA9IGIuc2NvcGUgPyBiLnNjb3BlLnNwbGl0KFwiIFwiKSA6IFtcImVkaXRvclwiXTtcbiAgICAgICAgaWYgKGIuYW55KVxuICAgICAgICAgICAgZm9yIChsZXQgc2NvcGUgb2Ygc2NvcGVzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNjb3BlT2JqID0gYm91bmRbc2NvcGVdIHx8IChib3VuZFtzY29wZV0gPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNjb3BlT2JqLl9hbnkpXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlT2JqLl9hbnkgPSB7IHByZXZlbnREZWZhdWx0OiBmYWxzZSwgc3RvcFByb3BhZ2F0aW9uOiBmYWxzZSwgcnVuOiBbXSB9O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBzY29wZU9iailcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVPYmpba2V5XS5ydW4ucHVzaChiLmFueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCBuYW1lID0gYltwbGF0Zm9ybV0gfHwgYi5rZXk7XG4gICAgICAgIGlmICghbmFtZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKGxldCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICAgICAgICAgIGFkZChzY29wZSwgbmFtZSwgYi5ydW4sIGIucHJldmVudERlZmF1bHQsIGIuc3RvcFByb3BhZ2F0aW9uKTtcbiAgICAgICAgICAgIGlmIChiLnNoaWZ0KVxuICAgICAgICAgICAgICAgIGFkZChzY29wZSwgXCJTaGlmdC1cIiArIG5hbWUsIGIuc2hpZnQsIGIucHJldmVudERlZmF1bHQsIGIuc3RvcFByb3BhZ2F0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYm91bmQ7XG59XG5mdW5jdGlvbiBydW5IYW5kbGVycyhtYXAsIGV2ZW50LCB2aWV3LCBzY29wZSkge1xuICAgIGxldCBuYW1lID0ga2V5TmFtZShldmVudCk7XG4gICAgbGV0IGNoYXJDb2RlID0gY29kZVBvaW50QXQobmFtZSwgMCksIGlzQ2hhciA9IGNvZGVQb2ludFNpemUoY2hhckNvZGUpID09IG5hbWUubGVuZ3RoICYmIG5hbWUgIT0gXCIgXCI7XG4gICAgbGV0IHByZWZpeCA9IFwiXCIsIGhhbmRsZWQgPSBmYWxzZSwgcHJldmVudGVkID0gZmFsc2UsIHN0b3BQcm9wYWdhdGlvbiA9IGZhbHNlO1xuICAgIGlmIChzdG9yZWRQcmVmaXggJiYgc3RvcmVkUHJlZml4LnZpZXcgPT0gdmlldyAmJiBzdG9yZWRQcmVmaXguc2NvcGUgPT0gc2NvcGUpIHtcbiAgICAgICAgcHJlZml4ID0gc3RvcmVkUHJlZml4LnByZWZpeCArIFwiIFwiO1xuICAgICAgICBpZiAobW9kaWZpZXJDb2Rlcy5pbmRleE9mKGV2ZW50LmtleUNvZGUpIDwgMCkge1xuICAgICAgICAgICAgcHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0b3JlZFByZWZpeCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHJhbiA9IG5ldyBTZXQ7XG4gICAgbGV0IHJ1bkZvciA9IChiaW5kaW5nKSA9PiB7XG4gICAgICAgIGlmIChiaW5kaW5nKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjbWQgb2YgYmluZGluZy5ydW4pXG4gICAgICAgICAgICAgICAgaWYgKCFyYW4uaGFzKGNtZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuLmFkZChjbWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY21kKHZpZXcsIGV2ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpbmRpbmcuc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiaW5kaW5nLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRpbmcuc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICAgICAgICAgICAgICBzdG9wUHJvcGFnYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgbGV0IHNjb3BlT2JqID0gbWFwW3Njb3BlXSwgYmFzZU5hbWUsIHNoaWZ0TmFtZTtcbiAgICBpZiAoc2NvcGVPYmopIHtcbiAgICAgICAgaWYgKHJ1bkZvcihzY29wZU9ialtwcmVmaXggKyBtb2RpZmllcnMobmFtZSwgZXZlbnQsICFpc0NoYXIpXSkpIHtcbiAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ2hhciAmJiAoZXZlbnQuYWx0S2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSkgJiZcbiAgICAgICAgICAgIC8vIEN0cmwtQWx0IG1heSBiZSB1c2VkIGZvciBBbHRHciBvbiBXaW5kb3dzXG4gICAgICAgICAgICAhKGJyb3dzZXIud2luZG93cyAmJiBldmVudC5jdHJsS2V5ICYmIGV2ZW50LmFsdEtleSkgJiZcbiAgICAgICAgICAgIChiYXNlTmFtZSA9IGJhc2VbZXZlbnQua2V5Q29kZV0pICYmIGJhc2VOYW1lICE9IG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChydW5Gb3Ioc2NvcGVPYmpbcHJlZml4ICsgbW9kaWZpZXJzKGJhc2VOYW1lLCBldmVudCwgdHJ1ZSldKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQuc2hpZnRLZXkgJiYgKHNoaWZ0TmFtZSA9IHNoaWZ0W2V2ZW50LmtleUNvZGVdKSAhPSBuYW1lICYmIHNoaWZ0TmFtZSAhPSBiYXNlTmFtZSAmJlxuICAgICAgICAgICAgICAgIHJ1bkZvcihzY29wZU9ialtwcmVmaXggKyBtb2RpZmllcnMoc2hpZnROYW1lLCBldmVudCwgZmFsc2UpXSkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0NoYXIgJiYgZXZlbnQuc2hpZnRLZXkgJiZcbiAgICAgICAgICAgIHJ1bkZvcihzY29wZU9ialtwcmVmaXggKyBtb2RpZmllcnMobmFtZSwgZXZlbnQsIHRydWUpXSkpIHtcbiAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGFuZGxlZCAmJiBydW5Gb3Ioc2NvcGVPYmouX2FueSkpXG4gICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHByZXZlbnRlZClcbiAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgaWYgKGhhbmRsZWQgJiYgc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICByZXR1cm4gaGFuZGxlZDtcbn1cblxuLyoqXG5JbXBsZW1lbnRhdGlvbiBvZiBbYExheWVyTWFya2VyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkxheWVyTWFya2VyKSB0aGF0IGNyZWF0ZXNcbmEgcmVjdGFuZ2xlIGF0IGEgZ2l2ZW4gc2V0IG9mIGNvb3JkaW5hdGVzLlxuKi9cbmNsYXNzIFJlY3RhbmdsZU1hcmtlciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFya2VyIHdpdGggdGhlIGdpdmVuIGNsYXNzIGFuZCBkaW1lbnNpb25zLiBJZiBgd2lkdGhgXG4gICAgaXMgbnVsbCwgdGhlIERPTSBlbGVtZW50IHdpbGwgZ2V0IG5vIHdpZHRoIHN0eWxlLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoY2xhc3NOYW1lLCBcbiAgICAvKipcbiAgICBUaGUgbGVmdCBwb3NpdGlvbiBvZiB0aGUgbWFya2VyIChpbiBwaXhlbHMsIGRvY3VtZW50LXJlbGF0aXZlKS5cbiAgICAqL1xuICAgIGxlZnQsIFxuICAgIC8qKlxuICAgIFRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIG1hcmtlci5cbiAgICAqL1xuICAgIHRvcCwgXG4gICAgLyoqXG4gICAgVGhlIHdpZHRoIG9mIHRoZSBtYXJrZXIsIG9yIG51bGwgaWYgaXQgc2hvdWxkbid0IGdldCBhIHdpZHRoIGFzc2lnbmVkLlxuICAgICovXG4gICAgd2lkdGgsIFxuICAgIC8qKlxuICAgIFRoZSBoZWlnaHQgb2YgdGhlIG1hcmtlci5cbiAgICAqL1xuICAgIGhlaWdodCkge1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuICAgIGRyYXcoKSB7XG4gICAgICAgIGxldCBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBlbHQuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWU7XG4gICAgICAgIHRoaXMuYWRqdXN0KGVsdCk7XG4gICAgICAgIHJldHVybiBlbHQ7XG4gICAgfVxuICAgIHVwZGF0ZShlbHQsIHByZXYpIHtcbiAgICAgICAgaWYgKHByZXYuY2xhc3NOYW1lICE9IHRoaXMuY2xhc3NOYW1lKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLmFkanVzdChlbHQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYWRqdXN0KGVsdCkge1xuICAgICAgICBlbHQuc3R5bGUubGVmdCA9IHRoaXMubGVmdCArIFwicHhcIjtcbiAgICAgICAgZWx0LnN0eWxlLnRvcCA9IHRoaXMudG9wICsgXCJweFwiO1xuICAgICAgICBpZiAodGhpcy53aWR0aCAhPSBudWxsKVxuICAgICAgICAgICAgZWx0LnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArIFwicHhcIjtcbiAgICAgICAgZWx0LnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgXCJweFwiO1xuICAgIH1cbiAgICBlcShwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlZnQgPT0gcC5sZWZ0ICYmIHRoaXMudG9wID09IHAudG9wICYmIHRoaXMud2lkdGggPT0gcC53aWR0aCAmJiB0aGlzLmhlaWdodCA9PSBwLmhlaWdodCAmJlxuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPT0gcC5jbGFzc05hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNldCBvZiByZWN0YW5nbGVzIGZvciB0aGUgZ2l2ZW4gc2VsZWN0aW9uIHJhbmdlLFxuICAgIGFzc2lnbmluZyB0aGVtIHRoZWNsYXNzYGNsYXNzTmFtZWAuIFdpbGwgY3JlYXRlIGEgc2luZ2xlXG4gICAgcmVjdGFuZ2xlIGZvciBlbXB0eSByYW5nZXMsIGFuZCBhIHNldCBvZiBzZWxlY3Rpb24tc3R5bGVcbiAgICByZWN0YW5nbGVzIGNvdmVyaW5nIHRoZSByYW5nZSdzIGNvbnRlbnQgKGluIGEgYmlkaS1hd2FyZVxuICAgIHdheSkgZm9yIG5vbi1lbXB0eSBvbmVzLlxuICAgICovXG4gICAgc3RhdGljIGZvclJhbmdlKHZpZXcsIGNsYXNzTmFtZSwgcmFuZ2UpIHtcbiAgICAgICAgaWYgKHJhbmdlLmVtcHR5KSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gdmlldy5jb29yZHNBdFBvcyhyYW5nZS5oZWFkLCByYW5nZS5hc3NvYyB8fCAxKTtcbiAgICAgICAgICAgIGlmICghcG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gZ2V0QmFzZSh2aWV3KTtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFJlY3RhbmdsZU1hcmtlcihjbGFzc05hbWUsIHBvcy5sZWZ0IC0gYmFzZS5sZWZ0LCBwb3MudG9wIC0gYmFzZS50b3AsIG51bGwsIHBvcy5ib3R0b20gLSBwb3MudG9wKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjdGFuZ2xlc0ZvclJhbmdlKHZpZXcsIGNsYXNzTmFtZSwgcmFuZ2UpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0QmFzZSh2aWV3KSB7XG4gICAgbGV0IHJlY3QgPSB2aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgbGVmdCA9IHZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSID8gcmVjdC5sZWZ0IDogcmVjdC5yaWdodCAtIHZpZXcuc2Nyb2xsRE9NLmNsaWVudFdpZHRoICogdmlldy5zY2FsZVg7XG4gICAgcmV0dXJuIHsgbGVmdDogbGVmdCAtIHZpZXcuc2Nyb2xsRE9NLnNjcm9sbExlZnQgKiB2aWV3LnNjYWxlWCwgdG9wOiByZWN0LnRvcCAtIHZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCAqIHZpZXcuc2NhbGVZIH07XG59XG5mdW5jdGlvbiB3cmFwcGVkTGluZSh2aWV3LCBwb3MsIGluc2lkZSkge1xuICAgIGxldCByYW5nZSA9IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zKTtcbiAgICByZXR1cm4geyBmcm9tOiBNYXRoLm1heChpbnNpZGUuZnJvbSwgdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkocmFuZ2UsIGZhbHNlLCB0cnVlKS5mcm9tKSxcbiAgICAgICAgdG86IE1hdGgubWluKGluc2lkZS50bywgdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkocmFuZ2UsIHRydWUsIHRydWUpLmZyb20pLFxuICAgICAgICB0eXBlOiBCbG9ja1R5cGUuVGV4dCB9O1xufVxuZnVuY3Rpb24gcmVjdGFuZ2xlc0ZvclJhbmdlKHZpZXcsIGNsYXNzTmFtZSwgcmFuZ2UpIHtcbiAgICBpZiAocmFuZ2UudG8gPD0gdmlldy52aWV3cG9ydC5mcm9tIHx8IHJhbmdlLmZyb20gPj0gdmlldy52aWV3cG9ydC50bylcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGxldCBmcm9tID0gTWF0aC5tYXgocmFuZ2UuZnJvbSwgdmlldy52aWV3cG9ydC5mcm9tKSwgdG8gPSBNYXRoLm1pbihyYW5nZS50bywgdmlldy52aWV3cG9ydC50byk7XG4gICAgbGV0IGx0ciA9IHZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSO1xuICAgIGxldCBjb250ZW50ID0gdmlldy5jb250ZW50RE9NLCBjb250ZW50UmVjdCA9IGNvbnRlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGJhc2UgPSBnZXRCYXNlKHZpZXcpO1xuICAgIGxldCBsaW5lRWx0ID0gY29udGVudC5xdWVyeVNlbGVjdG9yKFwiLmNtLWxpbmVcIiksIGxpbmVTdHlsZSA9IGxpbmVFbHQgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUobGluZUVsdCk7XG4gICAgbGV0IGxlZnRTaWRlID0gY29udGVudFJlY3QubGVmdCArXG4gICAgICAgIChsaW5lU3R5bGUgPyBwYXJzZUludChsaW5lU3R5bGUucGFkZGluZ0xlZnQpICsgTWF0aC5taW4oMCwgcGFyc2VJbnQobGluZVN0eWxlLnRleHRJbmRlbnQpKSA6IDApO1xuICAgIGxldCByaWdodFNpZGUgPSBjb250ZW50UmVjdC5yaWdodCAtIChsaW5lU3R5bGUgPyBwYXJzZUludChsaW5lU3R5bGUucGFkZGluZ1JpZ2h0KSA6IDApO1xuICAgIGxldCBzdGFydEJsb2NrID0gYmxvY2tBdCh2aWV3LCBmcm9tKSwgZW5kQmxvY2sgPSBibG9ja0F0KHZpZXcsIHRvKTtcbiAgICBsZXQgdmlzdWFsU3RhcnQgPSBzdGFydEJsb2NrLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQgPyBzdGFydEJsb2NrIDogbnVsbDtcbiAgICBsZXQgdmlzdWFsRW5kID0gZW5kQmxvY2sudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCA/IGVuZEJsb2NrIDogbnVsbDtcbiAgICBpZiAodmlzdWFsU3RhcnQgJiYgKHZpZXcubGluZVdyYXBwaW5nIHx8IHN0YXJ0QmxvY2sud2lkZ2V0TGluZUJyZWFrcykpXG4gICAgICAgIHZpc3VhbFN0YXJ0ID0gd3JhcHBlZExpbmUodmlldywgZnJvbSwgdmlzdWFsU3RhcnQpO1xuICAgIGlmICh2aXN1YWxFbmQgJiYgKHZpZXcubGluZVdyYXBwaW5nIHx8IGVuZEJsb2NrLndpZGdldExpbmVCcmVha3MpKVxuICAgICAgICB2aXN1YWxFbmQgPSB3cmFwcGVkTGluZSh2aWV3LCB0bywgdmlzdWFsRW5kKTtcbiAgICBpZiAodmlzdWFsU3RhcnQgJiYgdmlzdWFsRW5kICYmIHZpc3VhbFN0YXJ0LmZyb20gPT0gdmlzdWFsRW5kLmZyb20pIHtcbiAgICAgICAgcmV0dXJuIHBpZWNlcyhkcmF3Rm9yTGluZShyYW5nZS5mcm9tLCByYW5nZS50bywgdmlzdWFsU3RhcnQpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCB0b3AgPSB2aXN1YWxTdGFydCA/IGRyYXdGb3JMaW5lKHJhbmdlLmZyb20sIG51bGwsIHZpc3VhbFN0YXJ0KSA6IGRyYXdGb3JXaWRnZXQoc3RhcnRCbG9jaywgZmFsc2UpO1xuICAgICAgICBsZXQgYm90dG9tID0gdmlzdWFsRW5kID8gZHJhd0ZvckxpbmUobnVsbCwgcmFuZ2UudG8sIHZpc3VhbEVuZCkgOiBkcmF3Rm9yV2lkZ2V0KGVuZEJsb2NrLCB0cnVlKTtcbiAgICAgICAgbGV0IGJldHdlZW4gPSBbXTtcbiAgICAgICAgaWYgKCh2aXN1YWxTdGFydCB8fCBzdGFydEJsb2NrKS50byA8ICh2aXN1YWxFbmQgfHwgZW5kQmxvY2spLmZyb20gLSAodmlzdWFsU3RhcnQgJiYgdmlzdWFsRW5kID8gMSA6IDApIHx8XG4gICAgICAgICAgICBzdGFydEJsb2NrLndpZGdldExpbmVCcmVha3MgPiAxICYmIHRvcC5ib3R0b20gKyB2aWV3LmRlZmF1bHRMaW5lSGVpZ2h0IC8gMiA8IGJvdHRvbS50b3ApXG4gICAgICAgICAgICBiZXR3ZWVuLnB1c2gocGllY2UobGVmdFNpZGUsIHRvcC5ib3R0b20sIHJpZ2h0U2lkZSwgYm90dG9tLnRvcCkpO1xuICAgICAgICBlbHNlIGlmICh0b3AuYm90dG9tIDwgYm90dG9tLnRvcCAmJiB2aWV3LmVsZW1lbnRBdEhlaWdodCgodG9wLmJvdHRvbSArIGJvdHRvbS50b3ApIC8gMikudHlwZSA9PSBCbG9ja1R5cGUuVGV4dClcbiAgICAgICAgICAgIHRvcC5ib3R0b20gPSBib3R0b20udG9wID0gKHRvcC5ib3R0b20gKyBib3R0b20udG9wKSAvIDI7XG4gICAgICAgIHJldHVybiBwaWVjZXModG9wKS5jb25jYXQoYmV0d2VlbikuY29uY2F0KHBpZWNlcyhib3R0b20pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGllY2UobGVmdCwgdG9wLCByaWdodCwgYm90dG9tKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlTWFya2VyKGNsYXNzTmFtZSwgbGVmdCAtIGJhc2UubGVmdCwgdG9wIC0gYmFzZS50b3AgLSAwLjAxIC8qIEMuRXBzaWxvbiAqLywgcmlnaHQgLSBsZWZ0LCBib3R0b20gLSB0b3AgKyAwLjAxIC8qIEMuRXBzaWxvbiAqLyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBpZWNlcyh7IHRvcCwgYm90dG9tLCBob3Jpem9udGFsIH0pIHtcbiAgICAgICAgbGV0IHBpZWNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhvcml6b250YWwubGVuZ3RoOyBpICs9IDIpXG4gICAgICAgICAgICBwaWVjZXMucHVzaChwaWVjZShob3Jpem9udGFsW2ldLCB0b3AsIGhvcml6b250YWxbaSArIDFdLCBib3R0b20pKTtcbiAgICAgICAgcmV0dXJuIHBpZWNlcztcbiAgICB9XG4gICAgLy8gR2V0cyBwYXNzZWQgZnJvbS90byBpbiBsaW5lLWxvY2FsIHBvc2l0aW9uc1xuICAgIGZ1bmN0aW9uIGRyYXdGb3JMaW5lKGZyb20sIHRvLCBsaW5lKSB7XG4gICAgICAgIGxldCB0b3AgPSAxZTksIGJvdHRvbSA9IC0xZTksIGhvcml6b250YWwgPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gYWRkU3Bhbihmcm9tLCBmcm9tT3BlbiwgdG8sIHRvT3BlbiwgZGlyKSB7XG4gICAgICAgICAgICAvLyBQYXNzaW5nIDIvLTIgaXMgYSBrbHVkZ2UgdG8gZm9yY2UgdGhlIHZpZXcgdG8gcmV0dXJuXG4gICAgICAgICAgICAvLyBjb29yZGluYXRlcyBvbiB0aGUgcHJvcGVyIHNpZGUgb2YgYmxvY2sgd2lkZ2V0cywgc2luY2VcbiAgICAgICAgICAgIC8vIG5vcm1hbGl6aW5nIHRoZSBzaWRlIHRoZXJlLCB0aG91Z2ggYXBwcm9wcmlhdGUgZm9yIG1vc3RcbiAgICAgICAgICAgIC8vIGNvb3Jkc0F0UG9zIHF1ZXJpZXMsIHdvdWxkIGJyZWFrIHNlbGVjdGlvbiBkcmF3aW5nLlxuICAgICAgICAgICAgbGV0IGZyb21Db29yZHMgPSB2aWV3LmNvb3Jkc0F0UG9zKGZyb20sIChmcm9tID09IGxpbmUudG8gPyAtMiA6IDIpKTtcbiAgICAgICAgICAgIGxldCB0b0Nvb3JkcyA9IHZpZXcuY29vcmRzQXRQb3ModG8sICh0byA9PSBsaW5lLmZyb20gPyAyIDogLTIpKTtcbiAgICAgICAgICAgIGlmICghZnJvbUNvb3JkcyB8fCAhdG9Db29yZHMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdG9wID0gTWF0aC5taW4oZnJvbUNvb3Jkcy50b3AsIHRvQ29vcmRzLnRvcCwgdG9wKTtcbiAgICAgICAgICAgIGJvdHRvbSA9IE1hdGgubWF4KGZyb21Db29yZHMuYm90dG9tLCB0b0Nvb3Jkcy5ib3R0b20sIGJvdHRvbSk7XG4gICAgICAgICAgICBpZiAoZGlyID09IERpcmVjdGlvbi5MVFIpXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbC5wdXNoKGx0ciAmJiBmcm9tT3BlbiA/IGxlZnRTaWRlIDogZnJvbUNvb3Jkcy5sZWZ0LCBsdHIgJiYgdG9PcGVuID8gcmlnaHRTaWRlIDogdG9Db29yZHMucmlnaHQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGhvcml6b250YWwucHVzaCghbHRyICYmIHRvT3BlbiA/IGxlZnRTaWRlIDogdG9Db29yZHMubGVmdCwgIWx0ciAmJiBmcm9tT3BlbiA/IHJpZ2h0U2lkZSA6IGZyb21Db29yZHMucmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydCA9IGZyb20gIT09IG51bGwgJiYgZnJvbSAhPT0gdm9pZCAwID8gZnJvbSA6IGxpbmUuZnJvbSwgZW5kID0gdG8gIT09IG51bGwgJiYgdG8gIT09IHZvaWQgMCA/IHRvIDogbGluZS50bztcbiAgICAgICAgLy8gU3BsaXQgdGhlIHJhbmdlIGJ5IHZpc2libGUgcmFuZ2UgYW5kIGRvY3VtZW50IGxpbmVcbiAgICAgICAgZm9yIChsZXQgciBvZiB2aWV3LnZpc2libGVSYW5nZXMpXG4gICAgICAgICAgICBpZiAoci50byA+IHN0YXJ0ICYmIHIuZnJvbSA8IGVuZCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyA9IE1hdGgubWF4KHIuZnJvbSwgc3RhcnQpLCBlbmRQb3MgPSBNYXRoLm1pbihyLnRvLCBlbmQpOzspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRvY0xpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgc3BhbiBvZiB2aWV3LmJpZGlTcGFucyhkb2NMaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNwYW5Gcm9tID0gc3Bhbi5mcm9tICsgZG9jTGluZS5mcm9tLCBzcGFuVG8gPSBzcGFuLnRvICsgZG9jTGluZS5mcm9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwYW5Gcm9tID49IGVuZFBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGFuVG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkU3BhbihNYXRoLm1heChzcGFuRnJvbSwgcG9zKSwgZnJvbSA9PSBudWxsICYmIHNwYW5Gcm9tIDw9IHN0YXJ0LCBNYXRoLm1pbihzcGFuVG8sIGVuZFBvcyksIHRvID09IG51bGwgJiYgc3BhblRvID49IGVuZCwgc3Bhbi5kaXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGRvY0xpbmUudG8gKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID49IGVuZFBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKGhvcml6b250YWwubGVuZ3RoID09IDApXG4gICAgICAgICAgICBhZGRTcGFuKHN0YXJ0LCBmcm9tID09IG51bGwsIGVuZCwgdG8gPT0gbnVsbCwgdmlldy50ZXh0RGlyZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHsgdG9wLCBib3R0b20sIGhvcml6b250YWwgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZHJhd0ZvcldpZGdldChibG9jaywgdG9wKSB7XG4gICAgICAgIGxldCB5ID0gY29udGVudFJlY3QudG9wICsgKHRvcCA/IGJsb2NrLnRvcCA6IGJsb2NrLmJvdHRvbSk7XG4gICAgICAgIHJldHVybiB7IHRvcDogeSwgYm90dG9tOiB5LCBob3Jpem9udGFsOiBbXSB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbWVNYXJrZXIoYSwgYikge1xuICAgIHJldHVybiBhLmNvbnN0cnVjdG9yID09IGIuY29uc3RydWN0b3IgJiYgYS5lcShiKTtcbn1cbmNsYXNzIExheWVyVmlldyB7XG4gICAgY29uc3RydWN0b3IodmlldywgbGF5ZXIpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5sYXllciA9IGxheWVyO1xuICAgICAgICB0aGlzLmRyYXduID0gW107XG4gICAgICAgIHRoaXMuc2NhbGVYID0gMTtcbiAgICAgICAgdGhpcy5zY2FsZVkgPSAxO1xuICAgICAgICB0aGlzLm1lYXN1cmVSZXEgPSB7IHJlYWQ6IHRoaXMubWVhc3VyZS5iaW5kKHRoaXMpLCB3cml0ZTogdGhpcy5kcmF3LmJpbmQodGhpcykgfTtcbiAgICAgICAgdGhpcy5kb20gPSB2aWV3LnNjcm9sbERPTS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LmFkZChcImNtLWxheWVyXCIpO1xuICAgICAgICBpZiAobGF5ZXIuYWJvdmUpXG4gICAgICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tbGF5ZXItYWJvdmVcIik7XG4gICAgICAgIGlmIChsYXllci5jbGFzcylcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQobGF5ZXIuY2xhc3MpO1xuICAgICAgICB0aGlzLnNjYWxlKCk7XG4gICAgICAgIHRoaXMuZG9tLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgdGhpcy5zZXRPcmRlcih2aWV3LnN0YXRlKTtcbiAgICAgICAgdmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLm1lYXN1cmVSZXEpO1xuICAgICAgICBpZiAobGF5ZXIubW91bnQpXG4gICAgICAgICAgICBsYXllci5tb3VudCh0aGlzLmRvbSwgdmlldyk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGxheWVyT3JkZXIpICE9IHVwZGF0ZS5zdGF0ZS5mYWNldChsYXllck9yZGVyKSlcbiAgICAgICAgICAgIHRoaXMuc2V0T3JkZXIodXBkYXRlLnN0YXRlKTtcbiAgICAgICAgaWYgKHRoaXMubGF5ZXIudXBkYXRlKHVwZGF0ZSwgdGhpcy5kb20pIHx8IHVwZGF0ZS5nZW9tZXRyeUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGUoKTtcbiAgICAgICAgICAgIHVwZGF0ZS52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0T3JkZXIoc3RhdGUpIHtcbiAgICAgICAgbGV0IHBvcyA9IDAsIG9yZGVyID0gc3RhdGUuZmFjZXQobGF5ZXJPcmRlcik7XG4gICAgICAgIHdoaWxlIChwb3MgPCBvcmRlci5sZW5ndGggJiYgb3JkZXJbcG9zXSAhPSB0aGlzLmxheWVyKVxuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgIHRoaXMuZG9tLnN0eWxlLnpJbmRleCA9IFN0cmluZygodGhpcy5sYXllci5hYm92ZSA/IDE1MCA6IC0xKSAtIHBvcyk7XG4gICAgfVxuICAgIG1lYXN1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheWVyLm1hcmtlcnModGhpcy52aWV3KTtcbiAgICB9XG4gICAgc2NhbGUoKSB7XG4gICAgICAgIGxldCB7IHNjYWxlWCwgc2NhbGVZIH0gPSB0aGlzLnZpZXc7XG4gICAgICAgIGlmIChzY2FsZVggIT0gdGhpcy5zY2FsZVggfHwgc2NhbGVZICE9IHRoaXMuc2NhbGVZKSB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlWCA9IHNjYWxlWDtcbiAgICAgICAgICAgIHRoaXMuc2NhbGVZID0gc2NhbGVZO1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUudHJhbnNmb3JtID0gYHNjYWxlKCR7MSAvIHNjYWxlWH0sICR7MSAvIHNjYWxlWX0pYDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkcmF3KG1hcmtlcnMpIHtcbiAgICAgICAgaWYgKG1hcmtlcnMubGVuZ3RoICE9IHRoaXMuZHJhd24ubGVuZ3RoIHx8IG1hcmtlcnMuc29tZSgocCwgaSkgPT4gIXNhbWVNYXJrZXIocCwgdGhpcy5kcmF3bltpXSkpKSB7XG4gICAgICAgICAgICBsZXQgb2xkID0gdGhpcy5kb20uZmlyc3RDaGlsZCwgb2xkSSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBtYXJrZXIgb2YgbWFya2Vycykge1xuICAgICAgICAgICAgICAgIGlmIChtYXJrZXIudXBkYXRlICYmIG9sZCAmJiBtYXJrZXIuY29uc3RydWN0b3IgJiYgdGhpcy5kcmF3bltvbGRJXS5jb25zdHJ1Y3RvciAmJlxuICAgICAgICAgICAgICAgICAgICBtYXJrZXIudXBkYXRlKG9sZCwgdGhpcy5kcmF3bltvbGRJXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkID0gb2xkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBvbGRJKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5pbnNlcnRCZWZvcmUobWFya2VyLmRyYXcoKSwgb2xkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAob2xkKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBvbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgb2xkLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIG9sZCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRyYXduID0gbWFya2VycztcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5sYXllci5kZXN0cm95KVxuICAgICAgICAgICAgdGhpcy5sYXllci5kZXN0cm95KHRoaXMuZG9tLCB0aGlzLnZpZXcpO1xuICAgICAgICB0aGlzLmRvbS5yZW1vdmUoKTtcbiAgICB9XG59XG5jb25zdCBsYXllck9yZGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLyoqXG5EZWZpbmUgYSBsYXllci5cbiovXG5mdW5jdGlvbiBsYXllcihjb25maWcpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBWaWV3UGx1Z2luLmRlZmluZSh2ID0+IG5ldyBMYXllclZpZXcodiwgY29uZmlnKSksXG4gICAgICAgIGxheWVyT3JkZXIub2YoY29uZmlnKVxuICAgIF07XG59XG5cbmNvbnN0IENhbkhpZGVQcmltYXJ5ID0gIWJyb3dzZXIuaW9zOyAvLyBGSVhNRSB0ZXN0IElFXG5jb25zdCBzZWxlY3Rpb25Db25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgY3Vyc29yQmxpbmtSYXRlOiAxMjAwLFxuICAgICAgICAgICAgZHJhd1JhbmdlQ3Vyc29yOiB0cnVlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGN1cnNvckJsaW5rUmF0ZTogKGEsIGIpID0+IE1hdGgubWluKGEsIGIpLFxuICAgICAgICAgICAgZHJhd1JhbmdlQ3Vyc29yOiAoYSwgYikgPT4gYSB8fCBiXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGhpZGVzIHRoZSBicm93c2VyJ3MgbmF0aXZlIHNlbGVjdGlvbiBhbmRcbmN1cnNvciwgcmVwbGFjaW5nIHRoZSBzZWxlY3Rpb24gd2l0aCBhIGJhY2tncm91bmQgYmVoaW5kIHRoZSB0ZXh0XG4od2l0aCB0aGUgYGNtLXNlbGVjdGlvbkJhY2tncm91bmRgIGNsYXNzKSwgYW5kIHRoZVxuY3Vyc29ycyB3aXRoIGVsZW1lbnRzIG92ZXJsYWlkIG92ZXIgdGhlIGNvZGUgKHVzaW5nXG5gY20tY3Vyc29yLXByaW1hcnlgIGFuZCBgY20tY3Vyc29yLXNlY29uZGFyeWApLlxuXG5UaGlzIGFsbG93cyB0aGUgZWRpdG9yIHRvIGRpc3BsYXkgc2Vjb25kYXJ5IHNlbGVjdGlvbiByYW5nZXMsIGFuZFxudGVuZHMgdG8gcHJvZHVjZSBhIHR5cGUgb2Ygc2VsZWN0aW9uIG1vcmUgaW4gbGluZSB3aXRoIHRoYXQgdXNlcnNcbmV4cGVjdCBpbiBhIHRleHQgZWRpdG9yICh0aGUgbmF0aXZlIHNlbGVjdGlvbiBzdHlsaW5nIHdpbGwgb2Z0ZW5cbmxlYXZlIGdhcHMgYmV0d2VlbiBsaW5lcyBhbmQgd29uJ3QgZmlsbCB0aGUgaG9yaXpvbnRhbCBzcGFjZSBhZnRlclxuYSBsaW5lIHdoZW4gdGhlIHNlbGVjdGlvbiBjb250aW51ZXMgcGFzdCBpdCkuXG5cbkl0IGRvZXMgaGF2ZSBhIHBlcmZvcm1hbmNlIGNvc3QsIGluIHRoYXQgaXQgcmVxdWlyZXMgYW4gZXh0cmEgRE9NXG5sYXlvdXQgY3ljbGUgZm9yIG1hbnkgdXBkYXRlcyAodGhlIHNlbGVjdGlvbiBpcyBkcmF3biBiYXNlZCBvbiBET01cbmxheW91dCBpbmZvcm1hdGlvbiB0aGF0J3Mgb25seSBhdmFpbGFibGUgYWZ0ZXIgbGF5aW5nIG91dCB0aGVcbmNvbnRlbnQpLlxuKi9cbmZ1bmN0aW9uIGRyYXdTZWxlY3Rpb24oY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBzZWxlY3Rpb25Db25maWcub2YoY29uZmlnKSxcbiAgICAgICAgY3Vyc29yTGF5ZXIsXG4gICAgICAgIHNlbGVjdGlvbkxheWVyLFxuICAgICAgICBoaWRlTmF0aXZlU2VsZWN0aW9uLFxuICAgICAgICBuYXRpdmVTZWxlY3Rpb25IaWRkZW4ub2YodHJ1ZSlcbiAgICBdO1xufVxuLyoqXG5SZXRyaWV2ZSB0aGUgW2BkcmF3U2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmRyYXdTZWxlY3Rpb24pIGNvbmZpZ3VyYXRpb25cbmZvciB0aGlzIHN0YXRlLiAoTm90ZSB0aGF0IHRoaXMgd2lsbCByZXR1cm4gYSBzZXQgb2YgZGVmYXVsdHMgZXZlblxuaWYgYGRyYXdTZWxlY3Rpb25gIGlzbid0IGVuYWJsZWQuKVxuKi9cbmZ1bmN0aW9uIGdldERyYXdTZWxlY3Rpb25Db25maWcoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUuZmFjZXQoc2VsZWN0aW9uQ29uZmlnKTtcbn1cbmZ1bmN0aW9uIGNvbmZpZ0NoYW5nZWQodXBkYXRlKSB7XG4gICAgcmV0dXJuIHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZykgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZyk7XG59XG5jb25zdCBjdXJzb3JMYXllciA9IC8qQF9fUFVSRV9fKi9sYXllcih7XG4gICAgYWJvdmU6IHRydWUsXG4gICAgbWFya2Vycyh2aWV3KSB7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBjb25mID0gc3RhdGUuZmFjZXQoc2VsZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgbGV0IGN1cnNvcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgciBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgcHJpbSA9IHIgPT0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgICAgICAgICBpZiAoci5lbXB0eSA/ICFwcmltIHx8IENhbkhpZGVQcmltYXJ5IDogY29uZi5kcmF3UmFuZ2VDdXJzb3IpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2xhc3NOYW1lID0gcHJpbSA/IFwiY20tY3Vyc29yIGNtLWN1cnNvci1wcmltYXJ5XCIgOiBcImNtLWN1cnNvciBjbS1jdXJzb3Itc2Vjb25kYXJ5XCI7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnNvciA9IHIuZW1wdHkgPyByIDogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyLmhlYWQsIHIuaGVhZCA+IHIuYW5jaG9yID8gLTEgOiAxKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwaWVjZSBvZiBSZWN0YW5nbGVNYXJrZXIuZm9yUmFuZ2UodmlldywgY2xhc3NOYW1lLCBjdXJzb3IpKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3JzLnB1c2gocGllY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJzb3JzO1xuICAgIH0sXG4gICAgdXBkYXRlKHVwZGF0ZSwgZG9tKSB7XG4gICAgICAgIGlmICh1cGRhdGUudHJhbnNhY3Rpb25zLnNvbWUodHIgPT4gdHIuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgIGRvbS5zdHlsZS5hbmltYXRpb25OYW1lID0gZG9tLnN0eWxlLmFuaW1hdGlvbk5hbWUgPT0gXCJjbS1ibGlua1wiID8gXCJjbS1ibGluazJcIiA6IFwiY20tYmxpbmtcIjtcbiAgICAgICAgbGV0IGNvbmZDaGFuZ2UgPSBjb25maWdDaGFuZ2VkKHVwZGF0ZSk7XG4gICAgICAgIGlmIChjb25mQ2hhbmdlKVxuICAgICAgICAgICAgc2V0QmxpbmtSYXRlKHVwZGF0ZS5zdGF0ZSwgZG9tKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5zZWxlY3Rpb25TZXQgfHwgY29uZkNoYW5nZTtcbiAgICB9LFxuICAgIG1vdW50KGRvbSwgdmlldykge1xuICAgICAgICBzZXRCbGlua1JhdGUodmlldy5zdGF0ZSwgZG9tKTtcbiAgICB9LFxuICAgIGNsYXNzOiBcImNtLWN1cnNvckxheWVyXCJcbn0pO1xuZnVuY3Rpb24gc2V0QmxpbmtSYXRlKHN0YXRlLCBkb20pIHtcbiAgICBkb20uc3R5bGUuYW5pbWF0aW9uRHVyYXRpb24gPSBzdGF0ZS5mYWNldChzZWxlY3Rpb25Db25maWcpLmN1cnNvckJsaW5rUmF0ZSArIFwibXNcIjtcbn1cbmNvbnN0IHNlbGVjdGlvbkxheWVyID0gLypAX19QVVJFX18qL2xheWVyKHtcbiAgICBhYm92ZTogZmFsc2UsXG4gICAgbWFya2Vycyh2aWV3KSB7XG4gICAgICAgIHJldHVybiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubWFwKHIgPT4gci5lbXB0eSA/IFtdIDogUmVjdGFuZ2xlTWFya2VyLmZvclJhbmdlKHZpZXcsIFwiY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiLCByKSlcbiAgICAgICAgICAgIC5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpKTtcbiAgICB9LFxuICAgIHVwZGF0ZSh1cGRhdGUsIGRvbSkge1xuICAgICAgICByZXR1cm4gdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8IGNvbmZpZ0NoYW5nZWQodXBkYXRlKTtcbiAgICB9LFxuICAgIGNsYXNzOiBcImNtLXNlbGVjdGlvbkxheWVyXCJcbn0pO1xuY29uc3QgdGhlbWVTcGVjID0ge1xuICAgIFwiLmNtLWxpbmVcIjoge1xuICAgICAgICBcIiYgOjpzZWxlY3Rpb25cIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnQgIWltcG9ydGFudFwiIH0sXG4gICAgICAgIFwiJjo6c2VsZWN0aW9uXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50ICFpbXBvcnRhbnRcIiB9XG4gICAgfVxufTtcbmlmIChDYW5IaWRlUHJpbWFyeSkge1xuICAgIHRoZW1lU3BlY1tcIi5jbS1saW5lXCJdLmNhcmV0Q29sb3IgPSBcInRyYW5zcGFyZW50ICFpbXBvcnRhbnRcIjtcbiAgICB0aGVtZVNwZWNbXCIuY20tY29udGVudFwiXSA9IHsgY2FyZXRDb2xvcjogXCJ0cmFuc3BhcmVudCAhaW1wb3J0YW50XCIgfTtcbn1cbmNvbnN0IGhpZGVOYXRpdmVTZWxlY3Rpb24gPSAvKkBfX1BVUkVfXyovUHJlYy5oaWdoZXN0KC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LnRoZW1lKHRoZW1lU3BlYykpO1xuXG5jb25zdCBzZXREcm9wQ3Vyc29yUG9zID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7XG4gICAgbWFwKHBvcywgbWFwcGluZykgeyByZXR1cm4gcG9zID09IG51bGwgPyBudWxsIDogbWFwcGluZy5tYXBQb3MocG9zKTsgfVxufSk7XG5jb25zdCBkcm9wQ3Vyc29yUG9zID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiBudWxsOyB9LFxuICAgIHVwZGF0ZShwb3MsIHRyKSB7XG4gICAgICAgIGlmIChwb3MgIT0gbnVsbClcbiAgICAgICAgICAgIHBvcyA9IHRyLmNoYW5nZXMubWFwUG9zKHBvcyk7XG4gICAgICAgIHJldHVybiB0ci5lZmZlY3RzLnJlZHVjZSgocG9zLCBlKSA9PiBlLmlzKHNldERyb3BDdXJzb3JQb3MpID8gZS52YWx1ZSA6IHBvcywgcG9zKTtcbiAgICB9XG59KTtcbmNvbnN0IGRyYXdEcm9wQ3Vyc29yID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgdGhpcy5tZWFzdXJlUmVxID0geyByZWFkOiB0aGlzLnJlYWRQb3MuYmluZCh0aGlzKSwgd3JpdGU6IHRoaXMuZHJhd0N1cnNvci5iaW5kKHRoaXMpIH07XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgY3Vyc29yUG9zID0gdXBkYXRlLnN0YXRlLmZpZWxkKGRyb3BDdXJzb3JQb3MpO1xuICAgICAgICBpZiAoY3Vyc29yUG9zID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnNvciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5jdXJzb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSB0aGlzLnZpZXcuc2Nyb2xsRE9NLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLmNsYXNzTmFtZSA9IFwiY20tZHJvcEN1cnNvclwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVwZGF0ZS5zdGFydFN0YXRlLmZpZWxkKGRyb3BDdXJzb3JQb3MpICE9IGN1cnNvclBvcyB8fCB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuZ2VvbWV0cnlDaGFuZ2VkKVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLm1lYXN1cmVSZXEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlYWRQb3MoKSB7XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwb3MgPSB2aWV3LnN0YXRlLmZpZWxkKGRyb3BDdXJzb3JQb3MpO1xuICAgICAgICBsZXQgcmVjdCA9IHBvcyAhPSBudWxsICYmIHZpZXcuY29vcmRzQXRQb3MocG9zKTtcbiAgICAgICAgaWYgKCFyZWN0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBvdXRlciA9IHZpZXcuc2Nyb2xsRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogcmVjdC5sZWZ0IC0gb3V0ZXIubGVmdCArIHZpZXcuc2Nyb2xsRE9NLnNjcm9sbExlZnQgKiB2aWV3LnNjYWxlWCxcbiAgICAgICAgICAgIHRvcDogcmVjdC50b3AgLSBvdXRlci50b3AgKyB2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgKiB2aWV3LnNjYWxlWSxcbiAgICAgICAgICAgIGhlaWdodDogcmVjdC5ib3R0b20gLSByZWN0LnRvcFxuICAgICAgICB9O1xuICAgIH1cbiAgICBkcmF3Q3Vyc29yKHBvcykge1xuICAgICAgICBpZiAodGhpcy5jdXJzb3IpIHtcbiAgICAgICAgICAgIGxldCB7IHNjYWxlWCwgc2NhbGVZIH0gPSB0aGlzLnZpZXc7XG4gICAgICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3Iuc3R5bGUubGVmdCA9IHBvcy5sZWZ0IC8gc2NhbGVYICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnN0eWxlLnRvcCA9IHBvcy50b3AgLyBzY2FsZVkgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3Iuc3R5bGUuaGVpZ2h0ID0gcG9zLmhlaWdodCAvIHNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnN0eWxlLmxlZnQgPSBcIi0xMDAwMDBweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnNvcilcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yLnJlbW92ZSgpO1xuICAgIH1cbiAgICBzZXREcm9wUG9zKHBvcykge1xuICAgICAgICBpZiAodGhpcy52aWV3LnN0YXRlLmZpZWxkKGRyb3BDdXJzb3JQb3MpICE9IHBvcylcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldERyb3BDdXJzb3JQb3Mub2YocG9zKSB9KTtcbiAgICB9XG59LCB7XG4gICAgZXZlbnRPYnNlcnZlcnM6IHtcbiAgICAgICAgZHJhZ292ZXIoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyh0aGlzLnZpZXcucG9zQXRDb29yZHMoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJhZ2xlYXZlKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09IHRoaXMudmlldy5jb250ZW50RE9NIHx8ICF0aGlzLnZpZXcuY29udGVudERPTS5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSlcbiAgICAgICAgICAgICAgICB0aGlzLnNldERyb3BQb3MobnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYWdlbmQoKSB7XG4gICAgICAgICAgICB0aGlzLnNldERyb3BQb3MobnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRyb3AoKSB7XG4gICAgICAgICAgICB0aGlzLnNldERyb3BQb3MobnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbi8qKlxuRHJhd3MgYSBjdXJzb3IgYXQgdGhlIGN1cnJlbnQgZHJvcCBwb3NpdGlvbiB3aGVuIHNvbWV0aGluZyBpc1xuZHJhZ2dlZCBvdmVyIHRoZSBlZGl0b3IuXG4qL1xuZnVuY3Rpb24gZHJvcEN1cnNvcigpIHtcbiAgICByZXR1cm4gW2Ryb3BDdXJzb3JQb3MsIGRyYXdEcm9wQ3Vyc29yXTtcbn1cblxuZnVuY3Rpb24gaXRlck1hdGNoZXMoZG9jLCByZSwgZnJvbSwgdG8sIGYpIHtcbiAgICByZS5sYXN0SW5kZXggPSAwO1xuICAgIGZvciAobGV0IGN1cnNvciA9IGRvYy5pdGVyUmFuZ2UoZnJvbSwgdG8pLCBwb3MgPSBmcm9tLCBtOyAhY3Vyc29yLm5leHQoKS5kb25lOyBwb3MgKz0gY3Vyc29yLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICBpZiAoIWN1cnNvci5saW5lQnJlYWspXG4gICAgICAgICAgICB3aGlsZSAobSA9IHJlLmV4ZWMoY3Vyc29yLnZhbHVlKSlcbiAgICAgICAgICAgICAgICBmKHBvcyArIG0uaW5kZXgsIG0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hdGNoUmFuZ2VzKHZpZXcsIG1heExlbmd0aCkge1xuICAgIGxldCB2aXNpYmxlID0gdmlldy52aXNpYmxlUmFuZ2VzO1xuICAgIGlmICh2aXNpYmxlLmxlbmd0aCA9PSAxICYmIHZpc2libGVbMF0uZnJvbSA9PSB2aWV3LnZpZXdwb3J0LmZyb20gJiZcbiAgICAgICAgdmlzaWJsZVswXS50byA9PSB2aWV3LnZpZXdwb3J0LnRvKVxuICAgICAgICByZXR1cm4gdmlzaWJsZTtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIHZpc2libGUpIHtcbiAgICAgICAgZnJvbSA9IE1hdGgubWF4KHZpZXcuc3RhdGUuZG9jLmxpbmVBdChmcm9tKS5mcm9tLCBmcm9tIC0gbWF4TGVuZ3RoKTtcbiAgICAgICAgdG8gPSBNYXRoLm1pbih2aWV3LnN0YXRlLmRvYy5saW5lQXQodG8pLnRvLCB0byArIG1heExlbmd0aCk7XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICYmIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0udG8gPj0gZnJvbSlcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0udG8gPSB0bztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuSGVscGVyIGNsYXNzIHVzZWQgdG8gbWFrZSBpdCBlYXNpZXIgdG8gbWFpbnRhaW4gZGVjb3JhdGlvbnMgb25cbnZpc2libGUgY29kZSB0aGF0IG1hdGNoZXMgYSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24uIFRvIGJlIHVzZWRcbmluIGEgW3ZpZXcgcGx1Z2luXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuVmlld1BsdWdpbikuIEluc3RhbmNlcyBvZiB0aGlzIG9iamVjdFxucmVwcmVzZW50IGEgbWF0Y2hpbmcgY29uZmlndXJhdGlvbi5cbiovXG5jbGFzcyBNYXRjaERlY29yYXRvciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgZGVjb3JhdG9yLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHsgcmVnZXhwLCBkZWNvcmF0aW9uLCBkZWNvcmF0ZSwgYm91bmRhcnksIG1heExlbmd0aCA9IDEwMDAgfSA9IGNvbmZpZztcbiAgICAgICAgaWYgKCFyZWdleHAuZ2xvYmFsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgcmVndWxhciBleHByZXNzaW9uIGdpdmVuIHRvIE1hdGNoRGVjb3JhdG9yIHNob3VsZCBoYXZlIGl0cyAnZycgZmxhZyBzZXRcIik7XG4gICAgICAgIHRoaXMucmVnZXhwID0gcmVnZXhwO1xuICAgICAgICBpZiAoZGVjb3JhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTWF0Y2ggPSAobWF0Y2gsIHZpZXcsIGZyb20sIGFkZCkgPT4gZGVjb3JhdGUoYWRkLCBmcm9tLCBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoLCBtYXRjaCwgdmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRlY29yYXRpb24gPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE1hdGNoID0gKG1hdGNoLCB2aWV3LCBmcm9tLCBhZGQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZGVjbyA9IGRlY29yYXRpb24obWF0Y2gsIHZpZXcsIGZyb20pO1xuICAgICAgICAgICAgICAgIGlmIChkZWNvKVxuICAgICAgICAgICAgICAgICAgICBhZGQoZnJvbSwgZnJvbSArIG1hdGNoWzBdLmxlbmd0aCwgZGVjbyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlY29yYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTWF0Y2ggPSAobWF0Y2gsIF92aWV3LCBmcm9tLCBhZGQpID0+IGFkZChmcm9tLCBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoLCBkZWNvcmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRWl0aGVyICdkZWNvcmF0ZScgb3IgJ2RlY29yYXRpb24nIHNob3VsZCBiZSBwcm92aWRlZCB0byBNYXRjaERlY29yYXRvclwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvdW5kYXJ5ID0gYm91bmRhcnk7XG4gICAgICAgIHRoaXMubWF4TGVuZ3RoID0gbWF4TGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wdXRlIHRoZSBmdWxsIHNldCBvZiBkZWNvcmF0aW9ucyBmb3IgbWF0Y2hlcyBpbiB0aGUgZ2l2ZW5cbiAgICB2aWV3J3Mgdmlld3BvcnQuIFlvdSdsbCB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIGluaXRpYWxpemluZyB5b3VyXG4gICAgcGx1Z2luLlxuICAgICovXG4gICAgY3JlYXRlRGVjbyh2aWV3KSB7XG4gICAgICAgIGxldCBidWlsZCA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKSwgYWRkID0gYnVpbGQuYWRkLmJpbmQoYnVpbGQpO1xuICAgICAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgbWF0Y2hSYW5nZXModmlldywgdGhpcy5tYXhMZW5ndGgpKVxuICAgICAgICAgICAgaXRlck1hdGNoZXModmlldy5zdGF0ZS5kb2MsIHRoaXMucmVnZXhwLCBmcm9tLCB0bywgKGZyb20sIG0pID0+IHRoaXMuYWRkTWF0Y2gobSwgdmlldywgZnJvbSwgYWRkKSk7XG4gICAgICAgIHJldHVybiBidWlsZC5maW5pc2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIGEgc2V0IG9mIGRlY29yYXRpb25zIGZvciBhIHZpZXcgdXBkYXRlLiBgZGVjb2AgX211c3RfIGJlXG4gICAgdGhlIHNldCBvZiBkZWNvcmF0aW9ucyBwcm9kdWNlZCBieSBfdGhpc18gYE1hdGNoRGVjb3JhdG9yYCBmb3JcbiAgICB0aGUgdmlldyBzdGF0ZSBiZWZvcmUgdGhlIHVwZGF0ZS5cbiAgICAqL1xuICAgIHVwZGF0ZURlY28odXBkYXRlLCBkZWNvKSB7XG4gICAgICAgIGxldCBjaGFuZ2VGcm9tID0gMWU5LCBjaGFuZ2VUbyA9IC0xO1xuICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICB1cGRhdGUuY2hhbmdlcy5pdGVyQ2hhbmdlcygoX2YsIF90LCBmcm9tLCB0bykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0byA+IHVwZGF0ZS52aWV3LnZpZXdwb3J0LmZyb20gJiYgZnJvbSA8IHVwZGF0ZS52aWV3LnZpZXdwb3J0LnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUZyb20gPSBNYXRoLm1pbihmcm9tLCBjaGFuZ2VGcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlVG8gPSBNYXRoLm1heCh0bywgY2hhbmdlVG8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAodXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCB8fCBjaGFuZ2VUbyAtIGNoYW5nZUZyb20gPiAxMDAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRGVjbyh1cGRhdGUudmlldyk7XG4gICAgICAgIGlmIChjaGFuZ2VUbyA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlUmFuZ2UodXBkYXRlLnZpZXcsIGRlY28ubWFwKHVwZGF0ZS5jaGFuZ2VzKSwgY2hhbmdlRnJvbSwgY2hhbmdlVG8pO1xuICAgICAgICByZXR1cm4gZGVjbztcbiAgICB9XG4gICAgdXBkYXRlUmFuZ2UodmlldywgZGVjbywgdXBkYXRlRnJvbSwgdXBkYXRlVG8pIHtcbiAgICAgICAgZm9yIChsZXQgciBvZiB2aWV3LnZpc2libGVSYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gTWF0aC5tYXgoci5mcm9tLCB1cGRhdGVGcm9tKSwgdG8gPSBNYXRoLm1pbihyLnRvLCB1cGRhdGVUbyk7XG4gICAgICAgICAgICBpZiAodG8gPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb21MaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KGZyb20pLCB0b0xpbmUgPSBmcm9tTGluZS50byA8IHRvID8gdmlldy5zdGF0ZS5kb2MubGluZUF0KHRvKSA6IGZyb21MaW5lO1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KHIuZnJvbSwgZnJvbUxpbmUuZnJvbSksIGVuZCA9IE1hdGgubWluKHIudG8sIHRvTGluZS50byk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYm91bmRhcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGZyb20gPiBmcm9tTGluZS5mcm9tOyBmcm9tLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ib3VuZGFyeS50ZXN0KGZyb21MaW5lLnRleHRbZnJvbSAtIDEgLSBmcm9tTGluZS5mcm9tXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyB0byA8IHRvTGluZS50bzsgdG8rKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvdW5kYXJ5LnRlc3QodG9MaW5lLnRleHRbdG8gLSB0b0xpbmUuZnJvbV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdG87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByYW5nZXMgPSBbXSwgbTtcbiAgICAgICAgICAgICAgICBsZXQgYWRkID0gKGZyb20sIHRvLCBkZWNvKSA9PiByYW5nZXMucHVzaChkZWNvLnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb21MaW5lID09IHRvTGluZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZ2V4cC5sYXN0SW5kZXggPSBzdGFydCAtIGZyb21MaW5lLmZyb207XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgobSA9IHRoaXMucmVnZXhwLmV4ZWMoZnJvbUxpbmUudGV4dCkpICYmIG0uaW5kZXggPCBlbmQgLSBmcm9tTGluZS5mcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRNYXRjaChtLCB2aWV3LCBtLmluZGV4ICsgZnJvbUxpbmUuZnJvbSwgYWRkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJNYXRjaGVzKHZpZXcuc3RhdGUuZG9jLCB0aGlzLnJlZ2V4cCwgc3RhcnQsIGVuZCwgKGZyb20sIG0pID0+IHRoaXMuYWRkTWF0Y2gobSwgdmlldywgZnJvbSwgYWRkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlY28gPSBkZWNvLnVwZGF0ZSh7IGZpbHRlckZyb206IHN0YXJ0LCBmaWx0ZXJUbzogZW5kLCBmaWx0ZXI6IChmcm9tLCB0bykgPT4gZnJvbSA8IHN0YXJ0IHx8IHRvID4gZW5kLCBhZGQ6IHJhbmdlcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjbztcbiAgICB9XG59XG5cbmNvbnN0IFVuaWNvZGVSZWdleHBTdXBwb3J0ID0gL3gvLnVuaWNvZGUgIT0gbnVsbCA/IFwiZ3VcIiA6IFwiZ1wiO1xuY29uc3QgU3BlY2lhbHMgPSAvKkBfX1BVUkVfXyovbmV3IFJlZ0V4cChcIltcXHUwMDAwLVxcdTAwMDhcXHUwMDBhLVxcdTAwMWZcXHUwMDdmLVxcdTAwOWZcXHUwMGFkXFx1MDYxY1xcdTIwMGJcXHUyMDBlXFx1MjAwZlxcdTIwMjhcXHUyMDI5XFx1MjAyZFxcdTIwMmVcXHUyMDY2XFx1MjA2N1xcdTIwNjlcXHVmZWZmXFx1ZmZmOS1cXHVmZmZjXVwiLCBVbmljb2RlUmVnZXhwU3VwcG9ydCk7XG5jb25zdCBOYW1lcyA9IHtcbiAgICAwOiBcIm51bGxcIixcbiAgICA3OiBcImJlbGxcIixcbiAgICA4OiBcImJhY2tzcGFjZVwiLFxuICAgIDEwOiBcIm5ld2xpbmVcIixcbiAgICAxMTogXCJ2ZXJ0aWNhbCB0YWJcIixcbiAgICAxMzogXCJjYXJyaWFnZSByZXR1cm5cIixcbiAgICAyNzogXCJlc2NhcGVcIixcbiAgICA4MjAzOiBcInplcm8gd2lkdGggc3BhY2VcIixcbiAgICA4MjA0OiBcInplcm8gd2lkdGggbm9uLWpvaW5lclwiLFxuICAgIDgyMDU6IFwiemVybyB3aWR0aCBqb2luZXJcIixcbiAgICA4MjA2OiBcImxlZnQtdG8tcmlnaHQgbWFya1wiLFxuICAgIDgyMDc6IFwicmlnaHQtdG8tbGVmdCBtYXJrXCIsXG4gICAgODIzMjogXCJsaW5lIHNlcGFyYXRvclwiLFxuICAgIDgyMzc6IFwibGVmdC10by1yaWdodCBvdmVycmlkZVwiLFxuICAgIDgyMzg6IFwicmlnaHQtdG8tbGVmdCBvdmVycmlkZVwiLFxuICAgIDgyOTQ6IFwibGVmdC10by1yaWdodCBpc29sYXRlXCIsXG4gICAgODI5NTogXCJyaWdodC10by1sZWZ0IGlzb2xhdGVcIixcbiAgICA4Mjk3OiBcInBvcCBkaXJlY3Rpb25hbCBpc29sYXRlXCIsXG4gICAgODIzMzogXCJwYXJhZ3JhcGggc2VwYXJhdG9yXCIsXG4gICAgNjUyNzk6IFwiemVybyB3aWR0aCBuby1icmVhayBzcGFjZVwiLFxuICAgIDY1NTMyOiBcIm9iamVjdCByZXBsYWNlbWVudFwiXG59O1xubGV0IF9zdXBwb3J0c1RhYlNpemUgPSBudWxsO1xuZnVuY3Rpb24gc3VwcG9ydHNUYWJTaXplKCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoX3N1cHBvcnRzVGFiU2l6ZSA9PSBudWxsICYmIHR5cGVvZiBkb2N1bWVudCAhPSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgbGV0IHN0eWxlcyA9IGRvY3VtZW50LmJvZHkuc3R5bGU7XG4gICAgICAgIF9zdXBwb3J0c1RhYlNpemUgPSAoKF9hID0gc3R5bGVzLnRhYlNpemUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHN0eWxlcy5Nb3pUYWJTaXplKSAhPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gX3N1cHBvcnRzVGFiU2l6ZSB8fCBmYWxzZTtcbn1cbmNvbnN0IHNwZWNpYWxDaGFyQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIGxldCBjb25maWcgPSBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIHJlbmRlcjogbnVsbCxcbiAgICAgICAgICAgIHNwZWNpYWxDaGFyczogU3BlY2lhbHMsXG4gICAgICAgICAgICBhZGRTcGVjaWFsQ2hhcnM6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb25maWcucmVwbGFjZVRhYnMgPSAhc3VwcG9ydHNUYWJTaXplKCkpXG4gICAgICAgICAgICBjb25maWcuc3BlY2lhbENoYXJzID0gbmV3IFJlZ0V4cChcIlxcdHxcIiArIGNvbmZpZy5zcGVjaWFsQ2hhcnMuc291cmNlLCBVbmljb2RlUmVnZXhwU3VwcG9ydCk7XG4gICAgICAgIGlmIChjb25maWcuYWRkU3BlY2lhbENoYXJzKVxuICAgICAgICAgICAgY29uZmlnLnNwZWNpYWxDaGFycyA9IG5ldyBSZWdFeHAoY29uZmlnLnNwZWNpYWxDaGFycy5zb3VyY2UgKyBcInxcIiArIGNvbmZpZy5hZGRTcGVjaWFsQ2hhcnMuc291cmNlLCBVbmljb2RlUmVnZXhwU3VwcG9ydCk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxufSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgaW5zdGFsbHMgaGlnaGxpZ2h0aW5nIG9mIHNwZWNpYWxcbmNoYXJhY3RlcnMuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0U3BlY2lhbENoYXJzKFxuLyoqXG5Db25maWd1cmF0aW9uIG9wdGlvbnMuXG4qL1xuY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW3NwZWNpYWxDaGFyQ29uZmlnLm9mKGNvbmZpZyksIHNwZWNpYWxDaGFyUGx1Z2luKCldO1xufVxubGV0IF9wbHVnaW4gPSBudWxsO1xuZnVuY3Rpb24gc3BlY2lhbENoYXJQbHVnaW4oKSB7XG4gICAgcmV0dXJuIF9wbHVnaW4gfHwgKF9wbHVnaW4gPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9uQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0b3IgPSB0aGlzLm1ha2VEZWNvcmF0b3Iodmlldy5zdGF0ZS5mYWNldChzcGVjaWFsQ2hhckNvbmZpZykpO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdG9yLmNyZWF0ZURlY28odmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgbWFrZURlY29yYXRvcihjb25mKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hdGNoRGVjb3JhdG9yKHtcbiAgICAgICAgICAgICAgICByZWdleHA6IGNvbmYuc3BlY2lhbENoYXJzLFxuICAgICAgICAgICAgICAgIGRlY29yYXRpb246IChtLCB2aWV3LCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgZG9jIH0gPSB2aWV3LnN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29kZSA9IGNvZGVQb2ludEF0KG1bMF0sIDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA9PSA5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGluZSA9IGRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzaXplID0gdmlldy5zdGF0ZS50YWJTaXplLCBjb2wgPSBjb3VudENvbHVtbihsaW5lLnRleHQsIHNpemUsIHBvcyAtIGxpbmUuZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5yZXBsYWNlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXQ6IG5ldyBUYWJXaWRnZXQoKHNpemUgLSAoY29sICUgc2l6ZSkpICogdGhpcy52aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCAvIHRoaXMudmlldy5zY2FsZVgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvcmF0aW9uQ2FjaGVbY29kZV0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmRlY29yYXRpb25DYWNoZVtjb2RlXSA9IERlY29yYXRpb24ucmVwbGFjZSh7IHdpZGdldDogbmV3IFNwZWNpYWxDaGFyV2lkZ2V0KGNvbmYsIGNvZGUpIH0pKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5OiBjb25mLnJlcGxhY2VUYWJzID8gdW5kZWZpbmVkIDogL1teXS9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgICAgIGxldCBjb25mID0gdXBkYXRlLnN0YXRlLmZhY2V0KHNwZWNpYWxDaGFyQ29uZmlnKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChzcGVjaWFsQ2hhckNvbmZpZykgIT0gY29uZikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdG9yID0gdGhpcy5tYWtlRGVjb3JhdG9yKGNvbmYpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmRlY29yYXRvci5jcmVhdGVEZWNvKHVwZGF0ZS52aWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmRlY29yYXRvci51cGRhdGVEZWNvKHVwZGF0ZSwgdGhpcy5kZWNvcmF0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbiAgICB9KSk7XG59XG5jb25zdCBEZWZhdWx0UGxhY2Vob2xkZXIgPSBcIlxcdTIwMjJcIjtcbi8vIEFzc2lnbnMgcGxhY2Vob2xkZXIgY2hhcmFjdGVycyBmcm9tIHRoZSBDb250cm9sIFBpY3R1cmVzIGJsb2NrIHRvXG4vLyBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnNcbmZ1bmN0aW9uIHBsYWNlaG9sZGVyJDEoY29kZSkge1xuICAgIGlmIChjb2RlID49IDMyKVxuICAgICAgICByZXR1cm4gRGVmYXVsdFBsYWNlaG9sZGVyO1xuICAgIGlmIChjb2RlID09IDEwKVxuICAgICAgICByZXR1cm4gXCJcXHUyNDI0XCI7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoOTIxNiArIGNvZGUpO1xufVxuY2xhc3MgU3BlY2lhbENoYXJXaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjb2RlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlci5jb2RlID09IHRoaXMuY29kZTsgfVxuICAgIHRvRE9NKHZpZXcpIHtcbiAgICAgICAgbGV0IHBoID0gcGxhY2Vob2xkZXIkMSh0aGlzLmNvZGUpO1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuc3RhdGUucGhyYXNlKFwiQ29udHJvbCBjaGFyYWN0ZXJcIikgKyBcIiBcIiArIChOYW1lc1t0aGlzLmNvZGVdIHx8IFwiMHhcIiArIHRoaXMuY29kZS50b1N0cmluZygxNikpO1xuICAgICAgICBsZXQgY3VzdG9tID0gdGhpcy5vcHRpb25zLnJlbmRlciAmJiB0aGlzLm9wdGlvbnMucmVuZGVyKHRoaXMuY29kZSwgZGVzYywgcGgpO1xuICAgICAgICBpZiAoY3VzdG9tKVxuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbTtcbiAgICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IHBoO1xuICAgICAgICBzcGFuLnRpdGxlID0gZGVzYztcbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIGRlc2MpO1xuICAgICAgICBzcGFuLmNsYXNzTmFtZSA9IFwiY20tc3BlY2lhbENoYXJcIjtcbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxuICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbmNsYXNzIFRhYldpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHdpZHRoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLndpZHRoID09IHRoaXMud2lkdGg7IH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IFwiXFx0XCI7XG4gICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS10YWJcIjtcbiAgICAgICAgc3Bhbi5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyBcInB4XCI7XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbiAgICBpZ25vcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5cbmNvbnN0IHBsdWdpbiA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMTAwMDtcbiAgICAgICAgdGhpcy5hdHRycyA9IHsgc3R5bGU6IFwicGFkZGluZy1ib3R0b206IDEwMDBweFwiIH07XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdXBkYXRlO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gdmlldy52aWV3U3RhdGUuZWRpdG9ySGVpZ2h0ICogdmlldy5zY2FsZVkgLVxuICAgICAgICAgICAgdmlldy5kZWZhdWx0TGluZUhlaWdodCAtIHZpZXcuZG9jdW1lbnRQYWRkaW5nLnRvcCAtIDAuNTtcbiAgICAgICAgaWYgKGhlaWdodCA+PSAwICYmIGhlaWdodCAhPSB0aGlzLmhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmF0dHJzID0geyBzdHlsZTogYHBhZGRpbmctYm90dG9tOiAke2hlaWdodH1weGAgfTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IG1ha2VzIHN1cmUgdGhlIGNvbnRlbnQgaGFzIGEgYm90dG9tXG5tYXJnaW4gZXF1aXZhbGVudCB0byB0aGUgaGVpZ2h0IG9mIHRoZSBlZGl0b3IsIG1pbnVzIG9uZSBsaW5lXG5oZWlnaHQsIHNvIHRoYXQgZXZlcnkgbGluZSBpbiB0aGUgZG9jdW1lbnQgY2FuIGJlIHNjcm9sbGVkIHRvIHRoZVxudG9wIG9mIHRoZSBlZGl0b3IuXG5cblRoaXMgaXMgb25seSBtZWFuaW5nZnVsIHdoZW4gdGhlIGVkaXRvciBpcyBzY3JvbGxhYmxlLCBhbmQgc2hvdWxkXG5ub3QgYmUgZW5hYmxlZCBpbiBlZGl0b3JzIHRoYXQgdGFrZSB0aGUgc2l6ZSBvZiB0aGVpciBjb250ZW50LlxuKi9cbmZ1bmN0aW9uIHNjcm9sbFBhc3RFbmQoKSB7XG4gICAgcmV0dXJuIFtwbHVnaW4sIGNvbnRlbnRBdHRyaWJ1dGVzLm9mKHZpZXcgPT4geyB2YXIgX2E7IHJldHVybiAoKF9hID0gdmlldy5wbHVnaW4ocGx1Z2luKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF0dHJzKSB8fCBudWxsOyB9KV07XG59XG5cbi8qKlxuTWFyayBsaW5lcyB0aGF0IGhhdmUgYSBjdXJzb3Igb24gdGhlbSB3aXRoIHRoZSBgXCJjbS1hY3RpdmVMaW5lXCJgXG5ET00gY2xhc3MuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0QWN0aXZlTGluZSgpIHtcbiAgICByZXR1cm4gYWN0aXZlTGluZUhpZ2hsaWdodGVyO1xufVxuY29uc3QgbGluZURlY28gPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5saW5lKHsgY2xhc3M6IFwiY20tYWN0aXZlTGluZVwiIH0pO1xuY29uc3QgYWN0aXZlTGluZUhpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmdldERlY28odmlldyk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5zZWxlY3Rpb25TZXQpXG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5nZXREZWNvKHVwZGF0ZS52aWV3KTtcbiAgICB9XG4gICAgZ2V0RGVjbyh2aWV3KSB7XG4gICAgICAgIGxldCBsYXN0TGluZVN0YXJ0ID0gLTEsIGRlY28gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgciBvZiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdChyLmhlYWQpO1xuICAgICAgICAgICAgaWYgKGxpbmUuZnJvbSA+IGxhc3RMaW5lU3RhcnQpIHtcbiAgICAgICAgICAgICAgICBkZWNvLnB1c2gobGluZURlY28ucmFuZ2UobGluZS5mcm9tKSk7XG4gICAgICAgICAgICAgICAgbGFzdExpbmVTdGFydCA9IGxpbmUuZnJvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQoZGVjbyk7XG4gICAgfVxufSwge1xuICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbn0pO1xuXG5jbGFzcyBQbGFjZWhvbGRlciBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRlbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB9XG4gICAgdG9ET00oKSB7XG4gICAgICAgIGxldCB3cmFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHdyYXAuY2xhc3NOYW1lID0gXCJjbS1wbGFjZWhvbGRlclwiO1xuICAgICAgICB3cmFwLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgICAgICAgd3JhcC5hcHBlbmRDaGlsZCh0eXBlb2YgdGhpcy5jb250ZW50ID09IFwic3RyaW5nXCIgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLmNvbnRlbnQpIDogdGhpcy5jb250ZW50KTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvbnRlbnQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHdyYXAuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBcInBsYWNlaG9sZGVyIFwiICsgdGhpcy5jb250ZW50KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgd3JhcC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgIHJldHVybiB3cmFwO1xuICAgIH1cbiAgICBjb29yZHNBdChkb20pIHtcbiAgICAgICAgbGV0IHJlY3RzID0gZG9tLmZpcnN0Q2hpbGQgPyBjbGllbnRSZWN0c0Zvcihkb20uZmlyc3RDaGlsZCkgOiBbXTtcbiAgICAgICAgaWYgKCFyZWN0cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9tLnBhcmVudE5vZGUpO1xuICAgICAgICBsZXQgcmVjdCA9IGZsYXR0ZW5SZWN0KHJlY3RzWzBdLCBzdHlsZS5kaXJlY3Rpb24gIT0gXCJydGxcIik7XG4gICAgICAgIGxldCBsaW5lSGVpZ2h0ID0gcGFyc2VJbnQoc3R5bGUubGluZUhlaWdodCk7XG4gICAgICAgIGlmIChyZWN0LmJvdHRvbSAtIHJlY3QudG9wID4gbGluZUhlaWdodCAqIDEuNSlcbiAgICAgICAgICAgIHJldHVybiB7IGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QucmlnaHQsIHRvcDogcmVjdC50b3AsIGJvdHRvbTogcmVjdC50b3AgKyBsaW5lSGVpZ2h0IH07XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH1cbiAgICBpZ25vcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG4vKipcbkV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgYSBwbGFjZWhvbGRlcuKAlGEgcGllY2Ugb2YgZXhhbXBsZSBjb250ZW50XG50byBzaG93IHdoZW4gdGhlIGVkaXRvciBpcyBlbXB0eS5cbiovXG5mdW5jdGlvbiBwbGFjZWhvbGRlcihjb250ZW50KSB7XG4gICAgcmV0dXJuIFZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICAgICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBjb250ZW50XG4gICAgICAgICAgICAgICAgPyBEZWNvcmF0aW9uLnNldChbRGVjb3JhdGlvbi53aWRnZXQoeyB3aWRnZXQ6IG5ldyBQbGFjZWhvbGRlcihjb250ZW50KSwgc2lkZTogMSB9KS5yYW5nZSgwKV0pXG4gICAgICAgICAgICAgICAgOiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGRlY29yYXRpb25zKCkgeyByZXR1cm4gdGhpcy52aWV3LnN0YXRlLmRvYy5sZW5ndGggPyBEZWNvcmF0aW9uLm5vbmUgOiB0aGlzLnBsYWNlaG9sZGVyOyB9XG4gICAgfSwgeyBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zIH0pO1xufVxuXG4vLyBEb24ndCBjb21wdXRlIHByZWNpc2UgY29sdW1uIHBvc2l0aW9ucyBmb3IgbGluZSBvZmZzZXRzIGFib3ZlIHRoaXNcbi8vIChzaW5jZSBpdCBjb3VsZCBnZXQgZXhwZW5zaXZlKS4gQXNzdW1lIG9mZnNldD09Y29sdW1uIGZvciB0aGVtLlxuY29uc3QgTWF4T2ZmID0gMjAwMDtcbmZ1bmN0aW9uIHJlY3RhbmdsZUZvcihzdGF0ZSwgYSwgYikge1xuICAgIGxldCBzdGFydExpbmUgPSBNYXRoLm1pbihhLmxpbmUsIGIubGluZSksIGVuZExpbmUgPSBNYXRoLm1heChhLmxpbmUsIGIubGluZSk7XG4gICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgIGlmIChhLm9mZiA+IE1heE9mZiB8fCBiLm9mZiA+IE1heE9mZiB8fCBhLmNvbCA8IDAgfHwgYi5jb2wgPCAwKSB7XG4gICAgICAgIGxldCBzdGFydE9mZiA9IE1hdGgubWluKGEub2ZmLCBiLm9mZiksIGVuZE9mZiA9IE1hdGgubWF4KGEub2ZmLCBiLm9mZik7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydExpbmU7IGkgPD0gZW5kTGluZTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lKGkpO1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoIDw9IGVuZE9mZilcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChFZGl0b3JTZWxlY3Rpb24ucmFuZ2UobGluZS5mcm9tICsgc3RhcnRPZmYsIGxpbmUudG8gKyBlbmRPZmYpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHN0YXJ0Q29sID0gTWF0aC5taW4oYS5jb2wsIGIuY29sKSwgZW5kQ29sID0gTWF0aC5tYXgoYS5jb2wsIGIuY29sKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0TGluZTsgaSA8PSBlbmRMaW5lOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmUoaSk7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBmaW5kQ29sdW1uKGxpbmUudGV4dCwgc3RhcnRDb2wsIHN0YXRlLnRhYlNpemUsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobGluZS50bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IGZpbmRDb2x1bW4obGluZS50ZXh0LCBlbmRDb2wsIHN0YXRlLnRhYlNpemUpO1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5yYW5nZShsaW5lLmZyb20gKyBzdGFydCwgbGluZS5mcm9tICsgZW5kKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlcztcbn1cbmZ1bmN0aW9uIGFic29sdXRlQ29sdW1uKHZpZXcsIHgpIHtcbiAgICBsZXQgcmVmID0gdmlldy5jb29yZHNBdFBvcyh2aWV3LnZpZXdwb3J0LmZyb20pO1xuICAgIHJldHVybiByZWYgPyBNYXRoLnJvdW5kKE1hdGguYWJzKChyZWYubGVmdCAtIHgpIC8gdmlldy5kZWZhdWx0Q2hhcmFjdGVyV2lkdGgpKSA6IC0xO1xufVxuZnVuY3Rpb24gZ2V0UG9zKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IG9mZnNldCA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0sIGZhbHNlKTtcbiAgICBsZXQgbGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChvZmZzZXQpLCBvZmYgPSBvZmZzZXQgLSBsaW5lLmZyb207XG4gICAgbGV0IGNvbCA9IG9mZiA+IE1heE9mZiA/IC0xXG4gICAgICAgIDogb2ZmID09IGxpbmUubGVuZ3RoID8gYWJzb2x1dGVDb2x1bW4odmlldywgZXZlbnQuY2xpZW50WClcbiAgICAgICAgICAgIDogY291bnRDb2x1bW4obGluZS50ZXh0LCB2aWV3LnN0YXRlLnRhYlNpemUsIG9mZnNldCAtIGxpbmUuZnJvbSk7XG4gICAgcmV0dXJuIHsgbGluZTogbGluZS5udW1iZXIsIGNvbCwgb2ZmIH07XG59XG5mdW5jdGlvbiByZWN0YW5nbGVTZWxlY3Rpb25TdHlsZSh2aWV3LCBldmVudCkge1xuICAgIGxldCBzdGFydCA9IGdldFBvcyh2aWV3LCBldmVudCksIHN0YXJ0U2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCFzdGFydClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1N0YXJ0ID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHVwZGF0ZS5zdGFydFN0YXRlLmRvYy5saW5lKHN0YXJ0LmxpbmUpLmZyb20pO1xuICAgICAgICAgICAgICAgIGxldCBuZXdMaW5lID0gdXBkYXRlLnN0YXRlLmRvYy5saW5lQXQobmV3U3RhcnQpO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0geyBsaW5lOiBuZXdMaW5lLm51bWJlciwgY29sOiBzdGFydC5jb2wsIG9mZjogTWF0aC5taW4oc3RhcnQub2ZmLCBuZXdMaW5lLmxlbmd0aCkgfTtcbiAgICAgICAgICAgICAgICBzdGFydFNlbCA9IHN0YXJ0U2VsLm1hcCh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldChldmVudCwgX2V4dGVuZCwgbXVsdGlwbGUpIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSBnZXRQb3ModmlldywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFjdXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0U2VsO1xuICAgICAgICAgICAgbGV0IHJhbmdlcyA9IHJlY3RhbmdsZUZvcih2aWV3LnN0YXRlLCBzdGFydCwgY3VyKTtcbiAgICAgICAgICAgIGlmICghcmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRTZWw7XG4gICAgICAgICAgICBpZiAobXVsdGlwbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLmNvbmNhdChzdGFydFNlbC5yYW5nZXMpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgcmVjdGFuZ3VsYXIgc2VsZWN0aW9ucy4gQnlcbmRlZmF1bHQsIGl0IHdpbGwgcmVhY3QgdG8gbGVmdCBtb3VzZSBkcmFnIHdpdGggdGhlIEFsdCBrZXkgaGVsZFxuZG93bi4gV2hlbiBzdWNoIGEgc2VsZWN0aW9uIG9jY3VycywgdGhlIHRleHQgd2l0aGluIHRoZSByZWN0YW5nbGVcbnRoYXQgd2FzIGRyYWdnZWQgb3ZlciB3aWxsIGJlIHNlbGVjdGVkLCBhcyBvbmUgc2VsZWN0aW9uXG5bcmFuZ2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU2VsZWN0aW9uUmFuZ2UpIHBlciBsaW5lLlxuKi9cbmZ1bmN0aW9uIHJlY3Rhbmd1bGFyU2VsZWN0aW9uKG9wdGlvbnMpIHtcbiAgICBsZXQgZmlsdGVyID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ldmVudEZpbHRlcikgfHwgKGUgPT4gZS5hbHRLZXkgJiYgZS5idXR0b24gPT0gMCk7XG4gICAgcmV0dXJuIEVkaXRvclZpZXcubW91c2VTZWxlY3Rpb25TdHlsZS5vZigodmlldywgZXZlbnQpID0+IGZpbHRlcihldmVudCkgPyByZWN0YW5nbGVTZWxlY3Rpb25TdHlsZSh2aWV3LCBldmVudCkgOiBudWxsKTtcbn1cbmNvbnN0IGtleXMgPSB7XG4gICAgQWx0OiBbMTgsIGUgPT4gISFlLmFsdEtleV0sXG4gICAgQ29udHJvbDogWzE3LCBlID0+ICEhZS5jdHJsS2V5XSxcbiAgICBTaGlmdDogWzE2LCBlID0+ICEhZS5zaGlmdEtleV0sXG4gICAgTWV0YTogWzkxLCBlID0+ICEhZS5tZXRhS2V5XVxufTtcbmNvbnN0IHNob3dDcm9zc2hhaXIgPSB7IHN0eWxlOiBcImN1cnNvcjogY3Jvc3NoYWlyXCIgfTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCB0dXJucyB0aGUgcG9pbnRlciBjdXJzb3IgaW50byBhXG5jcm9zc2hhaXIgd2hlbiBhIGdpdmVuIG1vZGlmaWVyIGtleSwgZGVmYXVsdGluZyB0byBBbHQsIGlzIGhlbGRcbmRvd24uIENhbiBzZXJ2ZSBhcyBhIHZpc3VhbCBoaW50IHRoYXQgcmVjdGFuZ3VsYXIgc2VsZWN0aW9uIGlzXG5nb2luZyB0byBoYXBwZW4gd2hlbiBwYWlyZWQgd2l0aFxuW2ByZWN0YW5ndWxhclNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5yZWN0YW5ndWxhclNlbGVjdGlvbikuXG4qL1xuZnVuY3Rpb24gY3Jvc3NoYWlyQ3Vyc29yKG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBbY29kZSwgZ2V0dGVyXSA9IGtleXNbb3B0aW9ucy5rZXkgfHwgXCJBbHRcIl07XG4gICAgbGV0IHBsdWdpbiA9IFZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICAgICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgICAgIHRoaXMuaXNEb3duID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KGlzRG93bikge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEb3duICE9IGlzRG93bikge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNEb3duID0gaXNEb3duO1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy51cGRhdGUoW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBldmVudE9ic2VydmVyczoge1xuICAgICAgICAgICAga2V5ZG93bihlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoZS5rZXlDb2RlID09IGNvZGUgfHwgZ2V0dGVyKGUpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBrZXl1cChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PSBjb2RlIHx8ICFnZXR0ZXIoZSkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb3VzZW1vdmUoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGdldHRlcihlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gW1xuICAgICAgICBwbHVnaW4sXG4gICAgICAgIEVkaXRvclZpZXcuY29udGVudEF0dHJpYnV0ZXMub2YodmlldyA9PiB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSB2aWV3LnBsdWdpbihwbHVnaW4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNEb3duKSA/IHNob3dDcm9zc2hhaXIgOiBudWxsOyB9KVxuICAgIF07XG59XG5cbmNvbnN0IE91dHNpZGUgPSBcIi0xMDAwMHB4XCI7XG5jbGFzcyBUb29sdGlwVmlld01hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIGZhY2V0LCBjcmVhdGVUb29sdGlwVmlldywgcmVtb3ZlVG9vbHRpcFZpZXcpIHtcbiAgICAgICAgdGhpcy5mYWNldCA9IGZhY2V0O1xuICAgICAgICB0aGlzLmNyZWF0ZVRvb2x0aXBWaWV3ID0gY3JlYXRlVG9vbHRpcFZpZXc7XG4gICAgICAgIHRoaXMucmVtb3ZlVG9vbHRpcFZpZXcgPSByZW1vdmVUb29sdGlwVmlldztcbiAgICAgICAgdGhpcy5pbnB1dCA9IHZpZXcuc3RhdGUuZmFjZXQoZmFjZXQpO1xuICAgICAgICB0aGlzLnRvb2x0aXBzID0gdGhpcy5pbnB1dC5maWx0ZXIodCA9PiB0KTtcbiAgICAgICAgdGhpcy50b29sdGlwVmlld3MgPSB0aGlzLnRvb2x0aXBzLm1hcChjcmVhdGVUb29sdGlwVmlldyk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUsIGFib3ZlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGlucHV0ID0gdXBkYXRlLnN0YXRlLmZhY2V0KHRoaXMuZmFjZXQpO1xuICAgICAgICBsZXQgdG9vbHRpcHMgPSBpbnB1dC5maWx0ZXIoeCA9PiB4KTtcbiAgICAgICAgaWYgKGlucHV0ID09PSB0aGlzLmlucHV0KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgICAgIGlmICh0LnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgdC51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9vbHRpcFZpZXdzID0gW10sIG5ld0Fib3ZlID0gYWJvdmUgPyBbXSA6IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9vbHRpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0aXAgPSB0b29sdGlwc1tpXSwga25vd24gPSAtMTtcbiAgICAgICAgICAgIGlmICghdGlwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRvb2x0aXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG90aGVyID0gdGhpcy50b29sdGlwc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAob3RoZXIgJiYgb3RoZXIuY3JlYXRlID09IHRpcC5jcmVhdGUpXG4gICAgICAgICAgICAgICAgICAgIGtub3duID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrbm93biA8IDApIHtcbiAgICAgICAgICAgICAgICB0b29sdGlwVmlld3NbaV0gPSB0aGlzLmNyZWF0ZVRvb2x0aXBWaWV3KHRpcCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0Fib3ZlKVxuICAgICAgICAgICAgICAgICAgICBuZXdBYm92ZVtpXSA9ICEhdGlwLmFib3ZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHRvb2x0aXBWaWV3ID0gdG9vbHRpcFZpZXdzW2ldID0gdGhpcy50b29sdGlwVmlld3Nba25vd25dO1xuICAgICAgICAgICAgICAgIGlmIChuZXdBYm92ZSlcbiAgICAgICAgICAgICAgICAgICAgbmV3QWJvdmVbaV0gPSBhYm92ZVtrbm93bl07XG4gICAgICAgICAgICAgICAgaWYgKHRvb2x0aXBWaWV3LnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcFZpZXcudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgIGlmICh0b29sdGlwVmlld3MuaW5kZXhPZih0KSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVRvb2x0aXBWaWV3KHQpO1xuICAgICAgICAgICAgICAgIChfYSA9IHQuZGVzdHJveSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGlmIChhYm92ZSkge1xuICAgICAgICAgICAgbmV3QWJvdmUuZm9yRWFjaCgodmFsLCBpKSA9PiBhYm92ZVtpXSA9IHZhbCk7XG4gICAgICAgICAgICBhYm92ZS5sZW5ndGggPSBuZXdBYm92ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLnRvb2x0aXBzID0gdG9vbHRpcHM7XG4gICAgICAgIHRoaXMudG9vbHRpcFZpZXdzID0gdG9vbHRpcFZpZXdzO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4vKipcbkNyZWF0ZXMgYW4gZXh0ZW5zaW9uIHRoYXQgY29uZmlndXJlcyB0b29sdGlwIGJlaGF2aW9yLlxuKi9cbmZ1bmN0aW9uIHRvb2x0aXBzKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIHRvb2x0aXBDb25maWcub2YoY29uZmlnKTtcbn1cbmZ1bmN0aW9uIHdpbmRvd1NwYWNlKHZpZXcpIHtcbiAgICBsZXQgeyB3aW4gfSA9IHZpZXc7XG4gICAgcmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwLCBib3R0b206IHdpbi5pbm5lckhlaWdodCwgcmlnaHQ6IHdpbi5pbm5lcldpZHRoIH07XG59XG5jb25zdCB0b29sdGlwQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgcG9zaXRpb246IGJyb3dzZXIuaW9zID8gXCJhYnNvbHV0ZVwiIDogKChfYSA9IHZhbHVlcy5maW5kKGNvbmYgPT4gY29uZi5wb3NpdGlvbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wb3NpdGlvbikgfHwgXCJmaXhlZFwiLFxuICAgICAgICAgICAgcGFyZW50OiAoKF9iID0gdmFsdWVzLmZpbmQoY29uZiA9PiBjb25mLnBhcmVudCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wYXJlbnQpIHx8IG51bGwsXG4gICAgICAgICAgICB0b29sdGlwU3BhY2U6ICgoX2MgPSB2YWx1ZXMuZmluZChjb25mID0+IGNvbmYudG9vbHRpcFNwYWNlKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvb2x0aXBTcGFjZSkgfHwgd2luZG93U3BhY2UsXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuY29uc3Qga25vd25IZWlnaHQgPSAvKkBfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHRvb2x0aXBQbHVnaW4gPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5hYm92ZSA9IFtdO1xuICAgICAgICB0aGlzLmluVmlldyA9IHRydWU7XG4gICAgICAgIHRoaXMubWFkZUFic29sdXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFzdFRyYW5zYWN0aW9uID0gMDtcbiAgICAgICAgdGhpcy5tZWFzdXJlVGltZW91dCA9IC0xO1xuICAgICAgICBsZXQgY29uZmlnID0gdmlldy5zdGF0ZS5mYWNldCh0b29sdGlwQ29uZmlnKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IGNvbmZpZy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBjb25maWcucGFyZW50O1xuICAgICAgICB0aGlzLmNsYXNzZXMgPSB2aWV3LnRoZW1lQ2xhc3NlcztcbiAgICAgICAgdGhpcy5jcmVhdGVDb250YWluZXIoKTtcbiAgICAgICAgdGhpcy5tZWFzdXJlUmVxID0geyByZWFkOiB0aGlzLnJlYWRNZWFzdXJlLmJpbmQodGhpcyksIHdyaXRlOiB0aGlzLndyaXRlTWVhc3VyZS5iaW5kKHRoaXMpLCBrZXk6IHRoaXMgfTtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIgPyBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4gdGhpcy5tZWFzdXJlU29vbigpKSA6IG51bGw7XG4gICAgICAgIHRoaXMubWFuYWdlciA9IG5ldyBUb29sdGlwVmlld01hbmFnZXIodmlldywgc2hvd1Rvb2x0aXAsIHQgPT4gdGhpcy5jcmVhdGVUb29sdGlwKHQpLCB0ID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc2l6ZU9ic2VydmVyKVxuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKHQuZG9tKTtcbiAgICAgICAgICAgIHQuZG9tLnJlbW92ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hYm92ZSA9IHRoaXMubWFuYWdlci50b29sdGlwcy5tYXAodCA9PiAhIXQuYWJvdmUpO1xuICAgICAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyID0gdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09IFwiZnVuY3Rpb25cIiA/IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICAgICAgICAgIGlmIChEYXRlLm5vdygpID4gdGhpcy5sYXN0VHJhbnNhY3Rpb24gLSA1MCAmJlxuICAgICAgICAgICAgICAgIGVudHJpZXMubGVuZ3RoID4gMCAmJiBlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV0uaW50ZXJzZWN0aW9uUmF0aW8gPCAxKVxuICAgICAgICAgICAgICAgIHRoaXMubWVhc3VyZVNvb24oKTtcbiAgICAgICAgfSwgeyB0aHJlc2hvbGQ6IFsxXSB9KSA6IG51bGw7XG4gICAgICAgIHRoaXMub2JzZXJ2ZUludGVyc2VjdGlvbigpO1xuICAgICAgICB2aWV3Lndpbi5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMubWVhc3VyZVNvb24gPSB0aGlzLm1lYXN1cmVTb29uLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLm1heWJlTWVhc3VyZSgpO1xuICAgIH1cbiAgICBjcmVhdGVDb250YWluZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSB0aGlzLnZpZXcudGhlbWVDbGFzc2VzO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5jb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLnZpZXcuZG9tO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9ic2VydmVJbnRlcnNlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHRvb2x0aXAgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyLm9ic2VydmUodG9vbHRpcC5kb20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lYXN1cmVTb29uKCkge1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlVGltZW91dCA8IDApXG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZWFzdXJlVGltZW91dCA9IC0xO1xuICAgICAgICAgICAgICAgIHRoaXMubWF5YmVNZWFzdXJlKCk7XG4gICAgICAgICAgICB9LCA1MCk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5sYXN0VHJhbnNhY3Rpb24gPSBEYXRlLm5vdygpO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IHRoaXMubWFuYWdlci51cGRhdGUodXBkYXRlLCB0aGlzLmFib3ZlKTtcbiAgICAgICAgaWYgKHVwZGF0ZWQpXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVJbnRlcnNlY3Rpb24oKTtcbiAgICAgICAgbGV0IHNob3VsZE1lYXN1cmUgPSB1cGRhdGVkIHx8IHVwZGF0ZS5nZW9tZXRyeUNoYW5nZWQ7XG4gICAgICAgIGxldCBuZXdDb25maWcgPSB1cGRhdGUuc3RhdGUuZmFjZXQodG9vbHRpcENvbmZpZyk7XG4gICAgICAgIGlmIChuZXdDb25maWcucG9zaXRpb24gIT0gdGhpcy5wb3NpdGlvbiAmJiAhdGhpcy5tYWRlQWJzb2x1dGUpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBuZXdDb25maWcucG9zaXRpb247XG4gICAgICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgdC5kb20uc3R5bGUucG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICAgICAgc2hvdWxkTWVhc3VyZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0NvbmZpZy5wYXJlbnQgIT0gdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudClcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gbmV3Q29uZmlnLnBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlQ29udGFpbmVyKCk7XG4gICAgICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodC5kb20pO1xuICAgICAgICAgICAgc2hvdWxkTWVhc3VyZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wYXJlbnQgJiYgdGhpcy52aWV3LnRoZW1lQ2xhc3NlcyAhPSB0aGlzLmNsYXNzZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NlcyA9IHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IHRoaXMudmlldy50aGVtZUNsYXNzZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZE1lYXN1cmUpXG4gICAgICAgICAgICB0aGlzLm1heWJlTWVhc3VyZSgpO1xuICAgIH1cbiAgICBjcmVhdGVUb29sdGlwKHRvb2x0aXApIHtcbiAgICAgICAgbGV0IHRvb2x0aXBWaWV3ID0gdG9vbHRpcC5jcmVhdGUodGhpcy52aWV3KTtcbiAgICAgICAgdG9vbHRpcFZpZXcuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS10b29sdGlwXCIpO1xuICAgICAgICBpZiAodG9vbHRpcC5hcnJvdyAmJiAhdG9vbHRpcFZpZXcuZG9tLnF1ZXJ5U2VsZWN0b3IoXCIuY20tdG9vbHRpcCA+IC5jbS10b29sdGlwLWFycm93XCIpKSB7XG4gICAgICAgICAgICBsZXQgYXJyb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgYXJyb3cuY2xhc3NOYW1lID0gXCJjbS10b29sdGlwLWFycm93XCI7XG4gICAgICAgICAgICB0b29sdGlwVmlldy5kb20uYXBwZW5kQ2hpbGQoYXJyb3cpO1xuICAgICAgICB9XG4gICAgICAgIHRvb2x0aXBWaWV3LmRvbS5zdHlsZS5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIHRvb2x0aXBWaWV3LmRvbS5zdHlsZS50b3AgPSBPdXRzaWRlO1xuICAgICAgICB0b29sdGlwVmlldy5kb20uc3R5bGUubGVmdCA9IFwiMHB4XCI7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRvb2x0aXBWaWV3LmRvbSk7XG4gICAgICAgIGlmICh0b29sdGlwVmlldy5tb3VudClcbiAgICAgICAgICAgIHRvb2x0aXBWaWV3Lm1vdW50KHRoaXMudmlldyk7XG4gICAgICAgIGlmICh0aGlzLnJlc2l6ZU9ic2VydmVyKVxuICAgICAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRvb2x0aXBWaWV3LmRvbSk7XG4gICAgICAgIHJldHVybiB0b29sdGlwVmlldztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRoaXMudmlldy53aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLm1lYXN1cmVTb29uKTtcbiAgICAgICAgZm9yIChsZXQgdG9vbHRpcFZpZXcgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cykge1xuICAgICAgICAgICAgdG9vbHRpcFZpZXcuZG9tLnJlbW92ZSgpO1xuICAgICAgICAgICAgKF9hID0gdG9vbHRpcFZpZXcuZGVzdHJveSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodG9vbHRpcFZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhcmVudClcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgICAoX2IgPSB0aGlzLnJlc2l6ZU9ic2VydmVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlzY29ubmVjdCgpO1xuICAgICAgICAoX2MgPSB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZGlzY29ubmVjdCgpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5tZWFzdXJlVGltZW91dCk7XG4gICAgfVxuICAgIHJlYWRNZWFzdXJlKCkge1xuICAgICAgICBsZXQgZWRpdG9yID0gdGhpcy52aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IHNjYWxlWCA9IDEsIHNjYWxlWSA9IDEsIG1ha2VBYnNvbHV0ZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PSBcImZpeGVkXCIgJiYgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCB7IGRvbSB9ID0gdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3c1swXTtcbiAgICAgICAgICAgIGlmIChicm93c2VyLmdlY2tvKSB7XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCBzZXRzIHRoZSBlbGVtZW50J3MgYG9mZnNldFBhcmVudGAgdG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtZWQgZWxlbWVudCB3aGVuIGEgdHJhbnNmb3JtIGludGVyZmVyZXMgd2l0aCBmaXhlZFxuICAgICAgICAgICAgICAgIC8vIHBvc2l0aW9uaW5nLlxuICAgICAgICAgICAgICAgIG1ha2VBYnNvbHV0ZSA9IGRvbS5vZmZzZXRQYXJlbnQgIT0gdGhpcy5jb250YWluZXIub3duZXJEb2N1bWVudC5ib2R5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZG9tLnN0eWxlLnRvcCA9PSBPdXRzaWRlICYmIGRvbS5zdHlsZS5sZWZ0ID09IFwiMHB4XCIpIHtcbiAgICAgICAgICAgICAgICAvLyBPbiBvdGhlciBicm93c2Vycywgd2UgaGF2ZSB0byBhd2t3YXJkbHkgdHJ5IGFuZCB1c2Ugb3RoZXJcbiAgICAgICAgICAgICAgICAvLyBpbmZvcm1hdGlvbiB0byBkZXRlY3QgYSB0cmFuc2Zvcm0uXG4gICAgICAgICAgICAgICAgbGV0IHJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgbWFrZUFic29sdXRlID0gTWF0aC5hYnMocmVjdC50b3AgKyAxMDAwMCkgPiAxIHx8IE1hdGguYWJzKHJlY3QubGVmdCkgPiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYWtlQWJzb2x1dGUgfHwgdGhpcy5wb3NpdGlvbiA9PSBcImFic29sdXRlXCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIGxldCByZWN0ID0gdGhpcy5wYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3Qud2lkdGggJiYgcmVjdC5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVYID0gcmVjdC53aWR0aCAvIHRoaXMucGFyZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBzY2FsZVkgPSByZWN0LmhlaWdodCAvIHRoaXMucGFyZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAoeyBzY2FsZVgsIHNjYWxlWSB9ID0gdGhpcy52aWV3LnZpZXdTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIHBhcmVudDogdGhpcy5wYXJlbnQgPyB0aGlzLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IGVkaXRvcixcbiAgICAgICAgICAgIHBvczogdGhpcy5tYW5hZ2VyLnRvb2x0aXBzLm1hcCgodCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB0diA9IHRoaXMubWFuYWdlci50b29sdGlwVmlld3NbaV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR2LmdldENvb3JkcyA/IHR2LmdldENvb3Jkcyh0LnBvcykgOiB0aGlzLnZpZXcuY29vcmRzQXRQb3ModC5wb3MpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBzaXplOiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzLm1hcCgoeyBkb20gfSkgPT4gZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSxcbiAgICAgICAgICAgIHNwYWNlOiB0aGlzLnZpZXcuc3RhdGUuZmFjZXQodG9vbHRpcENvbmZpZykudG9vbHRpcFNwYWNlKHRoaXMudmlldyksXG4gICAgICAgICAgICBzY2FsZVgsIHNjYWxlWSwgbWFrZUFic29sdXRlXG4gICAgICAgIH07XG4gICAgfVxuICAgIHdyaXRlTWVhc3VyZShtZWFzdXJlZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChtZWFzdXJlZC5tYWtlQWJzb2x1dGUpIHtcbiAgICAgICAgICAgIHRoaXMubWFkZUFic29sdXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgdC5kb20uc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgZWRpdG9yLCBzcGFjZSwgc2NhbGVYLCBzY2FsZVkgfSA9IG1lYXN1cmVkO1xuICAgICAgICBsZXQgb3RoZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYW5hZ2VyLnRvb2x0aXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdG9vbHRpcCA9IHRoaXMubWFuYWdlci50b29sdGlwc1tpXSwgdFZpZXcgPSB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzW2ldLCB7IGRvbSB9ID0gdFZpZXc7XG4gICAgICAgICAgICBsZXQgcG9zID0gbWVhc3VyZWQucG9zW2ldLCBzaXplID0gbWVhc3VyZWQuc2l6ZVtpXTtcbiAgICAgICAgICAgIC8vIEhpZGUgdG9vbHRpcHMgdGhhdCBhcmUgb3V0c2lkZSBvZiB0aGUgZWRpdG9yLlxuICAgICAgICAgICAgaWYgKCFwb3MgfHwgcG9zLmJvdHRvbSA8PSBNYXRoLm1heChlZGl0b3IudG9wLCBzcGFjZS50b3ApIHx8XG4gICAgICAgICAgICAgICAgcG9zLnRvcCA+PSBNYXRoLm1pbihlZGl0b3IuYm90dG9tLCBzcGFjZS5ib3R0b20pIHx8XG4gICAgICAgICAgICAgICAgcG9zLnJpZ2h0IDwgTWF0aC5tYXgoZWRpdG9yLmxlZnQsIHNwYWNlLmxlZnQpIC0gLjEgfHxcbiAgICAgICAgICAgICAgICBwb3MubGVmdCA+IE1hdGgubWluKGVkaXRvci5yaWdodCwgc3BhY2UucmlnaHQpICsgLjEpIHtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUudG9wID0gT3V0c2lkZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBhcnJvdyA9IHRvb2x0aXAuYXJyb3cgPyB0Vmlldy5kb20ucXVlcnlTZWxlY3RvcihcIi5jbS10b29sdGlwLWFycm93XCIpIDogbnVsbDtcbiAgICAgICAgICAgIGxldCBhcnJvd0hlaWdodCA9IGFycm93ID8gNyAvKiBBcnJvdy5TaXplICovIDogMDtcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IHNpemUucmlnaHQgLSBzaXplLmxlZnQsIGhlaWdodCA9IChfYSA9IGtub3duSGVpZ2h0LmdldCh0VmlldykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHNpemUuYm90dG9tIC0gc2l6ZS50b3A7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gdFZpZXcub2Zmc2V0IHx8IG5vT2Zmc2V0LCBsdHIgPSB0aGlzLnZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSO1xuICAgICAgICAgICAgbGV0IGxlZnQgPSBzaXplLndpZHRoID4gc3BhY2UucmlnaHQgLSBzcGFjZS5sZWZ0ID8gKGx0ciA/IHNwYWNlLmxlZnQgOiBzcGFjZS5yaWdodCAtIHNpemUud2lkdGgpXG4gICAgICAgICAgICAgICAgOiBsdHIgPyBNYXRoLm1pbihwb3MubGVmdCAtIChhcnJvdyA/IDE0IC8qIEFycm93Lk9mZnNldCAqLyA6IDApICsgb2Zmc2V0LngsIHNwYWNlLnJpZ2h0IC0gd2lkdGgpXG4gICAgICAgICAgICAgICAgICAgIDogTWF0aC5tYXgoc3BhY2UubGVmdCwgcG9zLmxlZnQgLSB3aWR0aCArIChhcnJvdyA/IDE0IC8qIEFycm93Lk9mZnNldCAqLyA6IDApIC0gb2Zmc2V0LngpO1xuICAgICAgICAgICAgbGV0IGFib3ZlID0gdGhpcy5hYm92ZVtpXTtcbiAgICAgICAgICAgIGlmICghdG9vbHRpcC5zdHJpY3RTaWRlICYmIChhYm92ZVxuICAgICAgICAgICAgICAgID8gcG9zLnRvcCAtIChzaXplLmJvdHRvbSAtIHNpemUudG9wKSAtIG9mZnNldC55IDwgc3BhY2UudG9wXG4gICAgICAgICAgICAgICAgOiBwb3MuYm90dG9tICsgKHNpemUuYm90dG9tIC0gc2l6ZS50b3ApICsgb2Zmc2V0LnkgPiBzcGFjZS5ib3R0b20pICYmXG4gICAgICAgICAgICAgICAgYWJvdmUgPT0gKHNwYWNlLmJvdHRvbSAtIHBvcy5ib3R0b20gPiBwb3MudG9wIC0gc3BhY2UudG9wKSlcbiAgICAgICAgICAgICAgICBhYm92ZSA9IHRoaXMuYWJvdmVbaV0gPSAhYWJvdmU7XG4gICAgICAgICAgICBsZXQgc3BhY2VWZXJ0ID0gKGFib3ZlID8gcG9zLnRvcCAtIHNwYWNlLnRvcCA6IHNwYWNlLmJvdHRvbSAtIHBvcy5ib3R0b20pIC0gYXJyb3dIZWlnaHQ7XG4gICAgICAgICAgICBpZiAoc3BhY2VWZXJ0IDwgaGVpZ2h0ICYmIHRWaWV3LnJlc2l6ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BhY2VWZXJ0IDwgdGhpcy52aWV3LmRlZmF1bHRMaW5lSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbS5zdHlsZS50b3AgPSBPdXRzaWRlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga25vd25IZWlnaHQuc2V0KHRWaWV3LCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5oZWlnaHQgPSAoaGVpZ2h0ID0gc3BhY2VWZXJ0KSAvIHNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRvbS5zdHlsZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUuaGVpZ2h0ID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0b3AgPSBhYm92ZSA/IHBvcy50b3AgLSBoZWlnaHQgLSBhcnJvd0hlaWdodCAtIG9mZnNldC55IDogcG9zLmJvdHRvbSArIGFycm93SGVpZ2h0ICsgb2Zmc2V0Lnk7XG4gICAgICAgICAgICBsZXQgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG4gICAgICAgICAgICBpZiAodFZpZXcub3ZlcmxhcCAhPT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIG90aGVycylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIubGVmdCA8IHJpZ2h0ICYmIHIucmlnaHQgPiBsZWZ0ICYmIHIudG9wIDwgdG9wICsgaGVpZ2h0ICYmIHIuYm90dG9tID4gdG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0gYWJvdmUgPyByLnRvcCAtIGhlaWdodCAtIDIgLSBhcnJvd0hlaWdodCA6IHIuYm90dG9tICsgYXJyb3dIZWlnaHQgKyAyO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT0gXCJhYnNvbHV0ZVwiKSB7XG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLnRvcCA9ICh0b3AgLSBtZWFzdXJlZC5wYXJlbnQudG9wKSAvIHNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUubGVmdCA9IChsZWZ0IC0gbWVhc3VyZWQucGFyZW50LmxlZnQpIC8gc2NhbGVYICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLnRvcCA9IHRvcCAvIHNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUubGVmdCA9IGxlZnQgLyBzY2FsZVggKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJyb3cpIHtcbiAgICAgICAgICAgICAgICBsZXQgYXJyb3dMZWZ0ID0gcG9zLmxlZnQgKyAobHRyID8gb2Zmc2V0LnggOiAtb2Zmc2V0LngpIC0gKGxlZnQgKyAxNCAvKiBBcnJvdy5PZmZzZXQgKi8gLSA3IC8qIEFycm93LlNpemUgKi8pO1xuICAgICAgICAgICAgICAgIGFycm93LnN0eWxlLmxlZnQgPSBhcnJvd0xlZnQgLyBzY2FsZVggKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodFZpZXcub3ZlcmxhcCAhPT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICBvdGhlcnMucHVzaCh7IGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbTogdG9wICsgaGVpZ2h0IH0pO1xuICAgICAgICAgICAgZG9tLmNsYXNzTGlzdC50b2dnbGUoXCJjbS10b29sdGlwLWFib3ZlXCIsIGFib3ZlKTtcbiAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QudG9nZ2xlKFwiY20tdG9vbHRpcC1iZWxvd1wiLCAhYWJvdmUpO1xuICAgICAgICAgICAgaWYgKHRWaWV3LnBvc2l0aW9uZWQpXG4gICAgICAgICAgICAgICAgdFZpZXcucG9zaXRpb25lZChtZWFzdXJlZC5zcGFjZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWF5YmVNZWFzdXJlKCkge1xuICAgICAgICBpZiAodGhpcy5tYW5hZ2VyLnRvb2x0aXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmlldy5pblZpZXcpXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XG4gICAgICAgICAgICBpZiAodGhpcy5pblZpZXcgIT0gdGhpcy52aWV3LmluVmlldykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5WaWV3ID0gdGhpcy52aWV3LmluVmlldztcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaW5WaWV3KVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0diBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgICAgICAgICAgICAgdHYuZG9tLnN0eWxlLnRvcCA9IE91dHNpZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59LCB7XG4gICAgZXZlbnRPYnNlcnZlcnM6IHtcbiAgICAgICAgc2Nyb2xsKCkgeyB0aGlzLm1heWJlTWVhc3VyZSgpOyB9XG4gICAgfVxufSk7XG5jb25zdCBiYXNlVGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLXRvb2x0aXBcIjoge1xuICAgICAgICB6SW5kZXg6IDEwMCxcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXRvb2x0aXBcIjoge1xuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICNiYmJcIixcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmNWY1ZjVcIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXRvb2x0aXAtc2VjdGlvbjpub3QoOmZpcnN0LWNoaWxkKVwiOiB7XG4gICAgICAgIGJvcmRlclRvcDogXCIxcHggc29saWQgI2JiYlwiLFxuICAgIH0sXG4gICAgXCImZGFyayAuY20tdG9vbHRpcFwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMzMzMzM4XCIsXG4gICAgICAgIGNvbG9yOiBcIndoaXRlXCJcbiAgICB9LFxuICAgIFwiLmNtLXRvb2x0aXAtYXJyb3dcIjoge1xuICAgICAgICBoZWlnaHQ6IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weGAsXG4gICAgICAgIHdpZHRoOiBgJHs3IC8qIEFycm93LlNpemUgKi8gKiAyfXB4YCxcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgekluZGV4OiAtMSxcbiAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgICAgIFwiJjpiZWZvcmUsICY6YWZ0ZXJcIjoge1xuICAgICAgICAgICAgY29udGVudDogXCInJ1wiLFxuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgYm9yZGVyTGVmdDogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkIHRyYW5zcGFyZW50YCxcbiAgICAgICAgICAgIGJvcmRlclJpZ2h0OiBgJHs3IC8qIEFycm93LlNpemUgKi99cHggc29saWQgdHJhbnNwYXJlbnRgLFxuICAgICAgICB9LFxuICAgICAgICBcIi5jbS10b29sdGlwLWFib3ZlICZcIjoge1xuICAgICAgICAgICAgYm90dG9tOiBgLSR7NyAvKiBBcnJvdy5TaXplICovfXB4YCxcbiAgICAgICAgICAgIFwiJjpiZWZvcmVcIjoge1xuICAgICAgICAgICAgICAgIGJvcmRlclRvcDogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkICNiYmJgLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiJjphZnRlclwiOiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyVG9wOiBgJHs3IC8qIEFycm93LlNpemUgKi99cHggc29saWQgI2Y1ZjVmNWAsXG4gICAgICAgICAgICAgICAgYm90dG9tOiBcIjFweFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiLmNtLXRvb2x0aXAtYmVsb3cgJlwiOiB7XG4gICAgICAgICAgICB0b3A6IGAtJHs3IC8qIEFycm93LlNpemUgKi99cHhgLFxuICAgICAgICAgICAgXCImOmJlZm9yZVwiOiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tOiBgJHs3IC8qIEFycm93LlNpemUgKi99cHggc29saWQgI2JiYmAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCImOmFmdGVyXCI6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCAjZjVmNWY1YCxcbiAgICAgICAgICAgICAgICB0b3A6IFwiMXB4XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXRvb2x0aXAgLmNtLXRvb2x0aXAtYXJyb3dcIjoge1xuICAgICAgICBcIiY6YmVmb3JlXCI6IHtcbiAgICAgICAgICAgIGJvcmRlclRvcENvbG9yOiBcIiMzMzMzMzhcIixcbiAgICAgICAgICAgIGJvcmRlckJvdHRvbUNvbG9yOiBcIiMzMzMzMzhcIlxuICAgICAgICB9LFxuICAgICAgICBcIiY6YWZ0ZXJcIjoge1xuICAgICAgICAgICAgYm9yZGVyVG9wQ29sb3I6IFwidHJhbnNwYXJlbnRcIixcbiAgICAgICAgICAgIGJvcmRlckJvdHRvbUNvbG9yOiBcInRyYW5zcGFyZW50XCJcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuY29uc3Qgbm9PZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcbi8qKlxuRmFjZXQgdG8gd2hpY2ggYW4gZXh0ZW5zaW9uIGNhbiBhZGQgYSB2YWx1ZSB0byBzaG93IGEgdG9vbHRpcC5cbiovXG5jb25zdCBzaG93VG9vbHRpcCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGVuYWJsZXM6IFt0b29sdGlwUGx1Z2luLCBiYXNlVGhlbWVdXG59KTtcbmNvbnN0IHNob3dIb3ZlclRvb2x0aXAgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jbGFzcyBIb3ZlclRvb2x0aXBIb3N0IHtcbiAgICAvLyBOZWVkcyB0byBiZSBzdGF0aWMgc28gdGhhdCBob3N0IHRvb2x0aXAgaW5zdGFuY2VzIGFsd2F5cyBtYXRjaFxuICAgIHN0YXRpYyBjcmVhdGUodmlldykge1xuICAgICAgICByZXR1cm4gbmV3IEhvdmVyVG9vbHRpcEhvc3Qodmlldyk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5tb3VudGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LmFkZChcImNtLXRvb2x0aXAtaG92ZXJcIik7XG4gICAgICAgIHRoaXMubWFuYWdlciA9IG5ldyBUb29sdGlwVmlld01hbmFnZXIodmlldywgc2hvd0hvdmVyVG9vbHRpcCwgdCA9PiB0aGlzLmNyZWF0ZUhvc3RlZFZpZXcodCksIHQgPT4gdC5kb20ucmVtb3ZlKCkpO1xuICAgIH1cbiAgICBjcmVhdGVIb3N0ZWRWaWV3KHRvb2x0aXApIHtcbiAgICAgICAgbGV0IGhvc3RlZFZpZXcgPSB0b29sdGlwLmNyZWF0ZSh0aGlzLnZpZXcpO1xuICAgICAgICBob3N0ZWRWaWV3LmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tdG9vbHRpcC1zZWN0aW9uXCIpO1xuICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZChob3N0ZWRWaWV3LmRvbSk7XG4gICAgICAgIGlmICh0aGlzLm1vdW50ZWQgJiYgaG9zdGVkVmlldy5tb3VudClcbiAgICAgICAgICAgIGhvc3RlZFZpZXcubW91bnQodGhpcy52aWV3KTtcbiAgICAgICAgcmV0dXJuIGhvc3RlZFZpZXc7XG4gICAgfVxuICAgIG1vdW50KHZpZXcpIHtcbiAgICAgICAgZm9yIChsZXQgaG9zdGVkVmlldyBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKSB7XG4gICAgICAgICAgICBpZiAoaG9zdGVkVmlldy5tb3VudClcbiAgICAgICAgICAgICAgICBob3N0ZWRWaWV3Lm1vdW50KHZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW91bnRlZCA9IHRydWU7XG4gICAgfVxuICAgIHBvc2l0aW9uZWQoc3BhY2UpIHtcbiAgICAgICAgZm9yIChsZXQgaG9zdGVkVmlldyBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKSB7XG4gICAgICAgICAgICBpZiAoaG9zdGVkVmlldy5wb3NpdGlvbmVkKVxuICAgICAgICAgICAgICAgIGhvc3RlZFZpZXcucG9zaXRpb25lZChzcGFjZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICB0aGlzLm1hbmFnZXIudXBkYXRlKHVwZGF0ZSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgKF9hID0gdC5kZXN0cm95KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0KTtcbiAgICB9XG4gICAgcGFzc1Byb3AobmFtZSkge1xuICAgICAgICBsZXQgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAobGV0IHZpZXcgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cykge1xuICAgICAgICAgICAgbGV0IGdpdmVuID0gdmlld1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChnaXZlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2l2ZW47XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgIT09IGdpdmVuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IG9mZnNldCgpIHsgcmV0dXJuIHRoaXMucGFzc1Byb3AoXCJvZmZzZXRcIik7IH1cbiAgICBnZXQgZ2V0Q29vcmRzKCkgeyByZXR1cm4gdGhpcy5wYXNzUHJvcChcImdldENvb3Jkc1wiKTsgfVxuICAgIGdldCBvdmVybGFwKCkgeyByZXR1cm4gdGhpcy5wYXNzUHJvcChcIm92ZXJsYXBcIik7IH1cbiAgICBnZXQgcmVzaXplKCkgeyByZXR1cm4gdGhpcy5wYXNzUHJvcChcInJlc2l6ZVwiKTsgfVxufVxuY29uc3Qgc2hvd0hvdmVyVG9vbHRpcEhvc3QgPSAvKkBfX1BVUkVfXyovc2hvd1Rvb2x0aXAuY29tcHV0ZShbc2hvd0hvdmVyVG9vbHRpcF0sIHN0YXRlID0+IHtcbiAgICBsZXQgdG9vbHRpcHMgPSBzdGF0ZS5mYWNldChzaG93SG92ZXJUb29sdGlwKS5maWx0ZXIodCA9PiB0KTtcbiAgICBpZiAodG9vbHRpcHMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb3M6IE1hdGgubWluKC4uLnRvb2x0aXBzLm1hcCh0ID0+IHQucG9zKSksXG4gICAgICAgIGVuZDogTWF0aC5tYXgoLi4udG9vbHRpcHMubWFwKHQgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSB0LmVuZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdC5wb3M7IH0pKSxcbiAgICAgICAgY3JlYXRlOiBIb3ZlclRvb2x0aXBIb3N0LmNyZWF0ZSxcbiAgICAgICAgYWJvdmU6IHRvb2x0aXBzWzBdLmFib3ZlLFxuICAgICAgICBhcnJvdzogdG9vbHRpcHMuc29tZSh0ID0+IHQuYXJyb3cpLFxuICAgIH07XG59KTtcbmNsYXNzIEhvdmVyUGx1Z2luIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBzb3VyY2UsIGZpZWxkLCBzZXRIb3ZlciwgaG92ZXJUaW1lKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIHRoaXMuc2V0SG92ZXIgPSBzZXRIb3ZlcjtcbiAgICAgICAgdGhpcy5ob3ZlclRpbWUgPSBob3ZlclRpbWU7XG4gICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMucmVzdGFydFRpbWVvdXQgPSAtMTtcbiAgICAgICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0TW92ZSA9IHsgeDogMCwgeTogMCwgdGFyZ2V0OiB2aWV3LmRvbSwgdGltZTogMCB9O1xuICAgICAgICB0aGlzLmNoZWNrSG92ZXIgPSB0aGlzLmNoZWNrSG92ZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgdGhpcy5tb3VzZWxlYXZlID0gdGhpcy5tb3VzZWxlYXZlLmJpbmQodGhpcykpO1xuICAgICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW91c2Vtb3ZlID0gdGhpcy5tb3VzZW1vdmUuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZykge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc3RhcnRUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMucmVzdGFydFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc3RhcnRIb3ZlcigpLCAyMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGFjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5zdGF0ZS5maWVsZCh0aGlzLmZpZWxkKTtcbiAgICB9XG4gICAgY2hlY2tIb3ZlcigpIHtcbiAgICAgICAgdGhpcy5ob3ZlclRpbWVvdXQgPSAtMTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgaG92ZXJlZCA9IERhdGUubm93KCkgLSB0aGlzLmxhc3RNb3ZlLnRpbWU7XG4gICAgICAgIGlmIChob3ZlcmVkIDwgdGhpcy5ob3ZlclRpbWUpXG4gICAgICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5jaGVja0hvdmVyLCB0aGlzLmhvdmVyVGltZSAtIGhvdmVyZWQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnN0YXJ0SG92ZXIoKTtcbiAgICB9XG4gICAgc3RhcnRIb3ZlcigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVzdGFydFRpbWVvdXQpO1xuICAgICAgICBsZXQgeyB2aWV3LCBsYXN0TW92ZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IGRlc2MgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdChsYXN0TW92ZS50YXJnZXQpO1xuICAgICAgICBpZiAoIWRlc2MpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBwb3MsIHNpZGUgPSAxO1xuICAgICAgICBpZiAoZGVzYyBpbnN0YW5jZW9mIFdpZGdldFZpZXcpIHtcbiAgICAgICAgICAgIHBvcyA9IGRlc2MucG9zQXRTdGFydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvcyA9IHZpZXcucG9zQXRDb29yZHMobGFzdE1vdmUpO1xuICAgICAgICAgICAgaWYgKHBvcyA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCBwb3NDb29yZHMgPSB2aWV3LmNvb3Jkc0F0UG9zKHBvcyk7XG4gICAgICAgICAgICBpZiAoIXBvc0Nvb3JkcyB8fFxuICAgICAgICAgICAgICAgIGxhc3RNb3ZlLnkgPCBwb3NDb29yZHMudG9wIHx8IGxhc3RNb3ZlLnkgPiBwb3NDb29yZHMuYm90dG9tIHx8XG4gICAgICAgICAgICAgICAgbGFzdE1vdmUueCA8IHBvc0Nvb3Jkcy5sZWZ0IC0gdmlldy5kZWZhdWx0Q2hhcmFjdGVyV2lkdGggfHxcbiAgICAgICAgICAgICAgICBsYXN0TW92ZS54ID4gcG9zQ29vcmRzLnJpZ2h0ICsgdmlldy5kZWZhdWx0Q2hhcmFjdGVyV2lkdGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IGJpZGkgPSB2aWV3LmJpZGlTcGFucyh2aWV3LnN0YXRlLmRvYy5saW5lQXQocG9zKSkuZmluZChzID0+IHMuZnJvbSA8PSBwb3MgJiYgcy50byA+PSBwb3MpO1xuICAgICAgICAgICAgbGV0IHJ0bCA9IGJpZGkgJiYgYmlkaS5kaXIgPT0gRGlyZWN0aW9uLlJUTCA/IC0xIDogMTtcbiAgICAgICAgICAgIHNpZGUgPSAobGFzdE1vdmUueCA8IHBvc0Nvb3Jkcy5sZWZ0ID8gLXJ0bCA6IHJ0bCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9wZW4gPSB0aGlzLnNvdXJjZSh2aWV3LCBwb3MsIHNpZGUpO1xuICAgICAgICBpZiAob3BlbiA9PT0gbnVsbCB8fCBvcGVuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcGVuLnRoZW4pIHtcbiAgICAgICAgICAgIGxldCBwZW5kaW5nID0gdGhpcy5wZW5kaW5nID0geyBwb3MgfTtcbiAgICAgICAgICAgIG9wZW4udGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmcgPT0gcGVuZGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2YocmVzdWx0KSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBlID0+IGxvZ0V4Y2VwdGlvbih2aWV3LnN0YXRlLCBlLCBcImhvdmVyIHRvb2x0aXBcIikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0aGlzLnNldEhvdmVyLm9mKG9wZW4pIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB0b29sdGlwKCkge1xuICAgICAgICBsZXQgcGx1Z2luID0gdGhpcy52aWV3LnBsdWdpbih0b29sdGlwUGx1Z2luKTtcbiAgICAgICAgbGV0IGluZGV4ID0gcGx1Z2luID8gcGx1Z2luLm1hbmFnZXIudG9vbHRpcHMuZmluZEluZGV4KHQgPT4gdC5jcmVhdGUgPT0gSG92ZXJUb29sdGlwSG9zdC5jcmVhdGUpIDogLTE7XG4gICAgICAgIHJldHVybiBpbmRleCA+IC0xID8gcGx1Z2luLm1hbmFnZXIudG9vbHRpcFZpZXdzW2luZGV4XSA6IG51bGw7XG4gICAgfVxuICAgIG1vdXNlbW92ZShldmVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMubGFzdE1vdmUgPSB7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFksIHRhcmdldDogZXZlbnQudGFyZ2V0LCB0aW1lOiBEYXRlLm5vdygpIH07XG4gICAgICAgIGlmICh0aGlzLmhvdmVyVGltZW91dCA8IDApXG4gICAgICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5jaGVja0hvdmVyLCB0aGlzLmhvdmVyVGltZSk7XG4gICAgICAgIGxldCB7IGFjdGl2ZSwgdG9vbHRpcCB9ID0gdGhpcztcbiAgICAgICAgaWYgKGFjdGl2ZSAmJiB0b29sdGlwICYmICFpc0luVG9vbHRpcCh0b29sdGlwLmRvbSwgZXZlbnQpIHx8IHRoaXMucGVuZGluZykge1xuICAgICAgICAgICAgbGV0IHsgcG9zIH0gPSBhY3RpdmUgfHwgdGhpcy5wZW5kaW5nLCBlbmQgPSAoX2EgPSBhY3RpdmUgPT09IG51bGwgfHwgYWN0aXZlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3RpdmUuZW5kKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBwb3M7XG4gICAgICAgICAgICBpZiAoKHBvcyA9PSBlbmQgPyB0aGlzLnZpZXcucG9zQXRDb29yZHModGhpcy5sYXN0TW92ZSkgIT0gcG9zXG4gICAgICAgICAgICAgICAgOiAhaXNPdmVyUmFuZ2UodGhpcy52aWV3LCBwb3MsIGVuZCwgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdGhpcy5zZXRIb3Zlci5vZihudWxsKSB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG1vdXNlbGVhdmUoZXZlbnQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaG92ZXJUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5ob3ZlclRpbWVvdXQgPSAtMTtcbiAgICAgICAgbGV0IHsgYWN0aXZlIH0gPSB0aGlzO1xuICAgICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgICAgICBsZXQgeyB0b29sdGlwIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IGluVG9vbHRpcCA9IHRvb2x0aXAgJiYgdG9vbHRpcC5kb20uY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCk7XG4gICAgICAgICAgICBpZiAoIWluVG9vbHRpcClcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0aGlzLnNldEhvdmVyLm9mKG51bGwpIH0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMud2F0Y2hUb29sdGlwTGVhdmUodG9vbHRpcC5kb20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdhdGNoVG9vbHRpcExlYXZlKHRvb2x0aXApIHtcbiAgICAgICAgbGV0IHdhdGNoID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0b29sdGlwLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHdhdGNoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZSAmJiAhdGhpcy52aWV3LmRvbS5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSlcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0aGlzLnNldEhvdmVyLm9mKG51bGwpIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0b29sdGlwLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHdhdGNoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaG92ZXJUaW1lb3V0KTtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB0aGlzLm1vdXNlbGVhdmUpO1xuICAgICAgICB0aGlzLnZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3VzZW1vdmUpO1xuICAgIH1cbn1cbmNvbnN0IHRvb2x0aXBNYXJnaW4gPSA0O1xuZnVuY3Rpb24gaXNJblRvb2x0aXAodG9vbHRpcCwgZXZlbnQpIHtcbiAgICBsZXQgcmVjdCA9IHRvb2x0aXAuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIGV2ZW50LmNsaWVudFggPj0gcmVjdC5sZWZ0IC0gdG9vbHRpcE1hcmdpbiAmJiBldmVudC5jbGllbnRYIDw9IHJlY3QucmlnaHQgKyB0b29sdGlwTWFyZ2luICYmXG4gICAgICAgIGV2ZW50LmNsaWVudFkgPj0gcmVjdC50b3AgLSB0b29sdGlwTWFyZ2luICYmIGV2ZW50LmNsaWVudFkgPD0gcmVjdC5ib3R0b20gKyB0b29sdGlwTWFyZ2luO1xufVxuZnVuY3Rpb24gaXNPdmVyUmFuZ2UodmlldywgZnJvbSwgdG8sIHgsIHksIG1hcmdpbikge1xuICAgIGxldCByZWN0ID0gdmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IGRvY0JvdHRvbSA9IHZpZXcuZG9jdW1lbnRUb3AgKyB2aWV3LmRvY3VtZW50UGFkZGluZy50b3AgKyB2aWV3LmNvbnRlbnRIZWlnaHQ7XG4gICAgaWYgKHJlY3QubGVmdCA+IHggfHwgcmVjdC5yaWdodCA8IHggfHwgcmVjdC50b3AgPiB5IHx8IE1hdGgubWluKHJlY3QuYm90dG9tLCBkb2NCb3R0b20pIDwgeSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeCwgeSB9LCBmYWxzZSk7XG4gICAgcmV0dXJuIHBvcyA+PSBmcm9tICYmIHBvcyA8PSB0bztcbn1cbi8qKlxuU2V0IHVwIGEgaG92ZXIgdG9vbHRpcCwgd2hpY2ggc2hvd3MgdXAgd2hlbiB0aGUgcG9pbnRlciBob3ZlcnNcbm92ZXIgcmFuZ2VzIG9mIHRleHQuIFRoZSBjYWxsYmFjayBpcyBjYWxsZWQgd2hlbiB0aGUgbW91c2UgaG92ZXJzXG5vdmVyIHRoZSBkb2N1bWVudCB0ZXh0LiBJdCBzaG91bGQsIGlmIHRoZXJlIGlzIGEgdG9vbHRpcFxuYXNzb2NpYXRlZCB3aXRoIHBvc2l0aW9uIGBwb3NgLCByZXR1cm4gdGhlIHRvb2x0aXAgZGVzY3JpcHRpb25cbihlaXRoZXIgZGlyZWN0bHkgb3IgaW4gYSBwcm9taXNlKS4gVGhlIGBzaWRlYCBhcmd1bWVudCBpbmRpY2F0ZXNcbm9uIHdoaWNoIHNpZGUgb2YgdGhlIHBvc2l0aW9uIHRoZSBwb2ludGVyIGlz4oCUaXQgd2lsbCBiZSAtMSBpZiB0aGVcbnBvaW50ZXIgaXMgYmVmb3JlIHRoZSBwb3NpdGlvbiwgMSBpZiBhZnRlciB0aGUgcG9zaXRpb24uXG5cbk5vdGUgdGhhdCBhbGwgaG92ZXIgdG9vbHRpcHMgYXJlIGhvc3RlZCB3aXRoaW4gYSBzaW5nbGUgdG9vbHRpcFxuY29udGFpbmVyIGVsZW1lbnQuIFRoaXMgYWxsb3dzIG11bHRpcGxlIHRvb2x0aXBzIG92ZXIgdGhlIHNhbWVcbnJhbmdlIHRvIGJlIFwibWVyZ2VkXCIgdG9nZXRoZXIgd2l0aG91dCBvdmVybGFwcGluZy5cbiovXG5mdW5jdGlvbiBob3ZlclRvb2x0aXAoc291cmNlLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgc2V0SG92ZXIgPSBTdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbiAgICBsZXQgaG92ZXJTdGF0ZSA9IFN0YXRlRmllbGQuZGVmaW5lKHtcbiAgICAgICAgY3JlYXRlKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIChvcHRpb25zLmhpZGVPbkNoYW5nZSAmJiAodHIuZG9jQ2hhbmdlZCB8fCB0ci5zZWxlY3Rpb24pIHx8XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5oaWRlT24gJiYgb3B0aW9ucy5oaWRlT24odHIsIHZhbHVlKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdHIuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGxldCBuZXdQb3MgPSB0ci5jaGFuZ2VzLm1hcFBvcyh2YWx1ZS5wb3MsIC0xLCBNYXBNb2RlLlRyYWNrRGVsKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3UG9zID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBjb3B5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgY29weS5wb3MgPSBuZXdQb3M7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmVuZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBjb3B5LmVuZCA9IHRyLmNoYW5nZXMubWFwUG9zKHZhbHVlLmVuZCk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjb3B5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldEhvdmVyKSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBlZmZlY3QudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhjbG9zZUhvdmVyVG9vbHRpcEVmZmVjdCkpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJvdmlkZTogZiA9PiBzaG93SG92ZXJUb29sdGlwLmZyb20oZilcbiAgICB9KTtcbiAgICByZXR1cm4gW1xuICAgICAgICBob3ZlclN0YXRlLFxuICAgICAgICBWaWV3UGx1Z2luLmRlZmluZSh2aWV3ID0+IG5ldyBIb3ZlclBsdWdpbih2aWV3LCBzb3VyY2UsIGhvdmVyU3RhdGUsIHNldEhvdmVyLCBvcHRpb25zLmhvdmVyVGltZSB8fCAzMDAgLyogSG92ZXIuVGltZSAqLykpLFxuICAgICAgICBzaG93SG92ZXJUb29sdGlwSG9zdFxuICAgIF07XG59XG4vKipcbkdldCB0aGUgYWN0aXZlIHRvb2x0aXAgdmlldyBmb3IgYSBnaXZlbiB0b29sdGlwLCBpZiBhdmFpbGFibGUuXG4qL1xuZnVuY3Rpb24gZ2V0VG9vbHRpcCh2aWV3LCB0b29sdGlwKSB7XG4gICAgbGV0IHBsdWdpbiA9IHZpZXcucGx1Z2luKHRvb2x0aXBQbHVnaW4pO1xuICAgIGlmICghcGx1Z2luKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgZm91bmQgPSBwbHVnaW4ubWFuYWdlci50b29sdGlwcy5pbmRleE9mKHRvb2x0aXApO1xuICAgIHJldHVybiBmb3VuZCA8IDAgPyBudWxsIDogcGx1Z2luLm1hbmFnZXIudG9vbHRpcFZpZXdzW2ZvdW5kXTtcbn1cbi8qKlxuUmV0dXJucyB0cnVlIGlmIGFueSBob3ZlciB0b29sdGlwcyBhcmUgY3VycmVudGx5IGFjdGl2ZS5cbiovXG5mdW5jdGlvbiBoYXNIb3ZlclRvb2x0aXBzKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLmZhY2V0KHNob3dIb3ZlclRvb2x0aXApLnNvbWUoeCA9PiB4KTtcbn1cbmNvbnN0IGNsb3NlSG92ZXJUb29sdGlwRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuLyoqXG5UcmFuc2FjdGlvbiBlZmZlY3QgdGhhdCBjbG9zZXMgYWxsIGhvdmVyIHRvb2x0aXBzLlxuKi9cbmNvbnN0IGNsb3NlSG92ZXJUb29sdGlwcyA9IC8qQF9fUFVSRV9fKi9jbG9zZUhvdmVyVG9vbHRpcEVmZmVjdC5vZihudWxsKTtcbi8qKlxuVGVsbCB0aGUgdG9vbHRpcCBleHRlbnNpb24gdG8gcmVjb21wdXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgYWN0aXZlXG50b29sdGlwcy4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gc29tZXRoaW5nIGhhcHBlbnMgKHN1Y2ggYXMgYVxucmUtcG9zaXRpb25pbmcgb3IgQ1NTIGNoYW5nZSBhZmZlY3RpbmcgdGhlIGVkaXRvcikgdGhhdCBjb3VsZFxuaW52YWxpZGF0ZSB0aGUgZXhpc3RpbmcgdG9vbHRpcCBwb3NpdGlvbnMuXG4qL1xuZnVuY3Rpb24gcmVwb3NpdGlvblRvb2x0aXBzKHZpZXcpIHtcbiAgICBsZXQgcGx1Z2luID0gdmlldy5wbHVnaW4odG9vbHRpcFBsdWdpbik7XG4gICAgaWYgKHBsdWdpbilcbiAgICAgICAgcGx1Z2luLm1heWJlTWVhc3VyZSgpO1xufVxuXG5jb25zdCBwYW5lbENvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICBsZXQgdG9wQ29udGFpbmVyLCBib3R0b21Db250YWluZXI7XG4gICAgICAgIGZvciAobGV0IGMgb2YgY29uZmlncykge1xuICAgICAgICAgICAgdG9wQ29udGFpbmVyID0gdG9wQ29udGFpbmVyIHx8IGMudG9wQ29udGFpbmVyO1xuICAgICAgICAgICAgYm90dG9tQ29udGFpbmVyID0gYm90dG9tQ29udGFpbmVyIHx8IGMuYm90dG9tQ29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHRvcENvbnRhaW5lciwgYm90dG9tQ29udGFpbmVyIH07XG4gICAgfVxufSk7XG4vKipcbkNvbmZpZ3VyZXMgdGhlIHBhbmVsLW1hbmFnaW5nIGV4dGVuc2lvbi5cbiovXG5mdW5jdGlvbiBwYW5lbHMoY29uZmlnKSB7XG4gICAgcmV0dXJuIGNvbmZpZyA/IFtwYW5lbENvbmZpZy5vZihjb25maWcpXSA6IFtdO1xufVxuLyoqXG5HZXQgdGhlIGFjdGl2ZSBwYW5lbCBjcmVhdGVkIGJ5IHRoZSBnaXZlbiBjb25zdHJ1Y3RvciwgaWYgYW55LlxuVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4geW91IG5lZWQgYWNjZXNzIHRvIHlvdXIgcGFuZWxzJyBET01cbnN0cnVjdHVyZS5cbiovXG5mdW5jdGlvbiBnZXRQYW5lbCh2aWV3LCBwYW5lbCkge1xuICAgIGxldCBwbHVnaW4gPSB2aWV3LnBsdWdpbihwYW5lbFBsdWdpbik7XG4gICAgbGV0IGluZGV4ID0gcGx1Z2luID8gcGx1Z2luLnNwZWNzLmluZGV4T2YocGFuZWwpIDogLTE7XG4gICAgcmV0dXJuIGluZGV4ID4gLTEgPyBwbHVnaW4ucGFuZWxzW2luZGV4XSA6IG51bGw7XG59XG5jb25zdCBwYW5lbFBsdWdpbiA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLmlucHV0ID0gdmlldy5zdGF0ZS5mYWNldChzaG93UGFuZWwpO1xuICAgICAgICB0aGlzLnNwZWNzID0gdGhpcy5pbnB1dC5maWx0ZXIocyA9PiBzKTtcbiAgICAgICAgdGhpcy5wYW5lbHMgPSB0aGlzLnNwZWNzLm1hcChzcGVjID0+IHNwZWModmlldykpO1xuICAgICAgICBsZXQgY29uZiA9IHZpZXcuc3RhdGUuZmFjZXQocGFuZWxDb25maWcpO1xuICAgICAgICB0aGlzLnRvcCA9IG5ldyBQYW5lbEdyb3VwKHZpZXcsIHRydWUsIGNvbmYudG9wQ29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5ib3R0b20gPSBuZXcgUGFuZWxHcm91cCh2aWV3LCBmYWxzZSwgY29uZi5ib3R0b21Db250YWluZXIpO1xuICAgICAgICB0aGlzLnRvcC5zeW5jKHRoaXMucGFuZWxzLmZpbHRlcihwID0+IHAudG9wKSk7XG4gICAgICAgIHRoaXMuYm90dG9tLnN5bmModGhpcy5wYW5lbHMuZmlsdGVyKHAgPT4gIXAudG9wKSk7XG4gICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wYW5lbHMpIHtcbiAgICAgICAgICAgIHAuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1wYW5lbFwiKTtcbiAgICAgICAgICAgIGlmIChwLm1vdW50KVxuICAgICAgICAgICAgICAgIHAubW91bnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBjb25mID0gdXBkYXRlLnN0YXRlLmZhY2V0KHBhbmVsQ29uZmlnKTtcbiAgICAgICAgaWYgKHRoaXMudG9wLmNvbnRhaW5lciAhPSBjb25mLnRvcENvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy50b3Auc3luYyhbXSk7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IG5ldyBQYW5lbEdyb3VwKHVwZGF0ZS52aWV3LCB0cnVlLCBjb25mLnRvcENvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYm90dG9tLmNvbnRhaW5lciAhPSBjb25mLmJvdHRvbUNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5ib3R0b20uc3luYyhbXSk7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbSA9IG5ldyBQYW5lbEdyb3VwKHVwZGF0ZS52aWV3LCBmYWxzZSwgY29uZi5ib3R0b21Db250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9wLnN5bmNDbGFzc2VzKCk7XG4gICAgICAgIHRoaXMuYm90dG9tLnN5bmNDbGFzc2VzKCk7XG4gICAgICAgIGxldCBpbnB1dCA9IHVwZGF0ZS5zdGF0ZS5mYWNldChzaG93UGFuZWwpO1xuICAgICAgICBpZiAoaW5wdXQgIT0gdGhpcy5pbnB1dCkge1xuICAgICAgICAgICAgbGV0IHNwZWNzID0gaW5wdXQuZmlsdGVyKHggPT4geCk7XG4gICAgICAgICAgICBsZXQgcGFuZWxzID0gW10sIHRvcCA9IFtdLCBib3R0b20gPSBbXSwgbW91bnQgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHNwZWMgb2Ygc3BlY3MpIHtcbiAgICAgICAgICAgICAgICBsZXQga25vd24gPSB0aGlzLnNwZWNzLmluZGV4T2Yoc3BlYyksIHBhbmVsO1xuICAgICAgICAgICAgICAgIGlmIChrbm93biA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGFuZWwgPSBzcGVjKHVwZGF0ZS52aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgbW91bnQucHVzaChwYW5lbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYW5lbCA9IHRoaXMucGFuZWxzW2tub3duXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhbmVsLnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhbmVsLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYW5lbHMucHVzaChwYW5lbCk7XG4gICAgICAgICAgICAgICAgKHBhbmVsLnRvcCA/IHRvcCA6IGJvdHRvbSkucHVzaChwYW5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNwZWNzID0gc3BlY3M7XG4gICAgICAgICAgICB0aGlzLnBhbmVscyA9IHBhbmVscztcbiAgICAgICAgICAgIHRoaXMudG9wLnN5bmModG9wKTtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tLnN5bmMoYm90dG9tKTtcbiAgICAgICAgICAgIGZvciAobGV0IHAgb2YgbW91bnQpIHtcbiAgICAgICAgICAgICAgICBwLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tcGFuZWxcIik7XG4gICAgICAgICAgICAgICAgaWYgKHAubW91bnQpXG4gICAgICAgICAgICAgICAgICAgIHAubW91bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wYW5lbHMpXG4gICAgICAgICAgICAgICAgaWYgKHAudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICBwLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudG9wLnN5bmMoW10pO1xuICAgICAgICB0aGlzLmJvdHRvbS5zeW5jKFtdKTtcbiAgICB9XG59LCB7XG4gICAgcHJvdmlkZTogcGx1Z2luID0+IEVkaXRvclZpZXcuc2Nyb2xsTWFyZ2lucy5vZih2aWV3ID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gdmlldy5wbHVnaW4ocGx1Z2luKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmIHsgdG9wOiB2YWx1ZS50b3Auc2Nyb2xsTWFyZ2luKCksIGJvdHRvbTogdmFsdWUuYm90dG9tLnNjcm9sbE1hcmdpbigpIH07XG4gICAgfSlcbn0pO1xuY2xhc3MgUGFuZWxHcm91cCB7XG4gICAgY29uc3RydWN0b3IodmlldywgdG9wLCBjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmRvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jbGFzc2VzID0gXCJcIjtcbiAgICAgICAgdGhpcy5wYW5lbHMgPSBbXTtcbiAgICAgICAgdGhpcy5zeW5jQ2xhc3NlcygpO1xuICAgIH1cbiAgICBzeW5jKHBhbmVscykge1xuICAgICAgICBmb3IgKGxldCBwIG9mIHRoaXMucGFuZWxzKVxuICAgICAgICAgICAgaWYgKHAuZGVzdHJveSAmJiBwYW5lbHMuaW5kZXhPZihwKSA8IDApXG4gICAgICAgICAgICAgICAgcC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMucGFuZWxzID0gcGFuZWxzO1xuICAgICAgICB0aGlzLnN5bmNET00oKTtcbiAgICB9XG4gICAgc3luY0RPTSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFuZWxzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZG9tKSB7XG4gICAgICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSB0aGlzLnRvcCA/IFwiY20tcGFuZWxzIGNtLXBhbmVscy10b3BcIiA6IFwiY20tcGFuZWxzIGNtLXBhbmVscy1ib3R0b21cIjtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlW3RoaXMudG9wID8gXCJ0b3BcIiA6IFwiYm90dG9tXCJdID0gXCIwXCI7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5jb250YWluZXIgfHwgdGhpcy52aWV3LmRvbTtcbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodGhpcy5kb20sIHRoaXMudG9wID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VyRE9NID0gdGhpcy5kb20uZmlyc3RDaGlsZDtcbiAgICAgICAgZm9yIChsZXQgcGFuZWwgb2YgdGhpcy5wYW5lbHMpIHtcbiAgICAgICAgICAgIGlmIChwYW5lbC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJET00gIT0gcGFuZWwuZG9tKVxuICAgICAgICAgICAgICAgICAgICBjdXJET00gPSBybShjdXJET00pO1xuICAgICAgICAgICAgICAgIGN1ckRPTSA9IGN1ckRPTS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmluc2VydEJlZm9yZShwYW5lbC5kb20sIGN1ckRPTSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGN1ckRPTSlcbiAgICAgICAgICAgIGN1ckRPTSA9IHJtKGN1ckRPTSk7XG4gICAgfVxuICAgIHNjcm9sbE1hcmdpbigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmRvbSB8fCB0aGlzLmNvbnRhaW5lciA/IDBcbiAgICAgICAgICAgIDogTWF0aC5tYXgoMCwgdGhpcy50b3AgP1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSAtIE1hdGgubWF4KDAsIHRoaXMudmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wKSA6XG4gICAgICAgICAgICAgICAgTWF0aC5taW4oaW5uZXJIZWlnaHQsIHRoaXMudmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tKSAtIHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCk7XG4gICAgfVxuICAgIHN5bmNDbGFzc2VzKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGFpbmVyIHx8IHRoaXMuY2xhc3NlcyA9PSB0aGlzLnZpZXcudGhlbWVDbGFzc2VzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCBjbHMgb2YgdGhpcy5jbGFzc2VzLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgICAgICBmb3IgKGxldCBjbHMgb2YgKHRoaXMuY2xhc3NlcyA9IHRoaXMudmlldy50aGVtZUNsYXNzZXMpLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJtKG5vZGUpIHtcbiAgICBsZXQgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgbm9kZS5yZW1vdmUoKTtcbiAgICByZXR1cm4gbmV4dDtcbn1cbi8qKlxuT3BlbmluZyBhIHBhbmVsIGlzIGRvbmUgYnkgcHJvdmlkaW5nIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yXG50aGUgcGFuZWwgdGhyb3VnaCB0aGlzIGZhY2V0LiAoVGhlIHBhbmVsIGlzIGNsb3NlZCBhZ2FpbiB3aGVuIGl0c1xuY29uc3RydWN0b3IgaXMgbm8gbG9uZ2VyIHByb3ZpZGVkLikgVmFsdWVzIG9mIGBudWxsYCBhcmUgaWdub3JlZC5cbiovXG5jb25zdCBzaG93UGFuZWwgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBlbmFibGVzOiBwYW5lbFBsdWdpblxufSk7XG5cbi8qKlxuQSBndXR0ZXIgbWFya2VyIHJlcHJlc2VudHMgYSBiaXQgb2YgaW5mb3JtYXRpb24gYXR0YWNoZWQgdG8gYSBsaW5lXG5pbiBhIHNwZWNpZmljIGd1dHRlci4gWW91ciBvd24gY3VzdG9tIG1hcmtlcnMgaGF2ZSB0byBleHRlbmQgdGhpc1xuY2xhc3MuXG4qL1xuY2xhc3MgR3V0dGVyTWFya2VyIGV4dGVuZHMgUmFuZ2VWYWx1ZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXJlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8IHRoaXMuY29uc3RydWN0b3IgPT0gb3RoZXIuY29uc3RydWN0b3IgJiYgdGhpcy5lcShvdGhlcik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyBtYXJrZXIgdG8gYW5vdGhlciBtYXJrZXIgb2YgdGhlIHNhbWUgdHlwZS5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8qKlxuICAgIENhbGxlZCBpZiB0aGUgbWFya2VyIGhhcyBhIGB0b0RPTWAgbWV0aG9kIGFuZCBpdHMgcmVwcmVzZW50YXRpb25cbiAgICB3YXMgcmVtb3ZlZCBmcm9tIGEgZ3V0dGVyLlxuICAgICovXG4gICAgZGVzdHJveShkb20pIHsgfVxufVxuR3V0dGVyTWFya2VyLnByb3RvdHlwZS5lbGVtZW50Q2xhc3MgPSBcIlwiO1xuR3V0dGVyTWFya2VyLnByb3RvdHlwZS50b0RPTSA9IHVuZGVmaW5lZDtcbkd1dHRlck1hcmtlci5wcm90b3R5cGUubWFwTW9kZSA9IE1hcE1vZGUuVHJhY2tCZWZvcmU7XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLnN0YXJ0U2lkZSA9IEd1dHRlck1hcmtlci5wcm90b3R5cGUuZW5kU2lkZSA9IC0xO1xuR3V0dGVyTWFya2VyLnByb3RvdHlwZS5wb2ludCA9IHRydWU7XG4vKipcbkZhY2V0IHVzZWQgdG8gYWRkIGEgY2xhc3MgdG8gYWxsIGd1dHRlciBlbGVtZW50cyBmb3IgYSBnaXZlbiBsaW5lLlxuTWFya2VycyBnaXZlbiB0byB0aGlzIGZhY2V0IHNob3VsZCBfb25seV8gZGVmaW5lIGFuXG5bYGVsZW1lbnRjbGFzc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5HdXR0ZXJNYXJrZXIuZWxlbWVudENsYXNzKSwgbm90IGFcbltgdG9ET01gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuR3V0dGVyTWFya2VyLnRvRE9NKSAob3IgdGhlIG1hcmtlciB3aWxsIGFwcGVhclxuaW4gYWxsIGd1dHRlcnMgZm9yIHRoZSBsaW5lKS5cbiovXG5jb25zdCBndXR0ZXJMaW5lQ2xhc3MgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgICBjbGFzczogXCJcIixcbiAgICByZW5kZXJFbXB0eUVsZW1lbnRzOiBmYWxzZSxcbiAgICBlbGVtZW50U3R5bGU6IFwiXCIsXG4gICAgbWFya2VyczogKCkgPT4gUmFuZ2VTZXQuZW1wdHksXG4gICAgbGluZU1hcmtlcjogKCkgPT4gbnVsbCxcbiAgICB3aWRnZXRNYXJrZXI6ICgpID0+IG51bGwsXG4gICAgbGluZU1hcmtlckNoYW5nZTogbnVsbCxcbiAgICBpbml0aWFsU3BhY2VyOiBudWxsLFxuICAgIHVwZGF0ZVNwYWNlcjogbnVsbCxcbiAgICBkb21FdmVudEhhbmRsZXJzOiB7fVxufTtcbmNvbnN0IGFjdGl2ZUd1dHRlcnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcbkRlZmluZSBhbiBlZGl0b3IgZ3V0dGVyLiBUaGUgb3JkZXIgaW4gd2hpY2ggdGhlIGd1dHRlcnMgYXBwZWFyIGlzXG5kZXRlcm1pbmVkIGJ5IHRoZWlyIGV4dGVuc2lvbiBwcmlvcml0eS5cbiovXG5mdW5jdGlvbiBndXR0ZXIoY29uZmlnKSB7XG4gICAgcmV0dXJuIFtndXR0ZXJzKCksIGFjdGl2ZUd1dHRlcnMub2YoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cyksIGNvbmZpZykpXTtcbn1cbmNvbnN0IHVuZml4R3V0dGVycyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMuc29tZSh4ID0+IHgpXG59KTtcbi8qKlxuVGhlIGd1dHRlci1kcmF3aW5nIHBsdWdpbiBpcyBhdXRvbWF0aWNhbGx5IGVuYWJsZWQgd2hlbiB5b3UgYWRkIGFcbmd1dHRlciwgYnV0IHlvdSBjYW4gdXNlIHRoaXMgZnVuY3Rpb24gdG8gZXhwbGljaXRseSBjb25maWd1cmUgaXQuXG5cblVubGVzcyBgZml4ZWRgIGlzIGV4cGxpY2l0bHkgc2V0IHRvIGBmYWxzZWAsIHRoZSBndXR0ZXJzIGFyZVxuZml4ZWQsIG1lYW5pbmcgdGhleSBkb24ndCBzY3JvbGwgYWxvbmcgd2l0aCB0aGUgY29udGVudFxuaG9yaXpvbnRhbGx5IChleGNlcHQgb24gSW50ZXJuZXQgRXhwbG9yZXIsIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydFxuQ1NTIFtgcG9zaXRpb246XG5zdGlja3lgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvcG9zaXRpb24jc3RpY2t5KSkuXG4qL1xuZnVuY3Rpb24gZ3V0dGVycyhjb25maWcpIHtcbiAgICBsZXQgcmVzdWx0ID0gW1xuICAgICAgICBndXR0ZXJWaWV3LFxuICAgIF07XG4gICAgaWYgKGNvbmZpZyAmJiBjb25maWcuZml4ZWQgPT09IGZhbHNlKVxuICAgICAgICByZXN1bHQucHVzaCh1bmZpeEd1dHRlcnMub2YodHJ1ZSkpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBndXR0ZXJWaWV3ID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMucHJldlZpZXdwb3J0ID0gdmlldy52aWV3cG9ydDtcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBcImNtLWd1dHRlcnNcIjtcbiAgICAgICAgdGhpcy5kb20uc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICB0aGlzLmRvbS5zdHlsZS5taW5IZWlnaHQgPSAodGhpcy52aWV3LmNvbnRlbnRIZWlnaHQgLyB0aGlzLnZpZXcuc2NhbGVZKSArIFwicHhcIjtcbiAgICAgICAgdGhpcy5ndXR0ZXJzID0gdmlldy5zdGF0ZS5mYWNldChhY3RpdmVHdXR0ZXJzKS5tYXAoY29uZiA9PiBuZXcgU2luZ2xlR3V0dGVyVmlldyh2aWV3LCBjb25mKSk7XG4gICAgICAgIGZvciAobGV0IGd1dHRlciBvZiB0aGlzLmd1dHRlcnMpXG4gICAgICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZChndXR0ZXIuZG9tKTtcbiAgICAgICAgdGhpcy5maXhlZCA9ICF2aWV3LnN0YXRlLmZhY2V0KHVuZml4R3V0dGVycyk7XG4gICAgICAgIGlmICh0aGlzLmZpeGVkKSB7XG4gICAgICAgICAgICAvLyBGSVhNRSBJRTExIGZhbGxiYWNrLCB3aGljaCBkb2Vzbid0IHN1cHBvcnQgcG9zaXRpb246IHN0aWNreSxcbiAgICAgICAgICAgIC8vIGJ5IHVzaW5nIHBvc2l0aW9uOiByZWxhdGl2ZSArIGV2ZW50IGhhbmRsZXJzIHRoYXQgcmVhbGlnbiB0aGVcbiAgICAgICAgICAgIC8vIGd1dHRlciAob3IganVzdCBmb3JjZSBmaXhlZD1mYWxzZSBvbiBJRTExPylcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLnBvc2l0aW9uID0gXCJzdGlja3lcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN5bmNHdXR0ZXJzKGZhbHNlKTtcbiAgICAgICAgdmlldy5zY3JvbGxET00uaW5zZXJ0QmVmb3JlKHRoaXMuZG9tLCB2aWV3LmNvbnRlbnRET00pO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZUd1dHRlcnModXBkYXRlKSkge1xuICAgICAgICAgICAgLy8gRGV0YWNoIGR1cmluZyBzeW5jIHdoZW4gdGhlIHZpZXdwb3J0IGNoYW5nZWQgc2lnbmlmaWNhbnRseVxuICAgICAgICAgICAgLy8gKHN1Y2ggYXMgZHVyaW5nIHNjcm9sbGluZyksIHNpbmNlIGZvciBsYXJnZSB1cGRhdGVzIHRoYXQgaXNcbiAgICAgICAgICAgIC8vIGZhc3Rlci5cbiAgICAgICAgICAgIGxldCB2cEEgPSB0aGlzLnByZXZWaWV3cG9ydCwgdnBCID0gdXBkYXRlLnZpZXcudmlld3BvcnQ7XG4gICAgICAgICAgICBsZXQgdnBPdmVybGFwID0gTWF0aC5taW4odnBBLnRvLCB2cEIudG8pIC0gTWF0aC5tYXgodnBBLmZyb20sIHZwQi5mcm9tKTtcbiAgICAgICAgICAgIHRoaXMuc3luY0d1dHRlcnModnBPdmVybGFwIDwgKHZwQi50byAtIHZwQi5mcm9tKSAqIDAuOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZS5nZW9tZXRyeUNoYW5nZWQpXG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5taW5IZWlnaHQgPSB0aGlzLnZpZXcuY29udGVudEhlaWdodCArIFwicHhcIjtcbiAgICAgICAgaWYgKHRoaXMudmlldy5zdGF0ZS5mYWNldCh1bmZpeEd1dHRlcnMpICE9ICF0aGlzLmZpeGVkKSB7XG4gICAgICAgICAgICB0aGlzLmZpeGVkID0gIXRoaXMuZml4ZWQ7XG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5wb3NpdGlvbiA9IHRoaXMuZml4ZWQgPyBcInN0aWNreVwiIDogXCJcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXZWaWV3cG9ydCA9IHVwZGF0ZS52aWV3LnZpZXdwb3J0O1xuICAgIH1cbiAgICBzeW5jR3V0dGVycyhkZXRhY2gpIHtcbiAgICAgICAgbGV0IGFmdGVyID0gdGhpcy5kb20ubmV4dFNpYmxpbmc7XG4gICAgICAgIGlmIChkZXRhY2gpXG4gICAgICAgICAgICB0aGlzLmRvbS5yZW1vdmUoKTtcbiAgICAgICAgbGV0IGxpbmVDbGFzc2VzID0gUmFuZ2VTZXQuaXRlcih0aGlzLnZpZXcuc3RhdGUuZmFjZXQoZ3V0dGVyTGluZUNsYXNzKSwgdGhpcy52aWV3LnZpZXdwb3J0LmZyb20pO1xuICAgICAgICBsZXQgY2xhc3NTZXQgPSBbXTtcbiAgICAgICAgbGV0IGNvbnRleHRzID0gdGhpcy5ndXR0ZXJzLm1hcChndXR0ZXIgPT4gbmV3IFVwZGF0ZUNvbnRleHQoZ3V0dGVyLCB0aGlzLnZpZXcudmlld3BvcnQsIC10aGlzLnZpZXcuZG9jdW1lbnRQYWRkaW5nLnRvcCkpO1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRoaXMudmlldy52aWV3cG9ydExpbmVCbG9ja3MpIHtcbiAgICAgICAgICAgIGlmIChjbGFzc1NldC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgY2xhc3NTZXQgPSBbXTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxpbmUudHlwZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGIgb2YgbGluZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQgJiYgZmlyc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2VDdXJzb3IobGluZUNsYXNzZXMsIGNsYXNzU2V0LCBiLmZyb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY3ggb2YgY29udGV4dHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3gubGluZSh0aGlzLnZpZXcsIGIsIGNsYXNzU2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYi53aWRnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGN4IG9mIGNvbnRleHRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4LndpZGdldCh0aGlzLnZpZXcsIGIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGluZS50eXBlID09IEJsb2NrVHlwZS5UZXh0KSB7XG4gICAgICAgICAgICAgICAgYWR2YW5jZUN1cnNvcihsaW5lQ2xhc3NlcywgY2xhc3NTZXQsIGxpbmUuZnJvbSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY3ggb2YgY29udGV4dHMpXG4gICAgICAgICAgICAgICAgICAgIGN4LmxpbmUodGhpcy52aWV3LCBsaW5lLCBjbGFzc1NldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsaW5lLndpZGdldCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGN4IG9mIGNvbnRleHRzKVxuICAgICAgICAgICAgICAgICAgICBjeC53aWRnZXQodGhpcy52aWV3LCBsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBjeCBvZiBjb250ZXh0cylcbiAgICAgICAgICAgIGN4LmZpbmlzaCgpO1xuICAgICAgICBpZiAoZGV0YWNoKVxuICAgICAgICAgICAgdGhpcy52aWV3LnNjcm9sbERPTS5pbnNlcnRCZWZvcmUodGhpcy5kb20sIGFmdGVyKTtcbiAgICB9XG4gICAgdXBkYXRlR3V0dGVycyh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHByZXYgPSB1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChhY3RpdmVHdXR0ZXJzKSwgY3VyID0gdXBkYXRlLnN0YXRlLmZhY2V0KGFjdGl2ZUd1dHRlcnMpO1xuICAgICAgICBsZXQgY2hhbmdlID0gdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLmhlaWdodENoYW5nZWQgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCB8fFxuICAgICAgICAgICAgIVJhbmdlU2V0LmVxKHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGd1dHRlckxpbmVDbGFzcyksIHVwZGF0ZS5zdGF0ZS5mYWNldChndXR0ZXJMaW5lQ2xhc3MpLCB1cGRhdGUudmlldy52aWV3cG9ydC5mcm9tLCB1cGRhdGUudmlldy52aWV3cG9ydC50byk7XG4gICAgICAgIGlmIChwcmV2ID09IGN1cikge1xuICAgICAgICAgICAgZm9yIChsZXQgZ3V0dGVyIG9mIHRoaXMuZ3V0dGVycylcbiAgICAgICAgICAgICAgICBpZiAoZ3V0dGVyLnVwZGF0ZSh1cGRhdGUpKVxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBndXR0ZXJzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBjb25mIG9mIGN1cikge1xuICAgICAgICAgICAgICAgIGxldCBrbm93biA9IHByZXYuaW5kZXhPZihjb25mKTtcbiAgICAgICAgICAgICAgICBpZiAoa25vd24gPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGd1dHRlcnMucHVzaChuZXcgU2luZ2xlR3V0dGVyVmlldyh0aGlzLnZpZXcsIGNvbmYpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3V0dGVyc1trbm93bl0udXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGd1dHRlcnMucHVzaCh0aGlzLmd1dHRlcnNba25vd25dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBnIG9mIHRoaXMuZ3V0dGVycykge1xuICAgICAgICAgICAgICAgIGcuZG9tLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChndXR0ZXJzLmluZGV4T2YoZykgPCAwKVxuICAgICAgICAgICAgICAgICAgICBnLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGcgb2YgZ3V0dGVycylcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZChnLmRvbSk7XG4gICAgICAgICAgICB0aGlzLmd1dHRlcnMgPSBndXR0ZXJzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGZvciAobGV0IHZpZXcgb2YgdGhpcy5ndXR0ZXJzKVxuICAgICAgICAgICAgdmlldy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgIH1cbn0sIHtcbiAgICBwcm92aWRlOiBwbHVnaW4gPT4gRWRpdG9yVmlldy5zY3JvbGxNYXJnaW5zLm9mKHZpZXcgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSB2aWV3LnBsdWdpbihwbHVnaW4pO1xuICAgICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlLmd1dHRlcnMubGVuZ3RoID09IDAgfHwgIXZhbHVlLmZpeGVkKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB2aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUlxuICAgICAgICAgICAgPyB7IGxlZnQ6IHZhbHVlLmRvbS5vZmZzZXRXaWR0aCAqIHZpZXcuc2NhbGVYIH1cbiAgICAgICAgICAgIDogeyByaWdodDogdmFsdWUuZG9tLm9mZnNldFdpZHRoICogdmlldy5zY2FsZVggfTtcbiAgICB9KVxufSk7XG5mdW5jdGlvbiBhc0FycmF5KHZhbCkgeyByZXR1cm4gKEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbCA6IFt2YWxdKTsgfVxuZnVuY3Rpb24gYWR2YW5jZUN1cnNvcihjdXJzb3IsIGNvbGxlY3QsIHBvcykge1xuICAgIHdoaWxlIChjdXJzb3IudmFsdWUgJiYgY3Vyc29yLmZyb20gPD0gcG9zKSB7XG4gICAgICAgIGlmIChjdXJzb3IuZnJvbSA9PSBwb3MpXG4gICAgICAgICAgICBjb2xsZWN0LnB1c2goY3Vyc29yLnZhbHVlKTtcbiAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICB9XG59XG5jbGFzcyBVcGRhdGVDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihndXR0ZXIsIHZpZXdwb3J0LCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5ndXR0ZXIgPSBndXR0ZXI7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLmkgPSAwO1xuICAgICAgICB0aGlzLmN1cnNvciA9IFJhbmdlU2V0Lml0ZXIoZ3V0dGVyLm1hcmtlcnMsIHZpZXdwb3J0LmZyb20pO1xuICAgIH1cbiAgICBhZGRFbGVtZW50KHZpZXcsIGJsb2NrLCBtYXJrZXJzKSB7XG4gICAgICAgIGxldCB7IGd1dHRlciB9ID0gdGhpcywgYWJvdmUgPSAoYmxvY2sudG9wIC0gdGhpcy5oZWlnaHQpIC8gdmlldy5zY2FsZVksIGhlaWdodCA9IGJsb2NrLmhlaWdodCAvIHZpZXcuc2NhbGVZO1xuICAgICAgICBpZiAodGhpcy5pID09IGd1dHRlci5lbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBuZXdFbHQgPSBuZXcgR3V0dGVyRWxlbWVudCh2aWV3LCBoZWlnaHQsIGFib3ZlLCBtYXJrZXJzKTtcbiAgICAgICAgICAgIGd1dHRlci5lbGVtZW50cy5wdXNoKG5ld0VsdCk7XG4gICAgICAgICAgICBndXR0ZXIuZG9tLmFwcGVuZENoaWxkKG5ld0VsdC5kb20pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ3V0dGVyLmVsZW1lbnRzW3RoaXMuaV0udXBkYXRlKHZpZXcsIGhlaWdodCwgYWJvdmUsIG1hcmtlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gYmxvY2suYm90dG9tO1xuICAgICAgICB0aGlzLmkrKztcbiAgICB9XG4gICAgbGluZSh2aWV3LCBsaW5lLCBleHRyYU1hcmtlcnMpIHtcbiAgICAgICAgbGV0IGxvY2FsTWFya2VycyA9IFtdO1xuICAgICAgICBhZHZhbmNlQ3Vyc29yKHRoaXMuY3Vyc29yLCBsb2NhbE1hcmtlcnMsIGxpbmUuZnJvbSk7XG4gICAgICAgIGlmIChleHRyYU1hcmtlcnMubGVuZ3RoKVxuICAgICAgICAgICAgbG9jYWxNYXJrZXJzID0gbG9jYWxNYXJrZXJzLmNvbmNhdChleHRyYU1hcmtlcnMpO1xuICAgICAgICBsZXQgZm9yTGluZSA9IHRoaXMuZ3V0dGVyLmNvbmZpZy5saW5lTWFya2VyKHZpZXcsIGxpbmUsIGxvY2FsTWFya2Vycyk7XG4gICAgICAgIGlmIChmb3JMaW5lKVxuICAgICAgICAgICAgbG9jYWxNYXJrZXJzLnVuc2hpZnQoZm9yTGluZSk7XG4gICAgICAgIGxldCBndXR0ZXIgPSB0aGlzLmd1dHRlcjtcbiAgICAgICAgaWYgKGxvY2FsTWFya2Vycy5sZW5ndGggPT0gMCAmJiAhZ3V0dGVyLmNvbmZpZy5yZW5kZXJFbXB0eUVsZW1lbnRzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmFkZEVsZW1lbnQodmlldywgbGluZSwgbG9jYWxNYXJrZXJzKTtcbiAgICB9XG4gICAgd2lkZ2V0KHZpZXcsIGJsb2NrKSB7XG4gICAgICAgIGxldCBtYXJrZXIgPSB0aGlzLmd1dHRlci5jb25maWcud2lkZ2V0TWFya2VyKHZpZXcsIGJsb2NrLndpZGdldCwgYmxvY2spO1xuICAgICAgICBpZiAobWFya2VyKVxuICAgICAgICAgICAgdGhpcy5hZGRFbGVtZW50KHZpZXcsIGJsb2NrLCBbbWFya2VyXSk7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgbGV0IGd1dHRlciA9IHRoaXMuZ3V0dGVyO1xuICAgICAgICB3aGlsZSAoZ3V0dGVyLmVsZW1lbnRzLmxlbmd0aCA+IHRoaXMuaSkge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBndXR0ZXIuZWxlbWVudHMucG9wKCk7XG4gICAgICAgICAgICBndXR0ZXIuZG9tLnJlbW92ZUNoaWxkKGxhc3QuZG9tKTtcbiAgICAgICAgICAgIGxhc3QuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU2luZ2xlR3V0dGVyVmlldyB7XG4gICAgY29uc3RydWN0b3IodmlldywgY29uZmlnKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gW107XG4gICAgICAgIHRoaXMuc3BhY2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBcImNtLWd1dHRlclwiICsgKHRoaXMuY29uZmlnLmNsYXNzID8gXCIgXCIgKyB0aGlzLmNvbmZpZy5jbGFzcyA6IFwiXCIpO1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIGNvbmZpZy5kb21FdmVudEhhbmRsZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRFdmVudExpc3RlbmVyKHByb3AsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldmVudC50YXJnZXQsIHk7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPSB0aGlzLmRvbSAmJiB0aGlzLmRvbS5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0YXJnZXQucGFyZW50Tm9kZSAhPSB0aGlzLmRvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IChyZWN0LnRvcCArIHJlY3QuYm90dG9tKSAvIDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5ID0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0SGVpZ2h0KHkgLSB2aWV3LmRvY3VtZW50VG9wKTtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmRvbUV2ZW50SGFuZGxlcnNbcHJvcF0odmlldywgbGluZSwgZXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrZXJzID0gYXNBcnJheShjb25maWcubWFya2Vycyh2aWV3KSk7XG4gICAgICAgIGlmIChjb25maWcuaW5pdGlhbFNwYWNlcikge1xuICAgICAgICAgICAgdGhpcy5zcGFjZXIgPSBuZXcgR3V0dGVyRWxlbWVudCh2aWV3LCAwLCAwLCBbY29uZmlnLmluaXRpYWxTcGFjZXIodmlldyldKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuc3BhY2VyLmRvbSk7XG4gICAgICAgICAgICB0aGlzLnNwYWNlci5kb20uc3R5bGUuY3NzVGV4dCArPSBcInZpc2liaWxpdHk6IGhpZGRlbjsgcG9pbnRlci1ldmVudHM6IG5vbmVcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBwcmV2TWFya2VycyA9IHRoaXMubWFya2VycztcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gYXNBcnJheSh0aGlzLmNvbmZpZy5tYXJrZXJzKHVwZGF0ZS52aWV3KSk7XG4gICAgICAgIGlmICh0aGlzLnNwYWNlciAmJiB0aGlzLmNvbmZpZy51cGRhdGVTcGFjZXIpIHtcbiAgICAgICAgICAgIGxldCB1cGRhdGVkID0gdGhpcy5jb25maWcudXBkYXRlU3BhY2VyKHRoaXMuc3BhY2VyLm1hcmtlcnNbMF0sIHVwZGF0ZSk7XG4gICAgICAgICAgICBpZiAodXBkYXRlZCAhPSB0aGlzLnNwYWNlci5tYXJrZXJzWzBdKVxuICAgICAgICAgICAgICAgIHRoaXMuc3BhY2VyLnVwZGF0ZSh1cGRhdGUudmlldywgMCwgMCwgW3VwZGF0ZWRdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdnAgPSB1cGRhdGUudmlldy52aWV3cG9ydDtcbiAgICAgICAgcmV0dXJuICFSYW5nZVNldC5lcSh0aGlzLm1hcmtlcnMsIHByZXZNYXJrZXJzLCB2cC5mcm9tLCB2cC50bykgfHxcbiAgICAgICAgICAgICh0aGlzLmNvbmZpZy5saW5lTWFya2VyQ2hhbmdlID8gdGhpcy5jb25maWcubGluZU1hcmtlckNoYW5nZSh1cGRhdGUpIDogZmFsc2UpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGxldCBlbHQgb2YgdGhpcy5lbGVtZW50cylcbiAgICAgICAgICAgIGVsdC5kZXN0cm95KCk7XG4gICAgfVxufVxuY2xhc3MgR3V0dGVyRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycykge1xuICAgICAgICB0aGlzLmhlaWdodCA9IC0xO1xuICAgICAgICB0aGlzLmFib3ZlID0gMDtcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gW107XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1ndXR0ZXJFbGVtZW50XCI7XG4gICAgICAgIHRoaXMudXBkYXRlKHZpZXcsIGhlaWdodCwgYWJvdmUsIG1hcmtlcnMpO1xuICAgIH1cbiAgICB1cGRhdGUodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycykge1xuICAgICAgICBpZiAodGhpcy5oZWlnaHQgIT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hYm92ZSAhPSBhYm92ZSlcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLm1hcmdpblRvcCA9ICh0aGlzLmFib3ZlID0gYWJvdmUpID8gYWJvdmUgKyBcInB4XCIgOiBcIlwiO1xuICAgICAgICBpZiAoIXNhbWVNYXJrZXJzKHRoaXMubWFya2VycywgbWFya2VycykpXG4gICAgICAgICAgICB0aGlzLnNldE1hcmtlcnModmlldywgbWFya2Vycyk7XG4gICAgfVxuICAgIHNldE1hcmtlcnModmlldywgbWFya2Vycykge1xuICAgICAgICBsZXQgY2xzID0gXCJjbS1ndXR0ZXJFbGVtZW50XCIsIGRvbVBvcyA9IHRoaXMuZG9tLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGZvciAobGV0IGlOZXcgPSAwLCBpT2xkID0gMDs7KSB7XG4gICAgICAgICAgICBsZXQgc2tpcFRvID0gaU9sZCwgbWFya2VyID0gaU5ldyA8IG1hcmtlcnMubGVuZ3RoID8gbWFya2Vyc1tpTmV3KytdIDogbnVsbCwgbWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG1hcmtlcikge1xuICAgICAgICAgICAgICAgIGxldCBjID0gbWFya2VyLmVsZW1lbnRDbGFzcztcbiAgICAgICAgICAgICAgICBpZiAoYylcbiAgICAgICAgICAgICAgICAgICAgY2xzICs9IFwiIFwiICsgYztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gaU9sZDsgaSA8IHRoaXMubWFya2Vycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWFya2Vyc1tpXS5jb21wYXJlKG1hcmtlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBUbyA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBza2lwVG8gPSB0aGlzLm1hcmtlcnMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGlPbGQgPCBza2lwVG8pIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMubWFya2Vyc1tpT2xkKytdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0LnRvRE9NKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQuZGVzdHJveShkb21Qb3MpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWZ0ZXIgPSBkb21Qb3MubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGRvbVBvcy5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgZG9tUG9zID0gYWZ0ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtYXJrZXIpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAobWFya2VyLnRvRE9NKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZWQpXG4gICAgICAgICAgICAgICAgICAgIGRvbVBvcyA9IGRvbVBvcy5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmluc2VydEJlZm9yZShtYXJrZXIudG9ET00odmlldyksIGRvbVBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hlZClcbiAgICAgICAgICAgICAgICBpT2xkKys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gY2xzO1xuICAgICAgICB0aGlzLm1hcmtlcnMgPSBtYXJrZXJzO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldE1hcmtlcnMobnVsbCwgW10pOyAvLyBGaXJzdCBhcmd1bWVudCBub3QgdXNlZCB1bmxlc3MgY3JlYXRpbmcgbWFya2Vyc1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbWVNYXJrZXJzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghYVtpXS5jb21wYXJlKGJbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5GYWNldCB1c2VkIHRvIHByb3ZpZGUgbWFya2VycyB0byB0aGUgbGluZSBudW1iZXIgZ3V0dGVyLlxuKi9cbmNvbnN0IGxpbmVOdW1iZXJNYXJrZXJzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgbGluZU51bWJlckNvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKHZhbHVlcywgeyBmb3JtYXROdW1iZXI6IFN0cmluZywgZG9tRXZlbnRIYW5kbGVyczoge30gfSwge1xuICAgICAgICAgICAgZG9tRXZlbnRIYW5kbGVycyhhLCBiKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIGEpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGV2ZW50IGluIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGV4aXN0cyA9IHJlc3VsdFtldmVudF0sIGFkZCA9IGJbZXZlbnRdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbZXZlbnRdID0gZXhpc3RzID8gKHZpZXcsIGxpbmUsIGV2ZW50KSA9PiBleGlzdHModmlldywgbGluZSwgZXZlbnQpIHx8IGFkZCh2aWV3LCBsaW5lLCBldmVudCkgOiBhZGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuY2xhc3MgTnVtYmVyTWFya2VyIGV4dGVuZHMgR3V0dGVyTWFya2VyIHtcbiAgICBjb25zdHJ1Y3RvcihudW1iZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5udW1iZXIgPSBudW1iZXI7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiB0aGlzLm51bWJlciA9PSBvdGhlci5udW1iZXI7IH1cbiAgICB0b0RPTSgpIHsgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMubnVtYmVyKTsgfVxufVxuZnVuY3Rpb24gZm9ybWF0TnVtYmVyKHZpZXcsIG51bWJlcikge1xuICAgIHJldHVybiB2aWV3LnN0YXRlLmZhY2V0KGxpbmVOdW1iZXJDb25maWcpLmZvcm1hdE51bWJlcihudW1iZXIsIHZpZXcuc3RhdGUpO1xufVxuY29uc3QgbGluZU51bWJlckd1dHRlciA9IC8qQF9fUFVSRV9fKi9hY3RpdmVHdXR0ZXJzLmNvbXB1dGUoW2xpbmVOdW1iZXJDb25maWddLCBzdGF0ZSA9PiAoe1xuICAgIGNsYXNzOiBcImNtLWxpbmVOdW1iZXJzXCIsXG4gICAgcmVuZGVyRW1wdHlFbGVtZW50czogZmFsc2UsXG4gICAgbWFya2Vycyh2aWV3KSB7IHJldHVybiB2aWV3LnN0YXRlLmZhY2V0KGxpbmVOdW1iZXJNYXJrZXJzKTsgfSxcbiAgICBsaW5lTWFya2VyKHZpZXcsIGxpbmUsIG90aGVycykge1xuICAgICAgICBpZiAob3RoZXJzLnNvbWUobSA9PiBtLnRvRE9NKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IE51bWJlck1hcmtlcihmb3JtYXROdW1iZXIodmlldywgdmlldy5zdGF0ZS5kb2MubGluZUF0KGxpbmUuZnJvbSkubnVtYmVyKSk7XG4gICAgfSxcbiAgICB3aWRnZXRNYXJrZXI6ICgpID0+IG51bGwsXG4gICAgbGluZU1hcmtlckNoYW5nZTogdXBkYXRlID0+IHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGxpbmVOdW1iZXJDb25maWcpICE9IHVwZGF0ZS5zdGF0ZS5mYWNldChsaW5lTnVtYmVyQ29uZmlnKSxcbiAgICBpbml0aWFsU3BhY2VyKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJNYXJrZXIoZm9ybWF0TnVtYmVyKHZpZXcsIG1heExpbmVOdW1iZXIodmlldy5zdGF0ZS5kb2MubGluZXMpKSk7XG4gICAgfSxcbiAgICB1cGRhdGVTcGFjZXIoc3BhY2VyLCB1cGRhdGUpIHtcbiAgICAgICAgbGV0IG1heCA9IGZvcm1hdE51bWJlcih1cGRhdGUudmlldywgbWF4TGluZU51bWJlcih1cGRhdGUudmlldy5zdGF0ZS5kb2MubGluZXMpKTtcbiAgICAgICAgcmV0dXJuIG1heCA9PSBzcGFjZXIubnVtYmVyID8gc3BhY2VyIDogbmV3IE51bWJlck1hcmtlcihtYXgpO1xuICAgIH0sXG4gICAgZG9tRXZlbnRIYW5kbGVyczogc3RhdGUuZmFjZXQobGluZU51bWJlckNvbmZpZykuZG9tRXZlbnRIYW5kbGVyc1xufSkpO1xuLyoqXG5DcmVhdGUgYSBsaW5lIG51bWJlciBndXR0ZXIgZXh0ZW5zaW9uLlxuKi9cbmZ1bmN0aW9uIGxpbmVOdW1iZXJzKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbGluZU51bWJlckNvbmZpZy5vZihjb25maWcpLFxuICAgICAgICBndXR0ZXJzKCksXG4gICAgICAgIGxpbmVOdW1iZXJHdXR0ZXJcbiAgICBdO1xufVxuZnVuY3Rpb24gbWF4TGluZU51bWJlcihsaW5lcykge1xuICAgIGxldCBsYXN0ID0gOTtcbiAgICB3aGlsZSAobGFzdCA8IGxpbmVzKVxuICAgICAgICBsYXN0ID0gbGFzdCAqIDEwICsgOTtcbiAgICByZXR1cm4gbGFzdDtcbn1cbmNvbnN0IGFjdGl2ZUxpbmVHdXR0ZXJNYXJrZXIgPSAvKkBfX1BVUkVfXyovbmV3IGNsYXNzIGV4dGVuZHMgR3V0dGVyTWFya2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5lbGVtZW50Q2xhc3MgPSBcImNtLWFjdGl2ZUxpbmVHdXR0ZXJcIjtcbiAgICB9XG59O1xuY29uc3QgYWN0aXZlTGluZUd1dHRlckhpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL2d1dHRlckxpbmVDbGFzcy5jb21wdXRlKFtcInNlbGVjdGlvblwiXSwgc3RhdGUgPT4ge1xuICAgIGxldCBtYXJrcyA9IFtdLCBsYXN0ID0gLTE7XG4gICAgZm9yIChsZXQgcmFuZ2Ugb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICBsZXQgbGluZVBvcyA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UuaGVhZCkuZnJvbTtcbiAgICAgICAgaWYgKGxpbmVQb3MgPiBsYXN0KSB7XG4gICAgICAgICAgICBsYXN0ID0gbGluZVBvcztcbiAgICAgICAgICAgIG1hcmtzLnB1c2goYWN0aXZlTGluZUd1dHRlck1hcmtlci5yYW5nZShsaW5lUG9zKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFJhbmdlU2V0Lm9mKG1hcmtzKTtcbn0pO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGFkZHMgYSBgY20tYWN0aXZlTGluZUd1dHRlcmAgY2xhc3MgdG9cbmFsbCBndXR0ZXIgZWxlbWVudHMgb24gdGhlIFthY3RpdmVcbmxpbmVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5oaWdobGlnaHRBY3RpdmVMaW5lKS5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRBY3RpdmVMaW5lR3V0dGVyKCkge1xuICAgIHJldHVybiBhY3RpdmVMaW5lR3V0dGVySGlnaGxpZ2h0ZXI7XG59XG5cbmNvbnN0IFdoaXRlc3BhY2VEZWNvID0gLypAX19QVVJFX18qL25ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldFdoaXRlc3BhY2VEZWNvKHNwYWNlKSB7XG4gICAgbGV0IGRlY28gPSBXaGl0ZXNwYWNlRGVjby5nZXQoc3BhY2UpO1xuICAgIGlmICghZGVjbylcbiAgICAgICAgV2hpdGVzcGFjZURlY28uc2V0KHNwYWNlLCBkZWNvID0gRGVjb3JhdGlvbi5tYXJrKHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNwYWNlID09PSBcIlxcdFwiID8ge1xuICAgICAgICAgICAgICAgIGNsYXNzOiBcImNtLWhpZ2hsaWdodFRhYlwiLFxuICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICBjbGFzczogXCJjbS1oaWdobGlnaHRTcGFjZVwiLFxuICAgICAgICAgICAgICAgIFwiZGF0YS1kaXNwbGF5XCI6IHNwYWNlLnJlcGxhY2UoLyAvZywgXCLCt1wiKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgcmV0dXJuIGRlY287XG59XG5mdW5jdGlvbiBtYXRjaGVyKGRlY29yYXRvcikge1xuICAgIHJldHVybiBWaWV3UGx1Z2luLmRlZmluZSh2aWV3ID0+ICh7XG4gICAgICAgIGRlY29yYXRpb25zOiBkZWNvcmF0b3IuY3JlYXRlRGVjbyh2aWV3KSxcbiAgICAgICAgdXBkYXRlKHUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBkZWNvcmF0b3IudXBkYXRlRGVjbyh1LCB0aGlzLmRlY29yYXRpb25zKTtcbiAgICAgICAgfSxcbiAgICB9KSwge1xuICAgICAgICBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zXG4gICAgfSk7XG59XG5jb25zdCB3aGl0ZXNwYWNlSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovbWF0Y2hlcigvKkBfX1BVUkVfXyovbmV3IE1hdGNoRGVjb3JhdG9yKHtcbiAgICByZWdleHA6IC9cXHR8ICsvZyxcbiAgICBkZWNvcmF0aW9uOiBtYXRjaCA9PiBnZXRXaGl0ZXNwYWNlRGVjbyhtYXRjaFswXSksXG4gICAgYm91bmRhcnk6IC9cXFMvLFxufSkpO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGhpZ2hsaWdodHMgd2hpdGVzcGFjZSwgYWRkaW5nIGFcbmBjbS1oaWdobGlnaHRTcGFjZWAgY2xhc3MgdG8gc3RyZXRjaGVzIG9mIHNwYWNlcywgYW5kIGFcbmBjbS1oaWdobGlnaHRUYWJgIGNsYXNzIHRvIGluZGl2aWR1YWwgdGFiIGNoYXJhY3RlcnMuIEJ5IGRlZmF1bHQsXG50aGUgZm9ybWVyIGFyZSBzaG93biBhcyBmYWludCBkb3RzLCBhbmQgdGhlIGxhdHRlciBhcyBhcnJvd3MuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0V2hpdGVzcGFjZSgpIHtcbiAgICByZXR1cm4gd2hpdGVzcGFjZUhpZ2hsaWdodGVyO1xufVxuY29uc3QgdHJhaWxpbmdIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9tYXRjaGVyKC8qQF9fUFVSRV9fKi9uZXcgTWF0Y2hEZWNvcmF0b3Ioe1xuICAgIHJlZ2V4cDogL1xccyskL2csXG4gICAgZGVjb3JhdGlvbjogLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXRyYWlsaW5nU3BhY2VcIiB9KSxcbiAgICBib3VuZGFyeTogL1xcUy8sXG59KSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgYWRkcyBhIGBjbS10cmFpbGluZ1NwYWNlYCBjbGFzcyB0byBhbGxcbnRyYWlsaW5nIHdoaXRlc3BhY2UuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0VHJhaWxpbmdXaGl0ZXNwYWNlKCkge1xuICAgIHJldHVybiB0cmFpbGluZ0hpZ2hsaWdodGVyO1xufVxuXG4vKipcbkBpbnRlcm5hbFxuKi9cbmNvbnN0IF9fdGVzdCA9IHsgSGVpZ2h0TWFwLCBIZWlnaHRPcmFjbGUsIE1lYXN1cmVkSGVpZ2h0cywgUXVlcnlUeXBlLCBDaGFuZ2VkUmFuZ2UsIGNvbXB1dGVPcmRlciwgbW92ZVZpc3VhbGx5IH07XG5cbmV4cG9ydCB7IEJpZGlTcGFuLCBCbG9ja0luZm8sIEJsb2NrVHlwZSwgRGVjb3JhdGlvbiwgRGlyZWN0aW9uLCBFZGl0b3JWaWV3LCBHdXR0ZXJNYXJrZXIsIE1hdGNoRGVjb3JhdG9yLCBSZWN0YW5nbGVNYXJrZXIsIFZpZXdQbHVnaW4sIFZpZXdVcGRhdGUsIFdpZGdldFR5cGUsIF9fdGVzdCwgY2xvc2VIb3ZlclRvb2x0aXBzLCBjcm9zc2hhaXJDdXJzb3IsIGRyYXdTZWxlY3Rpb24sIGRyb3BDdXJzb3IsIGdldERyYXdTZWxlY3Rpb25Db25maWcsIGdldFBhbmVsLCBnZXRUb29sdGlwLCBndXR0ZXIsIGd1dHRlckxpbmVDbGFzcywgZ3V0dGVycywgaGFzSG92ZXJUb29sdGlwcywgaGlnaGxpZ2h0QWN0aXZlTGluZSwgaGlnaGxpZ2h0QWN0aXZlTGluZUd1dHRlciwgaGlnaGxpZ2h0U3BlY2lhbENoYXJzLCBoaWdobGlnaHRUcmFpbGluZ1doaXRlc3BhY2UsIGhpZ2hsaWdodFdoaXRlc3BhY2UsIGhvdmVyVG9vbHRpcCwga2V5bWFwLCBsYXllciwgbGluZU51bWJlck1hcmtlcnMsIGxpbmVOdW1iZXJzLCBsb2dFeGNlcHRpb24sIHBhbmVscywgcGxhY2Vob2xkZXIsIHJlY3Rhbmd1bGFyU2VsZWN0aW9uLCByZXBvc2l0aW9uVG9vbHRpcHMsIHJ1blNjb3BlSGFuZGxlcnMsIHNjcm9sbFBhc3RFbmQsIHNob3dQYW5lbCwgc2hvd1Rvb2x0aXAsIHRvb2x0aXBzIH07XG4iXSwibmFtZXMiOlsiVGV4dCIsIlJhbmdlU2V0IiwiTWFwTW9kZSIsIlJhbmdlVmFsdWUiLCJmaW5kQ2x1c3RlckJyZWFrIiwiRWRpdG9yU2VsZWN0aW9uIiwiRmFjZXQiLCJTdGF0ZUVmZmVjdCIsIkNoYW5nZVNldCIsImZpbmRDb2x1bW4iLCJDaGFyQ2F0ZWdvcnkiLCJBbm5vdGF0aW9uIiwiRWRpdG9yU3RhdGUiLCJUcmFuc2FjdGlvbiIsIlByZWMiLCJjb2RlUG9pbnRBdCIsImNvZGVQb2ludFNpemUiLCJjb21iaW5lQ29uZmlnIiwiU3RhdGVGaWVsZCIsIlJhbmdlU2V0QnVpbGRlciIsImNvdW50Q29sdW1uIiwiU3R5bGVNb2R1bGUiLCJrZXlOYW1lIiwiYmFzZSIsInNoaWZ0IiwiZ2V0U2VsZWN0aW9uIiwicm9vdCIsInRhcmdldCIsIm5vZGVUeXBlIiwib3duZXJEb2N1bWVudCIsImNvbnRhaW5zIiwiZG9tIiwibm9kZSIsInBhcmVudE5vZGUiLCJkZWVwQWN0aXZlRWxlbWVudCIsImRvYyIsImVsdCIsImFjdGl2ZUVsZW1lbnQiLCJzaGFkb3dSb290IiwiaGFzU2VsZWN0aW9uIiwic2VsZWN0aW9uIiwiYW5jaG9yTm9kZSIsIl8iLCJjbGllbnRSZWN0c0ZvciIsInRleHRSYW5nZSIsIm5vZGVWYWx1ZSIsImxlbmd0aCIsImdldENsaWVudFJlY3RzIiwiaXNFcXVpdmFsZW50UG9zaXRpb24iLCJvZmYiLCJ0YXJnZXROb2RlIiwidGFyZ2V0T2ZmIiwic2NhbkZvciIsImRvbUluZGV4IiwiaW5kZXgiLCJwcmV2aW91c1NpYmxpbmciLCJkaXIiLCJtYXhPZmZzZXQiLCJub2RlTmFtZSIsInBhcmVudCIsImNoaWxkTm9kZXMiLCJjb250ZW50RWRpdGFibGUiLCJmbGF0dGVuUmVjdCIsInJlY3QiLCJsZWZ0IiwieCIsInJpZ2h0IiwidG9wIiwiYm90dG9tIiwid2luZG93UmVjdCIsIndpbiIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsImdldFNjYWxlIiwic2NhbGVYIiwid2lkdGgiLCJvZmZzZXRXaWR0aCIsInNjYWxlWSIsImhlaWdodCIsIm9mZnNldEhlaWdodCIsImlzRmluaXRlIiwiTWF0aCIsImFicyIsInNjcm9sbFJlY3RJbnRvVmlldyIsInNpZGUiLCJ5IiwieE1hcmdpbiIsInlNYXJnaW4iLCJsdHIiLCJkZWZhdWx0VmlldyIsIndpbmRvdyIsImN1ciIsInN0b3AiLCJib3VuZGluZyIsImJvZHkiLCJ0ZXN0IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInBvc2l0aW9uIiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50SGVpZ2h0Iiwic2Nyb2xsV2lkdGgiLCJjbGllbnRXaWR0aCIsImFzc2lnbmVkU2xvdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIm1vdmVYIiwibW92ZVkiLCJyZWN0SGVpZ2h0IiwiYm91bmRpbmdIZWlnaHQiLCJ0YXJnZXRUb3AiLCJ0YXJnZXRMZWZ0Iiwic2Nyb2xsQnkiLCJtb3ZlZFgiLCJtb3ZlZFkiLCJzdGFydCIsInNjcm9sbFRvcCIsInNjcm9sbExlZnQiLCJob3N0Iiwic2Nyb2xsYWJsZVBhcmVudCIsIkRPTVNlbGVjdGlvblN0YXRlIiwiY29uc3RydWN0b3IiLCJhbmNob3JPZmZzZXQiLCJmb2N1c05vZGUiLCJmb2N1c09mZnNldCIsImVxIiwiZG9tU2VsIiwic2V0UmFuZ2UiLCJyYW5nZSIsInNldCIsIm1pbiIsInByZXZlbnRTY3JvbGxTdXBwb3J0ZWQiLCJmb2N1c1ByZXZlbnRTY3JvbGwiLCJzZXRBY3RpdmUiLCJmb2N1cyIsInN0YWNrIiwicHVzaCIsInByZXZlbnRTY3JvbGwiLCJ1bmRlZmluZWQiLCJpIiwic2NyYXRjaFJhbmdlIiwiZnJvbSIsInRvIiwiZG9jdW1lbnQiLCJjcmVhdGVSYW5nZSIsInNldEVuZCIsInNldFN0YXJ0IiwiZGlzcGF0Y2hLZXkiLCJuYW1lIiwiY29kZSIsIm9wdGlvbnMiLCJrZXkiLCJrZXlDb2RlIiwid2hpY2giLCJjYW5jZWxhYmxlIiwiZG93biIsIktleWJvYXJkRXZlbnQiLCJzeW50aGV0aWMiLCJkaXNwYXRjaEV2ZW50IiwidXAiLCJkZWZhdWx0UHJldmVudGVkIiwiZ2V0Um9vdCIsImNsZWFyQXR0cmlidXRlcyIsImF0dHJpYnV0ZXMiLCJyZW1vdmVBdHRyaWJ1dGVOb2RlIiwiYXRFbGVtZW50U3RhcnQiLCJvZmZzZXQiLCJwcmV2IiwiaXNTY3JvbGxlZFRvQm90dG9tIiwibWF4IiwiRE9NUG9zIiwicHJlY2lzZSIsImJlZm9yZSIsImFmdGVyIiwibm9DaGlsZHJlbiIsIkNvbnRlbnRWaWV3IiwiZmxhZ3MiLCJvdmVycmlkZURPTVRleHQiLCJwb3NBdFN0YXJ0IiwicG9zQmVmb3JlIiwicG9zQXRFbmQiLCJ2aWV3IiwicG9zIiwiY2hpbGQiLCJjaGlsZHJlbiIsImJyZWFrQWZ0ZXIiLCJSYW5nZUVycm9yIiwicG9zQWZ0ZXIiLCJzeW5jIiwidHJhY2siLCJuZXh0IiwibmV4dFNpYmxpbmciLCJmaXJzdENoaWxkIiwiY29udGVudFZpZXciLCJnZXQiLCJjYW5SZXVzZURPTSIsInJldXNlRE9NIiwid3JpdHRlbiIsInJtJDEiLCJpbnNlcnRCZWZvcmUiLCJfZG9tIiwibG9jYWxQb3NGcm9tRE9NIiwiYmlhcyIsImxhc3RDaGlsZCIsImRvbUJvdW5kc0Fyb3VuZCIsImZyb21JIiwiZnJvbVN0YXJ0IiwidG9JIiwidG9FbmQiLCJwcmV2RW5kIiwiZW5kIiwic3RhcnRET00iLCJlbmRET00iLCJtYXJrRGlydHkiLCJhbmRQYXJlbnQiLCJtYXJrUGFyZW50c0RpcnR5IiwiY2hpbGRMaXN0Iiwic2V0UGFyZW50Iiwic2V0RE9NIiwiY21WaWV3Iiwicm9vdFZpZXciLCJ2IiwicmVwbGFjZUNoaWxkcmVuIiwiaW5kZXhPZiIsImRlc3Ryb3kiLCJzcGxpY2UiLCJpZ25vcmVNdXRhdGlvbiIsIl9yZWMiLCJpZ25vcmVFdmVudCIsIl9ldmVudCIsImNoaWxkQ3Vyc29yIiwiQ2hpbGRDdXJzb3IiLCJjaGlsZFBvcyIsImZpbmRQb3MiLCJ0b1N0cmluZyIsInJlcGxhY2UiLCJqb2luIiwidGV4dCIsImlzRWRpdGFibGUiLCJpc1dpZGdldCIsImlzSGlkZGVuIiwibWVyZ2UiLCJzb3VyY2UiLCJoYXNTdGFydCIsIm9wZW5TdGFydCIsIm9wZW5FbmQiLCJiZWNvbWUiLCJvdGhlciIsImdldFNpZGUiLCJwcm90b3R5cGUiLCJyZW1vdmVDaGlsZCIsInJlcGxhY2VSYW5nZSIsImZyb21PZmYiLCJ0b09mZiIsImluc2VydCIsImJyZWFrQXRTdGFydCIsImxhc3QiLCJicmVha0F0RW5kIiwic3BsaXQiLCJwb3AiLCJtZXJnZUNoaWxkcmVuSW50byIsImRMZW4iLCJuYXYiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ2ZW5kb3IiLCJwbGF0Zm9ybSIsImRvY3VtZW50RWxlbWVudCIsInN0eWxlIiwiaWVfZWRnZSIsImV4ZWMiLCJpZV91cHRvMTAiLCJpZV8xMXVwIiwiaWUiLCJnZWNrbyIsImNocm9tZSIsIndlYmtpdCIsInNhZmFyaSIsImlvcyIsIm1heFRvdWNoUG9pbnRzIiwiYnJvd3NlciIsIm1hYyIsIndpbmRvd3MiLCJsaW51eCIsImllX3ZlcnNpb24iLCJkb2N1bWVudE1vZGUiLCJnZWNrb192ZXJzaW9uIiwiY2hyb21lX3ZlcnNpb24iLCJhbmRyb2lkIiwid2Via2l0X3ZlcnNpb24iLCJ0YWJTaXplIiwiTWF4Sm9pbkxlbiIsIlRleHRWaWV3IiwiY3JlYXRlRE9NIiwidGV4dERPTSIsImNyZWF0ZVRleHROb2RlIiwic2xpY2UiLCJyZXN1bHQiLCJkb21BdFBvcyIsIl9mcm9tIiwiX3RvIiwiY29vcmRzQXQiLCJ0ZXh0Q29vcmRzIiwiTWFya1ZpZXciLCJtYXJrIiwiY2giLCJzZXRBdHRycyIsImNsYXNzIiwiY2xhc3NOYW1lIiwiYXR0cnMiLCJzZXRBdHRyaWJ1dGUiLCJ0YWdOYW1lIiwidG9VcHBlckNhc2UiLCJjcmVhdGVFbGVtZW50IiwiX2hhc1N0YXJ0IiwiZGV0YWNoRnJvbSIsImlubGluZURPTUF0UG9zIiwiY29vcmRzSW5DaGlsZHJlbiIsImZsYXR0ZW4iLCJyZWN0cyIsIkFycmF5IiwiZmluZCIsImNhbGwiLCJyIiwiV2lkZ2V0VmlldyIsImNyZWF0ZSIsIndpZGdldCIsInByZXZXaWRnZXQiLCJ1cGRhdGVET00iLCJ0b0RPTSIsImVkaXRhYmxlIiwiY29tcGFyZSIsImV2ZW50IiwiZW1wdHkiLCJzdGF0ZSIsImN1c3RvbSIsImZyb21CYWNrIiwiV2lkZ2V0QnVmZmVyVmlldyIsImoiLCJqb2luSW5saW5lSW50byIsIm9wZW4iLCJiZWZvcmVQb3MiLCJhZnRlclBvcyIsInNjYW4iLCJmYWxsYmFja1JlY3QiLCJjb21iaW5lQXR0cnMiLCJub0F0dHJzIiwiT2JqZWN0IiwiYXR0cnNFcSIsImEiLCJiIiwiaWdub3JlIiwia2V5c0EiLCJrZXlzIiwia2V5c0IiLCJ1cGRhdGVBdHRycyIsImNoYW5nZWQiLCJjc3NUZXh0IiwicmVtb3ZlQXR0cmlidXRlIiwiZ2V0QXR0cnMiLCJhdHRyIiwidmFsdWUiLCJMaW5lVmlldyIsImFyZ3VtZW50cyIsInByZXZBdHRycyIsInRyYW5zZmVyRE9NIiwic2V0RGVjbyIsImF0IiwiYXBwZW5kIiwiYWRkTGluZURlY28iLCJkZWNvIiwic3BlYyIsImNscyIsIl9hIiwiY2xhc3NMaXN0IiwiYWRkIiwic29tZSIsImhhY2siLCJjbUlnbm9yZSIsImFwcGVuZENoaWxkIiwibWVhc3VyZVRleHRTaXplIiwidG90YWxXaWR0aCIsInRleHRIZWlnaHQiLCJsaW5lSGVpZ2h0IiwiY2hhcldpZHRoIiwiaGVpZ2h0T3JhY2xlIiwidmlld1N0YXRlIiwiZGlzdCIsIl9vdGhlciIsImNvdmVycyIsImRvY1ZpZXciLCJibG9jayIsIkJsb2NrV2lkZ2V0VmlldyIsIl90YWtlRGVjbyIsImxlbiIsInN0YXJ0U2lkZSIsImVuZFNpZGUiLCJXaWRnZXRUeXBlIiwiZXN0aW1hdGVkSGVpZ2h0IiwibGluZUJyZWFrcyIsIkJsb2NrVHlwZSIsIkRlY29yYXRpb24iLCJoZWlnaHRSZWxldmFudCIsIk1hcmtEZWNvcmF0aW9uIiwiaW5saW5lT3JkZXIiLCJQb2ludERlY29yYXRpb24iLCJpc0Jsb2NrR2FwIiwiZ2V0SW5jbHVzaXZlIiwibGluZSIsIkxpbmVEZWNvcmF0aW9uIiwib2YiLCJzb3J0IiwiaGFzSGVpZ2h0Iiwibm9uZSIsIl9iIiwicG9pbnQiLCJtYXBNb2RlIiwiVHJhY2tCZWZvcmUiLCJpc1JlcGxhY2UiLCJUcmFja0RlbCIsIlRyYWNrQWZ0ZXIiLCJ0eXBlIiwiV2lkZ2V0UmFuZ2UiLCJXaWRnZXRCZWZvcmUiLCJXaWRnZXRBZnRlciIsIndpZGdldHNFcSIsImluY2x1c2l2ZVN0YXJ0IiwiaW5jbHVzaXZlRW5kIiwiaW5jbHVzaXZlIiwiYWRkUmFuZ2UiLCJyYW5nZXMiLCJtYXJnaW4iLCJDb250ZW50QnVpbGRlciIsImRpc2FsbG93QmxvY2tFZmZlY3RzRm9yIiwiY29udGVudCIsImN1ckxpbmUiLCJwZW5kaW5nQnVmZmVyIiwiYnVmZmVyTWFya3MiLCJhdEN1cnNvclBvcyIsInRleHRPZmYiLCJjdXJzb3IiLCJpdGVyIiwic2tpcCIsInBvc0NvdmVyZWQiLCJsaW5lQXQiLCJnZXRMaW5lIiwiZmx1c2hCdWZmZXIiLCJhY3RpdmUiLCJ3cmFwTWFya3MiLCJhZGRCbG9ja1dpZGdldCIsImZpbmlzaCIsImJ1aWxkVGV4dCIsImxpbmVCcmVhayIsImRvbmUiLCJFcnJvciIsInRha2UiLCJzcGFuIiwiTnVsbFdpZGdldCIsImN1cnNvckJlZm9yZSIsImN1cnNvckFmdGVyIiwiYnVpbGQiLCJkZWNvcmF0aW9ucyIsImR5bmFtaWNEZWNvcmF0aW9uTWFwIiwiYnVpbGRlciIsInNwYW5zIiwidGFnIiwidG9Mb3dlckNhc2UiLCJEaXJlY3Rpb24iLCJMVFIiLCJSVEwiLCJkZWMiLCJzdHIiLCJMb3dUeXBlcyIsIkFyYWJpY1R5cGVzIiwiQnJhY2tldHMiLCJCcmFja2V0U3RhY2siLCJwIiwibCIsImNoYXJDb2RlQXQiLCJjaGFyVHlwZSIsIkJpZGlSRSIsIkJpZGlTcGFuIiwibGV2ZWwiLCJmb3J3YXJkIiwib3JkZXIiLCJhc3NvYyIsIm1heWJlIiwiaXNvbGF0ZXNFcSIsImlBIiwiaUIiLCJkaXJlY3Rpb24iLCJpbm5lciIsInR5cGVzIiwiY29tcHV0ZUNoYXJUeXBlcyIsInJGcm9tIiwiclRvIiwiaXNvbGF0ZXMiLCJvdXRlclR5cGUiLCJpSSIsInByZXZUeXBlIiwicHJldlN0cm9uZyIsInByb2Nlc3NCcmFja2V0UGFpcnMiLCJvcHBvc2l0ZVR5cGUiLCJzSSIsImNvbnRleHQiLCJiciIsInNKIiwiZW1iZWQiLCJwcm9jZXNzTmV1dHJhbHMiLCJiZWZvcmVMIiwiYWZ0ZXJMIiwiakkiLCJmcm9tSiIsImVtaXRTcGFucyIsImJhc2VMZXZlbCIsIm91clR5cGUiLCJpQ2giLCJzYW1lRGlyIiwiaXNOdW0iLCJyZWN1cnNlIiwibG9jYWxMZXZlbCIsImlTY2FuIiwicnVuIiwiaXNvIiwidXB0byIsImRpclN3YXAiLCJjb21wdXRlU2VjdGlvbk9yZGVyIiwiY29tcHV0ZU9yZGVyIiwidHJpdmlhbE9yZGVyIiwibW92ZWRPdmVyIiwibW92ZVZpc3VhbGx5Iiwic3RhcnRJbmRleCIsImhlYWQiLCJzcGFuSSIsImJpZGlMZXZlbCIsInNwYW5FbmQiLCJuZXh0SSIsIm5leHRJbmRleCIsIm5leHRTcGFuIiwiYXV0b0RpcmVjdGlvbiIsImNsaWNrQWRkc1NlbGVjdGlvblJhbmdlIiwiZGVmaW5lIiwiZHJhZ01vdmVzU2VsZWN0aW9uJDEiLCJtb3VzZVNlbGVjdGlvblN0eWxlIiwiZXhjZXB0aW9uU2luayIsInVwZGF0ZUxpc3RlbmVyIiwiaW5wdXRIYW5kbGVyIiwiZm9jdXNDaGFuZ2VFZmZlY3QiLCJwZXJMaW5lVGV4dERpcmVjdGlvbiIsImNvbWJpbmUiLCJ2YWx1ZXMiLCJuYXRpdmVTZWxlY3Rpb25IaWRkZW4iLCJTY3JvbGxUYXJnZXQiLCJpc1NuYXBzaG90IiwibWFwIiwiY2hhbmdlcyIsImNsaXAiLCJzY3JvbGxJbnRvVmlldyIsInQiLCJsb2dFeGNlcHRpb24iLCJleGNlcHRpb24iLCJoYW5kbGVyIiwiZmFjZXQiLCJvbmVycm9yIiwiU3RyaW5nIiwiY29uc29sZSIsImVycm9yIiwibmV4dFBsdWdpbklEIiwidmlld1BsdWdpbiIsIlZpZXdQbHVnaW4iLCJpZCIsImRvbUV2ZW50SGFuZGxlcnMiLCJkb21FdmVudE9ic2VydmVycyIsImJ1aWxkRXh0ZW5zaW9ucyIsImV4dGVuc2lvbiIsImV2ZW50SGFuZGxlcnMiLCJldmVudE9ic2VydmVycyIsInByb3ZpZGUiLCJwbHVnaW4iLCJleHQiLCJwbHVnaW5JbnN0IiwiZnJvbUNsYXNzIiwiUGx1Z2luSW5zdGFuY2UiLCJtdXN0VXBkYXRlIiwidXBkYXRlIiwiZSIsImRlYWN0aXZhdGUiLCJlZGl0b3JBdHRyaWJ1dGVzIiwiY29udGVudEF0dHJpYnV0ZXMiLCJvdXRlckRlY29yYXRpb25zIiwiYXRvbWljUmFuZ2VzIiwiYmlkaUlzb2xhdGVkUmFuZ2VzIiwiZ2V0SXNvbGF0ZWRSYW5nZXMiLCJzZXRzIiwiRnVuY3Rpb24iLCJmcm9tRG9jIiwidG9Eb2MiLCJiaWRpSXNvbGF0ZSIsInNjcm9sbE1hcmdpbnMiLCJnZXRTY3JvbGxNYXJnaW5zIiwibSIsInN0eWxlTW9kdWxlIiwiQ2hhbmdlZFJhbmdlIiwiZnJvbUEiLCJ0b0EiLCJmcm9tQiIsInRvQiIsImFkZFRvU2V0IiwibWUiLCJleHRlbmRXaXRoUmFuZ2VzIiwiZGlmZiIsImRJIiwickkiLCJwb3NBIiwicG9zQiIsIlZpZXdVcGRhdGUiLCJ0cmFuc2FjdGlvbnMiLCJzdGFydFN0YXRlIiwidHIiLCJjb21wb3NlIiwiY2hhbmdlZFJhbmdlcyIsIml0ZXJDaGFuZ2VkUmFuZ2VzIiwidmlld3BvcnRDaGFuZ2VkIiwiaGVpZ2h0Q2hhbmdlZCIsImdlb21ldHJ5Q2hhbmdlZCIsImRvY0NoYW5nZWQiLCJmb2N1c0NoYW5nZWQiLCJzZWxlY3Rpb25TZXQiLCJEb2NWaWV3IiwiZG9tQ2hhbmdlZCIsImhhc0NvbXBvc2l0aW9uIiwibWFya2VkRm9yQ29tcG9zaXRpb24iLCJTZXQiLCJtaW5XaWR0aCIsIm1pbldpZHRoRnJvbSIsIm1pbldpZHRoVG8iLCJpbXByZWNpc2VBbmNob3IiLCJpbXByZWNpc2VIZWFkIiwiZm9yY2VTZWxlY3Rpb24iLCJsYXN0VXBkYXRlIiwiRGF0ZSIsIm5vdyIsImNvbnRlbnRET00iLCJ1cGRhdGVEZWNvIiwidXBkYXRlSW5uZXIiLCJldmVyeSIsIm1hcFBvcyIsInJlYWRDb21wb3NpdGlvbkF0IiwiaW5wdXRTdGF0ZSIsImNvbXBvc2luZyIsIm5ld1NlbCIsInRvdWNoZXNDb21wb3NpdGlvbiIsIm1haW4iLCJjb21wb3NpdGlvbiIsImZpbmRDb21wb3NpdGlvblJhbmdlIiwiY2xlYXIiLCJsaW5lcyIsInByZXZEZWNvIiwiZGVjb0RpZmYiLCJmaW5kQ2hhbmdlZERlY28iLCJvbGRMZW5ndGgiLCJtdXN0TWVhc3VyZUNvbnRlbnQiLCJ1cGRhdGVDaGlsZHJlbiIsIm9ic2VydmVyIiwiY29udGVudEhlaWdodCIsImZsZXhCYXNpcyIsInNlbGVjdGlvblJhbmdlIiwiZm9yRWFjaCIsImNWaWV3IiwiZ2FwcyIsInZpZXdwb3J0IiwiQmxvY2tHYXBXaWRnZXQiLCJ1cGRhdGVHYXBzIiwiY29tcExpbmUiLCJjb21wb3NpdGlvblZpZXciLCJjb25jYXQiLCJmaXhDb21wb3NpdGlvbkRPTSIsIm1hcmtzIiwiZml4IiwiYyIsInVwZGF0ZVNlbGVjdGlvbiIsIm11c3RSZWFkIiwiZnJvbVBvaW50ZXIiLCJyZWFkU2VsZWN0aW9uUmFuZ2UiLCJhY3RpdmVFbHQiLCJmb2N1c2VkIiwic2VsZWN0aW9uTm90Rm9jdXMiLCJmb3JjZSIsImFuY2hvciIsIm1vdmVUb0xpbmUiLCJiZXR3ZWVuVW5lZGl0YWJsZSIsImR1bW15Iiwic3VwcHJlc3NXaWRnZXRDdXJzb3JDaGFuZ2UiLCJpblVuZWRpdGFibGUiLCJibHVyIiwicmF3U2VsIiwibmV4dFRvIiwibmV4dFRvVW5lZGl0YWJsZSIsIm5lYXJieVRleHROb2RlIiwiY29sbGFwc2UiLCJjYXJldEJpZGlMZXZlbCIsImV4dGVuZCIsInJlbW92ZUFsbFJhbmdlcyIsInNldFNlbGVjdGlvblJhbmdlIiwic2VsIiwicG9zRnJvbURPTSIsImVuZm9yY2VDdXJzb3JBc3NvYyIsIm1vZGlmeSIsImxpbmVTdGFydCIsIm5ld1JhbmdlIiwibmV3UG9zIiwibmVhcmVzdCIsImRvbVZpZXciLCJiZXN0IiwiYmVzdFBvcyIsImNvb3Jkc0ZvckNoYXIiLCJjaGlsZE9mZiIsIm1lYXN1cmVWaXNpYmxlTGluZUhlaWdodHMiLCJjb250ZW50V2lkdGgiLCJpc1dpZGVyIiwic2Nyb2xsRE9NIiwid2lkZXN0IiwidGV4dERpcmVjdGlvbiIsImNoaWxkUmVjdCIsInRleHREaXJlY3Rpb25BdCIsIm1lYXN1cmUiLCJ0ZXh0Q29udGVudCIsInJlbW92ZSIsImNvbXB1dGVCbG9ja0dhcERlY28iLCJ2cyIsInZpZXdwb3J0cyIsImxpbmVCbG9ja0F0IiwiYWxsRGVjbyIsImQiLCJkeW5hbWljIiwiZHluYW1pY091dGVyIiwib3V0ZXJEZWNvIiwibGluZUdhcERlY28iLCJyZWYiLCJtYXJnaW5zIiwidGFyZ2V0UmVjdCIsImZpbmRDb21wb3NpdGlvbk5vZGUiLCJoZWFkUG9zIiwidGV4dE5vZGUiLCJmb3VuZCIsInNsaWNlU3RyaW5nIiwiaW52IiwiaW52ZXJ0ZWREZXNjIiwicGFyZW50VmlldyIsInN0YXJ0Tm9kZSIsInN0YXJ0T2Zmc2V0IiwiRGVjb3JhdGlvbkNvbXBhcmF0b3IkMSIsIkRlY29yYXRpb25Db21wYXJhdG9yIiwiY29tcGFyZVJhbmdlIiwiY29tcGFyZVBvaW50IiwiY29tcCIsImluc2lkZSIsInRvdWNoZWQiLCJncm91cEF0IiwiY2F0ZWdvcml6ZSIsImNoYXJDYXRlZ29yaXplciIsImxpbmVQb3MiLCJjYXQiLCJnZXRkeCIsImdldGR5IiwieU92ZXJsYXAiLCJ1cFRvcCIsInVwQm90IiwiZG9tUG9zQXRDb29yZHMiLCJjbG9zZXN0IiwiY2xvc2VzdFJlY3QiLCJjbG9zZXN0WCIsImNsb3Nlc3RZIiwiY2xvc2VzdE92ZXJsYXAiLCJhYm92ZSIsImJlbG93IiwiYWJvdmVSZWN0IiwiYmVsb3dSZWN0IiwiZHgiLCJkeSIsImRvbVBvc0luVGV4dCIsImNsaXBYIiwiY2xvc2VzdE9mZnNldCIsImNsb3Nlc3REWSIsImdlbmVyYWxTaWRlIiwicmVjdEJlZm9yZSIsInBvc0F0Q29vcmRzIiwiY29vcmRzIiwiZG9jVG9wIiwicGFkZGluZ1RvcCIsImRvY0hlaWdodCIsInlPZmZzZXQiLCJoYWxmTGluZSIsImJvdW5jZWQiLCJlbGVtZW50QXRIZWlnaHQiLCJwb3NBdENvb3Jkc0ltcHJlY2lzZSIsImVsZW1lbnRGcm9tUG9pbnQiLCJlbGVtZW50IiwiY2FyZXRQb3NpdGlvbkZyb21Qb2ludCIsIm9mZnNldE5vZGUiLCJjYXJldFJhbmdlRnJvbVBvaW50Iiwic3RhcnRDb250YWluZXIiLCJpc1N1c3BpY2lvdXNTYWZhcmlDYXJldFJlc3VsdCIsImlzU3VzcGljaW91c0Nocm9tZUNhcmV0UmVzdWx0IiwiY29udGVudFJlY3QiLCJpbnRvIiwicm91bmQiLCJkZWZhdWx0Q2hhcmFjdGVyV2lkdGgiLCJsaW5lV3JhcHBpbmciLCJkZWZhdWx0TGluZUhlaWdodCIsImZsb29yIiwibGluZUxlbmd0aCIsInNsaWNlRG9jIiwiYmxvY2tBdCIsImlzQXJyYXkiLCJtb3ZlVG9MaW5lQm91bmRhcnkiLCJpbmNsdWRlV3JhcCIsIndpZGdldExpbmVCcmVha3MiLCJjb29yZHNBdFBvcyIsImVkaXRvclJlY3QiLCJtb3ZlQnlDaGFyIiwiYnkiLCJiaWRpU3BhbnMiLCJjaGVjayIsImNoYXIiLCJudW1iZXIiLCJ2aXN1YWxMaW5lU2lkZSIsImJ5R3JvdXAiLCJuZXh0Q2F0IiwiU3BhY2UiLCJtb3ZlVmVydGljYWxseSIsImRpc3RhbmNlIiwic3RhcnRQb3MiLCJnb2FsIiwiZ29hbENvbHVtbiIsInN0YXJ0WSIsInN0YXJ0Q29vcmRzIiwiZG9jdW1lbnRUb3AiLCJyZXNvbHZlZEdvYWwiLCJleHRyYSIsImN1clkiLCJjaGFyUmVjdCIsInNraXBBdG9taWNSYW5nZXMiLCJhdG9tcyIsIm1vdmVkIiwiYmV0d2VlbiIsInNraXBBdG9tcyIsIm9sZFBvcyIsImYiLCJJbnB1dFN0YXRlIiwic2V0U2VsZWN0aW9uT3JpZ2luIiwib3JpZ2luIiwibGFzdFNlbGVjdGlvbk9yaWdpbiIsImxhc3RTZWxlY3Rpb25UaW1lIiwibGFzdEtleUNvZGUiLCJsYXN0S2V5VGltZSIsImxhc3RUb3VjaFRpbWUiLCJsYXN0Rm9jdXNUaW1lIiwibGFzdFNjcm9sbFRvcCIsImxhc3RTY3JvbGxMZWZ0IiwicGVuZGluZ0lPU0tleSIsImxhc3RFc2NQcmVzcyIsImxhc3RDb250ZXh0TWVudSIsInNjcm9sbEhhbmRsZXJzIiwiaGFuZGxlcnMiLCJjb21wb3NpdGlvbkZpcnN0Q2hhbmdlIiwiY29tcG9zaXRpb25FbmRlZEF0IiwiY29tcG9zaXRpb25QZW5kaW5nS2V5IiwiY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlIiwibW91c2VTZWxlY3Rpb24iLCJkcmFnZ2VkQ29udGVudCIsImhhbmRsZUV2ZW50IiwiYmluZCIsIm5vdGlmaWVkRm9jdXNlZCIsImhhc0ZvY3VzIiwiYWRkRXZlbnRMaXN0ZW5lciIsImZpcmVmb3hDb3B5Q3V0SGFjayIsImV2ZW50QmVsb25nc1RvRWRpdG9yIiwiaWdub3JlRHVyaW5nQ29tcG9zaXRpb24iLCJrZXlkb3duIiwicnVuSGFuZGxlcnMiLCJvYnNlcnZlcnMiLCJwcmV2ZW50RGVmYXVsdCIsImVuc3VyZUhhbmRsZXJzIiwicGx1Z2lucyIsImNvbXB1dGVIYW5kbGVycyIsInBhc3NpdmUiLCJleGlzdHMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibW9kaWZpZXJDb2RlcyIsImRlbGF5QW5kcm9pZEtleSIsInBlbmRpbmciLCJhbHRLZXkiLCJtZXRhS2V5IiwiUGVuZGluZ0tleXMiLCJjdHJsS2V5IiwiRW1hY3N5UGVuZGluZ0tleXMiLCJzaGlmdEtleSIsInNldFRpbWVvdXQiLCJmbHVzaElPU0tleSIsImZvcmNlRmx1c2giLCJzdGFydE1vdXNlU2VsZWN0aW9uIiwiYmluZEhhbmRsZXIiLCJyZWNvcmQiLCJpbnB1dFR5cGUiLCJkcmFnU2Nyb2xsTWFyZ2luIiwiZHJhZ1Njcm9sbFNwZWVkIiwiY2xpZW50WCIsImNsaWVudFkiLCJNb3VzZVNlbGVjdGlvbiIsInN0YXJ0RXZlbnQiLCJtdXN0U2VsZWN0Iiwic2Nyb2xsU3BlZWQiLCJzY3JvbGxpbmciLCJsYXN0RXZlbnQiLCJzY3JvbGxQYXJlbnQiLCJtb3ZlIiwibXVsdGlwbGUiLCJhbGxvd011bHRpcGxlU2VsZWN0aW9ucyIsImFkZHNTZWxlY3Rpb25SYW5nZSIsImRyYWdnaW5nIiwiaXNJblByaW1hcnlTZWxlY3Rpb24iLCJnZXRDbGlja1R5cGUiLCJzZWxlY3QiLCJidXR0b25zIiwic3giLCJzeSIsInNldFNjcm9sbFNwZWVkIiwic2V0SW50ZXJ2YWwiLCJzY3JvbGwiLCJjbGVhckludGVydmFsIiwidXBkYXRlZCIsIm1haW5JbmRleCIsImRpc3BhdGNoIiwidXNlckV2ZW50IiwiZHJhZ01vdmVzU2VsZWN0aW9uIiwicmFuZ2VDb3VudCIsImdldFJhbmdlQXQiLCJidWJibGVzIiwiYnJva2VuQ2xpcGJvYXJkQVBJIiwiY2FwdHVyZVBhc3RlIiwiZG9QYXN0ZSIsImlucHV0IiwidG9UZXh0IiwiYnlMaW5lIiwibGluZXdpc2UiLCJsYXN0TGluZXdpc2VDb3B5IiwibGFzdExpbmUiLCJjaGFuZ2VCeVJhbmdlIiwicmVwbGFjZVNlbGVjdGlvbiIsInRvdWNoc3RhcnQiLCJ0b3VjaG1vdmUiLCJtb3VzZWRvd24iLCJmbHVzaCIsIm1ha2VTdHlsZSIsImJ1dHRvbiIsImJhc2ljTW91c2VTZWxlY3Rpb24iLCJtdXN0Rm9jdXMiLCJtb3VzZVNlbCIsInJhbmdlRm9yQ2xpY2siLCJ2aXN1YWwiLCJpbnNpZGVZIiwiZmluZFBvc2l0aW9uU2lkZSIsInF1ZXJ5UG9zIiwiQmFkTW91c2VEZXRhaWwiLCJsYXN0TW91c2VEb3duIiwibGFzdE1vdXNlRG93bkNvdW50IiwibGFzdE1vdXNlRG93blRpbWUiLCJkZXRhaWwiLCJsYXN0VGltZSIsInN0YXJ0U2VsIiwicmVtb3ZlZCIsInN0YXJ0UmFuZ2UiLCJyZW1vdmVSYW5nZUFyb3VuZCIsImRyYWdzdGFydCIsImRyYWdnYWJsZSIsImRhdGFUcmFuc2ZlciIsInNldERhdGEiLCJlZmZlY3RBbGxvd2VkIiwiZHJhZ2VuZCIsImRyb3BUZXh0IiwiZGlyZWN0IiwiZHJvcFBvcyIsImRlbCIsImlucyIsImRyb3AiLCJyZWFkT25seSIsImZpbGVzIiwicmVhZCIsImZpbmlzaEZpbGUiLCJmaWx0ZXIiLCJzIiwicmVhZGVyIiwiRmlsZVJlYWRlciIsIm9ubG9hZCIsInJlYWRBc1RleHQiLCJnZXREYXRhIiwicGFzdGUiLCJkYXRhIiwiY2xpcGJvYXJkRGF0YSIsImNhcHR1cmVDb3B5Iiwic2VsZWN0aW9uRW5kIiwic2VsZWN0aW9uU3RhcnQiLCJjb3BpZWRSYW5nZSIsImNvcHkiLCJjdXQiLCJjbGVhckRhdGEiLCJpc0ZvY3VzQ2hhbmdlIiwiZm9jdXNDaGFuZ2VUcmFuc2FjdGlvbiIsImVmZmVjdHMiLCJnZXRFZmZlY3QiLCJlZmZlY3QiLCJhbm5vdGF0aW9ucyIsInVwZGF0ZUZvckZvY3VzQ2hhbmdlIiwiY2xlYXJTZWxlY3Rpb25SYW5nZSIsImNvbXBvc2l0aW9uc3RhcnQiLCJjb21wb3NpdGlvbnVwZGF0ZSIsImNvbXBvc2l0aW9uZW5kIiwicGVuZGluZ1JlY29yZHMiLCJmbHVzaFNvb24iLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJjb250ZXh0bWVudSIsImJlZm9yZWlucHV0Iiwic3RhcnRWaWV3SGVpZ2h0IiwidmlzdWFsVmlld3BvcnQiLCJhcHBsaWVkRmlyZWZveEhhY2siLCJoYXMiLCJ3cmFwcGluZ1doaXRlU3BhY2UiLCJIZWlnaHRPcmFjbGUiLCJoZWlnaHRTYW1wbGVzIiwiaGVpZ2h0Rm9yR2FwIiwiY2VpbCIsImhlaWdodEZvckxpbmUiLCJzZXREb2MiLCJtdXN0UmVmcmVzaEZvcldyYXBwaW5nIiwid2hpdGVTcGFjZSIsIm11c3RSZWZyZXNoRm9ySGVpZ2h0cyIsImxpbmVIZWlnaHRzIiwibmV3SGVpZ2h0IiwiaCIsInJlZnJlc2giLCJrbm93bkhlaWdodHMiLCJNZWFzdXJlZEhlaWdodHMiLCJoZWlnaHRzIiwibW9yZSIsIkJsb2NrSW5mbyIsIl9jb250ZW50IiwiUXVlcnlUeXBlIiwiRXBzaWxvbiIsIkhlaWdodE1hcCIsIm91dGRhdGVkIiwic2V0SGVpZ2h0Iiwib3JhY2xlIiwibm9kZXMiLCJkZWNvbXBvc2VMZWZ0IiwiZGVjb21wb3NlUmlnaHQiLCJhcHBseUNoYW5nZXMiLCJvbGREb2MiLCJCeVBvc05vSGVpZ2h0IiwiTm9kZUJ1aWxkZXIiLCJ1cGRhdGVIZWlnaHQiLCJIZWlnaHRNYXBUZXh0IiwiYnJlYWsiLCJzaXplIiwiYnJrIiwiSGVpZ2h0TWFwQnJhbmNoIiwiSGVpZ2h0TWFwQmxvY2siLCJfaGVpZ2h0IiwiX29yYWNsZSIsIl92YWx1ZSIsIl90eXBlIiwiZm9yRWFjaExpbmUiLCJfZm9yY2UiLCJtZWFzdXJlZCIsImNvbGxhcHNlZCIsIndpZGdldEhlaWdodCIsImJyZWFrcyIsIkhlaWdodE1hcEdhcCIsImhlaWdodE1ldHJpY3MiLCJmaXJzdExpbmUiLCJwZXJMaW5lIiwicGVyQ2hhciIsInRvdGFsUGVyTGluZSIsImd1ZXNzIiwibGluZVRvcCIsIkJ5SGVpZ2h0IiwibGluZXNBYm92ZSIsImZpcnN0IiwidW5zaGlmdCIsInNpbmdsZUhlaWdodCIsIm1pZCIsInJpZ2h0VG9wIiwicmlnaHRPZmZzZXQiLCJzdWJRdWVyeSIsIkJ5UG9zIiwicmlnaHRTdGFydCIsImJhbGFuY2VkIiwibWVyZ2VHYXBzIiwicmViYWxhbmNlIiwiYXJvdW5kIiwicmVsZXZhbnRXaWRnZXRIZWlnaHQiLCJsaW5lRW5kIiwiY292ZXJpbmciLCJ3cml0dGVuVG8iLCJpc0NvdmVyZWQiLCJhZGRCbG9jayIsImVudGVyTGluZSIsImJsYW5rQ29udGVudCIsImdhcCIsImVuc3VyZUxpbmUiLCJoZWlnaHRSZWxldmFudERlY29DaGFuZ2VzIiwidmlzaWJsZVBpeGVsUmFuZ2UiLCJvdmVyZmxvdyIsInBhcmVudFJlY3QiLCJvZmZzZXRQYXJlbnQiLCJmdWxsUGl4ZWxSYW5nZSIsIkxpbmVHYXAiLCJzYW1lIiwiZ0EiLCJnQiIsImRyYXciLCJ3cmFwcGluZyIsIkxpbmVHYXBXaWRnZXQiLCJ2ZXJ0aWNhbCIsImRpc3BsYXkiLCJWaWV3U3RhdGUiLCJwaXhlbFZpZXdwb3J0IiwiaW5WaWV3IiwicGFkZGluZ0JvdHRvbSIsImNvbnRlbnRET01XaWR0aCIsImNvbnRlbnRET01IZWlnaHQiLCJlZGl0b3JIZWlnaHQiLCJlZGl0b3JXaWR0aCIsInNjcm9sbGVkVG9Cb3R0b20iLCJzY3JvbGxBbmNob3JQb3MiLCJzY3JvbGxBbmNob3JIZWlnaHQiLCJzY2FsZXIiLCJJZFNjYWxlciIsInNjcm9sbFRhcmdldCIsInByaW50aW5nIiwiZGVmYXVsdFRleHREaXJlY3Rpb24iLCJ2aXNpYmxlUmFuZ2VzIiwibXVzdEVuZm9yY2VDdXJzb3JBc3NvYyIsImd1ZXNzV3JhcHBpbmciLCJzdGF0ZURlY28iLCJoZWlnaHRNYXAiLCJnZXRWaWV3cG9ydCIsInVwZGF0ZVZpZXdwb3J0TGluZXMiLCJ1cGRhdGVGb3JWaWV3cG9ydCIsImxpbmVHYXBzIiwiZW5zdXJlTGluZUdhcHMiLCJjb21wdXRlVmlzaWJsZVJhbmdlcyIsIlZpZXdwb3J0IiwiQmlnU2NhbGVyIiwidmlld3BvcnRMaW5lcyIsInNjYWxlIiwic2NhbGVCbG9jayIsImNvbnRlbnRDaGFuZ2VzIiwiaGVpZ2h0Q2hhbmdlcyIsInByZXZIZWlnaHQiLCJzY3JvbGxBbmNob3IiLCJzY3JvbGxBbmNob3JBdCIsIm1hcFZpZXdwb3J0Iiwidmlld3BvcnRJc0FwcHJvcHJpYXRlIiwidXBkYXRlTGluZXMiLCJ1cGRhdGVMaW5lR2FwcyIsIm1hcExpbmVHYXBzIiwiZG9tUmVjdCIsIm1lYXN1cmVDb250ZW50IiwicGFyc2VJbnQiLCJkVG9wIiwiZEJvdHRvbSIsInZwIiwidmlld3BvcnRDaGFuZ2UiLCJ2aXNpYmxlVG9wIiwiZnJvbURPTSIsInZpc2libGVCb3R0b20iLCJtYXJnaW5Ub3AiLCJ2aWV3SGVpZ2h0IiwidG9wUG9zIiwibWFwcGVkIiwidG91Y2hlc1JhbmdlIiwiY3VycmVudCIsIm1heU1lYXN1cmUiLCJoYWxmTWFyZ2luIiwiZG91YmxlTWFyZ2luIiwiYWRkR2FwIiwic3RydWN0dXJlIiwiYXZvaWQiLCJnYXBTaXplIiwibGluZVN0cnVjdHVyZSIsInRvdGFsIiwidmlld0Zyb20iLCJ2aWV3VG8iLCJtYXJnaW5IZWlnaHQiLCJib3QiLCJ0YXJnZXRGcmFjIiwiZmluZEZyYWN0aW9uIiwic3BhY2VGcmFjIiwiZmluZFBvc2l0aW9uIiwibWFyZ2luV2lkdGgiLCJmcmFjdGlvbiIsImxpbmVCbG9ja0F0SGVpZ2h0IiwicmF0aW8iLCJjb3VudGVkIiwiYXJyYXkiLCJ2YWwiLCJuIiwidnBIZWlnaHQiLCJkb21CYXNlIiwiZG9tVG9wIiwiZG9tQm90dG9tIiwib2JqIiwiYlRvcCIsImJCb3R0b20iLCJ0aGVtZSIsInN0cnMiLCJkYXJrVGhlbWUiLCJiYXNlVGhlbWVJRCIsIm5ld05hbWUiLCJiYXNlTGlnaHRJRCIsImJhc2VEYXJrSUQiLCJsaWdodERhcmtJRHMiLCJidWlsZFRoZW1lIiwic2NvcGVzIiwiYmFzZVRoZW1lJDEiLCJib3hTaXppbmciLCJvdXRsaW5lIiwiZmxleERpcmVjdGlvbiIsImFsaWduSXRlbXMiLCJmb250RmFtaWx5Iiwib3ZlcmZsb3dYIiwiekluZGV4IiwiZmxleEdyb3ciLCJmbGV4U2hyaW5rIiwid29yZFdyYXAiLCJtaW5IZWlnaHQiLCJwYWRkaW5nIiwiV2Via2l0VXNlck1vZGlmeSIsIndoaXRlU3BhY2VfZmFsbGJhY2siLCJ3b3JkQnJlYWsiLCJvdmVyZmxvd1dyYXAiLCJjYXJldENvbG9yIiwiY29udGFpbiIsImJhY2tncm91bmQiLCJwb2ludGVyRXZlbnRzIiwiYW5pbWF0aW9uIiwib3BhY2l0eSIsImJvcmRlckxlZnQiLCJtYXJnaW5MZWZ0IiwiYm9yZGVyTGVmdENvbG9yIiwidW5pY29kZUJpZGkiLCJiYWNrZ3JvdW5kQ29sb3IiLCJjb2xvciIsImluc2V0SW5saW5lU3RhcnQiLCJib3JkZXJSaWdodCIsInRleHRBbGlnbiIsImJvcmRlckJvdHRvbSIsImJvcmRlclRvcCIsInZlcnRpY2FsQWxpZ24iLCJiYWNrZ3JvdW5kSW1hZ2UiLCJiYWNrZ3JvdW5kU2l6ZSIsImJhY2tncm91bmRQb3NpdGlvbiIsImJhY2tncm91bmRSZXBlYXQiLCJmb250U2l6ZSIsImJvcmRlclJhZGl1cyIsImJvcmRlciIsIkxpbmVCcmVha1BsYWNlaG9sZGVyIiwiRE9NUmVhZGVyIiwicG9pbnRzIiwibGluZVNlcGFyYXRvciIsInJlYWRSYW5nZSIsImZpbmRQb2ludEJlZm9yZSIsIm9sZExlbiIsInJlYWROb2RlIiwibmV4dFZpZXciLCJpc0Jsb2NrRWxlbWVudCIsInJlYWRUZXh0Tm9kZSIsInJlIiwibmV4dEJyZWFrIiwiYnJlYWtTaXplIiwiZnJvbVZpZXciLCJmaW5kUG9pbnRJbnNpZGUiLCJpc0F0RW5kIiwiRE9NUG9pbnQiLCJET01DaGFuZ2UiLCJ0eXBlT3ZlciIsImJvdW5kcyIsImlIZWFkIiwiaUFuY2hvciIsInNlbFBvaW50cyIsInNlbGVjdGlvblBvaW50cyIsInNlbGVjdGlvbkZyb21Qb2ludHMiLCJvZmZGcm9tIiwib2ZmVG8iLCJzaW5nbGUiLCJhcHBseURPTUNoYW5nZSIsImRvbUNoYW5nZSIsImNoYW5nZSIsImxhc3RLZXkiLCJwcmVmZXJyZWRQb3MiLCJwcmVmZXJyZWRTaWRlIiwiZmluZERpZmYiLCJnZXRBdHRyaWJ1dGUiLCJkZWZhdWx0VHIiLCJkZWZhdWx0SW5zZXJ0IiwiYXBwbHlEZWZhdWx0SW5zZXJ0IiwibWFpblNlbCIsIm5ld0xlbmd0aCIsInJlcGxhY2VkIiwiY29tcG9zaXRpb25SYW5nZSIsInJhbmdlQ2hhbmdlcyIsInNlbE9mZiIsIm1pbkxlbiIsImFkanVzdCIsIm9ic2VydmVPcHRpb25zIiwiY2hhcmFjdGVyRGF0YSIsInN1YnRyZWUiLCJjaGFyYWN0ZXJEYXRhT2xkVmFsdWUiLCJ1c2VDaGFyRGF0YSIsIkRPTU9ic2VydmVyIiwic2VsZWN0aW9uQ2hhbmdlZCIsImRlbGF5ZWRGbHVzaCIsInJlc2l6ZVRpbWVvdXQiLCJxdWV1ZSIsImRlbGF5ZWRBbmRyb2lkS2V5IiwiZmx1c2hpbmdBbmRyb2lkS2V5IiwibGFzdENoYW5nZSIsInNjcm9sbFRhcmdldHMiLCJpbnRlcnNlY3Rpb24iLCJyZXNpemVTY3JvbGwiLCJpbnRlcnNlY3RpbmciLCJnYXBJbnRlcnNlY3Rpb24iLCJwYXJlbnRDaGVjayIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJtdXRhdGlvbnMiLCJtdXQiLCJyZW1vdmVkTm9kZXMiLCJvbGRWYWx1ZSIsIm9uQ2hhckRhdGEiLCJwcmV2VmFsdWUiLCJvblNlbGVjdGlvbkNoYW5nZSIsIm9uUmVzaXplIiwib25QcmludCIsIm9uU2Nyb2xsIiwiUmVzaXplT2JzZXJ2ZXIiLCJvYnNlcnZlIiwiYWRkV2luZG93TGlzdGVuZXJzIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJlbnRyaWVzIiwibGlzdGVuRm9yU2Nyb2xsIiwiaW50ZXJzZWN0aW9uUmF0aW8iLCJvblNjcm9sbENoYW5nZWQiLCJjcmVhdGVFdmVudCIsInRocmVzaG9sZCIsInJlcXVlc3RNZWFzdXJlIiwiZyIsImRpc2Nvbm5lY3QiLCJ3YXNDaGFuZ2VkIiwic2FmYXJpU2VsZWN0aW9uUmFuZ2VIYWNrIiwibG9jYWwiLCJwcm9jZXNzUmVjb3JkcyIsImNsZWFyRGVsYXllZEFuZHJvaWRLZXkiLCJmbHVzaGVkIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJ0YWtlUmVjb3JkcyIsInJlY29yZHMiLCJyZWFkTXV0YXRpb24iLCJyZWFkQ2hhbmdlIiwicmVhZFNlbGVjdGlvbiIsImhhbmRsZWQiLCJyZWMiLCJjaGlsZEJlZm9yZSIsImZpbmRDaGlsZCIsImNoaWxkQWZ0ZXIiLCJzZXRXaW5kb3ciLCJyZW1vdmVXaW5kb3dMaXN0ZW5lcnMiLCJfYyIsImNsZWFyVGltZW91dCIsImN1clZpZXciLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJnZXRUYXJnZXRSYW5nZXMiLCJleGVjQ29tbWFuZCIsImVuZENvbnRhaW5lciIsImVuZE9mZnNldCIsImN1ckFuY2hvciIsIkVkaXRvclZpZXciLCJjb21wb3NpdGlvblN0YXJ0ZWQiLCJfcm9vdCIsImNvbmZpZyIsInBsdWdpbk1hcCIsIk1hcCIsImVkaXRvckF0dHJzIiwiY29udGVudEF0dHJzIiwiYmlkaUNhY2hlIiwiZGVzdHJveWVkIiwidXBkYXRlU3RhdGUiLCJtZWFzdXJlU2NoZWR1bGVkIiwibWVhc3VyZVJlcXVlc3RzIiwidGFiSW5kZXgiLCJhbm5vdW5jZURPTSIsImRpc3BhdGNoVHJhbnNhY3Rpb25zIiwidHJzIiwic2Nyb2xsVG8iLCJpcyIsIm1vdW50U3R5bGVzIiwicmVkcmF3biIsImF0dHJzQ2hhbmdlZCIsImZvY3VzRmxhZyIsImRpc3BhdGNoRm9jdXMiLCJhbm5vdGF0aW9uIiwicGVuZGluZ0tleSIsInBocmFzZXMiLCJzZXRTdGF0ZSIsIkNhY2hlZE9yZGVyIiwidXBkYXRlUGx1Z2lucyIsInN0eWxlTW9kdWxlcyIsInNob3dBbm5vdW5jZW1lbnRzIiwiaXNVc2VyRXZlbnQiLCJsaXN0ZW5lciIsIm5ld1N0YXRlIiwiaGFkRm9jdXMiLCJwcmV2U3BlY3MiLCJzcGVjcyIsIm5ld1BsdWdpbnMiLCJzRE9NIiwid2FybiIsIm1lYXN1cmluZyIsIkJhZE1lYXN1cmUiLCJ3cml0ZSIsIm5ld0FuY2hvckhlaWdodCIsInRoZW1lQ2xhc3NlcyIsImF0dHJzRnJvbUZhY2V0Iiwic3BlbGxjaGVjayIsImF1dG9jb3JyZWN0IiwiYXV0b2NhcGl0YWxpemUiLCJ0cmFuc2xhdGUiLCJjb250ZW50ZWRpdGFibGUiLCJyb2xlIiwiY2hhbmdlZENvbnRlbnQiLCJjaGFuZ2VkRWRpdG9yIiwiYW5ub3VuY2UiLCJkaXYiLCJub25jZSIsImNzcE5vbmNlIiwibW91bnQiLCJyZXZlcnNlIiwicmVhZE1lYXN1cmVkIiwicmVxdWVzdCIsImtub3duIiwiZG9jdW1lbnRQYWRkaW5nIiwidmlld3BvcnRMaW5lQmxvY2tzIiwibW92ZUJ5R3JvdXAiLCJpbml0aWFsIiwicG9zQXRET00iLCJNYXhCaWRpTGluZSIsImVudHJ5IiwiZnJlc2giLCJzZXRSb290Iiwic2Nyb2xsU25hcHNob3QiLCJwcmVmaXgiLCJkYXJrIiwiYmFzZVRoZW1lIiwibG93ZXN0IiwiZmluZEZyb21ET00iLCJxdWVyeVNlbGVjdG9yIiwiY2FjaGUiLCJsYXN0RGlyIiwic291cmNlcyIsImN1cnJlbnRQbGF0Zm9ybSIsIm5vcm1hbGl6ZUtleU5hbWUiLCJwYXJ0cyIsImFsdCIsImN0cmwiLCJtZXRhIiwibW9kIiwibW9kaWZpZXJzIiwiaGFuZGxlS2V5RXZlbnRzIiwiZGVmYXVsdCIsImdldEtleW1hcCIsImtleW1hcCIsImVuYWJsZXMiLCJLZXltYXBzIiwiV2Vha01hcCIsImJpbmRpbmdzIiwiYnVpbGRLZXltYXAiLCJyZWR1Y2UiLCJydW5TY29wZUhhbmRsZXJzIiwic2NvcGUiLCJzdG9yZWRQcmVmaXgiLCJQcmVmaXhUaW1lb3V0IiwiYm91bmQiLCJpc1ByZWZpeCIsImNoZWNrUHJlZml4IiwiY29tbWFuZCIsInN0b3BQcm9wYWdhdGlvbiIsInNjb3BlT2JqIiwiayIsIm91ck9iaiIsImZ1bGwiLCJiaW5kaW5nIiwiX2FueSIsImFueSIsImNoYXJDb2RlIiwiaXNDaGFyIiwicHJldmVudGVkIiwicmFuIiwicnVuRm9yIiwiY21kIiwiYmFzZU5hbWUiLCJzaGlmdE5hbWUiLCJSZWN0YW5nbGVNYXJrZXIiLCJmb3JSYW5nZSIsImdldEJhc2UiLCJyZWN0YW5nbGVzRm9yUmFuZ2UiLCJ3cmFwcGVkTGluZSIsImxpbmVFbHQiLCJsaW5lU3R5bGUiLCJsZWZ0U2lkZSIsInBhZGRpbmdMZWZ0IiwidGV4dEluZGVudCIsInJpZ2h0U2lkZSIsInBhZGRpbmdSaWdodCIsInN0YXJ0QmxvY2siLCJlbmRCbG9jayIsInZpc3VhbFN0YXJ0IiwidmlzdWFsRW5kIiwicGllY2VzIiwiZHJhd0ZvckxpbmUiLCJkcmF3Rm9yV2lkZ2V0IiwicGllY2UiLCJob3Jpem9udGFsIiwiYWRkU3BhbiIsImZyb21PcGVuIiwidG9PcGVuIiwiZnJvbUNvb3JkcyIsInRvQ29vcmRzIiwiZW5kUG9zIiwiZG9jTGluZSIsInNwYW5Gcm9tIiwic3BhblRvIiwic2FtZU1hcmtlciIsIkxheWVyVmlldyIsImxheWVyIiwiZHJhd24iLCJtZWFzdXJlUmVxIiwic2V0T3JkZXIiLCJsYXllck9yZGVyIiwibWFya2VycyIsInRyYW5zZm9ybSIsIm9sZCIsIm9sZEkiLCJtYXJrZXIiLCJDYW5IaWRlUHJpbWFyeSIsInNlbGVjdGlvbkNvbmZpZyIsImNvbmZpZ3MiLCJjdXJzb3JCbGlua1JhdGUiLCJkcmF3UmFuZ2VDdXJzb3IiLCJkcmF3U2VsZWN0aW9uIiwiY3Vyc29yTGF5ZXIiLCJzZWxlY3Rpb25MYXllciIsImhpZGVOYXRpdmVTZWxlY3Rpb24iLCJnZXREcmF3U2VsZWN0aW9uQ29uZmlnIiwiY29uZmlnQ2hhbmdlZCIsImNvbmYiLCJjdXJzb3JzIiwicHJpbSIsImFuaW1hdGlvbk5hbWUiLCJjb25mQ2hhbmdlIiwic2V0QmxpbmtSYXRlIiwiYW5pbWF0aW9uRHVyYXRpb24iLCJ0aGVtZVNwZWMiLCJoaWdoZXN0Iiwic2V0RHJvcEN1cnNvclBvcyIsIm1hcHBpbmciLCJkcm9wQ3Vyc29yUG9zIiwiZHJhd0Ryb3BDdXJzb3IiLCJyZWFkUG9zIiwiZHJhd0N1cnNvciIsImN1cnNvclBvcyIsImZpZWxkIiwib3V0ZXIiLCJzZXREcm9wUG9zIiwiZHJhZ292ZXIiLCJkcmFnbGVhdmUiLCJyZWxhdGVkVGFyZ2V0IiwiZHJvcEN1cnNvciIsIml0ZXJNYXRjaGVzIiwibGFzdEluZGV4IiwiaXRlclJhbmdlIiwibWF0Y2hSYW5nZXMiLCJtYXhMZW5ndGgiLCJ2aXNpYmxlIiwiTWF0Y2hEZWNvcmF0b3IiLCJyZWdleHAiLCJkZWNvcmF0aW9uIiwiZGVjb3JhdGUiLCJib3VuZGFyeSIsImdsb2JhbCIsImFkZE1hdGNoIiwibWF0Y2giLCJfdmlldyIsImNyZWF0ZURlY28iLCJjaGFuZ2VGcm9tIiwiY2hhbmdlVG8iLCJpdGVyQ2hhbmdlcyIsIl9mIiwiX3QiLCJ1cGRhdGVSYW5nZSIsInVwZGF0ZUZyb20iLCJ1cGRhdGVUbyIsImZyb21MaW5lIiwidG9MaW5lIiwiZmlsdGVyRnJvbSIsImZpbHRlclRvIiwiVW5pY29kZVJlZ2V4cFN1cHBvcnQiLCJ1bmljb2RlIiwiU3BlY2lhbHMiLCJSZWdFeHAiLCJOYW1lcyIsIl9zdXBwb3J0c1RhYlNpemUiLCJzdXBwb3J0c1RhYlNpemUiLCJzdHlsZXMiLCJNb3pUYWJTaXplIiwic3BlY2lhbENoYXJDb25maWciLCJyZW5kZXIiLCJzcGVjaWFsQ2hhcnMiLCJhZGRTcGVjaWFsQ2hhcnMiLCJyZXBsYWNlVGFicyIsImhpZ2hsaWdodFNwZWNpYWxDaGFycyIsInNwZWNpYWxDaGFyUGx1Z2luIiwiX3BsdWdpbiIsImRlY29yYXRpb25DYWNoZSIsImRlY29yYXRvciIsIm1ha2VEZWNvcmF0b3IiLCJjb2wiLCJUYWJXaWRnZXQiLCJTcGVjaWFsQ2hhcldpZGdldCIsIkRlZmF1bHRQbGFjZWhvbGRlciIsInBsYWNlaG9sZGVyJDEiLCJmcm9tQ2hhckNvZGUiLCJwaCIsImRlc2MiLCJwaHJhc2UiLCJ0aXRsZSIsInNjcm9sbFBhc3RFbmQiLCJoaWdobGlnaHRBY3RpdmVMaW5lIiwiYWN0aXZlTGluZUhpZ2hsaWdodGVyIiwibGluZURlY28iLCJnZXREZWNvIiwibGFzdExpbmVTdGFydCIsIlBsYWNlaG9sZGVyIiwid3JhcCIsInBsYWNlaG9sZGVyIiwiTWF4T2ZmIiwicmVjdGFuZ2xlRm9yIiwic3RhcnRMaW5lIiwiZW5kTGluZSIsInN0YXJ0T2ZmIiwiZW5kT2ZmIiwic3RhcnRDb2wiLCJlbmRDb2wiLCJhYnNvbHV0ZUNvbHVtbiIsImdldFBvcyIsInJlY3RhbmdsZVNlbGVjdGlvblN0eWxlIiwibmV3U3RhcnQiLCJuZXdMaW5lIiwiX2V4dGVuZCIsInJlY3Rhbmd1bGFyU2VsZWN0aW9uIiwiZXZlbnRGaWx0ZXIiLCJBbHQiLCJDb250cm9sIiwiU2hpZnQiLCJNZXRhIiwic2hvd0Nyb3NzaGFpciIsImNyb3NzaGFpckN1cnNvciIsImdldHRlciIsImlzRG93biIsImtleXVwIiwibW91c2Vtb3ZlIiwiT3V0c2lkZSIsIlRvb2x0aXBWaWV3TWFuYWdlciIsImNyZWF0ZVRvb2x0aXBWaWV3IiwicmVtb3ZlVG9vbHRpcFZpZXciLCJ0b29sdGlwcyIsInRvb2x0aXBWaWV3cyIsIm5ld0Fib3ZlIiwidGlwIiwidG9vbHRpcFZpZXciLCJ0b29sdGlwQ29uZmlnIiwid2luZG93U3BhY2UiLCJ0b29sdGlwU3BhY2UiLCJrbm93bkhlaWdodCIsInRvb2x0aXBQbHVnaW4iLCJtYWRlQWJzb2x1dGUiLCJsYXN0VHJhbnNhY3Rpb24iLCJtZWFzdXJlVGltZW91dCIsImNsYXNzZXMiLCJjcmVhdGVDb250YWluZXIiLCJyZWFkTWVhc3VyZSIsIndyaXRlTWVhc3VyZSIsInJlc2l6ZU9ic2VydmVyIiwibWVhc3VyZVNvb24iLCJtYW5hZ2VyIiwic2hvd1Rvb2x0aXAiLCJjcmVhdGVUb29sdGlwIiwidW5vYnNlcnZlIiwiaW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlSW50ZXJzZWN0aW9uIiwibWF5YmVNZWFzdXJlIiwiY29udGFpbmVyIiwidG9vbHRpcCIsInNob3VsZE1lYXN1cmUiLCJuZXdDb25maWciLCJhcnJvdyIsImVkaXRvciIsIm1ha2VBYnNvbHV0ZSIsInR2IiwiZ2V0Q29vcmRzIiwic3BhY2UiLCJvdGhlcnMiLCJ0VmlldyIsImFycm93SGVpZ2h0Iiwibm9PZmZzZXQiLCJzdHJpY3RTaWRlIiwic3BhY2VWZXJ0IiwicmVzaXplIiwib3ZlcmxhcCIsImFycm93TGVmdCIsInRvZ2dsZSIsInBvc2l0aW9uZWQiLCJib3JkZXJUb3BDb2xvciIsImJvcmRlckJvdHRvbUNvbG9yIiwic2hvd0hvdmVyVG9vbHRpcCIsIkhvdmVyVG9vbHRpcEhvc3QiLCJtb3VudGVkIiwiY3JlYXRlSG9zdGVkVmlldyIsImhvc3RlZFZpZXciLCJwYXNzUHJvcCIsImdpdmVuIiwic2hvd0hvdmVyVG9vbHRpcEhvc3QiLCJjb21wdXRlIiwiSG92ZXJQbHVnaW4iLCJzZXRIb3ZlciIsImhvdmVyVGltZSIsImhvdmVyVGltZW91dCIsInJlc3RhcnRUaW1lb3V0IiwibGFzdE1vdmUiLCJ0aW1lIiwiY2hlY2tIb3ZlciIsIm1vdXNlbGVhdmUiLCJzdGFydEhvdmVyIiwiaG92ZXJlZCIsInBvc0Nvb3JkcyIsImJpZGkiLCJydGwiLCJmaW5kSW5kZXgiLCJpc0luVG9vbHRpcCIsImlzT3ZlclJhbmdlIiwiaW5Ub29sdGlwIiwid2F0Y2hUb29sdGlwTGVhdmUiLCJ3YXRjaCIsInRvb2x0aXBNYXJnaW4iLCJkb2NCb3R0b20iLCJob3ZlclRvb2x0aXAiLCJob3ZlclN0YXRlIiwiaGlkZU9uQ2hhbmdlIiwiaGlkZU9uIiwiYXNzaWduIiwiY2xvc2VIb3ZlclRvb2x0aXBFZmZlY3QiLCJnZXRUb29sdGlwIiwiaGFzSG92ZXJUb29sdGlwcyIsImNsb3NlSG92ZXJUb29sdGlwcyIsInJlcG9zaXRpb25Ub29sdGlwcyIsInBhbmVsQ29uZmlnIiwidG9wQ29udGFpbmVyIiwiYm90dG9tQ29udGFpbmVyIiwicGFuZWxzIiwiZ2V0UGFuZWwiLCJwYW5lbCIsInBhbmVsUGx1Z2luIiwic2hvd1BhbmVsIiwiUGFuZWxHcm91cCIsInN5bmNDbGFzc2VzIiwic2Nyb2xsTWFyZ2luIiwic3luY0RPTSIsImN1ckRPTSIsInJtIiwiR3V0dGVyTWFya2VyIiwiZWxlbWVudENsYXNzIiwiZ3V0dGVyTGluZUNsYXNzIiwiZGVmYXVsdHMiLCJyZW5kZXJFbXB0eUVsZW1lbnRzIiwiZWxlbWVudFN0eWxlIiwibGluZU1hcmtlciIsIndpZGdldE1hcmtlciIsImxpbmVNYXJrZXJDaGFuZ2UiLCJpbml0aWFsU3BhY2VyIiwidXBkYXRlU3BhY2VyIiwiYWN0aXZlR3V0dGVycyIsImd1dHRlciIsImd1dHRlcnMiLCJ1bmZpeEd1dHRlcnMiLCJndXR0ZXJWaWV3IiwiZml4ZWQiLCJwcmV2Vmlld3BvcnQiLCJTaW5nbGVHdXR0ZXJWaWV3Iiwic3luY0d1dHRlcnMiLCJ1cGRhdGVHdXR0ZXJzIiwidnBBIiwidnBCIiwidnBPdmVybGFwIiwiZGV0YWNoIiwibGluZUNsYXNzZXMiLCJjbGFzc1NldCIsImNvbnRleHRzIiwiVXBkYXRlQ29udGV4dCIsImFkdmFuY2VDdXJzb3IiLCJjeCIsImFzQXJyYXkiLCJjb2xsZWN0IiwiYWRkRWxlbWVudCIsImVsZW1lbnRzIiwibmV3RWx0IiwiR3V0dGVyRWxlbWVudCIsImV4dHJhTWFya2VycyIsImxvY2FsTWFya2VycyIsImZvckxpbmUiLCJzcGFjZXIiLCJwcm9wIiwicHJldk1hcmtlcnMiLCJzYW1lTWFya2VycyIsInNldE1hcmtlcnMiLCJkb21Qb3MiLCJpTmV3IiwiaU9sZCIsInNraXBUbyIsIm1hdGNoZWQiLCJsaW5lTnVtYmVyTWFya2VycyIsImxpbmVOdW1iZXJDb25maWciLCJmb3JtYXROdW1iZXIiLCJOdW1iZXJNYXJrZXIiLCJsaW5lTnVtYmVyR3V0dGVyIiwibWF4TGluZU51bWJlciIsImxpbmVOdW1iZXJzIiwiYWN0aXZlTGluZUd1dHRlck1hcmtlciIsImFjdGl2ZUxpbmVHdXR0ZXJIaWdobGlnaHRlciIsImhpZ2hsaWdodEFjdGl2ZUxpbmVHdXR0ZXIiLCJXaGl0ZXNwYWNlRGVjbyIsImdldFdoaXRlc3BhY2VEZWNvIiwibWF0Y2hlciIsInUiLCJ3aGl0ZXNwYWNlSGlnaGxpZ2h0ZXIiLCJoaWdobGlnaHRXaGl0ZXNwYWNlIiwidHJhaWxpbmdIaWdobGlnaHRlciIsImhpZ2hsaWdodFRyYWlsaW5nV2hpdGVzcGFjZSIsIl9fdGVzdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/view/dist/index.js\n");

/***/ })

};
;
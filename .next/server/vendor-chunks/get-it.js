"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/get-it";
exports.ids = ["vendor-chunks/get-it"];
exports.modules = {

/***/ "(ssr)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-n1t8zknB.cjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/get-it/dist/_chunks/defaultOptionsValidator-n1t8zknB.cjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nconst isReactNative = typeof navigator === \"undefined\" ? false : navigator.product === \"ReactNative\";\nconst defaultOptions = {\n    timeout: isReactNative ? 6e4 : 12e4\n};\nconst processOptions = function processOptions2(opts) {\n    const options = {\n        ...defaultOptions,\n        ...typeof opts === \"string\" ? {\n            url: opts\n        } : opts\n    };\n    const { searchParams } = new URL(options.url, \"http://localhost\");\n    options.timeout = normalizeTimeout(options.timeout);\n    if (options.query) {\n        for (const [key, value] of Object.entries(options.query)){\n            if (value !== void 0) {\n                if (Array.isArray(value)) {\n                    for (const v of value){\n                        searchParams.append(key, v);\n                    }\n                } else {\n                    searchParams.append(key, value);\n                }\n            }\n        }\n    }\n    const [url] = options.url.split(\"?\");\n    const search = searchParams.toString();\n    if (search) {\n        options.url = \"\".concat(url, \"?\").concat(search);\n    }\n    options.method = options.body && !options.method ? \"POST\" : (options.method || \"GET\").toUpperCase();\n    return options;\n};\nfunction normalizeTimeout(time) {\n    if (time === false || time === 0) {\n        return false;\n    }\n    if (time.connect || time.socket) {\n        return time;\n    }\n    const delay = Number(time);\n    if (isNaN(delay)) {\n        return normalizeTimeout(defaultOptions.timeout);\n    }\n    return {\n        connect: delay,\n        socket: delay\n    };\n}\nconst validUrl = /^https?:\\/\\//i;\nconst validateOptions = function validateOptions2(options) {\n    if (!validUrl.test(options.url)) {\n        throw new Error('\"'.concat(options.url, '\" is not a valid URL'));\n    }\n};\nexports.processOptions = processOptions;\nexports.validateOptions = validateOptions; //# sourceMappingURL=defaultOptionsValidator-n1t8zknB.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvX2NodW5rcy9kZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci1uMXQ4emtuQi5janMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxnQkFBZ0IsT0FBT0MsY0FBYyxjQUFjLFFBQVFBLFVBQVVDLE9BQU8sS0FBSztBQUN2RixNQUFNQyxpQkFBaUI7SUFBRUMsU0FBU0osZ0JBQWdCLE1BQU07QUFBSztBQUM3RCxNQUFNSyxpQkFBaUIsU0FBU0MsZ0JBQWdCQyxJQUFJO0lBQ2xELE1BQU1DLFVBQVU7UUFDZCxHQUFHTCxjQUFjO1FBQ2pCLEdBQUcsT0FBT0ksU0FBUyxXQUFXO1lBQUVFLEtBQUtGO1FBQUssSUFBSUEsSUFBSTtJQUNwRDtJQUNBLE1BQU0sRUFBRUcsWUFBWSxFQUFFLEdBQUcsSUFBSUMsSUFBSUgsUUFBUUMsR0FBRyxFQUFFO0lBQzlDRCxRQUFRSixPQUFPLEdBQUdRLGlCQUFpQkosUUFBUUosT0FBTztJQUNsRCxJQUFJSSxRQUFRSyxLQUFLLEVBQUU7UUFDakIsS0FBSyxNQUFNLENBQUNDLEtBQUtDLE1BQU0sSUFBSUMsT0FBT0MsT0FBTyxDQUFDVCxRQUFRSyxLQUFLLEVBQUc7WUFDeEQsSUFBSUUsVUFBVSxLQUFLLEdBQUc7Z0JBQ3BCLElBQUlHLE1BQU1DLE9BQU8sQ0FBQ0osUUFBUTtvQkFDeEIsS0FBSyxNQUFNSyxLQUFLTCxNQUFPO3dCQUNyQkwsYUFBYVcsTUFBTSxDQUFDUCxLQUFLTTtvQkFDM0I7Z0JBQ0YsT0FBTztvQkFDTFYsYUFBYVcsTUFBTSxDQUFDUCxLQUFLQztnQkFDM0I7WUFDRjtRQUNGO0lBQ0Y7SUFDQSxNQUFNLENBQUNOLElBQUksR0FBR0QsUUFBUUMsR0FBRyxDQUFDYSxLQUFLLENBQUM7SUFDaEMsTUFBTUMsU0FBU2IsYUFBYWMsUUFBUTtJQUNwQyxJQUFJRCxRQUFRO1FBQ1ZmLFFBQVFDLEdBQUcsR0FBRyxHQUFHZ0IsTUFBTSxDQUFDaEIsS0FBSyxLQUFLZ0IsTUFBTSxDQUFDRjtJQUMzQztJQUNBZixRQUFRa0IsTUFBTSxHQUFHbEIsUUFBUW1CLElBQUksSUFBSSxDQUFDbkIsUUFBUWtCLE1BQU0sR0FBRyxTQUFTLENBQUNsQixRQUFRa0IsTUFBTSxJQUFJLEtBQUksRUFBR0UsV0FBVztJQUNqRyxPQUFPcEI7QUFDVDtBQUNBLFNBQVNJLGlCQUFpQmlCLElBQUk7SUFDNUIsSUFBSUEsU0FBUyxTQUFTQSxTQUFTLEdBQUc7UUFDaEMsT0FBTztJQUNUO0lBQ0EsSUFBSUEsS0FBS0MsT0FBTyxJQUFJRCxLQUFLRSxNQUFNLEVBQUU7UUFDL0IsT0FBT0Y7SUFDVDtJQUNBLE1BQU1HLFFBQVFDLE9BQU9KO0lBQ3JCLElBQUlLLE1BQU1GLFFBQVE7UUFDaEIsT0FBT3BCLGlCQUFpQlQsZUFBZUMsT0FBTztJQUNoRDtJQUNBLE9BQU87UUFBRTBCLFNBQVNFO1FBQU9ELFFBQVFDO0lBQU07QUFDekM7QUFFQSxNQUFNRyxXQUFXO0FBQ2pCLE1BQU1DLGtCQUFrQixTQUFTQyxpQkFBaUI3QixPQUFPO0lBQ3ZELElBQUksQ0FBQzJCLFNBQVNHLElBQUksQ0FBQzlCLFFBQVFDLEdBQUcsR0FBRztRQUMvQixNQUFNLElBQUk4QixNQUFNLElBQUlkLE1BQU0sQ0FBQ2pCLFFBQVFDLEdBQUcsRUFBRTtJQUMxQztBQUNGO0FBRUErQixzQkFBc0IsR0FBR25DO0FBQ3pCbUMsdUJBQXVCLEdBQUdKLGlCQUMxQiw2REFBNkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYmMvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvX2NodW5rcy9kZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci1uMXQ4emtuQi5janM/Y2NlZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGlzUmVhY3ROYXRpdmUgPSB0eXBlb2YgbmF2aWdhdG9yID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gXCJSZWFjdE5hdGl2ZVwiO1xuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7IHRpbWVvdXQ6IGlzUmVhY3ROYXRpdmUgPyA2ZTQgOiAxMmU0IH07XG5jb25zdCBwcm9jZXNzT3B0aW9ucyA9IGZ1bmN0aW9uIHByb2Nlc3NPcHRpb25zMihvcHRzKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgLi4udHlwZW9mIG9wdHMgPT09IFwic3RyaW5nXCIgPyB7IHVybDogb3B0cyB9IDogb3B0c1xuICB9O1xuICBjb25zdCB7IHNlYXJjaFBhcmFtcyB9ID0gbmV3IFVSTChvcHRpb25zLnVybCwgXCJodHRwOi8vbG9jYWxob3N0XCIpO1xuICBvcHRpb25zLnRpbWVvdXQgPSBub3JtYWxpemVUaW1lb3V0KG9wdGlvbnMudGltZW91dCk7XG4gIGlmIChvcHRpb25zLnF1ZXJ5KSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0aW9ucy5xdWVyeSkpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IFt1cmxdID0gb3B0aW9ucy51cmwuc3BsaXQoXCI/XCIpO1xuICBjb25zdCBzZWFyY2ggPSBzZWFyY2hQYXJhbXMudG9TdHJpbmcoKTtcbiAgaWYgKHNlYXJjaCkge1xuICAgIG9wdGlvbnMudXJsID0gXCJcIi5jb25jYXQodXJsLCBcIj9cIikuY29uY2F0KHNlYXJjaCk7XG4gIH1cbiAgb3B0aW9ucy5tZXRob2QgPSBvcHRpb25zLmJvZHkgJiYgIW9wdGlvbnMubWV0aG9kID8gXCJQT1NUXCIgOiAob3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIikudG9VcHBlckNhc2UoKTtcbiAgcmV0dXJuIG9wdGlvbnM7XG59O1xuZnVuY3Rpb24gbm9ybWFsaXplVGltZW91dCh0aW1lKSB7XG4gIGlmICh0aW1lID09PSBmYWxzZSB8fCB0aW1lID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0aW1lLmNvbm5lY3QgfHwgdGltZS5zb2NrZXQpIHtcbiAgICByZXR1cm4gdGltZTtcbiAgfVxuICBjb25zdCBkZWxheSA9IE51bWJlcih0aW1lKTtcbiAgaWYgKGlzTmFOKGRlbGF5KSkge1xuICAgIHJldHVybiBub3JtYWxpemVUaW1lb3V0KGRlZmF1bHRPcHRpb25zLnRpbWVvdXQpO1xuICB9XG4gIHJldHVybiB7IGNvbm5lY3Q6IGRlbGF5LCBzb2NrZXQ6IGRlbGF5IH07XG59XG5cbmNvbnN0IHZhbGlkVXJsID0gL15odHRwcz86XFwvXFwvL2k7XG5jb25zdCB2YWxpZGF0ZU9wdGlvbnMgPSBmdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbnMyKG9wdGlvbnMpIHtcbiAgaWYgKCF2YWxpZFVybC50ZXN0KG9wdGlvbnMudXJsKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignXCInLmNvbmNhdChvcHRpb25zLnVybCwgJ1wiIGlzIG5vdCBhIHZhbGlkIFVSTCcpKTtcbiAgfVxufTtcblxuZXhwb3J0cy5wcm9jZXNzT3B0aW9ucyA9IHByb2Nlc3NPcHRpb25zO1xuZXhwb3J0cy52YWxpZGF0ZU9wdGlvbnMgPSB2YWxpZGF0ZU9wdGlvbnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci1uMXQ4emtuQi5janMubWFwXG4iXSwibmFtZXMiOlsiaXNSZWFjdE5hdGl2ZSIsIm5hdmlnYXRvciIsInByb2R1Y3QiLCJkZWZhdWx0T3B0aW9ucyIsInRpbWVvdXQiLCJwcm9jZXNzT3B0aW9ucyIsInByb2Nlc3NPcHRpb25zMiIsIm9wdHMiLCJvcHRpb25zIiwidXJsIiwic2VhcmNoUGFyYW1zIiwiVVJMIiwibm9ybWFsaXplVGltZW91dCIsInF1ZXJ5Iiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJlbnRyaWVzIiwiQXJyYXkiLCJpc0FycmF5IiwidiIsImFwcGVuZCIsInNwbGl0Iiwic2VhcmNoIiwidG9TdHJpbmciLCJjb25jYXQiLCJtZXRob2QiLCJib2R5IiwidG9VcHBlckNhc2UiLCJ0aW1lIiwiY29ubmVjdCIsInNvY2tldCIsImRlbGF5IiwiTnVtYmVyIiwiaXNOYU4iLCJ2YWxpZFVybCIsInZhbGlkYXRlT3B0aW9ucyIsInZhbGlkYXRlT3B0aW9uczIiLCJ0ZXN0IiwiRXJyb3IiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-n1t8zknB.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/get-it/dist/index.cjs":
/*!********************************************!*\
  !*** ./node_modules/get-it/dist/index.cjs ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar defaultOptionsValidator = __webpack_require__(/*! ./_chunks/defaultOptionsValidator-n1t8zknB.cjs */ \"(ssr)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-n1t8zknB.cjs\");\nvar decompressResponse = __webpack_require__(/*! decompress-response */ \"(ssr)/./node_modules/decompress-response/index.js\");\nvar follow = __webpack_require__(/*! follow-redirects */ \"(ssr)/./node_modules/follow-redirects/index.js\");\nvar http = __webpack_require__(/*! http */ \"http\");\nvar https = __webpack_require__(/*! https */ \"https\");\nvar toStream = __webpack_require__(/*! into-stream */ \"(ssr)/./node_modules/into-stream/index.js\");\nvar isStream = __webpack_require__(/*! is-stream */ \"(ssr)/./node_modules/is-stream/index.js\");\nvar progressStream = __webpack_require__(/*! progress-stream */ \"(ssr)/./node_modules/progress-stream/index.js\");\nvar qs = __webpack_require__(/*! querystring */ \"querystring\");\nvar url = __webpack_require__(/*! url */ \"url\");\nvar tunnel = __webpack_require__(/*! tunnel-agent */ \"(ssr)/./node_modules/tunnel-agent/index.js\");\nfunction _interopDefaultCompat(e) {\n    return e && typeof e === \"object\" && \"default\" in e ? e : {\n        default: e\n    };\n}\nfunction _interopNamespaceCompat(e) {\n    if (e && typeof e === \"object\" && \"default\" in e) return e;\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function(k) {\n            if (k !== \"default\") {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n.default = e;\n    return Object.freeze(n);\n}\nvar decompressResponse__default = /*#__PURE__*/ _interopDefaultCompat(decompressResponse);\nvar follow__default = /*#__PURE__*/ _interopDefaultCompat(follow);\nvar http__default = /*#__PURE__*/ _interopDefaultCompat(http);\nvar https__default = /*#__PURE__*/ _interopDefaultCompat(https);\nvar toStream__default = /*#__PURE__*/ _interopDefaultCompat(toStream);\nvar isStream__default = /*#__PURE__*/ _interopDefaultCompat(isStream);\nvar progressStream__default = /*#__PURE__*/ _interopDefaultCompat(progressStream);\nvar qs__default = /*#__PURE__*/ _interopDefaultCompat(qs);\nvar url__default = /*#__PURE__*/ _interopDefaultCompat(url);\nvar tunnel__namespace = /*#__PURE__*/ _interopNamespaceCompat(tunnel);\nconst middlewareReducer = (middleware)=>function applyMiddleware(hook, defaultValue, ...args) {\n        const bailEarly = hook === \"onError\";\n        let value = defaultValue;\n        for(let i = 0; i < middleware[hook].length; i++){\n            const handler = middleware[hook][i];\n            value = handler(value, ...args);\n            if (bailEarly && !value) {\n                break;\n            }\n        }\n        return value;\n    };\nfunction createPubSub() {\n    const subscribers = /* @__PURE__ */ Object.create(null);\n    let nextId = 0;\n    function subscribe(subscriber) {\n        const id = nextId++;\n        subscribers[id] = subscriber;\n        return function unsubscribe() {\n            delete subscribers[id];\n        };\n    }\n    function publish(event) {\n        for(const id in subscribers){\n            subscribers[id](event);\n        }\n    }\n    return {\n        publish,\n        subscribe\n    };\n}\nconst channelNames = [\n    \"request\",\n    \"response\",\n    \"progress\",\n    \"error\",\n    \"abort\"\n];\nconst middlehooks = [\n    \"processOptions\",\n    \"validateOptions\",\n    \"interceptRequest\",\n    \"finalizeOptions\",\n    \"onRequest\",\n    \"onResponse\",\n    \"onError\",\n    \"onReturn\",\n    \"onHeaders\"\n];\nfunction createRequester(initMiddleware, httpRequest) {\n    const loadedMiddleware = [];\n    const middleware = middlehooks.reduce((ware, name)=>{\n        ware[name] = ware[name] || [];\n        return ware;\n    }, {\n        processOptions: [\n            defaultOptionsValidator.processOptions\n        ],\n        validateOptions: [\n            defaultOptionsValidator.validateOptions\n        ]\n    });\n    function request(opts) {\n        const onResponse = (reqErr, res, ctx)=>{\n            let error = reqErr;\n            let response = res;\n            if (!error) {\n                try {\n                    response = applyMiddleware(\"onResponse\", res, ctx);\n                } catch (err) {\n                    response = null;\n                    error = err;\n                }\n            }\n            error = error && applyMiddleware(\"onError\", error, ctx);\n            if (error) {\n                channels.error.publish(error);\n            } else if (response) {\n                channels.response.publish(response);\n            }\n        };\n        const channels = channelNames.reduce((target, name)=>{\n            target[name] = createPubSub();\n            return target;\n        }, {});\n        const applyMiddleware = middlewareReducer(middleware);\n        const options = applyMiddleware(\"processOptions\", opts);\n        applyMiddleware(\"validateOptions\", options);\n        const context = {\n            options,\n            channels,\n            applyMiddleware\n        };\n        let ongoingRequest;\n        const unsubscribe = channels.request.subscribe((ctx)=>{\n            ongoingRequest = httpRequest(ctx, (err, res)=>onResponse(err, res, ctx));\n        });\n        channels.abort.subscribe(()=>{\n            unsubscribe();\n            if (ongoingRequest) {\n                ongoingRequest.abort();\n            }\n        });\n        const returnValue = applyMiddleware(\"onReturn\", channels, context);\n        if (returnValue === channels) {\n            channels.request.publish(context);\n        }\n        return returnValue;\n    }\n    request.use = function use(newMiddleware) {\n        if (!newMiddleware) {\n            throw new Error(\"Tried to add middleware that resolved to falsey value\");\n        }\n        if (typeof newMiddleware === \"function\") {\n            throw new Error(\"Tried to add middleware that was a function. It probably expects you to pass options to it.\");\n        }\n        if (newMiddleware.onReturn && middleware.onReturn.length > 0) {\n            throw new Error(\"Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event\");\n        }\n        middlehooks.forEach((key)=>{\n            if (newMiddleware[key]) {\n                middleware[key].push(newMiddleware[key]);\n            }\n        });\n        loadedMiddleware.push(newMiddleware);\n        return request;\n    };\n    request.clone = ()=>createRequester(loadedMiddleware, httpRequest);\n    initMiddleware.forEach(request.use);\n    return request;\n}\nfunction lowerCaseHeaders(headers) {\n    return Object.keys(headers || {}).reduce((acc, header)=>{\n        acc[header.toLowerCase()] = headers[header];\n        return acc;\n    }, {});\n}\nfunction formatHostname(hostname) {\n    return hostname.replace(/^\\.*/, \".\").toLowerCase();\n}\nfunction parseNoProxyZone(zoneStr) {\n    const zone = zoneStr.trim().toLowerCase();\n    const zoneParts = zone.split(\":\", 2);\n    const zoneHost = formatHostname(zoneParts[0]);\n    const zonePort = zoneParts[1];\n    const hasPort = zone.indexOf(\":\") > -1;\n    return {\n        hostname: zoneHost,\n        port: zonePort,\n        hasPort\n    };\n}\nfunction uriInNoProxy(uri, noProxy) {\n    const port = uri.port || (uri.protocol === \"https:\" ? \"443\" : \"80\");\n    const hostname = formatHostname(uri.hostname);\n    const noProxyList = noProxy.split(\",\");\n    return noProxyList.map(parseNoProxyZone).some((noProxyZone)=>{\n        const isMatchedAt = hostname.indexOf(noProxyZone.hostname);\n        const hostnameMatched = isMatchedAt > -1 && isMatchedAt === hostname.length - noProxyZone.hostname.length;\n        if (noProxyZone.hasPort) {\n            return port === noProxyZone.port && hostnameMatched;\n        }\n        return hostnameMatched;\n    });\n}\nfunction getProxyFromUri(uri) {\n    const noProxy = process.env.NO_PROXY || process.env.no_proxy || \"\";\n    if (noProxy === \"*\") {\n        return null;\n    }\n    if (noProxy !== \"\" && uriInNoProxy(uri, noProxy)) {\n        return null;\n    }\n    if (uri.protocol === \"http:\") {\n        return process.env.HTTP_PROXY || process.env.http_proxy || null;\n    }\n    if (uri.protocol === \"https:\") {\n        return process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy || null;\n    }\n    return null;\n}\nfunction getHostFromUri(uri) {\n    let host = uri.host;\n    if (uri.port) {\n        if (uri.port === \"80\" && uri.protocol === \"http:\" || uri.port === \"443\" && uri.protocol === \"https:\") {\n            host = uri.hostname;\n        }\n    }\n    return host;\n}\nfunction getHostHeaderWithPort(uri) {\n    const port = uri.port || (uri.protocol === \"https:\" ? \"443\" : \"80\");\n    return \"\".concat(uri.hostname, \":\").concat(port);\n}\nfunction rewriteUriForProxy(reqOpts, uri, proxy) {\n    const headers = reqOpts.headers || {};\n    const options = Object.assign({}, reqOpts, {\n        headers\n    });\n    headers.host = headers.host || getHostHeaderWithPort(uri);\n    options.protocol = proxy.protocol || options.protocol;\n    options.hostname = proxy.host.replace(/:\\d+/, \"\");\n    options.port = proxy.port;\n    options.host = getHostFromUri(Object.assign({}, uri, proxy));\n    options.href = \"\".concat(options.protocol, \"//\").concat(options.host).concat(options.path);\n    options.path = url__default.default.format(uri);\n    return options;\n}\nfunction getProxyOptions(options) {\n    let proxy;\n    if (options.hasOwnProperty(\"proxy\")) {\n        proxy = options.proxy;\n    } else {\n        const uri = url__default.default.parse(options.url);\n        proxy = getProxyFromUri(uri);\n    }\n    return typeof proxy === \"string\" ? url__default.default.parse(proxy) : proxy;\n}\n/*! simple-concat. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ function concat(stream, cb) {\n    const chunks = [];\n    stream.on(\"data\", function(chunk) {\n        chunks.push(chunk);\n    });\n    stream.once(\"end\", function() {\n        if (cb) cb(null, Buffer.concat(chunks));\n        cb = null;\n    });\n    stream.once(\"error\", function(err) {\n        if (cb) cb(err);\n        cb = null;\n    });\n}\nfunction timedOut(req, time) {\n    if (req.timeoutTimer) {\n        return req;\n    }\n    const delays = isNaN(time) ? time : {\n        socket: time,\n        connect: time\n    };\n    const hostHeader = req.getHeader(\"host\");\n    const host = hostHeader ? \" to \" + hostHeader : \"\";\n    if (delays.connect !== void 0) {\n        req.timeoutTimer = setTimeout(function timeoutHandler() {\n            req.abort();\n            const e = new Error(\"Connection timed out on request\" + host);\n            e.code = \"ETIMEDOUT\";\n            req.emit(\"error\", e);\n        }, delays.connect);\n    }\n    req.on(\"socket\", function assign(socket) {\n        if (!(socket.connecting || socket._connecting)) {\n            connect();\n            return;\n        }\n        socket.once(\"connect\", connect);\n    });\n    function clear() {\n        if (req.timeoutTimer) {\n            clearTimeout(req.timeoutTimer);\n            req.timeoutTimer = null;\n        }\n    }\n    function connect() {\n        clear();\n        if (delays.socket !== void 0) {\n            req.setTimeout(delays.socket, function socketTimeoutHandler() {\n                req.abort();\n                const e = new Error(\"Socket timed out on request\" + host);\n                e.code = \"ESOCKETTIMEDOUT\";\n                req.emit(\"error\", e);\n            });\n        }\n    }\n    return req.on(\"error\", clear);\n}\nconst uriParts = [\n    \"protocol\",\n    \"slashes\",\n    \"auth\",\n    \"host\",\n    \"port\",\n    \"hostname\",\n    \"hash\",\n    \"search\",\n    \"query\",\n    \"pathname\",\n    \"path\",\n    \"href\"\n];\nconst defaultProxyHeaderWhiteList = [\n    \"accept\",\n    \"accept-charset\",\n    \"accept-encoding\",\n    \"accept-language\",\n    \"accept-ranges\",\n    \"cache-control\",\n    \"content-encoding\",\n    \"content-language\",\n    \"content-location\",\n    \"content-md5\",\n    \"content-range\",\n    \"content-type\",\n    \"connection\",\n    \"date\",\n    \"expect\",\n    \"max-forwards\",\n    \"pragma\",\n    \"referer\",\n    \"te\",\n    \"user-agent\",\n    \"via\"\n];\nconst defaultProxyHeaderExclusiveList = [\n    \"proxy-authorization\"\n];\nfunction shouldEnable(options) {\n    if (typeof options.tunnel !== \"undefined\") {\n        return Boolean(options.tunnel);\n    }\n    const uri = url__default.default.parse(options.url);\n    if (uri.protocol === \"https:\") {\n        return true;\n    }\n    return false;\n}\nfunction applyAgent(opts = {}, proxy) {\n    const options = Object.assign({}, opts);\n    const proxyHeaderWhiteList = defaultProxyHeaderWhiteList.concat(options.proxyHeaderWhiteList || []).map((header)=>header.toLowerCase());\n    const proxyHeaderExclusiveList = defaultProxyHeaderExclusiveList.concat(options.proxyHeaderExclusiveList || []).map((header)=>header.toLowerCase());\n    const proxyHeaders = getAllowedProxyHeaders(options.headers, proxyHeaderWhiteList);\n    proxyHeaders.host = constructProxyHost(options);\n    options.headers = Object.keys(options.headers || {}).reduce((headers, header)=>{\n        const isAllowed = proxyHeaderExclusiveList.indexOf(header.toLowerCase()) === -1;\n        if (isAllowed) {\n            headers[header] = options.headers[header];\n        }\n        return headers;\n    }, {});\n    const tunnelFn = getTunnelFn(options, proxy);\n    const tunnelOptions = constructTunnelOptions(options, proxy, proxyHeaders);\n    options.agent = tunnelFn(tunnelOptions);\n    return options;\n}\nfunction getTunnelFn(options, proxy) {\n    const uri = getUriParts(options);\n    const tunnelFnName = constructTunnelFnName(uri, proxy);\n    return tunnel__namespace[tunnelFnName];\n}\nfunction getUriParts(options) {\n    return uriParts.reduce((uri, part)=>{\n        uri[part] = options[part];\n        return uri;\n    }, {});\n}\nfunction constructTunnelFnName(uri, proxy) {\n    const uriProtocol = uri.protocol === \"https:\" ? \"https\" : \"http\";\n    const proxyProtocol = proxy.protocol === \"https:\" ? \"Https\" : \"Http\";\n    return \"\".concat(uriProtocol, \"Over\").concat(proxyProtocol);\n}\nfunction constructProxyHost(uri) {\n    const port = uri.port;\n    const protocol = uri.protocol;\n    let proxyHost = \"\".concat(uri.hostname, \":\");\n    if (port) {\n        proxyHost += port;\n    } else if (protocol === \"https:\") {\n        proxyHost += \"443\";\n    } else {\n        proxyHost += \"80\";\n    }\n    return proxyHost;\n}\nfunction getAllowedProxyHeaders(headers, whiteList) {\n    return Object.keys(headers).filter((header)=>whiteList.indexOf(header.toLowerCase()) !== -1).reduce((set, header)=>{\n        set[header] = headers[header];\n        return set;\n    }, {});\n}\nfunction constructTunnelOptions(options, proxy, proxyHeaders) {\n    return {\n        proxy: {\n            host: proxy.hostname,\n            port: +proxy.port,\n            proxyAuth: proxy.auth,\n            headers: proxyHeaders\n        },\n        headers: options.headers,\n        ca: options.ca,\n        cert: options.cert,\n        key: options.key,\n        passphrase: options.passphrase,\n        pfx: options.pfx,\n        ciphers: options.ciphers,\n        rejectUnauthorized: options.rejectUnauthorized,\n        secureOptions: options.secureOptions,\n        secureProtocol: options.secureProtocol\n    };\n}\nconst adapter = \"node\";\nconst reduceResponse = (res, reqUrl, method, body)=>({\n        body,\n        url: reqUrl,\n        method,\n        headers: res.headers,\n        statusCode: res.statusCode,\n        statusMessage: res.statusMessage\n    });\nconst httpRequester = (context, cb)=>{\n    const { options } = context;\n    const uri = Object.assign({}, url__default.default.parse(options.url));\n    if (typeof fetch === \"function\" && options.fetch) {\n        const controller = new AbortController();\n        const reqOpts2 = context.applyMiddleware(\"finalizeOptions\", {\n            ...uri,\n            method: options.method,\n            headers: {\n                ...typeof options.fetch === \"object\" && options.fetch.headers ? lowerCaseHeaders(options.fetch.headers) : {},\n                ...lowerCaseHeaders(options.headers)\n            },\n            maxRedirects: options.maxRedirects\n        });\n        const fetchOpts = {\n            credentials: options.withCredentials ? \"include\" : \"omit\",\n            ...typeof options.fetch === \"object\" ? options.fetch : {},\n            method: reqOpts2.method,\n            headers: reqOpts2.headers,\n            body: options.body,\n            signal: controller.signal\n        };\n        const injectedResponse2 = context.applyMiddleware(\"interceptRequest\", void 0, {\n            adapter,\n            context\n        });\n        if (injectedResponse2) {\n            const cbTimer = setTimeout(cb, 0, null, injectedResponse2);\n            const cancel = ()=>clearTimeout(cbTimer);\n            return {\n                abort: cancel\n            };\n        }\n        const request2 = fetch(options.url, fetchOpts);\n        context.applyMiddleware(\"onRequest\", {\n            options,\n            adapter,\n            request: request2,\n            context\n        });\n        request2.then(async (res)=>{\n            const body = options.rawBody ? res.body : await res.text();\n            const headers = {};\n            res.headers.forEach((value, key)=>{\n                headers[key] = value;\n            });\n            cb(null, {\n                body,\n                url: res.url,\n                method: options.method,\n                headers,\n                statusCode: res.status,\n                statusMessage: res.statusText\n            });\n        }).catch((err)=>{\n            if (err.name == \"AbortError\") return;\n            cb(err);\n        });\n        return {\n            abort: ()=>controller.abort()\n        };\n    }\n    const bodyType = isStream__default.default(options.body) ? \"stream\" : typeof options.body;\n    if (bodyType !== \"undefined\" && bodyType !== \"stream\" && bodyType !== \"string\" && !Buffer.isBuffer(options.body)) {\n        throw new Error(\"Request body must be a string, buffer or stream, got \".concat(bodyType));\n    }\n    const lengthHeader = {};\n    if (options.bodySize) {\n        lengthHeader[\"content-length\"] = options.bodySize;\n    } else if (options.body && bodyType !== \"stream\") {\n        lengthHeader[\"content-length\"] = Buffer.byteLength(options.body);\n    }\n    let aborted = false;\n    const callback = (err, res)=>!aborted && cb(err, res);\n    context.channels.abort.subscribe(()=>{\n        aborted = true;\n    });\n    let reqOpts = Object.assign({}, uri, {\n        method: options.method,\n        headers: Object.assign({}, lowerCaseHeaders(options.headers), lengthHeader),\n        maxRedirects: options.maxRedirects\n    });\n    const proxy = getProxyOptions(options);\n    const tunnel = proxy && shouldEnable(options);\n    const injectedResponse = context.applyMiddleware(\"interceptRequest\", void 0, {\n        adapter,\n        context\n    });\n    if (injectedResponse) {\n        const cbTimer = setImmediate(callback, null, injectedResponse);\n        const abort = ()=>clearImmediate(cbTimer);\n        return {\n            abort\n        };\n    }\n    if (options.maxRedirects !== 0) {\n        reqOpts.maxRedirects = options.maxRedirects || 5;\n    }\n    if (proxy && tunnel) {\n        reqOpts = applyAgent(reqOpts, proxy);\n    } else if (proxy && !tunnel) {\n        reqOpts = rewriteUriForProxy(reqOpts, uri, proxy);\n    }\n    if (!tunnel && proxy && proxy.auth && !reqOpts.headers[\"proxy-authorization\"]) {\n        const [username, password] = proxy.auth.username ? [\n            proxy.auth.username,\n            proxy.auth.password\n        ] : proxy.auth.split(\":\").map((item)=>qs__default.default.unescape(item));\n        const auth = Buffer.from(\"\".concat(username, \":\").concat(password), \"utf8\");\n        const authBase64 = auth.toString(\"base64\");\n        reqOpts.headers[\"proxy-authorization\"] = \"Basic \".concat(authBase64);\n    }\n    const transport = getRequestTransport(reqOpts, proxy, tunnel);\n    if (typeof options.debug === \"function\" && proxy) {\n        options.debug(\"Proxying using %s\", reqOpts.agent ? \"tunnel agent\" : \"\".concat(reqOpts.host, \":\").concat(reqOpts.port));\n    }\n    const tryCompressed = reqOpts.method !== \"HEAD\";\n    if (tryCompressed && !reqOpts.headers[\"accept-encoding\"] && options.compress !== false) {\n        reqOpts.headers[\"accept-encoding\"] = \"br, gzip, deflate\";\n    }\n    const finalOptions = context.applyMiddleware(\"finalizeOptions\", reqOpts);\n    const request = transport.request(finalOptions, (response)=>{\n        const res = tryCompressed ? decompressResponse__default.default(response) : response;\n        const resStream = context.applyMiddleware(\"onHeaders\", res, {\n            headers: response.headers,\n            adapter,\n            context\n        });\n        const reqUrl = \"responseUrl\" in response ? response.responseUrl : options.url;\n        if (options.stream) {\n            callback(null, reduceResponse(res, reqUrl, reqOpts.method, resStream));\n            return;\n        }\n        concat(resStream, (err, data)=>{\n            if (err) {\n                return callback(err);\n            }\n            const body = options.rawBody ? data : data.toString();\n            const reduced = reduceResponse(res, reqUrl, reqOpts.method, body);\n            return callback(null, reduced);\n        });\n    });\n    if (options.timeout) {\n        timedOut(request, options.timeout);\n    }\n    request.once(\"error\", callback);\n    const { bodyStream, progress } = getProgressStream(options);\n    context.applyMiddleware(\"onRequest\", {\n        options,\n        adapter,\n        request,\n        context,\n        progress\n    });\n    if (bodyStream) {\n        bodyStream.pipe(request);\n    } else {\n        request.end(options.body);\n    }\n    return {\n        abort: ()=>request.abort()\n    };\n};\nfunction getProgressStream(options) {\n    if (!options.body) {\n        return {};\n    }\n    const bodyIsStream = isStream__default.default(options.body);\n    const length = options.bodySize || (bodyIsStream ? null : Buffer.byteLength(options.body));\n    if (!length) {\n        return bodyIsStream ? {\n            bodyStream: options.body\n        } : {};\n    }\n    const progress = progressStream__default.default({\n        time: 16,\n        length\n    });\n    const bodyStream = bodyIsStream ? options.body : toStream__default.default(options.body);\n    return {\n        bodyStream: bodyStream.pipe(progress),\n        progress\n    };\n}\nfunction getRequestTransport(reqOpts, proxy, tunnel) {\n    const isHttpsRequest = reqOpts.protocol === \"https:\";\n    const transports = reqOpts.maxRedirects === 0 ? {\n        http: http__default.default,\n        https: https__default.default\n    } : {\n        http: follow__default.default.http,\n        https: follow__default.default.https\n    };\n    if (!proxy || tunnel) {\n        return isHttpsRequest ? transports.https : transports.http;\n    }\n    let isHttpsProxy = proxy.port === 443;\n    if (proxy.protocol) {\n        isHttpsProxy = /^https:?/.test(proxy.protocol);\n    }\n    return isHttpsProxy ? transports.https : transports.http;\n}\nconst getIt = (initMiddleware = [], httpRequest = httpRequester)=>createRequester(initMiddleware, httpRequest);\nconst environment = \"node\";\nexports.adapter = adapter;\nexports.environment = environment;\nexports.getIt = getIt; //# sourceMappingURL=index.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELElBQUlDLDBCQUEwQkMsbUJBQU9BLENBQUM7QUFDdEMsSUFBSUMscUJBQXFCRCxtQkFBT0EsQ0FBQztBQUNqQyxJQUFJRSxTQUFTRixtQkFBT0EsQ0FBQztBQUNyQixJQUFJRyxPQUFPSCxtQkFBT0EsQ0FBQztBQUNuQixJQUFJSSxRQUFRSixtQkFBT0EsQ0FBQztBQUNwQixJQUFJSyxXQUFXTCxtQkFBT0EsQ0FBQztBQUN2QixJQUFJTSxXQUFXTixtQkFBT0EsQ0FBQztBQUN2QixJQUFJTyxpQkFBaUJQLG1CQUFPQSxDQUFDO0FBQzdCLElBQUlRLEtBQUtSLG1CQUFPQSxDQUFDO0FBQ2pCLElBQUlTLE1BQU1ULG1CQUFPQSxDQUFDO0FBQ2xCLElBQUlVLFNBQVNWLG1CQUFPQSxDQUFDO0FBRXJCLFNBQVNXLHNCQUF1QkMsQ0FBQztJQUFJLE9BQU9BLEtBQUssT0FBT0EsTUFBTSxZQUFZLGFBQWFBLElBQUlBLElBQUk7UUFBRUMsU0FBU0Q7SUFBRTtBQUFHO0FBRS9HLFNBQVNFLHdCQUF3QkYsQ0FBQztJQUNoQyxJQUFJQSxLQUFLLE9BQU9BLE1BQU0sWUFBWSxhQUFhQSxHQUFHLE9BQU9BO0lBQ3pELElBQUlHLElBQUlwQixPQUFPcUIsTUFBTSxDQUFDO0lBQ3RCLElBQUlKLEdBQUc7UUFDTGpCLE9BQU9zQixJQUFJLENBQUNMLEdBQUdNLE9BQU8sQ0FBQyxTQUFVQyxDQUFDO1lBQ2hDLElBQUlBLE1BQU0sV0FBVztnQkFDbkIsSUFBSUMsSUFBSXpCLE9BQU8wQix3QkFBd0IsQ0FBQ1QsR0FBR087Z0JBQzNDeEIsT0FBT0MsY0FBYyxDQUFDbUIsR0FBR0ksR0FBR0MsRUFBRUUsR0FBRyxHQUFHRixJQUFJO29CQUN0Q0csWUFBWTtvQkFDWkQsS0FBSzt3QkFBYyxPQUFPVixD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SSxDQUFDZ0ksU0FBUzFILFFBQVE7UUFDcEIsT0FBTzhQLGlCQUFpQkMsV0FBV3JRLEtBQUssR0FBR3FRLFdBQVd0USxJQUFJO0lBQzVEO0lBQ0EsSUFBSXVRLGVBQWV0SSxNQUFNMUIsSUFBSSxLQUFLO0lBQ2xDLElBQUkwQixNQUFNdEIsUUFBUSxFQUFFO1FBQ2xCNEosZUFBZSxXQUFXQyxJQUFJLENBQUN2SSxNQUFNdEIsUUFBUTtJQUMvQztJQUNBLE9BQU80SixlQUFlRCxXQUFXclEsS0FBSyxHQUFHcVEsV0FBV3RRLElBQUk7QUFDMUQ7QUFFQSxNQUFNeVEsUUFBUSxDQUFDbk4saUJBQWlCLEVBQUUsRUFBRUMsY0FBY3dKLGFBQWEsR0FBSzFKLGdCQUFnQkMsZ0JBQWdCQztBQUNwRyxNQUFNbU4sY0FBYztBQUVwQmhSLGVBQWUsR0FBRzhNO0FBQ2xCOU0sbUJBQW1CLEdBQUdnUjtBQUN0QmhSLGFBQWEsR0FBRytRLE9BQ2hCLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL21iYy8uL25vZGVfbW9kdWxlcy9nZXQtaXQvZGlzdC9pbmRleC5janM/MjlhNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBkZWZhdWx0T3B0aW9uc1ZhbGlkYXRvciA9IHJlcXVpcmUoJy4vX2NodW5rcy9kZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci1uMXQ4emtuQi5janMnKTtcbnZhciBkZWNvbXByZXNzUmVzcG9uc2UgPSByZXF1aXJlKCdkZWNvbXByZXNzLXJlc3BvbnNlJyk7XG52YXIgZm9sbG93ID0gcmVxdWlyZSgnZm9sbG93LXJlZGlyZWN0cycpO1xudmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG52YXIgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xudmFyIHRvU3RyZWFtID0gcmVxdWlyZSgnaW50by1zdHJlYW0nKTtcbnZhciBpc1N0cmVhbSA9IHJlcXVpcmUoJ2lzLXN0cmVhbScpO1xudmFyIHByb2dyZXNzU3RyZWFtID0gcmVxdWlyZSgncHJvZ3Jlc3Mtc3RyZWFtJyk7XG52YXIgcXMgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xudmFyIHR1bm5lbCA9IHJlcXVpcmUoJ3R1bm5lbC1hZ2VudCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRDb21wYXQgKGUpIHsgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHsgZGVmYXVsdDogZSB9OyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlQ29tcGF0KGUpIHtcbiAgaWYgKGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlKSByZXR1cm4gZTtcbiAgdmFyIG4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoZSkge1xuICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgIGlmIChrICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG4uZGVmYXVsdCA9IGU7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgZGVjb21wcmVzc1Jlc3BvbnNlX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdENvbXBhdChkZWNvbXByZXNzUmVzcG9uc2UpO1xudmFyIGZvbGxvd19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRDb21wYXQoZm9sbG93KTtcbnZhciBodHRwX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdENvbXBhdChodHRwKTtcbnZhciBodHRwc19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRDb21wYXQoaHR0cHMpO1xudmFyIHRvU3RyZWFtX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdENvbXBhdCh0b1N0cmVhbSk7XG52YXIgaXNTdHJlYW1fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0Q29tcGF0KGlzU3RyZWFtKTtcbnZhciBwcm9ncmVzc1N0cmVhbV9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRDb21wYXQocHJvZ3Jlc3NTdHJlYW0pO1xudmFyIHFzX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdENvbXBhdChxcyk7XG52YXIgdXJsX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdENvbXBhdCh1cmwpO1xudmFyIHR1bm5lbF9fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlQ29tcGF0KHR1bm5lbCk7XG5cbmNvbnN0IG1pZGRsZXdhcmVSZWR1Y2VyID0gKG1pZGRsZXdhcmUpID0+IGZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZShob29rLCBkZWZhdWx0VmFsdWUsIC4uLmFyZ3MpIHtcbiAgY29uc3QgYmFpbEVhcmx5ID0gaG9vayA9PT0gXCJvbkVycm9yXCI7XG4gIGxldCB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtaWRkbGV3YXJlW2hvb2tdLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IG1pZGRsZXdhcmVbaG9va11baV07XG4gICAgdmFsdWUgPSBoYW5kbGVyKHZhbHVlLCAuLi5hcmdzKTtcbiAgICBpZiAoYmFpbEVhcmx5ICYmICF2YWx1ZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVB1YlN1YigpIHtcbiAgY29uc3Qgc3Vic2NyaWJlcnMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IG5leHRJZCA9IDA7XG4gIGZ1bmN0aW9uIHN1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gICAgY29uc3QgaWQgPSBuZXh0SWQrKztcbiAgICBzdWJzY3JpYmVyc1tpZF0gPSBzdWJzY3JpYmVyO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIGRlbGV0ZSBzdWJzY3JpYmVyc1tpZF07XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBwdWJsaXNoKGV2ZW50KSB7XG4gICAgZm9yIChjb25zdCBpZCBpbiBzdWJzY3JpYmVycykge1xuICAgICAgc3Vic2NyaWJlcnNbaWRdKGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwdWJsaXNoLFxuICAgIHN1YnNjcmliZVxuICB9O1xufVxuXG5jb25zdCBjaGFubmVsTmFtZXMgPSBbXG4gIFwicmVxdWVzdFwiLFxuICBcInJlc3BvbnNlXCIsXG4gIFwicHJvZ3Jlc3NcIixcbiAgXCJlcnJvclwiLFxuICBcImFib3J0XCJcbl07XG5jb25zdCBtaWRkbGVob29rcyA9IFtcbiAgXCJwcm9jZXNzT3B0aW9uc1wiLFxuICBcInZhbGlkYXRlT3B0aW9uc1wiLFxuICBcImludGVyY2VwdFJlcXVlc3RcIixcbiAgXCJmaW5hbGl6ZU9wdGlvbnNcIixcbiAgXCJvblJlcXVlc3RcIixcbiAgXCJvblJlc3BvbnNlXCIsXG4gIFwib25FcnJvclwiLFxuICBcIm9uUmV0dXJuXCIsXG4gIFwib25IZWFkZXJzXCJcbl07XG5mdW5jdGlvbiBjcmVhdGVSZXF1ZXN0ZXIoaW5pdE1pZGRsZXdhcmUsIGh0dHBSZXF1ZXN0KSB7XG4gIGNvbnN0IGxvYWRlZE1pZGRsZXdhcmUgPSBbXTtcbiAgY29uc3QgbWlkZGxld2FyZSA9IG1pZGRsZWhvb2tzLnJlZHVjZShcbiAgICAod2FyZSwgbmFtZSkgPT4ge1xuICAgICAgd2FyZVtuYW1lXSA9IHdhcmVbbmFtZV0gfHwgW107XG4gICAgICByZXR1cm4gd2FyZTtcbiAgICB9LFxuICAgIHtcbiAgICAgIHByb2Nlc3NPcHRpb25zOiBbZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3IucHJvY2Vzc09wdGlvbnNdLFxuICAgICAgdmFsaWRhdGVPcHRpb25zOiBbZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3IudmFsaWRhdGVPcHRpb25zXVxuICAgIH1cbiAgKTtcbiAgZnVuY3Rpb24gcmVxdWVzdChvcHRzKSB7XG4gICAgY29uc3Qgb25SZXNwb25zZSA9IChyZXFFcnIsIHJlcywgY3R4KSA9PiB7XG4gICAgICBsZXQgZXJyb3IgPSByZXFFcnI7XG4gICAgICBsZXQgcmVzcG9uc2UgPSByZXM7XG4gICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzcG9uc2UgPSBhcHBseU1pZGRsZXdhcmUoXCJvblJlc3BvbnNlXCIsIHJlcywgY3R4KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmVzcG9uc2UgPSBudWxsO1xuICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlcnJvciA9IGVycm9yICYmIGFwcGx5TWlkZGxld2FyZShcIm9uRXJyb3JcIiwgZXJyb3IsIGN0eCk7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY2hhbm5lbHMuZXJyb3IucHVibGlzaChlcnJvcik7XG4gICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgIGNoYW5uZWxzLnJlc3BvbnNlLnB1Ymxpc2gocmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY2hhbm5lbHMgPSBjaGFubmVsTmFtZXMucmVkdWNlKCh0YXJnZXQsIG5hbWUpID0+IHtcbiAgICAgIHRhcmdldFtuYW1lXSA9IGNyZWF0ZVB1YlN1YigpO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9LCB7fSk7XG4gICAgY29uc3QgYXBwbHlNaWRkbGV3YXJlID0gbWlkZGxld2FyZVJlZHVjZXIobWlkZGxld2FyZSk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGFwcGx5TWlkZGxld2FyZShcInByb2Nlc3NPcHRpb25zXCIsIG9wdHMpO1xuICAgIGFwcGx5TWlkZGxld2FyZShcInZhbGlkYXRlT3B0aW9uc1wiLCBvcHRpb25zKTtcbiAgICBjb25zdCBjb250ZXh0ID0geyBvcHRpb25zLCBjaGFubmVscywgYXBwbHlNaWRkbGV3YXJlIH07XG4gICAgbGV0IG9uZ29pbmdSZXF1ZXN0O1xuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gY2hhbm5lbHMucmVxdWVzdC5zdWJzY3JpYmUoKGN0eCkgPT4ge1xuICAgICAgb25nb2luZ1JlcXVlc3QgPSBodHRwUmVxdWVzdChjdHgsIChlcnIsIHJlcykgPT4gb25SZXNwb25zZShlcnIsIHJlcywgY3R4KSk7XG4gICAgfSk7XG4gICAgY2hhbm5lbHMuYWJvcnQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICBpZiAob25nb2luZ1JlcXVlc3QpIHtcbiAgICAgICAgb25nb2luZ1JlcXVlc3QuYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCByZXR1cm5WYWx1ZSA9IGFwcGx5TWlkZGxld2FyZShcIm9uUmV0dXJuXCIsIGNoYW5uZWxzLCBjb250ZXh0KTtcbiAgICBpZiAocmV0dXJuVmFsdWUgPT09IGNoYW5uZWxzKSB7XG4gICAgICBjaGFubmVscy5yZXF1ZXN0LnB1Ymxpc2goY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfVxuICByZXF1ZXN0LnVzZSA9IGZ1bmN0aW9uIHVzZShuZXdNaWRkbGV3YXJlKSB7XG4gICAgaWYgKCFuZXdNaWRkbGV3YXJlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmllZCB0byBhZGQgbWlkZGxld2FyZSB0aGF0IHJlc29sdmVkIHRvIGZhbHNleSB2YWx1ZVwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXdNaWRkbGV3YXJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJUcmllZCB0byBhZGQgbWlkZGxld2FyZSB0aGF0IHdhcyBhIGZ1bmN0aW9uLiBJdCBwcm9iYWJseSBleHBlY3RzIHlvdSB0byBwYXNzIG9wdGlvbnMgdG8gaXQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChuZXdNaWRkbGV3YXJlLm9uUmV0dXJuICYmIG1pZGRsZXdhcmUub25SZXR1cm4ubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlRyaWVkIHRvIGFkZCBuZXcgbWlkZGxld2FyZSB3aXRoIGBvblJldHVybmAgaGFuZGxlciwgYnV0IGFub3RoZXIgaGFuZGxlciBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgZm9yIHRoaXMgZXZlbnRcIlxuICAgICAgKTtcbiAgICB9XG4gICAgbWlkZGxlaG9va3MuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAobmV3TWlkZGxld2FyZVtrZXldKSB7XG4gICAgICAgIG1pZGRsZXdhcmVba2V5XS5wdXNoKG5ld01pZGRsZXdhcmVba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbG9hZGVkTWlkZGxld2FyZS5wdXNoKG5ld01pZGRsZXdhcmUpO1xuICAgIHJldHVybiByZXF1ZXN0O1xuICB9O1xuICByZXF1ZXN0LmNsb25lID0gKCkgPT4gY3JlYXRlUmVxdWVzdGVyKGxvYWRlZE1pZGRsZXdhcmUsIGh0dHBSZXF1ZXN0KTtcbiAgaW5pdE1pZGRsZXdhcmUuZm9yRWFjaChyZXF1ZXN0LnVzZSk7XG4gIHJldHVybiByZXF1ZXN0O1xufVxuXG5mdW5jdGlvbiBsb3dlckNhc2VIZWFkZXJzKGhlYWRlcnMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGhlYWRlcnMgfHwge30pLnJlZHVjZSgoYWNjLCBoZWFkZXIpID0+IHtcbiAgICBhY2NbaGVhZGVyLnRvTG93ZXJDYXNlKCldID0gaGVhZGVyc1toZWFkZXJdO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0SG9zdG5hbWUoaG9zdG5hbWUpIHtcbiAgcmV0dXJuIGhvc3RuYW1lLnJlcGxhY2UoL15cXC4qLywgXCIuXCIpLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBwYXJzZU5vUHJveHlab25lKHpvbmVTdHIpIHtcbiAgY29uc3Qgem9uZSA9IHpvbmVTdHIudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IHpvbmVQYXJ0cyA9IHpvbmUuc3BsaXQoXCI6XCIsIDIpO1xuICBjb25zdCB6b25lSG9zdCA9IGZvcm1hdEhvc3RuYW1lKHpvbmVQYXJ0c1swXSk7XG4gIGNvbnN0IHpvbmVQb3J0ID0gem9uZVBhcnRzWzFdO1xuICBjb25zdCBoYXNQb3J0ID0gem9uZS5pbmRleE9mKFwiOlwiKSA+IC0xO1xuICByZXR1cm4geyBob3N0bmFtZTogem9uZUhvc3QsIHBvcnQ6IHpvbmVQb3J0LCBoYXNQb3J0IH07XG59XG5mdW5jdGlvbiB1cmlJbk5vUHJveHkodXJpLCBub1Byb3h5KSB7XG4gIGNvbnN0IHBvcnQgPSB1cmkucG9ydCB8fCAodXJpLnByb3RvY29sID09PSBcImh0dHBzOlwiID8gXCI0NDNcIiA6IFwiODBcIik7XG4gIGNvbnN0IGhvc3RuYW1lID0gZm9ybWF0SG9zdG5hbWUodXJpLmhvc3RuYW1lKTtcbiAgY29uc3Qgbm9Qcm94eUxpc3QgPSBub1Byb3h5LnNwbGl0KFwiLFwiKTtcbiAgcmV0dXJuIG5vUHJveHlMaXN0Lm1hcChwYXJzZU5vUHJveHlab25lKS5zb21lKChub1Byb3h5Wm9uZSkgPT4ge1xuICAgIGNvbnN0IGlzTWF0Y2hlZEF0ID0gaG9zdG5hbWUuaW5kZXhPZihub1Byb3h5Wm9uZS5ob3N0bmFtZSk7XG4gICAgY29uc3QgaG9zdG5hbWVNYXRjaGVkID0gaXNNYXRjaGVkQXQgPiAtMSAmJiBpc01hdGNoZWRBdCA9PT0gaG9zdG5hbWUubGVuZ3RoIC0gbm9Qcm94eVpvbmUuaG9zdG5hbWUubGVuZ3RoO1xuICAgIGlmIChub1Byb3h5Wm9uZS5oYXNQb3J0KSB7XG4gICAgICByZXR1cm4gcG9ydCA9PT0gbm9Qcm94eVpvbmUucG9ydCAmJiBob3N0bmFtZU1hdGNoZWQ7XG4gICAgfVxuICAgIHJldHVybiBob3N0bmFtZU1hdGNoZWQ7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0UHJveHlGcm9tVXJpKHVyaSkge1xuICBjb25zdCBub1Byb3h5ID0gcHJvY2Vzcy5lbnYuTk9fUFJPWFkgfHwgcHJvY2Vzcy5lbnYubm9fcHJveHkgfHwgXCJcIjtcbiAgaWYgKG5vUHJveHkgPT09IFwiKlwiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKG5vUHJveHkgIT09IFwiXCIgJiYgdXJpSW5Ob1Byb3h5KHVyaSwgbm9Qcm94eSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAodXJpLnByb3RvY29sID09PSBcImh0dHA6XCIpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuSFRUUF9QUk9YWSB8fCBwcm9jZXNzLmVudi5odHRwX3Byb3h5IHx8IG51bGw7XG4gIH1cbiAgaWYgKHVyaS5wcm90b2NvbCA9PT0gXCJodHRwczpcIikge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5IVFRQU19QUk9YWSB8fCBwcm9jZXNzLmVudi5odHRwc19wcm94eSB8fCBwcm9jZXNzLmVudi5IVFRQX1BST1hZIHx8IHByb2Nlc3MuZW52Lmh0dHBfcHJveHkgfHwgbnVsbDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldEhvc3RGcm9tVXJpKHVyaSkge1xuICBsZXQgaG9zdCA9IHVyaS5ob3N0O1xuICBpZiAodXJpLnBvcnQpIHtcbiAgICBpZiAodXJpLnBvcnQgPT09IFwiODBcIiAmJiB1cmkucHJvdG9jb2wgPT09IFwiaHR0cDpcIiB8fCB1cmkucG9ydCA9PT0gXCI0NDNcIiAmJiB1cmkucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIpIHtcbiAgICAgIGhvc3QgPSB1cmkuaG9zdG5hbWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBob3N0O1xufVxuZnVuY3Rpb24gZ2V0SG9zdEhlYWRlcldpdGhQb3J0KHVyaSkge1xuICBjb25zdCBwb3J0ID0gdXJpLnBvcnQgfHwgKHVyaS5wcm90b2NvbCA9PT0gXCJodHRwczpcIiA/IFwiNDQzXCIgOiBcIjgwXCIpO1xuICByZXR1cm4gXCJcIi5jb25jYXQodXJpLmhvc3RuYW1lLCBcIjpcIikuY29uY2F0KHBvcnQpO1xufVxuZnVuY3Rpb24gcmV3cml0ZVVyaUZvclByb3h5KHJlcU9wdHMsIHVyaSwgcHJveHkpIHtcbiAgY29uc3QgaGVhZGVycyA9IHJlcU9wdHMuaGVhZGVycyB8fCB7fTtcbiAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHJlcU9wdHMsIHsgaGVhZGVycyB9KTtcbiAgaGVhZGVycy5ob3N0ID0gaGVhZGVycy5ob3N0IHx8IGdldEhvc3RIZWFkZXJXaXRoUG9ydCh1cmkpO1xuICBvcHRpb25zLnByb3RvY29sID0gcHJveHkucHJvdG9jb2wgfHwgb3B0aW9ucy5wcm90b2NvbDtcbiAgb3B0aW9ucy5ob3N0bmFtZSA9IHByb3h5Lmhvc3QucmVwbGFjZSgvOlxcZCsvLCBcIlwiKTtcbiAgb3B0aW9ucy5wb3J0ID0gcHJveHkucG9ydDtcbiAgb3B0aW9ucy5ob3N0ID0gZ2V0SG9zdEZyb21VcmkoT2JqZWN0LmFzc2lnbih7fSwgdXJpLCBwcm94eSkpO1xuICBvcHRpb25zLmhyZWYgPSBcIlwiLmNvbmNhdChvcHRpb25zLnByb3RvY29sLCBcIi8vXCIpLmNvbmNhdChvcHRpb25zLmhvc3QpLmNvbmNhdChvcHRpb25zLnBhdGgpO1xuICBvcHRpb25zLnBhdGggPSB1cmxfX2RlZmF1bHQuZGVmYXVsdC5mb3JtYXQodXJpKTtcbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiBnZXRQcm94eU9wdGlvbnMob3B0aW9ucykge1xuICBsZXQgcHJveHk7XG4gIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KFwicHJveHlcIikpIHtcbiAgICBwcm94eSA9IG9wdGlvbnMucHJveHk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdXJpID0gdXJsX19kZWZhdWx0LmRlZmF1bHQucGFyc2Uob3B0aW9ucy51cmwpO1xuICAgIHByb3h5ID0gZ2V0UHJveHlGcm9tVXJpKHVyaSk7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBwcm94eSA9PT0gXCJzdHJpbmdcIiA/IHVybF9fZGVmYXVsdC5kZWZhdWx0LnBhcnNlKHByb3h5KSA6IHByb3h5O1xufVxuXG4vKiEgc2ltcGxlLWNvbmNhdC4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuZnVuY3Rpb24gY29uY2F0KHN0cmVhbSwgY2IpIHtcbiAgY29uc3QgY2h1bmtzID0gW107XG4gIHN0cmVhbS5vbihcImRhdGFcIiwgZnVuY3Rpb24oY2h1bmspIHtcbiAgICBjaHVua3MucHVzaChjaHVuayk7XG4gIH0pO1xuICBzdHJlYW0ub25jZShcImVuZFwiLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoY2IpXG4gICAgICBjYihudWxsLCBCdWZmZXIuY29uY2F0KGNodW5rcykpO1xuICAgIGNiID0gbnVsbDtcbiAgfSk7XG4gIHN0cmVhbS5vbmNlKFwiZXJyb3JcIiwgZnVuY3Rpb24oZXJyKSB7XG4gICAgaWYgKGNiKVxuICAgICAgY2IoZXJyKTtcbiAgICBjYiA9IG51bGw7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0aW1lZE91dChyZXEsIHRpbWUpIHtcbiAgaWYgKHJlcS50aW1lb3V0VGltZXIpIHtcbiAgICByZXR1cm4gcmVxO1xuICB9XG4gIGNvbnN0IGRlbGF5cyA9IGlzTmFOKHRpbWUpID8gdGltZSA6IHsgc29ja2V0OiB0aW1lLCBjb25uZWN0OiB0aW1lIH07XG4gIGNvbnN0IGhvc3RIZWFkZXIgPSByZXEuZ2V0SGVhZGVyKFwiaG9zdFwiKTtcbiAgY29uc3QgaG9zdCA9IGhvc3RIZWFkZXIgPyBcIiB0byBcIiArIGhvc3RIZWFkZXIgOiBcIlwiO1xuICBpZiAoZGVsYXlzLmNvbm5lY3QgIT09IHZvaWQgMCkge1xuICAgIHJlcS50aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIHRpbWVvdXRIYW5kbGVyKCkge1xuICAgICAgcmVxLmFib3J0KCk7XG4gICAgICBjb25zdCBlID0gbmV3IEVycm9yKFwiQ29ubmVjdGlvbiB0aW1lZCBvdXQgb24gcmVxdWVzdFwiICsgaG9zdCk7XG4gICAgICBlLmNvZGUgPSBcIkVUSU1FRE9VVFwiO1xuICAgICAgcmVxLmVtaXQoXCJlcnJvclwiLCBlKTtcbiAgICB9LCBkZWxheXMuY29ubmVjdCk7XG4gIH1cbiAgcmVxLm9uKFwic29ja2V0XCIsIGZ1bmN0aW9uIGFzc2lnbihzb2NrZXQpIHtcbiAgICBpZiAoIShzb2NrZXQuY29ubmVjdGluZyB8fCBzb2NrZXQuX2Nvbm5lY3RpbmcpKSB7XG4gICAgICBjb25uZWN0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNvY2tldC5vbmNlKFwiY29ubmVjdFwiLCBjb25uZWN0KTtcbiAgfSk7XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGlmIChyZXEudGltZW91dFRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQocmVxLnRpbWVvdXRUaW1lcik7XG4gICAgICByZXEudGltZW91dFRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgICBjbGVhcigpO1xuICAgIGlmIChkZWxheXMuc29ja2V0ICE9PSB2b2lkIDApIHtcbiAgICAgIHJlcS5zZXRUaW1lb3V0KGRlbGF5cy5zb2NrZXQsIGZ1bmN0aW9uIHNvY2tldFRpbWVvdXRIYW5kbGVyKCkge1xuICAgICAgICByZXEuYWJvcnQoKTtcbiAgICAgICAgY29uc3QgZSA9IG5ldyBFcnJvcihcIlNvY2tldCB0aW1lZCBvdXQgb24gcmVxdWVzdFwiICsgaG9zdCk7XG4gICAgICAgIGUuY29kZSA9IFwiRVNPQ0tFVFRJTUVET1VUXCI7XG4gICAgICAgIHJlcS5lbWl0KFwiZXJyb3JcIiwgZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcS5vbihcImVycm9yXCIsIGNsZWFyKTtcbn1cblxuY29uc3QgdXJpUGFydHMgPSBbXG4gIFwicHJvdG9jb2xcIixcbiAgXCJzbGFzaGVzXCIsXG4gIFwiYXV0aFwiLFxuICBcImhvc3RcIixcbiAgXCJwb3J0XCIsXG4gIFwiaG9zdG5hbWVcIixcbiAgXCJoYXNoXCIsXG4gIFwic2VhcmNoXCIsXG4gIFwicXVlcnlcIixcbiAgXCJwYXRobmFtZVwiLFxuICBcInBhdGhcIixcbiAgXCJocmVmXCJcbl07XG5jb25zdCBkZWZhdWx0UHJveHlIZWFkZXJXaGl0ZUxpc3QgPSBbXG4gIFwiYWNjZXB0XCIsXG4gIFwiYWNjZXB0LWNoYXJzZXRcIixcbiAgXCJhY2NlcHQtZW5jb2RpbmdcIixcbiAgXCJhY2NlcHQtbGFuZ3VhZ2VcIixcbiAgXCJhY2NlcHQtcmFuZ2VzXCIsXG4gIFwiY2FjaGUtY29udHJvbFwiLFxuICBcImNvbnRlbnQtZW5jb2RpbmdcIixcbiAgXCJjb250ZW50LWxhbmd1YWdlXCIsXG4gIFwiY29udGVudC1sb2NhdGlvblwiLFxuICBcImNvbnRlbnQtbWQ1XCIsXG4gIFwiY29udGVudC1yYW5nZVwiLFxuICBcImNvbnRlbnQtdHlwZVwiLFxuICBcImNvbm5lY3Rpb25cIixcbiAgXCJkYXRlXCIsXG4gIFwiZXhwZWN0XCIsXG4gIFwibWF4LWZvcndhcmRzXCIsXG4gIFwicHJhZ21hXCIsXG4gIFwicmVmZXJlclwiLFxuICBcInRlXCIsXG4gIFwidXNlci1hZ2VudFwiLFxuICBcInZpYVwiXG5dO1xuY29uc3QgZGVmYXVsdFByb3h5SGVhZGVyRXhjbHVzaXZlTGlzdCA9IFtcInByb3h5LWF1dGhvcml6YXRpb25cIl07XG5mdW5jdGlvbiBzaG91bGRFbmFibGUob3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMudHVubmVsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4ob3B0aW9ucy50dW5uZWwpO1xuICB9XG4gIGNvbnN0IHVyaSA9IHVybF9fZGVmYXVsdC5kZWZhdWx0LnBhcnNlKG9wdGlvbnMudXJsKTtcbiAgaWYgKHVyaS5wcm90b2NvbCA9PT0gXCJodHRwczpcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGFwcGx5QWdlbnQob3B0cyA9IHt9LCBwcm94eSkge1xuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cyk7XG4gIGNvbnN0IHByb3h5SGVhZGVyV2hpdGVMaXN0ID0gZGVmYXVsdFByb3h5SGVhZGVyV2hpdGVMaXN0LmNvbmNhdChvcHRpb25zLnByb3h5SGVhZGVyV2hpdGVMaXN0IHx8IFtdKS5tYXAoKGhlYWRlcikgPT4gaGVhZGVyLnRvTG93ZXJDYXNlKCkpO1xuICBjb25zdCBwcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3QgPSBkZWZhdWx0UHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0LmNvbmNhdChvcHRpb25zLnByb3h5SGVhZGVyRXhjbHVzaXZlTGlzdCB8fCBbXSkubWFwKChoZWFkZXIpID0+IGhlYWRlci50b0xvd2VyQ2FzZSgpKTtcbiAgY29uc3QgcHJveHlIZWFkZXJzID0gZ2V0QWxsb3dlZFByb3h5SGVhZGVycyhvcHRpb25zLmhlYWRlcnMsIHByb3h5SGVhZGVyV2hpdGVMaXN0KTtcbiAgcHJveHlIZWFkZXJzLmhvc3QgPSBjb25zdHJ1Y3RQcm94eUhvc3Qob3B0aW9ucyk7XG4gIG9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5rZXlzKG9wdGlvbnMuaGVhZGVycyB8fCB7fSkucmVkdWNlKChoZWFkZXJzLCBoZWFkZXIpID0+IHtcbiAgICBjb25zdCBpc0FsbG93ZWQgPSBwcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3QuaW5kZXhPZihoZWFkZXIudG9Mb3dlckNhc2UoKSkgPT09IC0xO1xuICAgIGlmIChpc0FsbG93ZWQpIHtcbiAgICAgIGhlYWRlcnNbaGVhZGVyXSA9IG9wdGlvbnMuaGVhZGVyc1toZWFkZXJdO1xuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycztcbiAgfSwge30pO1xuICBjb25zdCB0dW5uZWxGbiA9IGdldFR1bm5lbEZuKG9wdGlvbnMsIHByb3h5KTtcbiAgY29uc3QgdHVubmVsT3B0aW9ucyA9IGNvbnN0cnVjdFR1bm5lbE9wdGlvbnMob3B0aW9ucywgcHJveHksIHByb3h5SGVhZGVycyk7XG4gIG9wdGlvbnMuYWdlbnQgPSB0dW5uZWxGbih0dW5uZWxPcHRpb25zKTtcbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiBnZXRUdW5uZWxGbihvcHRpb25zLCBwcm94eSkge1xuICBjb25zdCB1cmkgPSBnZXRVcmlQYXJ0cyhvcHRpb25zKTtcbiAgY29uc3QgdHVubmVsRm5OYW1lID0gY29uc3RydWN0VHVubmVsRm5OYW1lKHVyaSwgcHJveHkpO1xuICByZXR1cm4gdHVubmVsX19uYW1lc3BhY2VbdHVubmVsRm5OYW1lXTtcbn1cbmZ1bmN0aW9uIGdldFVyaVBhcnRzKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHVyaVBhcnRzLnJlZHVjZSgodXJpLCBwYXJ0KSA9PiB7XG4gICAgdXJpW3BhcnRdID0gb3B0aW9uc1twYXJ0XTtcbiAgICByZXR1cm4gdXJpO1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBjb25zdHJ1Y3RUdW5uZWxGbk5hbWUodXJpLCBwcm94eSkge1xuICBjb25zdCB1cmlQcm90b2NvbCA9IHVyaS5wcm90b2NvbCA9PT0gXCJodHRwczpcIiA/IFwiaHR0cHNcIiA6IFwiaHR0cFwiO1xuICBjb25zdCBwcm94eVByb3RvY29sID0gcHJveHkucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIgPyBcIkh0dHBzXCIgOiBcIkh0dHBcIjtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KHVyaVByb3RvY29sLCBcIk92ZXJcIikuY29uY2F0KHByb3h5UHJvdG9jb2wpO1xufVxuZnVuY3Rpb24gY29uc3RydWN0UHJveHlIb3N0KHVyaSkge1xuICBjb25zdCBwb3J0ID0gdXJpLnBvcnQ7XG4gIGNvbnN0IHByb3RvY29sID0gdXJpLnByb3RvY29sO1xuICBsZXQgcHJveHlIb3N0ID0gXCJcIi5jb25jYXQodXJpLmhvc3RuYW1lLCBcIjpcIik7XG4gIGlmIChwb3J0KSB7XG4gICAgcHJveHlIb3N0ICs9IHBvcnQ7XG4gIH0gZWxzZSBpZiAocHJvdG9jb2wgPT09IFwiaHR0cHM6XCIpIHtcbiAgICBwcm94eUhvc3QgKz0gXCI0NDNcIjtcbiAgfSBlbHNlIHtcbiAgICBwcm94eUhvc3QgKz0gXCI4MFwiO1xuICB9XG4gIHJldHVybiBwcm94eUhvc3Q7XG59XG5mdW5jdGlvbiBnZXRBbGxvd2VkUHJveHlIZWFkZXJzKGhlYWRlcnMsIHdoaXRlTGlzdCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoaGVhZGVycykuZmlsdGVyKChoZWFkZXIpID0+IHdoaXRlTGlzdC5pbmRleE9mKGhlYWRlci50b0xvd2VyQ2FzZSgpKSAhPT0gLTEpLnJlZHVjZSgoc2V0LCBoZWFkZXIpID0+IHtcbiAgICBzZXRbaGVhZGVyXSA9IGhlYWRlcnNbaGVhZGVyXTtcbiAgICByZXR1cm4gc2V0O1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBjb25zdHJ1Y3RUdW5uZWxPcHRpb25zKG9wdGlvbnMsIHByb3h5LCBwcm94eUhlYWRlcnMpIHtcbiAgcmV0dXJuIHtcbiAgICBwcm94eToge1xuICAgICAgaG9zdDogcHJveHkuaG9zdG5hbWUsXG4gICAgICBwb3J0OiArcHJveHkucG9ydCxcbiAgICAgIHByb3h5QXV0aDogcHJveHkuYXV0aCxcbiAgICAgIGhlYWRlcnM6IHByb3h5SGVhZGVyc1xuICAgIH0sXG4gICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzLFxuICAgIGNhOiBvcHRpb25zLmNhLFxuICAgIGNlcnQ6IG9wdGlvbnMuY2VydCxcbiAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgIHBhc3NwaHJhc2U6IG9wdGlvbnMucGFzc3BocmFzZSxcbiAgICBwZng6IG9wdGlvbnMucGZ4LFxuICAgIGNpcGhlcnM6IG9wdGlvbnMuY2lwaGVycyxcbiAgICByZWplY3RVbmF1dGhvcml6ZWQ6IG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkLFxuICAgIHNlY3VyZU9wdGlvbnM6IG9wdGlvbnMuc2VjdXJlT3B0aW9ucyxcbiAgICBzZWN1cmVQcm90b2NvbDogb3B0aW9ucy5zZWN1cmVQcm90b2NvbFxuICB9O1xufVxuXG5jb25zdCBhZGFwdGVyID0gXCJub2RlXCI7XG5jb25zdCByZWR1Y2VSZXNwb25zZSA9IChyZXMsIHJlcVVybCwgbWV0aG9kLCBib2R5KSA9PiAoe1xuICBib2R5LFxuICB1cmw6IHJlcVVybCxcbiAgbWV0aG9kLFxuICBoZWFkZXJzOiByZXMuaGVhZGVycyxcbiAgc3RhdHVzQ29kZTogcmVzLnN0YXR1c0NvZGUsXG4gIHN0YXR1c01lc3NhZ2U6IHJlcy5zdGF0dXNNZXNzYWdlXG59KTtcbmNvbnN0IGh0dHBSZXF1ZXN0ZXIgPSAoY29udGV4dCwgY2IpID0+IHtcbiAgY29uc3QgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xuICBjb25zdCB1cmkgPSBPYmplY3QuYXNzaWduKHt9LCB1cmxfX2RlZmF1bHQuZGVmYXVsdC5wYXJzZShvcHRpb25zLnVybCkpO1xuICBpZiAodHlwZW9mIGZldGNoID09PSBcImZ1bmN0aW9uXCIgJiYgb3B0aW9ucy5mZXRjaCkge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3QgcmVxT3B0czIgPSBjb250ZXh0LmFwcGx5TWlkZGxld2FyZShcImZpbmFsaXplT3B0aW9uc1wiLCB7XG4gICAgICAuLi51cmksXG4gICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi50eXBlb2Ygb3B0aW9ucy5mZXRjaCA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmZldGNoLmhlYWRlcnMgPyBsb3dlckNhc2VIZWFkZXJzKG9wdGlvbnMuZmV0Y2guaGVhZGVycykgOiB7fSxcbiAgICAgICAgLi4ubG93ZXJDYXNlSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgICB9LFxuICAgICAgbWF4UmVkaXJlY3RzOiBvcHRpb25zLm1heFJlZGlyZWN0c1xuICAgIH0pO1xuICAgIGNvbnN0IGZldGNoT3B0cyA9IHtcbiAgICAgIGNyZWRlbnRpYWxzOiBvcHRpb25zLndpdGhDcmVkZW50aWFscyA/IFwiaW5jbHVkZVwiIDogXCJvbWl0XCIsXG4gICAgICAuLi50eXBlb2Ygb3B0aW9ucy5mZXRjaCA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuZmV0Y2ggOiB7fSxcbiAgICAgIG1ldGhvZDogcmVxT3B0czIubWV0aG9kLFxuICAgICAgaGVhZGVyczogcmVxT3B0czIuaGVhZGVycyxcbiAgICAgIGJvZHk6IG9wdGlvbnMuYm9keSxcbiAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWxcbiAgICB9O1xuICAgIGNvbnN0IGluamVjdGVkUmVzcG9uc2UyID0gY29udGV4dC5hcHBseU1pZGRsZXdhcmUoXCJpbnRlcmNlcHRSZXF1ZXN0XCIsIHZvaWQgMCwge1xuICAgICAgYWRhcHRlcixcbiAgICAgIGNvbnRleHRcbiAgICB9KTtcbiAgICBpZiAoaW5qZWN0ZWRSZXNwb25zZTIpIHtcbiAgICAgIGNvbnN0IGNiVGltZXIgPSBzZXRUaW1lb3V0KGNiLCAwLCBudWxsLCBpbmplY3RlZFJlc3BvbnNlMik7XG4gICAgICBjb25zdCBjYW5jZWwgPSAoKSA9PiBjbGVhclRpbWVvdXQoY2JUaW1lcik7XG4gICAgICByZXR1cm4geyBhYm9ydDogY2FuY2VsIH07XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3QyID0gZmV0Y2gob3B0aW9ucy51cmwsIGZldGNoT3B0cyk7XG4gICAgY29udGV4dC5hcHBseU1pZGRsZXdhcmUoXCJvblJlcXVlc3RcIiwgeyBvcHRpb25zLCBhZGFwdGVyLCByZXF1ZXN0OiByZXF1ZXN0MiwgY29udGV4dCB9KTtcbiAgICByZXF1ZXN0Mi50aGVuKGFzeW5jIChyZXMpID0+IHtcbiAgICAgIGNvbnN0IGJvZHkgPSBvcHRpb25zLnJhd0JvZHkgPyByZXMuYm9keSA6IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgICByZXMuaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgICBjYihudWxsLCB7XG4gICAgICAgIGJvZHksXG4gICAgICAgIHVybDogcmVzLnVybCxcbiAgICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzTWVzc2FnZTogcmVzLnN0YXR1c1RleHRcbiAgICAgIH0pO1xuICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIubmFtZSA9PSBcIkFib3J0RXJyb3JcIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2IoZXJyKTtcbiAgICB9KTtcbiAgICByZXR1cm4geyBhYm9ydDogKCkgPT4gY29udHJvbGxlci5hYm9ydCgpIH07XG4gIH1cbiAgY29uc3QgYm9keVR5cGUgPSBpc1N0cmVhbV9fZGVmYXVsdC5kZWZhdWx0KG9wdGlvbnMuYm9keSkgPyBcInN0cmVhbVwiIDogdHlwZW9mIG9wdGlvbnMuYm9keTtcbiAgaWYgKGJvZHlUeXBlICE9PSBcInVuZGVmaW5lZFwiICYmIGJvZHlUeXBlICE9PSBcInN0cmVhbVwiICYmIGJvZHlUeXBlICE9PSBcInN0cmluZ1wiICYmICFCdWZmZXIuaXNCdWZmZXIob3B0aW9ucy5ib2R5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlJlcXVlc3QgYm9keSBtdXN0IGJlIGEgc3RyaW5nLCBidWZmZXIgb3Igc3RyZWFtLCBnb3QgXCIuY29uY2F0KGJvZHlUeXBlKSk7XG4gIH1cbiAgY29uc3QgbGVuZ3RoSGVhZGVyID0ge307XG4gIGlmIChvcHRpb25zLmJvZHlTaXplKSB7XG4gICAgbGVuZ3RoSGVhZGVyW1wiY29udGVudC1sZW5ndGhcIl0gPSBvcHRpb25zLmJvZHlTaXplO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuYm9keSAmJiBib2R5VHlwZSAhPT0gXCJzdHJlYW1cIikge1xuICAgIGxlbmd0aEhlYWRlcltcImNvbnRlbnQtbGVuZ3RoXCJdID0gQnVmZmVyLmJ5dGVMZW5ndGgob3B0aW9ucy5ib2R5KTtcbiAgfVxuICBsZXQgYWJvcnRlZCA9IGZhbHNlO1xuICBjb25zdCBjYWxsYmFjayA9IChlcnIsIHJlcykgPT4gIWFib3J0ZWQgJiYgY2IoZXJyLCByZXMpO1xuICBjb250ZXh0LmNoYW5uZWxzLmFib3J0LnN1YnNjcmliZSgoKSA9PiB7XG4gICAgYWJvcnRlZCA9IHRydWU7XG4gIH0pO1xuICBsZXQgcmVxT3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIHVyaSwge1xuICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7fSwgbG93ZXJDYXNlSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpLCBsZW5ndGhIZWFkZXIpLFxuICAgIG1heFJlZGlyZWN0czogb3B0aW9ucy5tYXhSZWRpcmVjdHNcbiAgfSk7XG4gIGNvbnN0IHByb3h5ID0gZ2V0UHJveHlPcHRpb25zKG9wdGlvbnMpO1xuICBjb25zdCB0dW5uZWwgPSBwcm94eSAmJiBzaG91bGRFbmFibGUob3B0aW9ucyk7XG4gIGNvbnN0IGluamVjdGVkUmVzcG9uc2UgPSBjb250ZXh0LmFwcGx5TWlkZGxld2FyZShcImludGVyY2VwdFJlcXVlc3RcIiwgdm9pZCAwLCB7XG4gICAgYWRhcHRlcixcbiAgICBjb250ZXh0XG4gIH0pO1xuICBpZiAoaW5qZWN0ZWRSZXNwb25zZSkge1xuICAgIGNvbnN0IGNiVGltZXIgPSBzZXRJbW1lZGlhdGUoY2FsbGJhY2ssIG51bGwsIGluamVjdGVkUmVzcG9uc2UpO1xuICAgIGNvbnN0IGFib3J0ID0gKCkgPT4gY2xlYXJJbW1lZGlhdGUoY2JUaW1lcik7XG4gICAgcmV0dXJuIHsgYWJvcnQgfTtcbiAgfVxuICBpZiAob3B0aW9ucy5tYXhSZWRpcmVjdHMgIT09IDApIHtcbiAgICByZXFPcHRzLm1heFJlZGlyZWN0cyA9IG9wdGlvbnMubWF4UmVkaXJlY3RzIHx8IDU7XG4gIH1cbiAgaWYgKHByb3h5ICYmIHR1bm5lbCkge1xuICAgIHJlcU9wdHMgPSBhcHBseUFnZW50KHJlcU9wdHMsIHByb3h5KTtcbiAgfSBlbHNlIGlmIChwcm94eSAmJiAhdHVubmVsKSB7XG4gICAgcmVxT3B0cyA9IHJld3JpdGVVcmlGb3JQcm94eShyZXFPcHRzLCB1cmksIHByb3h5KTtcbiAgfVxuICBpZiAoIXR1bm5lbCAmJiBwcm94eSAmJiBwcm94eS5hdXRoICYmICFyZXFPcHRzLmhlYWRlcnNbXCJwcm94eS1hdXRob3JpemF0aW9uXCJdKSB7XG4gICAgY29uc3QgW3VzZXJuYW1lLCBwYXNzd29yZF0gPSBwcm94eS5hdXRoLnVzZXJuYW1lID8gW3Byb3h5LmF1dGgudXNlcm5hbWUsIHByb3h5LmF1dGgucGFzc3dvcmRdIDogcHJveHkuYXV0aC5zcGxpdChcIjpcIikubWFwKChpdGVtKSA9PiBxc19fZGVmYXVsdC5kZWZhdWx0LnVuZXNjYXBlKGl0ZW0pKTtcbiAgICBjb25zdCBhdXRoID0gQnVmZmVyLmZyb20oXCJcIi5jb25jYXQodXNlcm5hbWUsIFwiOlwiKS5jb25jYXQocGFzc3dvcmQpLCBcInV0ZjhcIik7XG4gICAgY29uc3QgYXV0aEJhc2U2NCA9IGF1dGgudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgcmVxT3B0cy5oZWFkZXJzW1wicHJveHktYXV0aG9yaXphdGlvblwiXSA9IFwiQmFzaWMgXCIuY29uY2F0KGF1dGhCYXNlNjQpO1xuICB9XG4gIGNvbnN0IHRyYW5zcG9ydCA9IGdldFJlcXVlc3RUcmFuc3BvcnQocmVxT3B0cywgcHJveHksIHR1bm5lbCk7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5kZWJ1ZyA9PT0gXCJmdW5jdGlvblwiICYmIHByb3h5KSB7XG4gICAgb3B0aW9ucy5kZWJ1ZyhcbiAgICAgIFwiUHJveHlpbmcgdXNpbmcgJXNcIixcbiAgICAgIHJlcU9wdHMuYWdlbnQgPyBcInR1bm5lbCBhZ2VudFwiIDogXCJcIi5jb25jYXQocmVxT3B0cy5ob3N0LCBcIjpcIikuY29uY2F0KHJlcU9wdHMucG9ydClcbiAgICApO1xuICB9XG4gIGNvbnN0IHRyeUNvbXByZXNzZWQgPSByZXFPcHRzLm1ldGhvZCAhPT0gXCJIRUFEXCI7XG4gIGlmICh0cnlDb21wcmVzc2VkICYmICFyZXFPcHRzLmhlYWRlcnNbXCJhY2NlcHQtZW5jb2RpbmdcIl0gJiYgb3B0aW9ucy5jb21wcmVzcyAhPT0gZmFsc2UpIHtcbiAgICByZXFPcHRzLmhlYWRlcnNbXCJhY2NlcHQtZW5jb2RpbmdcIl0gPSBcImJyLCBnemlwLCBkZWZsYXRlXCI7XG4gIH1cbiAgY29uc3QgZmluYWxPcHRpb25zID0gY29udGV4dC5hcHBseU1pZGRsZXdhcmUoXG4gICAgXCJmaW5hbGl6ZU9wdGlvbnNcIixcbiAgICByZXFPcHRzXG4gICk7XG4gIGNvbnN0IHJlcXVlc3QgPSB0cmFuc3BvcnQucmVxdWVzdChmaW5hbE9wdGlvbnMsIChyZXNwb25zZSkgPT4ge1xuICAgIGNvbnN0IHJlcyA9IHRyeUNvbXByZXNzZWQgPyBkZWNvbXByZXNzUmVzcG9uc2VfX2RlZmF1bHQuZGVmYXVsdChyZXNwb25zZSkgOiByZXNwb25zZTtcbiAgICBjb25zdCByZXNTdHJlYW0gPSBjb250ZXh0LmFwcGx5TWlkZGxld2FyZShcIm9uSGVhZGVyc1wiLCByZXMsIHtcbiAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBhZGFwdGVyLFxuICAgICAgY29udGV4dFxuICAgIH0pO1xuICAgIGNvbnN0IHJlcVVybCA9IFwicmVzcG9uc2VVcmxcIiBpbiByZXNwb25zZSA/IHJlc3BvbnNlLnJlc3BvbnNlVXJsIDogb3B0aW9ucy51cmw7XG4gICAgaWYgKG9wdGlvbnMuc3RyZWFtKSB7XG4gICAgICBjYWxsYmFjayhudWxsLCByZWR1Y2VSZXNwb25zZShyZXMsIHJlcVVybCwgcmVxT3B0cy5tZXRob2QsIHJlc1N0cmVhbSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25jYXQocmVzU3RyZWFtLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgICAgY29uc3QgYm9keSA9IG9wdGlvbnMucmF3Qm9keSA/IGRhdGEgOiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICBjb25zdCByZWR1Y2VkID0gcmVkdWNlUmVzcG9uc2UocmVzLCByZXFVcmwsIHJlcU9wdHMubWV0aG9kLCBib2R5KTtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZWR1Y2VkKTtcbiAgICB9KTtcbiAgfSk7XG4gIGlmIChvcHRpb25zLnRpbWVvdXQpIHtcbiAgICB0aW1lZE91dChyZXF1ZXN0LCBvcHRpb25zLnRpbWVvdXQpO1xuICB9XG4gIHJlcXVlc3Qub25jZShcImVycm9yXCIsIGNhbGxiYWNrKTtcbiAgY29uc3QgeyBib2R5U3RyZWFtLCBwcm9ncmVzcyB9ID0gZ2V0UHJvZ3Jlc3NTdHJlYW0ob3B0aW9ucyk7XG4gIGNvbnRleHQuYXBwbHlNaWRkbGV3YXJlKFwib25SZXF1ZXN0XCIsIHsgb3B0aW9ucywgYWRhcHRlciwgcmVxdWVzdCwgY29udGV4dCwgcHJvZ3Jlc3MgfSk7XG4gIGlmIChib2R5U3RyZWFtKSB7XG4gICAgYm9keVN0cmVhbS5waXBlKHJlcXVlc3QpO1xuICB9IGVsc2Uge1xuICAgIHJlcXVlc3QuZW5kKG9wdGlvbnMuYm9keSk7XG4gIH1cbiAgcmV0dXJuIHsgYWJvcnQ6ICgpID0+IHJlcXVlc3QuYWJvcnQoKSB9O1xufTtcbmZ1bmN0aW9uIGdldFByb2dyZXNzU3RyZWFtKG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zLmJvZHkpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgY29uc3QgYm9keUlzU3RyZWFtID0gaXNTdHJlYW1fX2RlZmF1bHQuZGVmYXVsdChvcHRpb25zLmJvZHkpO1xuICBjb25zdCBsZW5ndGggPSBvcHRpb25zLmJvZHlTaXplIHx8IChib2R5SXNTdHJlYW0gPyBudWxsIDogQnVmZmVyLmJ5dGVMZW5ndGgob3B0aW9ucy5ib2R5KSk7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJvZHlJc1N0cmVhbSA/IHsgYm9keVN0cmVhbTogb3B0aW9ucy5ib2R5IH0gOiB7fTtcbiAgfVxuICBjb25zdCBwcm9ncmVzcyA9IHByb2dyZXNzU3RyZWFtX19kZWZhdWx0LmRlZmF1bHQoeyB0aW1lOiAxNiwgbGVuZ3RoIH0pO1xuICBjb25zdCBib2R5U3RyZWFtID0gYm9keUlzU3RyZWFtID8gb3B0aW9ucy5ib2R5IDogdG9TdHJlYW1fX2RlZmF1bHQuZGVmYXVsdChvcHRpb25zLmJvZHkpO1xuICByZXR1cm4geyBib2R5U3RyZWFtOiBib2R5U3RyZWFtLnBpcGUocHJvZ3Jlc3MpLCBwcm9ncmVzcyB9O1xufVxuZnVuY3Rpb24gZ2V0UmVxdWVzdFRyYW5zcG9ydChyZXFPcHRzLCBwcm94eSwgdHVubmVsKSB7XG4gIGNvbnN0IGlzSHR0cHNSZXF1ZXN0ID0gcmVxT3B0cy5wcm90b2NvbCA9PT0gXCJodHRwczpcIjtcbiAgY29uc3QgdHJhbnNwb3J0cyA9IHJlcU9wdHMubWF4UmVkaXJlY3RzID09PSAwID8geyBodHRwOiBodHRwX19kZWZhdWx0LmRlZmF1bHQsIGh0dHBzOiBodHRwc19fZGVmYXVsdC5kZWZhdWx0IH0gOiB7IGh0dHA6IGZvbGxvd19fZGVmYXVsdC5kZWZhdWx0Lmh0dHAsIGh0dHBzOiBmb2xsb3dfX2RlZmF1bHQuZGVmYXVsdC5odHRwcyB9O1xuICBpZiAoIXByb3h5IHx8IHR1bm5lbCkge1xuICAgIHJldHVybiBpc0h0dHBzUmVxdWVzdCA/IHRyYW5zcG9ydHMuaHR0cHMgOiB0cmFuc3BvcnRzLmh0dHA7XG4gIH1cbiAgbGV0IGlzSHR0cHNQcm94eSA9IHByb3h5LnBvcnQgPT09IDQ0MztcbiAgaWYgKHByb3h5LnByb3RvY29sKSB7XG4gICAgaXNIdHRwc1Byb3h5ID0gL15odHRwczo/Ly50ZXN0KHByb3h5LnByb3RvY29sKTtcbiAgfVxuICByZXR1cm4gaXNIdHRwc1Byb3h5ID8gdHJhbnNwb3J0cy5odHRwcyA6IHRyYW5zcG9ydHMuaHR0cDtcbn1cblxuY29uc3QgZ2V0SXQgPSAoaW5pdE1pZGRsZXdhcmUgPSBbXSwgaHR0cFJlcXVlc3QgPSBodHRwUmVxdWVzdGVyKSA9PiBjcmVhdGVSZXF1ZXN0ZXIoaW5pdE1pZGRsZXdhcmUsIGh0dHBSZXF1ZXN0KTtcbmNvbnN0IGVudmlyb25tZW50ID0gXCJub2RlXCI7XG5cbmV4cG9ydHMuYWRhcHRlciA9IGFkYXB0ZXI7XG5leHBvcnRzLmVudmlyb25tZW50ID0gZW52aXJvbm1lbnQ7XG5leHBvcnRzLmdldEl0ID0gZ2V0SXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5janMubWFwXG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0T3B0aW9uc1ZhbGlkYXRvciIsInJlcXVpcmUiLCJkZWNvbXByZXNzUmVzcG9uc2UiLCJmb2xsb3ciLCJodHRwIiwiaHR0cHMiLCJ0b1N0cmVhbSIsImlzU3RyZWFtIiwicHJvZ3Jlc3NTdHJlYW0iLCJxcyIsInVybCIsInR1bm5lbCIsIl9pbnRlcm9wRGVmYXVsdENvbXBhdCIsImUiLCJkZWZhdWx0IiwiX2ludGVyb3BOYW1lc3BhY2VDb21wYXQiLCJuIiwiY3JlYXRlIiwia2V5cyIsImZvckVhY2giLCJrIiwiZCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldCIsImVudW1lcmFibGUiLCJmcmVlemUiLCJkZWNvbXByZXNzUmVzcG9uc2VfX2RlZmF1bHQiLCJmb2xsb3dfX2RlZmF1bHQiLCJodHRwX19kZWZhdWx0IiwiaHR0cHNfX2RlZmF1bHQiLCJ0b1N0cmVhbV9fZGVmYXVsdCIsImlzU3RyZWFtX19kZWZhdWx0IiwicHJvZ3Jlc3NTdHJlYW1fX2RlZmF1bHQiLCJxc19fZGVmYXVsdCIsInVybF9fZGVmYXVsdCIsInR1bm5lbF9fbmFtZXNwYWNlIiwibWlkZGxld2FyZVJlZHVjZXIiLCJtaWRkbGV3YXJlIiwiYXBwbHlNaWRkbGV3YXJlIiwiaG9vayIsImRlZmF1bHRWYWx1ZSIsImFyZ3MiLCJiYWlsRWFybHkiLCJpIiwibGVuZ3RoIiwiaGFuZGxlciIsImNyZWF0ZVB1YlN1YiIsInN1YnNjcmliZXJzIiwibmV4dElkIiwic3Vic2NyaWJlIiwic3Vic2NyaWJlciIsImlkIiwidW5zdWJzY3JpYmUiLCJwdWJsaXNoIiwiZXZlbnQiLCJjaGFubmVsTmFtZXMiLCJtaWRkbGVob29rcyIsImNyZWF0ZVJlcXVlc3RlciIsImluaXRNaWRkbGV3YXJlIiwiaHR0cFJlcXVlc3QiLCJsb2FkZWRNaWRkbGV3YXJlIiwicmVkdWNlIiwid2FyZSIsIm5hbWUiLCJwcm9jZXNzT3B0aW9ucyIsInZhbGlkYXRlT3B0aW9ucyIsInJlcXVlc3QiLCJvcHRzIiwib25SZXNwb25zZSIsInJlcUVyciIsInJlcyIsImN0eCIsImVycm9yIiwicmVzcG9uc2UiLCJlcnIiLCJjaGFubmVscyIsInRhcmdldCIsIm9wdGlvbnMiLCJjb250ZXh0Iiwib25nb2luZ1JlcXVlc3QiLCJhYm9ydCIsInJldHVyblZhbHVlIiwidXNlIiwibmV3TWlkZGxld2FyZSIsIkVycm9yIiwib25SZXR1cm4iLCJrZXkiLCJwdXNoIiwiY2xvbmUiLCJsb3dlckNhc2VIZWFkZXJzIiwiaGVhZGVycyIsImFjYyIsImhlYWRlciIsInRvTG93ZXJDYXNlIiwiZm9ybWF0SG9zdG5hbWUiLCJob3N0bmFtZSIsInJlcGxhY2UiLCJwYXJzZU5vUHJveHlab25lIiwiem9uZVN0ciIsInpvbmUiLCJ0cmltIiwiem9uZVBhcnRzIiwic3BsaXQiLCJ6b25lSG9zdCIsInpvbmVQb3J0IiwiaGFzUG9ydCIsImluZGV4T2YiLCJwb3J0IiwidXJpSW5Ob1Byb3h5IiwidXJpIiwibm9Qcm94eSIsInByb3RvY29sIiwibm9Qcm94eUxpc3QiLCJtYXAiLCJzb21lIiwibm9Qcm94eVpvbmUiLCJpc01hdGNoZWRBdCIsImhvc3RuYW1lTWF0Y2hlZCIsImdldFByb3h5RnJvbVVyaSIsInByb2Nlc3MiLCJlbnYiLCJOT19QUk9YWSIsIm5vX3Byb3h5IiwiSFRUUF9QUk9YWSIsImh0dHBfcHJveHkiLCJIVFRQU19QUk9YWSIsImh0dHBzX3Byb3h5IiwiZ2V0SG9zdEZyb21VcmkiLCJob3N0IiwiZ2V0SG9zdEhlYWRlcldpdGhQb3J0IiwiY29uY2F0IiwicmV3cml0ZVVyaUZvclByb3h5IiwicmVxT3B0cyIsInByb3h5IiwiYXNzaWduIiwiaHJlZiIsInBhdGgiLCJmb3JtYXQiLCJnZXRQcm94eU9wdGlvbnMiLCJoYXNPd25Qcm9wZXJ0eSIsInBhcnNlIiwic3RyZWFtIiwiY2IiLCJjaHVua3MiLCJvbiIsImNodW5rIiwib25jZSIsIkJ1ZmZlciIsInRpbWVkT3V0IiwicmVxIiwidGltZSIsInRpbWVvdXRUaW1lciIsImRlbGF5cyIsImlzTmFOIiwic29ja2V0IiwiY29ubmVjdCIsImhvc3RIZWFkZXIiLCJnZXRIZWFkZXIiLCJzZXRUaW1lb3V0IiwidGltZW91dEhhbmRsZXIiLCJjb2RlIiwiZW1pdCIsImNvbm5lY3RpbmciLCJfY29ubmVjdGluZyIsImNsZWFyIiwiY2xlYXJUaW1lb3V0Iiwic29ja2V0VGltZW91dEhhbmRsZXIiLCJ1cmlQYXJ0cyIsImRlZmF1bHRQcm94eUhlYWRlcldoaXRlTGlzdCIsImRlZmF1bHRQcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3QiLCJzaG91bGRFbmFibGUiLCJCb29sZWFuIiwiYXBwbHlBZ2VudCIsInByb3h5SGVhZGVyV2hpdGVMaXN0IiwicHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0IiwicHJveHlIZWFkZXJzIiwiZ2V0QWxsb3dlZFByb3h5SGVhZGVycyIsImNvbnN0cnVjdFByb3h5SG9zdCIsImlzQWxsb3dlZCIsInR1bm5lbEZuIiwiZ2V0VHVubmVsRm4iLCJ0dW5uZWxPcHRpb25zIiwiY29uc3RydWN0VHVubmVsT3B0aW9ucyIsImFnZW50IiwiZ2V0VXJpUGFydHMiLCJ0dW5uZWxGbk5hbWUiLCJjb25zdHJ1Y3RUdW5uZWxGbk5hbWUiLCJwYXJ0IiwidXJpUHJvdG9jb2wiLCJwcm94eVByb3RvY29sIiwicHJveHlIb3N0Iiwid2hpdGVMaXN0IiwiZmlsdGVyIiwic2V0IiwicHJveHlBdXRoIiwiYXV0aCIsImNhIiwiY2VydCIsInBhc3NwaHJhc2UiLCJwZngiLCJjaXBoZXJzIiwicmVqZWN0VW5hdXRob3JpemVkIiwic2VjdXJlT3B0aW9ucyIsInNlY3VyZVByb3RvY29sIiwiYWRhcHRlciIsInJlZHVjZVJlc3BvbnNlIiwicmVxVXJsIiwibWV0aG9kIiwiYm9keSIsInN0YXR1c0NvZGUiLCJzdGF0dXNNZXNzYWdlIiwiaHR0cFJlcXVlc3RlciIsImZldGNoIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInJlcU9wdHMyIiwibWF4UmVkaXJlY3RzIiwiZmV0Y2hPcHRzIiwiY3JlZGVudGlhbHMiLCJ3aXRoQ3JlZGVudGlhbHMiLCJzaWduYWwiLCJpbmplY3RlZFJlc3BvbnNlMiIsImNiVGltZXIiLCJjYW5jZWwiLCJyZXF1ZXN0MiIsInRoZW4iLCJyYXdCb2R5IiwidGV4dCIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJjYXRjaCIsImJvZHlUeXBlIiwiaXNCdWZmZXIiLCJsZW5ndGhIZWFkZXIiLCJib2R5U2l6ZSIsImJ5dGVMZW5ndGgiLCJhYm9ydGVkIiwiY2FsbGJhY2siLCJpbmplY3RlZFJlc3BvbnNlIiwic2V0SW1tZWRpYXRlIiwiY2xlYXJJbW1lZGlhdGUiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiaXRlbSIsInVuZXNjYXBlIiwiZnJvbSIsImF1dGhCYXNlNjQiLCJ0b1N0cmluZyIsInRyYW5zcG9ydCIsImdldFJlcXVlc3RUcmFuc3BvcnQiLCJkZWJ1ZyIsInRyeUNvbXByZXNzZWQiLCJjb21wcmVzcyIsImZpbmFsT3B0aW9ucyIsInJlc1N0cmVhbSIsInJlc3BvbnNlVXJsIiwiZGF0YSIsInJlZHVjZWQiLCJ0aW1lb3V0IiwiYm9keVN0cmVhbSIsInByb2dyZXNzIiwiZ2V0UHJvZ3Jlc3NTdHJlYW0iLCJwaXBlIiwiZW5kIiwiYm9keUlzU3RyZWFtIiwiaXNIdHRwc1JlcXVlc3QiLCJ0cmFuc3BvcnRzIiwiaXNIdHRwc1Byb3h5IiwidGVzdCIsImdldEl0IiwiZW52aXJvbm1lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/get-it/dist/index.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/get-it/dist/middleware.cjs":
/*!*************************************************!*\
  !*** ./node_modules/get-it/dist/middleware.cjs ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar http = __webpack_require__(/*! http */ \"http\");\nvar https = __webpack_require__(/*! https */ \"https\");\nvar debugIt = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\");\nvar defaultOptionsValidator = __webpack_require__(/*! ./_chunks/defaultOptionsValidator-n1t8zknB.cjs */ \"(ssr)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-n1t8zknB.cjs\");\nvar isPlainObject = __webpack_require__(/*! is-plain-object */ \"(ssr)/./node_modules/is-plain-object/dist/is-plain-object.js\");\nvar progressStream = __webpack_require__(/*! progress-stream */ \"(ssr)/./node_modules/progress-stream/index.js\");\nvar allowed = __webpack_require__(/*! is-retry-allowed */ \"(ssr)/./node_modules/is-retry-allowed/index.js\");\nfunction _interopDefaultCompat(e) {\n    return e && typeof e === \"object\" && \"default\" in e ? e : {\n        default: e\n    };\n}\nvar debugIt__default = /*#__PURE__*/ _interopDefaultCompat(debugIt);\nvar progressStream__default = /*#__PURE__*/ _interopDefaultCompat(progressStream);\nvar allowed__default = /*#__PURE__*/ _interopDefaultCompat(allowed);\nconst isHttpsProto = /^https:/i;\nfunction agent(opts) {\n    const httpAgent = new http.Agent(opts);\n    const httpsAgent = new https.Agent(opts);\n    const agents = {\n        http: httpAgent,\n        https: httpsAgent\n    };\n    return {\n        finalizeOptions: (options)=>{\n            if (options.agent) {\n                return options;\n            }\n            if (options.maxRedirects > 0) {\n                return {\n                    ...options,\n                    agents\n                };\n            }\n            const isHttps = isHttpsProto.test(options.href || options.protocol);\n            return {\n                ...options,\n                agent: isHttps ? httpsAgent : httpAgent\n            };\n        }\n    };\n}\nconst leadingSlash = /^\\//;\nconst trailingSlash = /\\/$/;\nfunction base(baseUrl) {\n    const baseUri = baseUrl.replace(trailingSlash, \"\");\n    return {\n        processOptions: (options)=>{\n            if (/^https?:\\/\\//i.test(options.url)) {\n                return options;\n            }\n            const url = [\n                baseUri,\n                options.url.replace(leadingSlash, \"\")\n            ].join(\"/\");\n            return Object.assign({}, options, {\n                url\n            });\n        }\n    };\n}\nconst SENSITIVE_HEADERS = [\n    \"cookie\",\n    \"authorization\"\n];\nconst hasOwn = Object.prototype.hasOwnProperty;\nconst redactKeys = (source, redacted)=>{\n    const target = {};\n    for(const key in source){\n        if (hasOwn.call(source, key)) {\n            target[key] = redacted.indexOf(key.toLowerCase()) > -1 ? \"<redacted>\" : source[key];\n        }\n    }\n    return target;\n};\nfunction debug(opts = {}) {\n    const verbose = opts.verbose;\n    const namespace = opts.namespace || \"get-it\";\n    const defaultLogger = debugIt__default.default(namespace);\n    const log = opts.log || defaultLogger;\n    const shortCircuit = log === defaultLogger && !debugIt__default.default.enabled(namespace);\n    let requestId = 0;\n    return {\n        processOptions: (options)=>{\n            options.debug = log;\n            options.requestId = options.requestId || ++requestId;\n            return options;\n        },\n        onRequest: (event)=>{\n            if (shortCircuit || !event) {\n                return event;\n            }\n            const options = event.options;\n            log(\"[%s] HTTP %s %s\", options.requestId, options.method, options.url);\n            if (verbose && options.body && typeof options.body === \"string\") {\n                log(\"[%s] Request body: %s\", options.requestId, options.body);\n            }\n            if (verbose && options.headers) {\n                const headers = opts.redactSensitiveHeaders === false ? options.headers : redactKeys(options.headers, SENSITIVE_HEADERS);\n                log(\"[%s] Request headers: %s\", options.requestId, JSON.stringify(headers, null, 2));\n            }\n            return event;\n        },\n        onResponse: (res, context)=>{\n            if (shortCircuit || !res) {\n                return res;\n            }\n            const reqId = context.options.requestId;\n            log(\"[%s] Response code: %s %s\", reqId, res.statusCode, res.statusMessage);\n            if (verbose && res.body) {\n                log(\"[%s] Response body: %s\", reqId, stringifyBody(res));\n            }\n            return res;\n        },\n        onError: (err, context)=>{\n            const reqId = context.options.requestId;\n            if (!err) {\n                log(\"[%s] Error encountered, but handled by an earlier middleware\", reqId);\n                return err;\n            }\n            log(\"[%s] ERROR: %s\", reqId, err.message);\n            return err;\n        }\n    };\n}\nfunction stringifyBody(res) {\n    const contentType = (res.headers[\"content-type\"] || \"\").toLowerCase();\n    const isJson = contentType.indexOf(\"application/json\") !== -1;\n    return isJson ? tryFormat(res.body) : res.body;\n}\nfunction tryFormat(body) {\n    try {\n        const parsed = typeof body === \"string\" ? JSON.parse(body) : body;\n        return JSON.stringify(parsed, null, 2);\n    } catch (err) {\n        return body;\n    }\n}\nfunction headers(_headers, opts = {}) {\n    return {\n        processOptions: (options)=>{\n            const existing = options.headers || {};\n            options.headers = opts.override ? Object.assign({}, existing, _headers) : Object.assign({}, _headers, existing);\n            return options;\n        }\n    };\n}\nclass HttpError extends Error {\n    constructor(res, ctx){\n        super();\n        const truncatedUrl = res.url.length > 400 ? \"\".concat(res.url.slice(0, 399), \"\") : res.url;\n        let msg = \"\".concat(res.method, \"-request to \").concat(truncatedUrl, \" resulted in \");\n        msg += \"HTTP \".concat(res.statusCode, \" \").concat(res.statusMessage);\n        this.message = msg.trim();\n        this.response = res;\n        this.request = ctx.options;\n    }\n}\nfunction httpErrors() {\n    return {\n        onResponse: (res, ctx)=>{\n            const isHttpError = res.statusCode >= 400;\n            if (!isHttpError) {\n                return res;\n            }\n            throw new HttpError(res, ctx);\n        }\n    };\n}\nfunction injectResponse(opts = {}) {\n    if (typeof opts.inject !== \"function\") {\n        throw new Error(\"`injectResponse` middleware requires a `inject` function\");\n    }\n    const inject = function inject2(prevValue, event) {\n        const response = opts.inject(event, prevValue);\n        if (!response) {\n            return prevValue;\n        }\n        const options = event.context.options;\n        return {\n            body: \"\",\n            url: options.url,\n            method: options.method,\n            headers: {},\n            statusCode: 200,\n            statusMessage: \"OK\",\n            ...response\n        };\n    };\n    return {\n        interceptRequest: inject\n    };\n}\nconst isBuffer = typeof Buffer === \"undefined\" ? ()=>false : (obj)=>Buffer.isBuffer(obj);\nconst serializeTypes = [\n    \"boolean\",\n    \"string\",\n    \"number\"\n];\nfunction jsonRequest() {\n    return {\n        processOptions: (options)=>{\n            const body = options.body;\n            if (!body) {\n                return options;\n            }\n            const isStream = typeof body.pipe === \"function\";\n            const shouldSerialize = !isStream && !isBuffer(body) && (serializeTypes.indexOf(typeof body) !== -1 || Array.isArray(body) || isPlainObject.isPlainObject(body));\n            if (!shouldSerialize) {\n                return options;\n            }\n            return Object.assign({}, options, {\n                body: JSON.stringify(options.body),\n                headers: Object.assign({}, options.headers, {\n                    \"Content-Type\": \"application/json\"\n                })\n            });\n        }\n    };\n}\nfunction jsonResponse(opts) {\n    return {\n        onResponse: (response)=>{\n            const contentType = response.headers[\"content-type\"] || \"\";\n            const shouldDecode = opts && opts.force || contentType.indexOf(\"application/json\") !== -1;\n            if (!response.body || !contentType || !shouldDecode) {\n                return response;\n            }\n            return Object.assign({}, response, {\n                body: tryParse(response.body)\n            });\n        },\n        processOptions: (options)=>Object.assign({}, options, {\n                headers: Object.assign({\n                    Accept: \"application/json\"\n                }, options.headers)\n            })\n    };\n    function tryParse(body) {\n        try {\n            return JSON.parse(body);\n        } catch (err) {\n            err.message = \"Failed to parsed response body as JSON: \".concat(err.message);\n            throw err;\n        }\n    }\n}\nfunction isBrowserOptions(options) {\n    return typeof options === \"object\" && options !== null && !(\"protocol\" in options);\n}\nfunction mtls(config = {}) {\n    if (!config.ca) {\n        throw new Error('Required mtls option \"ca\" is missing');\n    }\n    if (!config.cert) {\n        throw new Error('Required mtls option \"cert\" is missing');\n    }\n    if (!config.key) {\n        throw new Error('Required mtls option \"key\" is missing');\n    }\n    return {\n        finalizeOptions: (options)=>{\n            if (isBrowserOptions(options)) {\n                return options;\n            }\n            const mtlsOpts = {\n                cert: config.cert,\n                key: config.key,\n                ca: config.ca\n            };\n            return Object.assign({}, options, mtlsOpts);\n        }\n    };\n}\nlet actualGlobal = {};\nif (typeof globalThis !== \"undefined\") {\n    actualGlobal = globalThis;\n} else if (false) {} else if (typeof global !== \"undefined\") {\n    actualGlobal = global;\n} else if (typeof self !== \"undefined\") {\n    actualGlobal = self;\n}\nvar global$1 = actualGlobal;\nfunction observable(opts = {}) {\n    const Observable = // eslint-disable-next-line @typescript-eslint/no-explicit-any -- @TODO consider dropping checking for a global Observable since it's not on a standards track\n    opts.implementation || global$1.Observable;\n    if (!Observable) {\n        throw new Error(\"`Observable` is not available in global scope, and no implementation was passed\");\n    }\n    return {\n        onReturn: (channels, context)=>new Observable((observer)=>{\n                channels.error.subscribe((err)=>observer.error(err));\n                channels.progress.subscribe((event)=>observer.next(Object.assign({\n                        type: \"progress\"\n                    }, event)));\n                channels.response.subscribe((response)=>{\n                    observer.next(Object.assign({\n                        type: \"response\"\n                    }, response));\n                    observer.complete();\n                });\n                channels.request.publish(context);\n                return ()=>channels.abort.publish();\n            })\n    };\n}\nfunction normalizer(stage) {\n    return (prog)=>({\n            stage,\n            percent: prog.percentage,\n            total: prog.length,\n            loaded: prog.transferred,\n            lengthComputable: !(prog.length === 0 && prog.percentage === 0)\n        });\n}\nfunction progress() {\n    return {\n        onHeaders: (response, evt)=>{\n            const _progress = progressStream__default.default({\n                time: 16\n            });\n            const normalize = normalizer(\"download\");\n            const contentLength = response.headers[\"content-length\"];\n            const length = contentLength ? Number(contentLength) : 0;\n            if (!isNaN(length) && length > 0) {\n                _progress.setLength(length);\n            }\n            _progress.on(\"progress\", (prog)=>evt.context.channels.progress.publish(normalize(prog)));\n            return response.pipe(_progress);\n        },\n        onRequest: (evt)=>{\n            if (!evt.progress) {\n                return;\n            }\n            const normalize = normalizer(\"upload\");\n            evt.progress.on(\"progress\", (prog)=>evt.context.channels.progress.publish(normalize(prog)));\n        }\n    };\n}\nconst promise = (options = {})=>{\n    const PromiseImplementation = options.implementation || Promise;\n    if (!PromiseImplementation) {\n        throw new Error(\"`Promise` is not available in global scope, and no implementation was passed\");\n    }\n    return {\n        onReturn: (channels, context)=>new PromiseImplementation((resolve, reject)=>{\n                const cancel = context.options.cancelToken;\n                if (cancel) {\n                    cancel.promise.then((reason)=>{\n                        channels.abort.publish(reason);\n                        reject(reason);\n                    });\n                }\n                channels.error.subscribe(reject);\n                channels.response.subscribe((response)=>{\n                    resolve(options.onlyBody ? response.body : response);\n                });\n                setTimeout(()=>{\n                    try {\n                        channels.request.publish(context);\n                    } catch (err) {\n                        reject(err);\n                    }\n                }, 0);\n            })\n    };\n};\nclass Cancel {\n    constructor(message){\n        this.__CANCEL__ = true;\n        this.message = message;\n    }\n    toString() {\n        return \"Cancel\".concat(this.message ? \": \".concat(this.message) : \"\");\n    }\n}\nconst _CancelToken = class _CancelToken {\n    constructor(executor){\n        if (typeof executor !== \"function\") {\n            throw new TypeError(\"executor must be a function.\");\n        }\n        let resolvePromise = null;\n        this.promise = new Promise((resolve)=>{\n            resolvePromise = resolve;\n        });\n        executor((message)=>{\n            if (this.reason) {\n                return;\n            }\n            this.reason = new Cancel(message);\n            resolvePromise(this.reason);\n        });\n    }\n};\n_CancelToken.source = ()=>{\n    let cancel;\n    const token = new _CancelToken((can)=>{\n        cancel = can;\n    });\n    return {\n        token,\n        cancel\n    };\n};\nlet CancelToken = _CancelToken;\nconst isCancel = (value)=>!!(value && (value == null ? void 0 : value.__CANCEL__));\npromise.Cancel = Cancel;\npromise.CancelToken = CancelToken;\npromise.isCancel = isCancel;\nfunction proxy(_proxy) {\n    if (_proxy !== false && (!_proxy || !_proxy.host)) {\n        throw new Error(\"Proxy middleware takes an object of host, port and auth properties\");\n    }\n    return {\n        processOptions: (options)=>Object.assign({\n                proxy: _proxy\n            }, options)\n    };\n}\nvar defaultShouldRetry = (err, num, options)=>{\n    if (options.method !== \"GET\" && options.method !== \"HEAD\") {\n        return false;\n    }\n    if (err.response && err.response.statusCode) {\n        return false;\n    }\n    return allowed__default.default(err);\n};\nconst isStream = (stream)=>stream !== null && typeof stream === \"object\" && typeof stream.pipe === \"function\";\nvar sharedRetry = (opts)=>{\n    const maxRetries = opts.maxRetries || 5;\n    const retryDelay = opts.retryDelay || getRetryDelay;\n    const allowRetry = opts.shouldRetry;\n    return {\n        onError: (err, context)=>{\n            const options = context.options;\n            const max = options.maxRetries || maxRetries;\n            const shouldRetry = options.shouldRetry || allowRetry;\n            const attemptNumber = options.attemptNumber || 0;\n            if (isStream(options.body)) {\n                return err;\n            }\n            if (!shouldRetry(err, attemptNumber, options) || attemptNumber >= max) {\n                return err;\n            }\n            const newContext = Object.assign({}, context, {\n                options: Object.assign({}, options, {\n                    attemptNumber: attemptNumber + 1\n                })\n            });\n            setTimeout(()=>context.channels.request.publish(newContext), retryDelay(attemptNumber));\n            return null;\n        }\n    };\n};\nfunction getRetryDelay(attemptNum) {\n    return 100 * Math.pow(2, attemptNum) + Math.random() * 100;\n}\nconst retry = (opts = {})=>sharedRetry({\n        shouldRetry: defaultShouldRetry,\n        ...opts\n    });\nretry.shouldRetry = defaultShouldRetry;\nfunction encode(data) {\n    const query = new URLSearchParams();\n    const nest = (name, _value)=>{\n        const value = _value instanceof Set ? Array.from(_value) : _value;\n        if (Array.isArray(value)) {\n            if (value.length) {\n                for(const index in value){\n                    nest(\"\".concat(name, \"[\").concat(index, \"]\"), value[index]);\n                }\n            } else {\n                query.append(\"\".concat(name, \"[]\"), \"\");\n            }\n        } else if (typeof value === \"object\" && value !== null) {\n            for (const [key, obj] of Object.entries(value)){\n                nest(\"\".concat(name, \"[\").concat(key, \"]\"), obj);\n            }\n        } else {\n            query.append(name, value);\n        }\n    };\n    for (const [key, value] of Object.entries(data)){\n        nest(key, value);\n    }\n    return query.toString();\n}\nfunction urlEncoded() {\n    return {\n        processOptions: (options)=>{\n            const body = options.body;\n            if (!body) {\n                return options;\n            }\n            const isStream = typeof body.pipe === \"function\";\n            const shouldSerialize = !isStream && !isBuffer(body) && isPlainObject.isPlainObject(body);\n            if (!shouldSerialize) {\n                return options;\n            }\n            return {\n                ...options,\n                body: encode(options.body),\n                headers: {\n                    ...options.headers,\n                    \"Content-Type\": \"application/x-www-form-urlencoded\"\n                }\n            };\n        }\n    };\n}\nfunction buildKeepAlive(agent) {\n    return function keepAlive(config = {}) {\n        const ms = config.ms || 1e3;\n        const maxFree = config.maxFree || 256;\n        const agentOptions = {\n            keepAlive: true,\n            keepAliveMsecs: ms,\n            maxFreeSockets: maxFree\n        };\n        return agent(agentOptions);\n    };\n}\nconst keepAlive = buildKeepAlive(agent);\nexports.processOptions = defaultOptionsValidator.processOptions;\nexports.validateOptions = defaultOptionsValidator.validateOptions;\nexports.Cancel = Cancel;\nexports.CancelToken = CancelToken;\nexports.agent = agent;\nexports.base = base;\nexports.debug = debug;\nexports.headers = headers;\nexports.httpErrors = httpErrors;\nexports.injectResponse = injectResponse;\nexports.jsonRequest = jsonRequest;\nexports.jsonResponse = jsonResponse;\nexports.keepAlive = keepAlive;\nexports.mtls = mtls;\nexports.observable = observable;\nexports.progress = progress;\nexports.promise = promise;\nexports.proxy = proxy;\nexports.retry = retry;\nexports.urlEncoded = urlEncoded; //# sourceMappingURL=middleware.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvbWlkZGxld2FyZS5janMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFFN0QsSUFBSUMsT0FBT0MsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUUsVUFBVUYsbUJBQU9BLENBQUM7QUFDdEIsSUFBSUcsMEJBQTBCSCxtQkFBT0EsQ0FBQztBQUN0QyxJQUFJSSxnQkFBZ0JKLG1CQUFPQSxDQUFDO0FBQzVCLElBQUlLLGlCQUFpQkwsbUJBQU9BLENBQUM7QUFDN0IsSUFBSU0sVUFBVU4sbUJBQU9BLENBQUM7QUFFdEIsU0FBU08sc0JBQXVCQyxDQUFDO0lBQUksT0FBT0EsS0FBSyxPQUFPQSxNQUFNLFlBQVksYUFBYUEsSUFBSUEsSUFBSTtRQUFFQyxTQUFTRDtJQUFFO0FBQUc7QUFFL0csSUFBSUUsbUJBQW1CLFdBQVcsR0FBRUgsc0JBQXNCTDtBQUMxRCxJQUFJUywwQkFBMEIsV0FBVyxHQUFFSixzQkFBc0JGO0FBQ2pFLElBQUlPLG1CQUFtQixXQUFXLEdBQUVMLHNCQUFzQkQ7QUFFMUQsTUFBTU8sZUFBZTtBQUNyQixTQUFTQyxNQUFNQyxJQUFJO0lBQ2pCLE1BQU1DLFlBQVksSUFBSWpCLEtBQUtrQixLQUFLLENBQUNGO0lBQ2pDLE1BQU1HLGFBQWEsSUFBSWpCLE1BQU1nQixLQUFLLENBQUNGO0lBQ25DLE1BQU1JLFNBQVM7UUFBRXBCLE1BQU1pQjtRQUFXZixPQUFPaUI7SUFBVztJQUNwRCxPQUFPO1FBQ0xFLGlCQUFpQixDQUFDQztZQUNoQixJQUFJQSxRQUFRUCxLQUFLLEVBQUU7Z0JBQ2pCLE9BQU9PO1lBQ1Q7WUFDQSxJQUFJQSxRQUFRQyxZQUFZLEdBQUcsR0FBRztnQkFDNUIsT0FBTztvQkFBRSxHQUFHRCxPQUFPO29CQUFFRjtnQkFBTztZQUM5QjtZQUNBLE1BQU1JLFVBQVVWLGFB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akJoTCxtQkFBbUIsR0FBR3lMO0FBQ3RCekwsYUFBYSxHQUFHaUI7QUFDaEJqQixZQUFZLEdBQUdnQztBQUNmaEMsYUFBYSxHQUFHb0Q7QUFDaEJwRCxlQUFlLEdBQUdnRTtBQUNsQmhFLGtCQUFrQixHQUFHa0c7QUFDckJsRyxzQkFBc0IsR0FBR29HO0FBQ3pCcEcsbUJBQW1CLEdBQUc2RztBQUN0QjdHLG9CQUFvQixHQUFHbUg7QUFDdkJuSCxpQkFBaUIsR0FBRzZOO0FBQ3BCN04sWUFBWSxHQUFHeUg7QUFDZnpILGtCQUFrQixHQUFHb0k7QUFDckJwSSxnQkFBZ0IsR0FBRzRJO0FBQ25CNUksZUFBZSxHQUFHcUs7QUFDbEJySyxhQUFhLEdBQUcyTDtBQUNoQjNMLGFBQWEsR0FBRzhNO0FBQ2hCOU0sa0JBQWtCLEdBQUcyTixZQUNyQix1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYmMvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvbWlkZGxld2FyZS5janM/MGVhNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xudmFyIGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbnZhciBkZWJ1Z0l0ID0gcmVxdWlyZSgnZGVidWcnKTtcbnZhciBkZWZhdWx0T3B0aW9uc1ZhbGlkYXRvciA9IHJlcXVpcmUoJy4vX2NodW5rcy9kZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci1uMXQ4emtuQi5janMnKTtcbnZhciBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnaXMtcGxhaW4tb2JqZWN0Jyk7XG52YXIgcHJvZ3Jlc3NTdHJlYW0gPSByZXF1aXJlKCdwcm9ncmVzcy1zdHJlYW0nKTtcbnZhciBhbGxvd2VkID0gcmVxdWlyZSgnaXMtcmV0cnktYWxsb3dlZCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRDb21wYXQgKGUpIHsgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHsgZGVmYXVsdDogZSB9OyB9XG5cbnZhciBkZWJ1Z0l0X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdENvbXBhdChkZWJ1Z0l0KTtcbnZhciBwcm9ncmVzc1N0cmVhbV9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRDb21wYXQocHJvZ3Jlc3NTdHJlYW0pO1xudmFyIGFsbG93ZWRfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0Q29tcGF0KGFsbG93ZWQpO1xuXG5jb25zdCBpc0h0dHBzUHJvdG8gPSAvXmh0dHBzOi9pO1xuZnVuY3Rpb24gYWdlbnQob3B0cykge1xuICBjb25zdCBodHRwQWdlbnQgPSBuZXcgaHR0cC5BZ2VudChvcHRzKTtcbiAgY29uc3QgaHR0cHNBZ2VudCA9IG5ldyBodHRwcy5BZ2VudChvcHRzKTtcbiAgY29uc3QgYWdlbnRzID0geyBodHRwOiBodHRwQWdlbnQsIGh0dHBzOiBodHRwc0FnZW50IH07XG4gIHJldHVybiB7XG4gICAgZmluYWxpemVPcHRpb25zOiAob3B0aW9ucykgPT4ge1xuICAgICAgaWYgKG9wdGlvbnMuYWdlbnQpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5tYXhSZWRpcmVjdHMgPiAwKSB7XG4gICAgICAgIHJldHVybiB7IC4uLm9wdGlvbnMsIGFnZW50cyB9O1xuICAgICAgfVxuICAgICAgY29uc3QgaXNIdHRwcyA9IGlzSHR0cHNQcm90by50ZXN0KG9wdGlvbnMuaHJlZiB8fCBvcHRpb25zLnByb3RvY29sKTtcbiAgICAgIHJldHVybiB7IC4uLm9wdGlvbnMsIGFnZW50OiBpc0h0dHBzID8gaHR0cHNBZ2VudCA6IGh0dHBBZ2VudCB9O1xuICAgIH1cbiAgfTtcbn1cblxuY29uc3QgbGVhZGluZ1NsYXNoID0gL15cXC8vO1xuY29uc3QgdHJhaWxpbmdTbGFzaCA9IC9cXC8kLztcbmZ1bmN0aW9uIGJhc2UoYmFzZVVybCkge1xuICBjb25zdCBiYXNlVXJpID0gYmFzZVVybC5yZXBsYWNlKHRyYWlsaW5nU2xhc2gsIFwiXCIpO1xuICByZXR1cm4ge1xuICAgIHByb2Nlc3NPcHRpb25zOiAob3B0aW9ucykgPT4ge1xuICAgICAgaWYgKC9eaHR0cHM/OlxcL1xcLy9pLnRlc3Qob3B0aW9ucy51cmwpKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgfVxuICAgICAgY29uc3QgdXJsID0gW2Jhc2VVcmksIG9wdGlvbnMudXJsLnJlcGxhY2UobGVhZGluZ1NsYXNoLCBcIlwiKV0uam9pbihcIi9cIik7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyB1cmwgfSk7XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBTRU5TSVRJVkVfSEVBREVSUyA9IFtcImNvb2tpZVwiLCBcImF1dGhvcml6YXRpb25cIl07XG5jb25zdCBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuY29uc3QgcmVkYWN0S2V5cyA9IChzb3VyY2UsIHJlZGFjdGVkKSA9PiB7XG4gIGNvbnN0IHRhcmdldCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcbiAgICBpZiAoaGFzT3duLmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHJlZGFjdGVkLmluZGV4T2Yoa2V5LnRvTG93ZXJDYXNlKCkpID4gLTEgPyBcIjxyZWRhY3RlZD5cIiA6IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbmZ1bmN0aW9uIGRlYnVnKG9wdHMgPSB7fSkge1xuICBjb25zdCB2ZXJib3NlID0gb3B0cy52ZXJib3NlO1xuICBjb25zdCBuYW1lc3BhY2UgPSBvcHRzLm5hbWVzcGFjZSB8fCBcImdldC1pdFwiO1xuICBjb25zdCBkZWZhdWx0TG9nZ2VyID0gZGVidWdJdF9fZGVmYXVsdC5kZWZhdWx0KG5hbWVzcGFjZSk7XG4gIGNvbnN0IGxvZyA9IG9wdHMubG9nIHx8IGRlZmF1bHRMb2dnZXI7XG4gIGNvbnN0IHNob3J0Q2lyY3VpdCA9IGxvZyA9PT0gZGVmYXVsdExvZ2dlciAmJiAhZGVidWdJdF9fZGVmYXVsdC5kZWZhdWx0LmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgbGV0IHJlcXVlc3RJZCA9IDA7XG4gIHJldHVybiB7XG4gICAgcHJvY2Vzc09wdGlvbnM6IChvcHRpb25zKSA9PiB7XG4gICAgICBvcHRpb25zLmRlYnVnID0gbG9nO1xuICAgICAgb3B0aW9ucy5yZXF1ZXN0SWQgPSBvcHRpb25zLnJlcXVlc3RJZCB8fCArK3JlcXVlc3RJZDtcbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH0sXG4gICAgb25SZXF1ZXN0OiAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChzaG9ydENpcmN1aXQgfHwgIWV2ZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBldmVudC5vcHRpb25zO1xuICAgICAgbG9nKFwiWyVzXSBIVFRQICVzICVzXCIsIG9wdGlvbnMucmVxdWVzdElkLCBvcHRpb25zLm1ldGhvZCwgb3B0aW9ucy51cmwpO1xuICAgICAgaWYgKHZlcmJvc2UgJiYgb3B0aW9ucy5ib2R5ICYmIHR5cGVvZiBvcHRpb25zLmJvZHkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbG9nKFwiWyVzXSBSZXF1ZXN0IGJvZHk6ICVzXCIsIG9wdGlvbnMucmVxdWVzdElkLCBvcHRpb25zLmJvZHkpO1xuICAgICAgfVxuICAgICAgaWYgKHZlcmJvc2UgJiYgb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBvcHRzLnJlZGFjdFNlbnNpdGl2ZUhlYWRlcnMgPT09IGZhbHNlID8gb3B0aW9ucy5oZWFkZXJzIDogcmVkYWN0S2V5cyhvcHRpb25zLmhlYWRlcnMsIFNFTlNJVElWRV9IRUFERVJTKTtcbiAgICAgICAgbG9nKFwiWyVzXSBSZXF1ZXN0IGhlYWRlcnM6ICVzXCIsIG9wdGlvbnMucmVxdWVzdElkLCBKU09OLnN0cmluZ2lmeShoZWFkZXJzLCBudWxsLCAyKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfSxcbiAgICBvblJlc3BvbnNlOiAocmVzLCBjb250ZXh0KSA9PiB7XG4gICAgICBpZiAoc2hvcnRDaXJjdWl0IHx8ICFyZXMpIHtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlcUlkID0gY29udGV4dC5vcHRpb25zLnJlcXVlc3RJZDtcbiAgICAgIGxvZyhcIlslc10gUmVzcG9uc2UgY29kZTogJXMgJXNcIiwgcmVxSWQsIHJlcy5zdGF0dXNDb2RlLCByZXMuc3RhdHVzTWVzc2FnZSk7XG4gICAgICBpZiAodmVyYm9zZSAmJiByZXMuYm9keSkge1xuICAgICAgICBsb2coXCJbJXNdIFJlc3BvbnNlIGJvZHk6ICVzXCIsIHJlcUlkLCBzdHJpbmdpZnlCb2R5KHJlcykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIG9uRXJyb3I6IChlcnIsIGNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IHJlcUlkID0gY29udGV4dC5vcHRpb25zLnJlcXVlc3RJZDtcbiAgICAgIGlmICghZXJyKSB7XG4gICAgICAgIGxvZyhcIlslc10gRXJyb3IgZW5jb3VudGVyZWQsIGJ1dCBoYW5kbGVkIGJ5IGFuIGVhcmxpZXIgbWlkZGxld2FyZVwiLCByZXFJZCk7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgICB9XG4gICAgICBsb2coXCJbJXNdIEVSUk9SOiAlc1wiLCByZXFJZCwgZXJyLm1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlCb2R5KHJlcykge1xuICBjb25zdCBjb250ZW50VHlwZSA9IChyZXMuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBpc0pzb24gPSBjb250ZW50VHlwZS5pbmRleE9mKFwiYXBwbGljYXRpb24vanNvblwiKSAhPT0gLTE7XG4gIHJldHVybiBpc0pzb24gPyB0cnlGb3JtYXQocmVzLmJvZHkpIDogcmVzLmJvZHk7XG59XG5mdW5jdGlvbiB0cnlGb3JtYXQoYm9keSkge1xuICB0cnkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHR5cGVvZiBib2R5ID09PSBcInN0cmluZ1wiID8gSlNPTi5wYXJzZShib2R5KSA6IGJvZHk7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBhcnNlZCwgbnVsbCwgMik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBib2R5O1xuICB9XG59XG5cbmZ1bmN0aW9uIGhlYWRlcnMoX2hlYWRlcnMsIG9wdHMgPSB7fSkge1xuICByZXR1cm4ge1xuICAgIHByb2Nlc3NPcHRpb25zOiAob3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBvcHRpb25zLmhlYWRlcnMgfHwge307XG4gICAgICBvcHRpb25zLmhlYWRlcnMgPSBvcHRzLm92ZXJyaWRlID8gT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcsIF9oZWFkZXJzKSA6IE9iamVjdC5hc3NpZ24oe30sIF9oZWFkZXJzLCBleGlzdGluZyk7XG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gIH07XG59XG5cbmNsYXNzIEh0dHBFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocmVzLCBjdHgpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IHRydW5jYXRlZFVybCA9IHJlcy51cmwubGVuZ3RoID4gNDAwID8gXCJcIi5jb25jYXQocmVzLnVybC5zbGljZSgwLCAzOTkpLCBcIlxcdTIwMjZcIikgOiByZXMudXJsO1xuICAgIGxldCBtc2cgPSBcIlwiLmNvbmNhdChyZXMubWV0aG9kLCBcIi1yZXF1ZXN0IHRvIFwiKS5jb25jYXQodHJ1bmNhdGVkVXJsLCBcIiByZXN1bHRlZCBpbiBcIik7XG4gICAgbXNnICs9IFwiSFRUUCBcIi5jb25jYXQocmVzLnN0YXR1c0NvZGUsIFwiIFwiKS5jb25jYXQocmVzLnN0YXR1c01lc3NhZ2UpO1xuICAgIHRoaXMubWVzc2FnZSA9IG1zZy50cmltKCk7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlcztcbiAgICB0aGlzLnJlcXVlc3QgPSBjdHgub3B0aW9ucztcbiAgfVxufVxuZnVuY3Rpb24gaHR0cEVycm9ycygpIHtcbiAgcmV0dXJuIHtcbiAgICBvblJlc3BvbnNlOiAocmVzLCBjdHgpID0+IHtcbiAgICAgIGNvbnN0IGlzSHR0cEVycm9yID0gcmVzLnN0YXR1c0NvZGUgPj0gNDAwO1xuICAgICAgaWYgKCFpc0h0dHBFcnJvcikge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEh0dHBFcnJvcihyZXMsIGN0eCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbmplY3RSZXNwb25zZShvcHRzID0ge30pIHtcbiAgaWYgKHR5cGVvZiBvcHRzLmluamVjdCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYGluamVjdFJlc3BvbnNlYCBtaWRkbGV3YXJlIHJlcXVpcmVzIGEgYGluamVjdGAgZnVuY3Rpb25cIik7XG4gIH1cbiAgY29uc3QgaW5qZWN0ID0gZnVuY3Rpb24gaW5qZWN0MihwcmV2VmFsdWUsIGV2ZW50KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBvcHRzLmluamVjdChldmVudCwgcHJldlZhbHVlKTtcbiAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gcHJldlZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBvcHRpb25zID0gZXZlbnQuY29udGV4dC5vcHRpb25zO1xuICAgIHJldHVybiB7XG4gICAgICBib2R5OiBcIlwiLFxuICAgICAgdXJsOiBvcHRpb25zLnVybCxcbiAgICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICBoZWFkZXJzOiB7fSxcbiAgICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICAgIHN0YXR1c01lc3NhZ2U6IFwiT0tcIixcbiAgICAgIC4uLnJlc3BvbnNlXG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIHsgaW50ZXJjZXB0UmVxdWVzdDogaW5qZWN0IH07XG59XG5cbmNvbnN0IGlzQnVmZmVyID0gdHlwZW9mIEJ1ZmZlciA9PT0gXCJ1bmRlZmluZWRcIiA/ICgpID0+IGZhbHNlIDogKG9iaikgPT4gQnVmZmVyLmlzQnVmZmVyKG9iaik7XG5cbmNvbnN0IHNlcmlhbGl6ZVR5cGVzID0gW1wiYm9vbGVhblwiLCBcInN0cmluZ1wiLCBcIm51bWJlclwiXTtcbmZ1bmN0aW9uIGpzb25SZXF1ZXN0KCkge1xuICByZXR1cm4ge1xuICAgIHByb2Nlc3NPcHRpb25zOiAob3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgYm9keSA9IG9wdGlvbnMuYm9keTtcbiAgICAgIGlmICghYm9keSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzU3RyZWFtID0gdHlwZW9mIGJvZHkucGlwZSA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgY29uc3Qgc2hvdWxkU2VyaWFsaXplID0gIWlzU3RyZWFtICYmICFpc0J1ZmZlcihib2R5KSAmJiAoc2VyaWFsaXplVHlwZXMuaW5kZXhPZih0eXBlb2YgYm9keSkgIT09IC0xIHx8IEFycmF5LmlzQXJyYXkoYm9keSkgfHwgaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KGJvZHkpKTtcbiAgICAgIGlmICghc2hvdWxkU2VyaWFsaXplKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5ib2R5KSxcbiAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5oZWFkZXJzLCB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24ganNvblJlc3BvbnNlKG9wdHMpIHtcbiAgcmV0dXJuIHtcbiAgICBvblJlc3BvbnNlOiAocmVzcG9uc2UpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSB8fCBcIlwiO1xuICAgICAgY29uc3Qgc2hvdWxkRGVjb2RlID0gb3B0cyAmJiBvcHRzLmZvcmNlIHx8IGNvbnRlbnRUeXBlLmluZGV4T2YoXCJhcHBsaWNhdGlvbi9qc29uXCIpICE9PSAtMTtcbiAgICAgIGlmICghcmVzcG9uc2UuYm9keSB8fCAhY29udGVudFR5cGUgfHwgIXNob3VsZERlY29kZSkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcmVzcG9uc2UsIHsgYm9keTogdHJ5UGFyc2UocmVzcG9uc2UuYm9keSkgfSk7XG4gICAgfSxcbiAgICBwcm9jZXNzT3B0aW9uczogKG9wdGlvbnMpID0+IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oeyBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiIH0sIG9wdGlvbnMuaGVhZGVycylcbiAgICB9KVxuICB9O1xuICBmdW5jdGlvbiB0cnlQYXJzZShib2R5KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGJvZHkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZXJyLm1lc3NhZ2UgPSBcIkZhaWxlZCB0byBwYXJzZWQgcmVzcG9uc2UgYm9keSBhcyBKU09OOiBcIi5jb25jYXQoZXJyLm1lc3NhZ2UpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0Jyb3dzZXJPcHRpb25zKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMgIT09IG51bGwgJiYgIShcInByb3RvY29sXCIgaW4gb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIG10bHMoY29uZmlnID0ge30pIHtcbiAgaWYgKCFjb25maWcuY2EpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmVkIG10bHMgb3B0aW9uIFwiY2FcIiBpcyBtaXNzaW5nJyk7XG4gIH1cbiAgaWYgKCFjb25maWcuY2VydCkge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVxdWlyZWQgbXRscyBvcHRpb24gXCJjZXJ0XCIgaXMgbWlzc2luZycpO1xuICB9XG4gIGlmICghY29uZmlnLmtleSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVxdWlyZWQgbXRscyBvcHRpb24gXCJrZXlcIiBpcyBtaXNzaW5nJyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmaW5hbGl6ZU9wdGlvbnM6IChvcHRpb25zKSA9PiB7XG4gICAgICBpZiAoaXNCcm93c2VyT3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgIH1cbiAgICAgIGNvbnN0IG10bHNPcHRzID0ge1xuICAgICAgICBjZXJ0OiBjb25maWcuY2VydCxcbiAgICAgICAga2V5OiBjb25maWcua2V5LFxuICAgICAgICBjYTogY29uZmlnLmNhXG4gICAgICB9O1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIG10bHNPcHRzKTtcbiAgICB9XG4gIH07XG59XG5cbmxldCBhY3R1YWxHbG9iYWwgPSB7fTtcbmlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICBhY3R1YWxHbG9iYWwgPSBnbG9iYWxUaGlzO1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIGFjdHVhbEdsb2JhbCA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICBhY3R1YWxHbG9iYWwgPSBnbG9iYWw7XG59IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIGFjdHVhbEdsb2JhbCA9IHNlbGY7XG59XG52YXIgZ2xvYmFsJDEgPSBhY3R1YWxHbG9iYWw7XG5cbmZ1bmN0aW9uIG9ic2VydmFibGUob3B0cyA9IHt9KSB7XG4gIGNvbnN0IE9ic2VydmFibGUgPSAoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgLS0gQFRPRE8gY29uc2lkZXIgZHJvcHBpbmcgY2hlY2tpbmcgZm9yIGEgZ2xvYmFsIE9ic2VydmFibGUgc2luY2UgaXQncyBub3Qgb24gYSBzdGFuZGFyZHMgdHJhY2tcbiAgICBvcHRzLmltcGxlbWVudGF0aW9uIHx8IGdsb2JhbCQxLk9ic2VydmFibGVcbiAgKTtcbiAgaWYgKCFPYnNlcnZhYmxlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJgT2JzZXJ2YWJsZWAgaXMgbm90IGF2YWlsYWJsZSBpbiBnbG9iYWwgc2NvcGUsIGFuZCBubyBpbXBsZW1lbnRhdGlvbiB3YXMgcGFzc2VkXCJcbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgb25SZXR1cm46IChjaGFubmVscywgY29udGV4dCkgPT4gbmV3IE9ic2VydmFibGUoKG9ic2VydmVyKSA9PiB7XG4gICAgICBjaGFubmVscy5lcnJvci5zdWJzY3JpYmUoKGVycikgPT4gb2JzZXJ2ZXIuZXJyb3IoZXJyKSk7XG4gICAgICBjaGFubmVscy5wcm9ncmVzcy5zdWJzY3JpYmUoXG4gICAgICAgIChldmVudCkgPT4gb2JzZXJ2ZXIubmV4dChPYmplY3QuYXNzaWduKHsgdHlwZTogXCJwcm9ncmVzc1wiIH0sIGV2ZW50KSlcbiAgICAgICk7XG4gICAgICBjaGFubmVscy5yZXNwb25zZS5zdWJzY3JpYmUoKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIG9ic2VydmVyLm5leHQoT2JqZWN0LmFzc2lnbih7IHR5cGU6IFwicmVzcG9uc2VcIiB9LCByZXNwb25zZSkpO1xuICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgfSk7XG4gICAgICBjaGFubmVscy5yZXF1ZXN0LnB1Ymxpc2goY29udGV4dCk7XG4gICAgICByZXR1cm4gKCkgPT4gY2hhbm5lbHMuYWJvcnQucHVibGlzaCgpO1xuICAgIH0pXG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZXIoc3RhZ2UpIHtcbiAgcmV0dXJuIChwcm9nKSA9PiAoe1xuICAgIHN0YWdlLFxuICAgIHBlcmNlbnQ6IHByb2cucGVyY2VudGFnZSxcbiAgICB0b3RhbDogcHJvZy5sZW5ndGgsXG4gICAgbG9hZGVkOiBwcm9nLnRyYW5zZmVycmVkLFxuICAgIGxlbmd0aENvbXB1dGFibGU6ICEocHJvZy5sZW5ndGggPT09IDAgJiYgcHJvZy5wZXJjZW50YWdlID09PSAwKVxuICB9KTtcbn1cbmZ1bmN0aW9uIHByb2dyZXNzKCkge1xuICByZXR1cm4ge1xuICAgIG9uSGVhZGVyczogKHJlc3BvbnNlLCBldnQpID0+IHtcbiAgICAgIGNvbnN0IF9wcm9ncmVzcyA9IHByb2dyZXNzU3RyZWFtX19kZWZhdWx0LmRlZmF1bHQoeyB0aW1lOiAxNiB9KTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZSA9IG5vcm1hbGl6ZXIoXCJkb3dubG9hZFwiKTtcbiAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSByZXNwb25zZS5oZWFkZXJzW1wiY29udGVudC1sZW5ndGhcIl07XG4gICAgICBjb25zdCBsZW5ndGggPSBjb250ZW50TGVuZ3RoID8gTnVtYmVyKGNvbnRlbnRMZW5ndGgpIDogMDtcbiAgICAgIGlmICghaXNOYU4obGVuZ3RoKSAmJiBsZW5ndGggPiAwKSB7XG4gICAgICAgIF9wcm9ncmVzcy5zZXRMZW5ndGgobGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIF9wcm9ncmVzcy5vbihcInByb2dyZXNzXCIsIChwcm9nKSA9PiBldnQuY29udGV4dC5jaGFubmVscy5wcm9ncmVzcy5wdWJsaXNoKG5vcm1hbGl6ZShwcm9nKSkpO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLnBpcGUoX3Byb2dyZXNzKTtcbiAgICB9LFxuICAgIG9uUmVxdWVzdDogKGV2dCkgPT4ge1xuICAgICAgaWYgKCFldnQucHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgbm9ybWFsaXplID0gbm9ybWFsaXplcihcInVwbG9hZFwiKTtcbiAgICAgIGV2dC5wcm9ncmVzcy5vbihcbiAgICAgICAgXCJwcm9ncmVzc1wiLFxuICAgICAgICAocHJvZykgPT4gZXZ0LmNvbnRleHQuY2hhbm5lbHMucHJvZ3Jlc3MucHVibGlzaChub3JtYWxpemUocHJvZykpXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cblxuY29uc3QgcHJvbWlzZSA9IChvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgUHJvbWlzZUltcGxlbWVudGF0aW9uID0gb3B0aW9ucy5pbXBsZW1lbnRhdGlvbiB8fCBQcm9taXNlO1xuICBpZiAoIVByb21pc2VJbXBsZW1lbnRhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImBQcm9taXNlYCBpcyBub3QgYXZhaWxhYmxlIGluIGdsb2JhbCBzY29wZSwgYW5kIG5vIGltcGxlbWVudGF0aW9uIHdhcyBwYXNzZWRcIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBvblJldHVybjogKGNoYW5uZWxzLCBjb250ZXh0KSA9PiBuZXcgUHJvbWlzZUltcGxlbWVudGF0aW9uKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGNhbmNlbCA9IGNvbnRleHQub3B0aW9ucy5jYW5jZWxUb2tlbjtcbiAgICAgIGlmIChjYW5jZWwpIHtcbiAgICAgICAgY2FuY2VsLnByb21pc2UudGhlbigocmVhc29uKSA9PiB7XG4gICAgICAgICAgY2hhbm5lbHMuYWJvcnQucHVibGlzaChyZWFzb24pO1xuICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNoYW5uZWxzLmVycm9yLnN1YnNjcmliZShyZWplY3QpO1xuICAgICAgY2hhbm5lbHMucmVzcG9uc2Uuc3Vic2NyaWJlKChyZXNwb25zZSkgPT4ge1xuICAgICAgICByZXNvbHZlKG9wdGlvbnMub25seUJvZHkgPyByZXNwb25zZS5ib2R5IDogcmVzcG9uc2UpO1xuICAgICAgfSk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjaGFubmVscy5yZXF1ZXN0LnB1Ymxpc2goY29udGV4dCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICB9LCAwKTtcbiAgICB9KVxuICB9O1xufTtcbmNsYXNzIENhbmNlbCB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLl9fQ0FOQ0VMX18gPSB0cnVlO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwiQ2FuY2VsXCIuY29uY2F0KHRoaXMubWVzc2FnZSA/IFwiOiBcIi5jb25jYXQodGhpcy5tZXNzYWdlKSA6IFwiXCIpO1xuICB9XG59XG5jb25zdCBfQ2FuY2VsVG9rZW4gPSBjbGFzcyBfQ2FuY2VsVG9rZW4ge1xuICBjb25zdHJ1Y3RvcihleGVjdXRvcikge1xuICAgIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImV4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuICAgIGxldCByZXNvbHZlUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgICB9KTtcbiAgICBleGVjdXRvcigobWVzc2FnZSkgPT4ge1xuICAgICAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVhc29uID0gbmV3IENhbmNlbChtZXNzYWdlKTtcbiAgICAgIHJlc29sdmVQcm9taXNlKHRoaXMucmVhc29uKTtcbiAgICB9KTtcbiAgfVxufTtcbl9DYW5jZWxUb2tlbi5zb3VyY2UgPSAoKSA9PiB7XG4gIGxldCBjYW5jZWw7XG4gIGNvbnN0IHRva2VuID0gbmV3IF9DYW5jZWxUb2tlbigoY2FuKSA9PiB7XG4gICAgY2FuY2VsID0gY2FuO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB0b2tlbixcbiAgICBjYW5jZWxcbiAgfTtcbn07XG5sZXQgQ2FuY2VsVG9rZW4gPSBfQ2FuY2VsVG9rZW47XG5jb25zdCBpc0NhbmNlbCA9ICh2YWx1ZSkgPT4gISEodmFsdWUgJiYgKHZhbHVlID09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZS5fX0NBTkNFTF9fKSk7XG5wcm9taXNlLkNhbmNlbCA9IENhbmNlbDtcbnByb21pc2UuQ2FuY2VsVG9rZW4gPSBDYW5jZWxUb2tlbjtcbnByb21pc2UuaXNDYW5jZWwgPSBpc0NhbmNlbDtcblxuZnVuY3Rpb24gcHJveHkoX3Byb3h5KSB7XG4gIGlmIChfcHJveHkgIT09IGZhbHNlICYmICghX3Byb3h5IHx8ICFfcHJveHkuaG9zdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm94eSBtaWRkbGV3YXJlIHRha2VzIGFuIG9iamVjdCBvZiBob3N0LCBwb3J0IGFuZCBhdXRoIHByb3BlcnRpZXNcIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwcm9jZXNzT3B0aW9uczogKG9wdGlvbnMpID0+IE9iamVjdC5hc3NpZ24oeyBwcm94eTogX3Byb3h5IH0sIG9wdGlvbnMpXG4gIH07XG59XG5cbnZhciBkZWZhdWx0U2hvdWxkUmV0cnkgPSAoZXJyLCBudW0sIG9wdGlvbnMpID0+IHtcbiAgaWYgKG9wdGlvbnMubWV0aG9kICE9PSBcIkdFVFwiICYmIG9wdGlvbnMubWV0aG9kICE9PSBcIkhFQURcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZXJyLnJlc3BvbnNlICYmIGVyci5yZXNwb25zZS5zdGF0dXNDb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBhbGxvd2VkX19kZWZhdWx0LmRlZmF1bHQoZXJyKTtcbn07XG5cbmNvbnN0IGlzU3RyZWFtID0gKHN0cmVhbSkgPT4gc3RyZWFtICE9PSBudWxsICYmIHR5cGVvZiBzdHJlYW0gPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHN0cmVhbS5waXBlID09PSBcImZ1bmN0aW9uXCI7XG52YXIgc2hhcmVkUmV0cnkgPSAob3B0cykgPT4ge1xuICBjb25zdCBtYXhSZXRyaWVzID0gb3B0cy5tYXhSZXRyaWVzIHx8IDU7XG4gIGNvbnN0IHJldHJ5RGVsYXkgPSBvcHRzLnJldHJ5RGVsYXkgfHwgZ2V0UmV0cnlEZWxheTtcbiAgY29uc3QgYWxsb3dSZXRyeSA9IG9wdHMuc2hvdWxkUmV0cnk7XG4gIHJldHVybiB7XG4gICAgb25FcnJvcjogKGVyciwgY29udGV4dCkgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucztcbiAgICAgIGNvbnN0IG1heCA9IG9wdGlvbnMubWF4UmV0cmllcyB8fCBtYXhSZXRyaWVzO1xuICAgICAgY29uc3Qgc2hvdWxkUmV0cnkgPSBvcHRpb25zLnNob3VsZFJldHJ5IHx8IGFsbG93UmV0cnk7XG4gICAgICBjb25zdCBhdHRlbXB0TnVtYmVyID0gb3B0aW9ucy5hdHRlbXB0TnVtYmVyIHx8IDA7XG4gICAgICBpZiAoaXNTdHJlYW0ob3B0aW9ucy5ib2R5KSkge1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgfVxuICAgICAgaWYgKCFzaG91bGRSZXRyeShlcnIsIGF0dGVtcHROdW1iZXIsIG9wdGlvbnMpIHx8IGF0dGVtcHROdW1iZXIgPj0gbWF4KSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdDb250ZXh0ID0gT2JqZWN0LmFzc2lnbih7fSwgY29udGV4dCwge1xuICAgICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7IGF0dGVtcHROdW1iZXI6IGF0dGVtcHROdW1iZXIgKyAxIH0pXG4gICAgICB9KTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gY29udGV4dC5jaGFubmVscy5yZXF1ZXN0LnB1Ymxpc2gobmV3Q29udGV4dCksIHJldHJ5RGVsYXkoYXR0ZW1wdE51bWJlcikpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xufTtcbmZ1bmN0aW9uIGdldFJldHJ5RGVsYXkoYXR0ZW1wdE51bSkge1xuICByZXR1cm4gMTAwICogTWF0aC5wb3coMiwgYXR0ZW1wdE51bSkgKyBNYXRoLnJhbmRvbSgpICogMTAwO1xufVxuXG5jb25zdCByZXRyeSA9IChvcHRzID0ge30pID0+IHNoYXJlZFJldHJ5KHsgc2hvdWxkUmV0cnk6IGRlZmF1bHRTaG91bGRSZXRyeSwgLi4ub3B0cyB9KTtcbnJldHJ5LnNob3VsZFJldHJ5ID0gZGVmYXVsdFNob3VsZFJldHJ5O1xuXG5mdW5jdGlvbiBlbmNvZGUoZGF0YSkge1xuICBjb25zdCBxdWVyeSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgY29uc3QgbmVzdCA9IChuYW1lLCBfdmFsdWUpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IF92YWx1ZSBpbnN0YW5jZW9mIFNldCA/IEFycmF5LmZyb20oX3ZhbHVlKSA6IF92YWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChjb25zdCBpbmRleCBpbiB2YWx1ZSkge1xuICAgICAgICAgIG5lc3QoXCJcIi5jb25jYXQobmFtZSwgXCJbXCIpLmNvbmNhdChpbmRleCwgXCJdXCIpLCB2YWx1ZVtpbmRleF0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWVyeS5hcHBlbmQoXCJcIi5jb25jYXQobmFtZSwgXCJbXVwiKSwgXCJcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgb2JqXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgbmVzdChcIlwiLmNvbmNhdChuYW1lLCBcIltcIikuY29uY2F0KGtleSwgXCJdXCIpLCBvYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBxdWVyeS5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZGF0YSkpIHtcbiAgICBuZXN0KGtleSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBxdWVyeS50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gdXJsRW5jb2RlZCgpIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9jZXNzT3B0aW9uczogKG9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IGJvZHkgPSBvcHRpb25zLmJvZHk7XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICB9XG4gICAgICBjb25zdCBpc1N0cmVhbSA9IHR5cGVvZiBib2R5LnBpcGUgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgIGNvbnN0IHNob3VsZFNlcmlhbGl6ZSA9ICFpc1N0cmVhbSAmJiAhaXNCdWZmZXIoYm9keSkgJiYgaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KGJvZHkpO1xuICAgICAgaWYgKCFzaG91bGRTZXJpYWxpemUpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBib2R5OiBlbmNvZGUob3B0aW9ucy5ib2R5KSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZEtlZXBBbGl2ZShhZ2VudCkge1xuICByZXR1cm4gZnVuY3Rpb24ga2VlcEFsaXZlKGNvbmZpZyA9IHt9KSB7XG4gICAgY29uc3QgbXMgPSBjb25maWcubXMgfHwgMWUzO1xuICAgIGNvbnN0IG1heEZyZWUgPSBjb25maWcubWF4RnJlZSB8fCAyNTY7XG4gICAgY29uc3QgYWdlbnRPcHRpb25zID0ge1xuICAgICAga2VlcEFsaXZlOiB0cnVlLFxuICAgICAga2VlcEFsaXZlTXNlY3M6IG1zLFxuICAgICAgbWF4RnJlZVNvY2tldHM6IG1heEZyZWVcbiAgICB9O1xuICAgIHJldHVybiBhZ2VudChhZ2VudE9wdGlvbnMpO1xuICB9O1xufVxuXG5jb25zdCBrZWVwQWxpdmUgPSBidWlsZEtlZXBBbGl2ZShhZ2VudCk7XG5cbmV4cG9ydHMucHJvY2Vzc09wdGlvbnMgPSBkZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci5wcm9jZXNzT3B0aW9ucztcbmV4cG9ydHMudmFsaWRhdGVPcHRpb25zID0gZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3IudmFsaWRhdGVPcHRpb25zO1xuZXhwb3J0cy5DYW5jZWwgPSBDYW5jZWw7XG5leHBvcnRzLkNhbmNlbFRva2VuID0gQ2FuY2VsVG9rZW47XG5leHBvcnRzLmFnZW50ID0gYWdlbnQ7XG5leHBvcnRzLmJhc2UgPSBiYXNlO1xuZXhwb3J0cy5kZWJ1ZyA9IGRlYnVnO1xuZXhwb3J0cy5oZWFkZXJzID0gaGVhZGVycztcbmV4cG9ydHMuaHR0cEVycm9ycyA9IGh0dHBFcnJvcnM7XG5leHBvcnRzLmluamVjdFJlc3BvbnNlID0gaW5qZWN0UmVzcG9uc2U7XG5leHBvcnRzLmpzb25SZXF1ZXN0ID0ganNvblJlcXVlc3Q7XG5leHBvcnRzLmpzb25SZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbmV4cG9ydHMua2VlcEFsaXZlID0ga2VlcEFsaXZlO1xuZXhwb3J0cy5tdGxzID0gbXRscztcbmV4cG9ydHMub2JzZXJ2YWJsZSA9IG9ic2VydmFibGU7XG5leHBvcnRzLnByb2dyZXNzID0gcHJvZ3Jlc3M7XG5leHBvcnRzLnByb21pc2UgPSBwcm9taXNlO1xuZXhwb3J0cy5wcm94eSA9IHByb3h5O1xuZXhwb3J0cy5yZXRyeSA9IHJldHJ5O1xuZXhwb3J0cy51cmxFbmNvZGVkID0gdXJsRW5jb2RlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pZGRsZXdhcmUuY2pzLm1hcFxuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaHR0cCIsInJlcXVpcmUiLCJodHRwcyIsImRlYnVnSXQiLCJkZWZhdWx0T3B0aW9uc1ZhbGlkYXRvciIsImlzUGxhaW5PYmplY3QiLCJwcm9ncmVzc1N0cmVhbSIsImFsbG93ZWQiLCJfaW50ZXJvcERlZmF1bHRDb21wYXQiLCJlIiwiZGVmYXVsdCIsImRlYnVnSXRfX2RlZmF1bHQiLCJwcm9ncmVzc1N0cmVhbV9fZGVmYXVsdCIsImFsbG93ZWRfX2RlZmF1bHQiLCJpc0h0dHBzUHJvdG8iLCJhZ2VudCIsIm9wdHMiLCJodHRwQWdlbnQiLCJBZ2VudCIsImh0dHBzQWdlbnQiLCJhZ2VudHMiLCJmaW5hbGl6ZU9wdGlvbnMiLCJvcHRpb25zIiwibWF4UmVkaXJlY3RzIiwiaXNIdHRwcyIsInRlc3QiLCJocmVmIiwicHJvdG9jb2wiLCJsZWFkaW5nU2xhc2giLCJ0cmFpbGluZ1NsYXNoIiwiYmFzZSIsImJhc2VVcmwiLCJiYXNlVXJpIiwicmVwbGFjZSIsInByb2Nlc3NPcHRpb25zIiwidXJsIiwiam9pbiIsImFzc2lnbiIsIlNFTlNJVElWRV9IRUFERVJTIiwiaGFzT3duIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJyZWRhY3RLZXlzIiwic291cmNlIiwicmVkYWN0ZWQiLCJ0YXJnZXQiLCJrZXkiLCJjYWxsIiwiaW5kZXhPZiIsInRvTG93ZXJDYXNlIiwiZGVidWciLCJ2ZXJib3NlIiwibmFtZXNwYWNlIiwiZGVmYXVsdExvZ2dlciIsImxvZyIsInNob3J0Q2lyY3VpdCIsImVuYWJsZWQiLCJyZXF1ZXN0SWQiLCJvblJlcXVlc3QiLCJldmVudCIsIm1ldGhvZCIsImJvZHkiLCJoZWFkZXJzIiwicmVkYWN0U2Vuc2l0aXZlSGVhZGVycyIsIkpTT04iLCJzdHJpbmdpZnkiLCJvblJlc3BvbnNlIiwicmVzIiwiY29udGV4dCIsInJlcUlkIiwic3RhdHVzQ29kZSIsInN0YXR1c01lc3NhZ2UiLCJzdHJpbmdpZnlCb2R5Iiwib25FcnJvciIsImVyciIsIm1lc3NhZ2UiLCJjb250ZW50VHlwZSIsImlzSnNvbiIsInRyeUZvcm1hdCIsInBhcnNlZCIsInBhcnNlIiwiX2hlYWRlcnMiLCJleGlzdGluZyIsIm92ZXJyaWRlIiwiSHR0cEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsImN0eCIsInRydW5jYXRlZFVybCIsImxlbmd0aCIsImNvbmNhdCIsInNsaWNlIiwibXNnIiwidHJpbSIsInJlc3BvbnNlIiwicmVxdWVzdCIsImh0dHBFcnJvcnMiLCJpc0h0dHBFcnJvciIsImluamVjdFJlc3BvbnNlIiwiaW5qZWN0IiwiaW5qZWN0MiIsInByZXZWYWx1ZSIsImludGVyY2VwdFJlcXVlc3QiLCJpc0J1ZmZlciIsIkJ1ZmZlciIsIm9iaiIsInNlcmlhbGl6ZVR5cGVzIiwianNvblJlcXVlc3QiLCJpc1N0cmVhbSIsInBpcGUiLCJzaG91bGRTZXJpYWxpemUiLCJBcnJheSIsImlzQXJyYXkiLCJqc29uUmVzcG9uc2UiLCJzaG91bGREZWNvZGUiLCJmb3JjZSIsInRyeVBhcnNlIiwiQWNjZXB0IiwiaXNCcm93c2VyT3B0aW9ucyIsIm10bHMiLCJjb25maWciLCJjYSIsImNlcnQiLCJtdGxzT3B0cyIsImFjdHVhbEdsb2JhbCIsImdsb2JhbFRoaXMiLCJ3aW5kb3ciLCJnbG9iYWwiLCJzZWxmIiwiZ2xvYmFsJDEiLCJvYnNlcnZhYmxlIiwiT2JzZXJ2YWJsZSIsImltcGxlbWVudGF0aW9uIiwib25SZXR1cm4iLCJjaGFubmVscyIsIm9ic2VydmVyIiwiZXJyb3IiLCJzdWJzY3JpYmUiLCJwcm9ncmVzcyIsIm5leHQiLCJ0eXBlIiwiY29tcGxldGUiLCJwdWJsaXNoIiwiYWJvcnQiLCJub3JtYWxpemVyIiwic3RhZ2UiLCJwcm9nIiwicGVyY2VudCIsInBlcmNlbnRhZ2UiLCJ0b3RhbCIsImxvYWRlZCIsInRyYW5zZmVycmVkIiwibGVuZ3RoQ29tcHV0YWJsZSIsIm9uSGVhZGVycyIsImV2dCIsIl9wcm9ncmVzcyIsInRpbWUiLCJub3JtYWxpemUiLCJjb250ZW50TGVuZ3RoIiwiTnVtYmVyIiwiaXNOYU4iLCJzZXRMZW5ndGgiLCJvbiIsInByb21pc2UiLCJQcm9taXNlSW1wbGVtZW50YXRpb24iLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImNhbmNlbCIsImNhbmNlbFRva2VuIiwidGhlbiIsInJlYXNvbiIsIm9ubHlCb2R5Iiwic2V0VGltZW91dCIsIkNhbmNlbCIsIl9fQ0FOQ0VMX18iLCJ0b1N0cmluZyIsIl9DYW5jZWxUb2tlbiIsImV4ZWN1dG9yIiwiVHlwZUVycm9yIiwicmVzb2x2ZVByb21pc2UiLCJ0b2tlbiIsImNhbiIsIkNhbmNlbFRva2VuIiwiaXNDYW5jZWwiLCJwcm94eSIsIl9wcm94eSIsImhvc3QiLCJkZWZhdWx0U2hvdWxkUmV0cnkiLCJudW0iLCJzdHJlYW0iLCJzaGFyZWRSZXRyeSIsIm1heFJldHJpZXMiLCJyZXRyeURlbGF5IiwiZ2V0UmV0cnlEZWxheSIsImFsbG93UmV0cnkiLCJzaG91bGRSZXRyeSIsIm1heCIsImF0dGVtcHROdW1iZXIiLCJuZXdDb250ZXh0IiwiYXR0ZW1wdE51bSIsIk1hdGgiLCJwb3ciLCJyYW5kb20iLCJyZXRyeSIsImVuY29kZSIsImRhdGEiLCJxdWVyeSIsIlVSTFNlYXJjaFBhcmFtcyIsIm5lc3QiLCJuYW1lIiwiX3ZhbHVlIiwiU2V0IiwiZnJvbSIsImluZGV4IiwiYXBwZW5kIiwiZW50cmllcyIsInVybEVuY29kZWQiLCJidWlsZEtlZXBBbGl2ZSIsImtlZXBBbGl2ZSIsIm1zIiwibWF4RnJlZSIsImFnZW50T3B0aW9ucyIsImtlZXBBbGl2ZU1zZWNzIiwibWF4RnJlZVNvY2tldHMiLCJ2YWxpZGF0ZU9wdGlvbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/get-it/dist/middleware.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/get-it/dist/_chunks/createRequester-46TmGIk5.js":
/*!**********************************************************************!*\
  !*** ./node_modules/get-it/dist/_chunks/createRequester-46TmGIk5.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createRequester: () => (/* binding */ createRequester)\n/* harmony export */ });\n/* harmony import */ var _defaultOptionsValidator_N21NGwyb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaultOptionsValidator-N21NGwyb.js */ \"(rsc)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-N21NGwyb.js\");\n\nconst middlewareReducer = (middleware)=>function applyMiddleware(hook, defaultValue, ...args) {\n        const bailEarly = hook === \"onError\";\n        let value = defaultValue;\n        for(let i = 0; i < middleware[hook].length; i++){\n            const handler = middleware[hook][i];\n            value = handler(value, ...args);\n            if (bailEarly && !value) {\n                break;\n            }\n        }\n        return value;\n    };\nfunction createPubSub() {\n    const subscribers = /* @__PURE__ */ Object.create(null);\n    let nextId = 0;\n    function subscribe(subscriber) {\n        const id = nextId++;\n        subscribers[id] = subscriber;\n        return function unsubscribe() {\n            delete subscribers[id];\n        };\n    }\n    function publish(event) {\n        for(const id in subscribers){\n            subscribers[id](event);\n        }\n    }\n    return {\n        publish,\n        subscribe\n    };\n}\nconst channelNames = [\n    \"request\",\n    \"response\",\n    \"progress\",\n    \"error\",\n    \"abort\"\n];\nconst middlehooks = [\n    \"processOptions\",\n    \"validateOptions\",\n    \"interceptRequest\",\n    \"finalizeOptions\",\n    \"onRequest\",\n    \"onResponse\",\n    \"onError\",\n    \"onReturn\",\n    \"onHeaders\"\n];\nfunction createRequester(initMiddleware, httpRequest) {\n    const loadedMiddleware = [];\n    const middleware = middlehooks.reduce((ware, name)=>{\n        ware[name] = ware[name] || [];\n        return ware;\n    }, {\n        processOptions: [\n            _defaultOptionsValidator_N21NGwyb_js__WEBPACK_IMPORTED_MODULE_0__.processOptions\n        ],\n        validateOptions: [\n            _defaultOptionsValidator_N21NGwyb_js__WEBPACK_IMPORTED_MODULE_0__.validateOptions\n        ]\n    });\n    function request(opts) {\n        const onResponse = (reqErr, res, ctx)=>{\n            let error = reqErr;\n            let response = res;\n            if (!error) {\n                try {\n                    response = applyMiddleware(\"onResponse\", res, ctx);\n                } catch (err) {\n                    response = null;\n                    error = err;\n                }\n            }\n            error = error && applyMiddleware(\"onError\", error, ctx);\n            if (error) {\n                channels.error.publish(error);\n            } else if (response) {\n                channels.response.publish(response);\n            }\n        };\n        const channels = channelNames.reduce((target, name)=>{\n            target[name] = createPubSub();\n            return target;\n        }, {});\n        const applyMiddleware = middlewareReducer(middleware);\n        const options = applyMiddleware(\"processOptions\", opts);\n        applyMiddleware(\"validateOptions\", options);\n        const context = {\n            options,\n            channels,\n            applyMiddleware\n        };\n        let ongoingRequest;\n        const unsubscribe = channels.request.subscribe((ctx)=>{\n            ongoingRequest = httpRequest(ctx, (err, res)=>onResponse(err, res, ctx));\n        });\n        channels.abort.subscribe(()=>{\n            unsubscribe();\n            if (ongoingRequest) {\n                ongoingRequest.abort();\n            }\n        });\n        const returnValue = applyMiddleware(\"onReturn\", channels, context);\n        if (returnValue === channels) {\n            channels.request.publish(context);\n        }\n        return returnValue;\n    }\n    request.use = function use(newMiddleware) {\n        if (!newMiddleware) {\n            throw new Error(\"Tried to add middleware that resolved to falsey value\");\n        }\n        if (typeof newMiddleware === \"function\") {\n            throw new Error(\"Tried to add middleware that was a function. It probably expects you to pass options to it.\");\n        }\n        if (newMiddleware.onReturn && middleware.onReturn.length > 0) {\n            throw new Error(\"Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event\");\n        }\n        middlehooks.forEach((key)=>{\n            if (newMiddleware[key]) {\n                middleware[key].push(newMiddleware[key]);\n            }\n        });\n        loadedMiddleware.push(newMiddleware);\n        return request;\n    };\n    request.clone = ()=>createRequester(loadedMiddleware, httpRequest);\n    initMiddleware.forEach(request.use);\n    return request;\n}\n //# sourceMappingURL=createRequester-46TmGIk5.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvX2NodW5rcy9jcmVhdGVSZXF1ZXN0ZXItNDZUbUdJazUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBd0Y7QUFFeEYsTUFBTUUsb0JBQW9CLENBQUNDLGFBQWUsU0FBU0MsZ0JBQWdCQyxJQUFJLEVBQUVDLFlBQVksRUFBRSxHQUFHQyxJQUFJO1FBQzVGLE1BQU1DLFlBQVlILFNBQVM7UUFDM0IsSUFBSUksUUFBUUg7UUFDWixJQUFLLElBQUlJLElBQUksR0FBR0EsSUFBSVAsVUFBVSxDQUFDRSxLQUFLLENBQUNNLE1BQU0sRUFBRUQsSUFBSztZQUNoRCxNQUFNRSxVQUFVVCxVQUFVLENBQUNFLEtBQUssQ0FBQ0ssRUFBRTtZQUNuQ0QsUUFBUUcsUUFBUUgsVUFBVUY7WUFDMUIsSUFBSUMsYUFBYSxDQUFDQyxPQUFPO2dCQUN2QjtZQUNGO1FBQ0Y7UUFDQSxPQUFPQTtJQUNUO0FBRUEsU0FBU0k7SUFDUCxNQUFNQyxjQUFjLGFBQWEsR0FBR0MsT0FBT0MsTUFBTSxDQUFDO0lBQ2xELElBQUlDLFNBQVM7SUFDYixTQUFTQyxVQUFVQyxVQUFVO1FBQzNCLE1BQU1DLEtBQUtIO1FBQ1hILFdBQVcsQ0FBQ00sR0FBRyxHQUFHRDtRQUNsQixPQUFPLFNBQVNFO1lBQ2QsT0FBT1AsV0FBVyxDQUFDTSxHQUFHO1FBQ3hCO0lBQ0Y7SUFDQSxTQUFTRSxRQUFRQyxLQUFLO1FBQ3BCLElBQUssTUFBTUgsTUFBTU4sWUFBYTtZQUM1QkEsV0FBVyxDQUFDTSxHQUFHLENBQUNHO1FBQ2xCO0lBQ0Y7SUFDQSxPQUFPO1FBQ0xEO1FBQ0FKO0lBQ0Y7QUFDRjtBQUVBLE1BQU1NLGVBQWU7SUFDbkI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBQ0QsTUFBTUMsY0FBYztJQUNsQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUNELFNBQVNDLGdCQUFnQkMsY0FBYyxFQUFFQyxXQUFXO0lBQ2xELE1BQU1DLG1CQUFtQixFQUFFO0lBQzNCLE1BQU0xQixhQUFhc0IsWUFBWUssTUFBTSxDQUNuQyxDQUFDQyxNQUFNQztRQUNMRCxJQUFJLENBQUNDLEtBQUssR0FBR0QsSUFBSSxDQUFDQyxLQUFLLElBQUksRUFBRTtRQUM3QixPQUFPRDtJQUNULEdBQ0E7UUFDRS9CLGdCQUFnQjtZQUFDQSxnRkFBY0E7U0FBQztRQUNoQ0MsaUJBQWlCO1lBQUNBLGlGQUFlQTtTQUFDO0lBQ3BDO0lBRUYsU0FBU2dDLFFBQVFDLElBQUk7UUFDbkIsTUFBTUMsYUFBYSxDQUFDQyxRQUFRQyxLQUFLQztZQUMvQixJQUFJQyxRQUFRSDtZQUNaLElBQUlJLFdBQVdIO1lBQ2YsSUFBSSxDQUFDRSxPQUFPO2dCQUNWLElBQUk7b0JBQ0ZDLFdBQVdwQyxnQkFBZ0IsY0FBY2lDLEtBQUtDO2dCQUNoRCxFQUFFLE9BQU9HLEtBQUs7b0JBQ1pELFdBQVc7b0JBQ1hELFFBQVFFO2dCQUNWO1lBQ0Y7WUFDQUYsUUFBUUEsU0FBU25DLGdCQUFnQixXQUFXbUMsT0FBT0Q7WUFDbkQsSUFBSUMsT0FBTztnQkFDVEcsU0FBU0gsS0FBSyxDQUFDakIsT0FBTyxDQUFDaUI7WUFDekIsT0FBTyxJQUFJQyxVQUFVO2dCQUNuQkUsU0FBU0YsUUFBUSxDQUFDbEIsT0FBTyxDQUFDa0I7WUFDNUI7UUFDRjtRQUNBLE1BQU1FLFdBQVdsQixhQUFhTSxNQUFNLENBQUMsQ0FBQ2EsUUFBUVg7WUFDNUNXLE1BQU0sQ0FBQ1gsS0FBSyxHQUFHbkI7WUFDZixPQUFPOEI7UUFDVCxHQUFHLENBQUM7UUFDSixNQUFNdkMsa0JBQWtCRixrQkFBa0JDO1FBQzFDLE1BQU15QyxVQUFVeEMsZ0JBQWdCLGtCQUFrQjhCO1FBQ2xEOUIsZ0JBQWdCLG1CQUFtQndDO1FBQ25DLE1BQU1DLFVBQVU7WUFBRUQ7WUFBU0Y7WUFBVXRDO1FBQWdCO1FBQ3JELElBQUkwQztRQUNKLE1BQU16QixjQUFjcUIsU0FBU1QsT0FBTyxDQUFDZixTQUFTLENBQUMsQ0FBQ29CO1lBQzlDUSxpQkFBaUJsQixZQUFZVSxLQUFLLENBQUNHLEtBQUtKLE1BQVFGLFdBQVdNLEtBQUtKLEtBQUtDO1FBQ3ZFO1FBQ0FJLFNBQVNLLEtBQUssQ0FBQzdCLFNBQVMsQ0FBQztZQUN2Qkc7WUFDQSxJQUFJeUIsZ0JBQWdCO2dCQUNsQkEsZUFBZUMsS0FBSztZQUN0QjtRQUNGO1FBQ0EsTUFBTUMsY0FBYzVDLGdCQUFnQixZQUFZc0MsVUFBVUc7UUFDMUQsSUFBSUcsZ0JBQWdCTixVQUFVO1lBQzVCQSxTQUFTVCxPQUFPLENBQUNYLE9BQU8sQ0FBQ3VCO1FBQzNCO1FBQ0EsT0FBT0c7SUFDVDtJQUNBZixRQUFRZ0IsR0FBRyxHQUFHLFNBQVNBLElBQUlDLGFBQWE7UUFDdEMsSUFBSSxDQUFDQSxlQUFlO1lBQ2xCLE1BQU0sSUFBSUMsTUFBTTtRQUNsQjtRQUNBLElBQUksT0FBT0Qsa0JBQWtCLFlBQVk7WUFDdkMsTUFBTSxJQUFJQyxNQUNSO1FBRUo7UUFDQSxJQUFJRCxjQUFjRSxRQUFRLElBQUlqRCxXQUFXaUQsUUFBUSxDQUFDekMsTUFBTSxHQUFHLEdBQUc7WUFDNUQsTUFBTSxJQUFJd0MsTUFDUjtRQUVKO1FBQ0ExQixZQUFZNEIsT0FBTyxDQUFDLENBQUNDO1lBQ25CLElBQUlKLGFBQWEsQ0FBQ0ksSUFBSSxFQUFFO2dCQUN0Qm5ELFVBQVUsQ0FBQ21ELElBQUksQ0FBQ0MsSUFBSSxDQUFDTCxhQUFhLENBQUNJLElBQUk7WUFDekM7UUFDRjtRQUNBekIsaUJBQWlCMEIsSUFBSSxDQUFDTDtRQUN0QixPQUFPakI7SUFDVDtJQUNBQSxRQUFRdUIsS0FBSyxHQUFHLElBQU05QixnQkFBZ0JHLGtCQUFrQkQ7SUFDeERELGVBQWUwQixPQUFPLENBQUNwQixRQUFRZ0IsR0FBRztJQUNsQyxPQUFPaEI7QUFDVDtBQUUyQixDQUMzQixvREFBb0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYmMvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvX2NodW5rcy9jcmVhdGVSZXF1ZXN0ZXItNDZUbUdJazUuanM/ZTU2MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwcm9jZXNzT3B0aW9ucywgdmFsaWRhdGVPcHRpb25zIH0gZnJvbSAnLi9kZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci1OMjFOR3d5Yi5qcyc7XG5cbmNvbnN0IG1pZGRsZXdhcmVSZWR1Y2VyID0gKG1pZGRsZXdhcmUpID0+IGZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZShob29rLCBkZWZhdWx0VmFsdWUsIC4uLmFyZ3MpIHtcbiAgY29uc3QgYmFpbEVhcmx5ID0gaG9vayA9PT0gXCJvbkVycm9yXCI7XG4gIGxldCB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtaWRkbGV3YXJlW2hvb2tdLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IG1pZGRsZXdhcmVbaG9va11baV07XG4gICAgdmFsdWUgPSBoYW5kbGVyKHZhbHVlLCAuLi5hcmdzKTtcbiAgICBpZiAoYmFpbEVhcmx5ICYmICF2YWx1ZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVB1YlN1YigpIHtcbiAgY29uc3Qgc3Vic2NyaWJlcnMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IG5leHRJZCA9IDA7XG4gIGZ1bmN0aW9uIHN1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gICAgY29uc3QgaWQgPSBuZXh0SWQrKztcbiAgICBzdWJzY3JpYmVyc1tpZF0gPSBzdWJzY3JpYmVyO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIGRlbGV0ZSBzdWJzY3JpYmVyc1tpZF07XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBwdWJsaXNoKGV2ZW50KSB7XG4gICAgZm9yIChjb25zdCBpZCBpbiBzdWJzY3JpYmVycykge1xuICAgICAgc3Vic2NyaWJlcnNbaWRdKGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwdWJsaXNoLFxuICAgIHN1YnNjcmliZVxuICB9O1xufVxuXG5jb25zdCBjaGFubmVsTmFtZXMgPSBbXG4gIFwicmVxdWVzdFwiLFxuICBcInJlc3BvbnNlXCIsXG4gIFwicHJvZ3Jlc3NcIixcbiAgXCJlcnJvclwiLFxuICBcImFib3J0XCJcbl07XG5jb25zdCBtaWRkbGVob29rcyA9IFtcbiAgXCJwcm9jZXNzT3B0aW9uc1wiLFxuICBcInZhbGlkYXRlT3B0aW9uc1wiLFxuICBcImludGVyY2VwdFJlcXVlc3RcIixcbiAgXCJmaW5hbGl6ZU9wdGlvbnNcIixcbiAgXCJvblJlcXVlc3RcIixcbiAgXCJvblJlc3BvbnNlXCIsXG4gIFwib25FcnJvclwiLFxuICBcIm9uUmV0dXJuXCIsXG4gIFwib25IZWFkZXJzXCJcbl07XG5mdW5jdGlvbiBjcmVhdGVSZXF1ZXN0ZXIoaW5pdE1pZGRsZXdhcmUsIGh0dHBSZXF1ZXN0KSB7XG4gIGNvbnN0IGxvYWRlZE1pZGRsZXdhcmUgPSBbXTtcbiAgY29uc3QgbWlkZGxld2FyZSA9IG1pZGRsZWhvb2tzLnJlZHVjZShcbiAgICAod2FyZSwgbmFtZSkgPT4ge1xuICAgICAgd2FyZVtuYW1lXSA9IHdhcmVbbmFtZV0gfHwgW107XG4gICAgICByZXR1cm4gd2FyZTtcbiAgICB9LFxuICAgIHtcbiAgICAgIHByb2Nlc3NPcHRpb25zOiBbcHJvY2Vzc09wdGlvbnNdLFxuICAgICAgdmFsaWRhdGVPcHRpb25zOiBbdmFsaWRhdGVPcHRpb25zXVxuICAgIH1cbiAgKTtcbiAgZnVuY3Rpb24gcmVxdWVzdChvcHRzKSB7XG4gICAgY29uc3Qgb25SZXNwb25zZSA9IChyZXFFcnIsIHJlcywgY3R4KSA9PiB7XG4gICAgICBsZXQgZXJyb3IgPSByZXFFcnI7XG4gICAgICBsZXQgcmVzcG9uc2UgPSByZXM7XG4gICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzcG9uc2UgPSBhcHBseU1pZGRsZXdhcmUoXCJvblJlc3BvbnNlXCIsIHJlcywgY3R4KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmVzcG9uc2UgPSBudWxsO1xuICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlcnJvciA9IGVycm9yICYmIGFwcGx5TWlkZGxld2FyZShcIm9uRXJyb3JcIiwgZXJyb3IsIGN0eCk7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY2hhbm5lbHMuZXJyb3IucHVibGlzaChlcnJvcik7XG4gICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgIGNoYW5uZWxzLnJlc3BvbnNlLnB1Ymxpc2gocmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY2hhbm5lbHMgPSBjaGFubmVsTmFtZXMucmVkdWNlKCh0YXJnZXQsIG5hbWUpID0+IHtcbiAgICAgIHRhcmdldFtuYW1lXSA9IGNyZWF0ZVB1YlN1YigpO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9LCB7fSk7XG4gICAgY29uc3QgYXBwbHlNaWRkbGV3YXJlID0gbWlkZGxld2FyZVJlZHVjZXIobWlkZGxld2FyZSk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGFwcGx5TWlkZGxld2FyZShcInByb2Nlc3NPcHRpb25zXCIsIG9wdHMpO1xuICAgIGFwcGx5TWlkZGxld2FyZShcInZhbGlkYXRlT3B0aW9uc1wiLCBvcHRpb25zKTtcbiAgICBjb25zdCBjb250ZXh0ID0geyBvcHRpb25zLCBjaGFubmVscywgYXBwbHlNaWRkbGV3YXJlIH07XG4gICAgbGV0IG9uZ29pbmdSZXF1ZXN0O1xuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gY2hhbm5lbHMucmVxdWVzdC5zdWJzY3JpYmUoKGN0eCkgPT4ge1xuICAgICAgb25nb2luZ1JlcXVlc3QgPSBodHRwUmVxdWVzdChjdHgsIChlcnIsIHJlcykgPT4gb25SZXNwb25zZShlcnIsIHJlcywgY3R4KSk7XG4gICAgfSk7XG4gICAgY2hhbm5lbHMuYWJvcnQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICBpZiAob25nb2luZ1JlcXVlc3QpIHtcbiAgICAgICAgb25nb2luZ1JlcXVlc3QuYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCByZXR1cm5WYWx1ZSA9IGFwcGx5TWlkZGxld2FyZShcIm9uUmV0dXJuXCIsIGNoYW5uZWxzLCBjb250ZXh0KTtcbiAgICBpZiAocmV0dXJuVmFsdWUgPT09IGNoYW5uZWxzKSB7XG4gICAgICBjaGFubmVscy5yZXF1ZXN0LnB1Ymxpc2goY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfVxuICByZXF1ZXN0LnVzZSA9IGZ1bmN0aW9uIHVzZShuZXdNaWRkbGV3YXJlKSB7XG4gICAgaWYgKCFuZXdNaWRkbGV3YXJlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmllZCB0byBhZGQgbWlkZGxld2FyZSB0aGF0IHJlc29sdmVkIHRvIGZhbHNleSB2YWx1ZVwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXdNaWRkbGV3YXJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJUcmllZCB0byBhZGQgbWlkZGxld2FyZSB0aGF0IHdhcyBhIGZ1bmN0aW9uLiBJdCBwcm9iYWJseSBleHBlY3RzIHlvdSB0byBwYXNzIG9wdGlvbnMgdG8gaXQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChuZXdNaWRkbGV3YXJlLm9uUmV0dXJuICYmIG1pZGRsZXdhcmUub25SZXR1cm4ubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlRyaWVkIHRvIGFkZCBuZXcgbWlkZGxld2FyZSB3aXRoIGBvblJldHVybmAgaGFuZGxlciwgYnV0IGFub3RoZXIgaGFuZGxlciBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgZm9yIHRoaXMgZXZlbnRcIlxuICAgICAgKTtcbiAgICB9XG4gICAgbWlkZGxlaG9va3MuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAobmV3TWlkZGxld2FyZVtrZXldKSB7XG4gICAgICAgIG1pZGRsZXdhcmVba2V5XS5wdXNoKG5ld01pZGRsZXdhcmVba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbG9hZGVkTWlkZGxld2FyZS5wdXNoKG5ld01pZGRsZXdhcmUpO1xuICAgIHJldHVybiByZXF1ZXN0O1xuICB9O1xuICByZXF1ZXN0LmNsb25lID0gKCkgPT4gY3JlYXRlUmVxdWVzdGVyKGxvYWRlZE1pZGRsZXdhcmUsIGh0dHBSZXF1ZXN0KTtcbiAgaW5pdE1pZGRsZXdhcmUuZm9yRWFjaChyZXF1ZXN0LnVzZSk7XG4gIHJldHVybiByZXF1ZXN0O1xufVxuXG5leHBvcnQgeyBjcmVhdGVSZXF1ZXN0ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZVJlcXVlc3Rlci00NlRtR0lrNS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJwcm9jZXNzT3B0aW9ucyIsInZhbGlkYXRlT3B0aW9ucyIsIm1pZGRsZXdhcmVSZWR1Y2VyIiwibWlkZGxld2FyZSIsImFwcGx5TWlkZGxld2FyZSIsImhvb2siLCJkZWZhdWx0VmFsdWUiLCJhcmdzIiwiYmFpbEVhcmx5IiwidmFsdWUiLCJpIiwibGVuZ3RoIiwiaGFuZGxlciIsImNyZWF0ZVB1YlN1YiIsInN1YnNjcmliZXJzIiwiT2JqZWN0IiwiY3JlYXRlIiwibmV4dElkIiwic3Vic2NyaWJlIiwic3Vic2NyaWJlciIsImlkIiwidW5zdWJzY3JpYmUiLCJwdWJsaXNoIiwiZXZlbnQiLCJjaGFubmVsTmFtZXMiLCJtaWRkbGVob29rcyIsImNyZWF0ZVJlcXVlc3RlciIsImluaXRNaWRkbGV3YXJlIiwiaHR0cFJlcXVlc3QiLCJsb2FkZWRNaWRkbGV3YXJlIiwicmVkdWNlIiwid2FyZSIsIm5hbWUiLCJyZXF1ZXN0Iiwib3B0cyIsIm9uUmVzcG9uc2UiLCJyZXFFcnIiLCJyZXMiLCJjdHgiLCJlcnJvciIsInJlc3BvbnNlIiwiZXJyIiwiY2hhbm5lbHMiLCJ0YXJnZXQiLCJvcHRpb25zIiwiY29udGV4dCIsIm9uZ29pbmdSZXF1ZXN0IiwiYWJvcnQiLCJyZXR1cm5WYWx1ZSIsInVzZSIsIm5ld01pZGRsZXdhcmUiLCJFcnJvciIsIm9uUmV0dXJuIiwiZm9yRWFjaCIsImtleSIsInB1c2giLCJjbG9uZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/get-it/dist/_chunks/createRequester-46TmGIk5.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-N21NGwyb.js":
/*!******************************************************************************!*\
  !*** ./node_modules/get-it/dist/_chunks/defaultOptionsValidator-N21NGwyb.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   processOptions: () => (/* binding */ processOptions),\n/* harmony export */   validateOptions: () => (/* binding */ validateOptions)\n/* harmony export */ });\nconst isReactNative = typeof navigator === \"undefined\" ? false : navigator.product === \"ReactNative\";\nconst defaultOptions = {\n    timeout: isReactNative ? 6e4 : 12e4\n};\nconst processOptions = function processOptions2(opts) {\n    const options = {\n        ...defaultOptions,\n        ...typeof opts === \"string\" ? {\n            url: opts\n        } : opts\n    };\n    const { searchParams } = new URL(options.url, \"http://localhost\");\n    options.timeout = normalizeTimeout(options.timeout);\n    if (options.query) {\n        for (const [key, value] of Object.entries(options.query)){\n            if (value !== void 0) {\n                if (Array.isArray(value)) {\n                    for (const v of value){\n                        searchParams.append(key, v);\n                    }\n                } else {\n                    searchParams.append(key, value);\n                }\n            }\n        }\n    }\n    const [url] = options.url.split(\"?\");\n    const search = searchParams.toString();\n    if (search) {\n        options.url = \"\".concat(url, \"?\").concat(search);\n    }\n    options.method = options.body && !options.method ? \"POST\" : (options.method || \"GET\").toUpperCase();\n    return options;\n};\nfunction normalizeTimeout(time) {\n    if (time === false || time === 0) {\n        return false;\n    }\n    if (time.connect || time.socket) {\n        return time;\n    }\n    const delay = Number(time);\n    if (isNaN(delay)) {\n        return normalizeTimeout(defaultOptions.timeout);\n    }\n    return {\n        connect: delay,\n        socket: delay\n    };\n}\nconst validUrl = /^https?:\\/\\//i;\nconst validateOptions = function validateOptions2(options) {\n    if (!validUrl.test(options.url)) {\n        throw new Error('\"'.concat(options.url, '\" is not a valid URL'));\n    }\n};\n //# sourceMappingURL=defaultOptionsValidator-N21NGwyb.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvX2NodW5rcy9kZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci1OMjFOR3d5Yi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLE1BQU1BLGdCQUFnQixPQUFPQyxjQUFjLGNBQWMsUUFBUUEsVUFBVUMsT0FBTyxLQUFLO0FBQ3ZGLE1BQU1DLGlCQUFpQjtJQUFFQyxTQUFTSixnQkFBZ0IsTUFBTTtBQUFLO0FBQzdELE1BQU1LLGlCQUFpQixTQUFTQyxnQkFBZ0JDLElBQUk7SUFDbEQsTUFBTUMsVUFBVTtRQUNkLEdBQUdMLGNBQWM7UUFDakIsR0FBRyxPQUFPSSxTQUFTLFdBQVc7WUFBRUUsS0FBS0Y7UUFBSyxJQUFJQSxJQUFJO0lBQ3BEO0lBQ0EsTUFBTSxFQUFFRyxZQUFZLEVBQUUsR0FBRyxJQUFJQyxJQUFJSCxRQUFRQyxHQUFHLEVBQUU7SUFDOUNELFFBQVFKLE9BQU8sR0FBR1EsaUJBQWlCSixRQUFRSixPQUFPO0lBQ2xELElBQUlJLFFBQVFLLEtBQUssRUFBRTtRQUNqQixLQUFLLE1BQU0sQ0FBQ0MsS0FBS0MsTUFBTSxJQUFJQyxPQUFPQyxPQUFPLENBQUNULFFBQVFLLEtBQUssRUFBRztZQUN4RCxJQUFJRSxVQUFVLEtBQUssR0FBRztnQkFDcEIsSUFBSUcsTUFBTUMsT0FBTyxDQUFDSixRQUFRO29CQUN4QixLQUFLLE1BQU1LLEtBQUtMLE1BQU87d0JBQ3JCTCxhQUFhVyxNQUFNLENBQUNQLEtBQUtNO29CQUMzQjtnQkFDRixPQUFPO29CQUNMVixhQUFhVyxNQUFNLENBQUNQLEtBQUtDO2dCQUMzQjtZQUNGO1FBQ0Y7SUFDRjtJQUNBLE1BQU0sQ0FBQ04sSUFBSSxHQUFHRCxRQUFRQyxHQUFHLENBQUNhLEtBQUssQ0FBQztJQUNoQyxNQUFNQyxTQUFTYixhQUFhYyxRQUFRO0lBQ3BDLElBQUlELFFBQVE7UUFDVmYsUUFBUUMsR0FBRyxHQUFHLEdBQUdnQixNQUFNLENBQUNoQixLQUFLLEtBQUtnQixNQUFNLENBQUNGO0lBQzNDO0lBQ0FmLFFBQVFrQixNQUFNLEdBQUdsQixRQUFRbUIsSUFBSSxJQUFJLENBQUNuQixRQUFRa0IsTUFBTSxHQUFHLFNBQVMsQ0FBQ2xCLFFBQVFrQixNQUFNLElBQUksS0FBSSxFQUFHRSxXQUFXO0lBQ2pHLE9BQU9wQjtBQUNUO0FBQ0EsU0FBU0ksaUJBQWlCaUIsSUFBSTtJQUM1QixJQUFJQSxTQUFTLFNBQVNBLFNBQVMsR0FBRztRQUNoQyxPQUFPO0lBQ1Q7SUFDQSxJQUFJQSxLQUFLQyxPQUFPLElBQUlELEtBQUtFLE1BQU0sRUFBRTtRQUMvQixPQUFPRjtJQUNUO0lBQ0EsTUFBTUcsUUFBUUMsT0FBT0o7SUFDckIsSUFBSUssTUFBTUYsUUFBUTtRQUNoQixPQUFPcEIsaUJBQWlCVCxlQUFlQyxPQUFPO0lBQ2hEO0lBQ0EsT0FBTztRQUFFMEIsU0FBU0U7UUFBT0QsUUFBUUM7SUFBTTtBQUN6QztBQUVBLE1BQU1HLFdBQVc7QUFDakIsTUFBTUMsa0JBQWtCLFNBQVNDLGlCQUFpQjdCLE9BQU87SUFDdkQsSUFBSSxDQUFDMkIsU0FBU0csSUFBSSxDQUFDOUIsUUFBUUMsR0FBRyxHQUFHO1FBQy9CLE1BQU0sSUFBSThCLE1BQU0sSUFBSWQsTUFBTSxDQUFDakIsUUFBUUMsR0FBRyxFQUFFO0lBQzFDO0FBQ0Y7QUFFMkMsQ0FDM0MsNERBQTREIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWJjLy4vbm9kZV9tb2R1bGVzL2dldC1pdC9kaXN0L19jaHVua3MvZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3ItTjIxTkd3eWIuanM/OWM4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBpc1JlYWN0TmF0aXZlID0gdHlwZW9mIG5hdmlnYXRvciA9PT0gXCJ1bmRlZmluZWRcIiA/IGZhbHNlIDogbmF2aWdhdG9yLnByb2R1Y3QgPT09IFwiUmVhY3ROYXRpdmVcIjtcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0geyB0aW1lb3V0OiBpc1JlYWN0TmF0aXZlID8gNmU0IDogMTJlNCB9O1xuY29uc3QgcHJvY2Vzc09wdGlvbnMgPSBmdW5jdGlvbiBwcm9jZXNzT3B0aW9uczIob3B0cykge1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgIC4uLnR5cGVvZiBvcHRzID09PSBcInN0cmluZ1wiID8geyB1cmw6IG9wdHMgfSA6IG9wdHNcbiAgfTtcbiAgY29uc3QgeyBzZWFyY2hQYXJhbXMgfSA9IG5ldyBVUkwob3B0aW9ucy51cmwsIFwiaHR0cDovL2xvY2FsaG9zdFwiKTtcbiAgb3B0aW9ucy50aW1lb3V0ID0gbm9ybWFsaXplVGltZW91dChvcHRpb25zLnRpbWVvdXQpO1xuICBpZiAob3B0aW9ucy5xdWVyeSkge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMucXVlcnkpKSB7XG4gICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBbdXJsXSA9IG9wdGlvbnMudXJsLnNwbGl0KFwiP1wiKTtcbiAgY29uc3Qgc2VhcmNoID0gc2VhcmNoUGFyYW1zLnRvU3RyaW5nKCk7XG4gIGlmIChzZWFyY2gpIHtcbiAgICBvcHRpb25zLnVybCA9IFwiXCIuY29uY2F0KHVybCwgXCI/XCIpLmNvbmNhdChzZWFyY2gpO1xuICB9XG4gIG9wdGlvbnMubWV0aG9kID0gb3B0aW9ucy5ib2R5ICYmICFvcHRpb25zLm1ldGhvZCA/IFwiUE9TVFwiIDogKG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCIpLnRvVXBwZXJDYXNlKCk7XG4gIHJldHVybiBvcHRpb25zO1xufTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVRpbWVvdXQodGltZSkge1xuICBpZiAodGltZSA9PT0gZmFsc2UgfHwgdGltZSA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodGltZS5jb25uZWN0IHx8IHRpbWUuc29ja2V0KSB7XG4gICAgcmV0dXJuIHRpbWU7XG4gIH1cbiAgY29uc3QgZGVsYXkgPSBOdW1iZXIodGltZSk7XG4gIGlmIChpc05hTihkZWxheSkpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplVGltZW91dChkZWZhdWx0T3B0aW9ucy50aW1lb3V0KTtcbiAgfVxuICByZXR1cm4geyBjb25uZWN0OiBkZWxheSwgc29ja2V0OiBkZWxheSB9O1xufVxuXG5jb25zdCB2YWxpZFVybCA9IC9eaHR0cHM/OlxcL1xcLy9pO1xuY29uc3QgdmFsaWRhdGVPcHRpb25zID0gZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zMihvcHRpb25zKSB7XG4gIGlmICghdmFsaWRVcmwudGVzdChvcHRpb25zLnVybCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJy5jb25jYXQob3B0aW9ucy51cmwsICdcIiBpcyBub3QgYSB2YWxpZCBVUkwnKSk7XG4gIH1cbn07XG5cbmV4cG9ydCB7IHByb2Nlc3NPcHRpb25zLCB2YWxpZGF0ZU9wdGlvbnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRPcHRpb25zVmFsaWRhdG9yLU4yMU5Hd3liLmpzLm1hcFxuIl0sIm5hbWVzIjpbImlzUmVhY3ROYXRpdmUiLCJuYXZpZ2F0b3IiLCJwcm9kdWN0IiwiZGVmYXVsdE9wdGlvbnMiLCJ0aW1lb3V0IiwicHJvY2Vzc09wdGlvbnMiLCJwcm9jZXNzT3B0aW9uczIiLCJvcHRzIiwib3B0aW9ucyIsInVybCIsInNlYXJjaFBhcmFtcyIsIlVSTCIsIm5vcm1hbGl6ZVRpbWVvdXQiLCJxdWVyeSIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsIkFycmF5IiwiaXNBcnJheSIsInYiLCJhcHBlbmQiLCJzcGxpdCIsInNlYXJjaCIsInRvU3RyaW5nIiwiY29uY2F0IiwibWV0aG9kIiwiYm9keSIsInRvVXBwZXJDYXNlIiwidGltZSIsImNvbm5lY3QiLCJzb2NrZXQiLCJkZWxheSIsIk51bWJlciIsImlzTmFOIiwidmFsaWRVcmwiLCJ2YWxpZGF0ZU9wdGlvbnMiLCJ2YWxpZGF0ZU9wdGlvbnMyIiwidGVzdCIsIkVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-N21NGwyb.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/get-it/dist/index.react-server.js":
/*!********************************************************!*\
  !*** ./node_modules/get-it/dist/index.react-server.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   adapter: () => (/* binding */ adapter),\n/* harmony export */   environment: () => (/* binding */ environment),\n/* harmony export */   getIt: () => (/* binding */ getIt)\n/* harmony export */ });\n/* harmony import */ var _chunks_createRequester_46TmGIk5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_chunks/createRequester-46TmGIk5.js */ \"(rsc)/./node_modules/get-it/dist/_chunks/createRequester-46TmGIk5.js\");\n/* harmony import */ var parse_headers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! parse-headers */ \"(rsc)/./node_modules/parse-headers/parse-headers.js\");\n\n\nvar __accessCheck = (obj, member, msg)=>{\n    if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter)=>{\n    __accessCheck(obj, member, \"read from private field\");\n    return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value)=>{\n    if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter)=>{\n    __accessCheck(obj, member, \"write to private field\");\n    setter ? setter.call(obj, value) : member.set(obj, value);\n    return value;\n};\nvar _method, _url, _resHeaders, _headers, _controller, _init, _useAbortSignal;\nclass FetchXhr {\n    constructor(){\n        /**\n     * https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readyState\n     */ this.readyState = 0;\n        this.responseType = \"\";\n        /**\n     * Private implementation details\n     */ __privateAdd(this, _method, void 0);\n        __privateAdd(this, _url, void 0);\n        __privateAdd(this, _resHeaders, void 0);\n        __privateAdd(this, _headers, {});\n        __privateAdd(this, _controller, void 0);\n        __privateAdd(this, _init, {});\n        __privateAdd(this, _useAbortSignal, void 0);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- _async is only declared for typings compatibility\n    open(method, url, _async) {\n        __privateSet(this, _method, method);\n        __privateSet(this, _url, url);\n        __privateSet(this, _resHeaders, \"\");\n        this.readyState = 1;\n        this.onreadystatechange();\n        __privateSet(this, _controller, void 0);\n    }\n    abort() {\n        if (__privateGet(this, _controller)) {\n            __privateGet(this, _controller).abort();\n        }\n    }\n    getAllResponseHeaders() {\n        return __privateGet(this, _resHeaders);\n    }\n    setRequestHeader(name, value) {\n        __privateGet(this, _headers)[name] = value;\n    }\n    // Allow setting extra fetch init options, needed for runtimes such as Vercel Edge to set `cache` and other options in React Server Components\n    setInit(init, useAbortSignal = true) {\n        __privateSet(this, _init, init);\n        __privateSet(this, _useAbortSignal, useAbortSignal);\n    }\n    send(body) {\n        const textBody = this.responseType !== \"arraybuffer\";\n        const options = {\n            ...__privateGet(this, _init),\n            method: __privateGet(this, _method),\n            headers: __privateGet(this, _headers),\n            body\n        };\n        if (typeof AbortController === \"function\" && __privateGet(this, _useAbortSignal)) {\n            __privateSet(this, _controller, new AbortController());\n            if (typeof EventTarget !== \"undefined\" && __privateGet(this, _controller).signal instanceof EventTarget) {\n                options.signal = __privateGet(this, _controller).signal;\n            }\n        }\n        if (typeof document !== \"undefined\") {\n            options.credentials = this.withCredentials ? \"include\" : \"omit\";\n        }\n        fetch(__privateGet(this, _url), options).then((res)=>{\n            res.headers.forEach((value, key)=>{\n                __privateSet(this, _resHeaders, __privateGet(this, _resHeaders) + \"\".concat(key, \": \").concat(value, \"\\r\\n\"));\n            });\n            this.status = res.status;\n            this.statusText = res.statusText;\n            this.readyState = 3;\n            return textBody ? res.text() : res.arrayBuffer();\n        }).then((resBody)=>{\n            if (typeof resBody === \"string\") {\n                this.responseText = resBody;\n            } else {\n                this.response = resBody;\n            }\n            this.readyState = 4;\n            this.onreadystatechange();\n        }).catch((err)=>{\n            var _a;\n            if (err.name === \"AbortError\") {\n                this.onabort();\n                return;\n            }\n            (_a = this.onerror) == null ? void 0 : _a.call(this, err);\n        });\n    }\n}\n_method = new WeakMap();\n_url = new WeakMap();\n_resHeaders = new WeakMap();\n_headers = new WeakMap();\n_controller = new WeakMap();\n_init = new WeakMap();\n_useAbortSignal = new WeakMap();\nconst adapter = typeof XMLHttpRequest === \"function\" ? \"xhr\" : \"fetch\";\nconst XmlHttpRequest = adapter === \"xhr\" ? XMLHttpRequest : FetchXhr;\nconst httpRequester = (context, callback)=>{\n    var _a;\n    const opts = context.options;\n    const options = context.applyMiddleware(\"finalizeOptions\", opts);\n    const timers = {};\n    const injectedResponse = context.applyMiddleware(\"interceptRequest\", void 0, {\n        adapter,\n        context\n    });\n    if (injectedResponse) {\n        const cbTimer = setTimeout(callback, 0, null, injectedResponse);\n        const cancel = ()=>clearTimeout(cbTimer);\n        return {\n            abort: cancel\n        };\n    }\n    let xhr = new XmlHttpRequest();\n    if (xhr instanceof FetchXhr && typeof options.fetch === \"object\") {\n        xhr.setInit(options.fetch, (_a = options.useAbortSignal) != null ? _a : true);\n    }\n    const headers = options.headers;\n    const delays = options.timeout;\n    let aborted = false;\n    let loaded = false;\n    let timedOut = false;\n    xhr.onerror = (event)=>{\n        onError(new Error(\"Request error while attempting to reach \".concat(options.url).concat(event.lengthComputable ? \"(\".concat(event.loaded, \" of \").concat(event.total, \" bytes transferred)\") : \"\")));\n    };\n    xhr.ontimeout = (event)=>{\n        onError(new Error(\"Request timeout while attempting to reach \".concat(options.url).concat(event.lengthComputable ? \"(\".concat(event.loaded, \" of \").concat(event.total, \" bytes transferred)\") : \"\")));\n    };\n    xhr.onabort = ()=>{\n        stopTimers(true);\n        aborted = true;\n    };\n    xhr.onreadystatechange = ()=>{\n        resetTimers();\n        if (aborted || xhr.readyState !== 4) {\n            return;\n        }\n        if (xhr.status === 0) {\n            return;\n        }\n        onLoad();\n    };\n    xhr.open(options.method, options.url, true);\n    xhr.withCredentials = !!options.withCredentials;\n    if (headers && xhr.setRequestHeader) {\n        for(const key in headers){\n            if (headers.hasOwnProperty(key)) {\n                xhr.setRequestHeader(key, headers[key]);\n            }\n        }\n    }\n    if (options.rawBody) {\n        xhr.responseType = \"arraybuffer\";\n    }\n    context.applyMiddleware(\"onRequest\", {\n        options,\n        adapter,\n        request: xhr,\n        context\n    });\n    xhr.send(options.body || null);\n    if (delays) {\n        timers.connect = setTimeout(()=>timeoutRequest(\"ETIMEDOUT\"), delays.connect);\n    }\n    return {\n        abort\n    };\n    function abort() {\n        aborted = true;\n        if (xhr) {\n            xhr.abort();\n        }\n    }\n    function timeoutRequest(code) {\n        timedOut = true;\n        xhr.abort();\n        const error = new Error(code === \"ESOCKETTIMEDOUT\" ? \"Socket timed out on request to \".concat(options.url) : \"Connection timed out on request to \".concat(options.url));\n        error.code = code;\n        context.channels.error.publish(error);\n    }\n    function resetTimers() {\n        if (!delays) {\n            return;\n        }\n        stopTimers();\n        timers.socket = setTimeout(()=>timeoutRequest(\"ESOCKETTIMEDOUT\"), delays.socket);\n    }\n    function stopTimers(force) {\n        if (force || aborted || xhr.readyState >= 2 && timers.connect) {\n            clearTimeout(timers.connect);\n        }\n        if (timers.socket) {\n            clearTimeout(timers.socket);\n        }\n    }\n    function onError(error) {\n        if (loaded) {\n            return;\n        }\n        stopTimers(true);\n        loaded = true;\n        xhr = null;\n        const err = error || new Error(\"Network error while attempting to reach \".concat(options.url));\n        err.isNetworkError = true;\n        err.request = options;\n        callback(err);\n    }\n    function reduceResponse() {\n        return {\n            body: xhr.response || (xhr.responseType === \"\" || xhr.responseType === \"text\" ? xhr.responseText : \"\"),\n            url: options.url,\n            method: options.method,\n            headers: parse_headers__WEBPACK_IMPORTED_MODULE_0__(xhr.getAllResponseHeaders()),\n            statusCode: xhr.status,\n            statusMessage: xhr.statusText\n        };\n    }\n    function onLoad() {\n        if (aborted || loaded || timedOut) {\n            return;\n        }\n        if (xhr.status === 0) {\n            onError(new Error(\"Unknown XHR error\"));\n            return;\n        }\n        stopTimers();\n        loaded = true;\n        callback(null, reduceResponse());\n    }\n};\nconst getIt = (initMiddleware = [], httpRequest = httpRequester)=>(0,_chunks_createRequester_46TmGIk5_js__WEBPACK_IMPORTED_MODULE_1__.createRequester)(initMiddleware, httpRequest);\nconst environment = \"react-server\";\n //# sourceMappingURL=index.react-server.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvaW5kZXgucmVhY3Qtc2VydmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXdFO0FBQy9CO0FBRXpDLElBQUlFLGdCQUFnQixDQUFDQyxLQUFLQyxRQUFRQztJQUNoQyxJQUFJLENBQUNELE9BQU9FLEdBQUcsQ0FBQ0gsTUFDZCxNQUFNSSxVQUFVLFlBQVlGO0FBQ2hDO0FBQ0EsSUFBSUcsZUFBZSxDQUFDTCxLQUFLQyxRQUFRSztJQUMvQlAsY0FBY0MsS0FBS0MsUUFBUTtJQUMzQixPQUFPSyxTQUFTQSxPQUFPQyxJQUFJLENBQUNQLE9BQU9DLE9BQU9PLEdBQUcsQ0FBQ1I7QUFDaEQ7QUFDQSxJQUFJUyxlQUFlLENBQUNULEtBQUtDLFFBQVFTO0lBQy9CLElBQUlULE9BQU9FLEdBQUcsQ0FBQ0gsTUFDYixNQUFNSSxVQUFVO0lBQ2xCSCxrQkFBa0JVLFVBQVVWLE9BQU9XLEdBQUcsQ0FBQ1osT0FBT0MsT0FBT1ksR0FBRyxDQUFDYixLQUFLVTtBQUNoRTtBQUNBLElBQUlJLGVBQWUsQ0FBQ2QsS0FBS0MsUUFBUVMsT0FBT0s7SUFDdENoQixjQUFjQyxLQUFLQyxRQUFRO0lBQzNCYyxTQUFTQSxPQUFPUixJQUFJLENBQUNQLEtBQUtVLFNBQVNULE9BQU9ZLEdBQUcsQ0FBQ2IsS0FBS1U7SUFDbkQsT0FBT0E7QUFDVDtBQUNBLElBQUlNLFNBQVNDLE1BQU1DLGFBQWFDLFVBQVVDLGFBQWFDLE9BQU9DO0FBQzlELE1BQU1DO0lBQ0pDLGFBQWM7UUFDWjs7S0FFQyxHQUNELElBQUksQ0FBQ0MsVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQ0MsWUFBWSxHQUFHO1FBQ3BCOztLQUVDLEdBQ0RqQixhQUFhLElBQUksRUFBRU8sU0FBUyxLQUFLO1FBQ2pDUCxhQUFhLElBQUksRUFBRVEsTUFBTSxLQUFLO1FBQzlCUixhQUFhLElBQUksRUFBRVMsYUFBYSxLQUFLO1FBQ3JDVCxhQUFhLElBQUksRUFBRVUsVUFB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QU07UUFDNUI7SUFDRjtJQUNBLFNBQVNqQixRQUFRYyxLQUFLO1FBQ3BCLElBQUlqQixRQUFRO1lBQ1Y7UUFDRjtRQUNBUSxXQUFXO1FBQ1hSLFNBQVM7UUFDVEosTUFBTTtRQUNOLE1BQU1uQixNQUFNd0MsU0FBUyxJQUFJYixNQUFNLDJDQUEyQ3BDLE1BQU0sQ0FBQ2IsUUFBUWIsR0FBRztRQUM1Rm1DLElBQUk2QyxjQUFjLEdBQUc7UUFDckI3QyxJQUFJb0MsT0FBTyxHQUFHMUQ7UUFDZGdDLFNBQVNWO0lBQ1g7SUFDQSxTQUFTOEM7UUFDUCxPQUFPO1lBQ0x0RSxNQUFNMkMsSUFBSXJCLFFBQVEsSUFBS3FCLENBQUFBLElBQUl6RCxZQUFZLEtBQUssTUFBTXlELElBQUl6RCxZQUFZLEtBQUssU0FBU3lELElBQUl0QixZQUFZLEdBQUcsRUFBQztZQUNwR2hDLEtBQUthLFFBQVFiLEdBQUc7WUFDaEJELFFBQVFjLFFBQVFkLE1BQU07WUFDdEJlLFNBQVM3QywwQ0FBWUEsQ0FBQ3FGLElBQUlsRCxxQkFBcUI7WUFDL0M4RSxZQUFZNUIsSUFBSTNCLE1BQU07WUFDdEJ3RCxlQUFlN0IsSUFBSTFCLFVBQVU7UUFDL0I7SUFDRjtJQUNBLFNBQVN3QztRQUNQLElBQUlYLFdBQVdDLFVBQVVDLFVBQVU7WUFDakM7UUFDRjtRQUNBLElBQUlMLElBQUkzQixNQUFNLEtBQUssR0FBRztZQUNwQmtDLFFBQVEsSUFBSUMsTUFBTTtZQUNsQjtRQUNGO1FBQ0FJO1FBQ0FSLFNBQVM7UUFDVGIsU0FBUyxNQUFNb0M7SUFDakI7QUFDRjtBQUVBLE1BQU1HLFFBQVEsQ0FBQ0MsaUJBQWlCLEVBQUUsRUFBRUMsY0FBYzNDLGFBQWEsR0FBSzNFLG9GQUFlQSxDQUFDcUgsZ0JBQWdCQztBQUVwRyxNQUFNQyxjQUFjO0FBRW1CLENBQ3ZDLDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL21iYy8uL25vZGVfbW9kdWxlcy9nZXQtaXQvZGlzdC9pbmRleC5yZWFjdC1zZXJ2ZXIuanM/NGJkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVSZXF1ZXN0ZXIgfSBmcm9tICcuL19jaHVua3MvY3JlYXRlUmVxdWVzdGVyLTQ2VG1HSWs1LmpzJztcbmltcG9ydCBwYXJzZUhlYWRlcnMgZnJvbSAncGFyc2UtaGVhZGVycyc7XG5cbnZhciBfX2FjY2Vzc0NoZWNrID0gKG9iaiwgbWVtYmVyLCBtc2cpID0+IHtcbiAgaWYgKCFtZW1iZXIuaGFzKG9iaikpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IFwiICsgbXNnKTtcbn07XG52YXIgX19wcml2YXRlR2V0ID0gKG9iaiwgbWVtYmVyLCBnZXR0ZXIpID0+IHtcbiAgX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJyZWFkIGZyb20gcHJpdmF0ZSBmaWVsZFwiKTtcbiAgcmV0dXJuIGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiBtZW1iZXIuZ2V0KG9iaik7XG59O1xudmFyIF9fcHJpdmF0ZUFkZCA9IChvYmosIG1lbWJlciwgdmFsdWUpID0+IHtcbiAgaWYgKG1lbWJlci5oYXMob2JqKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIHRoZSBzYW1lIHByaXZhdGUgbWVtYmVyIG1vcmUgdGhhbiBvbmNlXCIpO1xuICBtZW1iZXIgaW5zdGFuY2VvZiBXZWFrU2V0ID8gbWVtYmVyLmFkZChvYmopIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbn07XG52YXIgX19wcml2YXRlU2V0ID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSwgc2V0dGVyKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwid3JpdGUgdG8gcHJpdmF0ZSBmaWVsZFwiKTtcbiAgc2V0dGVyID8gc2V0dGVyLmNhbGwob2JqLCB2YWx1ZSkgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xudmFyIF9tZXRob2QsIF91cmwsIF9yZXNIZWFkZXJzLCBfaGVhZGVycywgX2NvbnRyb2xsZXIsIF9pbml0LCBfdXNlQWJvcnRTaWduYWw7XG5jbGFzcyBGZXRjaFhociB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKlxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdC9yZWFkeVN0YXRlXG4gICAgICovXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gMDtcbiAgICB0aGlzLnJlc3BvbnNlVHlwZSA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzXG4gICAgICovXG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9tZXRob2QsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF91cmwsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9yZXNIZWFkZXJzLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaGVhZGVycywge30pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfY29udHJvbGxlciwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2luaXQsIHt9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3VzZUFib3J0U2lnbmFsLCB2b2lkIDApO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgLS0gX2FzeW5jIGlzIG9ubHkgZGVjbGFyZWQgZm9yIHR5cGluZ3MgY29tcGF0aWJpbGl0eVxuICBvcGVuKG1ldGhvZCwgdXJsLCBfYXN5bmMpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX21ldGhvZCwgbWV0aG9kKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3VybCwgdXJsKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3Jlc0hlYWRlcnMsIFwiXCIpO1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IDE7XG4gICAgdGhpcy5vbnJlYWR5c3RhdGVjaGFuZ2UoKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2NvbnRyb2xsZXIsIHZvaWQgMCk7XG4gIH1cbiAgYWJvcnQoKSB7XG4gICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfY29udHJvbGxlcikpIHtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfY29udHJvbGxlcikuYWJvcnQoKTtcbiAgICB9XG4gIH1cbiAgZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX3Jlc0hlYWRlcnMpO1xuICB9XG4gIHNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpIHtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2hlYWRlcnMpW25hbWVdID0gdmFsdWU7XG4gIH1cbiAgLy8gQWxsb3cgc2V0dGluZyBleHRyYSBmZXRjaCBpbml0IG9wdGlvbnMsIG5lZWRlZCBmb3IgcnVudGltZXMgc3VjaCBhcyBWZXJjZWwgRWRnZSB0byBzZXQgYGNhY2hlYCBhbmQgb3RoZXIgb3B0aW9ucyBpbiBSZWFjdCBTZXJ2ZXIgQ29tcG9uZW50c1xuICBzZXRJbml0KGluaXQsIHVzZUFib3J0U2lnbmFsID0gdHJ1ZSkge1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfaW5pdCwgaW5pdCk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF91c2VBYm9ydFNpZ25hbCwgdXNlQWJvcnRTaWduYWwpO1xuICB9XG4gIHNlbmQoYm9keSkge1xuICAgIGNvbnN0IHRleHRCb2R5ID0gdGhpcy5yZXNwb25zZVR5cGUgIT09IFwiYXJyYXlidWZmZXJcIjtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgLi4uX19wcml2YXRlR2V0KHRoaXMsIF9pbml0KSxcbiAgICAgIG1ldGhvZDogX19wcml2YXRlR2V0KHRoaXMsIF9tZXRob2QpLFxuICAgICAgaGVhZGVyczogX19wcml2YXRlR2V0KHRoaXMsIF9oZWFkZXJzKSxcbiAgICAgIGJvZHlcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgQWJvcnRDb250cm9sbGVyID09PSBcImZ1bmN0aW9uXCIgJiYgX19wcml2YXRlR2V0KHRoaXMsIF91c2VBYm9ydFNpZ25hbCkpIHtcbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfY29udHJvbGxlciwgbmV3IEFib3J0Q29udHJvbGxlcigpKTtcbiAgICAgIGlmICh0eXBlb2YgRXZlbnRUYXJnZXQgIT09IFwidW5kZWZpbmVkXCIgJiYgX19wcml2YXRlR2V0KHRoaXMsIF9jb250cm9sbGVyKS5zaWduYWwgaW5zdGFuY2VvZiBFdmVudFRhcmdldCkge1xuICAgICAgICBvcHRpb25zLnNpZ25hbCA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfY29udHJvbGxlcikuc2lnbmFsO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBvcHRpb25zLmNyZWRlbnRpYWxzID0gdGhpcy53aXRoQ3JlZGVudGlhbHMgPyBcImluY2x1ZGVcIiA6IFwib21pdFwiO1xuICAgIH1cbiAgICBmZXRjaChfX3ByaXZhdGVHZXQodGhpcywgX3VybCksIG9wdGlvbnMpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgcmVzLmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBfX3ByaXZhdGVTZXQodGhpcywgX3Jlc0hlYWRlcnMsIF9fcHJpdmF0ZUdldCh0aGlzLCBfcmVzSGVhZGVycykgKyBcIlwiLmNvbmNhdChrZXksIFwiOiBcIikuY29uY2F0KHZhbHVlLCBcIlxcclxcblwiKSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc3RhdHVzID0gcmVzLnN0YXR1cztcbiAgICAgIHRoaXMuc3RhdHVzVGV4dCA9IHJlcy5zdGF0dXNUZXh0O1xuICAgICAgdGhpcy5yZWFkeVN0YXRlID0gMztcbiAgICAgIHJldHVybiB0ZXh0Qm9keSA/IHJlcy50ZXh0KCkgOiByZXMuYXJyYXlCdWZmZXIoKTtcbiAgICB9KS50aGVuKChyZXNCb2R5KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHJlc0JvZHkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhpcy5yZXNwb25zZVRleHQgPSByZXNCb2R5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHJlc0JvZHk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPSA0O1xuICAgICAgdGhpcy5vbnJlYWR5c3RhdGVjaGFuZ2UoKTtcbiAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoZXJyLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgIHRoaXMub25hYm9ydCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAoX2EgPSB0aGlzLm9uZXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGVycik7XG4gICAgfSk7XG4gIH1cbn1cbl9tZXRob2QgPSBuZXcgV2Vha01hcCgpO1xuX3VybCA9IG5ldyBXZWFrTWFwKCk7XG5fcmVzSGVhZGVycyA9IG5ldyBXZWFrTWFwKCk7XG5faGVhZGVycyA9IG5ldyBXZWFrTWFwKCk7XG5fY29udHJvbGxlciA9IG5ldyBXZWFrTWFwKCk7XG5faW5pdCA9IG5ldyBXZWFrTWFwKCk7XG5fdXNlQWJvcnRTaWduYWwgPSBuZXcgV2Vha01hcCgpO1xuXG5jb25zdCBhZGFwdGVyID0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ID09PSBcImZ1bmN0aW9uXCIgPyBcInhoclwiIDogXCJmZXRjaFwiO1xuY29uc3QgWG1sSHR0cFJlcXVlc3QgPSBhZGFwdGVyID09PSBcInhoclwiID8gWE1MSHR0cFJlcXVlc3QgOiBGZXRjaFhocjtcbmNvbnN0IGh0dHBSZXF1ZXN0ZXIgPSAoY29udGV4dCwgY2FsbGJhY2spID0+IHtcbiAgdmFyIF9hO1xuICBjb25zdCBvcHRzID0gY29udGV4dC5vcHRpb25zO1xuICBjb25zdCBvcHRpb25zID0gY29udGV4dC5hcHBseU1pZGRsZXdhcmUoXCJmaW5hbGl6ZU9wdGlvbnNcIiwgb3B0cyk7XG4gIGNvbnN0IHRpbWVycyA9IHt9O1xuICBjb25zdCBpbmplY3RlZFJlc3BvbnNlID0gY29udGV4dC5hcHBseU1pZGRsZXdhcmUoXCJpbnRlcmNlcHRSZXF1ZXN0XCIsIHZvaWQgMCwge1xuICAgIGFkYXB0ZXIsXG4gICAgY29udGV4dFxuICB9KTtcbiAgaWYgKGluamVjdGVkUmVzcG9uc2UpIHtcbiAgICBjb25zdCBjYlRpbWVyID0gc2V0VGltZW91dChjYWxsYmFjaywgMCwgbnVsbCwgaW5qZWN0ZWRSZXNwb25zZSk7XG4gICAgY29uc3QgY2FuY2VsID0gKCkgPT4gY2xlYXJUaW1lb3V0KGNiVGltZXIpO1xuICAgIHJldHVybiB7IGFib3J0OiBjYW5jZWwgfTtcbiAgfVxuICBsZXQgeGhyID0gbmV3IFhtbEh0dHBSZXF1ZXN0KCk7XG4gIGlmICh4aHIgaW5zdGFuY2VvZiBGZXRjaFhociAmJiB0eXBlb2Ygb3B0aW9ucy5mZXRjaCA9PT0gXCJvYmplY3RcIikge1xuICAgIHhoci5zZXRJbml0KG9wdGlvbnMuZmV0Y2gsIChfYSA9IG9wdGlvbnMudXNlQWJvcnRTaWduYWwpICE9IG51bGwgPyBfYSA6IHRydWUpO1xuICB9XG4gIGNvbnN0IGhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnM7XG4gIGNvbnN0IGRlbGF5cyA9IG9wdGlvbnMudGltZW91dDtcbiAgbGV0IGFib3J0ZWQgPSBmYWxzZTtcbiAgbGV0IGxvYWRlZCA9IGZhbHNlO1xuICBsZXQgdGltZWRPdXQgPSBmYWxzZTtcbiAgeGhyLm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICBvbkVycm9yKFxuICAgICAgbmV3IEVycm9yKFxuICAgICAgICBcIlJlcXVlc3QgZXJyb3Igd2hpbGUgYXR0ZW1wdGluZyB0byByZWFjaCBcIi5jb25jYXQob3B0aW9ucy51cmwpLmNvbmNhdChldmVudC5sZW5ndGhDb21wdXRhYmxlID8gXCIoXCIuY29uY2F0KGV2ZW50LmxvYWRlZCwgXCIgb2YgXCIpLmNvbmNhdChldmVudC50b3RhbCwgXCIgYnl0ZXMgdHJhbnNmZXJyZWQpXCIpIDogXCJcIilcbiAgICAgIClcbiAgICApO1xuICB9O1xuICB4aHIub250aW1lb3V0ID0gKGV2ZW50KSA9PiB7XG4gICAgb25FcnJvcihcbiAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgXCJSZXF1ZXN0IHRpbWVvdXQgd2hpbGUgYXR0ZW1wdGluZyB0byByZWFjaCBcIi5jb25jYXQob3B0aW9ucy51cmwpLmNvbmNhdChldmVudC5sZW5ndGhDb21wdXRhYmxlID8gXCIoXCIuY29uY2F0KGV2ZW50LmxvYWRlZCwgXCIgb2YgXCIpLmNvbmNhdChldmVudC50b3RhbCwgXCIgYnl0ZXMgdHJhbnNmZXJyZWQpXCIpIDogXCJcIilcbiAgICAgIClcbiAgICApO1xuICB9O1xuICB4aHIub25hYm9ydCA9ICgpID0+IHtcbiAgICBzdG9wVGltZXJzKHRydWUpO1xuICAgIGFib3J0ZWQgPSB0cnVlO1xuICB9O1xuICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgIHJlc2V0VGltZXJzKCk7XG4gICAgaWYgKGFib3J0ZWQgfHwgeGhyLnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHhoci5zdGF0dXMgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb25Mb2FkKCk7XG4gIH07XG4gIHhoci5vcGVuKFxuICAgIG9wdGlvbnMubWV0aG9kLFxuICAgIG9wdGlvbnMudXJsLFxuICAgIHRydWVcbiAgICAvLyBBbHdheXMgYXN5bmNcbiAgKTtcbiAgeGhyLndpdGhDcmVkZW50aWFscyA9ICEhb3B0aW9ucy53aXRoQ3JlZGVudGlhbHM7XG4gIGlmIChoZWFkZXJzICYmIHhoci5zZXRSZXF1ZXN0SGVhZGVyKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gaGVhZGVycykge1xuICAgICAgaWYgKGhlYWRlcnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGhlYWRlcnNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zLnJhd0JvZHkpIHtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuICB9XG4gIGNvbnRleHQuYXBwbHlNaWRkbGV3YXJlKFwib25SZXF1ZXN0XCIsIHsgb3B0aW9ucywgYWRhcHRlciwgcmVxdWVzdDogeGhyLCBjb250ZXh0IH0pO1xuICB4aHIuc2VuZChvcHRpb25zLmJvZHkgfHwgbnVsbCk7XG4gIGlmIChkZWxheXMpIHtcbiAgICB0aW1lcnMuY29ubmVjdCA9IHNldFRpbWVvdXQoKCkgPT4gdGltZW91dFJlcXVlc3QoXCJFVElNRURPVVRcIiksIGRlbGF5cy5jb25uZWN0KTtcbiAgfVxuICByZXR1cm4geyBhYm9ydCB9O1xuICBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICBpZiAoeGhyKSB7XG4gICAgICB4aHIuYWJvcnQoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdGltZW91dFJlcXVlc3QoY29kZSkge1xuICAgIHRpbWVkT3V0ID0gdHJ1ZTtcbiAgICB4aHIuYWJvcnQoKTtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgIGNvZGUgPT09IFwiRVNPQ0tFVFRJTUVET1VUXCIgPyBcIlNvY2tldCB0aW1lZCBvdXQgb24gcmVxdWVzdCB0byBcIi5jb25jYXQob3B0aW9ucy51cmwpIDogXCJDb25uZWN0aW9uIHRpbWVkIG91dCBvbiByZXF1ZXN0IHRvIFwiLmNvbmNhdChvcHRpb25zLnVybClcbiAgICApO1xuICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICAgIGNvbnRleHQuY2hhbm5lbHMuZXJyb3IucHVibGlzaChlcnJvcik7XG4gIH1cbiAgZnVuY3Rpb24gcmVzZXRUaW1lcnMoKSB7XG4gICAgaWYgKCFkZWxheXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RvcFRpbWVycygpO1xuICAgIHRpbWVycy5zb2NrZXQgPSBzZXRUaW1lb3V0KCgpID0+IHRpbWVvdXRSZXF1ZXN0KFwiRVNPQ0tFVFRJTUVET1VUXCIpLCBkZWxheXMuc29ja2V0KTtcbiAgfVxuICBmdW5jdGlvbiBzdG9wVGltZXJzKGZvcmNlKSB7XG4gICAgaWYgKGZvcmNlIHx8IGFib3J0ZWQgfHwgeGhyLnJlYWR5U3RhdGUgPj0gMiAmJiB0aW1lcnMuY29ubmVjdCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVycy5jb25uZWN0KTtcbiAgICB9XG4gICAgaWYgKHRpbWVycy5zb2NrZXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcnMuc29ja2V0KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25FcnJvcihlcnJvcikge1xuICAgIGlmIChsb2FkZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RvcFRpbWVycyh0cnVlKTtcbiAgICBsb2FkZWQgPSB0cnVlO1xuICAgIHhociA9IG51bGw7XG4gICAgY29uc3QgZXJyID0gZXJyb3IgfHwgbmV3IEVycm9yKFwiTmV0d29yayBlcnJvciB3aGlsZSBhdHRlbXB0aW5nIHRvIHJlYWNoIFwiLmNvbmNhdChvcHRpb25zLnVybCkpO1xuICAgIGVyci5pc05ldHdvcmtFcnJvciA9IHRydWU7XG4gICAgZXJyLnJlcXVlc3QgPSBvcHRpb25zO1xuICAgIGNhbGxiYWNrKGVycik7XG4gIH1cbiAgZnVuY3Rpb24gcmVkdWNlUmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJvZHk6IHhoci5yZXNwb25zZSB8fCAoeGhyLnJlc3BvbnNlVHlwZSA9PT0gXCJcIiB8fCB4aHIucmVzcG9uc2VUeXBlID09PSBcInRleHRcIiA/IHhoci5yZXNwb25zZVRleHQgOiBcIlwiKSxcbiAgICAgIHVybDogb3B0aW9ucy51cmwsXG4gICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSksXG4gICAgICBzdGF0dXNDb2RlOiB4aHIuc3RhdHVzLFxuICAgICAgc3RhdHVzTWVzc2FnZTogeGhyLnN0YXR1c1RleHRcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIG9uTG9hZCgpIHtcbiAgICBpZiAoYWJvcnRlZCB8fCBsb2FkZWQgfHwgdGltZWRPdXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHhoci5zdGF0dXMgPT09IDApIHtcbiAgICAgIG9uRXJyb3IobmV3IEVycm9yKFwiVW5rbm93biBYSFIgZXJyb3JcIikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdG9wVGltZXJzKCk7XG4gICAgbG9hZGVkID0gdHJ1ZTtcbiAgICBjYWxsYmFjayhudWxsLCByZWR1Y2VSZXNwb25zZSgpKTtcbiAgfVxufTtcblxuY29uc3QgZ2V0SXQgPSAoaW5pdE1pZGRsZXdhcmUgPSBbXSwgaHR0cFJlcXVlc3QgPSBodHRwUmVxdWVzdGVyKSA9PiBjcmVhdGVSZXF1ZXN0ZXIoaW5pdE1pZGRsZXdhcmUsIGh0dHBSZXF1ZXN0KTtcblxuY29uc3QgZW52aXJvbm1lbnQgPSBcInJlYWN0LXNlcnZlclwiO1xuXG5leHBvcnQgeyBhZGFwdGVyLCBlbnZpcm9ubWVudCwgZ2V0SXQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LnJlYWN0LXNlcnZlci5qcy5tYXBcbiJdLCJuYW1lcyI6WyJjcmVhdGVSZXF1ZXN0ZXIiLCJwYXJzZUhlYWRlcnMiLCJfX2FjY2Vzc0NoZWNrIiwib2JqIiwibWVtYmVyIiwibXNnIiwiaGFzIiwiVHlwZUVycm9yIiwiX19wcml2YXRlR2V0IiwiZ2V0dGVyIiwiY2FsbCIsImdldCIsIl9fcHJpdmF0ZUFkZCIsInZhbHVlIiwiV2Vha1NldCIsImFkZCIsInNldCIsIl9fcHJpdmF0ZVNldCIsInNldHRlciIsIl9tZXRob2QiLCJfdXJsIiwiX3Jlc0hlYWRlcnMiLCJfaGVhZGVycyIsIl9jb250cm9sbGVyIiwiX2luaXQiLCJfdXNlQWJvcnRTaWduYWwiLCJGZXRjaFhociIsImNvbnN0cnVjdG9yIiwicmVhZHlTdGF0ZSIsInJlc3BvbnNlVHlwZSIsIm9wZW4iLCJtZXRob2QiLCJ1cmwiLCJfYXN5bmMiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJhYm9ydCIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsInNldFJlcXVlc3RIZWFkZXIiLCJuYW1lIiwic2V0SW5pdCIsImluaXQiLCJ1c2VBYm9ydFNpZ25hbCIsInNlbmQiLCJib2R5IiwidGV4dEJvZHkiLCJvcHRpb25zIiwiaGVhZGVycyIsIkFib3J0Q29udHJvbGxlciIsIkV2ZW50VGFyZ2V0Iiwic2lnbmFsIiwiZG9jdW1lbnQiLCJjcmVkZW50aWFscyIsIndpdGhDcmVkZW50aWFscyIsImZldGNoIiwidGhlbiIsInJlcyIsImZvckVhY2giLCJrZXkiLCJjb25jYXQiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwidGV4dCIsImFycmF5QnVmZmVyIiwicmVzQm9keSIsInJlc3BvbnNlVGV4dCIsInJlc3BvbnNlIiwiY2F0Y2giLCJlcnIiLCJfYSIsIm9uYWJvcnQiLCJvbmVycm9yIiwiV2Vha01hcCIsImFkYXB0ZXIiLCJYTUxIdHRwUmVxdWVzdCIsIlhtbEh0dHBSZXF1ZXN0IiwiaHR0cFJlcXVlc3RlciIsImNvbnRleHQiLCJjYWxsYmFjayIsIm9wdHMiLCJhcHBseU1pZGRsZXdhcmUiLCJ0aW1lcnMiLCJpbmplY3RlZFJlc3BvbnNlIiwiY2JUaW1lciIsInNldFRpbWVvdXQiLCJjYW5jZWwiLCJjbGVhclRpbWVvdXQiLCJ4aHIiLCJkZWxheXMiLCJ0aW1lb3V0IiwiYWJvcnRlZCIsImxvYWRlZCIsInRpbWVkT3V0IiwiZXZlbnQiLCJvbkVycm9yIiwiRXJyb3IiLCJsZW5ndGhDb21wdXRhYmxlIiwidG90YWwiLCJvbnRpbWVvdXQiLCJzdG9wVGltZXJzIiwicmVzZXRUaW1lcnMiLCJvbkxvYWQiLCJoYXNPd25Qcm9wZXJ0eSIsInJhd0JvZHkiLCJyZXF1ZXN0IiwiY29ubmVjdCIsInRpbWVvdXRSZXF1ZXN0IiwiY29kZSIsImVycm9yIiwiY2hhbm5lbHMiLCJwdWJsaXNoIiwic29ja2V0IiwiZm9yY2UiLCJpc05ldHdvcmtFcnJvciIsInJlZHVjZVJlc3BvbnNlIiwic3RhdHVzQ29kZSIsInN0YXR1c01lc3NhZ2UiLCJnZXRJdCIsImluaXRNaWRkbGV3YXJlIiwiaHR0cFJlcXVlc3QiLCJlbnZpcm9ubWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/get-it/dist/index.react-server.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/get-it/dist/middleware.browser.js":
/*!********************************************************!*\
  !*** ./node_modules/get-it/dist/middleware.browser.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cancel: () => (/* binding */ Cancel),\n/* harmony export */   CancelToken: () => (/* binding */ CancelToken),\n/* harmony export */   agent: () => (/* binding */ agent),\n/* harmony export */   base: () => (/* binding */ base),\n/* harmony export */   debug: () => (/* binding */ debug),\n/* harmony export */   headers: () => (/* binding */ headers),\n/* harmony export */   httpErrors: () => (/* binding */ httpErrors),\n/* harmony export */   injectResponse: () => (/* binding */ injectResponse),\n/* harmony export */   jsonRequest: () => (/* binding */ jsonRequest),\n/* harmony export */   jsonResponse: () => (/* binding */ jsonResponse),\n/* harmony export */   keepAlive: () => (/* binding */ keepAlive),\n/* harmony export */   mtls: () => (/* binding */ mtls),\n/* harmony export */   observable: () => (/* binding */ observable),\n/* harmony export */   processOptions: () => (/* reexport safe */ _chunks_defaultOptionsValidator_N21NGwyb_js__WEBPACK_IMPORTED_MODULE_1__.processOptions),\n/* harmony export */   progress: () => (/* binding */ progress),\n/* harmony export */   promise: () => (/* binding */ promise),\n/* harmony export */   proxy: () => (/* binding */ proxy),\n/* harmony export */   retry: () => (/* binding */ retry),\n/* harmony export */   urlEncoded: () => (/* binding */ urlEncoded),\n/* harmony export */   validateOptions: () => (/* reexport safe */ _chunks_defaultOptionsValidator_N21NGwyb_js__WEBPACK_IMPORTED_MODULE_1__.validateOptions)\n/* harmony export */ });\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\");\n/* harmony import */ var _chunks_defaultOptionsValidator_N21NGwyb_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_chunks/defaultOptionsValidator-N21NGwyb.js */ \"(rsc)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-N21NGwyb.js\");\n/* harmony import */ var is_plain_object__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! is-plain-object */ \"(rsc)/./node_modules/is-plain-object/dist/is-plain-object.mjs\");\n\n\n\nfunction agent(opts) {\n    return {};\n}\nconst leadingSlash = /^\\//;\nconst trailingSlash = /\\/$/;\nfunction base(baseUrl) {\n    const baseUri = baseUrl.replace(trailingSlash, \"\");\n    return {\n        processOptions: (options)=>{\n            if (/^https?:\\/\\//i.test(options.url)) {\n                return options;\n            }\n            const url = [\n                baseUri,\n                options.url.replace(leadingSlash, \"\")\n            ].join(\"/\");\n            return Object.assign({}, options, {\n                url\n            });\n        }\n    };\n}\nconst SENSITIVE_HEADERS = [\n    \"cookie\",\n    \"authorization\"\n];\nconst hasOwn = Object.prototype.hasOwnProperty;\nconst redactKeys = (source, redacted)=>{\n    const target = {};\n    for(const key in source){\n        if (hasOwn.call(source, key)) {\n            target[key] = redacted.indexOf(key.toLowerCase()) > -1 ? \"<redacted>\" : source[key];\n        }\n    }\n    return target;\n};\nfunction debug(opts = {}) {\n    const verbose = opts.verbose;\n    const namespace = opts.namespace || \"get-it\";\n    const defaultLogger = debug__WEBPACK_IMPORTED_MODULE_0__(namespace);\n    const log = opts.log || defaultLogger;\n    const shortCircuit = log === defaultLogger && !debug__WEBPACK_IMPORTED_MODULE_0__.enabled(namespace);\n    let requestId = 0;\n    return {\n        processOptions: (options)=>{\n            options.debug = log;\n            options.requestId = options.requestId || ++requestId;\n            return options;\n        },\n        onRequest: (event)=>{\n            if (shortCircuit || !event) {\n                return event;\n            }\n            const options = event.options;\n            log(\"[%s] HTTP %s %s\", options.requestId, options.method, options.url);\n            if (verbose && options.body && typeof options.body === \"string\") {\n                log(\"[%s] Request body: %s\", options.requestId, options.body);\n            }\n            if (verbose && options.headers) {\n                const headers = opts.redactSensitiveHeaders === false ? options.headers : redactKeys(options.headers, SENSITIVE_HEADERS);\n                log(\"[%s] Request headers: %s\", options.requestId, JSON.stringify(headers, null, 2));\n            }\n            return event;\n        },\n        onResponse: (res, context)=>{\n            if (shortCircuit || !res) {\n                return res;\n            }\n            const reqId = context.options.requestId;\n            log(\"[%s] Response code: %s %s\", reqId, res.statusCode, res.statusMessage);\n            if (verbose && res.body) {\n                log(\"[%s] Response body: %s\", reqId, stringifyBody(res));\n            }\n            return res;\n        },\n        onError: (err, context)=>{\n            const reqId = context.options.requestId;\n            if (!err) {\n                log(\"[%s] Error encountered, but handled by an earlier middleware\", reqId);\n                return err;\n            }\n            log(\"[%s] ERROR: %s\", reqId, err.message);\n            return err;\n        }\n    };\n}\nfunction stringifyBody(res) {\n    const contentType = (res.headers[\"content-type\"] || \"\").toLowerCase();\n    const isJson = contentType.indexOf(\"application/json\") !== -1;\n    return isJson ? tryFormat(res.body) : res.body;\n}\nfunction tryFormat(body) {\n    try {\n        const parsed = typeof body === \"string\" ? JSON.parse(body) : body;\n        return JSON.stringify(parsed, null, 2);\n    } catch (err) {\n        return body;\n    }\n}\nfunction headers(_headers, opts = {}) {\n    return {\n        processOptions: (options)=>{\n            const existing = options.headers || {};\n            options.headers = opts.override ? Object.assign({}, existing, _headers) : Object.assign({}, _headers, existing);\n            return options;\n        }\n    };\n}\nclass HttpError extends Error {\n    constructor(res, ctx){\n        super();\n        const truncatedUrl = res.url.length > 400 ? \"\".concat(res.url.slice(0, 399), \"\") : res.url;\n        let msg = \"\".concat(res.method, \"-request to \").concat(truncatedUrl, \" resulted in \");\n        msg += \"HTTP \".concat(res.statusCode, \" \").concat(res.statusMessage);\n        this.message = msg.trim();\n        this.response = res;\n        this.request = ctx.options;\n    }\n}\nfunction httpErrors() {\n    return {\n        onResponse: (res, ctx)=>{\n            const isHttpError = res.statusCode >= 400;\n            if (!isHttpError) {\n                return res;\n            }\n            throw new HttpError(res, ctx);\n        }\n    };\n}\nfunction injectResponse(opts = {}) {\n    if (typeof opts.inject !== \"function\") {\n        throw new Error(\"`injectResponse` middleware requires a `inject` function\");\n    }\n    const inject = function inject2(prevValue, event) {\n        const response = opts.inject(event, prevValue);\n        if (!response) {\n            return prevValue;\n        }\n        const options = event.context.options;\n        return {\n            body: \"\",\n            url: options.url,\n            method: options.method,\n            headers: {},\n            statusCode: 200,\n            statusMessage: \"OK\",\n            ...response\n        };\n    };\n    return {\n        interceptRequest: inject\n    };\n}\nconst isBuffer = typeof Buffer === \"undefined\" ? ()=>false : (obj)=>Buffer.isBuffer(obj);\nconst serializeTypes = [\n    \"boolean\",\n    \"string\",\n    \"number\"\n];\nfunction jsonRequest() {\n    return {\n        processOptions: (options)=>{\n            const body = options.body;\n            if (!body) {\n                return options;\n            }\n            const isStream = typeof body.pipe === \"function\";\n            const shouldSerialize = !isStream && !isBuffer(body) && (serializeTypes.indexOf(typeof body) !== -1 || Array.isArray(body) || (0,is_plain_object__WEBPACK_IMPORTED_MODULE_2__.isPlainObject)(body));\n            if (!shouldSerialize) {\n                return options;\n            }\n            return Object.assign({}, options, {\n                body: JSON.stringify(options.body),\n                headers: Object.assign({}, options.headers, {\n                    \"Content-Type\": \"application/json\"\n                })\n            });\n        }\n    };\n}\nfunction jsonResponse(opts) {\n    return {\n        onResponse: (response)=>{\n            const contentType = response.headers[\"content-type\"] || \"\";\n            const shouldDecode = opts && opts.force || contentType.indexOf(\"application/json\") !== -1;\n            if (!response.body || !contentType || !shouldDecode) {\n                return response;\n            }\n            return Object.assign({}, response, {\n                body: tryParse(response.body)\n            });\n        },\n        processOptions: (options)=>Object.assign({}, options, {\n                headers: Object.assign({\n                    Accept: \"application/json\"\n                }, options.headers)\n            })\n    };\n    function tryParse(body) {\n        try {\n            return JSON.parse(body);\n        } catch (err) {\n            err.message = \"Failed to parsed response body as JSON: \".concat(err.message);\n            throw err;\n        }\n    }\n}\nfunction isBrowserOptions(options) {\n    return typeof options === \"object\" && options !== null && !(\"protocol\" in options);\n}\nfunction mtls(config = {}) {\n    if (!config.ca) {\n        throw new Error('Required mtls option \"ca\" is missing');\n    }\n    if (!config.cert) {\n        throw new Error('Required mtls option \"cert\" is missing');\n    }\n    if (!config.key) {\n        throw new Error('Required mtls option \"key\" is missing');\n    }\n    return {\n        finalizeOptions: (options)=>{\n            if (isBrowserOptions(options)) {\n                return options;\n            }\n            const mtlsOpts = {\n                cert: config.cert,\n                key: config.key,\n                ca: config.ca\n            };\n            return Object.assign({}, options, mtlsOpts);\n        }\n    };\n}\nlet actualGlobal = {};\nif (typeof globalThis !== \"undefined\") {\n    actualGlobal = globalThis;\n} else if (false) {} else if (typeof global !== \"undefined\") {\n    actualGlobal = global;\n} else if (typeof self !== \"undefined\") {\n    actualGlobal = self;\n}\nvar global$1 = actualGlobal;\nfunction observable(opts = {}) {\n    const Observable = // eslint-disable-next-line @typescript-eslint/no-explicit-any -- @TODO consider dropping checking for a global Observable since it's not on a standards track\n    opts.implementation || global$1.Observable;\n    if (!Observable) {\n        throw new Error(\"`Observable` is not available in global scope, and no implementation was passed\");\n    }\n    return {\n        onReturn: (channels, context)=>new Observable((observer)=>{\n                channels.error.subscribe((err)=>observer.error(err));\n                channels.progress.subscribe((event)=>observer.next(Object.assign({\n                        type: \"progress\"\n                    }, event)));\n                channels.response.subscribe((response)=>{\n                    observer.next(Object.assign({\n                        type: \"response\"\n                    }, response));\n                    observer.complete();\n                });\n                channels.request.publish(context);\n                return ()=>channels.abort.publish();\n            })\n    };\n}\nfunction progress() {\n    return {\n        onRequest: (evt)=>{\n            if (evt.adapter !== \"xhr\") {\n                return;\n            }\n            const xhr = evt.request;\n            const context = evt.context;\n            if (\"upload\" in xhr && \"onprogress\" in xhr.upload) {\n                xhr.upload.onprogress = handleProgress(\"upload\");\n            }\n            if (\"onprogress\" in xhr) {\n                xhr.onprogress = handleProgress(\"download\");\n            }\n            function handleProgress(stage) {\n                return (event)=>{\n                    const percent = event.lengthComputable ? event.loaded / event.total * 100 : -1;\n                    context.channels.progress.publish({\n                        stage,\n                        percent,\n                        total: event.total,\n                        loaded: event.loaded,\n                        lengthComputable: event.lengthComputable\n                    });\n                };\n            }\n        }\n    };\n}\nconst promise = (options = {})=>{\n    const PromiseImplementation = options.implementation || Promise;\n    if (!PromiseImplementation) {\n        throw new Error(\"`Promise` is not available in global scope, and no implementation was passed\");\n    }\n    return {\n        onReturn: (channels, context)=>new PromiseImplementation((resolve, reject)=>{\n                const cancel = context.options.cancelToken;\n                if (cancel) {\n                    cancel.promise.then((reason)=>{\n                        channels.abort.publish(reason);\n                        reject(reason);\n                    });\n                }\n                channels.error.subscribe(reject);\n                channels.response.subscribe((response)=>{\n                    resolve(options.onlyBody ? response.body : response);\n                });\n                setTimeout(()=>{\n                    try {\n                        channels.request.publish(context);\n                    } catch (err) {\n                        reject(err);\n                    }\n                }, 0);\n            })\n    };\n};\nclass Cancel {\n    constructor(message){\n        this.__CANCEL__ = true;\n        this.message = message;\n    }\n    toString() {\n        return \"Cancel\".concat(this.message ? \": \".concat(this.message) : \"\");\n    }\n}\nconst _CancelToken = class _CancelToken {\n    constructor(executor){\n        if (typeof executor !== \"function\") {\n            throw new TypeError(\"executor must be a function.\");\n        }\n        let resolvePromise = null;\n        this.promise = new Promise((resolve)=>{\n            resolvePromise = resolve;\n        });\n        executor((message)=>{\n            if (this.reason) {\n                return;\n            }\n            this.reason = new Cancel(message);\n            resolvePromise(this.reason);\n        });\n    }\n};\n_CancelToken.source = ()=>{\n    let cancel;\n    const token = new _CancelToken((can)=>{\n        cancel = can;\n    });\n    return {\n        token,\n        cancel\n    };\n};\nlet CancelToken = _CancelToken;\nconst isCancel = (value)=>!!(value && (value == null ? void 0 : value.__CANCEL__));\npromise.Cancel = Cancel;\npromise.CancelToken = CancelToken;\npromise.isCancel = isCancel;\nfunction proxy(_proxy) {\n    if (_proxy !== false && (!_proxy || !_proxy.host)) {\n        throw new Error(\"Proxy middleware takes an object of host, port and auth properties\");\n    }\n    return {\n        processOptions: (options)=>Object.assign({\n                proxy: _proxy\n            }, options)\n    };\n}\nvar defaultShouldRetry = (err, attempt, options)=>{\n    if (options.method !== \"GET\" && options.method !== \"HEAD\") {\n        return false;\n    }\n    return err.isNetworkError || false;\n};\nconst isStream = (stream)=>stream !== null && typeof stream === \"object\" && typeof stream.pipe === \"function\";\nvar sharedRetry = (opts)=>{\n    const maxRetries = opts.maxRetries || 5;\n    const retryDelay = opts.retryDelay || getRetryDelay;\n    const allowRetry = opts.shouldRetry;\n    return {\n        onError: (err, context)=>{\n            const options = context.options;\n            const max = options.maxRetries || maxRetries;\n            const shouldRetry = options.shouldRetry || allowRetry;\n            const attemptNumber = options.attemptNumber || 0;\n            if (isStream(options.body)) {\n                return err;\n            }\n            if (!shouldRetry(err, attemptNumber, options) || attemptNumber >= max) {\n                return err;\n            }\n            const newContext = Object.assign({}, context, {\n                options: Object.assign({}, options, {\n                    attemptNumber: attemptNumber + 1\n                })\n            });\n            setTimeout(()=>context.channels.request.publish(newContext), retryDelay(attemptNumber));\n            return null;\n        }\n    };\n};\nfunction getRetryDelay(attemptNum) {\n    return 100 * Math.pow(2, attemptNum) + Math.random() * 100;\n}\nconst retry = (opts = {})=>sharedRetry({\n        shouldRetry: defaultShouldRetry,\n        ...opts\n    });\nretry.shouldRetry = defaultShouldRetry;\nfunction encode(data) {\n    const query = new URLSearchParams();\n    const nest = (name, _value)=>{\n        const value = _value instanceof Set ? Array.from(_value) : _value;\n        if (Array.isArray(value)) {\n            if (value.length) {\n                for(const index in value){\n                    nest(\"\".concat(name, \"[\").concat(index, \"]\"), value[index]);\n                }\n            } else {\n                query.append(\"\".concat(name, \"[]\"), \"\");\n            }\n        } else if (typeof value === \"object\" && value !== null) {\n            for (const [key, obj] of Object.entries(value)){\n                nest(\"\".concat(name, \"[\").concat(key, \"]\"), obj);\n            }\n        } else {\n            query.append(name, value);\n        }\n    };\n    for (const [key, value] of Object.entries(data)){\n        nest(key, value);\n    }\n    return query.toString();\n}\nfunction urlEncoded() {\n    return {\n        processOptions: (options)=>{\n            const body = options.body;\n            if (!body) {\n                return options;\n            }\n            const isStream = typeof body.pipe === \"function\";\n            const shouldSerialize = !isStream && !isBuffer(body) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_2__.isPlainObject)(body);\n            if (!shouldSerialize) {\n                return options;\n            }\n            return {\n                ...options,\n                body: encode(options.body),\n                headers: {\n                    ...options.headers,\n                    \"Content-Type\": \"application/x-www-form-urlencoded\"\n                }\n            };\n        }\n    };\n}\nfunction buildKeepAlive(agent) {\n    return function keepAlive(config = {}) {\n        const ms = config.ms || 1e3;\n        const maxFree = config.maxFree || 256;\n        const agentOptions = {\n            keepAlive: true,\n            keepAliveMsecs: ms,\n            maxFreeSockets: maxFree\n        };\n        return agent(agentOptions);\n    };\n}\nconst keepAlive = buildKeepAlive(agent);\n //# sourceMappingURL=middleware.browser.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvbWlkZGxld2FyZS5icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRCO0FBQ29FO0FBQ2hEO0FBRWhELFNBQVNJLE1BQU1DLElBQUk7SUFDakIsT0FBTyxDQUFDO0FBQ1Y7QUFFQSxNQUFNQyxlQUFlO0FBQ3JCLE1BQU1DLGdCQUFnQjtBQUN0QixTQUFTQyxLQUFLQyxPQUFPO0lBQ25CLE1BQU1DLFVBQVVELFFBQVFFLE9BQU8sQ0FBQ0osZUFBZTtJQUMvQyxPQUFPO1FBQ0xOLGdCQUFnQixDQUFDVztZQUNmLElBQUksZ0JBQWdCQyxJQUFJLENBQUNELFFBQVFFLEdBQUcsR0FBRztnQkFDckMsT0FBT0Y7WUFDVDtZQUNBLE1BQU1FLE1BQU07Z0JBQUNKO2dCQUFTRSxRQUFRRSxHQUFHLENBQUNILE9BQU8sQ0FBQ0wsY0FBYzthQUFJLENBQUNTLElBQUksQ0FBQztZQUNsRSxPQUFPQyxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHTCxTQUFTO2dCQUFFRTtZQUFJO1FBQzFDO0lBQ0Y7QUFDRjtBQUVBLE1BQU1JLG9CQUFvQjtJQUFDO0lBQVU7Q0FBZ0I7QUFDckQsTUFBTUMsU0FBU0gsT0FBT0ksU0FBUyxDQUFDQyxjQUFjO0FBQzlDLE1BQU1DLGFBQWEsQ0FBQ0MsUUFBUUM7SUFDMUIsTUFBTUMsU0FBUyxDQUFDO0lBQ2hCLElBQUssTUFBTUMsT0FBT0gsT0FBUTtRQUN4QixJQUFJSixPQUFPUSxJQUFJLENBQUNKLFFBQVFHLE1BQU07WUFDNUJELE1BQU0sQ0FBQ0MsSUFBSSxHQUFHRixTQUFTSSxPQUFPLENBQUNGLElBQUlHLFdBQVcsTUFBTSxDQUFDLElBQUksZUFBZU4sTUFBTSxDQUFDRyxJQUFJO1FBQ3JGO0lBQ0Y7SUFDQSxPQUFPRDtBQUNUO0FBQ0EsU0FBU0ssTUFBTXpCLE9BQU8sQ0FBQyxDQUFDO0lBQ3RCLE1BQU0wQixVQUFVMUIsS0FBSzBCLE9B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O1lBQ3RDLE1BQU1DLGtCQUFrQixDQUFDRixZQUFZLENBQUNMLFNBQVMxQyxTQUFTdEMsOERBQWFBLENBQUNzQztZQUN0RSxJQUFJLENBQUNpRCxpQkFBaUI7Z0JBQ3BCLE9BQU85RTtZQUNUO1lBQ0EsT0FBTztnQkFDTCxHQUFHQSxPQUFPO2dCQUNWNkIsTUFBTTJJLE9BQU94SyxRQUFRNkIsSUFBSTtnQkFDekJDLFNBQVM7b0JBQ1AsR0FBRzlCLFFBQVE4QixPQUFPO29CQUNsQixnQkFBZ0I7Z0JBQ2xCO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxTQUFTdUosZUFBZTdMLEtBQUs7SUFDM0IsT0FBTyxTQUFTOEwsVUFBVTlGLFNBQVMsQ0FBQyxDQUFDO1FBQ25DLE1BQU0rRixLQUFLL0YsT0FBTytGLEVBQUUsSUFBSTtRQUN4QixNQUFNQyxVQUFVaEcsT0FBT2dHLE9BQU8sSUFBSTtRQUNsQyxNQUFNQyxlQUFlO1lBQ25CSCxXQUFXO1lBQ1hJLGdCQUFnQkg7WUFDaEJJLGdCQUFnQkg7UUFDbEI7UUFDQSxPQUFPaE0sTUFBTWlNO0lBQ2Y7QUFDRjtBQUVBLE1BQU1ILFlBQVlELGVBQWU3TDtBQUU0SixDQUM3TCw4Q0FBOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYmMvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvbWlkZGxld2FyZS5icm93c2VyLmpzP2Y2MzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGRlYnVnSXQgZnJvbSAnZGVidWcnO1xuZXhwb3J0IHsgcHJvY2Vzc09wdGlvbnMsIHZhbGlkYXRlT3B0aW9ucyB9IGZyb20gJy4vX2NodW5rcy9kZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci1OMjFOR3d5Yi5qcyc7XG5pbXBvcnQgeyBpc1BsYWluT2JqZWN0IH0gZnJvbSAnaXMtcGxhaW4tb2JqZWN0JztcblxuZnVuY3Rpb24gYWdlbnQob3B0cykge1xuICByZXR1cm4ge307XG59XG5cbmNvbnN0IGxlYWRpbmdTbGFzaCA9IC9eXFwvLztcbmNvbnN0IHRyYWlsaW5nU2xhc2ggPSAvXFwvJC87XG5mdW5jdGlvbiBiYXNlKGJhc2VVcmwpIHtcbiAgY29uc3QgYmFzZVVyaSA9IGJhc2VVcmwucmVwbGFjZSh0cmFpbGluZ1NsYXNoLCBcIlwiKTtcbiAgcmV0dXJuIHtcbiAgICBwcm9jZXNzT3B0aW9uczogKG9wdGlvbnMpID0+IHtcbiAgICAgIGlmICgvXmh0dHBzPzpcXC9cXC8vaS50ZXN0KG9wdGlvbnMudXJsKSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHVybCA9IFtiYXNlVXJpLCBvcHRpb25zLnVybC5yZXBsYWNlKGxlYWRpbmdTbGFzaCwgXCJcIildLmpvaW4oXCIvXCIpO1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgdXJsIH0pO1xuICAgIH1cbiAgfTtcbn1cblxuY29uc3QgU0VOU0lUSVZFX0hFQURFUlMgPSBbXCJjb29raWVcIiwgXCJhdXRob3JpemF0aW9uXCJdO1xuY29uc3QgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmNvbnN0IHJlZGFjdEtleXMgPSAoc291cmNlLCByZWRhY3RlZCkgPT4ge1xuICBjb25zdCB0YXJnZXQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgaWYgKGhhc093bi5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSByZWRhY3RlZC5pbmRleE9mKGtleS50b0xvd2VyQ2FzZSgpKSA+IC0xID8gXCI8cmVkYWN0ZWQ+XCIgOiBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5mdW5jdGlvbiBkZWJ1ZyhvcHRzID0ge30pIHtcbiAgY29uc3QgdmVyYm9zZSA9IG9wdHMudmVyYm9zZTtcbiAgY29uc3QgbmFtZXNwYWNlID0gb3B0cy5uYW1lc3BhY2UgfHwgXCJnZXQtaXRcIjtcbiAgY29uc3QgZGVmYXVsdExvZ2dlciA9IGRlYnVnSXQobmFtZXNwYWNlKTtcbiAgY29uc3QgbG9nID0gb3B0cy5sb2cgfHwgZGVmYXVsdExvZ2dlcjtcbiAgY29uc3Qgc2hvcnRDaXJjdWl0ID0gbG9nID09PSBkZWZhdWx0TG9nZ2VyICYmICFkZWJ1Z0l0LmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgbGV0IHJlcXVlc3RJZCA9IDA7XG4gIHJldHVybiB7XG4gICAgcHJvY2Vzc09wdGlvbnM6IChvcHRpb25zKSA9PiB7XG4gICAgICBvcHRpb25zLmRlYnVnID0gbG9nO1xuICAgICAgb3B0aW9ucy5yZXF1ZXN0SWQgPSBvcHRpb25zLnJlcXVlc3RJZCB8fCArK3JlcXVlc3RJZDtcbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH0sXG4gICAgb25SZXF1ZXN0OiAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChzaG9ydENpcmN1aXQgfHwgIWV2ZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBldmVudC5vcHRpb25zO1xuICAgICAgbG9nKFwiWyVzXSBIVFRQICVzICVzXCIsIG9wdGlvbnMucmVxdWVzdElkLCBvcHRpb25zLm1ldGhvZCwgb3B0aW9ucy51cmwpO1xuICAgICAgaWYgKHZlcmJvc2UgJiYgb3B0aW9ucy5ib2R5ICYmIHR5cGVvZiBvcHRpb25zLmJvZHkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbG9nKFwiWyVzXSBSZXF1ZXN0IGJvZHk6ICVzXCIsIG9wdGlvbnMucmVxdWVzdElkLCBvcHRpb25zLmJvZHkpO1xuICAgICAgfVxuICAgICAgaWYgKHZlcmJvc2UgJiYgb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBvcHRzLnJlZGFjdFNlbnNpdGl2ZUhlYWRlcnMgPT09IGZhbHNlID8gb3B0aW9ucy5oZWFkZXJzIDogcmVkYWN0S2V5cyhvcHRpb25zLmhlYWRlcnMsIFNFTlNJVElWRV9IRUFERVJTKTtcbiAgICAgICAgbG9nKFwiWyVzXSBSZXF1ZXN0IGhlYWRlcnM6ICVzXCIsIG9wdGlvbnMucmVxdWVzdElkLCBKU09OLnN0cmluZ2lmeShoZWFkZXJzLCBudWxsLCAyKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfSxcbiAgICBvblJlc3BvbnNlOiAocmVzLCBjb250ZXh0KSA9PiB7XG4gICAgICBpZiAoc2hvcnRDaXJjdWl0IHx8ICFyZXMpIHtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlcUlkID0gY29udGV4dC5vcHRpb25zLnJlcXVlc3RJZDtcbiAgICAgIGxvZyhcIlslc10gUmVzcG9uc2UgY29kZTogJXMgJXNcIiwgcmVxSWQsIHJlcy5zdGF0dXNDb2RlLCByZXMuc3RhdHVzTWVzc2FnZSk7XG4gICAgICBpZiAodmVyYm9zZSAmJiByZXMuYm9keSkge1xuICAgICAgICBsb2coXCJbJXNdIFJlc3BvbnNlIGJvZHk6ICVzXCIsIHJlcUlkLCBzdHJpbmdpZnlCb2R5KHJlcykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIG9uRXJyb3I6IChlcnIsIGNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IHJlcUlkID0gY29udGV4dC5vcHRpb25zLnJlcXVlc3RJZDtcbiAgICAgIGlmICghZXJyKSB7XG4gICAgICAgIGxvZyhcIlslc10gRXJyb3IgZW5jb3VudGVyZWQsIGJ1dCBoYW5kbGVkIGJ5IGFuIGVhcmxpZXIgbWlkZGxld2FyZVwiLCByZXFJZCk7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgICB9XG4gICAgICBsb2coXCJbJXNdIEVSUk9SOiAlc1wiLCByZXFJZCwgZXJyLm1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlCb2R5KHJlcykge1xuICBjb25zdCBjb250ZW50VHlwZSA9IChyZXMuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBpc0pzb24gPSBjb250ZW50VHlwZS5pbmRleE9mKFwiYXBwbGljYXRpb24vanNvblwiKSAhPT0gLTE7XG4gIHJldHVybiBpc0pzb24gPyB0cnlGb3JtYXQocmVzLmJvZHkpIDogcmVzLmJvZHk7XG59XG5mdW5jdGlvbiB0cnlGb3JtYXQoYm9keSkge1xuICB0cnkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHR5cGVvZiBib2R5ID09PSBcInN0cmluZ1wiID8gSlNPTi5wYXJzZShib2R5KSA6IGJvZHk7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBhcnNlZCwgbnVsbCwgMik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBib2R5O1xuICB9XG59XG5cbmZ1bmN0aW9uIGhlYWRlcnMoX2hlYWRlcnMsIG9wdHMgPSB7fSkge1xuICByZXR1cm4ge1xuICAgIHByb2Nlc3NPcHRpb25zOiAob3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBvcHRpb25zLmhlYWRlcnMgfHwge307XG4gICAgICBvcHRpb25zLmhlYWRlcnMgPSBvcHRzLm92ZXJyaWRlID8gT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcsIF9oZWFkZXJzKSA6IE9iamVjdC5hc3NpZ24oe30sIF9oZWFkZXJzLCBleGlzdGluZyk7XG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gIH07XG59XG5cbmNsYXNzIEh0dHBFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocmVzLCBjdHgpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IHRydW5jYXRlZFVybCA9IHJlcy51cmwubGVuZ3RoID4gNDAwID8gXCJcIi5jb25jYXQocmVzLnVybC5zbGljZSgwLCAzOTkpLCBcIlxcdTIwMjZcIikgOiByZXMudXJsO1xuICAgIGxldCBtc2cgPSBcIlwiLmNvbmNhdChyZXMubWV0aG9kLCBcIi1yZXF1ZXN0IHRvIFwiKS5jb25jYXQodHJ1bmNhdGVkVXJsLCBcIiByZXN1bHRlZCBpbiBcIik7XG4gICAgbXNnICs9IFwiSFRUUCBcIi5jb25jYXQocmVzLnN0YXR1c0NvZGUsIFwiIFwiKS5jb25jYXQocmVzLnN0YXR1c01lc3NhZ2UpO1xuICAgIHRoaXMubWVzc2FnZSA9IG1zZy50cmltKCk7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlcztcbiAgICB0aGlzLnJlcXVlc3QgPSBjdHgub3B0aW9ucztcbiAgfVxufVxuZnVuY3Rpb24gaHR0cEVycm9ycygpIHtcbiAgcmV0dXJuIHtcbiAgICBvblJlc3BvbnNlOiAocmVzLCBjdHgpID0+IHtcbiAgICAgIGNvbnN0IGlzSHR0cEVycm9yID0gcmVzLnN0YXR1c0NvZGUgPj0gNDAwO1xuICAgICAgaWYgKCFpc0h0dHBFcnJvcikge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEh0dHBFcnJvcihyZXMsIGN0eCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbmplY3RSZXNwb25zZShvcHRzID0ge30pIHtcbiAgaWYgKHR5cGVvZiBvcHRzLmluamVjdCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYGluamVjdFJlc3BvbnNlYCBtaWRkbGV3YXJlIHJlcXVpcmVzIGEgYGluamVjdGAgZnVuY3Rpb25cIik7XG4gIH1cbiAgY29uc3QgaW5qZWN0ID0gZnVuY3Rpb24gaW5qZWN0MihwcmV2VmFsdWUsIGV2ZW50KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBvcHRzLmluamVjdChldmVudCwgcHJldlZhbHVlKTtcbiAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gcHJldlZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBvcHRpb25zID0gZXZlbnQuY29udGV4dC5vcHRpb25zO1xuICAgIHJldHVybiB7XG4gICAgICBib2R5OiBcIlwiLFxuICAgICAgdXJsOiBvcHRpb25zLnVybCxcbiAgICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICBoZWFkZXJzOiB7fSxcbiAgICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICAgIHN0YXR1c01lc3NhZ2U6IFwiT0tcIixcbiAgICAgIC4uLnJlc3BvbnNlXG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIHsgaW50ZXJjZXB0UmVxdWVzdDogaW5qZWN0IH07XG59XG5cbmNvbnN0IGlzQnVmZmVyID0gdHlwZW9mIEJ1ZmZlciA9PT0gXCJ1bmRlZmluZWRcIiA/ICgpID0+IGZhbHNlIDogKG9iaikgPT4gQnVmZmVyLmlzQnVmZmVyKG9iaik7XG5cbmNvbnN0IHNlcmlhbGl6ZVR5cGVzID0gW1wiYm9vbGVhblwiLCBcInN0cmluZ1wiLCBcIm51bWJlclwiXTtcbmZ1bmN0aW9uIGpzb25SZXF1ZXN0KCkge1xuICByZXR1cm4ge1xuICAgIHByb2Nlc3NPcHRpb25zOiAob3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgYm9keSA9IG9wdGlvbnMuYm9keTtcbiAgICAgIGlmICghYm9keSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzU3RyZWFtID0gdHlwZW9mIGJvZHkucGlwZSA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgY29uc3Qgc2hvdWxkU2VyaWFsaXplID0gIWlzU3RyZWFtICYmICFpc0J1ZmZlcihib2R5KSAmJiAoc2VyaWFsaXplVHlwZXMuaW5kZXhPZih0eXBlb2YgYm9keSkgIT09IC0xIHx8IEFycmF5LmlzQXJyYXkoYm9keSkgfHwgaXNQbGFpbk9iamVjdChib2R5KSk7XG4gICAgICBpZiAoIXNob3VsZFNlcmlhbGl6ZSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgIH1cbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuYm9keSksXG4gICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuaGVhZGVycywge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGpzb25SZXNwb25zZShvcHRzKSB7XG4gIHJldHVybiB7XG4gICAgb25SZXNwb25zZTogKHJlc3BvbnNlKSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gfHwgXCJcIjtcbiAgICAgIGNvbnN0IHNob3VsZERlY29kZSA9IG9wdHMgJiYgb3B0cy5mb3JjZSB8fCBjb250ZW50VHlwZS5pbmRleE9mKFwiYXBwbGljYXRpb24vanNvblwiKSAhPT0gLTE7XG4gICAgICBpZiAoIXJlc3BvbnNlLmJvZHkgfHwgIWNvbnRlbnRUeXBlIHx8ICFzaG91bGREZWNvZGUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJlc3BvbnNlLCB7IGJvZHk6IHRyeVBhcnNlKHJlc3BvbnNlLmJvZHkpIH0pO1xuICAgIH0sXG4gICAgcHJvY2Vzc09wdGlvbnM6IChvcHRpb25zKSA9PiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHsgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LCBvcHRpb25zLmhlYWRlcnMpXG4gICAgfSlcbiAgfTtcbiAgZnVuY3Rpb24gdHJ5UGFyc2UoYm9keSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShib2R5KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGVyci5tZXNzYWdlID0gXCJGYWlsZWQgdG8gcGFyc2VkIHJlc3BvbnNlIGJvZHkgYXMgSlNPTjogXCIuY29uY2F0KGVyci5tZXNzYWdlKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNCcm93c2VyT3B0aW9ucyhvcHRpb25zKSB7XG4gIHJldHVybiB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zICE9PSBudWxsICYmICEoXCJwcm90b2NvbFwiIGluIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBtdGxzKGNvbmZpZyA9IHt9KSB7XG4gIGlmICghY29uZmlnLmNhKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1aXJlZCBtdGxzIG9wdGlvbiBcImNhXCIgaXMgbWlzc2luZycpO1xuICB9XG4gIGlmICghY29uZmlnLmNlcnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmVkIG10bHMgb3B0aW9uIFwiY2VydFwiIGlzIG1pc3NpbmcnKTtcbiAgfVxuICBpZiAoIWNvbmZpZy5rZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmVkIG10bHMgb3B0aW9uIFwia2V5XCIgaXMgbWlzc2luZycpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZmluYWxpemVPcHRpb25zOiAob3B0aW9ucykgPT4ge1xuICAgICAgaWYgKGlzQnJvd3Nlck9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICB9XG4gICAgICBjb25zdCBtdGxzT3B0cyA9IHtcbiAgICAgICAgY2VydDogY29uZmlnLmNlcnQsXG4gICAgICAgIGtleTogY29uZmlnLmtleSxcbiAgICAgICAgY2E6IGNvbmZpZy5jYVxuICAgICAgfTtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCBtdGxzT3B0cyk7XG4gICAgfVxuICB9O1xufVxuXG5sZXQgYWN0dWFsR2xvYmFsID0ge307XG5pZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgYWN0dWFsR2xvYmFsID0gZ2xvYmFsVGhpcztcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICBhY3R1YWxHbG9iYWwgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgYWN0dWFsR2xvYmFsID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICBhY3R1YWxHbG9iYWwgPSBzZWxmO1xufVxudmFyIGdsb2JhbCQxID0gYWN0dWFsR2xvYmFsO1xuXG5mdW5jdGlvbiBvYnNlcnZhYmxlKG9wdHMgPSB7fSkge1xuICBjb25zdCBPYnNlcnZhYmxlID0gKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55IC0tIEBUT0RPIGNvbnNpZGVyIGRyb3BwaW5nIGNoZWNraW5nIGZvciBhIGdsb2JhbCBPYnNlcnZhYmxlIHNpbmNlIGl0J3Mgbm90IG9uIGEgc3RhbmRhcmRzIHRyYWNrXG4gICAgb3B0cy5pbXBsZW1lbnRhdGlvbiB8fCBnbG9iYWwkMS5PYnNlcnZhYmxlXG4gICk7XG4gIGlmICghT2JzZXJ2YWJsZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiYE9ic2VydmFibGVgIGlzIG5vdCBhdmFpbGFibGUgaW4gZ2xvYmFsIHNjb3BlLCBhbmQgbm8gaW1wbGVtZW50YXRpb24gd2FzIHBhc3NlZFwiXG4gICAgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG9uUmV0dXJuOiAoY2hhbm5lbHMsIGNvbnRleHQpID0+IG5ldyBPYnNlcnZhYmxlKChvYnNlcnZlcikgPT4ge1xuICAgICAgY2hhbm5lbHMuZXJyb3Iuc3Vic2NyaWJlKChlcnIpID0+IG9ic2VydmVyLmVycm9yKGVycikpO1xuICAgICAgY2hhbm5lbHMucHJvZ3Jlc3Muc3Vic2NyaWJlKFxuICAgICAgICAoZXZlbnQpID0+IG9ic2VydmVyLm5leHQoT2JqZWN0LmFzc2lnbih7IHR5cGU6IFwicHJvZ3Jlc3NcIiB9LCBldmVudCkpXG4gICAgICApO1xuICAgICAgY2hhbm5lbHMucmVzcG9uc2Uuc3Vic2NyaWJlKChyZXNwb25zZSkgPT4ge1xuICAgICAgICBvYnNlcnZlci5uZXh0KE9iamVjdC5hc3NpZ24oeyB0eXBlOiBcInJlc3BvbnNlXCIgfSwgcmVzcG9uc2UpKTtcbiAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgIH0pO1xuICAgICAgY2hhbm5lbHMucmVxdWVzdC5wdWJsaXNoKGNvbnRleHQpO1xuICAgICAgcmV0dXJuICgpID0+IGNoYW5uZWxzLmFib3J0LnB1Ymxpc2goKTtcbiAgICB9KVxuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9ncmVzcygpIHtcbiAgcmV0dXJuIHtcbiAgICBvblJlcXVlc3Q6IChldnQpID0+IHtcbiAgICAgIGlmIChldnQuYWRhcHRlciAhPT0gXCJ4aHJcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB4aHIgPSBldnQucmVxdWVzdDtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBldnQuY29udGV4dDtcbiAgICAgIGlmIChcInVwbG9hZFwiIGluIHhociAmJiBcIm9ucHJvZ3Jlc3NcIiBpbiB4aHIudXBsb2FkKSB7XG4gICAgICAgIHhoci51cGxvYWQub25wcm9ncmVzcyA9IGhhbmRsZVByb2dyZXNzKFwidXBsb2FkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKFwib25wcm9ncmVzc1wiIGluIHhocikge1xuICAgICAgICB4aHIub25wcm9ncmVzcyA9IGhhbmRsZVByb2dyZXNzKFwiZG93bmxvYWRcIik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBoYW5kbGVQcm9ncmVzcyhzdGFnZSkge1xuICAgICAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgcGVyY2VudCA9IGV2ZW50Lmxlbmd0aENvbXB1dGFibGUgPyBldmVudC5sb2FkZWQgLyBldmVudC50b3RhbCAqIDEwMCA6IC0xO1xuICAgICAgICAgIGNvbnRleHQuY2hhbm5lbHMucHJvZ3Jlc3MucHVibGlzaCh7XG4gICAgICAgICAgICBzdGFnZSxcbiAgICAgICAgICAgIHBlcmNlbnQsXG4gICAgICAgICAgICB0b3RhbDogZXZlbnQudG90YWwsXG4gICAgICAgICAgICBsb2FkZWQ6IGV2ZW50LmxvYWRlZCxcbiAgICAgICAgICAgIGxlbmd0aENvbXB1dGFibGU6IGV2ZW50Lmxlbmd0aENvbXB1dGFibGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IHByb21pc2UgPSAob3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IFByb21pc2VJbXBsZW1lbnRhdGlvbiA9IG9wdGlvbnMuaW1wbGVtZW50YXRpb24gfHwgUHJvbWlzZTtcbiAgaWYgKCFQcm9taXNlSW1wbGVtZW50YXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJgUHJvbWlzZWAgaXMgbm90IGF2YWlsYWJsZSBpbiBnbG9iYWwgc2NvcGUsIGFuZCBubyBpbXBsZW1lbnRhdGlvbiB3YXMgcGFzc2VkXCIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgb25SZXR1cm46IChjaGFubmVscywgY29udGV4dCkgPT4gbmV3IFByb21pc2VJbXBsZW1lbnRhdGlvbigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBjYW5jZWwgPSBjb250ZXh0Lm9wdGlvbnMuY2FuY2VsVG9rZW47XG4gICAgICBpZiAoY2FuY2VsKSB7XG4gICAgICAgIGNhbmNlbC5wcm9taXNlLnRoZW4oKHJlYXNvbikgPT4ge1xuICAgICAgICAgIGNoYW5uZWxzLmFib3J0LnB1Ymxpc2gocmVhc29uKTtcbiAgICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjaGFubmVscy5lcnJvci5zdWJzY3JpYmUocmVqZWN0KTtcbiAgICAgIGNoYW5uZWxzLnJlc3BvbnNlLnN1YnNjcmliZSgocmVzcG9uc2UpID0+IHtcbiAgICAgICAgcmVzb2x2ZShvcHRpb25zLm9ubHlCb2R5ID8gcmVzcG9uc2UuYm9keSA6IHJlc3BvbnNlKTtcbiAgICAgIH0pO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2hhbm5lbHMucmVxdWVzdC5wdWJsaXNoKGNvbnRleHQpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSwgMCk7XG4gICAgfSlcbiAgfTtcbn07XG5jbGFzcyBDYW5jZWwge1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5fX0NBTkNFTF9fID0gdHJ1ZTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIkNhbmNlbFwiLmNvbmNhdCh0aGlzLm1lc3NhZ2UgPyBcIjogXCIuY29uY2F0KHRoaXMubWVzc2FnZSkgOiBcIlwiKTtcbiAgfVxufVxuY29uc3QgX0NhbmNlbFRva2VuID0gY2xhc3MgX0NhbmNlbFRva2VuIHtcbiAgY29uc3RydWN0b3IoZXhlY3V0b3IpIHtcbiAgICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cbiAgICBsZXQgcmVzb2x2ZVByb21pc2UgPSBudWxsO1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgZXhlY3V0b3IoKG1lc3NhZ2UpID0+IHtcbiAgICAgIGlmICh0aGlzLnJlYXNvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnJlYXNvbiA9IG5ldyBDYW5jZWwobWVzc2FnZSk7XG4gICAgICByZXNvbHZlUHJvbWlzZSh0aGlzLnJlYXNvbik7XG4gICAgfSk7XG4gIH1cbn07XG5fQ2FuY2VsVG9rZW4uc291cmNlID0gKCkgPT4ge1xuICBsZXQgY2FuY2VsO1xuICBjb25zdCB0b2tlbiA9IG5ldyBfQ2FuY2VsVG9rZW4oKGNhbikgPT4ge1xuICAgIGNhbmNlbCA9IGNhbjtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdG9rZW4sXG4gICAgY2FuY2VsXG4gIH07XG59O1xubGV0IENhbmNlbFRva2VuID0gX0NhbmNlbFRva2VuO1xuY29uc3QgaXNDYW5jZWwgPSAodmFsdWUpID0+ICEhKHZhbHVlICYmICh2YWx1ZSA9PSBudWxsID8gdm9pZCAwIDogdmFsdWUuX19DQU5DRUxfXykpO1xucHJvbWlzZS5DYW5jZWwgPSBDYW5jZWw7XG5wcm9taXNlLkNhbmNlbFRva2VuID0gQ2FuY2VsVG9rZW47XG5wcm9taXNlLmlzQ2FuY2VsID0gaXNDYW5jZWw7XG5cbmZ1bmN0aW9uIHByb3h5KF9wcm94eSkge1xuICBpZiAoX3Byb3h5ICE9PSBmYWxzZSAmJiAoIV9wcm94eSB8fCAhX3Byb3h5Lmhvc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUHJveHkgbWlkZGxld2FyZSB0YWtlcyBhbiBvYmplY3Qgb2YgaG9zdCwgcG9ydCBhbmQgYXV0aCBwcm9wZXJ0aWVzXCIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcHJvY2Vzc09wdGlvbnM6IChvcHRpb25zKSA9PiBPYmplY3QuYXNzaWduKHsgcHJveHk6IF9wcm94eSB9LCBvcHRpb25zKVxuICB9O1xufVxuXG52YXIgZGVmYXVsdFNob3VsZFJldHJ5ID0gKGVyciwgYXR0ZW1wdCwgb3B0aW9ucykgPT4ge1xuICBpZiAob3B0aW9ucy5tZXRob2QgIT09IFwiR0VUXCIgJiYgb3B0aW9ucy5tZXRob2QgIT09IFwiSEVBRFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBlcnIuaXNOZXR3b3JrRXJyb3IgfHwgZmFsc2U7XG59O1xuXG5jb25zdCBpc1N0cmVhbSA9IChzdHJlYW0pID0+IHN0cmVhbSAhPT0gbnVsbCAmJiB0eXBlb2Ygc3RyZWFtID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBzdHJlYW0ucGlwZSA9PT0gXCJmdW5jdGlvblwiO1xudmFyIHNoYXJlZFJldHJ5ID0gKG9wdHMpID0+IHtcbiAgY29uc3QgbWF4UmV0cmllcyA9IG9wdHMubWF4UmV0cmllcyB8fCA1O1xuICBjb25zdCByZXRyeURlbGF5ID0gb3B0cy5yZXRyeURlbGF5IHx8IGdldFJldHJ5RGVsYXk7XG4gIGNvbnN0IGFsbG93UmV0cnkgPSBvcHRzLnNob3VsZFJldHJ5O1xuICByZXR1cm4ge1xuICAgIG9uRXJyb3I6IChlcnIsIGNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgICBjb25zdCBtYXggPSBvcHRpb25zLm1heFJldHJpZXMgfHwgbWF4UmV0cmllcztcbiAgICAgIGNvbnN0IHNob3VsZFJldHJ5ID0gb3B0aW9ucy5zaG91bGRSZXRyeSB8fCBhbGxvd1JldHJ5O1xuICAgICAgY29uc3QgYXR0ZW1wdE51bWJlciA9IG9wdGlvbnMuYXR0ZW1wdE51bWJlciB8fCAwO1xuICAgICAgaWYgKGlzU3RyZWFtKG9wdGlvbnMuYm9keSkpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICAgIGlmICghc2hvdWxkUmV0cnkoZXJyLCBhdHRlbXB0TnVtYmVyLCBvcHRpb25zKSB8fCBhdHRlbXB0TnVtYmVyID49IG1heCkge1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3Q29udGV4dCA9IE9iamVjdC5hc3NpZ24oe30sIGNvbnRleHQsIHtcbiAgICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyBhdHRlbXB0TnVtYmVyOiBhdHRlbXB0TnVtYmVyICsgMSB9KVxuICAgICAgfSk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IGNvbnRleHQuY2hhbm5lbHMucmVxdWVzdC5wdWJsaXNoKG5ld0NvbnRleHQpLCByZXRyeURlbGF5KGF0dGVtcHROdW1iZXIpKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcbn07XG5mdW5jdGlvbiBnZXRSZXRyeURlbGF5KGF0dGVtcHROdW0pIHtcbiAgcmV0dXJuIDEwMCAqIE1hdGgucG93KDIsIGF0dGVtcHROdW0pICsgTWF0aC5yYW5kb20oKSAqIDEwMDtcbn1cblxuY29uc3QgcmV0cnkgPSAob3B0cyA9IHt9KSA9PiBzaGFyZWRSZXRyeSh7IHNob3VsZFJldHJ5OiBkZWZhdWx0U2hvdWxkUmV0cnksIC4uLm9wdHMgfSk7XG5yZXRyeS5zaG91bGRSZXRyeSA9IGRlZmF1bHRTaG91bGRSZXRyeTtcblxuZnVuY3Rpb24gZW5jb2RlKGRhdGEpIHtcbiAgY29uc3QgcXVlcnkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIGNvbnN0IG5lc3QgPSAobmFtZSwgX3ZhbHVlKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBfdmFsdWUgaW5zdGFuY2VvZiBTZXQgPyBBcnJheS5mcm9tKF92YWx1ZSkgOiBfdmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBpZiAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIGZvciAoY29uc3QgaW5kZXggaW4gdmFsdWUpIHtcbiAgICAgICAgICBuZXN0KFwiXCIuY29uY2F0KG5hbWUsIFwiW1wiKS5jb25jYXQoaW5kZXgsIFwiXVwiKSwgdmFsdWVbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVlcnkuYXBwZW5kKFwiXCIuY29uY2F0KG5hbWUsIFwiW11cIiksIFwiXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIG9ial0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgIG5lc3QoXCJcIi5jb25jYXQobmFtZSwgXCJbXCIpLmNvbmNhdChrZXksIFwiXVwiKSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcXVlcnkuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH07XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGRhdGEpKSB7XG4gICAgbmVzdChrZXksIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcXVlcnkudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIHVybEVuY29kZWQoKSB7XG4gIHJldHVybiB7XG4gICAgcHJvY2Vzc09wdGlvbnM6IChvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBib2R5ID0gb3B0aW9ucy5ib2R5O1xuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNTdHJlYW0gPSB0eXBlb2YgYm9keS5waXBlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICBjb25zdCBzaG91bGRTZXJpYWxpemUgPSAhaXNTdHJlYW0gJiYgIWlzQnVmZmVyKGJvZHkpICYmIGlzUGxhaW5PYmplY3QoYm9keSk7XG4gICAgICBpZiAoIXNob3VsZFNlcmlhbGl6ZSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGJvZHk6IGVuY29kZShvcHRpb25zLmJvZHkpLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCJcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkS2VlcEFsaXZlKGFnZW50KSB7XG4gIHJldHVybiBmdW5jdGlvbiBrZWVwQWxpdmUoY29uZmlnID0ge30pIHtcbiAgICBjb25zdCBtcyA9IGNvbmZpZy5tcyB8fCAxZTM7XG4gICAgY29uc3QgbWF4RnJlZSA9IGNvbmZpZy5tYXhGcmVlIHx8IDI1NjtcbiAgICBjb25zdCBhZ2VudE9wdGlvbnMgPSB7XG4gICAgICBrZWVwQWxpdmU6IHRydWUsXG4gICAgICBrZWVwQWxpdmVNc2VjczogbXMsXG4gICAgICBtYXhGcmVlU29ja2V0czogbWF4RnJlZVxuICAgIH07XG4gICAgcmV0dXJuIGFnZW50KGFnZW50T3B0aW9ucyk7XG4gIH07XG59XG5cbmNvbnN0IGtlZXBBbGl2ZSA9IGJ1aWxkS2VlcEFsaXZlKGFnZW50KTtcblxuZXhwb3J0IHsgQ2FuY2VsLCBDYW5jZWxUb2tlbiwgYWdlbnQsIGJhc2UsIGRlYnVnLCBoZWFkZXJzLCBodHRwRXJyb3JzLCBpbmplY3RSZXNwb25zZSwganNvblJlcXVlc3QsIGpzb25SZXNwb25zZSwga2VlcEFsaXZlLCBtdGxzLCBvYnNlcnZhYmxlLCBwcm9ncmVzcywgcHJvbWlzZSwgcHJveHksIHJldHJ5LCB1cmxFbmNvZGVkIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1taWRkbGV3YXJlLmJyb3dzZXIuanMubWFwXG4iXSwibmFtZXMiOlsiZGVidWdJdCIsInByb2Nlc3NPcHRpb25zIiwidmFsaWRhdGVPcHRpb25zIiwiaXNQbGFpbk9iamVjdCIsImFnZW50Iiwib3B0cyIsImxlYWRpbmdTbGFzaCIsInRyYWlsaW5nU2xhc2giLCJiYXNlIiwiYmFzZVVybCIsImJhc2VVcmkiLCJyZXBsYWNlIiwib3B0aW9ucyIsInRlc3QiLCJ1cmwiLCJqb2luIiwiT2JqZWN0IiwiYXNzaWduIiwiU0VOU0lUSVZFX0hFQURFUlMiLCJoYXNPd24iLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsInJlZGFjdEtleXMiLCJzb3VyY2UiLCJyZWRhY3RlZCIsInRhcmdldCIsImtleSIsImNhbGwiLCJpbmRleE9mIiwidG9Mb3dlckNhc2UiLCJkZWJ1ZyIsInZlcmJvc2UiLCJuYW1lc3BhY2UiLCJkZWZhdWx0TG9nZ2VyIiwibG9nIiwic2hvcnRDaXJjdWl0IiwiZW5hYmxlZCIsInJlcXVlc3RJZCIsIm9uUmVxdWVzdCIsImV2ZW50IiwibWV0aG9kIiwiYm9keSIsImhlYWRlcnMiLCJyZWRhY3RTZW5zaXRpdmVIZWFkZXJzIiwiSlNPTiIsInN0cmluZ2lmeSIsIm9uUmVzcG9uc2UiLCJyZXMiLCJjb250ZXh0IiwicmVxSWQiLCJzdGF0dXNDb2RlIiwic3RhdHVzTWVzc2FnZSIsInN0cmluZ2lmeUJvZHkiLCJvbkVycm9yIiwiZXJyIiwibWVzc2FnZSIsImNvbnRlbnRUeXBlIiwiaXNKc29uIiwidHJ5Rm9ybWF0IiwicGFyc2VkIiwicGFyc2UiLCJfaGVhZGVycyIsImV4aXN0aW5nIiwib3ZlcnJpZGUiLCJIdHRwRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwiY3R4IiwidHJ1bmNhdGVkVXJsIiwibGVuZ3RoIiwiY29uY2F0Iiwic2xpY2UiLCJtc2ciLCJ0cmltIiwicmVzcG9uc2UiLCJyZXF1ZXN0IiwiaHR0cEVycm9ycyIsImlzSHR0cEVycm9yIiwiaW5qZWN0UmVzcG9uc2UiLCJpbmplY3QiLCJpbmplY3QyIiwicHJldlZhbHVlIiwiaW50ZXJjZXB0UmVxdWVzdCIsImlzQnVmZmVyIiwiQnVmZmVyIiwib2JqIiwic2VyaWFsaXplVHlwZXMiLCJqc29uUmVxdWVzdCIsImlzU3RyZWFtIiwicGlwZSIsInNob3VsZFNlcmlhbGl6ZSIsIkFycmF5IiwiaXNBcnJheSIsImpzb25SZXNwb25zZSIsInNob3VsZERlY29kZSIsImZvcmNlIiwidHJ5UGFyc2UiLCJBY2NlcHQiLCJpc0Jyb3dzZXJPcHRpb25zIiwibXRscyIsImNvbmZpZyIsImNhIiwiY2VydCIsImZpbmFsaXplT3B0aW9ucyIsIm10bHNPcHRzIiwiYWN0dWFsR2xvYmFsIiwiZ2xvYmFsVGhpcyIsIndpbmRvdyIsImdsb2JhbCIsInNlbGYiLCJnbG9iYWwkMSIsIm9ic2VydmFibGUiLCJPYnNlcnZhYmxlIiwiaW1wbGVtZW50YXRpb24iLCJvblJldHVybiIsImNoYW5uZWxzIiwib2JzZXJ2ZXIiLCJlcnJvciIsInN1YnNjcmliZSIsInByb2dyZXNzIiwibmV4dCIsInR5cGUiLCJjb21wbGV0ZSIsInB1Ymxpc2giLCJhYm9ydCIsImV2dCIsImFkYXB0ZXIiLCJ4aHIiLCJ1cGxvYWQiLCJvbnByb2dyZXNzIiwiaGFuZGxlUHJvZ3Jlc3MiLCJzdGFnZSIsInBlcmNlbnQiLCJsZW5ndGhDb21wdXRhYmxlIiwibG9hZGVkIiwidG90YWwiLCJwcm9taXNlIiwiUHJvbWlzZUltcGxlbWVudGF0aW9uIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjYW5jZWwiLCJjYW5jZWxUb2tlbiIsInRoZW4iLCJyZWFzb24iLCJvbmx5Qm9keSIsInNldFRpbWVvdXQiLCJDYW5jZWwiLCJfX0NBTkNFTF9fIiwidG9TdHJpbmciLCJfQ2FuY2VsVG9rZW4iLCJleGVjdXRvciIsIlR5cGVFcnJvciIsInJlc29sdmVQcm9taXNlIiwidG9rZW4iLCJjYW4iLCJDYW5jZWxUb2tlbiIsImlzQ2FuY2VsIiwidmFsdWUiLCJwcm94eSIsIl9wcm94eSIsImhvc3QiLCJkZWZhdWx0U2hvdWxkUmV0cnkiLCJhdHRlbXB0IiwiaXNOZXR3b3JrRXJyb3IiLCJzdHJlYW0iLCJzaGFyZWRSZXRyeSIsIm1heFJldHJpZXMiLCJyZXRyeURlbGF5IiwiZ2V0UmV0cnlEZWxheSIsImFsbG93UmV0cnkiLCJzaG91bGRSZXRyeSIsIm1heCIsImF0dGVtcHROdW1iZXIiLCJuZXdDb250ZXh0IiwiYXR0ZW1wdE51bSIsIk1hdGgiLCJwb3ciLCJyYW5kb20iLCJyZXRyeSIsImVuY29kZSIsImRhdGEiLCJxdWVyeSIsIlVSTFNlYXJjaFBhcmFtcyIsIm5lc3QiLCJuYW1lIiwiX3ZhbHVlIiwiU2V0IiwiZnJvbSIsImluZGV4IiwiYXBwZW5kIiwiZW50cmllcyIsInVybEVuY29kZWQiLCJidWlsZEtlZXBBbGl2ZSIsImtlZXBBbGl2ZSIsIm1zIiwibWF4RnJlZSIsImFnZW50T3B0aW9ucyIsImtlZXBBbGl2ZU1zZWNzIiwibWF4RnJlZVNvY2tldHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/get-it/dist/middleware.browser.js\n");

/***/ })

};
;
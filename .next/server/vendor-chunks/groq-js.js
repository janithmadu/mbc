"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/groq-js";
exports.ids = ["vendor-chunks/groq-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/groq-js/dist/1.mjs":
/*!*****************************************!*\
  !*** ./node_modules/groq-js/dist/1.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DateTime: () => (/* binding */ DateTime),\n/* harmony export */   Path: () => (/* binding */ Path),\n/* harmony export */   evaluate: () => (/* binding */ evaluateQuery),\n/* harmony export */   parse: () => (/* binding */ parse)\n/* harmony export */ });\nvar __defProp$5 = Object.defineProperty;\nvar __defNormalProp$5 = (obj, key, value)=>key in obj ? __defProp$5(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField$5 = (obj, key, value)=>{\n    __defNormalProp$5(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n};\nfunction escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction pathRegExp(pattern) {\n    const re = [];\n    for (const part of pattern.split(\".\")){\n        if (part === \"*\") {\n            re.push(\"[^.]+\");\n        } else if (part === \"**\") {\n            re.push(\".*\");\n        } else {\n            re.push(escapeRegExp(part));\n        }\n    }\n    return new RegExp(\"^\".concat(re.join(\".\"), \"$\"));\n}\nclass Path {\n    constructor(pattern){\n        __publicField$5(this, \"pattern\");\n        __publicField$5(this, \"patternRe\");\n        this.pattern = pattern;\n        this.patternRe = pathRegExp(pattern);\n    }\n    matches(str) {\n        return this.patternRe.test(str);\n    }\n    toJSON() {\n        return this.pattern;\n    }\n}\nvar __defProp$4 = Object.defineProperty;\nvar __defNormalProp$4 = (obj, key, value)=>key in obj ? __defProp$4(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField$4 = (obj, key, value)=>{\n    __defNormalProp$4(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n};\nclass StreamValue {\n    constructor(generator){\n        __publicField$4(this, \"type\", \"stream\");\n        __publicField$4(this, \"generator\");\n        __publicField$4(this, \"ticker\");\n        __publicField$4(this, \"isDone\");\n        __publicField$4(this, \"data\");\n        this.generator = generator;\n        this.ticker = null;\n        this.isDone = false;\n        this.data = [];\n    }\n    // eslint-disable-next-line class-methods-use-this\n    isArray() {\n        return true;\n    }\n    async get() {\n        const result = [];\n        for await (const value of this){\n            result.push(await value.get());\n        }\n        return result;\n    }\n    async *[Symbol.asyncIterator]() {\n        let i = 0;\n        while(true){\n            for(; i < this.data.length; i++){\n                yield this.data[i];\n            }\n            if (this.isDone) {\n                return;\n            }\n            await this._nextTick();\n        }\n    }\n    _nextTick() {\n        if (this.ticker) {\n            return this.ticker;\n        }\n        let currentResolver;\n        const setupTicker = ()=>{\n            this.ticker = new Promise((resolve)=>{\n                currentResolver = resolve;\n            });\n        };\n        const tick = ()=>{\n            currentResolver();\n            setupTicker();\n        };\n        const fetch = async ()=>{\n            for await (const value of this.generator()){\n                this.data.push(value);\n                tick();\n            }\n            this.isDone = true;\n            tick();\n        };\n        setupTicker();\n        fetch();\n        return this.ticker;\n    }\n}\nconst RFC3339_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/;\nfunction parseRFC3339(str) {\n    if (RFC3339_REGEX.test(str)) {\n        return new Date(str);\n    }\n    return null;\n}\nfunction formatRFC3339(d) {\n    const year = addLeadingZero(d.getUTCFullYear(), 4);\n    const month = addLeadingZero(d.getUTCMonth() + 1, 2);\n    const day = addLeadingZero(d.getUTCDate(), 2);\n    const hour = addLeadingZero(d.getUTCHours(), 2);\n    const minute = addLeadingZero(d.getUTCMinutes(), 2);\n    const second = addLeadingZero(d.getUTCSeconds(), 2);\n    let fractionalSecond = \"\";\n    const millis = d.getMilliseconds();\n    if (millis != 0) {\n        fractionalSecond = \".\".concat(addLeadingZero(millis, 3));\n    }\n    return \"\".concat(year, \"-\").concat(month, \"-\").concat(day, \"T\").concat(hour, \":\").concat(minute, \":\").concat(second).concat(fractionalSecond, \"Z\");\n}\nfunction addLeadingZero(num, targetLength) {\n    let str = num.toString();\n    while(str.length < targetLength){\n        str = \"0\".concat(str);\n    }\n    return str;\n}\nvar __defProp$3 = Object.defineProperty;\nvar __defNormalProp$3 = (obj, key, value)=>key in obj ? __defProp$3(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField$3 = (obj, key, value)=>{\n    __defNormalProp$3(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n};\nclass StaticValue {\n    constructor(data, type){\n        __publicField$3(this, \"data\");\n        __publicField$3(this, \"type\");\n        this.data = data;\n        this.type = type;\n    }\n    isArray() {\n        return this.type === \"array\";\n    }\n    // eslint-disable-next-line require-await\n    async get() {\n        return this.data;\n    }\n    [Symbol.asyncIterator]() {\n        if (Array.isArray(this.data)) {\n            return function*(data) {\n                for (const element of data){\n                    yield fromJS(element);\n                }\n            }(this.data);\n        }\n        throw new Error(\"Cannot iterate over: \".concat(this.type));\n    }\n}\nconst NULL_VALUE = new StaticValue(null, \"null\");\nconst TRUE_VALUE = new StaticValue(true, \"boolean\");\nconst FALSE_VALUE = new StaticValue(false, \"boolean\");\nclass DateTime {\n    constructor(date){\n        __publicField$3(this, \"date\");\n        this.date = date;\n    }\n    static parseToValue(str) {\n        const date = parseRFC3339(str);\n        if (date) {\n            return new StaticValue(new DateTime(date), \"datetime\");\n        }\n        return NULL_VALUE;\n    }\n    equals(other) {\n        return this.date.getTime() == other.date.getTime();\n    }\n    add(secs) {\n        const copy = new Date(this.date.getTime());\n        copy.setTime(copy.getTime() + secs * 1e3);\n        return new DateTime(copy);\n    }\n    difference(other) {\n        return (this.date.getTime() - other.date.getTime()) / 1e3;\n    }\n    compareTo(other) {\n        return this.date.getTime() - other.date.getTime();\n    }\n    toString() {\n        return formatRFC3339(this.date);\n    }\n    toJSON() {\n        return this.toString();\n    }\n}\nfunction fromNumber(num) {\n    if (Number.isFinite(num)) {\n        return new StaticValue(num, \"number\");\n    }\n    return NULL_VALUE;\n}\nfunction fromString(str) {\n    return new StaticValue(str, \"string\");\n}\nfunction fromDateTime(dt) {\n    return new StaticValue(dt, \"datetime\");\n}\nfunction fromPath(path) {\n    return new StaticValue(path, \"path\");\n}\nfunction isIterator(obj) {\n    return obj && typeof obj.next === \"function\";\n}\nfunction fromJS(val) {\n    if (isIterator(val)) {\n        return new StreamValue(async function*() {\n            for await (const value of val){\n                yield fromJS(value);\n            }\n        });\n    } else if (val === null || val === void 0) {\n        return NULL_VALUE;\n    }\n    return new StaticValue(val, getType(val));\n}\nfunction getType(data) {\n    if (data === null || typeof data === \"undefined\") {\n        return \"null\";\n    }\n    if (Array.isArray(data)) {\n        return \"array\";\n    }\n    if (data instanceof Path) {\n        return \"path\";\n    }\n    if (data instanceof DateTime) {\n        return \"datetime\";\n    }\n    return typeof data;\n}\nfunction isEqual(a, b) {\n    if (a.type === \"string\" && b.type === \"string\" || a.type === \"boolean\" && b.type === \"boolean\" || a.type === \"null\" && b.type === \"null\" || a.type === \"number\" && b.type === \"number\") {\n        return a.data === b.data;\n    }\n    if (a.type === \"datetime\" && b.type === \"datetime\") {\n        return a.data.equals(b.data);\n    }\n    return false;\n}\nconst CHARS = /([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g;\nconst CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g;\nconst EDGE_CHARS = /(\\b\\.+|\\.+\\b)/g;\nconst MAX_TERM_LENGTH = 1024;\nfunction matchText(tokens, patterns) {\n    if (tokens.length === 0 || patterns.length === 0) {\n        return false;\n    }\n    return patterns.every((pattern)=>pattern(tokens));\n}\nfunction matchTokenize(text) {\n    return text.replace(EDGE_CHARS, \"\").match(CHARS) || [];\n}\nfunction matchAnalyzePattern(text) {\n    const termsRe = matchPatternRegex(text);\n    return termsRe.map((re)=>(tokens)=>tokens.some((token)=>re.test(token)));\n}\nfunction matchPatternRegex(text) {\n    const terms = text.replace(EDGE_CHARS, \"\").match(CHARS_WITH_WILDCARD) || [];\n    return terms.map((term)=>new RegExp(\"^\".concat(term.slice(0, MAX_TERM_LENGTH).replace(/\\*/g, \".*\"), \"$\"), \"i\"));\n}\nasync function gatherText(value, cb) {\n    if (value.type === \"string\") {\n        cb(value.data);\n        return true;\n    }\n    if (value.isArray()) {\n        let success = true;\n        for await (const part of value){\n            if (part.type === \"string\") {\n                cb(part.data);\n            } else {\n                success = false;\n            }\n        }\n        return success;\n    }\n    return false;\n}\nconst TYPE_ORDER = {\n    datetime: 1,\n    number: 2,\n    string: 3,\n    boolean: 4\n};\nfunction partialCompare(a, b) {\n    const aType = getType(a);\n    const bType = getType(b);\n    if (aType !== bType) {\n        return null;\n    }\n    switch(aType){\n        case \"number\":\n        case \"boolean\":\n            return a - b;\n        case \"string\":\n            if (a < b) return -1;\n            if (a > b) return 1;\n            return 0;\n        case \"datetime\":\n            return a.compareTo(b);\n        default:\n            return null;\n    }\n}\nfunction totalCompare(a, b) {\n    const aType = getType(a);\n    const bType = getType(b);\n    const aTypeOrder = TYPE_ORDER[aType] || 100;\n    const bTypeOrder = TYPE_ORDER[bType] || 100;\n    if (aTypeOrder !== bTypeOrder) {\n        return aTypeOrder - bTypeOrder;\n    }\n    let result = partialCompare(a, b);\n    if (result === null) {\n        result = 0;\n    }\n    return result;\n}\nconst operators = {\n    \"==\": function eq(left, right) {\n        return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE;\n    },\n    \"!=\": function neq(left, right) {\n        return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE;\n    },\n    \">\": function gt(left, right) {\n        if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n        const result = partialCompare(left.data, right.data);\n        if (result === null) {\n            return NULL_VALUE;\n        }\n        return result > 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    \">=\": function gte(left, right) {\n        if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n        const result = partialCompare(left.data, right.data);\n        if (result === null) {\n            return NULL_VALUE;\n        }\n        return result >= 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    \"<\": function lt(left, right) {\n        if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n        const result = partialCompare(left.data, right.data);\n        if (result === null) {\n            return NULL_VALUE;\n        }\n        return result < 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    \"<=\": function lte(left, right) {\n        if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n        const result = partialCompare(left.data, right.data);\n        if (result === null) {\n            return NULL_VALUE;\n        }\n        return result <= 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    // eslint-disable-next-line func-name-matching\n    in: async function inop(left, right) {\n        if (right.type === \"path\") {\n            if (left.type !== \"string\") {\n                return NULL_VALUE;\n            }\n            return right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE;\n        }\n        if (right.isArray()) {\n            for await (const b of right){\n                if (isEqual(left, b)) {\n                    return TRUE_VALUE;\n                }\n            }\n            return FALSE_VALUE;\n        }\n        return NULL_VALUE;\n    },\n    match: async function match(left, right) {\n        let tokens = [];\n        let patterns = [];\n        await gatherText(left, (part)=>{\n            tokens = tokens.concat(matchTokenize(part));\n        });\n        const didSucceed = await gatherText(right, (part)=>{\n            patterns = patterns.concat(matchAnalyzePattern(part));\n        });\n        if (!didSucceed) {\n            return FALSE_VALUE;\n        }\n        const matched = matchText(tokens, patterns);\n        return matched ? TRUE_VALUE : FALSE_VALUE;\n    },\n    \"+\": function plus(left, right) {\n        if (left.type === \"datetime\" && right.type === \"number\") {\n            return fromDateTime(left.data.add(right.data));\n        }\n        if (left.type === \"number\" && right.type === \"number\") {\n            return fromNumber(left.data + right.data);\n        }\n        if (left.type === \"string\" && right.type === \"string\") {\n            return fromString(left.data + right.data);\n        }\n        if (left.type === \"object\" && right.type === \"object\") {\n            return fromJS({\n                ...left.data,\n                ...right.data\n            });\n        }\n        if (left.type === \"array\" && right.type === \"array\") {\n            return fromJS(left.data.concat(right.data));\n        }\n        if (left.isArray() && right.isArray()) {\n            return new StreamValue(async function*() {\n                for await (const val of left){\n                    yield val;\n                }\n                for await (const val of right){\n                    yield val;\n                }\n            });\n        }\n        return NULL_VALUE;\n    },\n    \"-\": function minus(left, right) {\n        if (left.type === \"datetime\" && right.type === \"number\") {\n            return fromDateTime(left.data.add(-right.data));\n        }\n        if (left.type === \"datetime\" && right.type === \"datetime\") {\n            return fromNumber(left.data.difference(right.data));\n        }\n        if (left.type === \"number\" && right.type === \"number\") {\n            return fromNumber(left.data - right.data);\n        }\n        return NULL_VALUE;\n    },\n    \"*\": numericOperator((a, b)=>a * b),\n    \"/\": numericOperator((a, b)=>a / b),\n    \"%\": numericOperator((a, b)=>a % b),\n    \"**\": numericOperator((a, b)=>Math.pow(a, b))\n};\nfunction numericOperator(impl) {\n    return function(left, right) {\n        if (left.type === \"number\" && right.type === \"number\") {\n            const result = impl(left.data, right.data);\n            return fromNumber(result);\n        }\n        return NULL_VALUE;\n    };\n}\nvar __defProp$2 = Object.defineProperty;\nvar __defNormalProp$2 = (obj, key, value)=>key in obj ? __defProp$2(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField$2 = (obj, key, value)=>{\n    __defNormalProp$2(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n};\nclass Scope {\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    constructor(params, source, value, context, parent){\n        __publicField$2(this, \"params\");\n        __publicField$2(this, \"source\");\n        __publicField$2(this, \"value\");\n        __publicField$2(this, \"parent\");\n        __publicField$2(this, \"context\");\n        __publicField$2(this, \"isHidden\", false);\n        this.params = params;\n        this.source = source;\n        this.value = value;\n        this.context = context;\n        this.parent = parent;\n    }\n    createNested(value) {\n        if (this.isHidden) {\n            return new Scope(this.params, this.source, value, this.context, this.parent);\n        }\n        return new Scope(this.params, this.source, value, this.context, this);\n    }\n    createHidden(value) {\n        const result = this.createNested(value);\n        result.isHidden = true;\n        return result;\n    }\n}\nfunction evaluate(node, scope, execute = evaluate) {\n    const func = EXECUTORS[node.type];\n    return func(node, scope, execute);\n}\nfunction promiselessApply(value, cb) {\n    if (\"then\" in value) {\n        return value.then(cb);\n    }\n    return cb(value);\n}\nconst EXECUTORS = {\n    This (_, scope) {\n        return scope.value;\n    },\n    Selector () {\n        throw new Error(\"Selectors can not be evaluated\");\n    },\n    Everything (_, scope) {\n        return scope.source;\n    },\n    Parameter ({ name }, scope) {\n        return fromJS(scope.params[name]);\n    },\n    Context ({ key }, scope) {\n        if (key === \"before\" || key === \"after\") {\n            const value = scope.context[key];\n            return value || NULL_VALUE;\n        }\n        throw new Error(\"unknown context key: \".concat(key));\n    },\n    Parent ({ n }, scope) {\n        let current = scope;\n        for(let i = 0; i < n; i++){\n            if (!current.parent) {\n                return NULL_VALUE;\n            }\n            current = current.parent;\n        }\n        return current.value;\n    },\n    OpCall ({ op, left, right }, scope, execute) {\n        const func = operators[op];\n        if (!func) {\n            throw new Error(\"Unknown operator: \".concat(op));\n        }\n        const leftValue = execute(left, scope);\n        const rightValue = execute(right, scope);\n        if (\"then\" in leftValue || \"then\" in rightValue) {\n            return (async ()=>func(await leftValue, await rightValue))();\n        }\n        return func(leftValue, rightValue);\n    },\n    async Select ({ alternatives, fallback }, scope, execute) {\n        for (const alt of alternatives){\n            const altCond = await execute(alt.condition, scope);\n            if (altCond.type === \"boolean\" && altCond.data === true) {\n                return execute(alt.value, scope);\n            }\n        }\n        if (fallback) {\n            return execute(fallback, scope);\n        }\n        return NULL_VALUE;\n    },\n    async InRange ({ base, left, right, isInclusive }, scope, execute) {\n        const value = await execute(base, scope);\n        const leftValue = await execute(left, scope);\n        const rightValue = await execute(right, scope);\n        const leftCmp = partialCompare(await value.get(), await leftValue.get());\n        if (leftCmp === null) {\n            return NULL_VALUE;\n        }\n        const rightCmp = partialCompare(await value.get(), await rightValue.get());\n        if (rightCmp === null) {\n            return NULL_VALUE;\n        }\n        if (isInclusive) {\n            return leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE;\n        }\n        return leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    async Filter ({ base, expr }, scope, execute) {\n        const baseValue = await execute(base, scope);\n        if (!baseValue.isArray()) {\n            return NULL_VALUE;\n        }\n        return new StreamValue(async function*() {\n            for await (const elem of baseValue){\n                const newScope = scope.createNested(elem);\n                const exprValue = await execute(expr, newScope);\n                if (exprValue.type === \"boolean\" && exprValue.data === true) {\n                    yield elem;\n                }\n            }\n        });\n    },\n    async Projection ({ base, expr }, scope, execute) {\n        const baseValue = await execute(base, scope);\n        if (baseValue.type !== \"object\") {\n            return NULL_VALUE;\n        }\n        const newScope = scope.createNested(baseValue);\n        return execute(expr, newScope);\n    },\n    FuncCall ({ func, args }, scope, execute) {\n        return func(args, scope, execute);\n    },\n    async PipeFuncCall ({ func, base, args }, scope, execute) {\n        const baseValue = await execute(base, scope);\n        return func(baseValue, args, scope, execute);\n    },\n    async AccessAttribute ({ base, name }, scope, execute) {\n        let value = scope.value;\n        if (base) {\n            value = await execute(base, scope);\n        }\n        if (value.type === \"object\") {\n            if (value.data.hasOwnProperty(name)) {\n                return fromJS(value.data[name]);\n            }\n        }\n        return NULL_VALUE;\n    },\n    async AccessElement ({ base, index }, scope, execute) {\n        const baseValue = await execute(base, scope);\n        if (!baseValue.isArray()) {\n            return NULL_VALUE;\n        }\n        const data = await baseValue.get();\n        const finalIndex = index < 0 ? index + data.length : index;\n        return fromJS(data[finalIndex]);\n    },\n    async Slice ({ base, left, right, isInclusive }, scope, execute) {\n        const baseValue = await execute(base, scope);\n        if (!baseValue.isArray()) {\n            return NULL_VALUE;\n        }\n        const array = await baseValue.get();\n        let leftIdx = left;\n        let rightIdx = right;\n        if (leftIdx < 0) {\n            leftIdx = array.length + leftIdx;\n        }\n        if (rightIdx < 0) {\n            rightIdx = array.length + rightIdx;\n        }\n        if (isInclusive) {\n            rightIdx++;\n        }\n        if (leftIdx < 0) {\n            leftIdx = 0;\n        }\n        if (rightIdx < 0) {\n            rightIdx = 0;\n        }\n        return fromJS(array.slice(leftIdx, rightIdx));\n    },\n    async Deref ({ base }, scope, execute) {\n        const value = await execute(base, scope);\n        if (!scope.source.isArray()) {\n            return NULL_VALUE;\n        }\n        if (value.type !== \"object\") {\n            return NULL_VALUE;\n        }\n        const id = value.data._ref;\n        if (typeof id !== \"string\") {\n            return NULL_VALUE;\n        }\n        if (scope.context.dereference) {\n            return fromJS(await scope.context.dereference({\n                _ref: id\n            }));\n        }\n        for await (const doc of scope.source){\n            if (doc.type === \"object\" && id === doc.data._id) {\n                return doc;\n            }\n        }\n        return NULL_VALUE;\n    },\n    Value ({ value }) {\n        return fromJS(value);\n    },\n    Group ({ base }, scope, execute) {\n        return execute(base, scope);\n    },\n    async Object ({ attributes }, scope, execute) {\n        const result = {};\n        for (const attr of attributes){\n            const attrType = attr.type;\n            switch(attr.type){\n                case \"ObjectAttributeValue\":\n                    {\n                        const value = await execute(attr.value, scope);\n                        result[attr.name] = await value.get();\n                        break;\n                    }\n                case \"ObjectConditionalSplat\":\n                    {\n                        const cond = await execute(attr.condition, scope);\n                        if (cond.type !== \"boolean\" || cond.data === false) {\n                            continue;\n                        }\n                        const value = await execute(attr.value, scope);\n                        if (value.type === \"object\") {\n                            Object.assign(result, value.data);\n                        }\n                        break;\n                    }\n                case \"ObjectSplat\":\n                    {\n                        const value = await execute(attr.value, scope);\n                        if (value.type === \"object\") {\n                            Object.assign(result, value.data);\n                        }\n                        break;\n                    }\n                default:\n                    throw new Error(\"Unknown node type: \".concat(attrType));\n            }\n        }\n        return fromJS(result);\n    },\n    Array ({ elements }, scope, execute) {\n        return new StreamValue(async function*() {\n            for (const element of elements){\n                const value = await execute(element.value, scope);\n                if (element.isSplat) {\n                    if (value.isArray()) {\n                        for await (const v of value){\n                            yield v;\n                        }\n                    }\n                } else {\n                    yield value;\n                }\n            }\n        });\n    },\n    Tuple () {\n        throw new Error(\"tuples can not be evaluated\");\n    },\n    async Or ({ left, right }, scope, execute) {\n        const leftValue = await execute(left, scope);\n        const rightValue = await execute(right, scope);\n        if (leftValue.type === \"boolean\") {\n            if (leftValue.data === true) {\n                return TRUE_VALUE;\n            }\n        }\n        if (rightValue.type === \"boolean\") {\n            if (rightValue.data === true) {\n                return TRUE_VALUE;\n            }\n        }\n        if (leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\") {\n            return NULL_VALUE;\n        }\n        return FALSE_VALUE;\n    },\n    async And ({ left, right }, scope, execute) {\n        const leftValue = await execute(left, scope);\n        const rightValue = await execute(right, scope);\n        if (leftValue.type === \"boolean\") {\n            if (leftValue.data === false) {\n                return FALSE_VALUE;\n            }\n        }\n        if (rightValue.type === \"boolean\") {\n            if (rightValue.data === false) {\n                return FALSE_VALUE;\n            }\n        }\n        if (leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\") {\n            return NULL_VALUE;\n        }\n        return TRUE_VALUE;\n    },\n    async Not ({ base }, scope, execute) {\n        const value = await execute(base, scope);\n        if (value.type !== \"boolean\") {\n            return NULL_VALUE;\n        }\n        return value.data ? FALSE_VALUE : TRUE_VALUE;\n    },\n    Neg ({ base }, scope, execute) {\n        return promiselessApply(execute(base, scope), (value)=>{\n            if (value.type !== \"number\") {\n                return NULL_VALUE;\n            }\n            return fromNumber(-value.data);\n        });\n    },\n    Pos ({ base }, scope, execute) {\n        return promiselessApply(execute(base, scope), (value)=>{\n            if (value.type !== \"number\") {\n                return NULL_VALUE;\n            }\n            return fromNumber(value.data);\n        });\n    },\n    Asc () {\n        return NULL_VALUE;\n    },\n    Desc () {\n        return NULL_VALUE;\n    },\n    async ArrayCoerce ({ base }, scope, execute) {\n        const value = await execute(base, scope);\n        return value.isArray() ? value : NULL_VALUE;\n    },\n    async Map ({ base, expr }, scope, execute) {\n        const value = await execute(base, scope);\n        if (!value.isArray()) {\n            return NULL_VALUE;\n        }\n        return new StreamValue(async function*() {\n            for await (const elem of value){\n                const newScope = scope.createHidden(elem);\n                yield await execute(expr, newScope);\n            }\n        });\n    },\n    async FlatMap ({ base, expr }, scope, execute) {\n        const value = await execute(base, scope);\n        if (!value.isArray()) {\n            return NULL_VALUE;\n        }\n        return new StreamValue(async function*() {\n            for await (const elem of value){\n                const newScope = scope.createHidden(elem);\n                const innerValue = await execute(expr, newScope);\n                if (innerValue.isArray()) {\n                    for await (const inner of innerValue){\n                        yield inner;\n                    }\n                } else {\n                    yield innerValue;\n                }\n            }\n        });\n    }\n};\nfunction evaluateQuery(tree, options = {}) {\n    const root = fromJS(options.root);\n    const dataset = fromJS(options.dataset);\n    const params = {\n        ...options.params\n    };\n    const scope = new Scope(params, dataset, root, {\n        timestamp: options.timestamp || /* @__PURE__ */ new Date(),\n        identity: options.identity === void 0 ? \"me\" : options.identity,\n        sanity: options.sanity,\n        after: options.after ? fromJS(options.after) : null,\n        before: options.before ? fromJS(options.before) : null,\n        dereference: options.dereference\n    }, null);\n    return evaluate(tree, scope);\n}\nfunction canConstantEvaluate(node) {\n    switch(node.type){\n        case \"Group\":\n            return canConstantEvaluate(node.base);\n        case \"Value\":\n        case \"Parameter\":\n            return true;\n        case \"Pos\":\n        case \"Neg\":\n            return canConstantEvaluate(node.base);\n        case \"OpCall\":\n            switch(node.op){\n                case \"+\":\n                case \"-\":\n                case \"*\":\n                case \"/\":\n                case \"%\":\n                case \"**\":\n                    return canConstantEvaluate(node.left) && canConstantEvaluate(node.right);\n                default:\n                    return false;\n            }\n        default:\n            return false;\n    }\n}\nconst DUMMY_SCOPE = new Scope({}, NULL_VALUE, NULL_VALUE, {\n    timestamp: /* @__PURE__ */ new Date(0),\n    identity: \"me\",\n    before: null,\n    after: null\n}, null);\nfunction tryConstantEvaluate(node) {\n    if (!canConstantEvaluate(node)) {\n        return null;\n    }\n    return constantEvaluate(node);\n}\nfunction constantEvaluate(node) {\n    const value = evaluate(node, DUMMY_SCOPE, constantEvaluate);\n    if (\"then\" in value) {\n        throw new Error(\"BUG: constant evaluate should never return a promise\");\n    }\n    return value;\n}\nasync function portableTextContent(value) {\n    if (value.type === \"object\") {\n        return blockText(value.data);\n    } else if (value.isArray()) {\n        const texts = await arrayText(value);\n        if (texts.length > 0) {\n            return texts.join(\"\\n\\n\");\n        }\n    }\n    return null;\n}\nasync function arrayText(value, result = []) {\n    for await (const block of value){\n        if (block.type === \"object\") {\n            const text = blockText(block.data);\n            if (text !== null) result.push(text);\n        } else if (block.isArray()) {\n            await arrayText(block, result);\n        }\n    }\n    return result;\n}\nfunction blockText(obj) {\n    if (typeof obj._type !== \"string\") return null;\n    const children = obj.children;\n    if (!Array.isArray(children)) return null;\n    let result = \"\";\n    for (const child of children){\n        if (child && typeof child === \"object\" && typeof child._type === \"string\" && child._type === \"span\" && typeof child.text === \"string\") {\n            result += child.text;\n        }\n    }\n    return result;\n}\nconst BM25k = 1.2;\nasync function evaluateScore(node, scope, execute) {\n    if (node.type === \"OpCall\" && node.op === \"match\") {\n        return evaluateMatchScore(node.left, node.right, scope, execute);\n    }\n    if (node.type === \"FuncCall\" && node.name === \"boost\") {\n        const innerScore = await evaluateScore(node.args[0], scope, execute);\n        const boost = await execute(node.args[1], scope);\n        if (boost.type === \"number\" && innerScore > 0) {\n            return innerScore + boost.data;\n        }\n        return 0;\n    }\n    switch(node.type){\n        case \"Or\":\n            {\n                const leftScore = await evaluateScore(node.left, scope, execute);\n                const rightScore = await evaluateScore(node.right, scope, execute);\n                return leftScore + rightScore;\n            }\n        case \"And\":\n            {\n                const leftScore = await evaluateScore(node.left, scope, execute);\n                const rightScore = await evaluateScore(node.right, scope, execute);\n                if (leftScore === 0 || rightScore === 0) return 0;\n                return leftScore + rightScore;\n            }\n        default:\n            {\n                const res = await execute(node, scope);\n                return res.type === \"boolean\" && res.data === true ? 1 : 0;\n            }\n    }\n}\nasync function evaluateMatchScore(left, right, scope, execute) {\n    const text = await execute(left, scope);\n    const pattern = await execute(right, scope);\n    let tokens = [];\n    let terms = [];\n    await gatherText(text, (part)=>{\n        tokens = tokens.concat(matchTokenize(part));\n    });\n    const didSucceed = await gatherText(pattern, (part)=>{\n        terms = terms.concat(matchPatternRegex(part));\n    });\n    if (!didSucceed) {\n        return 0;\n    }\n    if (tokens.length === 0 || terms.length === 0) {\n        return 0;\n    }\n    let score = 0;\n    for (const re of terms){\n        const freq = tokens.reduce((c, token)=>c + (re.test(token) ? 1 : 0), 0);\n        score += freq * (BM25k + 1) / (freq + BM25k);\n    }\n    return score;\n}\nfunction hasReference(value, pathSet) {\n    switch(getType(value)){\n        case \"array\":\n            for (const v of value){\n                if (hasReference(v, pathSet)) {\n                    return true;\n                }\n            }\n            break;\n        case \"object\":\n            if (value._ref) {\n                return pathSet.has(value._ref);\n            }\n            for (const v of Object.values(value)){\n                if (hasReference(v, pathSet)) {\n                    return true;\n                }\n            }\n            break;\n    }\n    return false;\n}\nfunction countUTF8(str) {\n    let count2 = 0;\n    for(let i = 0; i < str.length; i++){\n        const code = str.charCodeAt(i);\n        if (code >= 55296 && code <= 56319) {\n            continue;\n        }\n        count2++;\n    }\n    return count2;\n}\nconst _global = {};\n_global.anywhere = async function anywhere() {\n    throw new Error(\"not implemented\");\n};\n_global.anywhere.arity = 1;\n_global.coalesce = async function coalesce(args, scope, execute) {\n    for (const arg of args){\n        const value = await execute(arg, scope);\n        if (value.type !== \"null\") {\n            return value;\n        }\n    }\n    return NULL_VALUE;\n};\n_global.count = async function count(args, scope, execute) {\n    const inner = await execute(args[0], scope);\n    if (!inner.isArray()) {\n        return NULL_VALUE;\n    }\n    let num = 0;\n    for await (const _ of inner){\n        num++;\n    }\n    return fromNumber(num);\n};\n_global.count.arity = 1;\n_global.dateTime = async function dateTime(args, scope, execute) {\n    const val = await execute(args[0], scope);\n    if (val.type === \"datetime\") {\n        return val;\n    }\n    if (val.type !== \"string\") {\n        return NULL_VALUE;\n    }\n    return DateTime.parseToValue(val.data);\n};\n_global.dateTime.arity = 1;\n_global.defined = async function defined(args, scope, execute) {\n    const inner = await execute(args[0], scope);\n    return inner.type === \"null\" ? FALSE_VALUE : TRUE_VALUE;\n};\n_global.defined.arity = 1;\n_global.identity = async function identity(args, scope) {\n    return fromString(scope.context.identity);\n};\n_global.identity.arity = 0;\n_global.length = async function length(args, scope, execute) {\n    const inner = await execute(args[0], scope);\n    if (inner.type === \"string\") {\n        return fromNumber(countUTF8(inner.data));\n    }\n    if (inner.isArray()) {\n        let num = 0;\n        for await (const _ of inner){\n            num++;\n        }\n        return fromNumber(num);\n    }\n    return NULL_VALUE;\n};\n_global.length.arity = 1;\n_global.path = async function path(args, scope, execute) {\n    const inner = await execute(args[0], scope);\n    if (inner.type !== \"string\") {\n        return NULL_VALUE;\n    }\n    return fromPath(new Path(inner.data));\n};\n_global.path.arity = 1;\n_global.string = async function string(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    switch(value.type){\n        case \"number\":\n        case \"string\":\n        case \"boolean\":\n        case \"datetime\":\n            return fromString(\"\".concat(value.data));\n        default:\n            return NULL_VALUE;\n    }\n};\n_global.string.arity = 1;\n_global.references = async function references(args, scope, execute) {\n    const pathSet = /* @__PURE__ */ new Set();\n    for (const arg of args){\n        const path2 = await execute(arg, scope);\n        if (path2.type === \"string\") {\n            pathSet.add(path2.data);\n        } else if (path2.isArray()) {\n            for await (const elem of path2){\n                if (elem.type === \"string\") {\n                    pathSet.add(elem.data);\n                }\n            }\n        }\n    }\n    if (pathSet.size === 0) {\n        return FALSE_VALUE;\n    }\n    const scopeValue = await scope.value.get();\n    return hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE;\n};\n_global.references.arity = (c)=>c >= 1;\n_global.round = async function round(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    if (value.type !== \"number\") {\n        return NULL_VALUE;\n    }\n    const num = value.data;\n    let prec = 0;\n    if (args.length === 2) {\n        const precValue = await execute(args[1], scope);\n        if (precValue.type !== \"number\" || precValue.data < 0 || !Number.isInteger(precValue.data)) {\n            return NULL_VALUE;\n        }\n        prec = precValue.data;\n    }\n    if (prec === 0) {\n        if (num < 0) {\n            return fromNumber(-Math.round(-num));\n        }\n        return fromNumber(Math.round(num));\n    }\n    return fromNumber(Number(num.toFixed(prec)));\n};\n_global.round.arity = (count2)=>count2 >= 1 && count2 <= 2;\n_global.now = async function now(args, scope) {\n    return fromString(scope.context.timestamp.toISOString());\n};\n_global.now.arity = 0;\n_global.boost = async function boost() {\n    throw new Error(\"unexpected boost call\");\n};\n_global.boost.arity = 2;\nconst string2 = {};\nstring2.lower = async function(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    if (value.type !== \"string\") {\n        return NULL_VALUE;\n    }\n    return fromString(value.data.toLowerCase());\n};\nstring2.lower.arity = 1;\nstring2.upper = async function(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    if (value.type !== \"string\") {\n        return NULL_VALUE;\n    }\n    return fromString(value.data.toUpperCase());\n};\nstring2.upper.arity = 1;\nstring2.split = async function(args, scope, execute) {\n    const str = await execute(args[0], scope);\n    if (str.type !== \"string\") {\n        return NULL_VALUE;\n    }\n    const sep = await execute(args[1], scope);\n    if (sep.type !== \"string\") {\n        return NULL_VALUE;\n    }\n    if (str.data.length === 0) {\n        return fromJS([]);\n    }\n    if (sep.data.length === 0) {\n        return fromJS(Array.from(str.data));\n    }\n    return fromJS(str.data.split(sep.data));\n};\nstring2.split.arity = 2;\n_global.lower = string2.lower;\n_global.upper = string2.upper;\nstring2.startsWith = async function(args, scope, execute) {\n    const str = await execute(args[0], scope);\n    if (str.type !== \"string\") {\n        return NULL_VALUE;\n    }\n    const prefix = await execute(args[1], scope);\n    if (prefix.type !== \"string\") {\n        return NULL_VALUE;\n    }\n    return str.data.startsWith(prefix.data) ? TRUE_VALUE : FALSE_VALUE;\n};\nstring2.startsWith.arity = 2;\nconst array = {};\narray.join = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) {\n        return NULL_VALUE;\n    }\n    const sep = await execute(args[1], scope);\n    if (sep.type !== \"string\") {\n        return NULL_VALUE;\n    }\n    let buf = \"\";\n    let needSep = false;\n    for await (const elem of arr){\n        if (needSep) {\n            buf += sep.data;\n        }\n        switch(elem.type){\n            case \"number\":\n            case \"string\":\n            case \"boolean\":\n            case \"datetime\":\n                buf += \"\".concat(elem.data);\n                break;\n            default:\n                return NULL_VALUE;\n        }\n        needSep = true;\n    }\n    return fromJS(buf);\n};\narray.join.arity = 2;\narray.compact = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) {\n        return NULL_VALUE;\n    }\n    return new StreamValue(async function*() {\n        for await (const elem of arr){\n            if (elem.type !== \"null\") {\n                yield elem;\n            }\n        }\n    });\n};\narray.compact.arity = 1;\narray.unique = async function(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    if (!value.isArray()) {\n        return NULL_VALUE;\n    }\n    return new StreamValue(async function*() {\n        const added = /* @__PURE__ */ new Set();\n        for await (const iter of value){\n            switch(iter.type){\n                case \"number\":\n                case \"string\":\n                case \"boolean\":\n                case \"datetime\":\n                    if (!added.has(iter.data)) {\n                        added.add(iter.data);\n                        yield iter;\n                    }\n                    break;\n                default:\n                    yield iter;\n            }\n        }\n    });\n};\narray.unique.arity = 1;\nconst pt = {};\npt.text = async function(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    const text = await portableTextContent(value);\n    if (text === null) {\n        return NULL_VALUE;\n    }\n    return fromString(text);\n};\npt.text.arity = 1;\nconst sanity = {};\nsanity.projectId = async function(args, scope) {\n    if (scope.context.sanity) {\n        return fromString(scope.context.sanity.projectId);\n    }\n    return NULL_VALUE;\n};\nsanity.dataset = async function(args, scope) {\n    if (scope.context.sanity) {\n        return fromString(scope.context.sanity.dataset);\n    }\n    return NULL_VALUE;\n};\nconst pipeFunctions = {};\npipeFunctions.order = async function order(base, args, scope, execute) {\n    await true;\n    if (!base.isArray()) {\n        return NULL_VALUE;\n    }\n    const mappers = [];\n    const directions = [];\n    let n = 0;\n    for (let mapper of args){\n        let direction = \"asc\";\n        if (mapper.type === \"Desc\") {\n            direction = \"desc\";\n            mapper = mapper.base;\n        } else if (mapper.type === \"Asc\") {\n            mapper = mapper.base;\n        }\n        mappers.push(mapper);\n        directions.push(direction);\n        n++;\n    }\n    const aux = [];\n    let idx = 0;\n    for await (const value of base){\n        const newScope = scope.createNested(value);\n        const tuple = [\n            await value.get(),\n            idx\n        ];\n        for(let i = 0; i < n; i++){\n            const result = await execute(mappers[i], newScope);\n            tuple.push(await result.get());\n        }\n        aux.push(tuple);\n        idx++;\n    }\n    aux.sort((aTuple, bTuple)=>{\n        for(let i = 0; i < n; i++){\n            let c = totalCompare(aTuple[i + 2], bTuple[i + 2]);\n            if (directions[i] === \"desc\") {\n                c = -c;\n            }\n            if (c !== 0) {\n                return c;\n            }\n        }\n        return aTuple[1] - bTuple[1];\n    });\n    return fromJS(aux.map((v)=>v[0]));\n};\npipeFunctions.order.arity = (count2)=>count2 >= 1;\npipeFunctions.score = async function score(base, args, scope, execute) {\n    if (!base.isArray()) return NULL_VALUE;\n    const unknown = [];\n    const scored = [];\n    for await (const value of base){\n        if (value.type !== \"object\") {\n            unknown.push(await value.get());\n            continue;\n        }\n        const newScope = scope.createNested(value);\n        let valueScore = typeof value.data._score === \"number\" ? value.data._score : 0;\n        for (const arg of args){\n            valueScore += await evaluateScore(arg, newScope, execute);\n        }\n        const newObject = Object.assign({}, value.data, {\n            _score: valueScore\n        });\n        scored.push(newObject);\n    }\n    scored.sort((a, b)=>b._score - a._score);\n    return fromJS(scored);\n};\npipeFunctions.score.arity = (count2)=>count2 >= 1;\nconst delta = {};\ndelta.operation = async function(args, scope) {\n    const hasBefore = scope.context.before !== null;\n    const hasAfter = scope.context.after !== null;\n    if (hasBefore && hasAfter) {\n        return fromString(\"update\");\n    }\n    if (hasAfter) {\n        return fromString(\"create\");\n    }\n    if (hasBefore) {\n        return fromString(\"delete\");\n    }\n    return NULL_VALUE;\n};\ndelta.changedAny = ()=>{\n    throw new Error(\"not implemented\");\n};\ndelta.changedAny.arity = 1;\ndelta.changedAny.mode = \"delta\";\ndelta.changedOnly = ()=>{\n    throw new Error(\"not implemented\");\n};\ndelta.changedOnly.arity = 1;\ndelta.changedOnly.mode = \"delta\";\nconst diff = {};\ndiff.changedAny = ()=>{\n    throw new Error(\"not implemented\");\n};\ndiff.changedAny.arity = 3;\ndiff.changedOnly = ()=>{\n    throw new Error(\"not implemented\");\n};\ndiff.changedOnly.arity = 3;\nconst math = {};\nmath.min = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) {\n        return NULL_VALUE;\n    }\n    let n;\n    for await (const elem of arr){\n        if (elem.type === \"null\") continue;\n        if (elem.type !== \"number\") {\n            return NULL_VALUE;\n        }\n        if (n === void 0 || elem.data < n) {\n            n = elem.data;\n        }\n    }\n    return fromJS(n);\n};\nmath.min.arity = 1;\nmath.max = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) {\n        return NULL_VALUE;\n    }\n    let n;\n    for await (const elem of arr){\n        if (elem.type === \"null\") continue;\n        if (elem.type !== \"number\") {\n            return NULL_VALUE;\n        }\n        if (n === void 0 || elem.data > n) {\n            n = elem.data;\n        }\n    }\n    return fromJS(n);\n};\nmath.max.arity = 1;\nmath.sum = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) {\n        return NULL_VALUE;\n    }\n    let n = 0;\n    for await (const elem of arr){\n        if (elem.type === \"null\") continue;\n        if (elem.type !== \"number\") {\n            return NULL_VALUE;\n        }\n        n += elem.data;\n    }\n    return fromJS(n);\n};\nmath.sum.arity = 1;\nmath.avg = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) {\n        return NULL_VALUE;\n    }\n    let n = 0;\n    let c = 0;\n    for await (const elem of arr){\n        if (elem.type === \"null\") continue;\n        if (elem.type !== \"number\") {\n            return NULL_VALUE;\n        }\n        n += elem.data;\n        c++;\n    }\n    if (c === 0) {\n        return NULL_VALUE;\n    }\n    return fromJS(n / c);\n};\nmath.avg.arity = 1;\nconst dateTime2 = {};\ndateTime2.now = async function now2(args, scope, execute) {\n    return fromDateTime(new DateTime(scope.context.timestamp));\n};\ndateTime2.now.arity = 0;\nconst namespaces = {\n    global: _global,\n    string: string2,\n    array,\n    pt,\n    delta,\n    diff,\n    sanity,\n    math,\n    dateTime: dateTime2\n};\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value)=>key in obj ? __defProp$1(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value)=>{\n    __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n};\nclass MarkProcessor {\n    constructor(string, marks, parseOptions){\n        __publicField$1(this, \"string\");\n        __publicField$1(this, \"marks\");\n        __publicField$1(this, \"index\");\n        __publicField$1(this, \"parseOptions\");\n        __publicField$1(this, \"allowBoost\", false);\n        this.string = string;\n        this.marks = marks;\n        this.index = 0;\n        this.parseOptions = parseOptions;\n    }\n    hasMark(pos = 0) {\n        return this.index + pos < this.marks.length;\n    }\n    getMark(pos = 0) {\n        return this.marks[this.index + pos];\n    }\n    shift() {\n        this.index += 1;\n    }\n    process(visitor) {\n        const mark = this.marks[this.index];\n        this.shift();\n        const func = visitor[mark.name];\n        if (!func) {\n            throw new Error(\"Unknown handler: \".concat(mark.name));\n        }\n        return func.call(visitor, this, mark);\n    }\n    processString() {\n        this.shift();\n        return this.processStringEnd();\n    }\n    processStringEnd() {\n        const prev = this.marks[this.index - 1];\n        const curr = this.marks[this.index];\n        this.shift();\n        return this.string.slice(prev.position, curr.position);\n    }\n    slice(len) {\n        const pos = this.marks[this.index].position;\n        return this.string.slice(pos, pos + len);\n    }\n}\nconst WS = /^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/;\nconst NUM = /^\\d+/;\nconst IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/;\nconst PREC_PAIR = 1;\nconst PREC_OR = 2;\nconst PREC_AND = 3;\nconst PREC_COMP = 4;\nconst PREC_ORDER = 4;\nconst PREC_ADD = 6;\nconst PREC_SUB = 6;\nconst PREC_MUL = 7;\nconst PREC_DIV = 7;\nconst PREC_MOD = 7;\nconst PREC_POW = 8;\nconst PREC_POS = 10;\nconst PREC_NOT = 10;\nconst PREC_NEG = 8;\nfunction parse$1(str) {\n    let pos = 0;\n    pos = skipWS(str, pos);\n    let result = parseExpr(str, pos, 0);\n    if (result.type === \"error\") return result;\n    pos = skipWS(str, result.position);\n    if (pos !== str.length) {\n        if (result.failPosition) {\n            pos = result.failPosition - 1;\n        }\n        return {\n            type: \"error\",\n            position: pos\n        };\n    }\n    delete result.position;\n    delete result.failPosition;\n    return result;\n}\nfunction parseExpr(str, pos, level) {\n    let startPos = pos;\n    let token = str[pos];\n    let marks;\n    switch(token){\n        case \"+\":\n            {\n                let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_POS);\n                if (rhs.type === \"error\") return rhs;\n                marks = [\n                    {\n                        name: \"pos\",\n                        position: startPos\n                    }\n                ].concat(rhs.marks);\n                pos = rhs.position;\n                break;\n            }\n        case \"-\":\n            {\n                let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NEG);\n                if (rhs.type === \"error\") return rhs;\n                marks = [\n                    {\n                        name: \"neg\",\n                        position: startPos\n                    }\n                ].concat(rhs.marks);\n                pos = rhs.position;\n                break;\n            }\n        case \"(\":\n            {\n                let rhs = parseExpr(str, skipWS(str, pos + 1), 0);\n                if (rhs.type === \"error\") return rhs;\n                pos = skipWS(str, rhs.position);\n                switch(str[pos]){\n                    case \",\":\n                        {\n                            marks = [\n                                {\n                                    name: \"tuple\",\n                                    position: startPos\n                                }\n                            ].concat(rhs.marks);\n                            pos = skipWS(str, pos + 1);\n                            while(true){\n                                rhs = parseExpr(str, pos, 0);\n                                if (rhs.type === \"error\") return rhs;\n                                pos = skipWS(str, rhs.position);\n                                if (str[pos] !== \",\") break;\n                                pos = skipWS(str, pos + 1);\n                            }\n                            if (str[pos] !== \")\") return {\n                                type: \"error\",\n                                position: pos\n                            };\n                            pos++;\n                            marks.push({\n                                name: \"tuple_end\",\n                                position: pos\n                            });\n                            break;\n                        }\n                    case \")\":\n                        {\n                            pos++;\n                            marks = [\n                                {\n                                    name: \"group\",\n                                    position: startPos\n                                }\n                            ].concat(rhs.marks);\n                            break;\n                        }\n                    default:\n                        return {\n                            type: \"error\",\n                            position: pos\n                        };\n                }\n                break;\n            }\n        case \"!\":\n            {\n                let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NOT);\n                if (rhs.type === \"error\") return rhs;\n                marks = [\n                    {\n                        name: \"not\",\n                        position: startPos\n                    }\n                ].concat(rhs.marks);\n                pos = rhs.position;\n                break;\n            }\n        case \"{\":\n            {\n                let result = parseObject(str, pos);\n                if (result.type === \"error\") return result;\n                marks = result.marks;\n                pos = result.position;\n                break;\n            }\n        case \"[\":\n            marks = [\n                {\n                    name: \"array\",\n                    position: pos\n                }\n            ];\n            pos = skipWS(str, pos + 1);\n            if (str[pos] !== \"]\") {\n                while(true){\n                    if (str.slice(pos, pos + 3) === \"...\") {\n                        marks.push({\n                            name: \"array_splat\",\n                            position: pos\n                        });\n                        pos = skipWS(str, pos + 3);\n                    }\n                    let res = parseExpr(str, pos, 0);\n                    if (res.type === \"error\") return res;\n                    marks = marks.concat(res.marks);\n                    pos = res.position;\n                    pos = skipWS(str, pos);\n                    if (str[pos] !== \",\") break;\n                    pos = skipWS(str, pos + 1);\n                    if (str[pos] === \"]\") break;\n                }\n            }\n            if (str[pos] === \"]\") {\n                pos++;\n                marks.push({\n                    name: \"array_end\",\n                    position: pos\n                });\n            } else {\n                return {\n                    type: \"error\",\n                    position: pos\n                };\n            }\n            break;\n        case \"'\":\n        case '\"':\n            {\n                let result = parseString(str, pos);\n                if (result.type === \"error\") return result;\n                marks = result.marks;\n                pos = result.position;\n                break;\n            }\n        case \"^\":\n            {\n                pos++;\n                marks = [];\n                while(str[pos] === \".\" && str[pos + 1] === \"^\"){\n                    marks.push({\n                        name: \"dblparent\",\n                        position: startPos\n                    });\n                    pos += 2;\n                }\n                marks.push({\n                    name: \"parent\",\n                    position: startPos\n                });\n                break;\n            }\n        case \"@\":\n            marks = [\n                {\n                    name: \"this\",\n                    position: startPos\n                }\n            ];\n            pos++;\n            break;\n        case \"*\":\n            marks = [\n                {\n                    name: \"everything\",\n                    position: startPos\n                }\n            ];\n            pos++;\n            break;\n        case \"$\":\n            {\n                let identLen = parseRegex(str, pos + 1, IDENT);\n                if (identLen) {\n                    pos += 1 + identLen;\n                    marks = [\n                        {\n                            name: \"param\",\n                            position: startPos\n                        },\n                        {\n                            name: \"ident\",\n                            position: startPos + 1\n                        },\n                        {\n                            name: \"ident_end\",\n                            position: pos\n                        }\n                    ];\n                }\n                break;\n            }\n        default:\n            {\n                let numLen = parseRegex(str, pos, NUM);\n                if (numLen) {\n                    pos += numLen;\n                    let name = \"integer\";\n                    if (str[pos] === \".\") {\n                        let fracLen = parseRegex(str, pos + 1, NUM);\n                        if (fracLen) {\n                            name = \"float\";\n                            pos += 1 + fracLen;\n                        }\n                    }\n                    if (str[pos] === \"e\" || str[pos] === \"E\") {\n                        name = \"sci\";\n                        pos++;\n                        if (str[pos] === \"+\" || str[pos] === \"-\") {\n                            pos++;\n                        }\n                        let expLen = parseRegex(str, pos, NUM);\n                        if (!expLen) return {\n                            type: \"error\",\n                            position: pos\n                        };\n                        pos += expLen;\n                    }\n                    marks = [\n                        {\n                            name,\n                            position: startPos\n                        },\n                        {\n                            name: name + \"_end\",\n                            position: pos\n                        }\n                    ];\n                    break;\n                }\n                let identLen = parseRegex(str, pos, IDENT);\n                if (identLen) {\n                    pos += identLen;\n                    switch(str[pos]){\n                        case \":\":\n                        case \"(\":\n                            {\n                                let result = parseFuncCall(str, startPos, pos);\n                                if (result.type === \"error\") return result;\n                                marks = result.marks;\n                                pos = result.position;\n                                break;\n                            }\n                        default:\n                            {\n                                marks = [\n                                    {\n                                        name: \"this_attr\",\n                                        position: startPos\n                                    },\n                                    {\n                                        name: \"ident\",\n                                        position: startPos\n                                    },\n                                    {\n                                        name: \"ident_end\",\n                                        position: pos\n                                    }\n                                ];\n                            }\n                    }\n                    break;\n                }\n            }\n    }\n    if (!marks) {\n        return {\n            type: \"error\",\n            position: pos\n        };\n    }\n    let lhsLevel = 12;\n    let trav;\n    loop: while(true){\n        let innerPos = skipWS(str, pos);\n        if (innerPos === str.length) {\n            pos = innerPos;\n            break;\n        }\n        trav = parseTraversal(str, innerPos);\n        if (trav.type === \"success\") {\n            marks.unshift({\n                name: \"traverse\",\n                position: startPos\n            });\n            while(trav.type === \"success\"){\n                marks = marks.concat(trav.marks);\n                pos = trav.position;\n                trav = parseTraversal(str, skipWS(str, pos));\n            }\n            marks.push({\n                name: \"traversal_end\",\n                position: pos\n            });\n            continue;\n        }\n        let token2 = str[innerPos];\n        switch(token2){\n            case \"=\":\n                {\n                    let nextToken = str[innerPos + 1];\n                    switch(nextToken){\n                        case \">\":\n                            {\n                                if (level > PREC_PAIR || lhsLevel <= PREC_PAIR) break loop;\n                                let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_PAIR);\n                                if (rhs.type === \"error\") return rhs;\n                                marks = marks.concat(rhs.marks);\n                                marks.unshift({\n                                    name: \"pair\",\n                                    position: startPos\n                                });\n                                pos = rhs.position;\n                                lhsLevel = PREC_PAIR;\n                                break;\n                            }\n                        case \"=\":\n                            {\n                                if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop;\n                                let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1);\n                                if (rhs.type === \"error\") return rhs;\n                                marks.unshift({\n                                    name: \"comp\",\n                                    position: startPos\n                                });\n                                marks.push({\n                                    name: \"op\",\n                                    position: innerPos\n                                }, {\n                                    name: \"op_end\",\n                                    position: innerPos + 2\n                                });\n                                marks = marks.concat(rhs.marks);\n                                pos = rhs.position;\n                                lhsLevel = PREC_COMP;\n                                break;\n                            }\n                        default:\n                            break loop;\n                    }\n                    break;\n                }\n            case \"+\":\n                {\n                    if (level > PREC_ADD || lhsLevel < PREC_ADD) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_ADD + 1);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks);\n                    marks.unshift({\n                        name: \"add\",\n                        position: startPos\n                    });\n                    pos = rhs.position;\n                    lhsLevel = PREC_ADD;\n                    break;\n                }\n            case \"-\":\n                {\n                    if (level > PREC_SUB || lhsLevel < PREC_SUB) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_SUB + 1);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks);\n                    marks.unshift({\n                        name: \"sub\",\n                        position: startPos\n                    });\n                    pos = rhs.position;\n                    lhsLevel = PREC_SUB;\n                    break;\n                }\n            case \"*\":\n                {\n                    if (str[innerPos + 1] === \"*\") {\n                        if (level > PREC_POW || lhsLevel <= PREC_POW) break loop;\n                        let rhs2 = parseExpr(str, skipWS(str, innerPos + 2), PREC_POW);\n                        if (rhs2.type === \"error\") return rhs2;\n                        marks = marks.concat(rhs2.marks);\n                        marks.unshift({\n                            name: \"pow\",\n                            position: startPos\n                        });\n                        pos = rhs2.position;\n                        lhsLevel = PREC_POW;\n                        break;\n                    }\n                    if (level > PREC_MUL || lhsLevel < PREC_MUL) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MUL + 1);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks);\n                    marks.unshift({\n                        name: \"mul\",\n                        position: startPos\n                    });\n                    pos = rhs.position;\n                    lhsLevel = PREC_MUL;\n                    break;\n                }\n            case \"/\":\n                {\n                    if (level > PREC_DIV || lhsLevel < PREC_DIV) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_DIV + 1);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks);\n                    marks.unshift({\n                        name: \"div\",\n                        position: startPos\n                    });\n                    pos = rhs.position;\n                    lhsLevel = PREC_DIV;\n                    break;\n                }\n            case \"%\":\n                {\n                    if (level > PREC_MOD || lhsLevel < PREC_MOD) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MOD + 1);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks);\n                    marks.unshift({\n                        name: \"mod\",\n                        position: startPos\n                    });\n                    pos = rhs.position;\n                    lhsLevel = PREC_MOD;\n                    break;\n                }\n            case \"<\":\n            case \">\":\n                {\n                    if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop;\n                    let nextPos = innerPos + 1;\n                    if (str[nextPos] === \"=\") {\n                        nextPos++;\n                    }\n                    let rhs = parseExpr(str, skipWS(str, nextPos), PREC_COMP + 1);\n                    if (rhs.type === \"error\") return rhs;\n                    marks.unshift({\n                        name: \"comp\",\n                        position: startPos\n                    });\n                    marks.push({\n                        name: \"op\",\n                        position: innerPos\n                    }, {\n                        name: \"op_end\",\n                        position: nextPos\n                    });\n                    marks = marks.concat(rhs.marks);\n                    pos = rhs.position;\n                    lhsLevel = PREC_COMP;\n                    break;\n                }\n            case \"|\":\n                {\n                    if (str[innerPos + 1] === \"|\") {\n                        if (level > PREC_OR || lhsLevel < PREC_OR) break loop;\n                        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_OR + 1);\n                        if (rhs.type === \"error\") return rhs;\n                        marks = marks.concat(rhs.marks);\n                        marks.unshift({\n                            name: \"or\",\n                            position: startPos\n                        });\n                        pos = rhs.position;\n                        lhsLevel = PREC_OR;\n                    } else {\n                        if (level > 11 || lhsLevel < 11) break loop;\n                        let identPos = skipWS(str, innerPos + 1);\n                        let identLen = parseRegex(str, identPos, IDENT);\n                        if (!identLen) return {\n                            type: \"error\",\n                            position: identPos\n                        };\n                        pos = identPos + identLen;\n                        if (str[pos] === \"(\" || str[pos] === \":\") {\n                            let result = parseFuncCall(str, identPos, pos);\n                            if (result.type === \"error\") return result;\n                            marks = marks.concat(result.marks);\n                            marks.unshift({\n                                name: \"pipecall\",\n                                position: startPos\n                            });\n                            pos = result.position;\n                            lhsLevel = 11;\n                        }\n                    }\n                    break;\n                }\n            case \"&\":\n                {\n                    if (str[innerPos + 1] != \"&\") break loop;\n                    if (level > PREC_AND || lhsLevel < PREC_AND) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_AND + 1);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks);\n                    marks.unshift({\n                        name: \"and\",\n                        position: startPos\n                    });\n                    pos = rhs.position;\n                    lhsLevel = PREC_AND;\n                    break;\n                }\n            case \"!\":\n                {\n                    if (str[innerPos + 1] !== \"=\") break loop;\n                    if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1);\n                    if (rhs.type === \"error\") return rhs;\n                    marks.unshift({\n                        name: \"comp\",\n                        position: startPos\n                    });\n                    marks.push({\n                        name: \"op\",\n                        position: innerPos\n                    }, {\n                        name: \"op_end\",\n                        position: innerPos + 2\n                    });\n                    marks = marks.concat(rhs.marks);\n                    pos = rhs.position;\n                    lhsLevel = PREC_COMP;\n                    break;\n                }\n            case \"d\":\n                {\n                    if (str.slice(innerPos, innerPos + 4) !== \"desc\") break loop;\n                    if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop;\n                    marks.unshift({\n                        name: \"desc\",\n                        position: startPos\n                    });\n                    pos = innerPos + 4;\n                    lhsLevel = PREC_ORDER;\n                    break;\n                }\n            case \"a\":\n                {\n                    if (str.slice(innerPos, innerPos + 3) !== \"asc\") break loop;\n                    if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop;\n                    marks.unshift({\n                        name: \"asc\",\n                        position: startPos\n                    });\n                    pos = innerPos + 3;\n                    lhsLevel = PREC_ORDER;\n                    break;\n                }\n            default:\n                {\n                    let ident = parseRegexStr(str, innerPos, IDENT);\n                    switch(ident){\n                        case \"in\":\n                            {\n                                if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop;\n                                pos = skipWS(str, innerPos + 2);\n                                let isGroup = false;\n                                if (str[pos] === \"(\") {\n                                    isGroup = true;\n                                    pos = skipWS(str, pos + 1);\n                                }\n                                let rangePos = pos;\n                                let result = parseExpr(str, pos, PREC_COMP + 1);\n                                if (result.type === \"error\") return result;\n                                pos = skipWS(str, result.position);\n                                if (str[pos] === \".\" && str[pos + 1] === \".\") {\n                                    let type = \"inc_range\";\n                                    if (str[pos + 2] === \".\") {\n                                        type = \"exc_range\";\n                                        pos = skipWS(str, pos + 3);\n                                    } else {\n                                        pos = skipWS(str, pos + 2);\n                                    }\n                                    let rhs = parseExpr(str, pos, PREC_COMP + 1);\n                                    if (rhs.type === \"error\") return rhs;\n                                    marks.unshift({\n                                        name: \"in_range\",\n                                        position: startPos\n                                    });\n                                    marks = marks.concat({\n                                        name: type,\n                                        position: rangePos\n                                    }, result.marks, rhs.marks);\n                                    pos = rhs.position;\n                                } else {\n                                    marks.unshift({\n                                        name: \"comp\",\n                                        position: startPos\n                                    });\n                                    marks.push({\n                                        name: \"op\",\n                                        position: innerPos\n                                    }, {\n                                        name: \"op_end\",\n                                        position: innerPos + 2\n                                    });\n                                    marks = marks.concat(result.marks);\n                                }\n                                if (isGroup) {\n                                    pos = skipWS(str, pos);\n                                    if (str[pos] !== \")\") return {\n                                        type: \"error\",\n                                        position: pos\n                                    };\n                                    pos++;\n                                }\n                                lhsLevel = PREC_COMP;\n                                break;\n                            }\n                        case \"match\":\n                            {\n                                if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop;\n                                let rhs = parseExpr(str, skipWS(str, innerPos + 5), PREC_COMP + 1);\n                                if (rhs.type === \"error\") return rhs;\n                                marks.unshift({\n                                    name: \"comp\",\n                                    position: startPos\n                                });\n                                marks.push({\n                                    name: \"op\",\n                                    position: innerPos\n                                }, {\n                                    name: \"op_end\",\n                                    position: innerPos + 5\n                                });\n                                marks = marks.concat(rhs.marks);\n                                pos = rhs.position;\n                                lhsLevel = 4;\n                                break;\n                            }\n                        default:\n                            {\n                                break loop;\n                            }\n                    }\n                }\n        }\n    }\n    let failPosition = (trav == null ? void 0 : trav.type) === \"error\" && trav.position;\n    return {\n        type: \"success\",\n        marks,\n        position: pos,\n        failPosition\n    };\n}\nfunction parseTraversal(str, pos) {\n    let startPos = pos;\n    switch(str[pos]){\n        case \".\":\n            {\n                pos = skipWS(str, pos + 1);\n                let identStart = pos;\n                let identLen2 = parseRegex(str, pos, IDENT);\n                if (!identLen2) return {\n                    type: \"error\",\n                    position: pos\n                };\n                pos += identLen2;\n                return {\n                    type: \"success\",\n                    marks: [\n                        {\n                            name: \"attr_access\",\n                            position: startPos\n                        },\n                        {\n                            name: \"ident\",\n                            position: identStart\n                        },\n                        {\n                            name: \"ident_end\",\n                            position: pos\n                        }\n                    ],\n                    position: pos\n                };\n            }\n        case \"-\":\n            if (str[pos + 1] !== \">\") return {\n                type: \"error\",\n                position: pos\n            };\n            let marks = [\n                {\n                    name: \"deref\",\n                    position: startPos\n                }\n            ];\n            pos += 2;\n            let identPos = skipWS(str, pos);\n            let identLen = parseRegex(str, identPos, IDENT);\n            if (identLen) {\n                pos = identPos + identLen;\n                marks.push({\n                    name: \"deref_attr\",\n                    position: identPos\n                }, {\n                    name: \"ident\",\n                    position: identPos\n                }, {\n                    name: \"ident_end\",\n                    position: pos\n                });\n            }\n            return {\n                type: \"success\",\n                marks,\n                position: pos\n            };\n        case \"[\":\n            {\n                pos = skipWS(str, pos + 1);\n                if (str[pos] === \"]\") {\n                    return {\n                        type: \"success\",\n                        marks: [\n                            {\n                                name: \"array_postfix\",\n                                position: startPos\n                            }\n                        ],\n                        position: pos + 1\n                    };\n                }\n                let rangePos = pos;\n                let result = parseExpr(str, pos, 0);\n                if (result.type === \"error\") return result;\n                pos = skipWS(str, result.position);\n                if (str[pos] === \".\" && str[pos + 1] === \".\") {\n                    let type = \"inc_range\";\n                    if (str[pos + 2] === \".\") {\n                        type = \"exc_range\";\n                        pos += 3;\n                    } else {\n                        pos += 2;\n                    }\n                    pos = skipWS(str, pos);\n                    let rhs = parseExpr(str, pos, 0);\n                    if (rhs.type === \"error\") return rhs;\n                    pos = skipWS(str, rhs.position);\n                    if (str[pos] !== \"]\") return {\n                        type: \"error\",\n                        position: pos\n                    };\n                    return {\n                        type: \"success\",\n                        marks: [\n                            {\n                                name: \"slice\",\n                                position: startPos\n                            },\n                            {\n                                name: type,\n                                position: rangePos\n                            }\n                        ].concat(result.marks, rhs.marks),\n                        position: pos + 1\n                    };\n                }\n                if (str[pos] !== \"]\") return {\n                    type: \"error\",\n                    position: pos\n                };\n                return {\n                    type: \"success\",\n                    marks: [\n                        {\n                            name: \"square_bracket\",\n                            position: startPos\n                        }\n                    ].concat(result.marks),\n                    position: pos + 1\n                };\n            }\n        case \"|\":\n            {\n                pos = skipWS(str, pos + 1);\n                if (str[pos] === \"{\") {\n                    let result = parseObject(str, pos);\n                    if (result.type === \"error\") return result;\n                    result.marks.unshift({\n                        name: \"projection\",\n                        position: startPos\n                    });\n                    return result;\n                }\n                break;\n            }\n        case \"{\":\n            {\n                let result = parseObject(str, pos);\n                if (result.type === \"error\") return result;\n                result.marks.unshift({\n                    name: \"projection\",\n                    position: startPos\n                });\n                return result;\n            }\n    }\n    return {\n        type: \"error\",\n        position: pos\n    };\n}\nfunction parseFuncCall(str, startPos, pos) {\n    let marks = [];\n    marks.push({\n        name: \"func_call\",\n        position: startPos\n    });\n    if (str[pos] === \":\" && str[pos + 1] === \":\") {\n        marks.push({\n            name: \"namespace\",\n            position: startPos\n        });\n        marks.push({\n            name: \"ident\",\n            position: startPos\n        }, {\n            name: \"ident_end\",\n            position: pos\n        });\n        pos = skipWS(str, pos + 2);\n        let nameLen = parseRegex(str, pos, IDENT);\n        if (!nameLen) return {\n            type: \"error\",\n            position: pos\n        };\n        marks.push({\n            name: \"ident\",\n            position: pos\n        }, {\n            name: \"ident_end\",\n            position: pos + nameLen\n        });\n        pos = skipWS(str, pos + nameLen);\n        if (str[pos] !== \"(\") return {\n            type: \"error\",\n            position: pos\n        };\n        pos++;\n        pos = skipWS(str, pos);\n    } else {\n        marks.push({\n            name: \"ident\",\n            position: startPos\n        }, {\n            name: \"ident_end\",\n            position: pos\n        });\n        pos = skipWS(str, pos + 1);\n    }\n    let lastPos = pos;\n    if (str[pos] !== \")\") {\n        while(true){\n            let result = parseExpr(str, pos, 0);\n            if (result.type === \"error\") return result;\n            marks = marks.concat(result.marks);\n            lastPos = result.position;\n            pos = skipWS(str, result.position);\n            if (str[pos] !== \",\") break;\n            pos = skipWS(str, pos + 1);\n            if (str[pos] === \")\") break;\n        }\n    }\n    if (str[pos] !== \")\") {\n        return {\n            type: \"error\",\n            position: pos\n        };\n    }\n    marks.push({\n        name: \"func_args_end\",\n        position: lastPos\n    });\n    return {\n        type: \"success\",\n        marks,\n        position: pos + 1\n    };\n}\nfunction parseObject(str, pos) {\n    let marks = [\n        {\n            name: \"object\",\n            position: pos\n        }\n    ];\n    pos = skipWS(str, pos + 1);\n    while(str[pos] !== \"}\"){\n        let pairPos = pos;\n        if (str.slice(pos, pos + 3) === \"...\") {\n            pos = skipWS(str, pos + 3);\n            if (str[pos] !== \"}\" && str[pos] !== \",\") {\n                let expr = parseExpr(str, pos, 0);\n                if (expr.type === \"error\") return expr;\n                marks.push({\n                    name: \"object_splat\",\n                    position: pairPos\n                });\n                marks = marks.concat(expr.marks);\n                pos = expr.position;\n            } else {\n                marks.push({\n                    name: \"object_splat_this\",\n                    position: pairPos\n                });\n            }\n        } else {\n            let expr = parseExpr(str, pos, 0);\n            if (expr.type === \"error\") return expr;\n            let nextPos = skipWS(str, expr.position);\n            if (expr.marks[0].name === \"str\" && str[nextPos] === \":\") {\n                let value = parseExpr(str, skipWS(str, nextPos + 1), 0);\n                if (value.type === \"error\") return value;\n                marks.push({\n                    name: \"object_pair\",\n                    position: pairPos\n                });\n                marks = marks.concat(expr.marks, value.marks);\n                pos = value.position;\n            } else {\n                marks = marks.concat({\n                    name: \"object_expr\",\n                    position: pos\n                }, expr.marks);\n                pos = expr.position;\n            }\n        }\n        pos = skipWS(str, pos);\n        if (str[pos] !== \",\") break;\n        pos = skipWS(str, pos + 1);\n    }\n    if (str[pos] !== \"}\") {\n        return {\n            type: \"error\",\n            position: pos\n        };\n    }\n    pos++;\n    marks.push({\n        name: \"object_end\",\n        position: pos\n    });\n    return {\n        type: \"success\",\n        marks,\n        position: pos\n    };\n}\nfunction parseString(str, pos) {\n    let token = str[pos];\n    pos = pos + 1;\n    const marks = [\n        {\n            name: \"str\",\n            position: pos\n        }\n    ];\n    str: for(;; pos++){\n        if (pos > str.length) return {\n            type: \"error\",\n            position: pos\n        };\n        switch(str[pos]){\n            case token:\n                {\n                    marks.push({\n                        name: \"str_end\",\n                        position: pos\n                    });\n                    pos++;\n                    break str;\n                }\n            case \"\\\\\":\n                {\n                    marks.push({\n                        name: \"str_pause\",\n                        position: pos\n                    });\n                    if (str[pos + 1] === \"u\") {\n                        if (str[pos + 2] === \"{\") {\n                            marks.push({\n                                name: \"unicode_hex\",\n                                position: pos + 3\n                            });\n                            pos = str.indexOf(\"}\", pos + 3);\n                            marks.push({\n                                name: \"unicode_hex_end\",\n                                position: pos\n                            });\n                        } else {\n                            marks.push({\n                                name: \"unicode_hex\",\n                                position: pos + 2\n                            });\n                            marks.push({\n                                name: \"unicode_hex_end\",\n                                position: pos + 6\n                            });\n                            pos += 5;\n                        }\n                    } else {\n                        marks.push({\n                            name: \"single_escape\",\n                            position: pos + 1\n                        });\n                        pos += 1;\n                    }\n                    marks.push({\n                        name: \"str_start\",\n                        position: pos + 1\n                    });\n                }\n        }\n    }\n    return {\n        type: \"success\",\n        marks,\n        position: pos\n    };\n}\nfunction skipWS(str, pos) {\n    return pos + parseRegex(str, pos, WS);\n}\nfunction parseRegex(str, pos, re) {\n    let m = re.exec(str.slice(pos));\n    return m ? m[0].length : 0;\n}\nfunction parseRegexStr(str, pos, re) {\n    let m = re.exec(str.slice(pos));\n    return m ? m[0] : null;\n}\nfunction join(a, b) {\n    return (base)=>b(a(base));\n}\nfunction map(inner) {\n    return (base)=>({\n            type: \"Map\",\n            base,\n            expr: inner({\n                type: \"This\"\n            })\n        });\n}\nfunction flatMap(inner) {\n    return (base)=>({\n            type: \"FlatMap\",\n            base,\n            expr: inner({\n                type: \"This\"\n            })\n        });\n}\nfunction traverseArray(build, right) {\n    if (!right) {\n        return {\n            type: \"a-a\",\n            build\n        };\n    }\n    switch(right.type){\n        case \"a-a\":\n            return {\n                type: \"a-a\",\n                build: join(build, right.build)\n            };\n        case \"a-b\":\n            return {\n                type: \"a-b\",\n                build: join(build, right.build)\n            };\n        case \"b-b\":\n            return {\n                type: \"a-a\",\n                build: join(build, map(right.build))\n            };\n        case \"b-a\":\n            return {\n                type: \"a-a\",\n                build: join(build, flatMap(right.build))\n            };\n        default:\n            throw new Error(\"unknown type: \".concat(right.type));\n    }\n}\nfunction traversePlain(mapper, right) {\n    if (!right) {\n        return {\n            type: \"b-b\",\n            build: mapper\n        };\n    }\n    switch(right.type){\n        case \"a-a\":\n        case \"b-a\":\n            return {\n                type: \"b-a\",\n                build: join(mapper, right.build)\n            };\n        case \"a-b\":\n        case \"b-b\":\n            return {\n                type: \"b-b\",\n                build: join(mapper, right.build)\n            };\n        default:\n            throw new Error(\"unknown type: \".concat(right.type));\n    }\n}\nfunction traverseElement(mapper, right) {\n    if (!right) {\n        return {\n            type: \"a-b\",\n            build: mapper\n        };\n    }\n    switch(right.type){\n        case \"a-a\":\n        case \"b-a\":\n            return {\n                type: \"a-a\",\n                build: join(mapper, right.build)\n            };\n        case \"a-b\":\n        case \"b-b\":\n            return {\n                type: \"a-b\",\n                build: join(mapper, right.build)\n            };\n        default:\n            throw new Error(\"unknown type: \".concat(right.type));\n    }\n}\nfunction traverseProjection(mapper, right) {\n    if (!right) {\n        return {\n            type: \"b-b\",\n            build: mapper\n        };\n    }\n    switch(right.type){\n        case \"a-a\":\n            return {\n                type: \"a-a\",\n                build: join(map(mapper), right.build)\n            };\n        case \"a-b\":\n            return {\n                type: \"a-b\",\n                build: join(map(mapper), right.build)\n            };\n        case \"b-a\":\n            return {\n                type: \"b-a\",\n                build: join(mapper, right.build)\n            };\n        case \"b-b\":\n            return {\n                type: \"b-b\",\n                build: join(mapper, right.build)\n            };\n        default:\n            throw new Error(\"unknown type: \".concat(right.type));\n    }\n}\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField = (obj, key, value)=>{\n    __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n};\nconst ESCAPE_SEQUENCE = {\n    \"'\": \"'\",\n    '\"': '\"',\n    \"\\\\\": \"\\\\\",\n    \"/\": \"/\",\n    b: \"\\b\",\n    f: \"\\f\",\n    n: \"\\n\",\n    r: \"\\r\",\n    t: \"\t\"\n};\nfunction expandHex(str) {\n    const charCode = parseInt(str, 16);\n    return String.fromCharCode(charCode);\n}\nclass GroqQueryError extends Error {\n    constructor(){\n        super(...arguments);\n        __publicField(this, \"name\", \"GroqQueryError\");\n    }\n}\nconst EXPR_BUILDER = {\n    group (p) {\n        const inner = p.process(EXPR_BUILDER);\n        return {\n            type: \"Group\",\n            base: inner\n        };\n    },\n    everything () {\n        return {\n            type: \"Everything\"\n        };\n    },\n    this () {\n        return {\n            type: \"This\"\n        };\n    },\n    parent () {\n        return {\n            type: \"Parent\",\n            n: 1\n        };\n    },\n    dblparent (p) {\n        const next = p.process(EXPR_BUILDER);\n        return {\n            type: \"Parent\",\n            n: next.n + 1\n        };\n    },\n    traverse (p) {\n        const base = p.process(EXPR_BUILDER);\n        const traversalList = [];\n        while(p.getMark().name !== \"traversal_end\"){\n            traversalList.push(p.process(TRAVERSE_BUILDER));\n        }\n        p.shift();\n        let traversal = null;\n        for(let i = traversalList.length - 1; i >= 0; i--){\n            traversal = traversalList[i](traversal);\n        }\n        if (base.type === \"Everything\" || base.type === \"Array\" || base.type === \"PipeFuncCall\") {\n            traversal = traverseArray((val)=>val, traversal);\n        }\n        if (traversal === null) throw new Error(\"BUG: unexpected empty traversal\");\n        return traversal.build(base);\n    },\n    this_attr (p) {\n        const name = p.processString();\n        if (name === \"null\") {\n            return {\n                type: \"Value\",\n                value: null\n            };\n        }\n        if (name === \"true\") {\n            return {\n                type: \"Value\",\n                value: true\n            };\n        }\n        if (name === \"false\") {\n            return {\n                type: \"Value\",\n                value: false\n            };\n        }\n        return {\n            type: \"AccessAttribute\",\n            name\n        };\n    },\n    neg (p) {\n        const base = p.process(EXPR_BUILDER);\n        return {\n            type: \"Neg\",\n            base\n        };\n    },\n    pos (p) {\n        const base = p.process(EXPR_BUILDER);\n        return {\n            type: \"Pos\",\n            base\n        };\n    },\n    add (p) {\n        const left = p.process(EXPR_BUILDER);\n        const right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"+\",\n            left,\n            right\n        };\n    },\n    sub (p) {\n        const left = p.process(EXPR_BUILDER);\n        const right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"-\",\n            left,\n            right\n        };\n    },\n    mul (p) {\n        const left = p.process(EXPR_BUILDER);\n        const right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"*\",\n            left,\n            right\n        };\n    },\n    div (p) {\n        const left = p.process(EXPR_BUILDER);\n        const right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"/\",\n            left,\n            right\n        };\n    },\n    mod (p) {\n        const left = p.process(EXPR_BUILDER);\n        const right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"%\",\n            left,\n            right\n        };\n    },\n    pow (p) {\n        const left = p.process(EXPR_BUILDER);\n        const right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"**\",\n            left,\n            right\n        };\n    },\n    comp (p) {\n        const left = p.process(EXPR_BUILDER);\n        const op = p.processString();\n        const right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op,\n            left,\n            right\n        };\n    },\n    in_range (p) {\n        const base = p.process(EXPR_BUILDER);\n        const isInclusive = p.getMark().name === \"inc_range\";\n        p.shift();\n        const left = p.process(EXPR_BUILDER);\n        const right = p.process(EXPR_BUILDER);\n        return {\n            type: \"InRange\",\n            base,\n            left,\n            right,\n            isInclusive\n        };\n    },\n    str (p) {\n        let value = \"\";\n        loop: while(p.hasMark()){\n            const mark = p.getMark();\n            switch(mark.name){\n                case \"str_end\":\n                    value += p.processStringEnd();\n                    break loop;\n                case \"str_pause\":\n                    value += p.processStringEnd();\n                    break;\n                case \"str_start\":\n                    p.shift();\n                    break;\n                case \"single_escape\":\n                    {\n                        const char = p.slice(1);\n                        p.shift();\n                        value += ESCAPE_SEQUENCE[char];\n                        break;\n                    }\n                case \"unicode_hex\":\n                    p.shift();\n                    value += expandHex(p.processStringEnd());\n                    break;\n                default:\n                    throw new Error(\"unexpected mark: \".concat(mark.name));\n            }\n        }\n        return {\n            type: \"Value\",\n            value\n        };\n    },\n    integer (p) {\n        const strValue = p.processStringEnd();\n        return {\n            type: \"Value\",\n            value: Number(strValue)\n        };\n    },\n    float (p) {\n        const strValue = p.processStringEnd();\n        return {\n            type: \"Value\",\n            value: Number(strValue)\n        };\n    },\n    sci (p) {\n        const strValue = p.processStringEnd();\n        return {\n            type: \"Value\",\n            value: Number(strValue)\n        };\n    },\n    object (p) {\n        const attributes = [];\n        while(p.getMark().name !== \"object_end\"){\n            attributes.push(p.process(OBJECT_BUILDER));\n        }\n        p.shift();\n        return {\n            type: \"Object\",\n            attributes\n        };\n    },\n    array (p) {\n        const elements = [];\n        while(p.getMark().name !== \"array_end\"){\n            let isSplat = false;\n            if (p.getMark().name === \"array_splat\") {\n                isSplat = true;\n                p.shift();\n            }\n            const value = p.process(EXPR_BUILDER);\n            elements.push({\n                type: \"ArrayElement\",\n                value,\n                isSplat\n            });\n        }\n        p.shift();\n        return {\n            type: \"Array\",\n            elements\n        };\n    },\n    tuple (p) {\n        const members = [];\n        while(p.getMark().name !== \"tuple_end\"){\n            members.push(p.process(EXPR_BUILDER));\n        }\n        p.shift();\n        return {\n            type: \"Tuple\",\n            members\n        };\n    },\n    func_call (p) {\n        let namespace = \"global\";\n        if (p.getMark().name === \"namespace\") {\n            p.shift();\n            namespace = p.processString();\n        }\n        const name = p.processString();\n        if (namespace === \"global\" && name === \"select\") {\n            const result = {\n                type: \"Select\",\n                alternatives: []\n            };\n            while(p.getMark().name !== \"func_args_end\"){\n                if (p.getMark().name === \"pair\") {\n                    if (result.fallback) throw new GroqQueryError(\"unexpected argument to select()\");\n                    p.shift();\n                    const condition = p.process(EXPR_BUILDER);\n                    const value = p.process(EXPR_BUILDER);\n                    result.alternatives.push({\n                        type: \"SelectAlternative\",\n                        condition,\n                        value\n                    });\n                } else {\n                    if (result.fallback) throw new GroqQueryError(\"unexpected argument to select()\");\n                    const value = p.process(EXPR_BUILDER);\n                    result.fallback = value;\n                }\n            }\n            p.shift();\n            return result;\n        }\n        const args = [];\n        while(p.getMark().name !== \"func_args_end\"){\n            if (argumentShouldBeSelector(namespace, name, args.length)) {\n                p.process(SELECTOR_BUILDER);\n                args.push({\n                    type: \"Selector\"\n                });\n            } else {\n                args.push(p.process(EXPR_BUILDER));\n            }\n        }\n        p.shift();\n        if (namespace === \"global\" && (name === \"before\" || name === \"after\")) {\n            if (p.parseOptions.mode === \"delta\") {\n                return {\n                    type: \"Context\",\n                    key: name\n                };\n            }\n        }\n        if (namespace === \"global\" && name === \"boost\" && !p.allowBoost) throw new GroqQueryError(\"unexpected boost\");\n        const funcs = namespaces[namespace];\n        if (!funcs) {\n            throw new GroqQueryError(\"Undefined namespace: \".concat(namespace));\n        }\n        const func = funcs[name];\n        if (!func) {\n            throw new GroqQueryError(\"Undefined function: \".concat(name));\n        }\n        if (func.arity !== void 0) {\n            validateArity(name, func.arity, args.length);\n        }\n        if (func.mode !== void 0 && func.mode !== p.parseOptions.mode) {\n            throw new GroqQueryError(\"Undefined function: \".concat(name));\n        }\n        return {\n            type: \"FuncCall\",\n            func,\n            namespace,\n            name,\n            args\n        };\n    },\n    pipecall (p) {\n        const base = p.process(EXPR_BUILDER);\n        p.shift();\n        let namespace = \"global\";\n        if (p.getMark().name === \"namespace\") {\n            p.shift();\n            namespace = p.processString();\n        }\n        if (namespace !== \"global\") {\n            throw new GroqQueryError(\"Undefined namespace: \".concat(namespace));\n        }\n        const name = p.processString();\n        const args = [];\n        const oldAllowBoost = p.allowBoost;\n        if (name === \"score\") {\n            p.allowBoost = true;\n        }\n        for(;;){\n            const markName = p.getMark().name;\n            if (markName === \"func_args_end\") {\n                break;\n            }\n            if (name === \"order\") {\n                if (markName === \"asc\") {\n                    p.shift();\n                    args.push({\n                        type: \"Asc\",\n                        base: p.process(EXPR_BUILDER)\n                    });\n                    continue;\n                } else if (markName === \"desc\") {\n                    p.shift();\n                    args.push({\n                        type: \"Desc\",\n                        base: p.process(EXPR_BUILDER)\n                    });\n                    continue;\n                }\n            }\n            args.push(p.process(EXPR_BUILDER));\n        }\n        p.shift();\n        p.allowBoost = oldAllowBoost;\n        const func = pipeFunctions[name];\n        if (!func) {\n            throw new GroqQueryError(\"Undefined pipe function: \".concat(name));\n        }\n        if (func.arity) {\n            validateArity(name, func.arity, args.length);\n        }\n        return {\n            type: \"PipeFuncCall\",\n            func,\n            base,\n            name,\n            args\n        };\n    },\n    pair (p) {\n        throw new GroqQueryError(\"unexpected =>\");\n    },\n    and (p) {\n        const left = p.process(EXPR_BUILDER);\n        const right = p.process(EXPR_BUILDER);\n        return {\n            type: \"And\",\n            left,\n            right\n        };\n    },\n    or (p) {\n        const left = p.process(EXPR_BUILDER);\n        const right = p.process(EXPR_BUILDER);\n        return {\n            type: \"Or\",\n            left,\n            right\n        };\n    },\n    not (p) {\n        const base = p.process(EXPR_BUILDER);\n        return {\n            type: \"Not\",\n            base\n        };\n    },\n    asc (p) {\n        throw new GroqQueryError(\"unexpected asc\");\n    },\n    desc (p) {\n        throw new GroqQueryError(\"unexpected desc\");\n    },\n    param (p) {\n        const name = p.processString();\n        if (p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name)) {\n            return {\n                type: \"Value\",\n                value: p.parseOptions.params[name]\n            };\n        }\n        return {\n            type: \"Parameter\",\n            name\n        };\n    }\n};\nconst OBJECT_BUILDER = {\n    object_expr (p) {\n        if (p.getMark().name === \"pair\") {\n            p.shift();\n            const condition = p.process(EXPR_BUILDER);\n            const value2 = p.process(EXPR_BUILDER);\n            return {\n                type: \"ObjectConditionalSplat\",\n                condition,\n                value: value2\n            };\n        }\n        const value = p.process(EXPR_BUILDER);\n        return {\n            type: \"ObjectAttributeValue\",\n            name: extractPropertyKey(value),\n            value\n        };\n    },\n    object_pair (p) {\n        const name = p.process(EXPR_BUILDER);\n        if (name.type !== \"Value\") throw new Error(\"name must be string\");\n        const value = p.process(EXPR_BUILDER);\n        return {\n            type: \"ObjectAttributeValue\",\n            name: name.value,\n            value\n        };\n    },\n    object_splat (p) {\n        const value = p.process(EXPR_BUILDER);\n        return {\n            type: \"ObjectSplat\",\n            value\n        };\n    },\n    object_splat_this () {\n        return {\n            type: \"ObjectSplat\",\n            value: {\n                type: \"This\"\n            }\n        };\n    }\n};\nconst TRAVERSE_BUILDER = {\n    square_bracket (p) {\n        const expr = p.process(EXPR_BUILDER);\n        const value = tryConstantEvaluate(expr);\n        if (value && value.type === \"number\") {\n            return (right)=>traverseElement((base)=>({\n                        type: \"AccessElement\",\n                        base,\n                        index: value.data\n                    }), right);\n        }\n        if (value && value.type === \"string\") {\n            return (right)=>traversePlain((base)=>({\n                        type: \"AccessAttribute\",\n                        base,\n                        name: value.data\n                    }), right);\n        }\n        return (right)=>traverseArray((base)=>({\n                    type: \"Filter\",\n                    base,\n                    expr\n                }), right);\n    },\n    slice (p) {\n        const isInclusive = p.getMark().name === \"inc_range\";\n        p.shift();\n        const left = p.process(EXPR_BUILDER);\n        const right = p.process(EXPR_BUILDER);\n        const leftValue = tryConstantEvaluate(left);\n        const rightValue = tryConstantEvaluate(right);\n        if (!leftValue || !rightValue || leftValue.type !== \"number\" || rightValue.type !== \"number\") {\n            throw new GroqQueryError(\"slicing must use constant numbers\");\n        }\n        return (rhs)=>traverseArray((base)=>({\n                    type: \"Slice\",\n                    base,\n                    left: leftValue.data,\n                    right: rightValue.data,\n                    isInclusive\n                }), rhs);\n    },\n    projection (p) {\n        const obj = p.process(EXPR_BUILDER);\n        return (right)=>traverseProjection((base)=>({\n                    type: \"Projection\",\n                    base,\n                    expr: obj\n                }), right);\n    },\n    attr_access (p) {\n        const name = p.processString();\n        return (right)=>traversePlain((base)=>({\n                    type: \"AccessAttribute\",\n                    base,\n                    name\n                }), right);\n    },\n    deref (p) {\n        let attr = null;\n        if (p.getMark().name === \"deref_attr\") {\n            p.shift();\n            attr = p.processString();\n        }\n        const wrap = (base)=>attr ? {\n                type: \"AccessAttribute\",\n                base,\n                name: attr\n            } : base;\n        return (right)=>traversePlain((base)=>wrap({\n                    type: \"Deref\",\n                    base\n                }), right);\n    },\n    array_postfix (p) {\n        return (right)=>traverseArray((base)=>({\n                    type: \"ArrayCoerce\",\n                    base\n                }), right);\n    }\n};\nconst SELECTOR_BUILDER = {\n    group (p) {\n        p.process(SELECTOR_BUILDER);\n        return null;\n    },\n    everything () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    this () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    parent () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    dblparent (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    traverse (p) {\n        p.process(SELECTOR_BUILDER);\n        while(p.getMark().name !== \"traversal_end\"){\n            p.process(TRAVERSE_BUILDER);\n        }\n        p.shift();\n        return null;\n    },\n    this_attr (p) {\n        p.processString();\n        return null;\n    },\n    neg (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    pos (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    add (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    sub (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    mul (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    div (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    mod (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    pow (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    comp (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    in_range (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    str (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    integer (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    float (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    sci (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    object (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    array (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    tuple (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    func_call (p, mark) {\n        const func = EXPR_BUILDER.func_call(p, mark);\n        if (func.name === \"anywhere\" && func.args.length === 1) return null;\n        throw new Error(\"Invalid selector syntax\");\n    },\n    pipecall (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    pair (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    and (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    or (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    not (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    asc (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    desc (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    param (p) {\n        throw new Error(\"Invalid selector syntax\");\n    }\n};\nfunction extractPropertyKey(node) {\n    if (node.type === \"AccessAttribute\" && !node.base) {\n        return node.name;\n    }\n    if (node.type === \"Deref\" || node.type === \"Map\" || node.type === \"Projection\" || node.type === \"Slice\" || node.type === \"Filter\" || node.type === \"AccessElement\" || node.type === \"ArrayCoerce\") {\n        return extractPropertyKey(node.base);\n    }\n    throw new GroqQueryError(\"Cannot determine property key for type: \".concat(node.type));\n}\nfunction validateArity(name, arity, count) {\n    if (typeof arity === \"number\") {\n        if (count !== arity) {\n            throw new GroqQueryError(\"Incorrect number of arguments to function \".concat(name, \"(). Expected \").concat(arity, \", got \").concat(count, \".\"));\n        }\n    } else if (arity) {\n        if (!arity(count)) {\n            throw new GroqQueryError(\"Incorrect number of arguments to function \".concat(name, \"().\"));\n        }\n    }\n}\nfunction argumentShouldBeSelector(namespace, functionName, argCount) {\n    const functionsRequiringSelectors = [\n        \"changedAny\",\n        \"changedOnly\"\n    ];\n    return namespace == \"diff\" && argCount == 2 && functionsRequiringSelectors.includes(functionName);\n}\nclass GroqSyntaxError extends Error {\n    constructor(position){\n        super(\"Syntax error in GROQ query at position \".concat(position));\n        __publicField(this, \"position\");\n        __publicField(this, \"name\", \"GroqSyntaxError\");\n        this.position = position;\n    }\n}\nfunction parse(input, options = {}) {\n    const result = parse$1(input);\n    if (result.type === \"error\") {\n        throw new GroqSyntaxError(result.position);\n    }\n    const processor = new MarkProcessor(input, result.marks, options);\n    return processor.process(EXPR_BUILDER);\n}\n //# sourceMappingURL=1.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Y0FBYyxJQUFJLEVBQUUsUUFBUTtRQUM1QixJQUFJLENBQUNqRSxRQUFRLEdBQUdBO0lBQ2xCO0FBQ0Y7QUFDQSxTQUFTeUksTUFBTUMsS0FBSyxFQUFFNVEsVUFBVSxDQUFDLENBQUM7SUFDaEMsTUFBTTdOLFNBQVNrWCxRQUFRdUg7SUFDdkIsSUFBSXplLE9BQU93QyxJQUFJLEtBQUssU0FBUztRQUMzQixNQUFNLElBQUkrYixnQkFBZ0J2ZSxPQUFPK1YsUUFBUTtJQUMzQztJQUNBLE1BQU0ySSxZQUFZLElBQUkxSixjQUFjeUosT0FBT3plLE9BQU9pVixLQUFLLEVBQUVwSDtJQUN6RCxPQUFPNlEsVUFBVW5KLE9BQU8sQ0FBQ3FGO0FBQzNCO0FBRTRELENBQzVELDhCQUE4QiIsInNvdXJjZXMiOlsid2VicGFjazovL21iYy8uL25vZGVfbW9kdWxlcy9ncm9xLWpzL2Rpc3QvMS5tanM/OThjMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wJDUgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wJDUgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDUob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQkNSA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wJDUob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTtcbn1cbmZ1bmN0aW9uIHBhdGhSZWdFeHAocGF0dGVybikge1xuICBjb25zdCByZSA9IFtdO1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGF0dGVybi5zcGxpdChcIi5cIikpIHtcbiAgICBpZiAocGFydCA9PT0gXCIqXCIpIHtcbiAgICAgIHJlLnB1c2goXCJbXi5dK1wiKTtcbiAgICB9IGVsc2UgaWYgKHBhcnQgPT09IFwiKipcIikge1xuICAgICAgcmUucHVzaChcIi4qXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZS5wdXNoKGVzY2FwZVJlZ0V4cChwYXJ0KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgUmVnRXhwKFwiXlwiLmNvbmNhdChyZS5qb2luKFwiLlwiKSwgXCIkXCIpKTtcbn1cbmNsYXNzIFBhdGgge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgX19wdWJsaWNGaWVsZCQ1KHRoaXMsIFwicGF0dGVyblwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDUodGhpcywgXCJwYXR0ZXJuUmVcIik7XG4gICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybjtcbiAgICB0aGlzLnBhdHRlcm5SZSA9IHBhdGhSZWdFeHAocGF0dGVybik7XG4gIH1cbiAgbWF0Y2hlcyhzdHIpIHtcbiAgICByZXR1cm4gdGhpcy5wYXR0ZXJuUmUudGVzdChzdHIpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5wYXR0ZXJuO1xuICB9XG59XG5cbnZhciBfX2RlZlByb3AkNCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AkNCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkNChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCQ0ID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3AkNChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jbGFzcyBTdHJlYW1WYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKGdlbmVyYXRvcikge1xuICAgIF9fcHVibGljRmllbGQkNCh0aGlzLCBcInR5cGVcIiwgXCJzdHJlYW1cIik7XG4gICAgX19wdWJsaWNGaWVsZCQ0KHRoaXMsIFwiZ2VuZXJhdG9yXCIpO1xuICAgIF9fcHVibGljRmllbGQkNCh0aGlzLCBcInRpY2tlclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDQodGhpcywgXCJpc0RvbmVcIik7XG4gICAgX19wdWJsaWNGaWVsZCQ0KHRoaXMsIFwiZGF0YVwiKTtcbiAgICB0aGlzLmdlbmVyYXRvciA9IGdlbmVyYXRvcjtcbiAgICB0aGlzLnRpY2tlciA9IG51bGw7XG4gICAgdGhpcy5pc0RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLmRhdGEgPSBbXTtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICBpc0FycmF5KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGFzeW5jIGdldCgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIHRoaXMpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGF3YWl0IHZhbHVlLmdldCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhc3luYyAqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGZvciAoOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuZGF0YVtpXTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzRG9uZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLl9uZXh0VGljaygpO1xuICAgIH1cbiAgfVxuICBfbmV4dFRpY2soKSB7XG4gICAgaWYgKHRoaXMudGlja2VyKSB7XG4gICAgICByZXR1cm4gdGhpcy50aWNrZXI7XG4gICAgfVxuICAgIGxldCBjdXJyZW50UmVzb2x2ZXI7XG4gICAgY29uc3Qgc2V0dXBUaWNrZXIgPSAoKSA9PiB7XG4gICAgICB0aGlzLnRpY2tlciA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGN1cnJlbnRSZXNvbHZlciA9IHJlc29sdmU7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHRpY2sgPSAoKSA9PiB7XG4gICAgICBjdXJyZW50UmVzb2x2ZXIoKTtcbiAgICAgIHNldHVwVGlja2VyKCk7XG4gICAgfTtcbiAgICBjb25zdCBmZXRjaCA9IGFzeW5jICgpID0+IHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgdGhpcy5nZW5lcmF0b3IoKSkge1xuICAgICAgICB0aGlzLmRhdGEucHVzaCh2YWx1ZSk7XG4gICAgICAgIHRpY2soKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNEb25lID0gdHJ1ZTtcbiAgICAgIHRpY2soKTtcbiAgICB9O1xuICAgIHNldHVwVGlja2VyKCk7XG4gICAgZmV0Y2goKTtcbiAgICByZXR1cm4gdGhpcy50aWNrZXI7XG4gIH1cbn1cblxuY29uc3QgUkZDMzMzOV9SRUdFWCA9IC9eXFxkezR9LVxcZHsyfS1cXGR7Mn1UXFxkezJ9OlxcZHsyfTpcXGR7Mn0oXFwuXFxkKyk/KFp8KFstK11cXGR7Mn06XFxkezJ9KSkkLztcbmZ1bmN0aW9uIHBhcnNlUkZDMzMzOShzdHIpIHtcbiAgaWYgKFJGQzMzMzlfUkVHRVgudGVzdChzdHIpKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHN0cik7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmb3JtYXRSRkMzMzM5KGQpIHtcbiAgY29uc3QgeWVhciA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDRnVsbFllYXIoKSwgNCk7XG4gIGNvbnN0IG1vbnRoID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENNb250aCgpICsgMSwgMik7XG4gIGNvbnN0IGRheSA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDRGF0ZSgpLCAyKTtcbiAgY29uc3QgaG91ciA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDSG91cnMoKSwgMik7XG4gIGNvbnN0IG1pbnV0ZSA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDTWludXRlcygpLCAyKTtcbiAgY29uc3Qgc2Vjb25kID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENTZWNvbmRzKCksIDIpO1xuICBsZXQgZnJhY3Rpb25hbFNlY29uZCA9IFwiXCI7XG4gIGNvbnN0IG1pbGxpcyA9IGQuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gIGlmIChtaWxsaXMgIT0gMCkge1xuICAgIGZyYWN0aW9uYWxTZWNvbmQgPSBcIi5cIi5jb25jYXQoYWRkTGVhZGluZ1plcm8obWlsbGlzLCAzKSk7XG4gIH1cbiAgcmV0dXJuIFwiXCIuY29uY2F0KHllYXIsIFwiLVwiKS5jb25jYXQobW9udGgsIFwiLVwiKS5jb25jYXQoZGF5LCBcIlRcIikuY29uY2F0KGhvdXIsIFwiOlwiKS5jb25jYXQobWludXRlLCBcIjpcIikuY29uY2F0KHNlY29uZCkuY29uY2F0KGZyYWN0aW9uYWxTZWNvbmQsIFwiWlwiKTtcbn1cbmZ1bmN0aW9uIGFkZExlYWRpbmdaZXJvKG51bSwgdGFyZ2V0TGVuZ3RoKSB7XG4gIGxldCBzdHIgPSBudW0udG9TdHJpbmcoKTtcbiAgd2hpbGUgKHN0ci5sZW5ndGggPCB0YXJnZXRMZW5ndGgpIHtcbiAgICBzdHIgPSBcIjBcIi5jb25jYXQoc3RyKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuXG52YXIgX19kZWZQcm9wJDMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wJDMgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDMob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQkMyA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wJDMob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY2xhc3MgU3RhdGljVmFsdWUge1xuICBjb25zdHJ1Y3RvcihkYXRhLCB0eXBlKSB7XG4gICAgX19wdWJsaWNGaWVsZCQzKHRoaXMsIFwiZGF0YVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDModGhpcywgXCJ0eXBlXCIpO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxuICBpc0FycmF5KCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IFwiYXJyYXlcIjtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hd2FpdFxuICBhc3luYyBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgfVxuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuZGF0YSkpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKGRhdGEpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGRhdGEpIHtcbiAgICAgICAgICB5aWVsZCBmcm9tSlMoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0odGhpcy5kYXRhKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGl0ZXJhdGUgb3ZlcjogXCIuY29uY2F0KHRoaXMudHlwZSkpO1xuICB9XG59XG5jb25zdCBOVUxMX1ZBTFVFID0gbmV3IFN0YXRpY1ZhbHVlKG51bGwsIFwibnVsbFwiKTtcbmNvbnN0IFRSVUVfVkFMVUUgPSBuZXcgU3RhdGljVmFsdWUodHJ1ZSwgXCJib29sZWFuXCIpO1xuY29uc3QgRkFMU0VfVkFMVUUgPSBuZXcgU3RhdGljVmFsdWUoZmFsc2UsIFwiYm9vbGVhblwiKTtcbmNsYXNzIERhdGVUaW1lIHtcbiAgY29uc3RydWN0b3IoZGF0ZSkge1xuICAgIF9fcHVibGljRmllbGQkMyh0aGlzLCBcImRhdGVcIik7XG4gICAgdGhpcy5kYXRlID0gZGF0ZTtcbiAgfVxuICBzdGF0aWMgcGFyc2VUb1ZhbHVlKHN0cikge1xuICAgIGNvbnN0IGRhdGUgPSBwYXJzZVJGQzMzMzkoc3RyKTtcbiAgICBpZiAoZGF0ZSkge1xuICAgICAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShuZXcgRGF0ZVRpbWUoZGF0ZSksIFwiZGF0ZXRpbWVcIik7XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmRhdGUuZ2V0VGltZSgpID09IG90aGVyLmRhdGUuZ2V0VGltZSgpO1xuICB9XG4gIGFkZChzZWNzKSB7XG4gICAgY29uc3QgY29weSA9IG5ldyBEYXRlKHRoaXMuZGF0ZS5nZXRUaW1lKCkpO1xuICAgIGNvcHkuc2V0VGltZShjb3B5LmdldFRpbWUoKSArIHNlY3MgKiAxZTMpO1xuICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoY29weSk7XG4gIH1cbiAgZGlmZmVyZW5jZShvdGhlcikge1xuICAgIHJldHVybiAodGhpcy5kYXRlLmdldFRpbWUoKSAtIG90aGVyLmRhdGUuZ2V0VGltZSgpKSAvIDFlMztcbiAgfVxuICBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlLmdldFRpbWUoKSAtIG90aGVyLmRhdGUuZ2V0VGltZSgpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBmb3JtYXRSRkMzMzM5KHRoaXMuZGF0ZSk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZyb21OdW1iZXIobnVtKSB7XG4gIGlmIChOdW1iZXIuaXNGaW5pdGUobnVtKSkge1xuICAgIHJldHVybiBuZXcgU3RhdGljVmFsdWUobnVtLCBcIm51bWJlclwiKTtcbiAgfVxuICByZXR1cm4gTlVMTF9WQUxVRTtcbn1cbmZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyKSB7XG4gIHJldHVybiBuZXcgU3RhdGljVmFsdWUoc3RyLCBcInN0cmluZ1wiKTtcbn1cbmZ1bmN0aW9uIGZyb21EYXRlVGltZShkdCkge1xuICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKGR0LCBcImRhdGV0aW1lXCIpO1xufVxuZnVuY3Rpb24gZnJvbVBhdGgocGF0aCkge1xuICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKHBhdGgsIFwicGF0aFwiKTtcbn1cbmZ1bmN0aW9uIGlzSXRlcmF0b3Iob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIG9iai5uZXh0ID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBmcm9tSlModmFsKSB7XG4gIGlmIChpc0l0ZXJhdG9yKHZhbCkpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIHZhbCkge1xuICAgICAgICB5aWVsZCBmcm9tSlModmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIHJldHVybiBuZXcgU3RhdGljVmFsdWUodmFsLCBnZXRUeXBlKHZhbCkpO1xufVxuZnVuY3Rpb24gZ2V0VHlwZShkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsIHx8IHR5cGVvZiBkYXRhID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIFwibnVsbFwiO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgfVxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIFBhdGgpIHtcbiAgICByZXR1cm4gXCJwYXRoXCI7XG4gIH1cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBEYXRlVGltZSkge1xuICAgIHJldHVybiBcImRhdGV0aW1lXCI7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBkYXRhO1xufVxuXG5mdW5jdGlvbiBpc0VxdWFsKGEsIGIpIHtcbiAgaWYgKGEudHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBiLnR5cGUgPT09IFwic3RyaW5nXCIgfHwgYS50eXBlID09PSBcImJvb2xlYW5cIiAmJiBiLnR5cGUgPT09IFwiYm9vbGVhblwiIHx8IGEudHlwZSA9PT0gXCJudWxsXCIgJiYgYi50eXBlID09PSBcIm51bGxcIiB8fCBhLnR5cGUgPT09IFwibnVtYmVyXCIgJiYgYi50eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIGEuZGF0YSA9PT0gYi5kYXRhO1xuICB9XG4gIGlmIChhLnR5cGUgPT09IFwiZGF0ZXRpbWVcIiAmJiBiLnR5cGUgPT09IFwiZGF0ZXRpbWVcIikge1xuICAgIHJldHVybiBhLmRhdGEuZXF1YWxzKGIuZGF0YSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5jb25zdCBDSEFSUyA9IC8oW14hQCMkJV4mKigpLFxcXFwvP1wiOzp7fXxbXFxdKzw+XFxzLV0pKy9nO1xuY29uc3QgQ0hBUlNfV0lUSF9XSUxEQ0FSRCA9IC8oW14hQCMkJV4mKCksXFxcXC8/XCI7Ont9fFtcXF0rPD5cXHMtXSkrL2c7XG5jb25zdCBFREdFX0NIQVJTID0gLyhcXGJcXC4rfFxcLitcXGIpL2c7XG5jb25zdCBNQVhfVEVSTV9MRU5HVEggPSAxMDI0O1xuZnVuY3Rpb24gbWF0Y2hUZXh0KHRva2VucywgcGF0dGVybnMpIHtcbiAgaWYgKHRva2Vucy5sZW5ndGggPT09IDAgfHwgcGF0dGVybnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBwYXR0ZXJucy5ldmVyeSgocGF0dGVybikgPT4gcGF0dGVybih0b2tlbnMpKTtcbn1cbmZ1bmN0aW9uIG1hdGNoVG9rZW5pemUodGV4dCkge1xuICByZXR1cm4gdGV4dC5yZXBsYWNlKEVER0VfQ0hBUlMsIFwiXCIpLm1hdGNoKENIQVJTKSB8fCBbXTtcbn1cbmZ1bmN0aW9uIG1hdGNoQW5hbHl6ZVBhdHRlcm4odGV4dCkge1xuICBjb25zdCB0ZXJtc1JlID0gbWF0Y2hQYXR0ZXJuUmVnZXgodGV4dCk7XG4gIHJldHVybiB0ZXJtc1JlLm1hcCgocmUpID0+ICh0b2tlbnMpID0+IHRva2Vucy5zb21lKCh0b2tlbikgPT4gcmUudGVzdCh0b2tlbikpKTtcbn1cbmZ1bmN0aW9uIG1hdGNoUGF0dGVyblJlZ2V4KHRleHQpIHtcbiAgY29uc3QgdGVybXMgPSB0ZXh0LnJlcGxhY2UoRURHRV9DSEFSUywgXCJcIikubWF0Y2goQ0hBUlNfV0lUSF9XSUxEQ0FSRCkgfHwgW107XG4gIHJldHVybiB0ZXJtcy5tYXAoXG4gICAgKHRlcm0pID0+IG5ldyBSZWdFeHAoXCJeXCIuY29uY2F0KHRlcm0uc2xpY2UoMCwgTUFYX1RFUk1fTEVOR1RIKS5yZXBsYWNlKC9cXCovZywgXCIuKlwiKSwgXCIkXCIpLCBcImlcIilcbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdhdGhlclRleHQodmFsdWUsIGNiKSB7XG4gIGlmICh2YWx1ZS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgY2IodmFsdWUuZGF0YSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlLmlzQXJyYXkoKSkge1xuICAgIGxldCBzdWNjZXNzID0gdHJ1ZTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHBhcnQgb2YgdmFsdWUpIHtcbiAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY2IocGFydC5kYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3M7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5jb25zdCBUWVBFX09SREVSID0ge1xuICBkYXRldGltZTogMSxcbiAgbnVtYmVyOiAyLFxuICBzdHJpbmc6IDMsXG4gIGJvb2xlYW46IDRcbn07XG5mdW5jdGlvbiBwYXJ0aWFsQ29tcGFyZShhLCBiKSB7XG4gIGNvbnN0IGFUeXBlID0gZ2V0VHlwZShhKTtcbiAgY29uc3QgYlR5cGUgPSBnZXRUeXBlKGIpO1xuICBpZiAoYVR5cGUgIT09IGJUeXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc3dpdGNoIChhVHlwZSkge1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgcmV0dXJuIGEgLSBiO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIGlmIChhIDwgYilcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKGEgPiBiKVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIHJldHVybiAwO1xuICAgIGNhc2UgXCJkYXRldGltZVwiOlxuICAgICAgcmV0dXJuIGEuY29tcGFyZVRvKGIpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gdG90YWxDb21wYXJlKGEsIGIpIHtcbiAgY29uc3QgYVR5cGUgPSBnZXRUeXBlKGEpO1xuICBjb25zdCBiVHlwZSA9IGdldFR5cGUoYik7XG4gIGNvbnN0IGFUeXBlT3JkZXIgPSBUWVBFX09SREVSW2FUeXBlXSB8fCAxMDA7XG4gIGNvbnN0IGJUeXBlT3JkZXIgPSBUWVBFX09SREVSW2JUeXBlXSB8fCAxMDA7XG4gIGlmIChhVHlwZU9yZGVyICE9PSBiVHlwZU9yZGVyKSB7XG4gICAgcmV0dXJuIGFUeXBlT3JkZXIgLSBiVHlwZU9yZGVyO1xuICB9XG4gIGxldCByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShhLCBiKTtcbiAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgIHJlc3VsdCA9IDA7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3Qgb3BlcmF0b3JzID0ge1xuICBcIj09XCI6IGZ1bmN0aW9uIGVxKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIGlzRXF1YWwobGVmdCwgcmlnaHQpID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBcIiE9XCI6IGZ1bmN0aW9uIG5lcShsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiBpc0VxdWFsKGxlZnQsIHJpZ2h0KSA/IEZBTFNFX1ZBTFVFIDogVFJVRV9WQUxVRTtcbiAgfSxcbiAgXCI+XCI6IGZ1bmN0aW9uIGd0KGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJzdHJlYW1cIiB8fCByaWdodC50eXBlID09PSBcInN0cmVhbVwiKVxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCA+IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiPj1cIjogZnVuY3Rpb24gZ3RlKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJzdHJlYW1cIiB8fCByaWdodC50eXBlID09PSBcInN0cmVhbVwiKVxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCA+PSAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBcIjxcIjogZnVuY3Rpb24gbHQobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmVhbVwiIHx8IHJpZ2h0LnR5cGUgPT09IFwic3RyZWFtXCIpXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0IDwgMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgXCI8PVwiOiBmdW5jdGlvbiBsdGUobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmVhbVwiIHx8IHJpZ2h0LnR5cGUgPT09IFwic3RyZWFtXCIpXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0IDw9IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWUtbWF0Y2hpbmdcbiAgaW46IGFzeW5jIGZ1bmN0aW9uIGlub3AobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAocmlnaHQudHlwZSA9PT0gXCJwYXRoXCIpIHtcbiAgICAgIGlmIChsZWZ0LnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmlnaHQuZGF0YS5tYXRjaGVzKGxlZnQuZGF0YSkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gICAgfVxuICAgIGlmIChyaWdodC5pc0FycmF5KCkpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgYiBvZiByaWdodCkge1xuICAgICAgICBpZiAoaXNFcXVhbChsZWZ0LCBiKSkge1xuICAgICAgICAgIHJldHVybiBUUlVFX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gRkFMU0VfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9LFxuICBtYXRjaDogYXN5bmMgZnVuY3Rpb24gbWF0Y2gobGVmdCwgcmlnaHQpIHtcbiAgICBsZXQgdG9rZW5zID0gW107XG4gICAgbGV0IHBhdHRlcm5zID0gW107XG4gICAgYXdhaXQgZ2F0aGVyVGV4dChsZWZ0LCAocGFydCkgPT4ge1xuICAgICAgdG9rZW5zID0gdG9rZW5zLmNvbmNhdChtYXRjaFRva2VuaXplKHBhcnQpKTtcbiAgICB9KTtcbiAgICBjb25zdCBkaWRTdWNjZWVkID0gYXdhaXQgZ2F0aGVyVGV4dChyaWdodCwgKHBhcnQpID0+IHtcbiAgICAgIHBhdHRlcm5zID0gcGF0dGVybnMuY29uY2F0KG1hdGNoQW5hbHl6ZVBhdHRlcm4ocGFydCkpO1xuICAgIH0pO1xuICAgIGlmICghZGlkU3VjY2VlZCkge1xuICAgICAgcmV0dXJuIEZBTFNFX1ZBTFVFO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaGVkID0gbWF0Y2hUZXh0KHRva2VucywgcGF0dGVybnMpO1xuICAgIHJldHVybiBtYXRjaGVkID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBcIitcIjogZnVuY3Rpb24gcGx1cyhsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwiZGF0ZXRpbWVcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gZnJvbURhdGVUaW1lKGxlZnQuZGF0YS5hZGQocmlnaHQuZGF0YSkpO1xuICAgIH1cbiAgICBpZiAobGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBmcm9tTnVtYmVyKGxlZnQuZGF0YSArIHJpZ2h0LmRhdGEpO1xuICAgIH1cbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmluZ1wiICYmIHJpZ2h0LnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKGxlZnQuZGF0YSArIHJpZ2h0LmRhdGEpO1xuICAgIH1cbiAgICBpZiAobGVmdC50eXBlID09PSBcIm9iamVjdFwiICYmIHJpZ2h0LnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHJldHVybiBmcm9tSlMoeyAuLi5sZWZ0LmRhdGEsIC4uLnJpZ2h0LmRhdGEgfSk7XG4gICAgfVxuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwiYXJyYXlcIiAmJiByaWdodC50eXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgIHJldHVybiBmcm9tSlMobGVmdC5kYXRhLmNvbmNhdChyaWdodC5kYXRhKSk7XG4gICAgfVxuICAgIGlmIChsZWZ0LmlzQXJyYXkoKSAmJiByaWdodC5pc0FycmF5KCkpIHtcbiAgICAgIHJldHVybiBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWwgb2YgbGVmdCkge1xuICAgICAgICAgIHlpZWxkIHZhbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbCBvZiByaWdodCkge1xuICAgICAgICAgIHlpZWxkIHZhbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9LFxuICBcIi1cIjogZnVuY3Rpb24gbWludXMobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC50eXBlID09PSBcImRhdGV0aW1lXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIGZyb21EYXRlVGltZShsZWZ0LmRhdGEuYWRkKC1yaWdodC5kYXRhKSk7XG4gICAgfVxuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwiZGF0ZXRpbWVcIiAmJiByaWdodC50eXBlID09PSBcImRhdGV0aW1lXCIpIHtcbiAgICAgIHJldHVybiBmcm9tTnVtYmVyKGxlZnQuZGF0YS5kaWZmZXJlbmNlKHJpZ2h0LmRhdGEpKTtcbiAgICB9XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJudW1iZXJcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gZnJvbU51bWJlcihsZWZ0LmRhdGEgLSByaWdodC5kYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH0sXG4gIFwiKlwiOiBudW1lcmljT3BlcmF0b3IoKGEsIGIpID0+IGEgKiBiKSxcbiAgXCIvXCI6IG51bWVyaWNPcGVyYXRvcigoYSwgYikgPT4gYSAvIGIpLFxuICBcIiVcIjogbnVtZXJpY09wZXJhdG9yKChhLCBiKSA9PiBhICUgYiksXG4gIFwiKipcIjogbnVtZXJpY09wZXJhdG9yKChhLCBiKSA9PiBNYXRoLnBvdyhhLCBiKSlcbn07XG5mdW5jdGlvbiBudW1lcmljT3BlcmF0b3IoaW1wbCkge1xuICByZXR1cm4gZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGltcGwobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICAgIHJldHVybiBmcm9tTnVtYmVyKHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9O1xufVxuXG52YXIgX19kZWZQcm9wJDIgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wJDIgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDIob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQkMiA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wJDIob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY2xhc3MgU2NvcGUge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuICBjb25zdHJ1Y3RvcihwYXJhbXMsIHNvdXJjZSwgdmFsdWUsIGNvbnRleHQsIHBhcmVudCkge1xuICAgIF9fcHVibGljRmllbGQkMih0aGlzLCBcInBhcmFtc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDIodGhpcywgXCJzb3VyY2VcIik7XG4gICAgX19wdWJsaWNGaWVsZCQyKHRoaXMsIFwidmFsdWVcIik7XG4gICAgX19wdWJsaWNGaWVsZCQyKHRoaXMsIFwicGFyZW50XCIpO1xuICAgIF9fcHVibGljRmllbGQkMih0aGlzLCBcImNvbnRleHRcIik7XG4gICAgX19wdWJsaWNGaWVsZCQyKHRoaXMsIFwiaXNIaWRkZW5cIiwgZmFsc2UpO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB9XG4gIGNyZWF0ZU5lc3RlZCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmlzSGlkZGVuKSB7XG4gICAgICByZXR1cm4gbmV3IFNjb3BlKHRoaXMucGFyYW1zLCB0aGlzLnNvdXJjZSwgdmFsdWUsIHRoaXMuY29udGV4dCwgdGhpcy5wYXJlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFNjb3BlKHRoaXMucGFyYW1zLCB0aGlzLnNvdXJjZSwgdmFsdWUsIHRoaXMuY29udGV4dCwgdGhpcyk7XG4gIH1cbiAgY3JlYXRlSGlkZGVuKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jcmVhdGVOZXN0ZWQodmFsdWUpO1xuICAgIHJlc3VsdC5pc0hpZGRlbiA9IHRydWU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmFsdWF0ZShub2RlLCBzY29wZSwgZXhlY3V0ZSA9IGV2YWx1YXRlKSB7XG4gIGNvbnN0IGZ1bmMgPSBFWEVDVVRPUlNbbm9kZS50eXBlXTtcbiAgcmV0dXJuIGZ1bmMobm9kZSwgc2NvcGUsIGV4ZWN1dGUpO1xufVxuZnVuY3Rpb24gcHJvbWlzZWxlc3NBcHBseSh2YWx1ZSwgY2IpIHtcbiAgaWYgKFwidGhlblwiIGluIHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRoZW4oY2IpO1xuICB9XG4gIHJldHVybiBjYih2YWx1ZSk7XG59XG5jb25zdCBFWEVDVVRPUlMgPSB7XG4gIFRoaXMoXywgc2NvcGUpIHtcbiAgICByZXR1cm4gc2NvcGUudmFsdWU7XG4gIH0sXG4gIFNlbGVjdG9yKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNlbGVjdG9ycyBjYW4gbm90IGJlIGV2YWx1YXRlZFwiKTtcbiAgfSxcbiAgRXZlcnl0aGluZyhfLCBzY29wZSkge1xuICAgIHJldHVybiBzY29wZS5zb3VyY2U7XG4gIH0sXG4gIFBhcmFtZXRlcih7IG5hbWUgfSwgc2NvcGUpIHtcbiAgICByZXR1cm4gZnJvbUpTKHNjb3BlLnBhcmFtc1tuYW1lXSk7XG4gIH0sXG4gIENvbnRleHQoeyBrZXkgfSwgc2NvcGUpIHtcbiAgICBpZiAoa2V5ID09PSBcImJlZm9yZVwiIHx8IGtleSA9PT0gXCJhZnRlclwiKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHNjb3BlLmNvbnRleHRba2V5XTtcbiAgICAgIHJldHVybiB2YWx1ZSB8fCBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGNvbnRleHQga2V5OiBcIi5jb25jYXQoa2V5KSk7XG4gIH0sXG4gIFBhcmVudCh7IG4gfSwgc2NvcGUpIHtcbiAgICBsZXQgY3VycmVudCA9IHNjb3BlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBpZiAoIWN1cnJlbnQucGFyZW50KSB7XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudC52YWx1ZTtcbiAgfSxcbiAgT3BDYWxsKHsgb3AsIGxlZnQsIHJpZ2h0IH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgZnVuYyA9IG9wZXJhdG9yc1tvcF07XG4gICAgaWYgKCFmdW5jKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9wZXJhdG9yOiBcIi5jb25jYXQob3ApKTtcbiAgICB9XG4gICAgY29uc3QgbGVmdFZhbHVlID0gZXhlY3V0ZShsZWZ0LCBzY29wZSk7XG4gICAgY29uc3QgcmlnaHRWYWx1ZSA9IGV4ZWN1dGUocmlnaHQsIHNjb3BlKTtcbiAgICBpZiAoXCJ0aGVuXCIgaW4gbGVmdFZhbHVlIHx8IFwidGhlblwiIGluIHJpZ2h0VmFsdWUpIHtcbiAgICAgIHJldHVybiAoYXN5bmMgKCkgPT4gZnVuYyhhd2FpdCBsZWZ0VmFsdWUsIGF3YWl0IHJpZ2h0VmFsdWUpKSgpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYyhsZWZ0VmFsdWUsIHJpZ2h0VmFsdWUpO1xuICB9LFxuICBhc3luYyBTZWxlY3QoeyBhbHRlcm5hdGl2ZXMsIGZhbGxiYWNrIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgZm9yIChjb25zdCBhbHQgb2YgYWx0ZXJuYXRpdmVzKSB7XG4gICAgICBjb25zdCBhbHRDb25kID0gYXdhaXQgZXhlY3V0ZShhbHQuY29uZGl0aW9uLCBzY29wZSk7XG4gICAgICBpZiAoYWx0Q29uZC50eXBlID09PSBcImJvb2xlYW5cIiAmJiBhbHRDb25kLmRhdGEgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGUoYWx0LnZhbHVlLCBzY29wZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGV4ZWN1dGUoZmFsbGJhY2ssIHNjb3BlKTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIEluUmFuZ2UoeyBiYXNlLCBsZWZ0LCByaWdodCwgaXNJbmNsdXNpdmUgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGNvbnN0IGxlZnRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUobGVmdCwgc2NvcGUpO1xuICAgIGNvbnN0IHJpZ2h0VmFsdWUgPSBhd2FpdCBleGVjdXRlKHJpZ2h0LCBzY29wZSk7XG4gICAgY29uc3QgbGVmdENtcCA9IHBhcnRpYWxDb21wYXJlKGF3YWl0IHZhbHVlLmdldCgpLCBhd2FpdCBsZWZ0VmFsdWUuZ2V0KCkpO1xuICAgIGlmIChsZWZ0Q21wID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgY29uc3QgcmlnaHRDbXAgPSBwYXJ0aWFsQ29tcGFyZShhd2FpdCB2YWx1ZS5nZXQoKSwgYXdhaXQgcmlnaHRWYWx1ZS5nZXQoKSk7XG4gICAgaWYgKHJpZ2h0Q21wID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgaWYgKGlzSW5jbHVzaXZlKSB7XG4gICAgICByZXR1cm4gbGVmdENtcCA+PSAwICYmIHJpZ2h0Q21wIDw9IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiBsZWZ0Q21wID49IDAgJiYgcmlnaHRDbXAgPCAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBhc3luYyBGaWx0ZXIoeyBiYXNlLCBleHByIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKCFiYXNlVmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGJhc2VWYWx1ZSkge1xuICAgICAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZChlbGVtKTtcbiAgICAgICAgY29uc3QgZXhwclZhbHVlID0gYXdhaXQgZXhlY3V0ZShleHByLCBuZXdTY29wZSk7XG4gICAgICAgIGlmIChleHByVmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgZXhwclZhbHVlLmRhdGEgPT09IHRydWUpIHtcbiAgICAgICAgICB5aWVsZCBlbGVtO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIGFzeW5jIFByb2plY3Rpb24oeyBiYXNlLCBleHByIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKGJhc2VWYWx1ZS50eXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQoYmFzZVZhbHVlKTtcbiAgICByZXR1cm4gZXhlY3V0ZShleHByLCBuZXdTY29wZSk7XG4gIH0sXG4gIEZ1bmNDYWxsKHsgZnVuYywgYXJncyB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBmdW5jKGFyZ3MsIHNjb3BlLCBleGVjdXRlKTtcbiAgfSxcbiAgYXN5bmMgUGlwZUZ1bmNDYWxsKHsgZnVuYywgYmFzZSwgYXJncyB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIHJldHVybiBmdW5jKGJhc2VWYWx1ZSwgYXJncywgc2NvcGUsIGV4ZWN1dGUpO1xuICB9LFxuICBhc3luYyBBY2Nlc3NBdHRyaWJ1dGUoeyBiYXNlLCBuYW1lIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHZhbHVlID0gc2NvcGUudmFsdWU7XG4gICAgaWYgKGJhc2UpIHtcbiAgICAgIHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBpZiAodmFsdWUuZGF0YS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICByZXR1cm4gZnJvbUpTKHZhbHVlLmRhdGFbbmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgQWNjZXNzRWxlbWVudCh7IGJhc2UsIGluZGV4IH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKCFiYXNlVmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGJhc2VWYWx1ZS5nZXQoKTtcbiAgICBjb25zdCBmaW5hbEluZGV4ID0gaW5kZXggPCAwID8gaW5kZXggKyBkYXRhLmxlbmd0aCA6IGluZGV4O1xuICAgIHJldHVybiBmcm9tSlMoZGF0YVtmaW5hbEluZGV4XSk7XG4gIH0sXG4gIGFzeW5jIFNsaWNlKHsgYmFzZSwgbGVmdCwgcmlnaHQsIGlzSW5jbHVzaXZlIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKCFiYXNlVmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgY29uc3QgYXJyYXkgPSBhd2FpdCBiYXNlVmFsdWUuZ2V0KCk7XG4gICAgbGV0IGxlZnRJZHggPSBsZWZ0O1xuICAgIGxldCByaWdodElkeCA9IHJpZ2h0O1xuICAgIGlmIChsZWZ0SWR4IDwgMCkge1xuICAgICAgbGVmdElkeCA9IGFycmF5Lmxlbmd0aCArIGxlZnRJZHg7XG4gICAgfVxuICAgIGlmIChyaWdodElkeCA8IDApIHtcbiAgICAgIHJpZ2h0SWR4ID0gYXJyYXkubGVuZ3RoICsgcmlnaHRJZHg7XG4gICAgfVxuICAgIGlmIChpc0luY2x1c2l2ZSkge1xuICAgICAgcmlnaHRJZHgrKztcbiAgICB9XG4gICAgaWYgKGxlZnRJZHggPCAwKSB7XG4gICAgICBsZWZ0SWR4ID0gMDtcbiAgICB9XG4gICAgaWYgKHJpZ2h0SWR4IDwgMCkge1xuICAgICAgcmlnaHRJZHggPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnJvbUpTKGFycmF5LnNsaWNlKGxlZnRJZHgsIHJpZ2h0SWR4KSk7XG4gIH0sXG4gIGFzeW5jIERlcmVmKHsgYmFzZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKCFzY29wZS5zb3VyY2UuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLnR5cGUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IHZhbHVlLmRhdGEuX3JlZjtcbiAgICBpZiAodHlwZW9mIGlkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgaWYgKHNjb3BlLmNvbnRleHQuZGVyZWZlcmVuY2UpIHtcbiAgICAgIHJldHVybiBmcm9tSlMoYXdhaXQgc2NvcGUuY29udGV4dC5kZXJlZmVyZW5jZSh7IF9yZWY6IGlkIH0pKTtcbiAgICB9XG4gICAgZm9yIGF3YWl0IChjb25zdCBkb2Mgb2Ygc2NvcGUuc291cmNlKSB7XG4gICAgICBpZiAoZG9jLnR5cGUgPT09IFwib2JqZWN0XCIgJiYgaWQgPT09IGRvYy5kYXRhLl9pZCkge1xuICAgICAgICByZXR1cm4gZG9jO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgVmFsdWUoeyB2YWx1ZSB9KSB7XG4gICAgcmV0dXJuIGZyb21KUyh2YWx1ZSk7XG4gIH0sXG4gIEdyb3VwKHsgYmFzZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgfSxcbiAgYXN5bmMgT2JqZWN0KHsgYXR0cmlidXRlcyB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgYXR0ciBvZiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyVHlwZSA9IGF0dHIudHlwZTtcbiAgICAgIHN3aXRjaCAoYXR0ci50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJPYmplY3RBdHRyaWJ1dGVWYWx1ZVwiOiB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGF0dHIudmFsdWUsIHNjb3BlKTtcbiAgICAgICAgICByZXN1bHRbYXR0ci5uYW1lXSA9IGF3YWl0IHZhbHVlLmdldCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJPYmplY3RDb25kaXRpb25hbFNwbGF0XCI6IHtcbiAgICAgICAgICBjb25zdCBjb25kID0gYXdhaXQgZXhlY3V0ZShhdHRyLmNvbmRpdGlvbiwgc2NvcGUpO1xuICAgICAgICAgIGlmIChjb25kLnR5cGUgIT09IFwiYm9vbGVhblwiIHx8IGNvbmQuZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXR0ci52YWx1ZSwgc2NvcGUpO1xuICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHJlc3VsdCwgdmFsdWUuZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJPYmplY3RTcGxhdFwiOiB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGF0dHIudmFsdWUsIHNjb3BlKTtcbiAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHZhbHVlLmRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbm9kZSB0eXBlOiBcIi5jb25jYXQoYXR0clR5cGUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZyb21KUyhyZXN1bHQpO1xuICB9LFxuICBBcnJheSh7IGVsZW1lbnRzIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShlbGVtZW50LnZhbHVlLCBzY29wZSk7XG4gICAgICAgIGlmIChlbGVtZW50LmlzU3BsYXQpIHtcbiAgICAgICAgICBpZiAodmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgeWllbGQgdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeWllbGQgdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgVHVwbGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidHVwbGVzIGNhbiBub3QgYmUgZXZhbHVhdGVkXCIpO1xuICB9LFxuICBhc3luYyBPcih7IGxlZnQsIHJpZ2h0IH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgbGVmdFZhbHVlID0gYXdhaXQgZXhlY3V0ZShsZWZ0LCBzY29wZSk7XG4gICAgY29uc3QgcmlnaHRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUocmlnaHQsIHNjb3BlKTtcbiAgICBpZiAobGVmdFZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICBpZiAobGVmdFZhbHVlLmRhdGEgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFRSVUVfVkFMVUU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyaWdodFZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICBpZiAocmlnaHRWYWx1ZS5kYXRhID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBUUlVFX1ZBTFVFO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGVmdFZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiIHx8IHJpZ2h0VmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICByZXR1cm4gRkFMU0VfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIEFuZCh7IGxlZnQsIHJpZ2h0IH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgbGVmdFZhbHVlID0gYXdhaXQgZXhlY3V0ZShsZWZ0LCBzY29wZSk7XG4gICAgY29uc3QgcmlnaHRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUocmlnaHQsIHNjb3BlKTtcbiAgICBpZiAobGVmdFZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICBpZiAobGVmdFZhbHVlLmRhdGEgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBGQUxTRV9WQUxVRTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJpZ2h0VmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIGlmIChyaWdodFZhbHVlLmRhdGEgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBGQUxTRV9WQUxVRTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxlZnRWYWx1ZS50eXBlICE9PSBcImJvb2xlYW5cIiB8fCByaWdodFZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIFRSVUVfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIE5vdCh7IGJhc2UgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGlmICh2YWx1ZS50eXBlICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5kYXRhID8gRkFMU0VfVkFMVUUgOiBUUlVFX1ZBTFVFO1xuICB9LFxuICBOZWcoeyBiYXNlIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIHByb21pc2VsZXNzQXBwbHkoZXhlY3V0ZShiYXNlLCBzY29wZSksICh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbU51bWJlcigtdmFsdWUuZGF0YSk7XG4gICAgfSk7XG4gIH0sXG4gIFBvcyh7IGJhc2UgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICByZXR1cm4gcHJvbWlzZWxlc3NBcHBseShleGVjdXRlKGJhc2UsIHNjb3BlKSwgKHZhbHVlKSA9PiB7XG4gICAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tTnVtYmVyKHZhbHVlLmRhdGEpO1xuICAgIH0pO1xuICB9LFxuICBBc2MoKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH0sXG4gIERlc2MoKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIEFycmF5Q29lcmNlKHsgYmFzZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgcmV0dXJuIHZhbHVlLmlzQXJyYXkoKSA/IHZhbHVlIDogTlVMTF9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgTWFwKHsgYmFzZSwgZXhwciB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKCF2YWx1ZS5pc0FycmF5KCkpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVIaWRkZW4oZWxlbSk7XG4gICAgICAgIHlpZWxkIGF3YWl0IGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBhc3luYyBGbGF0TWFwKHsgYmFzZSwgZXhwciB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKCF2YWx1ZS5pc0FycmF5KCkpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVIaWRkZW4oZWxlbSk7XG4gICAgICAgIGNvbnN0IGlubmVyVmFsdWUgPSBhd2FpdCBleGVjdXRlKGV4cHIsIG5ld1Njb3BlKTtcbiAgICAgICAgaWYgKGlubmVyVmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBpbm5lciBvZiBpbm5lclZhbHVlKSB7XG4gICAgICAgICAgICB5aWVsZCBpbm5lcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeWllbGQgaW5uZXJWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gZXZhbHVhdGVRdWVyeSh0cmVlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qgcm9vdCA9IGZyb21KUyhvcHRpb25zLnJvb3QpO1xuICBjb25zdCBkYXRhc2V0ID0gZnJvbUpTKG9wdGlvbnMuZGF0YXNldCk7XG4gIGNvbnN0IHBhcmFtcyA9IHsgLi4ub3B0aW9ucy5wYXJhbXMgfTtcbiAgY29uc3Qgc2NvcGUgPSBuZXcgU2NvcGUoXG4gICAgcGFyYW1zLFxuICAgIGRhdGFzZXQsXG4gICAgcm9vdCxcbiAgICB7XG4gICAgICB0aW1lc3RhbXA6IG9wdGlvbnMudGltZXN0YW1wIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgaWRlbnRpdHk6IG9wdGlvbnMuaWRlbnRpdHkgPT09IHZvaWQgMCA/IFwibWVcIiA6IG9wdGlvbnMuaWRlbnRpdHksXG4gICAgICBzYW5pdHk6IG9wdGlvbnMuc2FuaXR5LFxuICAgICAgYWZ0ZXI6IG9wdGlvbnMuYWZ0ZXIgPyBmcm9tSlMob3B0aW9ucy5hZnRlcikgOiBudWxsLFxuICAgICAgYmVmb3JlOiBvcHRpb25zLmJlZm9yZSA/IGZyb21KUyhvcHRpb25zLmJlZm9yZSkgOiBudWxsLFxuICAgICAgZGVyZWZlcmVuY2U6IG9wdGlvbnMuZGVyZWZlcmVuY2VcbiAgICB9LFxuICAgIG51bGxcbiAgKTtcbiAgcmV0dXJuIGV2YWx1YXRlKHRyZWUsIHNjb3BlKTtcbn1cblxuZnVuY3Rpb24gY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlKSB7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkdyb3VwXCI6XG4gICAgICByZXR1cm4gY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlLmJhc2UpO1xuICAgIGNhc2UgXCJWYWx1ZVwiOlxuICAgIGNhc2UgXCJQYXJhbWV0ZXJcIjpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgXCJQb3NcIjpcbiAgICBjYXNlIFwiTmVnXCI6XG4gICAgICByZXR1cm4gY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlLmJhc2UpO1xuICAgIGNhc2UgXCJPcENhbGxcIjpcbiAgICAgIHN3aXRjaCAobm9kZS5vcCkge1xuICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICBjYXNlIFwiLVwiOlxuICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICBjYXNlIFwiL1wiOlxuICAgICAgICBjYXNlIFwiJVwiOlxuICAgICAgICBjYXNlIFwiKipcIjpcbiAgICAgICAgICByZXR1cm4gY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlLmxlZnQpICYmIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZS5yaWdodCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmNvbnN0IERVTU1ZX1NDT1BFID0gbmV3IFNjb3BlKFxuICB7fSxcbiAgTlVMTF9WQUxVRSxcbiAgTlVMTF9WQUxVRSxcbiAgeyB0aW1lc3RhbXA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgwKSwgaWRlbnRpdHk6IFwibWVcIiwgYmVmb3JlOiBudWxsLCBhZnRlcjogbnVsbCB9LFxuICBudWxsXG4pO1xuZnVuY3Rpb24gdHJ5Q29uc3RhbnRFdmFsdWF0ZShub2RlKSB7XG4gIGlmICghY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjb25zdGFudEV2YWx1YXRlKG5vZGUpO1xufVxuZnVuY3Rpb24gY29uc3RhbnRFdmFsdWF0ZShub2RlKSB7XG4gIGNvbnN0IHZhbHVlID0gZXZhbHVhdGUobm9kZSwgRFVNTVlfU0NPUEUsIGNvbnN0YW50RXZhbHVhdGUpO1xuICBpZiAoXCJ0aGVuXCIgaW4gdmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCVUc6IGNvbnN0YW50IGV2YWx1YXRlIHNob3VsZCBuZXZlciByZXR1cm4gYSBwcm9taXNlXCIpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcG9ydGFibGVUZXh0Q29udGVudCh2YWx1ZSkge1xuICBpZiAodmFsdWUudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBibG9ja1RleHQodmFsdWUuZGF0YSk7XG4gIH0gZWxzZSBpZiAodmFsdWUuaXNBcnJheSgpKSB7XG4gICAgY29uc3QgdGV4dHMgPSBhd2FpdCBhcnJheVRleHQodmFsdWUpO1xuICAgIGlmICh0ZXh0cy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGV4dHMuam9pbihcIlxcblxcblwiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5hc3luYyBmdW5jdGlvbiBhcnJheVRleHQodmFsdWUsIHJlc3VsdCA9IFtdKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgYmxvY2sgb2YgdmFsdWUpIHtcbiAgICBpZiAoYmxvY2sudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3QgdGV4dCA9IGJsb2NrVGV4dChibG9jay5kYXRhKTtcbiAgICAgIGlmICh0ZXh0ICE9PSBudWxsKVxuICAgICAgICByZXN1bHQucHVzaCh0ZXh0KTtcbiAgICB9IGVsc2UgaWYgKGJsb2NrLmlzQXJyYXkoKSkge1xuICAgICAgYXdhaXQgYXJyYXlUZXh0KGJsb2NrLCByZXN1bHQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYmxvY2tUZXh0KG9iaikge1xuICBpZiAodHlwZW9mIG9iai5fdHlwZSAhPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgY2hpbGRyZW4gPSBvYmouY2hpbGRyZW47XG4gIGlmICghQXJyYXkuaXNBcnJheShjaGlsZHJlbikpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgaWYgKGNoaWxkICYmIHR5cGVvZiBjaGlsZCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgY2hpbGQuX3R5cGUgPT09IFwic3RyaW5nXCIgJiYgY2hpbGQuX3R5cGUgPT09IFwic3BhblwiICYmIHR5cGVvZiBjaGlsZC50ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXN1bHQgKz0gY2hpbGQudGV4dDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3QgQk0yNWsgPSAxLjI7XG5hc3luYyBmdW5jdGlvbiBldmFsdWF0ZVNjb3JlKG5vZGUsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IFwiT3BDYWxsXCIgJiYgbm9kZS5vcCA9PT0gXCJtYXRjaFwiKSB7XG4gICAgcmV0dXJuIGV2YWx1YXRlTWF0Y2hTY29yZShub2RlLmxlZnQsIG5vZGUucmlnaHQsIHNjb3BlLCBleGVjdXRlKTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSBcIkZ1bmNDYWxsXCIgJiYgbm9kZS5uYW1lID09PSBcImJvb3N0XCIpIHtcbiAgICBjb25zdCBpbm5lclNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZShub2RlLmFyZ3NbMF0sIHNjb3BlLCBleGVjdXRlKTtcbiAgICBjb25zdCBib29zdCA9IGF3YWl0IGV4ZWN1dGUobm9kZS5hcmdzWzFdLCBzY29wZSk7XG4gICAgaWYgKGJvb3N0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgaW5uZXJTY29yZSA+IDApIHtcbiAgICAgIHJldHVybiBpbm5lclNjb3JlICsgYm9vc3QuZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiT3JcIjoge1xuICAgICAgY29uc3QgbGVmdFNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZShub2RlLmxlZnQsIHNjb3BlLCBleGVjdXRlKTtcbiAgICAgIGNvbnN0IHJpZ2h0U2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUucmlnaHQsIHNjb3BlLCBleGVjdXRlKTtcbiAgICAgIHJldHVybiBsZWZ0U2NvcmUgKyByaWdodFNjb3JlO1xuICAgIH1cbiAgICBjYXNlIFwiQW5kXCI6IHtcbiAgICAgIGNvbnN0IGxlZnRTY29yZSA9IGF3YWl0IGV2YWx1YXRlU2NvcmUobm9kZS5sZWZ0LCBzY29wZSwgZXhlY3V0ZSk7XG4gICAgICBjb25zdCByaWdodFNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZShub2RlLnJpZ2h0LCBzY29wZSwgZXhlY3V0ZSk7XG4gICAgICBpZiAobGVmdFNjb3JlID09PSAwIHx8IHJpZ2h0U2NvcmUgPT09IDApXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgcmV0dXJuIGxlZnRTY29yZSArIHJpZ2h0U2NvcmU7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGV4ZWN1dGUobm9kZSwgc2NvcGUpO1xuICAgICAgcmV0dXJuIHJlcy50eXBlID09PSBcImJvb2xlYW5cIiAmJiByZXMuZGF0YSA9PT0gdHJ1ZSA/IDEgOiAwO1xuICAgIH1cbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZXZhbHVhdGVNYXRjaFNjb3JlKGxlZnQsIHJpZ2h0LCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB0ZXh0ID0gYXdhaXQgZXhlY3V0ZShsZWZ0LCBzY29wZSk7XG4gIGNvbnN0IHBhdHRlcm4gPSBhd2FpdCBleGVjdXRlKHJpZ2h0LCBzY29wZSk7XG4gIGxldCB0b2tlbnMgPSBbXTtcbiAgbGV0IHRlcm1zID0gW107XG4gIGF3YWl0IGdhdGhlclRleHQodGV4dCwgKHBhcnQpID0+IHtcbiAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KG1hdGNoVG9rZW5pemUocGFydCkpO1xuICB9KTtcbiAgY29uc3QgZGlkU3VjY2VlZCA9IGF3YWl0IGdhdGhlclRleHQocGF0dGVybiwgKHBhcnQpID0+IHtcbiAgICB0ZXJtcyA9IHRlcm1zLmNvbmNhdChtYXRjaFBhdHRlcm5SZWdleChwYXJ0KSk7XG4gIH0pO1xuICBpZiAoIWRpZFN1Y2NlZWQpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCB8fCB0ZXJtcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBsZXQgc2NvcmUgPSAwO1xuICBmb3IgKGNvbnN0IHJlIG9mIHRlcm1zKSB7XG4gICAgY29uc3QgZnJlcSA9IHRva2Vucy5yZWR1Y2UoKGMsIHRva2VuKSA9PiBjICsgKHJlLnRlc3QodG9rZW4pID8gMSA6IDApLCAwKTtcbiAgICBzY29yZSArPSBmcmVxICogKEJNMjVrICsgMSkgLyAoZnJlcSArIEJNMjVrKTtcbiAgfVxuICByZXR1cm4gc2NvcmU7XG59XG5cbmZ1bmN0aW9uIGhhc1JlZmVyZW5jZSh2YWx1ZSwgcGF0aFNldCkge1xuICBzd2l0Y2ggKGdldFR5cGUodmFsdWUpKSB7XG4gICAgY2FzZSBcImFycmF5XCI6XG4gICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICAgICAgaWYgKGhhc1JlZmVyZW5jZSh2LCBwYXRoU2V0KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICBpZiAodmFsdWUuX3JlZikge1xuICAgICAgICByZXR1cm4gcGF0aFNldC5oYXModmFsdWUuX3JlZik7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHYgb2YgT2JqZWN0LnZhbHVlcyh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGhhc1JlZmVyZW5jZSh2LCBwYXRoU2V0KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjb3VudFVURjgoc3RyKSB7XG4gIGxldCBjb3VudDIgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA+PSA1NTI5NiAmJiBjb2RlIDw9IDU2MzE5KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY291bnQyKys7XG4gIH1cbiAgcmV0dXJuIGNvdW50Mjtcbn1cbmNvbnN0IF9nbG9iYWwgPSB7fTtcbl9nbG9iYWwuYW55d2hlcmUgPSBhc3luYyBmdW5jdGlvbiBhbnl3aGVyZSgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufTtcbl9nbG9iYWwuYW55d2hlcmUuYXJpdHkgPSAxO1xuX2dsb2JhbC5jb2FsZXNjZSA9IGFzeW5jIGZ1bmN0aW9uIGNvYWxlc2NlKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnLCBzY29wZSk7XG4gICAgaWYgKHZhbHVlLnR5cGUgIT09IFwibnVsbFwiKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBOVUxMX1ZBTFVFO1xufTtcbl9nbG9iYWwuY291bnQgPSBhc3luYyBmdW5jdGlvbiBjb3VudChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBpbm5lciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoIWlubmVyLmlzQXJyYXkoKSkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGxldCBudW0gPSAwO1xuICBmb3IgYXdhaXQgKGNvbnN0IF8gb2YgaW5uZXIpIHtcbiAgICBudW0rKztcbiAgfVxuICByZXR1cm4gZnJvbU51bWJlcihudW0pO1xufTtcbl9nbG9iYWwuY291bnQuYXJpdHkgPSAxO1xuX2dsb2JhbC5kYXRlVGltZSA9IGFzeW5jIGZ1bmN0aW9uIGRhdGVUaW1lKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHZhbCA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAodmFsLnR5cGUgPT09IFwiZGF0ZXRpbWVcIikge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgaWYgKHZhbC50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgcmV0dXJuIERhdGVUaW1lLnBhcnNlVG9WYWx1ZSh2YWwuZGF0YSk7XG59O1xuX2dsb2JhbC5kYXRlVGltZS5hcml0eSA9IDE7XG5fZ2xvYmFsLmRlZmluZWQgPSBhc3luYyBmdW5jdGlvbiBkZWZpbmVkKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGlubmVyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIHJldHVybiBpbm5lci50eXBlID09PSBcIm51bGxcIiA/IEZBTFNFX1ZBTFVFIDogVFJVRV9WQUxVRTtcbn07XG5fZ2xvYmFsLmRlZmluZWQuYXJpdHkgPSAxO1xuX2dsb2JhbC5pZGVudGl0eSA9IGFzeW5jIGZ1bmN0aW9uIGlkZW50aXR5KGFyZ3MsIHNjb3BlKSB7XG4gIHJldHVybiBmcm9tU3RyaW5nKHNjb3BlLmNvbnRleHQuaWRlbnRpdHkpO1xufTtcbl9nbG9iYWwuaWRlbnRpdHkuYXJpdHkgPSAwO1xuX2dsb2JhbC5sZW5ndGggPSBhc3luYyBmdW5jdGlvbiBsZW5ndGgoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgaW5uZXIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKGlubmVyLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZnJvbU51bWJlcihjb3VudFVURjgoaW5uZXIuZGF0YSkpO1xuICB9XG4gIGlmIChpbm5lci5pc0FycmF5KCkpIHtcbiAgICBsZXQgbnVtID0gMDtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IF8gb2YgaW5uZXIpIHtcbiAgICAgIG51bSsrO1xuICAgIH1cbiAgICByZXR1cm4gZnJvbU51bWJlcihudW0pO1xuICB9XG4gIHJldHVybiBOVUxMX1ZBTFVFO1xufTtcbl9nbG9iYWwubGVuZ3RoLmFyaXR5ID0gMTtcbl9nbG9iYWwucGF0aCA9IGFzeW5jIGZ1bmN0aW9uIHBhdGgoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgaW5uZXIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKGlubmVyLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gZnJvbVBhdGgobmV3IFBhdGgoaW5uZXIuZGF0YSkpO1xufTtcbl9nbG9iYWwucGF0aC5hcml0eSA9IDE7XG5fZ2xvYmFsLnN0cmluZyA9IGFzeW5jIGZ1bmN0aW9uIHN0cmluZyhhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgY2FzZSBcImRhdGV0aW1lXCI6XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhcIlwiLmNvbmNhdCh2YWx1ZS5kYXRhKSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG59O1xuX2dsb2JhbC5zdHJpbmcuYXJpdHkgPSAxO1xuX2dsb2JhbC5yZWZlcmVuY2VzID0gYXN5bmMgZnVuY3Rpb24gcmVmZXJlbmNlcyhhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBwYXRoU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgIGNvbnN0IHBhdGgyID0gYXdhaXQgZXhlY3V0ZShhcmcsIHNjb3BlKTtcbiAgICBpZiAocGF0aDIudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcGF0aFNldC5hZGQocGF0aDIuZGF0YSk7XG4gICAgfSBlbHNlIGlmIChwYXRoMi5pc0FycmF5KCkpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBwYXRoMikge1xuICAgICAgICBpZiAoZWxlbS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcGF0aFNldC5hZGQoZWxlbS5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocGF0aFNldC5zaXplID09PSAwKSB7XG4gICAgcmV0dXJuIEZBTFNFX1ZBTFVFO1xuICB9XG4gIGNvbnN0IHNjb3BlVmFsdWUgPSBhd2FpdCBzY29wZS52YWx1ZS5nZXQoKTtcbiAgcmV0dXJuIGhhc1JlZmVyZW5jZShzY29wZVZhbHVlLCBwYXRoU2V0KSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbn07XG5fZ2xvYmFsLnJlZmVyZW5jZXMuYXJpdHkgPSAoYykgPT4gYyA+PSAxO1xuX2dsb2JhbC5yb3VuZCA9IGFzeW5jIGZ1bmN0aW9uIHJvdW5kKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICh2YWx1ZS50eXBlICE9PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgY29uc3QgbnVtID0gdmFsdWUuZGF0YTtcbiAgbGV0IHByZWMgPSAwO1xuICBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICBjb25zdCBwcmVjVmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMV0sIHNjb3BlKTtcbiAgICBpZiAocHJlY1ZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIgfHwgcHJlY1ZhbHVlLmRhdGEgPCAwIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKHByZWNWYWx1ZS5kYXRhKSkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHByZWMgPSBwcmVjVmFsdWUuZGF0YTtcbiAgfVxuICBpZiAocHJlYyA9PT0gMCkge1xuICAgIGlmIChudW0gPCAwKSB7XG4gICAgICByZXR1cm4gZnJvbU51bWJlcigtTWF0aC5yb3VuZCgtbnVtKSk7XG4gICAgfVxuICAgIHJldHVybiBmcm9tTnVtYmVyKE1hdGgucm91bmQobnVtKSk7XG4gIH1cbiAgcmV0dXJuIGZyb21OdW1iZXIoTnVtYmVyKG51bS50b0ZpeGVkKHByZWMpKSk7XG59O1xuX2dsb2JhbC5yb3VuZC5hcml0eSA9IChjb3VudDIpID0+IGNvdW50MiA+PSAxICYmIGNvdW50MiA8PSAyO1xuX2dsb2JhbC5ub3cgPSBhc3luYyBmdW5jdGlvbiBub3coYXJncywgc2NvcGUpIHtcbiAgcmV0dXJuIGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC50aW1lc3RhbXAudG9JU09TdHJpbmcoKSk7XG59O1xuX2dsb2JhbC5ub3cuYXJpdHkgPSAwO1xuX2dsb2JhbC5ib29zdCA9IGFzeW5jIGZ1bmN0aW9uIGJvb3N0KCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIGJvb3N0IGNhbGxcIik7XG59O1xuX2dsb2JhbC5ib29zdC5hcml0eSA9IDI7XG5jb25zdCBzdHJpbmcyID0ge307XG5zdHJpbmcyLmxvd2VyID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKHZhbHVlLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZS5kYXRhLnRvTG93ZXJDYXNlKCkpO1xufTtcbnN0cmluZzIubG93ZXIuYXJpdHkgPSAxO1xuc3RyaW5nMi51cHBlciA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICh2YWx1ZS50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUuZGF0YS50b1VwcGVyQ2FzZSgpKTtcbn07XG5zdHJpbmcyLnVwcGVyLmFyaXR5ID0gMTtcbnN0cmluZzIuc3BsaXQgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBzdHIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKHN0ci50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgY29uc3Qgc2VwID0gYXdhaXQgZXhlY3V0ZShhcmdzWzFdLCBzY29wZSk7XG4gIGlmIChzZXAudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGlmIChzdHIuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZnJvbUpTKFtdKTtcbiAgfVxuICBpZiAoc2VwLmRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZyb21KUyhBcnJheS5mcm9tKHN0ci5kYXRhKSk7XG4gIH1cbiAgcmV0dXJuIGZyb21KUyhzdHIuZGF0YS5zcGxpdChzZXAuZGF0YSkpO1xufTtcbnN0cmluZzIuc3BsaXQuYXJpdHkgPSAyO1xuX2dsb2JhbC5sb3dlciA9IHN0cmluZzIubG93ZXI7XG5fZ2xvYmFsLnVwcGVyID0gc3RyaW5nMi51cHBlcjtcbnN0cmluZzIuc3RhcnRzV2l0aCA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHN0ciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoc3RyLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICBjb25zdCBwcmVmaXggPSBhd2FpdCBleGVjdXRlKGFyZ3NbMV0sIHNjb3BlKTtcbiAgaWYgKHByZWZpeC50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgcmV0dXJuIHN0ci5kYXRhLnN0YXJ0c1dpdGgocHJlZml4LmRhdGEpID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xufTtcbnN0cmluZzIuc3RhcnRzV2l0aC5hcml0eSA9IDI7XG5jb25zdCBhcnJheSA9IHt9O1xuYXJyYXkuam9pbiA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGFyciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoIWFyci5pc0FycmF5KCkpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICBjb25zdCBzZXAgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMV0sIHNjb3BlKTtcbiAgaWYgKHNlcC50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgbGV0IGJ1ZiA9IFwiXCI7XG4gIGxldCBuZWVkU2VwID0gZmFsc2U7XG4gIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBhcnIpIHtcbiAgICBpZiAobmVlZFNlcCkge1xuICAgICAgYnVmICs9IHNlcC5kYXRhO1xuICAgIH1cbiAgICBzd2l0Y2ggKGVsZW0udHlwZSkge1xuICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIGNhc2UgXCJkYXRldGltZVwiOlxuICAgICAgICBidWYgKz0gXCJcIi5jb25jYXQoZWxlbS5kYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgbmVlZFNlcCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGZyb21KUyhidWYpO1xufTtcbmFycmF5LmpvaW4uYXJpdHkgPSAyO1xuYXJyYXkuY29tcGFjdCA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGFyciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoIWFyci5pc0FycmF5KCkpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGFycikge1xuICAgICAgaWYgKGVsZW0udHlwZSAhPT0gXCJudWxsXCIpIHtcbiAgICAgICAgeWllbGQgZWxlbTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcbmFycmF5LmNvbXBhY3QuYXJpdHkgPSAxO1xuYXJyYXkudW5pcXVlID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKCF2YWx1ZS5pc0FycmF5KCkpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgYWRkZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGZvciBhd2FpdCAoY29uc3QgaXRlciBvZiB2YWx1ZSkge1xuICAgICAgc3dpdGNoIChpdGVyLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIGNhc2UgXCJkYXRldGltZVwiOlxuICAgICAgICAgIGlmICghYWRkZWQuaGFzKGl0ZXIuZGF0YSkpIHtcbiAgICAgICAgICAgIGFkZGVkLmFkZChpdGVyLmRhdGEpO1xuICAgICAgICAgICAgeWllbGQgaXRlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgeWllbGQgaXRlcjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcbmFycmF5LnVuaXF1ZS5hcml0eSA9IDE7XG5jb25zdCBwdCA9IHt9O1xucHQudGV4dCA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGNvbnN0IHRleHQgPSBhd2FpdCBwb3J0YWJsZVRleHRDb250ZW50KHZhbHVlKTtcbiAgaWYgKHRleHQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gZnJvbVN0cmluZyh0ZXh0KTtcbn07XG5wdC50ZXh0LmFyaXR5ID0gMTtcbmNvbnN0IHNhbml0eSA9IHt9O1xuc2FuaXR5LnByb2plY3RJZCA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlKSB7XG4gIGlmIChzY29wZS5jb250ZXh0LnNhbml0eSkge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHNjb3BlLmNvbnRleHQuc2FuaXR5LnByb2plY3RJZCk7XG4gIH1cbiAgcmV0dXJuIE5VTExfVkFMVUU7XG59O1xuc2FuaXR5LmRhdGFzZXQgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSkge1xuICBpZiAoc2NvcGUuY29udGV4dC5zYW5pdHkpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyhzY29wZS5jb250ZXh0LnNhbml0eS5kYXRhc2V0KTtcbiAgfVxuICByZXR1cm4gTlVMTF9WQUxVRTtcbn07XG5jb25zdCBwaXBlRnVuY3Rpb25zID0ge307XG5waXBlRnVuY3Rpb25zLm9yZGVyID0gYXN5bmMgZnVuY3Rpb24gb3JkZXIoYmFzZSwgYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgYXdhaXQgdHJ1ZTtcbiAgaWYgKCFiYXNlLmlzQXJyYXkoKSkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGNvbnN0IG1hcHBlcnMgPSBbXTtcbiAgY29uc3QgZGlyZWN0aW9ucyA9IFtdO1xuICBsZXQgbiA9IDA7XG4gIGZvciAobGV0IG1hcHBlciBvZiBhcmdzKSB7XG4gICAgbGV0IGRpcmVjdGlvbiA9IFwiYXNjXCI7XG4gICAgaWYgKG1hcHBlci50eXBlID09PSBcIkRlc2NcIikge1xuICAgICAgZGlyZWN0aW9uID0gXCJkZXNjXCI7XG4gICAgICBtYXBwZXIgPSBtYXBwZXIuYmFzZTtcbiAgICB9IGVsc2UgaWYgKG1hcHBlci50eXBlID09PSBcIkFzY1wiKSB7XG4gICAgICBtYXBwZXIgPSBtYXBwZXIuYmFzZTtcbiAgICB9XG4gICAgbWFwcGVycy5wdXNoKG1hcHBlcik7XG4gICAgZGlyZWN0aW9ucy5wdXNoKGRpcmVjdGlvbik7XG4gICAgbisrO1xuICB9XG4gIGNvbnN0IGF1eCA9IFtdO1xuICBsZXQgaWR4ID0gMDtcbiAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBiYXNlKSB7XG4gICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQodmFsdWUpO1xuICAgIGNvbnN0IHR1cGxlID0gW2F3YWl0IHZhbHVlLmdldCgpLCBpZHhdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleGVjdXRlKG1hcHBlcnNbaV0sIG5ld1Njb3BlKTtcbiAgICAgIHR1cGxlLnB1c2goYXdhaXQgcmVzdWx0LmdldCgpKTtcbiAgICB9XG4gICAgYXV4LnB1c2godHVwbGUpO1xuICAgIGlkeCsrO1xuICB9XG4gIGF1eC5zb3J0KChhVHVwbGUsIGJUdXBsZSkgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBsZXQgYyA9IHRvdGFsQ29tcGFyZShhVHVwbGVbaSArIDJdLCBiVHVwbGVbaSArIDJdKTtcbiAgICAgIGlmIChkaXJlY3Rpb25zW2ldID09PSBcImRlc2NcIikge1xuICAgICAgICBjID0gLWM7XG4gICAgICB9XG4gICAgICBpZiAoYyAhPT0gMCkge1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFUdXBsZVsxXSAtIGJUdXBsZVsxXTtcbiAgfSk7XG4gIHJldHVybiBmcm9tSlMoYXV4Lm1hcCgodikgPT4gdlswXSkpO1xufTtcbnBpcGVGdW5jdGlvbnMub3JkZXIuYXJpdHkgPSAoY291bnQyKSA9PiBjb3VudDIgPj0gMTtcbnBpcGVGdW5jdGlvbnMuc2NvcmUgPSBhc3luYyBmdW5jdGlvbiBzY29yZShiYXNlLCBhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBpZiAoIWJhc2UuaXNBcnJheSgpKVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICBjb25zdCB1bmtub3duID0gW107XG4gIGNvbnN0IHNjb3JlZCA9IFtdO1xuICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIGJhc2UpIHtcbiAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgdW5rbm93bi5wdXNoKGF3YWl0IHZhbHVlLmdldCgpKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZCh2YWx1ZSk7XG4gICAgbGV0IHZhbHVlU2NvcmUgPSB0eXBlb2YgdmFsdWUuZGF0YS5fc2NvcmUgPT09IFwibnVtYmVyXCIgPyB2YWx1ZS5kYXRhLl9zY29yZSA6IDA7XG4gICAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgICAgdmFsdWVTY29yZSArPSBhd2FpdCBldmFsdWF0ZVNjb3JlKGFyZywgbmV3U2NvcGUsIGV4ZWN1dGUpO1xuICAgIH1cbiAgICBjb25zdCBuZXdPYmplY3QgPSBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZS5kYXRhLCB7IF9zY29yZTogdmFsdWVTY29yZSB9KTtcbiAgICBzY29yZWQucHVzaChuZXdPYmplY3QpO1xuICB9XG4gIHNjb3JlZC5zb3J0KChhLCBiKSA9PiBiLl9zY29yZSAtIGEuX3Njb3JlKTtcbiAgcmV0dXJuIGZyb21KUyhzY29yZWQpO1xufTtcbnBpcGVGdW5jdGlvbnMuc2NvcmUuYXJpdHkgPSAoY291bnQyKSA9PiBjb3VudDIgPj0gMTtcbmNvbnN0IGRlbHRhID0ge307XG5kZWx0YS5vcGVyYXRpb24gPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSkge1xuICBjb25zdCBoYXNCZWZvcmUgPSBzY29wZS5jb250ZXh0LmJlZm9yZSAhPT0gbnVsbDtcbiAgY29uc3QgaGFzQWZ0ZXIgPSBzY29wZS5jb250ZXh0LmFmdGVyICE9PSBudWxsO1xuICBpZiAoaGFzQmVmb3JlICYmIGhhc0FmdGVyKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcoXCJ1cGRhdGVcIik7XG4gIH1cbiAgaWYgKGhhc0FmdGVyKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcoXCJjcmVhdGVcIik7XG4gIH1cbiAgaWYgKGhhc0JlZm9yZSkge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKFwiZGVsZXRlXCIpO1xuICB9XG4gIHJldHVybiBOVUxMX1ZBTFVFO1xufTtcbmRlbHRhLmNoYW5nZWRBbnkgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG5kZWx0YS5jaGFuZ2VkQW55LmFyaXR5ID0gMTtcbmRlbHRhLmNoYW5nZWRBbnkubW9kZSA9IFwiZGVsdGFcIjtcbmRlbHRhLmNoYW5nZWRPbmx5ID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG59O1xuZGVsdGEuY2hhbmdlZE9ubHkuYXJpdHkgPSAxO1xuZGVsdGEuY2hhbmdlZE9ubHkubW9kZSA9IFwiZGVsdGFcIjtcbmNvbnN0IGRpZmYgPSB7fTtcbmRpZmYuY2hhbmdlZEFueSA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufTtcbmRpZmYuY2hhbmdlZEFueS5hcml0eSA9IDM7XG5kaWZmLmNoYW5nZWRPbmx5ID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG59O1xuZGlmZi5jaGFuZ2VkT25seS5hcml0eSA9IDM7XG5jb25zdCBtYXRoID0ge307XG5tYXRoLm1pbiA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGFyciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoIWFyci5pc0FycmF5KCkpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICBsZXQgbjtcbiAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGFycikge1xuICAgIGlmIChlbGVtLnR5cGUgPT09IFwibnVsbFwiKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKGVsZW0udHlwZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIGlmIChuID09PSB2b2lkIDAgfHwgZWxlbS5kYXRhIDwgbikge1xuICAgICAgbiA9IGVsZW0uZGF0YTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZyb21KUyhuKTtcbn07XG5tYXRoLm1pbi5hcml0eSA9IDE7XG5tYXRoLm1heCA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGFyciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoIWFyci5pc0FycmF5KCkpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICBsZXQgbjtcbiAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGFycikge1xuICAgIGlmIChlbGVtLnR5cGUgPT09IFwibnVsbFwiKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKGVsZW0udHlwZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIGlmIChuID09PSB2b2lkIDAgfHwgZWxlbS5kYXRhID4gbikge1xuICAgICAgbiA9IGVsZW0uZGF0YTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZyb21KUyhuKTtcbn07XG5tYXRoLm1heC5hcml0eSA9IDE7XG5tYXRoLnN1bSA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGFyciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoIWFyci5pc0FycmF5KCkpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICBsZXQgbiA9IDA7XG4gIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBhcnIpIHtcbiAgICBpZiAoZWxlbS50eXBlID09PSBcIm51bGxcIilcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmIChlbGVtLnR5cGUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBuICs9IGVsZW0uZGF0YTtcbiAgfVxuICByZXR1cm4gZnJvbUpTKG4pO1xufTtcbm1hdGguc3VtLmFyaXR5ID0gMTtcbm1hdGguYXZnID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghYXJyLmlzQXJyYXkoKSkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGxldCBuID0gMDtcbiAgbGV0IGMgPSAwO1xuICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgYXJyKSB7XG4gICAgaWYgKGVsZW0udHlwZSA9PT0gXCJudWxsXCIpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAoZWxlbS50eXBlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgbiArPSBlbGVtLmRhdGE7XG4gICAgYysrO1xuICB9XG4gIGlmIChjID09PSAwKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgcmV0dXJuIGZyb21KUyhuIC8gYyk7XG59O1xubWF0aC5hdmcuYXJpdHkgPSAxO1xuY29uc3QgZGF0ZVRpbWUyID0ge307XG5kYXRlVGltZTIubm93ID0gYXN5bmMgZnVuY3Rpb24gbm93MihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICByZXR1cm4gZnJvbURhdGVUaW1lKG5ldyBEYXRlVGltZShzY29wZS5jb250ZXh0LnRpbWVzdGFtcCkpO1xufTtcbmRhdGVUaW1lMi5ub3cuYXJpdHkgPSAwO1xuY29uc3QgbmFtZXNwYWNlcyA9IHtcbiAgZ2xvYmFsOiBfZ2xvYmFsLFxuICBzdHJpbmc6IHN0cmluZzIsXG4gIGFycmF5LFxuICBwdCxcbiAgZGVsdGEsXG4gIGRpZmYsXG4gIHNhbml0eSxcbiAgbWF0aCxcbiAgZGF0ZVRpbWU6IGRhdGVUaW1lMlxufTtcblxudmFyIF9fZGVmUHJvcCQxID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCQxID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQxKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkJDEgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcCQxKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNsYXNzIE1hcmtQcm9jZXNzb3Ige1xuICBjb25zdHJ1Y3RvcihzdHJpbmcsIG1hcmtzLCBwYXJzZU9wdGlvbnMpIHtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJzdHJpbmdcIik7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwibWFya3NcIik7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiaW5kZXhcIik7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwicGFyc2VPcHRpb25zXCIpO1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImFsbG93Qm9vc3RcIiwgZmFsc2UpO1xuICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgIHRoaXMubWFya3MgPSBtYXJrcztcbiAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB0aGlzLnBhcnNlT3B0aW9ucyA9IHBhcnNlT3B0aW9ucztcbiAgfVxuICBoYXNNYXJrKHBvcyA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleCArIHBvcyA8IHRoaXMubWFya3MubGVuZ3RoO1xuICB9XG4gIGdldE1hcmsocG9zID0gMCkge1xuICAgIHJldHVybiB0aGlzLm1hcmtzW3RoaXMuaW5kZXggKyBwb3NdO1xuICB9XG4gIHNoaWZ0KCkge1xuICAgIHRoaXMuaW5kZXggKz0gMTtcbiAgfVxuICBwcm9jZXNzKHZpc2l0b3IpIHtcbiAgICBjb25zdCBtYXJrID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4XTtcbiAgICB0aGlzLnNoaWZ0KCk7XG4gICAgY29uc3QgZnVuYyA9IHZpc2l0b3JbbWFyay5uYW1lXTtcbiAgICBpZiAoIWZ1bmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gaGFuZGxlcjogXCIuY29uY2F0KG1hcmsubmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5jYWxsKHZpc2l0b3IsIHRoaXMsIG1hcmspO1xuICB9XG4gIHByb2Nlc3NTdHJpbmcoKSB7XG4gICAgdGhpcy5zaGlmdCgpO1xuICAgIHJldHVybiB0aGlzLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgfVxuICBwcm9jZXNzU3RyaW5nRW5kKCkge1xuICAgIGNvbnN0IHByZXYgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXggLSAxXTtcbiAgICBjb25zdCBjdXJyID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4XTtcbiAgICB0aGlzLnNoaWZ0KCk7XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHByZXYucG9zaXRpb24sIGN1cnIucG9zaXRpb24pO1xuICB9XG4gIHNsaWNlKGxlbikge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMubWFya3NbdGhpcy5pbmRleF0ucG9zaXRpb247XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHBvcywgcG9zICsgbGVuKTtcbiAgfVxufVxuXG5jb25zdCBXUyA9IC9eKFtcXHRcXG5cXHZcXGZcXHIgXFx1MDA4NVxcdTAwQTBdfChcXC9cXC9bXlxcbl0qXFxuKSkrLztcbmNvbnN0IE5VTSA9IC9eXFxkKy87XG5jb25zdCBJREVOVCA9IC9eW2EtekEtWl9dW2EtekEtWl8wLTldKi87XG5jb25zdCBQUkVDX1BBSVIgPSAxO1xuY29uc3QgUFJFQ19PUiA9IDI7XG5jb25zdCBQUkVDX0FORCA9IDM7XG5jb25zdCBQUkVDX0NPTVAgPSA0O1xuY29uc3QgUFJFQ19PUkRFUiA9IDQ7XG5jb25zdCBQUkVDX0FERCA9IDY7XG5jb25zdCBQUkVDX1NVQiA9IDY7XG5jb25zdCBQUkVDX01VTCA9IDc7XG5jb25zdCBQUkVDX0RJViA9IDc7XG5jb25zdCBQUkVDX01PRCA9IDc7XG5jb25zdCBQUkVDX1BPVyA9IDg7XG5jb25zdCBQUkVDX1BPUyA9IDEwO1xuY29uc3QgUFJFQ19OT1QgPSAxMDtcbmNvbnN0IFBSRUNfTkVHID0gODtcbmZ1bmN0aW9uIHBhcnNlJDEoc3RyKSB7XG4gIGxldCBwb3MgPSAwO1xuICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICBsZXQgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgcG9zID0gc2tpcFdTKHN0ciwgcmVzdWx0LnBvc2l0aW9uKTtcbiAgaWYgKHBvcyAhPT0gc3RyLmxlbmd0aCkge1xuICAgIGlmIChyZXN1bHQuZmFpbFBvc2l0aW9uKSB7XG4gICAgICBwb3MgPSByZXN1bHQuZmFpbFBvc2l0aW9uIC0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gIH1cbiAgZGVsZXRlIHJlc3VsdC5wb3NpdGlvbjtcbiAgZGVsZXRlIHJlc3VsdC5mYWlsUG9zaXRpb247XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZUV4cHIoc3RyLCBwb3MsIGxldmVsKSB7XG4gIGxldCBzdGFydFBvcyA9IHBvcztcbiAgbGV0IHRva2VuID0gc3RyW3Bvc107XG4gIGxldCBtYXJrcztcbiAgc3dpdGNoICh0b2tlbikge1xuICAgIGNhc2UgXCIrXCI6IHtcbiAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgUFJFQ19QT1MpO1xuICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByaHM7XG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwicG9zXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiLVwiOiB7XG4gICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgcG9zICsgMSksIFBSRUNfTkVHKTtcbiAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgbWFya3MgPSBbeyBuYW1lOiBcIm5lZ1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0uY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIihcIjoge1xuICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIHBvcyArIDEpLCAwKTtcbiAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcmhzLnBvc2l0aW9uKTtcbiAgICAgIHN3aXRjaCAoc3RyW3Bvc10pIHtcbiAgICAgICAgY2FzZSBcIixcIjoge1xuICAgICAgICAgIG1hcmtzID0gW3sgbmFtZTogXCJ0dXBsZVwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0uY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHJocyA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHJocy5wb3NpdGlvbik7XG4gICAgICAgICAgICBpZiAoc3RyW3Bvc10gIT09IFwiLFwiKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RyW3Bvc10gIT09IFwiKVwiKVxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwidHVwbGVfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIilcIjoge1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIG1hcmtzID0gW3sgbmFtZTogXCJncm91cFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0uY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiIVwiOiB7XG4gICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgcG9zICsgMSksIFBSRUNfTk9UKTtcbiAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgbWFya3MgPSBbeyBuYW1lOiBcIm5vdFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0uY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIntcIjoge1xuICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlT2JqZWN0KHN0ciwgcG9zKTtcbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgbWFya3MgPSByZXN1bHQubWFya3M7XG4gICAgICBwb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIltcIjpcbiAgICAgIG1hcmtzID0gW3sgbmFtZTogXCJhcnJheVwiLCBwb3NpdGlvbjogcG9zIH1dO1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICBpZiAoc3RyW3Bvc10gIT09IFwiXVwiKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgaWYgKHN0ci5zbGljZShwb3MsIHBvcyArIDMpID09PSBcIi4uLlwiKSB7XG4gICAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJhcnJheV9zcGxhdFwiLCBwb3NpdGlvbjogcG9zIH0pO1xuICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCByZXMgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgICAgIGlmIChyZXMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyZXMubWFya3MpO1xuICAgICAgICAgIHBvcyA9IHJlcy5wb3NpdGlvbjtcbiAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgICAgIGlmIChzdHJbcG9zXSAhPT0gXCIsXCIpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiXVwiKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCJdXCIpIHtcbiAgICAgICAgcG9zKys7XG4gICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcImFycmF5X2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiJ1wiOlxuICAgIGNhc2UgJ1wiJzoge1xuICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlU3RyaW5nKHN0ciwgcG9zKTtcbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgbWFya3MgPSByZXN1bHQubWFya3M7XG4gICAgICBwb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIl5cIjoge1xuICAgICAgcG9zKys7XG4gICAgICBtYXJrcyA9IFtdO1xuICAgICAgd2hpbGUgKHN0cltwb3NdID09PSBcIi5cIiAmJiBzdHJbcG9zICsgMV0gPT09IFwiXlwiKSB7XG4gICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcImRibHBhcmVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgIHBvcyArPSAyO1xuICAgICAgfVxuICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwicGFyZW50XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiQFwiOlxuICAgICAgbWFya3MgPSBbeyBuYW1lOiBcInRoaXNcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dO1xuICAgICAgcG9zKys7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiKlwiOlxuICAgICAgbWFya3MgPSBbeyBuYW1lOiBcImV2ZXJ5dGhpbmdcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dO1xuICAgICAgcG9zKys7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiJFwiOiB7XG4gICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zICsgMSwgSURFTlQpO1xuICAgICAgaWYgKGlkZW50TGVuKSB7XG4gICAgICAgIHBvcyArPSAxICsgaWRlbnRMZW47XG4gICAgICAgIG1hcmtzID0gW1xuICAgICAgICAgIHsgbmFtZTogXCJwYXJhbVwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSxcbiAgICAgICAgICB7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IHN0YXJ0UG9zICsgMSB9LFxuICAgICAgICAgIHsgbmFtZTogXCJpZGVudF9lbmRcIiwgcG9zaXRpb246IHBvcyB9XG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgbGV0IG51bUxlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIE5VTSk7XG4gICAgICBpZiAobnVtTGVuKSB7XG4gICAgICAgIHBvcyArPSBudW1MZW47XG4gICAgICAgIGxldCBuYW1lID0gXCJpbnRlZ2VyXCI7XG4gICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICBsZXQgZnJhY0xlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MgKyAxLCBOVU0pO1xuICAgICAgICAgIGlmIChmcmFjTGVuKSB7XG4gICAgICAgICAgICBuYW1lID0gXCJmbG9hdFwiO1xuICAgICAgICAgICAgcG9zICs9IDEgKyBmcmFjTGVuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiZVwiIHx8IHN0cltwb3NdID09PSBcIkVcIikge1xuICAgICAgICAgIG5hbWUgPSBcInNjaVwiO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIrXCIgfHwgc3RyW3Bvc10gPT09IFwiLVwiKSB7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGV4cExlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIE5VTSk7XG4gICAgICAgICAgaWYgKCFleHBMZW4pXG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgICAgICBwb3MgKz0gZXhwTGVuO1xuICAgICAgICB9XG4gICAgICAgIG1hcmtzID0gW1xuICAgICAgICAgIHsgbmFtZSwgcG9zaXRpb246IHN0YXJ0UG9zIH0sXG4gICAgICAgICAgeyBuYW1lOiBuYW1lICsgXCJfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfVxuICAgICAgICBdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGxldCBpZGVudExlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIElERU5UKTtcbiAgICAgIGlmIChpZGVudExlbikge1xuICAgICAgICBwb3MgKz0gaWRlbnRMZW47XG4gICAgICAgIHN3aXRjaCAoc3RyW3Bvc10pIHtcbiAgICAgICAgICBjYXNlIFwiOlwiOlxuICAgICAgICAgIGNhc2UgXCIoXCI6IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZUZ1bmNDYWxsKHN0ciwgc3RhcnRQb3MsIHBvcyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIG1hcmtzID0gcmVzdWx0Lm1hcmtzO1xuICAgICAgICAgICAgcG9zID0gcmVzdWx0LnBvc2l0aW9uO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIG1hcmtzID0gW1xuICAgICAgICAgICAgICB7IG5hbWU6IFwidGhpc19hdHRyXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxuICAgICAgICAgICAgICB7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0sXG4gICAgICAgICAgICAgIHsgbmFtZTogXCJpZGVudF9lbmRcIiwgcG9zaXRpb246IHBvcyB9XG4gICAgICAgICAgICBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFtYXJrcykge1xuICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICB9XG4gIGxldCBsaHNMZXZlbCA9IDEyO1xuICBsZXQgdHJhdjtcbiAgbG9vcDpcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgbGV0IGlubmVyUG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICAgIGlmIChpbm5lclBvcyA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICBwb3MgPSBpbm5lclBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0cmF2ID0gcGFyc2VUcmF2ZXJzYWwoc3RyLCBpbm5lclBvcyk7XG4gICAgICBpZiAodHJhdi50eXBlID09PSBcInN1Y2Nlc3NcIikge1xuICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJ0cmF2ZXJzZVwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgIHdoaWxlICh0cmF2LnR5cGUgPT09IFwic3VjY2Vzc1wiKSB7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQodHJhdi5tYXJrcyk7XG4gICAgICAgICAgcG9zID0gdHJhdi5wb3NpdGlvbjtcbiAgICAgICAgICB0cmF2ID0gcGFyc2VUcmF2ZXJzYWwoc3RyLCBza2lwV1Moc3RyLCBwb3MpKTtcbiAgICAgICAgfVxuICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJ0cmF2ZXJzYWxfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IHRva2VuMiA9IHN0cltpbm5lclBvc107XG4gICAgICBzd2l0Y2ggKHRva2VuMikge1xuICAgICAgICBjYXNlIFwiPVwiOiB7XG4gICAgICAgICAgbGV0IG5leHRUb2tlbiA9IHN0cltpbm5lclBvcyArIDFdO1xuICAgICAgICAgIHN3aXRjaCAobmV4dFRva2VuKSB7XG4gICAgICAgICAgICBjYXNlIFwiPlwiOiB7XG4gICAgICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfUEFJUiB8fCBsaHNMZXZlbCA8PSBQUkVDX1BBSVIpXG4gICAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIFBSRUNfUEFJUik7XG4gICAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInBhaXJcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19QQUlSO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCI9XCI6IHtcbiAgICAgICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDw9IFBSRUNfQ09NUClcbiAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19DT01QICsgMSk7XG4gICAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImNvbXBcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJvcFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgfSwgeyBuYW1lOiBcIm9wX2VuZFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgKyAyIH0pO1xuICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19DT01QO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCIrXCI6IHtcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0FERCB8fCBsaHNMZXZlbCA8IFBSRUNfQUREKVxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKSwgUFJFQ19BREQgKyAxKTtcbiAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJhZGRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfQUREO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCItXCI6IHtcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX1NVQiB8fCBsaHNMZXZlbCA8IFBSRUNfU1VCKVxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKSwgUFJFQ19TVUIgKyAxKTtcbiAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJzdWJcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfU1VCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCIqXCI6IHtcbiAgICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gPT09IFwiKlwiKSB7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX1BPVyB8fCBsaHNMZXZlbCA8PSBQUkVDX1BPVylcbiAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgIGxldCByaHMyID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19QT1cpO1xuICAgICAgICAgICAgaWYgKHJoczIudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICByZXR1cm4gcmhzMjtcbiAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJoczIubWFya3MpO1xuICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwicG93XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgICAgIHBvcyA9IHJoczIucG9zaXRpb247XG4gICAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfUE9XO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfTVVMIHx8IGxoc0xldmVsIDwgUFJFQ19NVUwpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX01VTCArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcIm11bFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19NVUw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIi9cIjoge1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfRElWIHx8IGxoc0xldmVsIDwgUFJFQ19ESVYpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX0RJViArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImRpdlwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19ESVY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIiVcIjoge1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfTU9EIHx8IGxoc0xldmVsIDwgUFJFQ19NT0QpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX01PRCArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcIm1vZFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19NT0Q7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgY2FzZSBcIj5cIjoge1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQ09NUCB8fCBsaHNMZXZlbCA8PSBQUkVDX0NPTVApXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGxldCBuZXh0UG9zID0gaW5uZXJQb3MgKyAxO1xuICAgICAgICAgIGlmIChzdHJbbmV4dFBvc10gPT09IFwiPVwiKSB7XG4gICAgICAgICAgICBuZXh0UG9zKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBuZXh0UG9zKSwgUFJFQ19DT01QICsgMSk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImNvbXBcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9wXCIsIHBvc2l0aW9uOiBpbm5lclBvcyB9LCB7IG5hbWU6IFwib3BfZW5kXCIsIHBvc2l0aW9uOiBuZXh0UG9zIH0pO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19DT01QO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ8XCI6IHtcbiAgICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gPT09IFwifFwiKSB7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX09SIHx8IGxoc0xldmVsIDwgUFJFQ19PUilcbiAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCBQUkVDX09SICsgMSk7XG4gICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJvclwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfT1I7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChsZXZlbCA+IDExIHx8IGxoc0xldmVsIDwgMTEpXG4gICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICBsZXQgaWRlbnRQb3MgPSBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpO1xuICAgICAgICAgICAgbGV0IGlkZW50TGVuID0gcGFyc2VSZWdleChzdHIsIGlkZW50UG9zLCBJREVOVCk7XG4gICAgICAgICAgICBpZiAoIWlkZW50TGVuKVxuICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBpZGVudFBvcyB9O1xuICAgICAgICAgICAgcG9zID0gaWRlbnRQb3MgKyBpZGVudExlbjtcbiAgICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIoXCIgfHwgc3RyW3Bvc10gPT09IFwiOlwiKSB7XG4gICAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZUZ1bmNDYWxsKHN0ciwgaWRlbnRQb3MsIHBvcyk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJlc3VsdC5tYXJrcyk7XG4gICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInBpcGVjYWxsXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgICAgICAgcG9zID0gcmVzdWx0LnBvc2l0aW9uO1xuICAgICAgICAgICAgICBsaHNMZXZlbCA9IDExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiJlwiOiB7XG4gICAgICAgICAgaWYgKHN0cltpbm5lclBvcyArIDFdICE9IFwiJlwiKVxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0FORCB8fCBsaHNMZXZlbCA8IFBSRUNfQU5EKVxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19BTkQgKyAxKTtcbiAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJhbmRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfQU5EO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCIhXCI6IHtcbiAgICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gIT09IFwiPVwiKVxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0NPTVAgfHwgbGhzTGV2ZWwgPD0gUFJFQ19DT01QKVxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19DT01QICsgMSk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImNvbXBcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9wXCIsIHBvc2l0aW9uOiBpbm5lclBvcyB9LCB7IG5hbWU6IFwib3BfZW5kXCIsIHBvc2l0aW9uOiBpbm5lclBvcyArIDIgfSk7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0NPTVA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImRcIjoge1xuICAgICAgICAgIGlmIChzdHIuc2xpY2UoaW5uZXJQb3MsIGlubmVyUG9zICsgNCkgIT09IFwiZGVzY1wiKVxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX09SREVSIHx8IGxoc0xldmVsIDwgUFJFQ19PUkRFUilcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiZGVzY1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgcG9zID0gaW5uZXJQb3MgKyA0O1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19PUkRFUjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiYVwiOiB7XG4gICAgICAgICAgaWYgKHN0ci5zbGljZShpbm5lclBvcywgaW5uZXJQb3MgKyAzKSAhPT0gXCJhc2NcIilcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19PUkRFUiB8fCBsaHNMZXZlbCA8IFBSRUNfT1JERVIpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImFzY1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgcG9zID0gaW5uZXJQb3MgKyAzO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19PUkRFUjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgbGV0IGlkZW50ID0gcGFyc2VSZWdleFN0cihzdHIsIGlubmVyUG9zLCBJREVOVCk7XG4gICAgICAgICAgc3dpdGNoIChpZGVudCkge1xuICAgICAgICAgICAgY2FzZSBcImluXCI6IHtcbiAgICAgICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDw9IFBSRUNfQ09NUClcbiAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpO1xuICAgICAgICAgICAgICBsZXQgaXNHcm91cCA9IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiKFwiKSB7XG4gICAgICAgICAgICAgICAgaXNHcm91cCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IHJhbmdlUG9zID0gcG9zO1xuICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCBQUkVDX0NPTVAgKyAxKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcmVzdWx0LnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgaWYgKHN0cltwb3NdID09PSBcIi5cIiAmJiBzdHJbcG9zICsgMV0gPT09IFwiLlwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IHR5cGUgPSBcImluY19yYW5nZVwiO1xuICAgICAgICAgICAgICAgIGlmIChzdHJbcG9zICsgMl0gPT09IFwiLlwiKSB7XG4gICAgICAgICAgICAgICAgICB0eXBlID0gXCJleGNfcmFuZ2VcIjtcbiAgICAgICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHBvcywgUFJFQ19DT01QICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImluX3JhbmdlXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdCh7IG5hbWU6IHR5cGUsIHBvc2l0aW9uOiByYW5nZVBvcyB9LCByZXN1bHQubWFya3MsIHJocy5tYXJrcyk7XG4gICAgICAgICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImNvbXBcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9wXCIsIHBvc2l0aW9uOiBpbm5lclBvcyB9LCB7IG5hbWU6IFwib3BfZW5kXCIsIHBvc2l0aW9uOiBpbm5lclBvcyArIDIgfSk7XG4gICAgICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmVzdWx0Lm1hcmtzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNHcm91cCkge1xuICAgICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHN0cltwb3NdICE9PSBcIilcIilcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19DT01QO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJtYXRjaFwiOiB7XG4gICAgICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQ09NUCB8fCBsaHNMZXZlbCA8PSBQUkVDX0NPTVApXG4gICAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgNSksIFBSRUNfQ09NUCArIDEpO1xuICAgICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJjb21wXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwib3BcIiwgcG9zaXRpb246IGlubmVyUG9zIH0sIHsgbmFtZTogXCJvcF9lbmRcIiwgcG9zaXRpb246IGlubmVyUG9zICsgNSB9KTtcbiAgICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgICAgICBsaHNMZXZlbCA9IDQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgbGV0IGZhaWxQb3NpdGlvbiA9ICh0cmF2ID09IG51bGwgPyB2b2lkIDAgOiB0cmF2LnR5cGUpID09PSBcImVycm9yXCIgJiYgdHJhdi5wb3NpdGlvbjtcbiAgcmV0dXJuIHsgdHlwZTogXCJzdWNjZXNzXCIsIG1hcmtzLCBwb3NpdGlvbjogcG9zLCBmYWlsUG9zaXRpb24gfTtcbn1cbmZ1bmN0aW9uIHBhcnNlVHJhdmVyc2FsKHN0ciwgcG9zKSB7XG4gIGxldCBzdGFydFBvcyA9IHBvcztcbiAgc3dpdGNoIChzdHJbcG9zXSkge1xuICAgIGNhc2UgXCIuXCI6IHtcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgbGV0IGlkZW50U3RhcnQgPSBwb3M7XG4gICAgICBsZXQgaWRlbnRMZW4yID0gcGFyc2VSZWdleChzdHIsIHBvcywgSURFTlQpO1xuICAgICAgaWYgKCFpZGVudExlbjIpXG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgICAgcG9zICs9IGlkZW50TGVuMjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICBtYXJrczogW1xuICAgICAgICAgIHsgbmFtZTogXCJhdHRyX2FjY2Vzc1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSxcbiAgICAgICAgICB7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IGlkZW50U3RhcnQgfSxcbiAgICAgICAgICB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfVxuICAgICAgICBdLFxuICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwiLVwiOlxuICAgICAgaWYgKHN0cltwb3MgKyAxXSAhPT0gXCI+XCIpXG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgICAgbGV0IG1hcmtzID0gW3sgbmFtZTogXCJkZXJlZlwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV07XG4gICAgICBwb3MgKz0gMjtcbiAgICAgIGxldCBpZGVudFBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XG4gICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgaWRlbnRQb3MsIElERU5UKTtcbiAgICAgIGlmIChpZGVudExlbikge1xuICAgICAgICBwb3MgPSBpZGVudFBvcyArIGlkZW50TGVuO1xuICAgICAgICBtYXJrcy5wdXNoKFxuICAgICAgICAgIHsgbmFtZTogXCJkZXJlZl9hdHRyXCIsIHBvc2l0aW9uOiBpZGVudFBvcyB9LFxuICAgICAgICAgIHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogaWRlbnRQb3MgfSxcbiAgICAgICAgICB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgIG1hcmtzLFxuICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICB9O1xuICAgIGNhc2UgXCJbXCI6IHtcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgaWYgKHN0cltwb3NdID09PSBcIl1cIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgIG1hcmtzOiBbeyBuYW1lOiBcImFycmF5X3Bvc3RmaXhcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLFxuICAgICAgICAgIHBvc2l0aW9uOiBwb3MgKyAxXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBsZXQgcmFuZ2VQb3MgPSBwb3M7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcmVzdWx0LnBvc2l0aW9uKTtcbiAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIuXCIgJiYgc3RyW3BvcyArIDFdID09PSBcIi5cIikge1xuICAgICAgICBsZXQgdHlwZSA9IFwiaW5jX3JhbmdlXCI7XG4gICAgICAgIGlmIChzdHJbcG9zICsgMl0gPT09IFwiLlwiKSB7XG4gICAgICAgICAgdHlwZSA9IFwiZXhjX3JhbmdlXCI7XG4gICAgICAgICAgcG9zICs9IDM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHJocy5wb3NpdGlvbik7XG4gICAgICAgIGlmIChzdHJbcG9zXSAhPT0gXCJdXCIpXG4gICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgbWFya3M6IFtcbiAgICAgICAgICAgIHsgbmFtZTogXCJzbGljZVwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSxcbiAgICAgICAgICAgIHsgbmFtZTogdHlwZSwgcG9zaXRpb246IHJhbmdlUG9zIH1cbiAgICAgICAgICBdLmNvbmNhdChyZXN1bHQubWFya3MsIHJocy5tYXJrcyksXG4gICAgICAgICAgcG9zaXRpb246IHBvcyArIDFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJbcG9zXSAhPT0gXCJdXCIpXG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgIG1hcmtzOiBbeyBuYW1lOiBcInNxdWFyZV9icmFja2V0XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmVzdWx0Lm1hcmtzKSxcbiAgICAgICAgcG9zaXRpb246IHBvcyArIDFcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJ8XCI6IHtcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgaWYgKHN0cltwb3NdID09PSBcIntcIikge1xuICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VPYmplY3Qoc3RyLCBwb3MpO1xuICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICByZXN1bHQubWFya3MudW5zaGlmdCh7IG5hbWU6IFwicHJvamVjdGlvblwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIntcIjoge1xuICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlT2JqZWN0KHN0ciwgcG9zKTtcbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgcmVzdWx0Lm1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInByb2plY3Rpb25cIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG59XG5mdW5jdGlvbiBwYXJzZUZ1bmNDYWxsKHN0ciwgc3RhcnRQb3MsIHBvcykge1xuICBsZXQgbWFya3MgPSBbXTtcbiAgbWFya3MucHVzaCh7IG5hbWU6IFwiZnVuY19jYWxsXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgaWYgKHN0cltwb3NdID09PSBcIjpcIiAmJiBzdHJbcG9zICsgMV0gPT09IFwiOlwiKSB7XG4gICAgbWFya3MucHVzaCh7IG5hbWU6IFwibmFtZXNwYWNlXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSwgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pO1xuICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDIpO1xuICAgIGxldCBuYW1lTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgSURFTlQpO1xuICAgIGlmICghbmFtZUxlbilcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBwb3MgfSwgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zICsgbmFtZUxlbiB9KTtcbiAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyBuYW1lTGVuKTtcbiAgICBpZiAoc3RyW3Bvc10gIT09IFwiKFwiKVxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgcG9zKys7XG4gICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgfSBlbHNlIHtcbiAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSwgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pO1xuICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICB9XG4gIGxldCBsYXN0UG9zID0gcG9zO1xuICBpZiAoc3RyW3Bvc10gIT09IFwiKVwiKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGxldCByZXN1bHQgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyZXN1bHQubWFya3MpO1xuICAgICAgbGFzdFBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHJlc3VsdC5wb3NpdGlvbik7XG4gICAgICBpZiAoc3RyW3Bvc10gIT09IFwiLFwiKVxuICAgICAgICBicmVhaztcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgaWYgKHN0cltwb3NdID09PSBcIilcIilcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChzdHJbcG9zXSAhPT0gXCIpXCIpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgfVxuICBtYXJrcy5wdXNoKHsgbmFtZTogXCJmdW5jX2FyZ3NfZW5kXCIsIHBvc2l0aW9uOiBsYXN0UG9zIH0pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgIG1hcmtzLFxuICAgIHBvc2l0aW9uOiBwb3MgKyAxXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZU9iamVjdChzdHIsIHBvcykge1xuICBsZXQgbWFya3MgPSBbeyBuYW1lOiBcIm9iamVjdFwiLCBwb3NpdGlvbjogcG9zIH1dO1xuICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgd2hpbGUgKHN0cltwb3NdICE9PSBcIn1cIikge1xuICAgICAgbGV0IHBhaXJQb3MgPSBwb3M7XG4gICAgICBpZiAoc3RyLnNsaWNlKHBvcywgcG9zICsgMykgPT09IFwiLi4uXCIpIHtcbiAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMyk7XG4gICAgICAgIGlmIChzdHJbcG9zXSAhPT0gXCJ9XCIgJiYgc3RyW3Bvc10gIT09IFwiLFwiKSB7XG4gICAgICAgICAgbGV0IGV4cHIgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgICAgIGlmIChleHByLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9iamVjdF9zcGxhdFwiLCBwb3NpdGlvbjogcGFpclBvcyB9KTtcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChleHByLm1hcmtzKTtcbiAgICAgICAgICBwb3MgPSBleHByLnBvc2l0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9iamVjdF9zcGxhdF90aGlzXCIsIHBvc2l0aW9uOiBwYWlyUG9zIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgIGlmIChleHByLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgICAgbGV0IG5leHRQb3MgPSBza2lwV1Moc3RyLCBleHByLnBvc2l0aW9uKTtcbiAgICAgICAgaWYgKGV4cHIubWFya3NbMF0ubmFtZSA9PT0gXCJzdHJcIiAmJiBzdHJbbmV4dFBvc10gPT09IFwiOlwiKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgbmV4dFBvcyArIDEpLCAwKTtcbiAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9iamVjdF9wYWlyXCIsIHBvc2l0aW9uOiBwYWlyUG9zIH0pO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KGV4cHIubWFya3MsIHZhbHVlLm1hcmtzKTtcbiAgICAgICAgICBwb3MgPSB2YWx1ZS5wb3NpdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdCh7IG5hbWU6IFwib2JqZWN0X2V4cHJcIiwgcG9zaXRpb246IHBvcyB9LCBleHByLm1hcmtzKTtcbiAgICAgICAgICBwb3MgPSBleHByLnBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgaWYgKHN0cltwb3NdICE9PSBcIixcIilcbiAgICAgICAgYnJlYWs7XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICB9XG4gIGlmIChzdHJbcG9zXSAhPT0gXCJ9XCIpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgfVxuICBwb3MrKztcbiAgbWFya3MucHVzaCh7IG5hbWU6IFwib2JqZWN0X2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pO1xuICByZXR1cm4geyB0eXBlOiBcInN1Y2Nlc3NcIiwgbWFya3MsIHBvc2l0aW9uOiBwb3MgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0ciwgcG9zKSB7XG4gIGxldCB0b2tlbiA9IHN0cltwb3NdO1xuICBwb3MgPSBwb3MgKyAxO1xuICBjb25zdCBtYXJrcyA9IFt7IG5hbWU6IFwic3RyXCIsIHBvc2l0aW9uOiBwb3MgfV07XG4gIHN0cjpcbiAgICBmb3IgKDsgOyBwb3MrKykge1xuICAgICAgaWYgKHBvcyA+IHN0ci5sZW5ndGgpXG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgICAgc3dpdGNoIChzdHJbcG9zXSkge1xuICAgICAgICBjYXNlIHRva2VuOiB7XG4gICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwic3RyX2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIGJyZWFrIHN0cjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiXFxcXFwiOiB7XG4gICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwic3RyX3BhdXNlXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgICAgICAgaWYgKHN0cltwb3MgKyAxXSA9PT0gXCJ1XCIpIHtcbiAgICAgICAgICAgIGlmIChzdHJbcG9zICsgMl0gPT09IFwie1wiKSB7XG4gICAgICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInVuaWNvZGVfaGV4XCIsIHBvc2l0aW9uOiBwb3MgKyAzIH0pO1xuICAgICAgICAgICAgICBwb3MgPSBzdHIuaW5kZXhPZihcIn1cIiwgcG9zICsgMyk7XG4gICAgICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInVuaWNvZGVfaGV4X2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwidW5pY29kZV9oZXhcIiwgcG9zaXRpb246IHBvcyArIDIgfSk7XG4gICAgICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInVuaWNvZGVfaGV4X2VuZFwiLCBwb3NpdGlvbjogcG9zICsgNiB9KTtcbiAgICAgICAgICAgICAgcG9zICs9IDU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInNpbmdsZV9lc2NhcGVcIiwgcG9zaXRpb246IHBvcyArIDEgfSk7XG4gICAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwic3RyX3N0YXJ0XCIsIHBvc2l0aW9uOiBwb3MgKyAxIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICByZXR1cm4geyB0eXBlOiBcInN1Y2Nlc3NcIiwgbWFya3MsIHBvc2l0aW9uOiBwb3MgfTtcbn1cbmZ1bmN0aW9uIHNraXBXUyhzdHIsIHBvcykge1xuICByZXR1cm4gcG9zICsgcGFyc2VSZWdleChzdHIsIHBvcywgV1MpO1xufVxuZnVuY3Rpb24gcGFyc2VSZWdleChzdHIsIHBvcywgcmUpIHtcbiAgbGV0IG0gPSByZS5leGVjKHN0ci5zbGljZShwb3MpKTtcbiAgcmV0dXJuIG0gPyBtWzBdLmxlbmd0aCA6IDA7XG59XG5mdW5jdGlvbiBwYXJzZVJlZ2V4U3RyKHN0ciwgcG9zLCByZSkge1xuICBsZXQgbSA9IHJlLmV4ZWMoc3RyLnNsaWNlKHBvcykpO1xuICByZXR1cm4gbSA/IG1bMF0gOiBudWxsO1xufVxuXG5mdW5jdGlvbiBqb2luKGEsIGIpIHtcbiAgcmV0dXJuIChiYXNlKSA9PiBiKGEoYmFzZSkpO1xufVxuZnVuY3Rpb24gbWFwKGlubmVyKSB7XG4gIHJldHVybiAoYmFzZSkgPT4gKHsgdHlwZTogXCJNYXBcIiwgYmFzZSwgZXhwcjogaW5uZXIoeyB0eXBlOiBcIlRoaXNcIiB9KSB9KTtcbn1cbmZ1bmN0aW9uIGZsYXRNYXAoaW5uZXIpIHtcbiAgcmV0dXJuIChiYXNlKSA9PiAoeyB0eXBlOiBcIkZsYXRNYXBcIiwgYmFzZSwgZXhwcjogaW5uZXIoeyB0eXBlOiBcIlRoaXNcIiB9KSB9KTtcbn1cbmZ1bmN0aW9uIHRyYXZlcnNlQXJyYXkoYnVpbGQsIHJpZ2h0KSB7XG4gIGlmICghcmlnaHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgIGJ1aWxkXG4gICAgfTtcbiAgfVxuICBzd2l0Y2ggKHJpZ2h0LnR5cGUpIHtcbiAgICBjYXNlIFwiYS1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgICBidWlsZDogam9pbihidWlsZCwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJhLWJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1iXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKGJ1aWxkLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImItYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIG1hcChyaWdodC5idWlsZCkpXG4gICAgICB9O1xuICAgIGNhc2UgXCJiLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKGJ1aWxkLCBmbGF0TWFwKHJpZ2h0LmJ1aWxkKSlcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIuY29uY2F0KHJpZ2h0LnR5cGUpKTtcbiAgfVxufVxuZnVuY3Rpb24gdHJhdmVyc2VQbGFpbihtYXBwZXIsIHJpZ2h0KSB7XG4gIGlmICghcmlnaHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJiLWJcIixcbiAgICAgIGJ1aWxkOiBtYXBwZXJcbiAgICB9O1xuICB9XG4gIHN3aXRjaCAocmlnaHQudHlwZSkge1xuICAgIGNhc2UgXCJhLWFcIjpcbiAgICBjYXNlIFwiYi1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImItYVwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYS1iXCI6XG4gICAgY2FzZSBcImItYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJiLWJcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIuY29uY2F0KHJpZ2h0LnR5cGUpKTtcbiAgfVxufVxuZnVuY3Rpb24gdHJhdmVyc2VFbGVtZW50KG1hcHBlciwgcmlnaHQpIHtcbiAgaWYgKCFyaWdodCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImEtYlwiLFxuICAgICAgYnVpbGQ6IG1hcHBlclxuICAgIH07XG4gIH1cbiAgc3dpdGNoIChyaWdodC50eXBlKSB7XG4gICAgY2FzZSBcImEtYVwiOlxuICAgIGNhc2UgXCJiLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJhLWJcIjpcbiAgICBjYXNlIFwiYi1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYlwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIi5jb25jYXQocmlnaHQudHlwZSkpO1xuICB9XG59XG5mdW5jdGlvbiB0cmF2ZXJzZVByb2plY3Rpb24obWFwcGVyLCByaWdodCkge1xuICBpZiAoIXJpZ2h0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYi1iXCIsXG4gICAgICBidWlsZDogbWFwcGVyXG4gICAgfTtcbiAgfVxuICBzd2l0Y2ggKHJpZ2h0LnR5cGUpIHtcbiAgICBjYXNlIFwiYS1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgICBidWlsZDogam9pbihtYXAobWFwcGVyKSwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJhLWJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1iXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcChtYXBwZXIpLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImItYVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJiLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImItYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJiLWJcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIuY29uY2F0KHJpZ2h0LnR5cGUpKTtcbiAgfVxufVxuXG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jb25zdCBFU0NBUEVfU0VRVUVOQ0UgPSB7XG4gIFwiJ1wiOiBcIidcIixcbiAgJ1wiJzogJ1wiJyxcbiAgXCJcXFxcXCI6IFwiXFxcXFwiLFxuICBcIi9cIjogXCIvXCIsXG4gIGI6IFwiXFxiXCIsXG4gIGY6IFwiXFxmXCIsXG4gIG46IFwiXFxuXCIsXG4gIHI6IFwiXFxyXCIsXG4gIHQ6IFwiXHRcIlxufTtcbmZ1bmN0aW9uIGV4cGFuZEhleChzdHIpIHtcbiAgY29uc3QgY2hhckNvZGUgPSBwYXJzZUludChzdHIsIDE2KTtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xufVxuY2xhc3MgR3JvcVF1ZXJ5RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm5hbWVcIiwgXCJHcm9xUXVlcnlFcnJvclwiKTtcbiAgfVxufVxuY29uc3QgRVhQUl9CVUlMREVSID0ge1xuICBncm91cChwKSB7XG4gICAgY29uc3QgaW5uZXIgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJHcm91cFwiLFxuICAgICAgYmFzZTogaW5uZXJcbiAgICB9O1xuICB9LFxuICBldmVyeXRoaW5nKCkge1xuICAgIHJldHVybiB7IHR5cGU6IFwiRXZlcnl0aGluZ1wiIH07XG4gIH0sXG4gIHRoaXMoKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJUaGlzXCIgfTtcbiAgfSxcbiAgcGFyZW50KCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlBhcmVudFwiLFxuICAgICAgbjogMVxuICAgIH07XG4gIH0sXG4gIGRibHBhcmVudChwKSB7XG4gICAgY29uc3QgbmV4dCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlBhcmVudFwiLFxuICAgICAgbjogbmV4dC5uICsgMVxuICAgIH07XG4gIH0sXG4gIHRyYXZlcnNlKHApIHtcbiAgICBjb25zdCBiYXNlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgdHJhdmVyc2FsTGlzdCA9IFtdO1xuICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSBcInRyYXZlcnNhbF9lbmRcIikge1xuICAgICAgdHJhdmVyc2FsTGlzdC5wdXNoKHAucHJvY2VzcyhUUkFWRVJTRV9CVUlMREVSKSk7XG4gICAgfVxuICAgIHAuc2hpZnQoKTtcbiAgICBsZXQgdHJhdmVyc2FsID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gdHJhdmVyc2FsTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdHJhdmVyc2FsID0gdHJhdmVyc2FsTGlzdFtpXSh0cmF2ZXJzYWwpO1xuICAgIH1cbiAgICBpZiAoYmFzZS50eXBlID09PSBcIkV2ZXJ5dGhpbmdcIiB8fCBiYXNlLnR5cGUgPT09IFwiQXJyYXlcIiB8fCBiYXNlLnR5cGUgPT09IFwiUGlwZUZ1bmNDYWxsXCIpIHtcbiAgICAgIHRyYXZlcnNhbCA9IHRyYXZlcnNlQXJyYXkoKHZhbCkgPT4gdmFsLCB0cmF2ZXJzYWwpO1xuICAgIH1cbiAgICBpZiAodHJhdmVyc2FsID09PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQlVHOiB1bmV4cGVjdGVkIGVtcHR5IHRyYXZlcnNhbFwiKTtcbiAgICByZXR1cm4gdHJhdmVyc2FsLmJ1aWxkKGJhc2UpO1xuICB9LFxuICB0aGlzX2F0dHIocCkge1xuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICBpZiAobmFtZSA9PT0gXCJudWxsXCIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiVmFsdWVcIiwgdmFsdWU6IG51bGwgfTtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09IFwidHJ1ZVwiKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIlZhbHVlXCIsIHZhbHVlOiB0cnVlIH07XG4gICAgfVxuICAgIGlmIChuYW1lID09PSBcImZhbHNlXCIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiVmFsdWVcIiwgdmFsdWU6IGZhbHNlIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkFjY2Vzc0F0dHJpYnV0ZVwiLFxuICAgICAgbmFtZVxuICAgIH07XG4gIH0sXG4gIG5lZyhwKSB7XG4gICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk5lZ1wiLFxuICAgICAgYmFzZVxuICAgIH07XG4gIH0sXG4gIHBvcyhwKSB7XG4gICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlBvc1wiLFxuICAgICAgYmFzZVxuICAgIH07XG4gIH0sXG4gIGFkZChwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCIrXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBzdWIocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiLVwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgbXVsKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIipcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIGRpdihwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCIvXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBtb2QocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiJVwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgcG93KHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIioqXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBjb21wKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3Qgb3AgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3AsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBpbl9yYW5nZShwKSB7XG4gICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IGlzSW5jbHVzaXZlID0gcC5nZXRNYXJrKCkubmFtZSA9PT0gXCJpbmNfcmFuZ2VcIjtcbiAgICBwLnNoaWZ0KCk7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiSW5SYW5nZVwiLFxuICAgICAgYmFzZSxcbiAgICAgIGxlZnQsXG4gICAgICByaWdodCxcbiAgICAgIGlzSW5jbHVzaXZlXG4gICAgfTtcbiAgfSxcbiAgc3RyKHApIHtcbiAgICBsZXQgdmFsdWUgPSBcIlwiO1xuICAgIGxvb3A6XG4gICAgICB3aGlsZSAocC5oYXNNYXJrKCkpIHtcbiAgICAgICAgY29uc3QgbWFyayA9IHAuZ2V0TWFyaygpO1xuICAgICAgICBzd2l0Y2ggKG1hcmsubmFtZSkge1xuICAgICAgICAgIGNhc2UgXCJzdHJfZW5kXCI6XG4gICAgICAgICAgICB2YWx1ZSArPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgY2FzZSBcInN0cl9wYXVzZVwiOlxuICAgICAgICAgICAgdmFsdWUgKz0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwic3RyX3N0YXJ0XCI6XG4gICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwic2luZ2xlX2VzY2FwZVwiOiB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gcC5zbGljZSgxKTtcbiAgICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICAgIHZhbHVlICs9IEVTQ0FQRV9TRVFVRU5DRVtjaGFyXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwidW5pY29kZV9oZXhcIjpcbiAgICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICAgIHZhbHVlICs9IGV4cGFuZEhleChwLnByb2Nlc3NTdHJpbmdFbmQoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZCBtYXJrOiBcIi5jb25jYXQobWFyay5uYW1lKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcIlZhbHVlXCIsIHZhbHVlIH07XG4gIH0sXG4gIGludGVnZXIocCkge1xuICAgIGNvbnN0IHN0clZhbHVlID0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgIHZhbHVlOiBOdW1iZXIoc3RyVmFsdWUpXG4gICAgfTtcbiAgfSxcbiAgZmxvYXQocCkge1xuICAgIGNvbnN0IHN0clZhbHVlID0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgIHZhbHVlOiBOdW1iZXIoc3RyVmFsdWUpXG4gICAgfTtcbiAgfSxcbiAgc2NpKHApIHtcbiAgICBjb25zdCBzdHJWYWx1ZSA9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICB2YWx1ZTogTnVtYmVyKHN0clZhbHVlKVxuICAgIH07XG4gIH0sXG4gIG9iamVjdChwKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IFtdO1xuICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSBcIm9iamVjdF9lbmRcIikge1xuICAgICAgYXR0cmlidXRlcy5wdXNoKHAucHJvY2VzcyhPQkpFQ1RfQlVJTERFUikpO1xuICAgIH1cbiAgICBwLnNoaWZ0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT2JqZWN0XCIsXG4gICAgICBhdHRyaWJ1dGVzXG4gICAgfTtcbiAgfSxcbiAgYXJyYXkocCkge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09IFwiYXJyYXlfZW5kXCIpIHtcbiAgICAgIGxldCBpc1NwbGF0ID0gZmFsc2U7XG4gICAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJhcnJheV9zcGxhdFwiKSB7XG4gICAgICAgIGlzU3BsYXQgPSB0cnVlO1xuICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgZWxlbWVudHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiQXJyYXlFbGVtZW50XCIsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBpc1NwbGF0XG4gICAgICB9KTtcbiAgICB9XG4gICAgcC5zaGlmdCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkFycmF5XCIsXG4gICAgICBlbGVtZW50c1xuICAgIH07XG4gIH0sXG4gIHR1cGxlKHApIHtcbiAgICBjb25zdCBtZW1iZXJzID0gW107XG4gICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09IFwidHVwbGVfZW5kXCIpIHtcbiAgICAgIG1lbWJlcnMucHVzaChwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSk7XG4gICAgfVxuICAgIHAuc2hpZnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJUdXBsZVwiLFxuICAgICAgbWVtYmVyc1xuICAgIH07XG4gIH0sXG4gIGZ1bmNfY2FsbChwKSB7XG4gICAgbGV0IG5hbWVzcGFjZSA9IFwiZ2xvYmFsXCI7XG4gICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwibmFtZXNwYWNlXCIpIHtcbiAgICAgIHAuc2hpZnQoKTtcbiAgICAgIG5hbWVzcGFjZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIH1cbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgaWYgKG5hbWVzcGFjZSA9PT0gXCJnbG9iYWxcIiAmJiBuYW1lID09PSBcInNlbGVjdFwiKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IFwiU2VsZWN0XCIsXG4gICAgICAgIGFsdGVybmF0aXZlczogW11cbiAgICAgIH07XG4gICAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gXCJmdW5jX2FyZ3NfZW5kXCIpIHtcbiAgICAgICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwicGFpclwiKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdC5mYWxsYmFjaylcbiAgICAgICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgYXJndW1lbnQgdG8gc2VsZWN0KClcIik7XG4gICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgICAgcmVzdWx0LmFsdGVybmF0aXZlcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiU2VsZWN0QWx0ZXJuYXRpdmVcIixcbiAgICAgICAgICAgIGNvbmRpdGlvbixcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHJlc3VsdC5mYWxsYmFjaylcbiAgICAgICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgYXJndW1lbnQgdG8gc2VsZWN0KClcIik7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgICByZXN1bHQuZmFsbGJhY2sgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcC5zaGlmdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgYXJncyA9IFtdO1xuICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSBcImZ1bmNfYXJnc19lbmRcIikge1xuICAgICAgaWYgKGFyZ3VtZW50U2hvdWxkQmVTZWxlY3RvcihuYW1lc3BhY2UsIG5hbWUsIGFyZ3MubGVuZ3RoKSkge1xuICAgICAgICBwLnByb2Nlc3MoU0VMRUNUT1JfQlVJTERFUik7XG4gICAgICAgIGFyZ3MucHVzaCh7IHR5cGU6IFwiU2VsZWN0b3JcIiB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyZ3MucHVzaChwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHAuc2hpZnQoKTtcbiAgICBpZiAobmFtZXNwYWNlID09PSBcImdsb2JhbFwiICYmIChuYW1lID09PSBcImJlZm9yZVwiIHx8IG5hbWUgPT09IFwiYWZ0ZXJcIikpIHtcbiAgICAgIGlmIChwLnBhcnNlT3B0aW9ucy5tb2RlID09PSBcImRlbHRhXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcIkNvbnRleHRcIixcbiAgICAgICAgICBrZXk6IG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5hbWVzcGFjZSA9PT0gXCJnbG9iYWxcIiAmJiBuYW1lID09PSBcImJvb3N0XCIgJiYgIXAuYWxsb3dCb29zdClcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgYm9vc3RcIik7XG4gICAgY29uc3QgZnVuY3MgPSBuYW1lc3BhY2VzW25hbWVzcGFjZV07XG4gICAgaWYgKCFmdW5jcykge1xuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwiVW5kZWZpbmVkIG5hbWVzcGFjZTogXCIuY29uY2F0KG5hbWVzcGFjZSkpO1xuICAgIH1cbiAgICBjb25zdCBmdW5jID0gZnVuY3NbbmFtZV07XG4gICAgaWYgKCFmdW5jKSB7XG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJVbmRlZmluZWQgZnVuY3Rpb246IFwiLmNvbmNhdChuYW1lKSk7XG4gICAgfVxuICAgIGlmIChmdW5jLmFyaXR5ICE9PSB2b2lkIDApIHtcbiAgICAgIHZhbGlkYXRlQXJpdHkobmFtZSwgZnVuYy5hcml0eSwgYXJncy5sZW5ndGgpO1xuICAgIH1cbiAgICBpZiAoZnVuYy5tb2RlICE9PSB2b2lkIDAgJiYgZnVuYy5tb2RlICE9PSBwLnBhcnNlT3B0aW9ucy5tb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJVbmRlZmluZWQgZnVuY3Rpb246IFwiLmNvbmNhdChuYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkZ1bmNDYWxsXCIsXG4gICAgICBmdW5jLFxuICAgICAgbmFtZXNwYWNlLFxuICAgICAgbmFtZSxcbiAgICAgIGFyZ3NcbiAgICB9O1xuICB9LFxuICBwaXBlY2FsbChwKSB7XG4gICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHAuc2hpZnQoKTtcbiAgICBsZXQgbmFtZXNwYWNlID0gXCJnbG9iYWxcIjtcbiAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJuYW1lc3BhY2VcIikge1xuICAgICAgcC5zaGlmdCgpO1xuICAgICAgbmFtZXNwYWNlID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChuYW1lc3BhY2UgIT09IFwiZ2xvYmFsXCIpIHtcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIlVuZGVmaW5lZCBuYW1lc3BhY2U6IFwiLmNvbmNhdChuYW1lc3BhY2UpKTtcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIGNvbnN0IGFyZ3MgPSBbXTtcbiAgICBjb25zdCBvbGRBbGxvd0Jvb3N0ID0gcC5hbGxvd0Jvb3N0O1xuICAgIGlmIChuYW1lID09PSBcInNjb3JlXCIpIHtcbiAgICAgIHAuYWxsb3dCb29zdCA9IHRydWU7XG4gICAgfVxuICAgIGZvciAoOyA7ICkge1xuICAgICAgY29uc3QgbWFya05hbWUgPSBwLmdldE1hcmsoKS5uYW1lO1xuICAgICAgaWYgKG1hcmtOYW1lID09PSBcImZ1bmNfYXJnc19lbmRcIikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lID09PSBcIm9yZGVyXCIpIHtcbiAgICAgICAgaWYgKG1hcmtOYW1lID09PSBcImFzY1wiKSB7XG4gICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgIGFyZ3MucHVzaCh7IHR5cGU6IFwiQXNjXCIsIGJhc2U6IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG1hcmtOYW1lID09PSBcImRlc2NcIikge1xuICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICBhcmdzLnB1c2goeyB0eXBlOiBcIkRlc2NcIiwgYmFzZTogcC5wcm9jZXNzKEVYUFJfQlVJTERFUikgfSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFyZ3MucHVzaChwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSk7XG4gICAgfVxuICAgIHAuc2hpZnQoKTtcbiAgICBwLmFsbG93Qm9vc3QgPSBvbGRBbGxvd0Jvb3N0O1xuICAgIGNvbnN0IGZ1bmMgPSBwaXBlRnVuY3Rpb25zW25hbWVdO1xuICAgIGlmICghZnVuYykge1xuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwiVW5kZWZpbmVkIHBpcGUgZnVuY3Rpb246IFwiLmNvbmNhdChuYW1lKSk7XG4gICAgfVxuICAgIGlmIChmdW5jLmFyaXR5KSB7XG4gICAgICB2YWxpZGF0ZUFyaXR5KG5hbWUsIGZ1bmMuYXJpdHksIGFyZ3MubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiUGlwZUZ1bmNDYWxsXCIsXG4gICAgICBmdW5jLFxuICAgICAgYmFzZSxcbiAgICAgIG5hbWUsXG4gICAgICBhcmdzXG4gICAgfTtcbiAgfSxcbiAgcGFpcihwKSB7XG4gICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCA9PlwiKTtcbiAgfSxcbiAgYW5kKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJBbmRcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIG9yKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPclwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgbm90KHApIHtcbiAgICBjb25zdCBiYXNlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTm90XCIsXG4gICAgICBiYXNlXG4gICAgfTtcbiAgfSxcbiAgYXNjKHApIHtcbiAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGFzY1wiKTtcbiAgfSxcbiAgZGVzYyhwKSB7XG4gICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCBkZXNjXCIpO1xuICB9LFxuICBwYXJhbShwKSB7XG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIGlmIChwLnBhcnNlT3B0aW9ucy5wYXJhbXMgJiYgcC5wYXJzZU9wdGlvbnMucGFyYW1zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICAgIHZhbHVlOiBwLnBhcnNlT3B0aW9ucy5wYXJhbXNbbmFtZV1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlBhcmFtZXRlclwiLFxuICAgICAgbmFtZVxuICAgIH07XG4gIH1cbn07XG5jb25zdCBPQkpFQ1RfQlVJTERFUiA9IHtcbiAgb2JqZWN0X2V4cHIocCkge1xuICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcInBhaXJcIikge1xuICAgICAgcC5zaGlmdCgpO1xuICAgICAgY29uc3QgY29uZGl0aW9uID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICBjb25zdCB2YWx1ZTIgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiT2JqZWN0Q29uZGl0aW9uYWxTcGxhdFwiLFxuICAgICAgICBjb25kaXRpb24sXG4gICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT2JqZWN0QXR0cmlidXRlVmFsdWVcIixcbiAgICAgIG5hbWU6IGV4dHJhY3RQcm9wZXJ0eUtleSh2YWx1ZSksXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH0sXG4gIG9iamVjdF9wYWlyKHApIHtcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgaWYgKG5hbWUudHlwZSAhPT0gXCJWYWx1ZVwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibmFtZSBtdXN0IGJlIHN0cmluZ1wiKTtcbiAgICBjb25zdCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9iamVjdEF0dHJpYnV0ZVZhbHVlXCIsXG4gICAgICBuYW1lOiBuYW1lLnZhbHVlLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9LFxuICBvYmplY3Rfc3BsYXQocCkge1xuICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT2JqZWN0U3BsYXRcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfSxcbiAgb2JqZWN0X3NwbGF0X3RoaXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT2JqZWN0U3BsYXRcIixcbiAgICAgIHZhbHVlOiB7IHR5cGU6IFwiVGhpc1wiIH1cbiAgICB9O1xuICB9XG59O1xuY29uc3QgVFJBVkVSU0VfQlVJTERFUiA9IHtcbiAgc3F1YXJlX2JyYWNrZXQocCkge1xuICAgIGNvbnN0IGV4cHIgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCB2YWx1ZSA9IHRyeUNvbnN0YW50RXZhbHVhdGUoZXhwcik7XG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiAocmlnaHQpID0+IHRyYXZlcnNlRWxlbWVudCgoYmFzZSkgPT4gKHsgdHlwZTogXCJBY2Nlc3NFbGVtZW50XCIsIGJhc2UsIGluZGV4OiB2YWx1ZS5kYXRhIH0pLCByaWdodCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gKHJpZ2h0KSA9PiB0cmF2ZXJzZVBsYWluKChiYXNlKSA9PiAoeyB0eXBlOiBcIkFjY2Vzc0F0dHJpYnV0ZVwiLCBiYXNlLCBuYW1lOiB2YWx1ZS5kYXRhIH0pLCByaWdodCk7XG4gICAgfVxuICAgIHJldHVybiAocmlnaHQpID0+IHRyYXZlcnNlQXJyYXkoXG4gICAgICAoYmFzZSkgPT4gKHtcbiAgICAgICAgdHlwZTogXCJGaWx0ZXJcIixcbiAgICAgICAgYmFzZSxcbiAgICAgICAgZXhwclxuICAgICAgfSksXG4gICAgICByaWdodFxuICAgICk7XG4gIH0sXG4gIHNsaWNlKHApIHtcbiAgICBjb25zdCBpc0luY2x1c2l2ZSA9IHAuZ2V0TWFyaygpLm5hbWUgPT09IFwiaW5jX3JhbmdlXCI7XG4gICAgcC5zaGlmdCgpO1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IGxlZnRWYWx1ZSA9IHRyeUNvbnN0YW50RXZhbHVhdGUobGVmdCk7XG4gICAgY29uc3QgcmlnaHRWYWx1ZSA9IHRyeUNvbnN0YW50RXZhbHVhdGUocmlnaHQpO1xuICAgIGlmICghbGVmdFZhbHVlIHx8ICFyaWdodFZhbHVlIHx8IGxlZnRWYWx1ZS50eXBlICE9PSBcIm51bWJlclwiIHx8IHJpZ2h0VmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwic2xpY2luZyBtdXN0IHVzZSBjb25zdGFudCBudW1iZXJzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gKHJocykgPT4gdHJhdmVyc2VBcnJheShcbiAgICAgIChiYXNlKSA9PiAoe1xuICAgICAgICB0eXBlOiBcIlNsaWNlXCIsXG4gICAgICAgIGJhc2UsXG4gICAgICAgIGxlZnQ6IGxlZnRWYWx1ZS5kYXRhLFxuICAgICAgICByaWdodDogcmlnaHRWYWx1ZS5kYXRhLFxuICAgICAgICBpc0luY2x1c2l2ZVxuICAgICAgfSksXG4gICAgICByaHNcbiAgICApO1xuICB9LFxuICBwcm9qZWN0aW9uKHApIHtcbiAgICBjb25zdCBvYmogPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4gKHJpZ2h0KSA9PiB0cmF2ZXJzZVByb2plY3Rpb24oKGJhc2UpID0+ICh7IHR5cGU6IFwiUHJvamVjdGlvblwiLCBiYXNlLCBleHByOiBvYmogfSksIHJpZ2h0KTtcbiAgfSxcbiAgYXR0cl9hY2Nlc3MocCkge1xuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICByZXR1cm4gKHJpZ2h0KSA9PiB0cmF2ZXJzZVBsYWluKChiYXNlKSA9PiAoeyB0eXBlOiBcIkFjY2Vzc0F0dHJpYnV0ZVwiLCBiYXNlLCBuYW1lIH0pLCByaWdodCk7XG4gIH0sXG4gIGRlcmVmKHApIHtcbiAgICBsZXQgYXR0ciA9IG51bGw7XG4gICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwiZGVyZWZfYXR0clwiKSB7XG4gICAgICBwLnNoaWZ0KCk7XG4gICAgICBhdHRyID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgfVxuICAgIGNvbnN0IHdyYXAgPSAoYmFzZSkgPT4gYXR0ciA/IHsgdHlwZTogXCJBY2Nlc3NBdHRyaWJ1dGVcIiwgYmFzZSwgbmFtZTogYXR0ciB9IDogYmFzZTtcbiAgICByZXR1cm4gKHJpZ2h0KSA9PiB0cmF2ZXJzZVBsYWluKFxuICAgICAgKGJhc2UpID0+IHdyYXAoe1xuICAgICAgICB0eXBlOiBcIkRlcmVmXCIsXG4gICAgICAgIGJhc2VcbiAgICAgIH0pLFxuICAgICAgcmlnaHRcbiAgICApO1xuICB9LFxuICBhcnJheV9wb3N0Zml4KHApIHtcbiAgICByZXR1cm4gKHJpZ2h0KSA9PiB0cmF2ZXJzZUFycmF5KChiYXNlKSA9PiAoeyB0eXBlOiBcIkFycmF5Q29lcmNlXCIsIGJhc2UgfSksIHJpZ2h0KTtcbiAgfVxufTtcbmNvbnN0IFNFTEVDVE9SX0JVSUxERVIgPSB7XG4gIGdyb3VwKHApIHtcbiAgICBwLnByb2Nlc3MoU0VMRUNUT1JfQlVJTERFUik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIGV2ZXJ5dGhpbmcoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHRoaXMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHBhcmVudCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgZGJscGFyZW50KHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgdHJhdmVyc2UocCkge1xuICAgIHAucHJvY2VzcyhTRUxFQ1RPUl9CVUlMREVSKTtcbiAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gXCJ0cmF2ZXJzYWxfZW5kXCIpIHtcbiAgICAgIHAucHJvY2VzcyhUUkFWRVJTRV9CVUlMREVSKTtcbiAgICB9XG4gICAgcC5zaGlmdCgpO1xuICAgIHJldHVybiBudWxsO1xuICB9LFxuICB0aGlzX2F0dHIocCkge1xuICAgIHAucHJvY2Vzc1N0cmluZygpO1xuICAgIHJldHVybiBudWxsO1xuICB9LFxuICBuZWcocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBwb3MocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBhZGQocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBzdWIocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBtdWwocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBkaXYocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBtb2QocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBwb3cocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBjb21wKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgaW5fcmFuZ2UocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBzdHIocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBpbnRlZ2VyKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgZmxvYXQocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBzY2kocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBvYmplY3QocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBhcnJheShwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHR1cGxlKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgZnVuY19jYWxsKHAsIG1hcmspIHtcbiAgICBjb25zdCBmdW5jID0gRVhQUl9CVUlMREVSLmZ1bmNfY2FsbChwLCBtYXJrKTtcbiAgICBpZiAoZnVuYy5uYW1lID09PSBcImFueXdoZXJlXCIgJiYgZnVuYy5hcmdzLmxlbmd0aCA9PT0gMSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBwaXBlY2FsbChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHBhaXIocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBhbmQocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBvcihwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIG5vdChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGFzYyhwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGRlc2MocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBwYXJhbShwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH1cbn07XG5mdW5jdGlvbiBleHRyYWN0UHJvcGVydHlLZXkobm9kZSkge1xuICBpZiAobm9kZS50eXBlID09PSBcIkFjY2Vzc0F0dHJpYnV0ZVwiICYmICFub2RlLmJhc2UpIHtcbiAgICByZXR1cm4gbm9kZS5uYW1lO1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IFwiRGVyZWZcIiB8fCBub2RlLnR5cGUgPT09IFwiTWFwXCIgfHwgbm9kZS50eXBlID09PSBcIlByb2plY3Rpb25cIiB8fCBub2RlLnR5cGUgPT09IFwiU2xpY2VcIiB8fCBub2RlLnR5cGUgPT09IFwiRmlsdGVyXCIgfHwgbm9kZS50eXBlID09PSBcIkFjY2Vzc0VsZW1lbnRcIiB8fCBub2RlLnR5cGUgPT09IFwiQXJyYXlDb2VyY2VcIikge1xuICAgIHJldHVybiBleHRyYWN0UHJvcGVydHlLZXkobm9kZS5iYXNlKTtcbiAgfVxuICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJDYW5ub3QgZGV0ZXJtaW5lIHByb3BlcnR5IGtleSBmb3IgdHlwZTogXCIuY29uY2F0KG5vZGUudHlwZSkpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVBcml0eShuYW1lLCBhcml0eSwgY291bnQpIHtcbiAgaWYgKHR5cGVvZiBhcml0eSA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmIChjb3VudCAhPT0gYXJpdHkpIHtcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcbiAgICAgICAgXCJJbmNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBmdW5jdGlvbiBcIi5jb25jYXQobmFtZSwgXCIoKS4gRXhwZWN0ZWQgXCIpLmNvbmNhdChhcml0eSwgXCIsIGdvdCBcIikuY29uY2F0KGNvdW50LCBcIi5cIilcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyaXR5KSB7XG4gICAgaWYgKCFhcml0eShjb3VudCkpIHtcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIkluY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGZ1bmN0aW9uIFwiLmNvbmNhdChuYW1lLCBcIigpLlwiKSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhcmd1bWVudFNob3VsZEJlU2VsZWN0b3IobmFtZXNwYWNlLCBmdW5jdGlvbk5hbWUsIGFyZ0NvdW50KSB7XG4gIGNvbnN0IGZ1bmN0aW9uc1JlcXVpcmluZ1NlbGVjdG9ycyA9IFtcImNoYW5nZWRBbnlcIiwgXCJjaGFuZ2VkT25seVwiXTtcbiAgcmV0dXJuIG5hbWVzcGFjZSA9PSBcImRpZmZcIiAmJiBhcmdDb3VudCA9PSAyICYmIGZ1bmN0aW9uc1JlcXVpcmluZ1NlbGVjdG9ycy5pbmNsdWRlcyhmdW5jdGlvbk5hbWUpO1xufVxuY2xhc3MgR3JvcVN5bnRheEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihwb3NpdGlvbikge1xuICAgIHN1cGVyKFwiU3ludGF4IGVycm9yIGluIEdST1EgcXVlcnkgYXQgcG9zaXRpb24gXCIuY29uY2F0KHBvc2l0aW9uKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInBvc2l0aW9uXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJuYW1lXCIsIFwiR3JvcVN5bnRheEVycm9yXCIpO1xuICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2UoaW5wdXQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCByZXN1bHQgPSBwYXJzZSQxKGlucHV0KTtcbiAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICB0aHJvdyBuZXcgR3JvcVN5bnRheEVycm9yKHJlc3VsdC5wb3NpdGlvbik7XG4gIH1cbiAgY29uc3QgcHJvY2Vzc29yID0gbmV3IE1hcmtQcm9jZXNzb3IoaW5wdXQsIHJlc3VsdC5tYXJrcywgb3B0aW9ucyk7XG4gIHJldHVybiBwcm9jZXNzb3IucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xufVxuXG5leHBvcnQgeyBEYXRlVGltZSwgUGF0aCwgZXZhbHVhdGVRdWVyeSBhcyBldmFsdWF0ZSwgcGFyc2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPTEubWpzLm1hcFxuIl0sIm5hbWVzIjpbIl9fZGVmUHJvcCQ1IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2RlZk5vcm1hbFByb3AkNSIsIm9iaiIsImtleSIsInZhbHVlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX19wdWJsaWNGaWVsZCQ1IiwiZXNjYXBlUmVnRXhwIiwic3RyaW5nIiwicmVwbGFjZSIsInBhdGhSZWdFeHAiLCJwYXR0ZXJuIiwicmUiLCJwYXJ0Iiwic3BsaXQiLCJwdXNoIiwiUmVnRXhwIiwiY29uY2F0Iiwiam9pbiIsIlBhdGgiLCJjb25zdHJ1Y3RvciIsInBhdHRlcm5SZSIsIm1hdGNoZXMiLCJzdHIiLCJ0ZXN0IiwidG9KU09OIiwiX19kZWZQcm9wJDQiLCJfX2RlZk5vcm1hbFByb3AkNCIsIl9fcHVibGljRmllbGQkNCIsIlN0cmVhbVZhbHVlIiwiZ2VuZXJhdG9yIiwidGlja2VyIiwiaXNEb25lIiwiZGF0YSIsImlzQXJyYXkiLCJnZXQiLCJyZXN1bHQiLCJTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwiaSIsImxlbmd0aCIsIl9uZXh0VGljayIsImN1cnJlbnRSZXNvbHZlciIsInNldHVwVGlja2VyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aWNrIiwiZmV0Y2giLCJSRkMzMzM5X1JFR0VYIiwicGFyc2VSRkMzMzM5IiwiRGF0ZSIsImZvcm1hdFJGQzMzMzkiLCJkIiwieWVhciIsImFkZExlYWRpbmdaZXJvIiwiZ2V0VVRDRnVsbFllYXIiLCJtb250aCIsImdldFVUQ01vbnRoIiwiZGF5IiwiZ2V0VVRDRGF0ZSIsImhvdXIiLCJnZXRVVENIb3VycyIsIm1pbnV0ZSIsImdldFVUQ01pbnV0ZXMiLCJzZWNvbmQiLCJnZXRVVENTZWNvbmRzIiwiZnJhY3Rpb25hbFNlY29uZCIsIm1pbGxpcyIsImdldE1pbGxpc2Vjb25kcyIsIm51bSIsInRhcmdldExlbmd0aCIsInRvU3RyaW5nIiwiX19kZWZQcm9wJDMiLCJfX2RlZk5vcm1hbFByb3AkMyIsIl9fcHVibGljRmllbGQkMyIsIlN0YXRpY1ZhbHVlIiwidHlwZSIsIkFycmF5IiwiZWxlbWVudCIsImZyb21KUyIsIkVycm9yIiwiTlVMTF9WQUxVRSIsIlRSVUVfVkFMVUUiLCJGQUxTRV9WQUxVRSIsIkRhdGVUaW1lIiwiZGF0ZSIsInBhcnNlVG9WYWx1ZSIsImVxdWFscyIsIm90aGVyIiwiZ2V0VGltZSIsImFkZCIsInNlY3MiLCJjb3B5Iiwic2V0VGltZSIsImRpZmZlcmVuY2UiLCJjb21wYXJlVG8iLCJmcm9tTnVtYmVyIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJmcm9tU3RyaW5nIiwiZnJvbURhdGVUaW1lIiwiZHQiLCJmcm9tUGF0aCIsInBhdGgiLCJpc0l0ZXJhdG9yIiwibmV4dCIsInZhbCIsImdldFR5cGUiLCJpc0VxdWFsIiwiYSIsImIiLCJDSEFSUyIsIkNIQVJTX1dJVEhfV0lMRENBUkQiLCJFREdFX0NIQVJTIiwiTUFYX1RFUk1fTEVOR1RIIiwibWF0Y2hUZXh0IiwidG9rZW5zIiwicGF0dGVybnMiLCJldmVyeSIsIm1hdGNoVG9rZW5pemUiLCJ0ZXh0IiwibWF0Y2giLCJtYXRjaEFuYWx5emVQYXR0ZXJuIiwidGVybXNSZSIsIm1hdGNoUGF0dGVyblJlZ2V4IiwibWFwIiwic29tZSIsInRva2VuIiwidGVybXMiLCJ0ZXJtIiwic2xpY2UiLCJnYXRoZXJUZXh0IiwiY2IiLCJzdWNjZXNzIiwiVFlQRV9PUkRFUiIsImRhdGV0aW1lIiwibnVtYmVyIiwiYm9vbGVhbiIsInBhcnRpYWxDb21wYXJlIiwiYVR5cGUiLCJiVHlwZSIsInRvdGFsQ29tcGFyZSIsImFUeXBlT3JkZXIiLCJiVHlwZU9yZGVyIiwib3BlcmF0b3JzIiwiZXEiLCJsZWZ0IiwicmlnaHQiLCJuZXEiLCJndCIsImd0ZSIsImx0IiwibHRlIiwiaW4iLCJpbm9wIiwiZGlkU3VjY2VlZCIsIm1hdGNoZWQiLCJwbHVzIiwibWludXMiLCJudW1lcmljT3BlcmF0b3IiLCJNYXRoIiwicG93IiwiaW1wbCIsIl9fZGVmUHJvcCQyIiwiX19kZWZOb3JtYWxQcm9wJDIiLCJfX3B1YmxpY0ZpZWxkJDIiLCJTY29wZSIsInBhcmFtcyIsInNvdXJjZSIsImNvbnRleHQiLCJwYXJlbnQiLCJjcmVhdGVOZXN0ZWQiLCJpc0hpZGRlbiIsImNyZWF0ZUhpZGRlbiIsImV2YWx1YXRlIiwibm9kZSIsInNjb3BlIiwiZXhlY3V0ZSIsImZ1bmMiLCJFWEVDVVRPUlMiLCJwcm9taXNlbGVzc0FwcGx5IiwidGhlbiIsIlRoaXMiLCJfIiwiU2VsZWN0b3IiLCJFdmVyeXRoaW5nIiwiUGFyYW1ldGVyIiwibmFtZSIsIkNvbnRleHQiLCJQYXJlbnQiLCJuIiwiY3VycmVudCIsIk9wQ2FsbCIsIm9wIiwibGVmdFZhbHVlIiwicmlnaHRWYWx1ZSIsIlNlbGVjdCIsImFsdGVybmF0aXZlcyIsImZhbGxiYWNrIiwiYWx0IiwiYWx0Q29uZCIsImNvbmRpdGlvbiIsIkluUmFuZ2UiLCJiYXNlIiwiaXNJbmNsdXNpdmUiLCJsZWZ0Q21wIiwicmlnaHRDbXAiLCJGaWx0ZXIiLCJleHByIiwiYmFzZVZhbHVlIiwiZWxlbSIsIm5ld1Njb3BlIiwiZXhwclZhbHVlIiwiUHJvamVjdGlvbiIsIkZ1bmNDYWxsIiwiYXJncyIsIlBpcGVGdW5jQ2FsbCIsIkFjY2Vzc0F0dHJpYnV0ZSIsImhhc093blByb3BlcnR5IiwiQWNjZXNzRWxlbWVudCIsImluZGV4IiwiZmluYWxJbmRleCIsIlNsaWNlIiwiYXJyYXkiLCJsZWZ0SWR4IiwicmlnaHRJZHgiLCJEZXJlZiIsImlkIiwiX3JlZiIsImRlcmVmZXJlbmNlIiwiZG9jIiwiX2lkIiwiVmFsdWUiLCJHcm91cCIsImF0dHJpYnV0ZXMiLCJhdHRyIiwiYXR0clR5cGUiLCJjb25kIiwiYXNzaWduIiwiZWxlbWVudHMiLCJpc1NwbGF0IiwidiIsIlR1cGxlIiwiT3IiLCJBbmQiLCJOb3QiLCJOZWciLCJQb3MiLCJBc2MiLCJEZXNjIiwiQXJyYXlDb2VyY2UiLCJNYXAiLCJGbGF0TWFwIiwiaW5uZXJWYWx1ZSIsImlubmVyIiwiZXZhbHVhdGVRdWVyeSIsInRyZWUiLCJvcHRpb25zIiwicm9vdCIsImRhdGFzZXQiLCJ0aW1lc3RhbXAiLCJpZGVudGl0eSIsInNhbml0eSIsImFmdGVyIiwiYmVmb3JlIiwiY2FuQ29uc3RhbnRFdmFsdWF0ZSIsIkRVTU1ZX1NDT1BFIiwidHJ5Q29uc3RhbnRFdmFsdWF0ZSIsImNvbnN0YW50RXZhbHVhdGUiLCJwb3J0YWJsZVRleHRDb250ZW50IiwiYmxvY2tUZXh0IiwidGV4dHMiLCJhcnJheVRleHQiLCJibG9jayIsIl90eXBlIiwiY2hpbGRyZW4iLCJjaGlsZCIsIkJNMjVrIiwiZXZhbHVhdGVTY29yZSIsImV2YWx1YXRlTWF0Y2hTY29yZSIsImlubmVyU2NvcmUiLCJib29zdCIsImxlZnRTY29yZSIsInJpZ2h0U2NvcmUiLCJyZXMiLCJzY29yZSIsImZyZXEiLCJyZWR1Y2UiLCJjIiwiaGFzUmVmZXJlbmNlIiwicGF0aFNldCIsImhhcyIsInZhbHVlcyIsImNvdW50VVRGOCIsImNvdW50MiIsImNvZGUiLCJjaGFyQ29kZUF0IiwiX2dsb2JhbCIsImFueXdoZXJlIiwiYXJpdHkiLCJjb2FsZXNjZSIsImFyZyIsImNvdW50IiwiZGF0ZVRpbWUiLCJkZWZpbmVkIiwicmVmZXJlbmNlcyIsIlNldCIsInBhdGgyIiwic2l6ZSIsInNjb3BlVmFsdWUiLCJyb3VuZCIsInByZWMiLCJwcmVjVmFsdWUiLCJpc0ludGVnZXIiLCJ0b0ZpeGVkIiwibm93IiwidG9JU09TdHJpbmciLCJzdHJpbmcyIiwibG93ZXIiLCJ0b0xvd2VyQ2FzZSIsInVwcGVyIiwidG9VcHBlckNhc2UiLCJzZXAiLCJmcm9tIiwic3RhcnRzV2l0aCIsInByZWZpeCIsImFyciIsImJ1ZiIsIm5lZWRTZXAiLCJjb21wYWN0IiwidW5pcXVlIiwiYWRkZWQiLCJpdGVyIiwicHQiLCJwcm9qZWN0SWQiLCJwaXBlRnVuY3Rpb25zIiwib3JkZXIiLCJtYXBwZXJzIiwiZGlyZWN0aW9ucyIsIm1hcHBlciIsImRpcmVjdGlvbiIsImF1eCIsImlkeCIsInR1cGxlIiwic29ydCIsImFUdXBsZSIsImJUdXBsZSIsInVua25vd24iLCJzY29yZWQiLCJ2YWx1ZVNjb3JlIiwiX3Njb3JlIiwibmV3T2JqZWN0IiwiZGVsdGEiLCJvcGVyYXRpb24iLCJoYXNCZWZvcmUiLCJoYXNBZnRlciIsImNoYW5nZWRBbnkiLCJtb2RlIiwiY2hhbmdlZE9ubHkiLCJkaWZmIiwibWF0aCIsIm1pbiIsIm1heCIsInN1bSIsImF2ZyIsImRhdGVUaW1lMiIsIm5vdzIiLCJuYW1lc3BhY2VzIiwiZ2xvYmFsIiwiX19kZWZQcm9wJDEiLCJfX2RlZk5vcm1hbFByb3AkMSIsIl9fcHVibGljRmllbGQkMSIsIk1hcmtQcm9jZXNzb3IiLCJtYXJrcyIsInBhcnNlT3B0aW9ucyIsImhhc01hcmsiLCJwb3MiLCJnZXRNYXJrIiwic2hpZnQiLCJwcm9jZXNzIiwidmlzaXRvciIsIm1hcmsiLCJjYWxsIiwicHJvY2Vzc1N0cmluZyIsInByb2Nlc3NTdHJpbmdFbmQiLCJwcmV2IiwiY3VyciIsInBvc2l0aW9uIiwibGVuIiwiV1MiLCJOVU0iLCJJREVOVCIsIlBSRUNfUEFJUiIsIlBSRUNfT1IiLCJQUkVDX0FORCIsIlBSRUNfQ09NUCIsIlBSRUNfT1JERVIiLCJQUkVDX0FERCIsIlBSRUNfU1VCIiwiUFJFQ19NVUwiLCJQUkVDX0RJViIsIlBSRUNfTU9EIiwiUFJFQ19QT1ciLCJQUkVDX1BPUyIsIlBSRUNfTk9UIiwiUFJFQ19ORUciLCJwYXJzZSQxIiwic2tpcFdTIiwicGFyc2VFeHByIiwiZmFpbFBvc2l0aW9uIiwibGV2ZWwiLCJzdGFydFBvcyIsInJocyIsInBhcnNlT2JqZWN0IiwicGFyc2VTdHJpbmciLCJpZGVudExlbiIsInBhcnNlUmVnZXgiLCJudW1MZW4iLCJmcmFjTGVuIiwiZXhwTGVuIiwicGFyc2VGdW5jQ2FsbCIsImxoc0xldmVsIiwidHJhdiIsImxvb3AiLCJpbm5lclBvcyIsInBhcnNlVHJhdmVyc2FsIiwidW5zaGlmdCIsInRva2VuMiIsIm5leHRUb2tlbiIsInJoczIiLCJuZXh0UG9zIiwiaWRlbnRQb3MiLCJpZGVudCIsInBhcnNlUmVnZXhTdHIiLCJpc0dyb3VwIiwicmFuZ2VQb3MiLCJpZGVudFN0YXJ0IiwiaWRlbnRMZW4yIiwibmFtZUxlbiIsImxhc3RQb3MiLCJwYWlyUG9zIiwiaW5kZXhPZiIsIm0iLCJleGVjIiwiZmxhdE1hcCIsInRyYXZlcnNlQXJyYXkiLCJidWlsZCIsInRyYXZlcnNlUGxhaW4iLCJ0cmF2ZXJzZUVsZW1lbnQiLCJ0cmF2ZXJzZVByb2plY3Rpb24iLCJfX2RlZlByb3AiLCJfX2RlZk5vcm1hbFByb3AiLCJfX3B1YmxpY0ZpZWxkIiwiRVNDQVBFX1NFUVVFTkNFIiwiZiIsInIiLCJ0IiwiZXhwYW5kSGV4IiwiY2hhckNvZGUiLCJwYXJzZUludCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIkdyb3FRdWVyeUVycm9yIiwiYXJndW1lbnRzIiwiRVhQUl9CVUlMREVSIiwiZ3JvdXAiLCJwIiwiZXZlcnl0aGluZyIsInRoaXMiLCJkYmxwYXJlbnQiLCJ0cmF2ZXJzZSIsInRyYXZlcnNhbExpc3QiLCJUUkFWRVJTRV9CVUlMREVSIiwidHJhdmVyc2FsIiwidGhpc19hdHRyIiwibmVnIiwic3ViIiwibXVsIiwiZGl2IiwibW9kIiwiY29tcCIsImluX3JhbmdlIiwiY2hhciIsImludGVnZXIiLCJzdHJWYWx1ZSIsImZsb2F0Iiwic2NpIiwib2JqZWN0IiwiT0JKRUNUX0JVSUxERVIiLCJtZW1iZXJzIiwiZnVuY19jYWxsIiwibmFtZXNwYWNlIiwiYXJndW1lbnRTaG91bGRCZVNlbGVjdG9yIiwiU0VMRUNUT1JfQlVJTERFUiIsImFsbG93Qm9vc3QiLCJmdW5jcyIsInZhbGlkYXRlQXJpdHkiLCJwaXBlY2FsbCIsIm9sZEFsbG93Qm9vc3QiLCJtYXJrTmFtZSIsInBhaXIiLCJhbmQiLCJvciIsIm5vdCIsImFzYyIsImRlc2MiLCJwYXJhbSIsIm9iamVjdF9leHByIiwidmFsdWUyIiwiZXh0cmFjdFByb3BlcnR5S2V5Iiwib2JqZWN0X3BhaXIiLCJvYmplY3Rfc3BsYXQiLCJvYmplY3Rfc3BsYXRfdGhpcyIsInNxdWFyZV9icmFja2V0IiwicHJvamVjdGlvbiIsImF0dHJfYWNjZXNzIiwiZGVyZWYiLCJ3cmFwIiwiYXJyYXlfcG9zdGZpeCIsImZ1bmN0aW9uTmFtZSIsImFyZ0NvdW50IiwiZnVuY3Rpb25zUmVxdWlyaW5nU2VsZWN0b3JzIiwiaW5jbHVkZXMiLCJHcm9xU3ludGF4RXJyb3IiLCJwYXJzZSIsImlucHV0IiwicHJvY2Vzc29yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/groq-js/dist/1.mjs\n");

/***/ })

};
;